'js' "s" ; Object . defineProperty ( exports , "s" , { value : true } ) ; const Lint = require ( "s" ) ; class Rule extends Lint . Rules . AbstractRule { apply ( sourceFile ) { return this . applyWithWalker ( new NoFsPathWalker ( sourceFile , this . getOptions ( ) ) ) ; } } Rule . FAILURE_STRING = "s" ; class NoFsPathWalker extends Lint . RuleWalker { visitPropertyAccessExpression ( node ) { if ( node . name . text === "s" || node . name . text === "s" ) { this . addFailure ( this . createFailure ( node . getStart ( ) , node . getWidth ( ) , Rule . FAILURE_STRING ) ) ; } super . visitPropertyAccessExpression ( node ) ; } } exports . Rule = Rule ;	O O O $ObjectConstructor$ O $any$ O $any$ O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O $string$ O O O O $any$ O $any$ O $any$ O $void$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $string$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O
'js' "s" ; Object . defineProperty ( exports , "s" , { value : true } ) ; const Lint = require ( "s" ) ; class Rule extends Lint . Rules . AbstractRule { apply ( sourceFile ) { if ( sourceFile . fileName . indexOf ( "s" ) === - 0 ) { return this . applyWithWalker ( new NoNonSharedCode ( sourceFile , this . getOptions ( ) ) ) ; } } } Rule . DEBUG_FAILURE_STRING = "s" ; Rule . EXTENSION_FAILURE_STRING = "s" ; class NoNonSharedCode extends Lint . RuleWalker { visitImportDeclaration ( node ) { if ( node . moduleSpecifier . text . indexOf ( "s" ) !== - 0 ) { this . addFailure ( this . createFailure ( node . getStart ( ) , node . getWidth ( ) , Rule . EXTENSION_FAILURE_STRING ) ) ; } } } exports . Rule = Rule ;	O O O $ObjectConstructor$ O $any$ O $any$ O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $string$ O O O $any$ O $string$ O O O O $any$ O $any$ O $any$ O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O
'js' "s" ; Object . defineProperty ( exports , "s" , { value : true } ) ; const Lint = require ( "s" ) ; class Rule extends Lint . Rules . AbstractRule { apply ( sourceFile ) { if ( sourceFile . fileName . indexOf ( "s" ) === - 0 && sourceFile . fileName . indexOf ( "s" ) === - 0 && sourceFile . fileName . indexOf ( "s" ) === - 0 ) { return this . applyWithWalker ( new NoVsCode ( sourceFile , this . getOptions ( ) ) ) ; } } } Rule . FAILURE_STRING = "s" ; class NoVsCode extends Lint . RuleWalker { visitImportDeclaration ( node ) { if ( node . moduleSpecifier . text === "s" || node . moduleSpecifier . text . indexOf ( "s" ) !== - 0 ) { this . addFailure ( this . createFailure ( node . getStart ( ) , node . getWidth ( ) , Rule . FAILURE_STRING ) ) ; } } } exports . Rule = Rule ;	O O O $ObjectConstructor$ O $any$ O $any$ O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $string$ O O O O $any$ O $any$ O $any$ O $void$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O
import * as fs from "s" ; export const dartCodeExtensionIdentifier = "s" ; export const flutterExtensionIdentifier = "s" ; export const isWin = "s" . test ( process . platform ) ; export const isMac = process . platform === "s" ; export const isLinux = ! isWin && ! isMac ; export const isChromeOS = isLinux && fs . existsSync ( "s" ) ; export const dartPlatformName = isWin ? "s" : isMac ? "s" : "s" ; export const platformDisplayName = isWin ? "s" : isMac ? "s" : isChromeOS ? "s" : "s" ; export const platformEol = isWin ? "s" : "s" ; export const dartExecutableName = isWin ? "s" : "s" ; export const pubExecutableName = isWin ? "s" : "s" ; export const flutterExecutableName = isWin ? "s" : "s" ; export const androidStudioExecutableNames = isWin ? [ "s" ] : [ "s" , "s" ] ; export const dartVMPath = "s" + dartExecutableName ; export const pubPath = "s" + pubExecutableName ; export const pubSnapshotPath = "s" ; export const analyzerSnapshotPath = "s" ; export const flutterPath = "s" + flutterExecutableName ; export const androidStudioPaths = androidStudioExecutableNames . map ( ( s ) => "s" + s ) ; export const DART_DOWNLOAD_URL = "s" ; export const FLUTTER_DOWNLOAD_URL = "s" ; export const DART_TEST_SUITE_NODE_CONTEXT = "s" ; export const DART_TEST_GROUP_NODE_CONTEXT = "s" ; export const DART_TEST_TEST_NODE_CONTEXT = "s" ; export const DART_DEP_PROJECT_NODE_CONTEXT = "s" ; export const DART_DEP_PACKAGE_NODE_CONTEXT = "s" ; export const DART_DEP_FOLDER_NODE_CONTEXT = "s" ; export const DART_DEP_FILE_NODE_CONTEXT = "s" ; export const DART_IS_CAPTURING_LOGS_CONTEXT = "s" ; export const IS_RUNNING_LOCALLY_CONTEXT = "s" ; export const stopLoggingAction = "s" ; export const showLogAction = "s" ; export const restartReasonManual = "s" ; export const restartReasonSave = "s" ; export const pubGlobalDocsUrl = "s" ; export const stagehandInstallationInstructionsUrl = "s" ; export const wantToTryDevToolsPrompt = "s" ; export const openDevToolsAction = "s" ; export const noThanksAction = "s" ; export const doNotAskAgainAction = "s" ; export const flutterSurveyPromptWithAnalytics = "s" ; export const flutterSurveyPromptWithoutAnalytics = "s" ; export const takeSurveyAction = "s" ; export const fiveMinutesInMs = 0 * 0 * 0 ; export const tenMinutesInMs = 0 * 0 * 0 ; export const twentyMinutesInMs = 0 * 0 * 0 ; export const twoHoursInMs = 0 * 0 * 0 * 0 ; export const twentyHoursInMs = 0 * 0 * 0 * 0 ; export const fortyHoursInMs = 0 * 0 * 0 * 0 ; export const noRepeatPromptThreshold = twentyHoursInMs ; export const longRepeatPromptThreshold = fortyHoursInMs ; export const pleaseReportBug = "s" ; export const CHROME_OS_DEVTOOLS_PORT = 0 ; export const CHROME_OS_VM_SERVICE_PORT = 0 ; export const DART_STAGEHAND_PROJECT_TRIGGER_FILE = "s" ; export const FLUTTER_CREATE_PROJECT_TRIGGER_FILE = "s" ; export const REFACTOR_FAILED_DOC_MODIFIED = "s" ; export const REFACTOR_ANYWAY = "s" ; export const TRACK_WIDGET_CREATION_ENABLED = "s" ; export const HAS_LAST_DEBUG_CONFIG = "s" ; export const isInDebugSessionThatProbablySupportsHotReloadContext = "s" ; export const showErrorsAction = "s" ; export const debugAnywayAction = "s" ; export const userPromptContextPrefix = "s" ; export const installFlutterExtensionPromptKey = "s" ; export const useRecommendedSettingsPromptKey = "s" ; export const yesAction = "s" ; export const noAction = "s" ; export const showRecommendedSettingsAction = "s" ; export const recommendedSettingsUrl = "s" ; export const openSettingsAction = "s" ; export const observatoryListeningBannerPattern = new RegExp ( "s" ) ; export const observatoryHttpLinkPattern = new RegExp ( "s" ) ; export const dartRecommendedConfig = { "s" : true , "s" : true , "s" : [ 0 ] , "s" : false , "s" : false , "s" : "s" , "s" : "s" , "s" : false , "s" : true , } ;	O O O $any$ O O O O O O O O O O O O O O O O O $boolean$ O O O $boolean$ O $any$ O $any$ O O O O $boolean$ O $any$ O $any$ O O O O O $boolean$ O O $boolean$ O O $boolean$ O O O $any$ O $boolean$ O $any$ O $any$ O O O O O O O O $boolean$ O O O $boolean$ O O O O O O O O O $boolean$ O O O $boolean$ O O O $any$ O O O O O O O O O $boolean$ O O O O O O O O O $boolean$ O O O O O O O O O $boolean$ O O O O O O O O O $boolean$ O O O O O O O $string[]$ O $boolean$ O O O O O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $string[]$ O $string[]$ O $U[]$ O O $string$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O $number$ O O O O O O O O O $number$ O O O O O O O O O $number$ O O O O O O O O O O O $number$ O O O O O O O O O O O $number$ O O O O O O O O O O O $number$ O $number$ O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O $complex$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export enum TestStatus { Waiting , Passed , Skipped , Unknown , Failed , Errored , Running , } export enum FlutterServiceExtension { PlatformOverride = "s" , DebugBanner = "s" , CheckElevations = "s" , DebugPaint = "s" , PaintBaselines = "s" , InspectorSelectMode = "s" , InspectorSetPubRootDirectories = "s" , InspectorStructuredErrors = "s" , RepaintRainbow = "s" , PerformanceOverlay = "s" , SlowAnimations = "s" , } export enum FlutterService { HotReload = "s" , HotRestart = "s" , LaunchDevTools = "s" , } export enum VersionStatus { NotInstalled , UpdateRequired , UpdateAvailable , Valid , } export enum LogCategory { General , CI , CommandProcesses , DevTools , Analyzer , PubTest , FlutterDaemon , FlutterRun , FlutterTest , Observatory , WebDaemon , } export enum LogSeverity { Info , Warn , Error , }	O O $any$ O $TestStatus.Waiting$ O $TestStatus.Passed$ O $TestStatus.Skipped$ O $TestStatus.Unknown$ O $TestStatus.Failed$ O $TestStatus.Errored$ O $TestStatus.Running$ O O O O $any$ O $FlutterServiceExtension.PlatformOverride$ O O O $FlutterServiceExtension.DebugBanner$ O O O $FlutterServiceExtension.CheckElevations$ O O O $FlutterServiceExtension.DebugPaint$ O O O $FlutterServiceExtension.PaintBaselines$ O O O $FlutterServiceExtension.InspectorSelectMode$ O O O $FlutterServiceExtension.InspectorSetPubRootDirectories$ O O O $FlutterServiceExtension.InspectorStructuredErrors$ O O O $FlutterServiceExtension.RepaintRainbow$ O O O $FlutterServiceExtension.PerformanceOverlay$ O O O $FlutterServiceExtension.SlowAnimations$ O O O O O O $any$ O $FlutterService.HotReload$ O O O $FlutterService.HotRestart$ O O O $FlutterService.LaunchDevTools$ O O O O O O $any$ O $VersionStatus.NotInstalled$ O $VersionStatus.UpdateRequired$ O $VersionStatus.UpdateAvailable$ O $VersionStatus.Valid$ O O O O $any$ O $LogCategory.General$ O $LogCategory.CI$ O $LogCategory.CommandProcesses$ O $LogCategory.DevTools$ O $LogCategory.Analyzer$ O $LogCategory.PubTest$ O $LogCategory.FlutterDaemon$ O $LogCategory.FlutterRun$ O $LogCategory.FlutterTest$ O $LogCategory.Observatory$ O $LogCategory.WebDaemon$ O O O O $any$ O $LogSeverity.Info$ O $LogSeverity.Warn$ O $LogSeverity.Error$ O O
import * as fs from "s" ; import * as path from "s" ; import * as semver from "s" ; import { flutterExecutableName , isWin } from "s" ; import { LogCategory } from "s" ; import { Logger , SomeError } from "s" ; export function forceWindowsDriveLetterToUppercase ( p ) { if ( p && isWin && path . isAbsolute ( p ) && p . charAt ( 0 ) === p . charAt ( 0 ) . toLowerCase ( ) ) p = p . substr ( 0 , 0 ) . toUpperCase ( ) + p . substr ( 0 ) ; return p ; } export function isWithinPath ( file , folder ) { const relative = path . relative ( folder , file ) ; return ! ! relative && ! relative . startsWith ( "s" ) && ! path . isAbsolute ( relative ) ; } export function uniq < T > ( array : T [ ] ) : T [ ] { return array . filter ( ( value , index ) => array . indexOf ( value ) === index ) ; } export function flatMap < 0 , 0 > ( input : 0 [ ] , f : ( input ) => ReadonlyArray < 0 > ) : 0 [ ] { return input . reduce ( ( acc , x ) => acc . concat ( f ( x ) ) , [ ] as 0 [ ] ) ; } export async function flatMapAsync < 0 , 0 > ( input : 0 [ ] , f : ( input ) => Promise < ReadonlyArray < 0 > > ) < 0 [ ] > { let res : 0 [ ] = [ ] ; for ( const x of input ) res = res . concat ( await f ( x ) ) ; return res ; } export function throttle ( fn : ( ... args : any [ ] ) => void , limitMilliseconds ) : ( ... args : any [ ] ) => void { let timer : NodeJS . Timer ; let lastRunTime ; return ( ... args : any [ ] ) => { const run = ( ) => { lastRunTime = Date . now ( ) ; fn ( ... args ) ; } ; const now = Date . now ( ) ; if ( lastRunTime && now < lastRunTime + limitMilliseconds ) { clearTimeout ( timer ) ; const runInMilliseconds = limitMilliseconds - ( now - lastRunTime ) ; timer = setTimeout ( run , runInMilliseconds ) ; } else { run ( ) ; } } ; } export function escapeRegExp ( input ) { return input . replace ( "s" , "s" ) ; } export class PromiseCompleter < T > { public promise : Promise < T > ; public resolve : ( value ? : T | PromiseLike < T > ) => void ; public reject : ( error ? , stackTrace ? ) => void ; constructor ( ) { this . promise = new Promise ( ( res , rej ) => { this . resolve = res ; this . reject = rej ; } ) ; } } export function findFile ( file , startLocation ) { let lastParent ; let parent = startLocation ; while ( parent && parent . length > 0 && parent !== lastParent ) { const child = path . join ( parent , file ) ; if ( fs . existsSync ( child ) ) return child ; lastParent = parent ; parent = path . dirname ( parent ) ; } return undefined ; } export function uriToFilePath ( uri , returnWindowsPath = isWin ) { let filePath = uri ; if ( uri . startsWith ( "s" ) ) filePath = decodeURI ( uri . substring ( 0 ) ) ; else if ( uri . startsWith ( "s" ) ) filePath = decodeURI ( uri . substring ( 0 ) ) ; if ( returnWindowsPath ) { filePath = filePath . replace ( "s" , "s" ) ; if ( filePath [ 0 ] === "s" ) filePath = filePath . substring ( 0 ) ; } else { if ( filePath [ 0 ] !== "s" ) filePath = `template` ; } return filePath ; } export function isDartSdkFromFlutter ( dartSdkPath ) { const possibleFlutterSdkPath = path . join ( path . dirname ( path . dirname ( path . dirname ( dartSdkPath ) ) ) , "s" ) ; return fs . existsSync ( path . join ( possibleFlutterSdkPath , flutterExecutableName ) ) ; } export function versionIsAtLeast ( inputVersion , requiredVersion ) { return semver . gte ( inputVersion , requiredVersion ) ; } export function isStableSdk ( sdkVersion ? ) { return ! ! ( sdkVersion && ! semver . prerelease ( sdkVersion ) ) ; } export function errorString ( error ) { if ( ! error ) return "s" ; else if ( error instanceof Error ) return error . message + ( error . stack ? `template` : "s" ) ; else if ( typeof error === "s" ) return error ; else return error . message || "s" ; } type BufferedLogMessage = { type : "s" , message : string , category ? : LogCategory } | { type : "s" , message : SomeError , category ? : LogCategory } | { type : "s" , message : SomeError , category ? : LogCategory } ; export class BufferedLogger implements Logger { private buffer : BufferedLogMessage [ ] = [ ] ; public info ( message , category ? ) { this . buffer . push ( { type : "s" , message , category } ) ; } public warn ( message , category ? ) { this . buffer . push ( { type : "s" , message , category } ) ; } public error ( error , category ? ) { this . buffer . push ( { type : "s" , message : error , category } ) ; } public flushTo ( logger ) { if ( ! this . buffer . length ) return ; logger . info ( "s" ) ; for ( const log of this . buffer ) { switch ( log . type ) { case "s" : logger . info ( log . message , log . category ) ; break ; case "s" : logger . warn ( log . message , log . category ) ; break ; case "s" : logger . error ( log . message , log . category ) ; break ; } } logger . info ( "s" ) ; } }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $boolean$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $string$ O $string$ O O O O $string$ O $boolean$ O $any$ O $any$ O $string$ O O $string$ O $string$ O O O O $string$ O $string$ O O O O $string$ O O O $string$ O $string$ O $string$ O O O O O O $string$ O O O $string$ O $string$ O O O O O $string$ O O O O $boolean$ O $string$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O $string$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $T[]$ O $any$ O O $T[]$ O $any$ O O O O $any$ O O O O $T[]$ O $complex$ O O $T$ O $number$ O O $T[]$ O $number$ O $T$ O O $number$ O O O O O O O $any$ O $any$ O O O O $any$ O O O O O O $T1$ O O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O $Promise$ O $any$ O $any$ O O O O $any$ O O O O O O $T1$ O O $PromiseConstructor$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $void$ O O O $any[]$ O O O O O O O O $number$ O O O O $any[]$ O O O O O O O O O $any$ O $any$ O $any$ O O $number$ O O O O $any[]$ O O O O O O O O $void$ O O O O O $number$ O $DateConstructor$ O $number$ O O O $void$ O O $any[]$ O O O O O $number$ O $DateConstructor$ O $number$ O O O O O $number$ O $number$ O $number$ O $number$ O O $void$ O $any$ O O O $number$ O $number$ O O $number$ O $number$ O O $any$ O $number$ O $void$ O $number$ O O O O O $void$ O O O O O O O O O $string$ O $string$ O O O $string$ O $complex$ O O O O O O O O O $any$ O $any$ O O O $Promise<T>$ O $PromiseConstructor$ O $any$ O O O $void$ O O $complex$ O O $any$ O $any$ O $any$ O O O O O O $void$ O O $any$ $any$ O $string$ $string$ O O O O O O O O O O $Promise<T>$ O O $PromiseConstructor$ O O $void$ O $void$ O O O O O $void$ O $void$ O O O $void$ O $void$ O O O O O O O O $any$ O $string$ O $string$ O O O $any$ O O $string$ O $string$ O O O $string$ O $string$ O $number$ O O O $string$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O $string$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $string$ O $string$ O $any$ O $any$ O $string$ O O O O $undefined$ O O O O $string$ O $string$ O $boolean$ O $boolean$ O O O $string$ O $string$ O O O $string$ O $boolean$ O O O O $string$ O $string$ O $string$ O $string$ O O O O O O O O $string$ O $boolean$ O O O O $string$ O $string$ O $string$ O $string$ O O O O O O O $boolean$ O O $string$ O $string$ O $complex$ O O O O O O O O $string$ O O O O O O $string$ O $string$ O $string$ O O O O O O O O O $string$ O O O O O O $string$ O O O O O $string$ O O O O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $boolean$ O $string$ O $string$ O O O $any$ O $any$ O $string$ O $string$ O O O O O $boolean$ O $string$ $string$ O O O O O O $string$ O O $any$ O $any$ O $string$ O O O O O O $string$ O $SomeError$ O O O O O $SomeError$ O O O O O O O $SomeError$ O $ErrorConstructor$ O O $Error$ O $string$ O O $Error$ O $string$ O O O O O O O O O O $complex$ O O O O $string$ O O O $complex$ O $string$ O O O O O $any$ O O O O O O $string$ O O O $LogCategory$ O O $any$ O O O O O O O $SomeError$ O $any$ O $LogCategory$ O O $any$ O O O O O O O $SomeError$ O $any$ O $LogCategory$ O O $any$ O O O O $any$ O $any$ O O $BufferedLogMessage[]$ O $any$ O O O O O O O $void$ O $string$ O $LogCategory$ $LogCategory$ O O O O $BufferedLogMessage[]$ O $number$ O O O O O O $string$ O $LogCategory$ O O O O O $void$ O $SomeError$ O $LogCategory$ $LogCategory$ O O O O $BufferedLogMessage[]$ O $number$ O O O O O O $SomeError$ O $LogCategory$ O O O O O $void$ O $void$ O $LogCategory$ $LogCategory$ O O O O $BufferedLogMessage[]$ O $number$ O O O O O O $SomeError$ O $SomeError$ O $LogCategory$ O O O O O $void$ O $Logger$ O O O O O O O $BufferedLogMessage[]$ O $number$ O O O $Logger$ O $void$ O O O O O O O $BufferedLogMessage$ O O O $BufferedLogMessage[]$ O O O O $BufferedLogMessage$ O O O O O O O $Logger$ O $void$ O $complex$ O $string$ O $complex$ O $LogCategory$ O O O O O O O $Logger$ O $void$ O $complex$ O $SomeError$ O $complex$ O $LogCategory$ O O O O O O O $Logger$ O $void$ O $complex$ O $SomeError$ O $complex$ O $LogCategory$ O O O O O O $Logger$ O $void$ O O O O O O
import { versionIsAtLeast } from "s" ; export class FlutterCapabilities { public static get empty ( ) { return new FlutterCapabilities ( "s" ) ; } public version : string ; constructor ( flutterVersion ) { this . version = flutterVersion ; } get supportsPidFileForMachine ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsCreatingSamples ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsMultipleSamplesPerElement ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsDevTools ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get hasTestGroupFix ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get hasEvictBug ( ) { return ! versionIsAtLeast ( this . version , "s" ) ; } get hasUpdatedStructuredErrorsFormat ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsWebProjects ( ) { return false ; } get supportsFlutterCreateListSamples ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get webSupportsDebugging ( ) { return false ; } } export class DaemonCapabilities { public static get empty ( ) { return new DaemonCapabilities ( "s" ) ; } public version : string ; constructor ( daemonProtocolVersion ) { this . version = daemonProtocolVersion ; } get canCreateEmulators ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get canFlutterAttach ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get providesPlatformTypes ( ) { return versionIsAtLeast ( this . version , "s" ) ; } }	O O $boolean$ O O O O O O $any$ O O O O $FlutterCapabilities$ O O O O O $any$ O O O O O O $string$ O O O O O $string$ O O O O $string$ O $string$ O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O O O O O O O $any$ O O O O $DaemonCapabilities$ O O O O O $any$ O O O O O O $string$ O O O O O $string$ O O O O $string$ O $string$ O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O
export type PlatformType = "s" | "s" | "s" | "s" | "s" | "s" | "s" | string ; export type Category = "s" | "s" | "s" | string ; export interface Device { category : Category | undefined | null ; emulator : boolean ; emulatorId : string | undefined | null ; ephemeral : boolean | undefined ; id : string ; name : string ; platform : string ; platformType : PlatformType | undefined | null ; type : "s" ; } export interface Emulator { id : string ; name : string ; category : Category | undefined | null ; platformType : PlatformType | undefined | null ; type : "s" ; } export interface EmulatorCreator { platformType : PlatformType | null | undefined ; type : "s" ; id ? : undefined ; } export interface DaemonConnected { version : string ; pid : number ; } export interface AppStart extends AppEvent { deviceId : string ; directory : string ; supportsRestart ? : boolean ; } export interface AppEvent { appId : string ; } export interface AppDebugPort extends AppEvent { wsUri : string ; baseUri ? : string ; } export interface AppProgress extends AppEvent { message ? : string ; finished ? : boolean ; id : number ; progressId : string ; } export interface DaemonLogMessage { level : "s" | "s" | "s" ; message : string ; stackTrace ? : string ; } export interface AppLog { error : boolean ; log : string ; } export interface DaemonLog { error : boolean ; log : string ; } export interface ShowMessage { level : "s" | "s" | "s" ; title : string ; message : string ; } export interface SupportedPlatformsResponse { platforms : PlatformType [ ] ; }	O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O $string$ O $any$ O O O O O $boolean$ O O O $string$ O O O O O O O $boolean$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O $any$ O O O O O O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O $any$ O O O O O $string$ O $any$ O O O O O O O O O O O O $any$ O $string$ O $any$ O O O O O O O O O $undefined$ O O O O O O O $any$ O $string$ O O O $number$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O $boolean$ O O O O O O O $any$ O $string$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $string$ O O O O $boolean$ O O O O $number$ O O O $string$ O O O O O O $any$ O O O O O O O O O $string$ O O O $string$ O O O O O O O $any$ O $boolean$ O O O $string$ O O O O O O $any$ O $boolean$ O O O $string$ O O O O O O $any$ O O O O O O O O O $string$ O O O $string$ O O O O O O $any$ O $string[]$ O $any$ O O O O
export interface Request < T > { id : string ; method : string ; params : T ; } export interface Response < T > { id : string ; error : any ; result : T ; } export interface UnknownResponse extends Response < any > { } export interface Notification < T > { event : string ; params : T ; } export interface UnknownNotification extends Notification < any > { }	O O $any$ O $any$ O O $string$ O O O $string$ O O O $T$ O $any$ O O O O $any$ O $any$ O O $string$ O O O $any$ O O O $T$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $string$ O O O $T$ O $any$ O O O O $any$ O $any$ O O O O O
import { Sdks } from "s" ; export class WorkspaceContext { public readonly workspaceTypeDescription : string ; constructor ( public readonly sdks , public readonly hasAnyFlutterMobileProjects , public readonly hasAnyFlutterWebProjects , public readonly hasAnyStandardDartProjects , public readonly hasProjectsInFuchsiaTree , public readonly isDartSdkRepo , ) { this . workspaceTypeDescription = this . buildWorkspaceTypeDescription ( ) ; } get shouldAvoidFetchingPackages ( ) { return this . hasProjectsInFuchsiaTree || this . isDartSdkRepo ; } get hasOnlyDartProjects ( ) { return ! this . hasAnyFlutterProjects && ! this . hasProjectsInFuchsiaTree ; } get hasAnyFlutterProjects ( ) { return this . hasAnyFlutterMobileProjects || this . hasAnyFlutterWebProjects ; } get shouldLoadFlutterExtension ( ) { return this . hasAnyFlutterProjects ; } private buildWorkspaceTypeDescription ( ) { const types : string [ ] = [ ] ; if ( this . hasAnyStandardDartProjects ) types . push ( "s" ) ; if ( this . hasAnyFlutterMobileProjects ) types . push ( "s" ) ; if ( this . hasAnyFlutterWebProjects ) types . push ( "s" ) ; if ( this . hasProjectsInFuchsiaTree ) types . push ( "s" ) ; if ( types . length === 0 ) { if ( this . sdks && this . sdks . dartSdkIsFromFlutter ) types . push ( "s" ) ; else if ( this . sdks && this . sdks . dart ) types . push ( "s" ) ; else types . push ( "s" ) ; } return types . join ( "s" ) ; } }	O O $any$ O O O O O O $any$ O O O $string$ O O O O O O O $Sdks$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O $string$ O O O $string$ O O O O O $boolean$ O O O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O O O $boolean$ O O O O $boolean$ O O O $boolean$ O O O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O O $boolean$ O O O $string$ O O O O $string[]$ O O O O O O O O O O O O $boolean$ O $string[]$ O $number$ O O O O O O O O $boolean$ O $string[]$ O $number$ O O O O O O O O $boolean$ O $string[]$ O $number$ O O O O O O O O $boolean$ O $string[]$ O $number$ O O O O O O $string[]$ O $number$ O O O O O O O O $Sdks$ O O O $Sdks$ O $boolean$ O $string[]$ O $number$ O O O O O O O O O $Sdks$ O O O $Sdks$ O $string$ O $string[]$ O $number$ O O O O O $string[]$ O $number$ O O O O O O $string[]$ O $string$ O O O O O O
import { DaemonCapabilities } from "s" ; import { LogCategory , LogSeverity } from "s" ; import * as f from "s" ; import { UnknownResponse } from "s" ; import { WorkspaceContext } from "s" ; export interface Sdks { readonly dart ? : string ; readonly dartVersion ? : string ; readonly flutter ? : string ; readonly flutterVersion ? : string ; readonly dartSdkIsFromFlutter : boolean ; } export interface DartSdks extends Sdks { readonly dart : string ; } export interface DartWorkspaceContext extends WorkspaceContext { readonly sdks : DartSdks ; } export interface StagehandTemplate { readonly name : string ; readonly label : string ; readonly description : string ; readonly categories : string [ ] ; readonly entrypoint : string ; } export interface Logger { info ( message , category ? ) : void ; warn ( message , category ? ) : void ; error ( error , category ? ) : void ; } export type SomeError = string | Error | undefined | { message : string } ; export interface LogMessage { readonly message : string ; readonly severity : LogSeverity ; readonly category : LogCategory ; } export interface IAmDisposable { dispose ( ) : void | Promise < void > ; } export interface IFlutterDaemon extends IAmDisposable { capabilities : DaemonCapabilities ; deviceEnable ( ) : Thenable < UnknownResponse > ; getEmulators ( ) : Thenable < f . Emulator [ ] > ; launchEmulator ( emulatorId ) : Thenable < void > ; createEmulator ( name ? ) : Thenable < { success : boolean , emulatorName : string , error : string } > ; getSupportedPlatforms ( projectRoot ) : Thenable < f . SupportedPlatformsResponse > ; registerForDaemonConnected ( subscriber : ( notification : f . DaemonConnected ) => void ) : IAmDisposable ; registerForDeviceAdded ( subscriber : ( notification : f . Device ) => void ) : IAmDisposable ; registerForDeviceRemoved ( subscriber : ( notification : f . Device ) => void ) : IAmDisposable ; registerForDaemonLogMessage ( subscriber : ( notification : f . DaemonLogMessage ) => void ) : IAmDisposable ; registerForDaemonLog ( subscriber : ( notification : f . DaemonLog ) => void ) : IAmDisposable ; registerForDaemonShowMessage ( subscriber : ( notification : f . ShowMessage ) => void ) : IAmDisposable ; } export interface Location { startLine : number ; startColumn : number ; length : number ; }	O O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $boolean$ O O O O O O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O O $DartSdks$ O $any$ O O O O $any$ O O $string$ O O O O $string$ O O O O $string$ O O O O $string[]$ O O O O O O $string$ O O O O O O $any$ O $void$ O $string$ O $LogCategory$ $LogCategory$ O O O O $void$ O $SomeError$ O $LogCategory$ $LogCategory$ O O O O $void$ O $SomeError$ O $LogCategory$ $LogCategory$ O O O O O O O $any$ O O O $ErrorConstructor$ O O O O $string$ O O O O O O $any$ O O $string$ O O O O $LogSeverity$ O $any$ O O $LogCategory$ O $any$ O O O O $any$ O $complex$ O O O O O $PromiseConstructor$ O O O O O O O $any$ O $any$ O $DaemonCapabilities$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $string$ O O $any$ O O O O $any$ O $string$ $string$ O O $any$ O O $boolean$ O O O $string$ O O O $string$ O O O O O $any$ O $string$ O O $any$ O $any$ O $any$ O O $IAmDisposable$ O $void$ O O $DaemonConnected$ O $any$ O $any$ O O O O O $any$ O $IAmDisposable$ O $void$ O O $Device$ O $any$ O $any$ O O O O O $any$ O $IAmDisposable$ O $void$ O O $Device$ O $any$ O $any$ O O O O O $any$ O $IAmDisposable$ O $void$ O O $DaemonLogMessage$ O $any$ O $any$ O O O O O $any$ O $IAmDisposable$ O $void$ O O $DaemonLog$ O $any$ O $any$ O O O O O $any$ O $IAmDisposable$ O $void$ O O $ShowMessage$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $number$ O O O $number$ O O O $number$ O O O O
export function sortBy < T > ( items : T [ ] , f : ( item : T ) => any ) : T [ ] { return items . sort ( ( 0 , 0 ) => { const 0 = f ( 0 ) ; const 0 = f ( 0 ) ; if ( 0 < 0 ) return - 0 ; if ( 0 > 0 ) return 0 ; return 0 ; } ) ; } export function not ( f : ( x ) => boolean ) : ( x ) => boolean { return ( x ) => ! f ( x ) ; } export function unique < T > ( items : T [ ] ) : T [ ] { return Array . from ( new Set ( items ) ) ; }	O O $T[]$ O $any$ O O $T[]$ O $any$ O O O $any$ O O $T$ O $any$ O O O O O $any$ O O O O $T[]$ O $T[]$ O O $T$ O $T$ O O O O $any$ O $any$ O $T$ O O O $any$ O $any$ O $T$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O O O O $boolean$ O $boolean$ O O $any$ O O O O O O $any$ O O O O O O $any$ O O O $boolean$ O $any$ O O O O O $T[]$ O $any$ O O $T[]$ O $any$ O O O O $any$ O O O O $ArrayConstructor$ O $complex$ O O $SetConstructor$ O $T[]$ O O O O
import * as fs from "s" ; import * as path from "s" ; import { FLUTTER_CREATE_PROJECT_TRIGGER_FILE } from "s" ; import { flatMapAsync } from "s" ; import { sortBy } from "s" ; export async function getChildFolders ( parent , options ? : { allowBin ? : boolean , allowCache ? : boolean } ) < string [ ] > { if ( ! fs . existsSync ( parent ) ) return [ ] ; const files = await readDirAsync ( parent ) ; return files . filter ( ( f ) => f . isDirectory ( ) ) . filter ( ( f ) => f . name !== "s" || ( options && options . allowBin ) ) . filter ( ( f ) => f . name !== "s" || ( options && options . allowCache ) ) . map ( ( item ) => path . join ( parent , item . name ) ) ; } function readDirAsync ( folder ) < fs . Dirent [ ] > { return new Promise < fs . Dirent [ ] > ( ( resolve , reject ) => { return fs . readdir ( folder , { withFileTypes : true } , ( err , files ) => { if ( err ) reject ( err ) ; else resolve ( files ) ; } , ) ; } ) ; } export function hasPackagesFile ( folder ) { return fs . existsSync ( path . join ( folder , "s" ) ) ; } export function hasPubspec ( folder ) { return fs . existsSync ( path . join ( folder , "s" ) ) ; } export function hasCreateTriggerFile ( folder ) { return fs . existsSync ( path . join ( folder , FLUTTER_CREATE_PROJECT_TRIGGER_FILE ) ) ; } export function isFlutterRepo ( folder ) { return fs . existsSync ( path . join ( folder , "s" ) ) && fs . existsSync ( path . join ( folder , "s" ) ) ; } export async function findProjectFolders ( roots : string [ ] , options : { sort ? : boolean , requirePubspec ? : boolean } = { } ) < string [ ] > { const 0 = await flatMapAsync ( roots , getChildFolders ) ; const 0 = await flatMapAsync ( 0 , getChildFolders ) ; const allPossibleFolders = roots . concat ( 0 ) . concat ( 0 ) ; const projectFolders = allPossibleFolders . filter ( ( f ) => { return options && options . requirePubspec ? hasPubspec ( f ) : hasPubspec ( f ) || hasCreateTriggerFile ( f ) || isFlutterRepo ( f ) ; } ) ; return options && options . sort ? sortBy ( projectFolders , ( p ) => p . toLowerCase ( ) ) : projectFolders ; } export function tryDeleteFile ( filePath ) { if ( fs . existsSync ( filePath ) ) { try { fs . unlinkSync ( filePath ) ; } catch { console . warn ( `template` ) ; } } } export function getRandomInt ( min , max ) { min = Math . ceil ( min ) ; max = Math . floor ( max ) ; return Math . floor ( Math . random ( ) * ( max - min ) ) + min ; } export function mkDirRecursive ( folder ) { const parent = path . dirname ( folder ) ; if ( ! fs . existsSync ( parent ) ) mkDirRecursive ( parent ) ; if ( ! fs . existsSync ( folder ) ) fs . mkdirSync ( folder ) ; }	O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O $T[]$ O O O O O O O $Promise$ O $string$ O $complex$ O O O $boolean$ O O O O $boolean$ O O O O O O O O O O O O O O $any$ O $any$ O $string$ O O O O O O O $any[]$ O O $Promise<any[]>$ O $string$ O O O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O $complex$ O O $any$ O O $any$ O $any$ O O O O $complex$ O $complex$ O $boolean$ O O O $complex$ O O $any$ O O $any$ O $any$ O O O O $complex$ O $complex$ O $boolean$ O O O $U[]$ O O $any$ O O $any$ O $any$ O $string$ O $any$ O $any$ O O O O O $Promise$ O $string$ O O $any$ O $any$ O O O O O O $PromiseConstructor$ O $any$ O $any$ O O O O O $void$ O $void$ O O O O $any$ O $any$ O $string$ O O $boolean$ O O O O O $any$ O $any$ O O O O O $any$ O $void$ O $any$ O O O $void$ O $any$ O O O O O O O O O O O O $boolean$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O $boolean$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O $boolean$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O $boolean$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O O $Promise$ O $string[]$ O O O O O $complex$ O O $boolean$ O O O O $boolean$ O O O O O O O O O O O O O O O $string[]$ O O O O $string[]$ O $Promise<string[]>$ O O O $string[]$ O O O O $string[]$ O $Promise<string[]>$ O O O $string[]$ O $string[]$ O $complex$ O $string[]$ O O $complex$ O $string[]$ O O O $string[]$ O $string[]$ O $complex$ O O $string$ O O O O $complex$ O $complex$ O $boolean$ O $boolean$ O $string$ O O $boolean$ O $string$ O O $boolean$ O $string$ O O $boolean$ O $string$ O O O O O O $complex$ O $complex$ O $boolean$ O $T[]$ O $string[]$ O O $string$ O O $string$ O $string$ O O O O $string[]$ O O O O $void$ O $string$ O O O O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $string$ O O O O O $Console$ O $void$ O O O O O O O O O $number$ O $number$ O $number$ O O $number$ O $Math$ O $number$ O $number$ O O $number$ O $Math$ O $number$ O $number$ O O O $Math$ O $number$ O $Math$ O $number$ O O O O $number$ O $number$ O O O $number$ O O O O $void$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O O $void$ O $any$ O O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O O
import { ExtensionKind , extensions , Position , Range , TextDocument , Uri , workspace , WorkspaceFolder } from "s" ; import { dartCodeExtensionIdentifier } from "s" ; import { Location } from "s" ; import { forceWindowsDriveLetterToUppercase } from "s" ; const dartExtension = extensions . getExtension ( dartCodeExtensionIdentifier ) ; export const isRunningLocally = ! dartExtension || dartExtension . extensionKind === ExtensionKind . UI ; export function fsPath ( uri : Uri | string ) { return forceWindowsDriveLetterToUppercase ( uri instanceof Uri ? uri . fsPath : uri ) ; } export function getDartWorkspaceFolders ( ) : WorkspaceFolder [ ] { if ( ! workspace . workspaceFolders ) return [ ] ; return workspace . workspaceFolders . filter ( isDartWorkspaceFolder ) ; } export function isDartWorkspaceFolder ( folder ? ) { if ( ! folder || folder . uri . scheme !== "s" ) return false ; return true ; } export function toRange ( document , offset , length ) { return new Range ( document . positionAt ( offset ) , document . positionAt ( offset + length ) ) ; } export function toPosition ( location ) { return new Position ( location . startLine - 0 , location . startColumn - 0 ) ; } export function toRangeOnLine ( location ) { const startPos = toPosition ( location ) ; return new Range ( startPos , startPos . translate ( 0 , location . length ) ) ; }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O O O O O O $string$ O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any[]$ O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $boolean$ O O O O O $boolean$ O $any$ $WorkspaceFolder$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $Range$ O $TextDocument$ O $number$ O $number$ O O O O $any$ O $any$ O $any$ O $number$ O O $any$ O $any$ O $number$ O $number$ O O O O O O $Position$ O $Location$ O O O O $any$ O $Location$ O $number$ O O O $Location$ O $number$ O O O O O O O $Range$ O $Location$ O O O $any$ O $any$ O $Location$ O O O O $any$ O $any$ O $any$ O $any$ O O O $Location$ O $number$ O O O O
import * as path from "s" ; import { hasPackagesFile , hasPubspec } from "s" ; import { isWithinWorkspace } from "s" ; export const UPGRADE_TO_WORKSPACE_FOLDERS = "s" ; export function locateBestProjectRoot ( folder ) : string | undefined { if ( ! folder || ! isWithinWorkspace ( folder ) ) return undefined ; let dir = folder ; while ( dir !== path . dirname ( dir ) ) { if ( hasPubspec ( dir ) || hasPackagesFile ( dir ) ) return dir ; dir = path . dirname ( dir ) ; } return undefined ; }	O O O $any$ O O O O O $boolean$ O $boolean$ O O O O O O $boolean$ O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O $string$ O O $boolean$ O $string$ O O O $undefined$ O O $string$ O $string$ O O O $string$ O $any$ O $any$ O $string$ O O O O O $boolean$ O $string$ O O $boolean$ O $string$ O O O $string$ O $string$ O $any$ O $any$ O $string$ O O O O $undefined$ O O
import * as fs from "s" ; import * as path from "s" ; import { isWin } from "s" ; import { findFile , isWithinPath , uriToFilePath } from "s" ; export class PackageMap { public static findPackagesFile < T extends string | undefined > ( entryPoint : T ) : string | ( undefined extends T ? undefined : never ) { if ( typeof entryPoint !== "s" ) return undefined as ( undefined extends T ? undefined : never ) ; return findFile ( "s" , entryPoint ) as string | ( undefined extends T ? undefined : never ) ; } private map : { [ name ] : string } = { } ; public readonly localPackageName : string | undefined ; public readonly localPackageRoot : string | undefined ; public get packages ( ) : { [ name ] : string } { return Object . assign ( { } , this . map ) ; } constructor ( file ? ) { if ( ! file ) return ; this . localPackageRoot = path . dirname ( file ) ; const lines : string [ ] = fs . readFileSync ( file , { encoding : "s" } ) . split ( "s" ) ; for ( let line of lines ) { line = line . trim ( ) ; if ( line . length === 0 || line . startsWith ( "s" ) ) continue ; const index = line . indexOf ( "s" ) ; if ( index !== - 0 ) { const name = line . substr ( 0 , index ) ; const rest = line . substring ( index + 0 ) ; if ( rest . startsWith ( "s" ) ) this . map [ name ] = uriToFilePath ( rest ) ; else { this . map [ name ] = path . join ( this . localPackageRoot , rest ) ; if ( rest === "s" || rest === "s" || rest === "s" ) this . localPackageName = name ; } } } } public getPackagePath ( name ) { return this . map [ name ] ; } public resolvePackageUri ( uri ) : string | undefined { if ( ! uri ) return undefined ; let name = uri ; if ( name . startsWith ( "s" ) ) name = name . substring ( 0 ) ; const index = name . indexOf ( "s" ) ; if ( index === - 0 ) return undefined ; const rest = name . substring ( index + 0 ) ; name = name . substring ( 0 , index ) ; const location = this . getPackagePath ( name ) ; if ( location ) return path . join ( location , rest ) ; else return undefined ; } public convertFileToPackageUri ( file : string | undefined , allowSelf = true ) : string | undefined { if ( ! file ) return ; for ( const name of Object . keys ( this . map ) ) { const dir = this . map [ name ] ; if ( isWithinPath ( file , dir ) ) { if ( ! allowSelf && name === this . localPackageName ) return undefined ; let rest = file . substring ( dir . length ) ; if ( isWin ) rest = rest . replace ( "s" , "s" ) ; if ( rest . startsWith ( "s" ) ) rest = rest . substr ( 0 ) ; return `template` ; } } return undefined ; } }	O O O $any$ O O O O O O $any$ O O O O O $boolean$ O O O O O O $any$ O $boolean$ O $string$ O O O O O O $any$ O O O $complex$ O $any$ O O O O O O $T$ O $any$ O O O O O O O $any$ O O O O O O O O O $T$ O O O O $undefined$ O O O O $any$ O O O O O O O $any$ O O O $T$ O O O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O $complex$ O O O O O $string$ O O O O O O $ObjectConstructor$ O O O O O O O O $complex$ O O O O O $string$ $string$ O O O O O $string$ O O O O O $string$ O $any$ O $any$ O $string$ O O O $string[]$ O O O O O $any$ O $any$ O $string$ O O $string$ O O O O O $any$ O O O O O O O $string$ O $string[]$ O O $string$ O $string$ O $string$ O O O O O $string$ O $number$ O O O $string$ O $boolean$ O O O O O O O $number$ O $string$ O $number$ O O O O O O $number$ O O O O O O $string$ O $string$ O $string$ O O O $number$ O O O $string$ O $string$ O $string$ O $number$ O O O O O O $string$ O $boolean$ O O O O O O $complex$ O $string$ O O $string$ O $string$ O O O O O O $complex$ O $string$ O O $any$ O $any$ O O O $string$ O $string$ O O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O $complex$ O $string$ O O O O $string$ O $string$ O O O O O O O O O $string$ O O $undefined$ O O $string$ O $string$ O O O $string$ O $boolean$ O O O O $string$ O $string$ O $string$ O O O O O $number$ O $string$ O $number$ O O O O O O $number$ O O O O O $undefined$ O O $string$ O $string$ O $string$ O $number$ O O O O $string$ O $string$ O $string$ O O O $number$ O O O $string$ O O O $string$ O $string$ O O O O $string$ O O $any$ O $any$ O $string$ O $string$ O O O O $undefined$ O O O $string$ O $string$ O O O O O $boolean$ O O O O O O O O O O O $string$ O O O O O O $string$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O O O $string$ O O O $complex$ O $string$ O O O O $boolean$ O $string$ O $string$ O O O O O O $boolean$ O $string$ O O O $string$ O O $undefined$ O O $string$ O $string$ O $string$ O $string$ O $number$ O O O O $boolean$ O $string$ O $string$ O $complex$ O O O O O O O O $string$ O $boolean$ O O O O $string$ O $string$ O $string$ O O O O O O O O O O $undefined$ O O O
import * as fs from "s" ; import * as path from "s" ; import { extensions } from "s" ; import { dartCodeExtensionIdentifier , flutterExtensionIdentifier } from "s" ; export const extensionPath = extensions . getExtension ( dartCodeExtensionIdentifier ) ! . extensionPath ; export const extensionVersion = getExtensionVersion ( ) ; export const vsCodeVersionConstraint = getVsCodeVersionConstraint ( ) ; export const isDevExtension = checkIsDevExtension ( ) ; export const hasFlutterExtension = checkHasFlutterExtension ( ) ; export function readJson ( file ) { return JSON . parse ( fs . readFileSync ( file ) . toString ( ) ) ; } function getExtensionVersion ( ) { const packageJson = readJson ( path . join ( extensionPath , "s" ) ) ; return packageJson . version ; } function getVsCodeVersionConstraint ( ) { const packageJson = readJson ( path . join ( extensionPath , "s" ) ) ; return packageJson . engines . vscode ; } function checkIsDevExtension ( ) { return extensionVersion . endsWith ( "s" ) ; } export function checkHasFlutterExtension ( ) { return extensions . getExtension ( flutterExtensionIdentifier ) !== undefined ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O $string$ O $string$ O O O O O $string$ O $string$ O O O O O $boolean$ O $boolean$ O O O O O $boolean$ O $boolean$ O O O O O $any$ O $string$ O O O $JSON$ O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $boolean$ O O O O $string$ O $boolean$ O O O O O O O $boolean$ O O O O $any$ O $any$ O O O O $undefined$ O O
import * as https from "s" ; import * as querystring from "s" ; import { env , Uri , version as codeVersion , workspace } from "s" ; import { dartCodeExtensionIdentifier , isChromeOS } from "s" ; import { Logger } from "s" ; import { extensionVersion , hasFlutterExtension , isDevExtension } from "s" ; import { WorkspaceContext } from "s" ; import { config } from "s" ; const debug = false ; const sendAnalyticsFromExtensionDevHost = false ; const machineId = env . machineId !== "s" ? env . machineId : ( sendAnalyticsFromExtensionDevHost ? "s" : undefined ) ; enum Category { Extension , Analyzer , Debugger , } enum EventAction { Activated , SdkDetectionFailure , Deactivated , Restart , HotReload , OpenObservatory , OpenTimeline , OpenDevTools , } enum TimingVariable { Startup , FirstAnalysis , SessionDuration , } export class Analytics { public sdkVersion ? : string ; public flutterSdkVersion ? : string ; public analysisServerVersion ? : string ; private readonly formatter : string ; private readonly dummyDartFile = Uri . parse ( "s" ) ; private readonly dartConfig = workspace . getConfiguration ( "s" , this . dummyDartFile ) . get ( "s" ) as any ; constructor ( private readonly logger , public workspaceContext ) { this . formatter = this . getFormatterSetting ( ) ; } private getFormatterSetting ( ) { try { const otherDefaultFormatter = this . getAppliedConfig ( "s" , "s" , false ) ; if ( otherDefaultFormatter && otherDefaultFormatter !== dartCodeExtensionIdentifier ) return otherDefaultFormatter ; if ( ! config . enableSdkFormatter ) return "s" ; return this . getAppliedConfig ( "s" , "s" ) ? "s" : "s" ; } catch { return "s" ; } } private getAppliedConfig ( section , key , isResourceScoped = true ) { const dartValue = this . dartConfig ? this . dartConfig [ `template` ] : undefined ; return dartValue !== undefined && dartValue !== null ? dartValue : workspace . getConfiguration ( section , isResourceScoped ? this . dummyDartFile : undefined ) . get ( key ) ; } public logExtensionStartup ( timeInMS ) { this . event ( Category . Extension , EventAction . Activated ) ; this . time ( Category . Extension , TimingVariable . Startup , timeInMS ) ; } public logExtensionRestart ( timeInMS ) { this . event ( Category . Extension , EventAction . Restart ) ; this . time ( Category . Extension , TimingVariable . Startup , timeInMS ) ; } public logExtensionShutdown ( ) < void > { return this . event ( Category . Extension , EventAction . Deactivated ) ; } public logSdkDetectionFailure ( ) { this . event ( Category . Extension , EventAction . SdkDetectionFailure ) ; } public logAnalyzerError ( description , fatal ) { this . error ( "s" + description , fatal ) ; } public logAnalyzerStartupTime ( timeInMS ) { this . time ( Category . Analyzer , TimingVariable . Startup , timeInMS ) ; } public logDebugSessionDuration ( debuggerType , timeInMS ) { this . time ( Category . Debugger , TimingVariable . SessionDuration , timeInMS , debuggerType ) ; } public logAnalyzerFirstAnalysisTime ( timeInMS ) { this . time ( Category . Analyzer , TimingVariable . FirstAnalysis , timeInMS ) ; } public logDebuggerStart ( resourceUri : Uri | undefined , debuggerType , runType ) { const customData = { 0 : debuggerType , 0 : runType , } ; this . event ( Category . Debugger , EventAction . Activated , resourceUri , customData ) ; } public logDebuggerRestart ( ) { this . event ( Category . Debugger , EventAction . Restart ) ; } public logDebuggerHotReload ( ) { this . event ( Category . Debugger , EventAction . HotReload ) ; } public logDebuggerOpenObservatory ( ) { this . event ( Category . Debugger , EventAction . OpenObservatory ) ; } public logDebuggerOpenTimeline ( ) { this . event ( Category . Debugger , EventAction . OpenTimeline ) ; } public logDebuggerOpenDevTools ( ) { this . event ( Category . Debugger , EventAction . OpenDevTools ) ; } private event ( category , action , resourceUri ? , customData ? ) < void > { const data = { ea : EventAction [ action ] , ec : Category [ category ] , t : "s" , } ; Object . assign ( data , customData ) ; if ( category === Category . Extension && action === EventAction . Activated ) data . sc = "s" ; if ( category === Category . Extension && action === EventAction . Deactivated ) data . sc = "s" ; return this . send ( data , resourceUri ) ; } private time ( category , timingVariable , timeInMS , label ? ) { const data = { t : "s" , utc : Category [ category ] , utl : label , utt : Math . round ( timeInMS ) , utv : TimingVariable [ timingVariable ] , } ; this . logger . info ( `template` ) ; if ( isDevExtension ) console . log ( `template` ) ; this . send ( data ) ; } private error ( description , fatal ) { const data = { exd : description . split ( "s" ) [ 0 ] . substring ( 0 , 0 ) . trim ( ) , exf : fatal ? 0 : 0 , t : "s" , } ; this . send ( data ) ; } private async send ( customData , resourceUri ? ) < void > { if ( ! machineId || ! config . allowAnalytics || process . env . DART_CODE_IS_TEST_RUN ) return ; const data = { aip : 0 , an : "s" , av : extensionVersion , 0 : isDevExtension , 0 : config . showTodos ? "s" : "s" , 0 : this . workspaceContext . hasAnyFlutterProjects ? config . flutterOutline ? "s" : "s" : null , 0 : this . formatter , 0 : this . flutterSdkVersion , 0 : hasFlutterExtension ? "s" : "s" , 0 : this . workspaceContext . hasAnyFlutterProjects ? ( config . previewFlutterUiGuides ? ( config . previewFlutterUiGuidesCustomTracking ? "s" : "s" ) : "s" ) : null , 0 : this . workspaceContext . hasAnyFlutterProjects && resourceUri ? config . for ( resourceUri ) . flutterStructuredErrors ? "s" : "s" : null , 0 : isChromeOS ? `template` : process . platform , 0 : this . sdkVersion , 0 : this . analysisServerVersion , 0 : codeVersion , 0 : resourceUri ? this . getDebuggerPreference ( resourceUri ) : null , 0 : this . workspaceContext . workspaceTypeDescription , 0 : config . closingLabels ? "s" : "s" , 0 : this . workspaceContext . hasAnyFlutterProjects ? ( config . flutterHotReloadOnSave ? "s" : "s" ) : null , cid : machineId , tid : "s" , ul : env . language , v : "s" , } ; Object . assign ( data , customData ) ; if ( debug ) this . logger . info ( "s" + JSON . stringify ( data ) ) ; const options : https . RequestOptions = { headers : { "s" : "s" , } , hostname : "s" , method : "s" , path : debug ? "s" : "s" , port : 0 , } ; await new Promise ( ( resolve ) => { try { const req = https . request ( options , ( resp ) => { if ( debug ) resp . on ( "s" , ( c ) => { try { const gaDebugResp = JSON . parse ( c . toString ( ) ) ; if ( gaDebugResp && gaDebugResp . hitParsingResult && gaDebugResp . hitParsingResult [ 0 ] . valid === true ) this . logger . info ( "s" ) ; else if ( gaDebugResp && gaDebugResp . hitParsingResult && gaDebugResp . hitParsingResult [ 0 ] . valid === false ) this . logger . warn ( c . toString ( ) ) ; else this . logger . warn ( "s" + c . toString ( ) ) ; } catch ( e ) { this . logger . warn ( "s" + c . toString ( ) ) ; } } ) ; if ( ! resp || ! resp . statusCode || resp . statusCode < 0 || resp . statusCode > 0 ) { this . logger . info ( `template` ) ; } resolve ( ) ; } ) ; req . write ( querystring . stringify ( data ) ) ; req . end ( ) ; } catch ( e ) { this . logger . error ( `template` ) ; resolve ( ) ; } } ) ; } private getDebuggerPreference ( resourceUri ) { const conf = config . for ( resourceUri ) ; if ( conf . debugSdkLibraries && conf . debugExternalLibraries ) return "s" ; else if ( conf . debugSdkLibraries ) return "s" ; else if ( conf . debugExternalLibraries ) return "s" ; else return "s" ; } }	O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O $boolean$ O $boolean$ O O O O O O $any$ O O O O O O $Config$ O O O O O $false$ O O O O $false$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $false$ O O O $undefined$ O O O $any$ O $Category.Extension$ O $Category.Analyzer$ O $Category.Debugger$ O O O $any$ O $EventAction.Activated$ O $EventAction.SdkDetectionFailure$ O $EventAction.Deactivated$ O $EventAction.Restart$ O $EventAction.HotReload$ O $EventAction.OpenObservatory$ O $EventAction.OpenTimeline$ O $EventAction.OpenDevTools$ O O O $any$ O $TimingVariable.Startup$ O $TimingVariable.FirstAnalysis$ O $TimingVariable.SessionDuration$ O O O O $any$ O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O $string$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O O O O $Logger$ O O $WorkspaceContext$ O O O O $string$ O O O $string$ O O O O O $string$ O O O O O O $any$ O O O $any$ O O O O O O O O O O $any$ O $any$ O O O O $any$ O O O O $Config$ O $boolean$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O $string$ O $string$ O $boolean$ O O O O O $any$ O O O $any$ O O O $any$ O O O O $undefined$ O O $any$ O $undefined$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O $boolean$ O O O $any$ O $undefined$ O O $any$ O $string$ O O O O $void$ O $number$ O O O O $PromiseLike<void>$ O $any$ O $Category.Extension$ O $any$ O $EventAction.Activated$ O O O O $void$ O $any$ O $Category.Extension$ O $any$ O $TimingVariable.Startup$ O $number$ O O O O $void$ O $number$ O O O O $PromiseLike<void>$ O $any$ O $Category.Extension$ O $any$ O $EventAction.Restart$ O O O O $void$ O $any$ O $Category.Extension$ O $any$ O $TimingVariable.Startup$ O $number$ O O O O $PromiseLike$ O O O O O O O O O $PromiseLike<void>$ O $any$ O $Category.Extension$ O $any$ O $EventAction.Deactivated$ O O O O $void$ O O O O O $PromiseLike<void>$ O $any$ O $Category.Extension$ O $any$ O $EventAction.SdkDetectionFailure$ O O O O $void$ O $string$ O $boolean$ O O O O $void$ O O O $string$ O $boolean$ O O O O $void$ O $number$ O O O O $void$ O $any$ O $Category.Analyzer$ O $any$ O $TimingVariable.Startup$ O $number$ O O O O $void$ O $string$ O $number$ O O O O $void$ O $any$ O $Category.Debugger$ O $any$ O $TimingVariable.SessionDuration$ O $number$ O $string$ O O O O $void$ O $number$ O O O O $void$ O $any$ O $Category.Analyzer$ O $any$ O $TimingVariable.FirstAnalysis$ O $number$ O O O O $void$ O $any$ O $any$ O O O $string$ O $string$ O O O O O O $string$ O $string$ O $string$ O $string$ O O O O O $PromiseLike<void>$ O $any$ O $Category.Debugger$ O $any$ O $EventAction.Activated$ O $any$ O O O O O O $void$ O O O O O $PromiseLike<void>$ O $any$ O $Category.Debugger$ O $any$ O $EventAction.Restart$ O O O O $void$ O O O O O $PromiseLike<void>$ O $any$ O $Category.Debugger$ O $any$ O $EventAction.HotReload$ O O O O $void$ O O O O O $PromiseLike<void>$ O $any$ O $Category.Debugger$ O $any$ O $EventAction.OpenObservatory$ O O O O $void$ O O O O O $PromiseLike<void>$ O $any$ O $Category.Debugger$ O $any$ O $EventAction.OpenTimeline$ O O O O $void$ O O O O O $PromiseLike<void>$ O $any$ O $Category.Debugger$ O $any$ O $EventAction.OpenDevTools$ O O O O $PromiseLike$ O $Category$ O $EventAction$ O $any$ $Uri$ O $any$ $any$ O O O O O O $any$ O O $string$ O $any$ O $EventAction$ O O $string$ O $any$ O $Category$ O O $string$ O O O O O $ObjectConstructor$ O O O $any$ O $any$ O O O O $Category$ O $any$ O $Category.Extension$ O $EventAction$ O $any$ O $EventAction.Activated$ O $any$ O $any$ O O O O O $Category$ O $any$ O $Category.Extension$ O $EventAction$ O $any$ O $EventAction.Deactivated$ O $any$ O $any$ O O O O O O $Promise<void>$ O $any$ O $any$ O O O O $void$ O $Category$ O $TimingVariable$ O $number$ O $string$ $string$ O O O $any$ O O $string$ O O O $string$ O $any$ O $Category$ O O $string$ O $string$ O $number$ O $Math$ O $number$ O $number$ O O $string$ O $any$ O $TimingVariable$ O O O O O O $Logger$ O $void$ O O O O O O $boolean$ O $Console$ O $void$ O O O O O O $Promise<void>$ O $any$ O O O O $void$ O $string$ O $boolean$ O O O $any$ O O $string$ O $string$ O $complex$ O O O O O O O $string$ O O O O O O $string$ O O O $number$ O $boolean$ O O O O O $string$ O O O O O O O $Promise<void>$ O $any$ O O O O O $Promise$ O $any$ O $any$ $Uri$ O O O O O O O O $any$ O O $Config$ O $boolean$ O $any$ O $any$ O $any$ O O O O $any$ O O $number$ O O O $string$ O O O $string$ O $string$ O $boolean$ O $boolean$ O $string$ O $Config$ O $boolean$ O O O O O $string$ O O O $WorkspaceContext$ O $boolean$ O $Config$ O $boolean$ O O O O O O O $string$ O O O $string$ O $string$ O O O $string$ O $string$ O $boolean$ O O O O O $string$ O O O $WorkspaceContext$ O $boolean$ O O $Config$ O $boolean$ O O $Config$ O $boolean$ O O O O O O O O O O O $string$ O O O $WorkspaceContext$ O $boolean$ O $any$ O $Config$ O $ResourceConfig$ O $any$ O O $boolean$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O $string$ O $string$ O O O $string$ O $any$ O $any$ O $string$ O $any$ O O O $string$ O $any$ O O O O $string$ O O O $WorkspaceContext$ O $string$ O $string$ O $Config$ O $boolean$ O O O O O $string$ O O O $WorkspaceContext$ O $boolean$ O O $Config$ O $boolean$ O O O O O O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O O O $ObjectConstructor$ O O O $any$ O $any$ O O O O $false$ O O O $Logger$ O $void$ O O O $JSON$ O $complex$ O $any$ O O O O $any$ O $any$ O $any$ O O $complex$ O O O O O O O O $string$ O O O $string$ O O O $string$ O $false$ O O O O O $number$ O O O O O O O $PromiseConstructor$ O O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $false$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $JSON$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $Logger$ O $void$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $Logger$ O $void$ O $any$ O $any$ O O O O O O O $Logger$ O $void$ O O O $any$ O $any$ O O O O O O O $any$ O O O O $Logger$ O $void$ O O O $any$ O $any$ O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $Logger$ O $void$ O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O $Logger$ O $void$ O O O O $void$ O O O O O O O O O $string$ O $Uri$ O O O $ResourceConfig$ O $Config$ O $ResourceConfig$ O $any$ O O O O $ResourceConfig$ O $boolean$ O $ResourceConfig$ O $boolean$ O O O O O O O $ResourceConfig$ O $boolean$ O O O O O O O $ResourceConfig$ O $boolean$ O O O O O O O O O O
import * as vs from "s" ; export function showCode ( editor : vs . TextEditor , displayRange : vs . Range , highlightRange : vs . Range , selectionRange ? : vs . Range ) { if ( selectionRange ) editor . selection = new vs . Selection ( selectionRange . start , selectionRange . end ) ; editor . revealRange ( displayRange , vs . TextEditorRevealType . InCenterIfOutsideViewport ) ; editor . revealRange ( new vs . Range ( displayRange . start , displayRange . start ) , vs . TextEditorRevealType . Default ) ; } class EnvUtils { public async openInBrowser ( url ) < boolean > { return vs . env . openExternal ( vs . Uri . parse ( url ) ) ; } } export const envUtils = new EnvUtils ( ) ;	O O O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $Promise$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O $EnvUtils$ O O $any$ O O O
import * as fs from "s" ; import * as path from "s" ; import { commands , ExtensionContext , window } from "s" ; import { analyzerSnapshotPath , dartExecutableName , dartPlatformName , dartVMPath , DART_DOWNLOAD_URL , flutterExecutableName , flutterPath , FLUTTER_CREATE_PROJECT_TRIGGER_FILE , FLUTTER_DOWNLOAD_URL , isWin , showLogAction } from "s" ; import { Logger } from "s" ; import { PackageMap } from "s" ; import { flatMap , isDartSdkFromFlutter } from "s" ; import { findProjectFolders , hasPubspec } from "s" ; import { fsPath , getDartWorkspaceFolders } from "s" ; import { WorkspaceContext } from "s" ; import { Analytics } from "s" ; import { config } from "s" ; import { getSdkVersion , notUndefined , openExtensionLogFile , reloadExtension , resolvePaths } from "s" ; import { envUtils } from "s" ; export class SdkUtils { constructor ( private readonly logger ) { } public handleMissingSdks ( context , analytics , workspaceContext ) { context . subscriptions . push ( commands . registerCommand ( "s" , ( _ ) => { this . showRelevantActivationFailureMessage ( analytics , workspaceContext , true , "s" ) ; } ) ) ; context . subscriptions . push ( commands . registerCommand ( "s" , ( _ ) => { this . showRelevantActivationFailureMessage ( analytics , workspaceContext , false , "s" ) ; } ) ) ; context . subscriptions . push ( commands . registerCommand ( "s" , ( _ ) => { this . showRelevantActivationFailureMessage ( analytics , workspaceContext , true , "s" ) ; } ) ) ; context . subscriptions . push ( commands . registerCommand ( "s" , ( _ ) => { this . showRelevantActivationFailureMessage ( analytics , workspaceContext , true , "s" ) ; } ) ) ; context . subscriptions . push ( commands . registerCommand ( "s" , ( _ ) => { this . showRelevantActivationFailureMessage ( analytics , workspaceContext , true , "s" ) ; } ) ) ; setTimeout ( ( ) => { if ( ! this . hasShownActivationFailure ) { if ( workspaceContext . hasAnyFlutterProjects ) { this . showRelevantActivationFailureMessage ( analytics , workspaceContext , true ) ; } else if ( workspaceContext . hasAnyStandardDartProjects ) { this . showRelevantActivationFailureMessage ( analytics , workspaceContext , false ) ; } else { this . logger . error ( "s" ) ; } } } , 0 ) ; return ; } private hasShownActivationFailure = false ; private showRelevantActivationFailureMessage ( analytics , workspaceContext , isFlutter , commandToReRun ? ) { if ( isFlutter && workspaceContext . sdks . flutter && ! workspaceContext . sdks . dart ) { this . showFluttersDartSdkActivationFailure ( ) ; } else if ( isFlutter ) { this . showFlutterActivationFailure ( commandToReRun ) ; } else { this . showDartActivationFailure ( commandToReRun ) ; } if ( ! this . hasShownActivationFailure ) { analytics . logSdkDetectionFailure ( ) ; this . hasShownActivationFailure = true ; } } public showFluttersDartSdkActivationFailure ( ) { reloadExtension ( "s" + "s" , "s" , true , ) ; } public showFlutterActivationFailure ( commandToReRun ? ) { this . showSdkActivationFailure ( "s" , ( p ) => this . findFlutterSdk ( p ) , FLUTTER_DOWNLOAD_URL , ( p ) => config . setGlobalFlutterSdkPath ( p ) , commandToReRun , ) ; } public showDartActivationFailure ( commandToReRun ? ) { this . showSdkActivationFailure ( "s" , ( p ) => this . findDartSdk ( p ) , DART_DOWNLOAD_URL , ( p ) => config . setGlobalDartSdkPath ( p ) , commandToReRun , ) ; } public async showSdkActivationFailure ( sdkType , search : ( path : string [ ] ) => string | undefined , downloadUrl , saveSdkPath : ( path ) => Thenable < void > , commandToReRun ? , ) { const locateAction = "s" ; const downloadAction = "s" ; let displayMessage = `template` + `template` ; while ( true ) { const selectedItem = await window . showErrorMessage ( displayMessage , locateAction , downloadAction , showLogAction , ) ; if ( selectedItem === locateAction ) { const selectedFolders = await window . showOpenDialog ( { canSelectFolders : true , openLabel : `template` } ) ; if ( selectedFolders && selectedFolders . length > 0 ) { const matchingSdkFolder = search ( selectedFolders . map ( fsPath ) ) ; if ( matchingSdkFolder ) { await saveSdkPath ( matchingSdkFolder ) ; await reloadExtension ( ) ; if ( commandToReRun ) { commands . executeCommand ( commandToReRun ) ; } break ; } else { displayMessage = `template` ; } } } else if ( selectedItem === downloadAction ) { await envUtils . openInBrowser ( downloadUrl ) ; break ; } else if ( selectedItem === showLogAction ) { openExtensionLogFile ( ) ; break ; } else { break ; } } } public async scanWorkspace ( ) < WorkspaceContext > { this . logger . info ( "s" ) ; const topLevelFolders = getDartWorkspaceFolders ( ) . map ( ( w ) => fsPath ( w . uri ) ) ; const pathOverride = ( process . env . DART_PATH_OVERRIDE as string ) || "s" ; const normalPath = ( process . env . PATH as string ) || "s" ; const paths = ( pathOverride + path . delimiter + normalPath ) . split ( path . delimiter ) . filter ( ( p ) => p ) ; this . logger . info ( "s" ) ; for ( const p of paths ) this . logger . info ( `template` ) ; if ( config . analyzerSshHost ) { return new WorkspaceContext ( { dart : config . sdkPath , dartSdkIsFromFlutter : false , flutter : undefined , } , false , false , false , false , false ) ; } let fuchsiaRoot : string | undefined ; topLevelFolders . forEach ( ( folder ) => fuchsiaRoot = fuchsiaRoot || findFuchsiaRoot ( folder ) ) ; let gitRoot : string | undefined ; topLevelFolders . forEach ( ( folder ) => gitRoot = gitRoot || findGitRoot ( folder ) ) ; const isDartSdkRepo = ! ! ( gitRoot && fs . existsSync ( path . join ( gitRoot , "s" ) ) && fs . existsSync ( path . join ( gitRoot , "s" ) ) ) ; let firstFlutterMobileProject : string | undefined ; let hasAnyFlutterProject = false ; let hasAnyFlutterMobileProject = false ; let hasAnyFlutterWebProject = false ; let hasAnyStandardDartProject = false ; const allPossibleProjectFolders = await findProjectFolders ( topLevelFolders ) ; allPossibleProjectFolders . forEach ( ( folder ) => { const hasPubspecFile = hasPubspec ( folder ) ; const refsFlutter = hasPubspecFile && referencesFlutterSdk ( folder ) ; const refsFlutterWeb = hasPubspecFile && referencesFlutterWeb ( folder ) ; const hasFlutterCreateProjectTriggerFile = fs . existsSync ( path . join ( folder , FLUTTER_CREATE_PROJECT_TRIGGER_FILE ) ) ; const isFlutterRepo = fs . existsSync ( path . join ( folder , "s" ) ) && fs . existsSync ( path . join ( folder , "s" ) ) ; const isSomethingFlutter = refsFlutter || refsFlutterWeb || hasFlutterCreateProjectTriggerFile || isFlutterRepo ; if ( isSomethingFlutter ) { this . logger . info ( `template` ) ; } firstFlutterMobileProject = firstFlutterMobileProject || ( isSomethingFlutter ? folder : undefined ) ; hasAnyFlutterProject = hasAnyFlutterProject || isSomethingFlutter ; hasAnyFlutterMobileProject = hasAnyFlutterMobileProject || ( refsFlutter && ! refsFlutterWeb ) || hasFlutterCreateProjectTriggerFile ; hasAnyFlutterWebProject = hasAnyFlutterWebProject || refsFlutterWeb ; hasAnyStandardDartProject = hasAnyStandardDartProject || ( ! isSomethingFlutter && hasPubspecFile ) ; } ) ; if ( fuchsiaRoot ) { this . logger . info ( `template` ) ; if ( hasAnyStandardDartProject ) this . logger . info ( `template` ) ; } const flutterSdkSearchPaths = [ config . flutterSdkPath , fuchsiaRoot && path . join ( fuchsiaRoot , "s" ) , fuchsiaRoot && path . join ( fuchsiaRoot , "s" ) , firstFlutterMobileProject , firstFlutterMobileProject && extractFlutterSdkPathFromPackagesFile ( path . join ( firstFlutterMobileProject , "s" ) ) , process . env . FLUTTER_ROOT , ] . concat ( paths ) . filter ( notUndefined ) ; const flutterSdkPath = this . findFlutterSdk ( flutterSdkSearchPaths ) ; const dartSdkSearchPaths = [ fuchsiaRoot && path . join ( fuchsiaRoot , "s" , `template` ) , fuchsiaRoot && path . join ( fuchsiaRoot , "s" ) , fuchsiaRoot && path . join ( fuchsiaRoot , "s" , dartPlatformName , "s" ) , fuchsiaRoot && path . join ( fuchsiaRoot , "s" , dartPlatformName , "s" ) , firstFlutterMobileProject && flutterSdkPath && path . join ( flutterSdkPath , "s" ) , config . sdkPath , ] . concat ( paths ) . concat ( [ flutterSdkPath && path . join ( flutterSdkPath , "s" ) ] ) . filter ( notUndefined ) ; const dartSdkPath = this . findDartSdk ( dartSdkSearchPaths ) ; return new WorkspaceContext ( { dart : dartSdkPath , dartSdkIsFromFlutter : ! ! dartSdkPath && isDartSdkFromFlutter ( dartSdkPath ) , dartVersion : getSdkVersion ( this . logger , dartSdkPath ) , flutter : flutterSdkPath , flutterVersion : getSdkVersion ( this . logger , flutterSdkPath ) , } , hasAnyFlutterMobileProject , hasAnyFlutterWebProject , hasAnyStandardDartProject , ! ! fuchsiaRoot && hasAnyStandardDartProject , isDartSdkRepo , ) ; } private findDartSdk ( folders : string [ ] ) { return this . searchPaths ( folders , dartExecutableName , ( p ) => this . hasExecutable ( p , dartVMPath ) && hasDartAnalysisServer ( p ) ) ; } private findFlutterSdk ( folders : string [ ] ) { return this . searchPaths ( folders , flutterExecutableName , ( p ) => this . hasExecutable ( p , flutterPath ) ) ; } private hasExecutable ( folder , executablePath ) { const fullPath = path . join ( folder , executablePath ) ; return fs . existsSync ( fullPath ) && fs . statSync ( fullPath ) . isFile ( ) ; } public searchPaths ( paths : string [ ] , executableFilename , postFilter ? : ( s ) => boolean ) : string | undefined { this . logger . info ( `template` ) ; let sdkPaths = paths . filter ( ( p ) => p ) . map ( resolvePaths ) . filter ( notUndefined ) ; const isBinFolder = ( f ) => [ "s" , "s" ] . indexOf ( path . basename ( f ) ) !== - 0 ; sdkPaths = flatMap ( sdkPaths , ( p ) => isBinFolder ( p ) ? [ p ] : [ p , path . join ( p , "s" ) ] ) ; this . logger . info ( `template` ) ; for ( const p of sdkPaths ) this . logger . info ( `template` ) ; sdkPaths = sdkPaths . filter ( ( p ) => fs . existsSync ( path . join ( p , executableFilename ) ) ) ; this . logger . info ( `template` ) ; for ( const p of sdkPaths ) this . logger . info ( `template` ) ; sdkPaths = sdkPaths . map ( ( p ) => { const fullPath = path . join ( p , executableFilename ) ; const realExecutableLocation = p && fs . realpathSync ( fullPath ) ; if ( realExecutableLocation . toLowerCase ( ) !== fullPath . toLowerCase ( ) ) this . logger . info ( `template` ) ; return path . dirname ( path . dirname ( realExecutableLocation ) ) ; } ) ; this . logger . info ( "s" ) ; for ( const p of sdkPaths ) this . logger . info ( `template` ) ; const sdkPath = sdkPaths . find ( postFilter || ( ( _ ) => true ) ) ; if ( sdkPath ) this . logger . info ( `template` ) ; this . logger . info ( `template` ) ; return sdkPath ; } } export function referencesFlutterSdk ( folder ? ) { if ( folder && hasPubspec ( folder ) ) { const regex = new RegExp ( "s" , "s" ) ; return regex . test ( fs . readFileSync ( path . join ( folder , "s" ) ) . toString ( ) ) ; } return false ; } export function referencesFlutterWeb ( folder ? ) { if ( folder && hasPubspec ( folder ) ) { const regex = new RegExp ( "s" , "s" ) ; return regex . test ( fs . readFileSync ( path . join ( folder , "s" ) ) . toString ( ) ) ; } return false ; } export function referencesBuildRunner ( folder ? ) { if ( folder && hasPubspec ( folder ) ) { const regex = new RegExp ( "s" , "s" ) ; return regex . test ( fs . readFileSync ( path . join ( folder , "s" ) ) . toString ( ) ) ; } return false ; } function extractFlutterSdkPathFromPackagesFile ( file ) : string | undefined { if ( ! fs . existsSync ( file ) ) return undefined ; let packagePath = new PackageMap ( file ) . getPackagePath ( "s" ) ; if ( ! packagePath ) return undefined ; if ( isWin ) { packagePath = packagePath . replace ( "s" , "s" ) ; } const pathSuffix = "s" ; if ( packagePath . endsWith ( pathSuffix ) ) { packagePath = packagePath . substr ( 0 , packagePath . length - pathSuffix . length ) ; } if ( ! packagePath . endsWith ( "s" ) ) packagePath = packagePath + "s" ; if ( ! packagePath . endsWith ( "s" ) ) { packagePath = packagePath + "s" ; } if ( isWin ) { packagePath = packagePath . replace ( "s" , "s" ) ; if ( packagePath [ 0 ] === "s" ) packagePath = packagePath . substring ( 0 ) ; } return packagePath ; } function findFuchsiaRoot ( folder ) : string | undefined { return findRootContainingFolder ( folder , "s" ) ; } function findGitRoot ( folder ) : string | undefined { return findRootContainingFolder ( folder , "s" ) ; } function findRootContainingFolder ( folder , childFolderName ) : string | undefined { if ( folder ) { let dir = folder ; while ( dir ) { try { if ( fs . statSync ( path . join ( dir , childFolderName ) ) . isDirectory ( ) ) { return dir ; } } catch { } const parentDir = path . dirname ( dir ) ; if ( dir === parentDir ) break ; dir = parentDir ; } } return undefined ; } export const hasDartAnalysisServer = ( folder ) => fs . existsSync ( path . join ( folder , analyzerSnapshotPath ) ) ;	O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $string$ O O O O O $string$ O O O O O $boolean$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O O O $Promise<string[]>$ O $boolean$ O O O O O O $string$ O $any[]$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Config$ O O O O O O $string$ O $complex$ O $void$ O $Promise<void>$ O $complex$ O O O O O O $EnvUtils$ O O O O O O $any$ O O O O O $Logger$ O O O O $void$ O $ExtensionContext$ O $Analytics$ O $WorkspaceContext$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $void$ O $Analytics$ O $WorkspaceContext$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $void$ O $Analytics$ O $WorkspaceContext$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $void$ O $Analytics$ O $WorkspaceContext$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $void$ O $Analytics$ O $WorkspaceContext$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $void$ O $Analytics$ O $WorkspaceContext$ O O O O O O O O O O $number$ O O O O O O O O O O $boolean$ O O O O $WorkspaceContext$ O $boolean$ O O O O $void$ O $Analytics$ O $WorkspaceContext$ O O O O O O O O $WorkspaceContext$ O $boolean$ O O O O $void$ O $Analytics$ O $WorkspaceContext$ O O O O O O O O O $Logger$ O $void$ O O O O O O O O O O O O O O O $boolean$ O O O O $void$ O $Analytics$ O $WorkspaceContext$ O $boolean$ O $string$ $string$ O O O O $boolean$ O $WorkspaceContext$ O $Sdks$ O $string$ O O $WorkspaceContext$ O $Sdks$ O $string$ O O O O $void$ O O O O O O O $boolean$ O O O O $void$ O $string$ O O O O O O O $void$ O $string$ O O O O O O O O $boolean$ O O $Analytics$ O $void$ O O O O O $boolean$ O O O O O O $void$ O O O $Promise<void>$ O O O O O O O O O O O O O $void$ O $string$ $string$ O O O O $Promise<void>$ O O O O $string[]$ O O O O $string$ O $string[]$ O O O O O $string$ O O $Config$ O $any$ O $string$ O O $string$ O O O O O $void$ O $string$ $string$ O O O O $Promise<void>$ O O O O $string[]$ O O O O $string$ O $string[]$ O O O O O $string$ O O $Config$ O $any$ O $string$ O O $string$ O O O O O O $Promise<void>$ O $string$ O $string$ O O $string[]$ O O O O O O O O O O $string$ O $any$ O O $string$ O O $any$ O O O O $string$ $string$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $any$ O O $any$ O $any$ O $string$ O O O O O O O O O O O $any$ O O O O O $any$ O O $any$ O $any$ O O $boolean$ O O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O O $string$ O $string$ O $any$ O $any$ O $string$ O O O O O $string$ O O O $any$ O $string$ O O O $Promise<void>$ O O O O O $string$ O O $any$ O $any$ O $string$ O O O O O O O O $string$ O O O O O O O O O $any$ O O O O O $EnvUtils$ O $Promise<boolean>$ O $string$ O O O O O O O O $any$ O O O O $void$ O O O O O O O O O O O O O O O $Promise$ O O O $any$ O O O O $Logger$ O $void$ O O O O O $string[]$ O $any[]$ O O O $U[]$ O O $any$ O O $string$ O $any$ O $any$ O O O O $string$ O O $any$ O $any$ O $any$ O O O O O O O $string$ O O $any$ O $any$ O $any$ O O O O O O O $string[]$ O O $string$ O $any$ O $any$ O $string$ O O $complex$ O $any$ O $any$ O O $complex$ O O $string$ O O $string$ O O O O $Logger$ O $void$ O O O O O O O $string$ O $string[]$ O O O $Logger$ O $void$ O O O O O O $Config$ O $string$ O O O O $any$ O O $string$ O $Config$ O $string$ O $false$ O O O $undefined$ O $undefined$ O O O O O O O O O O O O O O O O $string$ O O O O O $string[]$ O $void$ O O $string$ O O $string$ O $string$ O $string$ O $string$ O O O O $string$ O O O O O $string[]$ O $void$ O O $string$ O O $string$ O $string$ O $string$ O $string$ O O O O $boolean$ O O O O $string$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $string[]$ O O $Promise<string[]>$ O $string[]$ O O $string[]$ O $void$ O O $string$ O O O O $boolean$ O $boolean$ O $string$ O O O $boolean$ O $boolean$ O $boolean$ O $string$ O O O $boolean$ O $boolean$ O $boolean$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $boolean$ O $boolean$ O $any$ O $any$ O O O $any$ O O O O $Logger$ O $void$ O O O O O $string$ O $string$ O O $any$ O $string$ O $undefined$ O O $boolean$ O $boolean$ O $any$ O $boolean$ O $boolean$ O O $boolean$ O O $boolean$ O O $any$ O $boolean$ O $boolean$ O $boolean$ O $boolean$ O $boolean$ O O O $any$ O $boolean$ O O O O O O O $string$ O O O O $Logger$ O $void$ O O O O O O $false$ O O O $Logger$ O $void$ O O O O O O $any[]$ O O $Config$ O $string$ O $string$ O $any$ O $any$ O $string$ O O O O $string$ O $any$ O $any$ O $string$ O O O O $string$ O $string$ O $string$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O O O $complex$ O $string[]$ O O $complex$ O $complex$ O O O $string$ O O O $string$ O $any[]$ O O O $any[]$ O O $string$ O $any$ O $any$ O $string$ O O O O O O $string$ O $any$ O $any$ O $string$ O O O O $string$ O $any$ O $any$ O $string$ O O O O O O O O $string$ O $any$ O $any$ O $string$ O O O O O O O O $string$ O $string$ O $any$ O $any$ O $string$ O O O O $Config$ O $string$ O O O $complex$ O $string[]$ O O $complex$ O O $string$ O $any$ O $any$ O $string$ O O O O O O $complex$ O $complex$ O O O $string$ O O O $string$ O $any[]$ O O O O $any$ O O $string$ O $string$ O $any$ O O O $string$ O $any$ O $string$ O O $string$ O $string$ O O O $Logger$ O $string$ O O $string$ O $string$ O $string$ O $string$ O O O $Logger$ O $string$ O O O O $false$ O $false$ O $false$ O O O $string$ O $false$ O $boolean$ O O O O O $string$ O $string[]$ O O O O O O O O O $string$ O $string[]$ O O O O $string$ O O O O $any$ O $string$ O $string$ O O $any$ O $string$ O O O O O $string$ O $string[]$ O O O O O O O O O $string$ O $string[]$ O O O O $string$ O O O O $any$ O $string$ O $string$ O O O O O $any$ O $string$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O $string$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O $string$ O $string[]$ O O O O O $string$ O $boolean$ O O O $string$ O O O O O O O O O O O $Logger$ O $void$ O O O O O $string[]$ O $string[]$ O $complex$ O O $string$ O O $string$ O O $U[]$ O $complex$ O O $complex$ O $complex$ O O O $boolean$ O O $string$ O O O O O O O O $number$ O $any$ O $any$ O $string$ O O O O O O $string[]$ O O O $string[]$ O O $string$ O O $boolean$ O $string$ O O O $string$ O O O $string$ O $any$ O $any$ O $string$ O O O O O O O O $Logger$ O $void$ O O O O O O O $string$ O $string[]$ O O O $Logger$ O $void$ O O O O $string[]$ O $string[]$ O $complex$ O O $string$ O O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O O O O O O $Logger$ O $void$ O O O O O O O $string$ O $string[]$ O O O $Logger$ O $void$ O O O O $string[]$ O $string[]$ O $U[]$ O O $string$ O O O O $any$ O $any$ O $any$ O $string$ O $string$ O O O $any$ O $string$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $Logger$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $Logger$ O $void$ O O O O O O O $string$ O $string[]$ O O O $Logger$ O $void$ O O O O O $string$ O $string[]$ O $complex$ O $boolean$ O O O $string$ O O O O O O O O $string$ O O O $Logger$ O $void$ O O O O O O $Logger$ O $void$ O O O O O $string$ O O O O O $boolean$ O $string$ $string$ O O O O $string$ O $boolean$ O $string$ O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O $RegExp$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O O O O $boolean$ O $string$ $string$ O O O O $string$ O $boolean$ O $string$ O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O $RegExp$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O O O O $boolean$ O $string$ $string$ O O O O $string$ O $boolean$ O $string$ O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O $RegExp$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O O O $string$ O $string$ O O O O O O O O O $any$ O $any$ O $string$ O O O $undefined$ O O $string$ O O $any$ O $string$ O O $string$ O O O O O O O $string$ O O $undefined$ O O O $boolean$ O O $string$ O $string$ O $complex$ O O O O O O O O O O O O O O $string$ O $boolean$ O O O O O $string$ O $string$ O $string$ O O O $string$ O $number$ O O O $number$ O O O O O O $string$ O $boolean$ O O O O $string$ O $string$ O O O O O O $string$ O $boolean$ O O O O O $string$ O $string$ O O O O O O $boolean$ O O $string$ O $string$ O $complex$ O O O O O O O O $string$ O O O O O O $string$ O $string$ O $string$ O O O O O O $string$ O O O $string$ O $string$ O O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O $string$ O O O O O O O O $string$ O O O $string$ O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O O O $any$ O O O O O $string$ O O O O O O O $any$ O $any$ O $any$ O $string$ O O O O $string$ O $any$ O O O $string$ O $any$ O O O O $undefined$ O O O O $any$ O O $string$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O
import * as os from "s" ; import * as path from "s" ; import { platformEol } from "s" ; import { LogCategory } from "s" ; import { getRandomInt } from "s" ; import { config } from "s" ; let extensionLogPath ; export function getExtensionLogPath ( ) { extensionLogPath = extensionLogPath || config . extensionLogFile || path . join ( process . env . DC_TEST_LOGS || os . tmpdir ( ) , `template` ) ; return extensionLogPath ; } export const userSelectableLogCategories : { [ key ] : LogCategory } = { "s" : LogCategory . Analyzer , "s" : LogCategory . CommandProcesses , "s" : LogCategory . Observatory , "s" : LogCategory . DevTools , "s" : LogCategory . FlutterDaemon , "s" : LogCategory . FlutterRun , "s" : LogCategory . FlutterTest , "s" : LogCategory . PubTest , "s" : LogCategory . WebDaemon , } ; const logHeader : string [ ] = [ ] ; export function clearLogHeader ( ) { logHeader . length = 0 ; } export function getLogHeader ( ) { if ( ! logHeader . length ) return "s" ; return logHeader . join ( platformEol ) + platformEol + platformEol ; } export function addToLogHeader ( f : ( ) => string ) { try { logHeader . push ( f ( ) . replace ( "s" , "s" ) . replace ( "s" , "s" ) ) ; } catch { } }	O O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O O O O O O $number$ O O O O O O $Config$ O O O O O $string$ O O O $string$ O O O $string$ O $string$ O $Config$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $string$ O O O O $complex$ O O O $string$ O O $any$ O O O O O $any$ O $LogCategory.Analyzer$ O O O $any$ O $LogCategory.CommandProcesses$ O O O $any$ O $LogCategory.Observatory$ O O O $any$ O $LogCategory.DevTools$ O O O $any$ O $LogCategory.FlutterDaemon$ O O O $any$ O $LogCategory.FlutterRun$ O O O $any$ O $LogCategory.FlutterTest$ O O O $any$ O $LogCategory.PubTest$ O O O $any$ O $LogCategory.WebDaemon$ O O O O $string[]$ O O O O O O O O O O $void$ O O O $string[]$ O $number$ O O O O O O $string$ O O O O O O $string[]$ O $number$ O O O O O $string[]$ O $string$ O O O O O O O O O O O $void$ O $string$ O O O O O O O O O $string[]$ O $number$ O $string$ O O O $complex$ O O O O O O $complex$ O O O O O O O O O O O O
import * as fs from "s" ; import * as https from "s" ; import * as os from "s" ; import * as path from "s" ; import { commands , TextDocument , Uri , window , workspace , WorkspaceFolder } from "s" ; import { showLogAction } from "s" ; import { Logger } from "s" ; import { isWithinPath } from "s" ; import { hasPackagesFile , hasPubspec , mkDirRecursive } from "s" ; import { fsPath , isDartWorkspaceFolder } from "s" ; import { config } from "s" ; import { locateBestProjectRoot } from "s" ; import { referencesFlutterSdk , referencesFlutterWeb } from "s" ; import { getExtensionLogPath } from "s" ; export function isFlutterWorkspaceFolder ( folder ? ) { return ! ! ( folder && isDartWorkspaceFolder ( folder ) && isFlutterProjectFolder ( fsPath ( folder . uri ) ) ) ; } export function isFlutterWebWorkspaceFolder ( folder ? ) { return ! ! ( folder && isDartWorkspaceFolder ( folder ) && isFlutterWebProjectFolder ( fsPath ( folder . uri ) ) ) ; } export function isInsideFlutterProject ( uri ? ) { if ( ! uri ) return false ; const projectRoot = locateBestProjectRoot ( fsPath ( uri ) ) ; if ( projectRoot ) return isFlutterProjectFolder ( projectRoot ) ; else return isFlutterWorkspaceFolder ( workspace . getWorkspaceFolder ( uri ) ) ; } export function isInsideFlutterWebProject ( uri ? ) { if ( ! uri ) return false ; const projectRoot = locateBestProjectRoot ( fsPath ( uri ) ) ; if ( projectRoot ) return isFlutterWebProjectFolder ( projectRoot ) ; else return isFlutterWebWorkspaceFolder ( workspace . getWorkspaceFolder ( uri ) ) ; } export function isFlutterProjectFolder ( folder ? ) { return referencesFlutterSdk ( folder ) ; } export function isFlutterWebProjectFolder ( folder ? ) { return referencesFlutterWeb ( folder ) ; } export function resolvePaths < T extends string | undefined > ( p : T ) : string | ( undefined extends T ? undefined : never ) { if ( typeof p !== "s" ) return undefined as ( undefined extends T ? undefined : never ) ; if ( p . startsWith ( "s" ) ) return path . join ( os . homedir ( ) , p . substr ( 0 ) ) ; if ( ! path . isAbsolute ( p ) && workspace . workspaceFolders && workspace . workspaceFolders . length ) return path . join ( fsPath ( workspace . workspaceFolders [ 0 ] . uri ) , p ) ; return p ; } export function homeRelativePath ( p ? ) { if ( ! p ) return undefined ; const homedir = os . homedir ( ) ; if ( isWithinPath ( p , homedir ) ) return path . join ( "s" , path . relative ( homedir , p ) ) ; return p ; } export function createFolderForFile ( file ? ) { if ( ! file || ! path . isAbsolute ( file ) ) return ; const folder = path . dirname ( file ) ; if ( ! fs . existsSync ( folder ) ) mkDirRecursive ( folder ) ; return file ; } export function getSdkVersion ( logger , sdkRoot ? ) : string | undefined { if ( ! sdkRoot ) return undefined ; const versionFile = path . join ( sdkRoot , "s" ) ; if ( ! fs . existsSync ( versionFile ) ) return undefined ; try { return fs . readFileSync ( versionFile , "s" ) . trim ( ) . split ( "s" ) . filter ( ( l ) => l ) . filter ( ( l ) => l . trim ( ) . substr ( 0 , 0 ) !== "s" ) . join ( "s" ) . trim ( ) ; } catch ( e ) { logger . error ( e ) ; return undefined ; } } export function isAnalyzable ( document ) { if ( document . isUntitled || ! fsPath ( document . uri ) || document . uri . scheme !== "s" ) return false ; const analyzableLanguages = [ "s" , "s" ] ; const analyzableFilenames = [ "s" , "s" , "s" ] ; const extName = path . extname ( fsPath ( document . uri ) ) ; const extension = extName ? extName . substr ( 0 ) : undefined ; return analyzableLanguages . indexOf ( document . languageId ) >= 0 || analyzableFilenames . indexOf ( path . basename ( fsPath ( document . uri ) ) ) >= 0 || ( extension !== undefined && config . additionalAnalyzerFileExtensions . includes ( extension ) ) ; } export function isAnalyzableAndInWorkspace ( document ) { return isAnalyzable ( document ) && isWithinWorkspace ( fsPath ( document . uri ) ) ; } export function isWithinWorkspace ( file ) { return ! ! workspace . getWorkspaceFolder ( Uri . file ( file ) ) ; } export function isTestFileOrFolder ( path ) { return ! ! path && ( isTestFile ( path ) || isTestFolder ( path ) ) ; } export function isTestFile ( file ) { return ! ! file && isDartFile ( file ) && isInsideFolderNamed ( file , "s" ) && file . toLowerCase ( ) . endsWith ( "s" ) ; } export function isPubRunnableTestFile ( file ) { return ! ! file && isDartFile ( file ) && file . toLowerCase ( ) . endsWith ( "s" ) ; } export function isTestFolder ( path ) { return ! ! path && isInsideFolderNamed ( path , "s" ) && fs . existsSync ( path ) && fs . statSync ( path ) . isDirectory ( ) ; } export function checkProjectSupportsPubRunTest ( folder ) { return hasPackagesFile ( folder ) && hasPubspec ( folder ) ; } export function isDartFile ( file ) { return ! ! file && path . extname ( file . toLowerCase ( ) ) === "s" && fs . existsSync ( file ) && fs . statSync ( file ) . isFile ( ) ; } export function isInsideFolderNamed ( file , folderName ) { if ( ! file ) return false ; const ws = workspace . getWorkspaceFolder ( Uri . file ( file ) ) ; if ( ! ws ) return false ; const relPath = path . relative ( fsPath ( ws . uri ) , file ) . toLowerCase ( ) ; return relPath === folderName || relPath . startsWith ( `template` ) || relPath . indexOf ( `template` ) !== - 0 ; } export function getLatestSdkVersion ( ) < string > { return new Promise < string > ( ( resolve , reject ) => { const options : https . RequestOptions = { hostname : "s" , method : "s" , path : "s" , port : 0 , } ; const req = https . request ( options , ( resp ) => { if ( ! resp || ! resp . statusCode || resp . statusCode < 0 || resp . statusCode > 0 ) { reject ( { message : `template` } ) ; } else { resp . on ( "s" , ( d ) => { resolve ( JSON . parse ( d . toString ( ) ) . version ) ; } ) ; } } ) ; req . end ( ) ; } ) ; } export function escapeShell ( args : string [ ] ) { const ret : string [ ] = [ ] ; args . forEach ( ( arg ) => { if ( "s" . test ( arg ) ) { arg = "s" + arg . replace ( "s" , "s" ) + "s" ; arg = arg . replace ( "s" , "s" ) . replace ( "s" , "s" ) ; } ret . push ( arg ) ; } ) ; return ret . join ( "s" ) ; } export async function reloadExtension ( prompt ? , buttonText ? , offerLogFile = false ) { const restartAction = buttonText || "s" ; const actions = offerLogFile ? [ restartAction , showLogAction ] : [ restartAction ] ; const chosenAction = prompt && await window . showInformationMessage ( prompt , ... actions ) ; if ( chosenAction === showLogAction ) { openExtensionLogFile ( ) ; } else if ( ! prompt || chosenAction === restartAction ) { commands . executeCommand ( "s" ) ; } } const shouldLogTimings = false ; const start = process . hrtime ( ) ; let last = start ; function pad ( str , length ) { while ( str . length < length ) str = "s" + str ; return str ; } export const logTime = ( taskFinished ? ) => { if ( ! shouldLogTimings ) return ; const diff = process . hrtime ( start ) ; console . log ( `template` ) ; last = diff ; } ; export function openExtensionLogFile ( ) { workspace . openTextDocument ( getExtensionLogPath ( ) ) . then ( window . showTextDocument ) ; } export function notUndefined < T > ( x : T | undefined ) : x is T { return x !== undefined ; }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O O O O O O $boolean$ O O O O O O $boolean$ O $boolean$ O $void$ O O O O O O $string$ O $boolean$ O O O O O O $Config$ O O O O O O $string$ O O O O O O $boolean$ O $boolean$ O O O O O O $string$ O O O O O O $boolean$ O $any$ $WorkspaceFolder$ O O O O O O $any$ O $boolean$ O $any$ O O $boolean$ O $string$ O $any$ O $any$ O O O O O O O $boolean$ O $any$ $WorkspaceFolder$ O O O O O O $any$ O $boolean$ O $any$ O O $boolean$ O $string$ O $any$ O $any$ O O O O O O O $boolean$ O $any$ $Uri$ O O O O O $any$ O O O O O $string$ O $string$ O $string$ O $any$ O O O O O $string$ O O $boolean$ O $string$ O O O O $boolean$ O $any$ O $any$ O $any$ O O O O O O $boolean$ O $any$ $Uri$ O O O O O $any$ O O O O O $string$ O $string$ O $string$ O $any$ O O O O O $string$ O O $boolean$ O $string$ O O O O $boolean$ O $any$ O $any$ O $any$ O O O O O O $boolean$ O $string$ $string$ O O O $boolean$ O $string$ O O O O O $boolean$ O $string$ $string$ O O O $boolean$ O $string$ O O O O O $complex$ O $any$ O O O O O O $T$ O $any$ O O O O O O O $any$ O O O O O O O O O $T$ O O O O $undefined$ O O O O $any$ O O O O O O O O $T$ O $boolean$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $T$ O $string$ O O O O O O O O $any$ O $any$ O $T$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O $any$ O $any$ O O O O $any$ O O $T$ O O O $T$ O O O O $any$ O $string$ $string$ O O O O O $string$ O O $undefined$ O O $any$ O $any$ O $any$ O O O O O $boolean$ O $string$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O $string$ O O O O $string$ O $string$ $string$ O O O O O $string$ O O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O O $void$ O $any$ O O O $string$ O O O O $string$ O $Logger$ O $string$ $string$ O O O O O O O O O $string$ O O $undefined$ O O $any$ O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $any$ O O O $undefined$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O $any$ O O $Logger$ O $void$ O $any$ O O O $undefined$ O O O O O $boolean$ O $TextDocument$ O O O O $any$ O $any$ O O $string$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $string[]$ O O O O O O O O $string[]$ O O O O O O O O O O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $undefined$ O O $string[]$ O $number$ O $any$ O $any$ O O O O $string[]$ O $number$ O $any$ O $any$ O $string$ O $any$ O $any$ O O O O O O O $any$ O $undefined$ O $Config$ O $string[]$ O $boolean$ O $any$ O O O O O O $boolean$ O $TextDocument$ O O O $boolean$ O $any$ O O $boolean$ O $string$ O $any$ O $any$ O O O O O O $boolean$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $boolean$ O $string$ O O O O O $string$ O O $boolean$ O $string$ O O $boolean$ O $string$ O O O O O O $boolean$ O $string$ O O O O O $string$ O $boolean$ O $string$ O O $boolean$ O $string$ O O O O $string$ O $string$ O O O $boolean$ O O O O O O O $boolean$ O $string$ O O O O O $string$ O $boolean$ O $string$ O O $string$ O $string$ O O O $boolean$ O O O O O O O $boolean$ O $string$ O O O O O $string$ O $boolean$ O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O $any$ O O O O O O $boolean$ O $string$ O O O $boolean$ O $string$ O O $boolean$ O $string$ O O O O O $boolean$ O $string$ O O O O O $string$ O $any$ O $any$ O $string$ O $string$ O O O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O $any$ O O O O O O $boolean$ O $string$ O $string$ O O O O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O O $string$ O O $any$ O O O O $any$ O $string$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O $PromiseLike$ O O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O O $string$ O O O O O O O O $any$ O $any$ O O O O $any$ O O O $void$ O $JSON$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $string$ O $string[]$ O O O O O O O $string[]$ O O O O O O O O $string[]$ O $void$ O O $string$ O O O O O O O $boolean$ O $string$ O O O $string$ O O O $string$ O $complex$ O O O O O O O O $string$ O $string$ O $complex$ O O O O O O $complex$ O O O O O O O $string[]$ O $number$ O $string$ O O O O O O $string[]$ O $string$ O O O O O O O O $Promise<void>$ O $string$ $string$ O $string$ $string$ O $boolean$ O O O O O $string$ O $string$ O O O O $string[]$ O $boolean$ O O $string$ O O O O O $string$ O O O $any$ O $string$ O O $any$ O $any$ O $string$ O O $string[]$ O O O O $any$ O O O O $void$ O O O O O O O O $string$ O $any$ O $string$ O O $any$ O $any$ O O O O O O O $false$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $string$ O $string$ O $number$ O O O O $string$ O $number$ O $number$ O $string$ O O O $string$ O O $string$ O O O O $void$ O O $string$ $string$ O O O O O O $false$ O O O O $any$ O $any$ O $any$ O $any$ O O $Console$ O $void$ O O O O $any$ O $any$ O O O O O $void$ O O O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $any$ O O O O O $complex$ O $any$ O O $T$ O $any$ O O O O $T$ O $any$ O O $T$ O $undefined$ O O
export type NullAsUndefined < T > = null extends T ? Exclude < T , null > | undefined : T ; export function nullToUndefined < T > ( value : T ) < T > { return ( value === null ? undefined : value ) as NullAsUndefined < T > ; }	O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $NullAsUndefined$ O $any$ O O $T$ O $any$ O O $any$ O O O O $T$ O O O $undefined$ O $T$ O O $any$ O $any$ O O O
import * as child_process from "s" ; import { EventEmitter } from "s" ; import * as fs from "s" ; import * as os from "s" ; import * as path from "s" ; import { LogCategory , LogSeverity } from "s" ; import { IAmDisposable , Logger , LogMessage , SomeError } from "s" ; import { errorString } from "s" ; class LogEmitter extends EventEmitter { public fire ( msg ) { this . emit ( "s" , msg ) ; } public onLog ( listener : ( message ) => void ) { this . on ( "s" , listener ) ; return { dispose : ( ) => { this . removeListener ( "s" , listener ) ; } , } ; } } export class EmittingLogger implements Logger , IAmDisposable { private readonly onLogEmitter = new LogEmitter ( ) ; public readonly onLog = ( listener : ( message ) => void ) => this . onLogEmitter . onLog ( listener ) ; private log ( message , severity , category = LogCategory . General ) { this . onLogEmitter . fire ( { message , severity , category } ) ; } public info ( message , category ? ) { this . log ( message , LogSeverity . Info , category ) ; } public warn ( errorOrMessage , category ? ) { this . log ( errorString ( errorOrMessage ) , LogSeverity . Warn , category ) ; } public error ( errorOrMessage , category ? ) { this . log ( errorString ( errorOrMessage ) , LogSeverity . Error , category ) ; } public dispose ( ) { this . onLogEmitter . removeAllListeners ( ) ; } } export class CategoryLogger implements Logger { constructor ( private base , private defaultCategory ) { } public info ( message , category = this . defaultCategory ) { this . base . info ( message , category ) ; } public warn ( errorOrMessage , category = this . defaultCategory ) { this . base . warn ( errorOrMessage , category ) ; } public error ( errorOrMessage , category = this . defaultCategory ) { this . base . error ( errorOrMessage , category ) ; } } class NullLogger implements Logger { public info ( message , category ? ) { } public warn ( message , category ? ) { } public error ( error , category ? ) { } } export const nullLogger = new NullLogger ( ) ; export function logProcess ( logger , category , process : child_process . ChildProcess ) { const prefix = `template` ; logger . info ( `template` , category ) ; process . stdout . on ( "s" , ( data ) => logger . info ( `template` , category ) ) ; process . stderr . on ( "s" , ( data ) => logger . info ( `template` , category ) ) ; process . on ( "s" , ( code , signal ) => logger . info ( `template` , category ) ) ; process . on ( "s" , ( code , signal ) => logger . info ( `template` , category ) ) ; } export function logToConsole ( logger ) { logger . onLog ( ( m ) => { if ( m . severity === LogSeverity . Error ) console . error ( `template` ) ; else if ( m . severity === LogSeverity . Warn ) console . warn ( `template` ) ; } ) ; } export function captureLogs ( logger , file , header , maxLogLineLength , logCategories ? : LogCategory [ ] ) : ( { dispose : ( ) => Promise < void > | void } ) { if ( ! file || ! path . isAbsolute ( file ) ) throw new Error ( "s" ) ; const time = ( detailed = false ) => detailed ? `template` : `template` ; let logStream : fs . WriteStream | undefined = fs . createWriteStream ( file ) ; if ( header ) logStream . write ( header ) ; logStream . write ( `template` ) ; let fileLogger : IAmDisposable | undefined = logger . onLog ( ( e ) => { if ( ! logStream ) return ; const shouldLog = ! logCategories || logCategories . indexOf ( e . category ) !== - 0 || e . severity === LogSeverity . Warn || e . severity === LogSeverity . Error ; if ( ! shouldLog ) return ; const message = e . message ? e . message . trimRight ( ) : "s" ; const logMessage = maxLogLineLength && message . length > maxLogLineLength ? message . substring ( 0 , maxLogLineLength ) + "s" : message ; const prefix = `template` ; logStream . write ( `template` ) ; } ) ; return { dispose ( ) : Promise < void > | void { if ( fileLogger ) { fileLogger . dispose ( ) ; fileLogger = undefined ; } return new Promise ( ( resolve ) => { if ( logStream ) { logStream . write ( `template` ) ; logStream . end ( resolve ) ; logStream = undefined ; } } ) ; } , } ; }	O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O O O O O $any$ O $any$ O O $void$ O $LogMessage$ O O O O $any$ O O O $LogMessage$ O O O O $IAmDisposable$ O $void$ O O $LogMessage$ O O O O O O O $any$ O O O $void$ O O O O $void$ O O O O O O O $any$ O O O $void$ O O O O O O O O O O $any$ O $any$ O $any$ O O O $LogEmitter$ O O $any$ O O O O O $IAmDisposable$ O O $void$ O O $LogMessage$ O O O O O O O $LogEmitter$ O $IAmDisposable$ O $void$ O O O $void$ O $string$ O $LogSeverity$ O $LogCategory$ O $any$ O $LogCategory.General$ O O O O $LogEmitter$ O $void$ O O $string$ O $LogSeverity$ O $LogCategory$ O O O O O $void$ O $string$ O $LogCategory$ $LogCategory$ O O O O $void$ O $string$ O $any$ O $LogSeverity.Info$ O $LogCategory$ O O O O $void$ O $SomeError$ O $LogCategory$ $LogCategory$ O O O O $void$ O $string$ O $SomeError$ O O $any$ O $LogSeverity.Warn$ O $LogCategory$ O O O O $void$ O $SomeError$ O $LogCategory$ $LogCategory$ O O O O $void$ O $string$ O $SomeError$ O O $any$ O $LogSeverity.Error$ O $LogCategory$ O O O O $void$ O O O O O $LogEmitter$ O $any$ O O O O O O O $any$ O $any$ O O O O $Logger$ O O $LogCategory$ O O O O $void$ O $string$ O $LogCategory$ O O O $LogCategory$ O O O O $Logger$ O $void$ O $string$ O $LogCategory$ O O O O $void$ O $SomeError$ O $LogCategory$ O O O $LogCategory$ O O O O $Logger$ O $void$ O $SomeError$ O $LogCategory$ O O O O $void$ O $SomeError$ O $LogCategory$ O O O $LogCategory$ O O O O $Logger$ O $void$ O $SomeError$ O $LogCategory$ O O O O O $any$ O $any$ O O $void$ O $string$ O $LogCategory$ $LogCategory$ O O O O $void$ O $SomeError$ O $LogCategory$ $LogCategory$ O O O O $void$ O $void$ O $LogCategory$ $LogCategory$ O O O O O O $NullLogger$ O O $any$ O O O O O $void$ O $Logger$ O $LogCategory$ O $any$ O $any$ O $any$ O O O $string$ O O O $Logger$ O $void$ O O O $LogCategory$ O O $any$ O $any$ O $any$ O O O O $any$ O O $Logger$ O $void$ O O O $LogCategory$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $Logger$ O $void$ O O O $LogCategory$ O O O $any$ O $any$ O O O O $any$ O $any$ O O $Logger$ O $void$ O O O $LogCategory$ O O O $any$ O $any$ O O O O $any$ O $any$ O O $Logger$ O $void$ O O O $LogCategory$ O O O O O O $void$ O $EmittingLogger$ O O $EmittingLogger$ O $IAmDisposable$ O O $LogMessage$ O O O O O $LogMessage$ O $LogSeverity$ O $any$ O $LogSeverity.Error$ O $Console$ O $void$ O O O O O O O $LogMessage$ O $complex$ O $any$ O $LogSeverity.Warn$ O $Console$ O $void$ O O O O O O O O O O $complex$ O $EmittingLogger$ O $string$ O $string$ O $number$ O $LogCategory[]$ O O $any$ O O O O O O $complex$ O O O O $PromiseConstructor$ O O O O O O O O O O O $string$ O O $any$ O $any$ O $string$ O O O O $ErrorConstructor$ O O O O O $string$ O O $boolean$ O O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O O $string$ O $any$ O $any$ O $string$ O O $any$ O $any$ O O O O O $IAmDisposable$ O $any$ O O O $EmittingLogger$ O $IAmDisposable$ O O $LogMessage$ O O O O O O $any$ O O O O $boolean$ O O $LogCategory[]$ O $LogCategory[]$ O $number$ O $LogMessage$ O $LogCategory$ O O O O O $LogMessage$ O $LogSeverity$ O $any$ O $LogSeverity.Warn$ O $LogMessage$ O $complex$ O $any$ O $LogSeverity.Error$ O O O O $boolean$ O O O O $string$ O $LogMessage$ O $string$ O $LogMessage$ O $string$ O $string$ O O O O O O $string$ O $number$ O $string$ O $number$ O $number$ O $string$ O $string$ O O O $number$ O O O O $string$ O O $string$ O O O $any$ O $any$ O O O O O O O O O $complex$ O O O $PromiseConstructor$ O O O O O O O O $IAmDisposable$ O O $IAmDisposable$ O $complex$ O O O $IAmDisposable$ O $undefined$ O O O O $PromiseConstructor$ O O $void$ O O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $void$ O O $any$ O $undefined$ O O O O O O O O O O
import * as child_process from "s" ; import { LogCategory } from "s" ; import { Logger } from "s" ; import { logProcess } from "s" ; import { nullToUndefined } from "s" ; export let toolEnv : { [ key ] : string } = { } ; export let globalFlutterArgs : string [ ] = [ ] ; export function setupToolEnv ( envOverrides ? ) { toolEnv = Object . create ( process . env ) ; globalFlutterArgs = [ ] ; toolEnv . FLUTTER_HOST = "s" ; toolEnv . PUB_ENVIRONMENT = ( toolEnv . PUB_ENVIRONMENT ? `template` : "s" ) + "s" ; if ( process . env . DART_CODE_IS_TEST_RUN ) { toolEnv . PUB_ENVIRONMENT += "s" ; globalFlutterArgs . push ( "s" ) ; } if ( envOverrides ) toolEnv = Object . assign ( Object . create ( toolEnv ) , envOverrides ) ; } setupToolEnv ( ) ; export function safeSpawn ( workingDirectory : string | undefined , binPath , args : string [ ] , envOverrides ? ) : child_process . ChildProcess { const customEnv = envOverrides ? Object . assign ( Object . create ( toolEnv ) , envOverrides ) : toolEnv ; return child_process . spawn ( `template` , args . map ( ( a ) => `template` ) , { cwd : workingDirectory , env : customEnv , shell : true } ) ; } export function runProcess ( logger , workingDirectory : string | undefined , binPath , args : string [ ] , envOverrides ? ) < RunProcessResult > { return new Promise ( ( resolve ) => { logger . info ( `template` ) ; const proc = safeSpawn ( workingDirectory , binPath , args , envOverrides ) ; logProcess ( logger , LogCategory . CommandProcesses , proc ) ; const out : string [ ] = [ ] ; const err : string [ ] = [ ] ; proc . stdout . on ( "s" , ( data ) => out . push ( data . toString ( ) ) ) ; proc . stderr . on ( "s" , ( data ) => err . push ( data . toString ( ) ) ) ; proc . on ( "s" , ( code ) => { resolve ( new RunProcessResult ( nullToUndefined ( code ) , out . join ( "s" ) , err . join ( "s" ) ) ) ; } ) ; } ) ; } export class RunProcessResult { constructor ( public readonly exitCode : number | undefined , public readonly stdout , public readonly stderr ) { } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $NullAsUndefined<T>$ O O O O O O $complex$ O O O $string$ O O O O O O O O O O $string[]$ O O O O O O O O O O $void$ O $object$ $object$ O O $complex$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O O $string[]$ O O O O $complex$ O $any$ O O O $complex$ O $any$ O O $complex$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O $complex$ O $any$ O O O $string[]$ O $number$ O O O O O O O $object$ O $complex$ O $ObjectConstructor$ O O O $ObjectConstructor$ O $complex$ O $complex$ O O $object$ O O O $void$ O O O O O $any$ O $string$ O O O O O $string$ O $string[]$ O O O O O $any$ $any$ O O $any$ O $any$ O O $any$ O $any$ O $ObjectConstructor$ O O O $ObjectConstructor$ O $complex$ O $complex$ O O $any$ O O $complex$ O O $any$ O $any$ O O O $string[]$ O $U[]$ O O $string$ O O O O O O $string$ O $string$ O $any$ O $any$ O $boolean$ O O O O O O O O $Promise$ O $Logger$ O $string$ O O O O O $string$ O $string[]$ O O O O O $any$ $any$ O O $any$ O O O O $PromiseConstructor$ O O $void$ O O O $Logger$ O $void$ O O O O O $any$ O $any$ O $string$ O $string$ O $string[]$ O $any$ O O $void$ O $Logger$ O $any$ O $LogCategory.CommandProcesses$ O $any$ O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Buffer$ O O $string[]$ O $number$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $Buffer$ O O $string[]$ O $number$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O $void$ O O $any$ O $NullAsUndefined<T>$ O $any$ O O $string[]$ O $string$ O O O O $string[]$ O $string$ O O O O O O O O O O O O O O O $any$ O O O O O $number$ O O O O O O O $string$ O O O $string$ O O O O
import { ConfigurationTarget , Uri , version as codeVersion , workspace , WorkspaceConfiguration } from "s" ; import { createFolderForFile , resolvePaths } from "s" ; import { NullAsUndefined , nullToUndefined } from "s" ; import { setupToolEnv } from "s" ; class Config { private config : WorkspaceConfiguration ; constructor ( ) { workspace . onDidChangeConfiguration ( ( e ) => this . reloadConfig ( ) ) ; this . config = workspace . getConfiguration ( "s" ) ; setupToolEnv ( this . env ) ; } private reloadConfig ( ) { this . config = workspace . getConfiguration ( "s" ) ; setupToolEnv ( this . env ) ; } private getConfig < T > ( key , defaultValue : T ) < T > { return nullToUndefined ( this . config . get < T > ( key , defaultValue ) ) ; } private getWorkspaceConfig < T > ( key ) < T > { return nullToUndefined ( this . config . inspect < T > ( key ) . workspaceValue || this . config . inspect < T > ( key ) . workspaceValue ) ; } private async setConfig < T > ( key , value : T , target ) < void > { await this . config . update ( key , value , target ) ; } get additionalAnalyzerFileExtensions ( ) : string [ ] { return this . getConfig < string [ ] > ( "s" , [ ] ) ; } get allowAnalytics ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get analysisServerFolding ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get analyzeAngularTemplates ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get analyzerAdditionalArgs ( ) : string [ ] { return this . getConfig < string [ ] > ( "s" , [ ] ) ; } get analyzerDiagnosticsPort ( ) : undefined | number { return this . getConfig < null | number > ( "s" , null ) ; } get analyzerInstrumentationLogFile ( ) : undefined | string { return createFolderForFile ( resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ) ; } get analyzerLogFile ( ) : undefined | string { return createFolderForFile ( resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ) ; } get analyzerObservatoryPort ( ) : undefined | number { return this . getConfig < null | number > ( "s" , null ) ; } get analyzerPath ( ) : undefined | string { return resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ; } get analyzerSshHost ( ) : undefined | string { return this . getConfig < null | string > ( "s" , null ) ; } get autoImportCompletions ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get buildRunnerAdditionalArgs ( ) : string [ ] { return this . getConfig < string [ ] > ( "s" , [ ] ) ; } get checkForSdkUpdates ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get closingLabels ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get devToolsLogFile ( ) : undefined | string { return createFolderForFile ( resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ) ; } get devToolsPort ( ) : undefined | number { return this . getConfig < null | number > ( "s" , null ) ; } get devToolsTheme ( ) : "s" | "s" { return this . getConfig < "s" | "s" > ( "s" , "s" ) ; } get enableSdkFormatter ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get env ( ) : object { return this . getConfig < object > ( "s" , { } ) ; } get extensionLogFile ( ) : undefined | string { return createFolderForFile ( resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ) ; } get flutterAdbConnectOnChromeOs ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get flutterAndroidX ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get flutterCreateAndroidLanguage ( ) : "s" | "s" { return this . getConfig < "s" | "s" > ( "s" , "s" ) ; } get flutterCreateIOSLanguage ( ) : "s" | "s" { return this . getConfig < "s" | "s" > ( "s" , "s" ) ; } get flutterCreateOrganization ( ) : undefined | string { return this . getConfig < null | string > ( "s" , null ) ; } get flutterDaemonLogFile ( ) : undefined | string { return createFolderForFile ( resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ) ; } get flutterHotReloadOnSave ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get flutterHotRestartOnSave ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get flutterOutline ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get flutterScreenshotPath ( ) : undefined | string { return resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ; } get flutterSdkPath ( ) : undefined | string { return resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ; } get flutterSdkPaths ( ) : string [ ] { return this . getConfig < string [ ] > ( "s" , [ ] ) . map ( resolvePaths ) ; } get flutterSelectDeviceWhenConnected ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get maxLogLineLength ( ) : number { return this . getConfig < number > ( "s" , 0 ) ; } get openTestView ( ) : Array < "s" | "s" > { return this . getConfig < Array < "s" | "s" > > ( "s" , [ "s" ] ) ; } get previewBuildRunnerTasks ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get previewFlutterGutterIcons ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get previewFlutterUiGuides ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get previewFlutterUiGuidesCustomTracking ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get previewToStringInDebugViews ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get promptToRunIfErrors ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get reportAnalyzerErrors ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get sdkPath ( ) : undefined | string { return resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ; } get sdkPaths ( ) : string [ ] { return this . getConfig < string [ ] > ( "s" , [ ] ) . map ( resolvePaths ) ; } get showIgnoreQuickFixes ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get showTestCodeLens ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get showTodos ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get triggerSignatureHelpAutomatically ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get useKnownChromeOSPorts ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get warnWhenEditingFilesOutsideWorkspace ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get previewHotReloadCoverageMarkers ( ) { return this . getConfig < boolean > ( "s" , false ) ; } get useDevToolsDarkTheme ( ) { return this . devToolsTheme === "s" ; } get openTestViewOnFailure ( ) { return this . openTestView . indexOf ( "s" ) !== - 0 ; } get openTestViewOnStart ( ) { return this . openTestView . indexOf ( "s" ) !== - 0 ; } get workspaceSdkPath ( ) : undefined | string { return resolvePaths ( this . getWorkspaceConfig < null | string > ( "s" ) ) ; } get workspaceFlutterSdkPath ( ) : undefined | string { return resolvePaths ( this . getWorkspaceConfig < null | string > ( "s" ) ) ; } public setCheckForSdkUpdates ( value ) < void > { return this . setConfig ( "s" , value , ConfigurationTarget . Global ) ; } public setFlutterSdkPath ( value : string | undefined ) < void > { return this . setConfig ( "s" , value , ConfigurationTarget . Workspace ) ; } public setGlobalDartSdkPath ( value ) < void > { return this . setConfig ( "s" , value , ConfigurationTarget . Global ) ; } public setGlobalFlutterSdkPath ( value ) < void > { return this . setConfig ( "s" , value , ConfigurationTarget . Global ) ; } public setSdkPath ( value : string | undefined ) < void > { return this . setConfig ( "s" , value , ConfigurationTarget . Workspace ) ; } public setWarnWhenEditingFilesOutsideWorkspace ( value ) < void > { return this . setConfig ( "s" , value , ConfigurationTarget . Global ) ; } public for ( uri ? ) { return new ResourceConfig ( uri ) ; } } class ResourceConfig { public uri ? : Uri ; public config : WorkspaceConfiguration ; constructor ( uri ? ) { this . uri = uri ; this . config = workspace . getConfiguration ( "s" , this . uri ) ; } private getConfig < T > ( key , defaultValue : T ) < T > { return nullToUndefined ( this . config . get < T > ( key , defaultValue ) ) ; } get analysisExcludedFolders ( ) : string [ ] { return this . getConfig < string [ ] > ( "s" , [ ] ) ; } get debugExternalLibraries ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get debugSdkLibraries ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get doNotFormat ( ) : string [ ] { return this . getConfig < string [ ] > ( "s" , [ ] ) ; } get enableCompletionCommitCharacters ( ) : boolean { return this . getConfig < boolean > ( "s" , false ) ; } get evaluateGettersInDebugViews ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get flutterAdditionalArgs ( ) : string [ ] { return this . getConfig < string [ ] > ( "s" , [ ] ) ; } get flutterRunLogFile ( ) : undefined | string { return createFolderForFile ( resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ) ; } get flutterStructuredErrors ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get flutterTestLogFile ( ) : undefined | string { return createFolderForFile ( resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ) ; } get flutterTrackWidgetCreation ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get insertArgumentPlaceholders ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get lineLength ( ) : number { return this . getConfig < number > ( "s" , 0 ) ; } get observatoryLogFile ( ) : undefined | string { return createFolderForFile ( resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ) ; } get promptToGetPackages ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get pubAdditionalArgs ( ) : string [ ] { return this . getConfig < string [ ] > ( "s" , [ ] ) ; } get pubTestLogFile ( ) : undefined | string { return createFolderForFile ( resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ) ; } get runPubGetOnPubspecChanges ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get showDartDeveloperLogs ( ) : boolean { return this . getConfig < boolean > ( "s" , true ) ; } get vmAdditionalArgs ( ) : string [ ] { return this . getConfig < string [ ] > ( "s" , [ ] ) ; } get webDaemonLogFile ( ) : undefined | string { return createFolderForFile ( resolvePaths ( this . getConfig < null | string > ( "s" , null ) ) ) ; } get runPubGetOnPubspecChangesIsConfiguredExplicitly ( ) { const runPubGet = this . config . inspect ( "s" ) ; return runPubGet && ( runPubGet . globalValue !== undefined || runPubGet . workspaceValue !== undefined || runPubGet . workspaceFolderValue !== undefined ) ; } } export class CodeCapabilities { public version : string ; constructor ( version ) { this . version = version ; } } export const config = new Config ( ) ; export const vsCodeVersion = new CodeCapabilities ( codeVersion ) ;	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O $complex$ O O O O O O $any$ O $NullAsUndefined<T>$ O O O O O O $void$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O O O $void$ O O O $object$ O O O O $void$ O O O O O $any$ O $any$ O $any$ O O O O $void$ O O O $object$ O O O O $NullAsUndefined$ O $any$ O O $string$ O $T$ O $any$ O O $any$ O O O $NullAsUndefined<T>$ O O O $any$ O $any$ O $any$ O O $string$ O $T$ O O O O O $NullAsUndefined$ O $any$ O O $string$ O O $any$ O O O $NullAsUndefined<T>$ O O O $any$ O $any$ O $any$ O O $string$ O O $any$ O O O $any$ O $any$ O $any$ O O $string$ O O $any$ O O O O O $Promise$ O $any$ O O $string$ O $T$ O $any$ O $ConfigurationTarget$ O O O O O O O O $any$ O $any$ O $string$ O $T$ O $any$ O O O O $string[]$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $string[]$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O $number$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O $number$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O $string$ O O O O O O O O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $string[]$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $string$ O O O O O O O O $string$ O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O $number$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $object$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O $string$ O O O O O O O O $string$ O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O $string$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $string$ O O O O O O O O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O $string$ O O O O O O O O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O $string[]$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O $U[]$ O $complex$ O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $number$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $complex$ O O O $ArrayConstructor$ O O O O O O O O O $NullAsUndefined<T>$ O $ArrayConstructor$ O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $string$ O O O O O O O O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O $string[]$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O $U[]$ O $complex$ O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O O O O O $boolean$ O O O O O O $complex$ O $number$ O O O O O O O O O $boolean$ O O O O O O $complex$ O $number$ O O O O O O O O O $string$ O O O O O O O O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O $string$ O O O O O O O O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O $Thenable$ O $boolean$ O O O O O O O O $Promise<void>$ O O O $boolean$ O $any$ O $any$ O O O O $Thenable$ O $string$ O O O O O O O O O O O O $Promise<void>$ O O O $string$ O $any$ O $any$ O O O O $Thenable$ O $string$ O O O O O O O O $Promise<void>$ O O O $string$ O $any$ O $any$ O O O O $Thenable$ O $string$ O O O O O O O O $Promise<void>$ O O O $string$ O $any$ O $any$ O O O O $Thenable$ O $string$ O O O O O O O O O O O O $Promise<void>$ O O O $string$ O $any$ O $any$ O O O O $Thenable$ O $boolean$ O O O O O O O O $Promise<void>$ O O O $boolean$ O $any$ O $any$ O O O O $ResourceConfig$ O $any$ $Uri$ O O O O $any$ O $any$ O O O O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O O $any$ $Uri$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O $NullAsUndefined$ O $any$ O O $string$ O $T$ O $any$ O O $any$ O O O $NullAsUndefined<T>$ O O O $any$ O $any$ O $any$ O O $string$ O $T$ O O O O O $string[]$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $string[]$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $string[]$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $string$ O O O O O O O O $string$ O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $number$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $string$ O O O O O O O O $string$ O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $string[]$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $boolean$ O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O $string[]$ O O O O O O O O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O $complex$ O O O $NullAsUndefined<T>$ O O O O O O O O O O O O O O O $boolean$ O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $undefined$ O $any$ O $any$ O $undefined$ O $any$ O $any$ O $undefined$ O O O O O O $any$ O O $string$ O O O O O $string$ O O O O $string$ O $string$ O O O O O $Config$ O O $any$ O O O O O $CodeCapabilities$ O O $any$ O $any$ O O
import { versionIsAtLeast } from "s" ; export class VmServiceCapabilities { public static get empty ( ) { return new VmServiceCapabilities ( "s" ) ; } constructor ( public version ) { } get hasLoggingStream ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get serviceStreamIsPublic ( ) { return versionIsAtLeast ( this . version , "s" ) ; } }	O O $boolean$ O O O O O O $any$ O O O O $VmServiceCapabilities$ O O O O O $any$ O O O O O O O O $string$ O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O
const codeReset = "s" ; const brightOffset = 0 ; const codeFg = "s" ; const codeBg = "s" ; const codeBlack = 0 ; const codeRed = 0 ; const codeGreen = 0 ; const codeYellow = 0 ; const codeBlue = 0 ; const codeMagenta = 0 ; const codeCyan = 0 ; const codeWhite = 0 ; const codeGrey = 0 ; const 0 = 0 ; const esc = ( ... code < number | string > ) => `template` ; export const black = ( msg ) => `template` ; export const red = ( msg ) => `template` ; export const green = ( msg ) => `template` ; export const yellow = ( msg ) => `template` ; export const blue = ( msg ) => `template` ; export const magenta = ( msg ) => `template` ; export const cyan = ( msg ) => `template` ; export const white = ( msg ) => `template` ; export const grey = ( msg ) => `template` ; export const 0 = ( msg ) => `template` ; export const brightBlack = ( msg ) => `template` ; export const brightRed = ( msg ) => `template` ; export const brightGreen = ( msg ) => `template` ; export const brightYellow = ( msg ) => `template` ; export const brightBlue = ( msg ) => `template` ; export const brightMagenta = ( msg ) => `template` ; export const brightCyan = ( msg ) => `template` ; export const brightWhite = ( msg ) => `template` ; export const blackBackground = ( msg ) => `template` ; export const redBackground = ( msg ) => `template` ; export const greenBackground = ( msg ) => `template` ; export const yellowBackground = ( msg ) => `template` ; export const blueBackground = ( msg ) => `template` ; export const magentaBackground = ( msg ) => `template` ; export const cyanBackground = ( msg ) => `template` ; export const whiteBackground = ( msg ) => `template` ; export const brightBlackBackground = ( msg ) => `template` ; export const brightRedBackground = ( msg ) => `template` ; export const brightGreenBackground = ( msg ) => `template` ; export const brightYellowBackground = ( msg ) => `template` ; export const brightBlueBackground = ( msg ) => `template` ; export const brightMagentaBackground = ( msg ) => `template` ; export const brightCyanBackground = ( msg ) => `template` ; export const brightWhiteBackground = ( msg ) => `template` ; const whitespacePattern = new RegExp ( `template` ) ; export function applyColor ( text , color : ( text ) => string ) { const match = text && whitespacePattern . exec ( text ) ; if ( ! match ) return color ( text ) ; return `template` ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $Array$ O O O O O O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O O $string$ O O $string$ O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O $string$ O $string$ O $string$ O O $string$ O O O O O O $RegExpExecArray$ O $string$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O O $RegExpExecArray$ O O $string$ O $string$ O O O O O O
import * as WebSocket from "s" ; import { PromiseCompleter } from "s" ; export class DebuggerResult { public result : VMResponse ; constructor ( result ) { this . result = result ; } } export interface VMEvent { kind : string ; timestamp : number ; isolate ? : VMIsolateRef ; exception ? : VMInstanceRef ; breakpoint ? : VMBreakpoint ; pauseBreakpoints ? : VMBreakpoint [ ] ; atAsyncSuspension ? : boolean ; extensionRPC ? : string ; extensionKind ? : string ; extensionData ? : any ; service ? : string ; method ? : string ; logRecord ? : VMLogRecord ; } export interface VMBreakpoint extends VMObj { breakpointNumber : number ; resolved : boolean ; location : VMSourceLocation | VMUnresolvedSourceLocation ; } export interface VMObj extends VMResponse { id : string ; class ? : VMClassRef ; size ? : number ; } export interface VMIsolateRef extends VMResponse { id : string ; name : string ; } export interface VMIsolate extends VMResponse , VMIsolateRef { number : string ; runnable : boolean ; pauseEvent : VMEvent ; libraries : VMLibraryRef [ ] ; _heaps ? : { new : VMHeapSpace , old : VMHeapSpace } ; rootLib ? : VMLibraryRef ; extensionRPCs ? : string [ ] ; } export interface VMObjectRef extends VMResponse { id : string ; } export interface VMStack extends VMResponse { frames : VMFrame [ ] ; asyncCausalFrames ? : VMFrame [ ] ; } export interface VMHeapSpace extends VMResponse { name : string ; used : number ; capacity : number ; external : number ; } export interface VMFrame extends VMResponse { index : number ; kind : string ; code ? : VMCodeRef ; function ? : VMFuncRef ; location ? : VMSourceLocation ; vars ? : VMBoundVariable [ ] ; } export interface VMCodeRef extends VMObjectRef { name : string ; kind : string ; } export interface VMSourceLocation extends VMResponse { script : VMScriptRef ; tokenPos : number ; endTokenPos ? : number ; } export interface VMUnresolvedSourceLocation extends VMResponse { script ? : VMScriptRef ; scriptUri ? : string ; tokenPos ? : number ; line ? : number ; column ? : number ; } export interface VMScriptRef extends VMObjectRef { uri : string ; } export interface VMScript extends VMObj { uri : string ; library : VMLibraryRef ; source : string ; tokenPosTable : number [ ] [ ] ; } export interface VMInstance extends VMObj { kind : string ; valueAsString ? : boolean ; valueAsStringIsTruncated ? : boolean ; length ? : number ; offset ? : number ; count ? : number ; name ? : string ; fields ? : VMBoundField [ ] ; elements ? : any [ ] ; associations ? : VMMapAssociation [ ] ; } export interface VMClass extends VMObj { name : string ; functions : VMFunctionRef [ ] ; super ? : VMClassRef ; } export interface VMBoundField { decl : VMFieldRef ; value : VMInstanceRef | VMSentinel ; } export interface VMMapAssociation { key : VMInstanceRef | VMSentinel ; value : VMInstanceRef | VMSentinel ; } export interface VMFieldRef extends VMObjectRef { name : string ; owner : VMObjectRef ; } export interface VMLibraryRef extends VMObjectRef { name : string ; uri : string ; } export interface VMLibrary extends VMObj { scripts : VMScriptRef [ ] ; } export interface VMFuncRef extends VMObjectRef { name : string ; owner : VMLibraryRef | VMClassRef | VMFuncRef ; isStatic : boolean ; isConst : boolean ; } export interface VMBoundVariable { name : string ; value : VMInstanceRef | VMSentinel ; } export interface VMResponse { type : string ; } export interface VM extends VMResponse { architectureBits : number ; targetCPU : string ; hostCPU : string ; version : string ; pid : number ; isolates : VMIsolateRef [ ] ; libraries : VMLibraryRef [ ] ; } export interface Version extends VMResponse { major : number ; minor : number ; } export interface VMMapEntry extends VMResponse { keyId : string ; mapEvaluateName : string ; valueId : string ; } export interface VMSentinel extends VMResponse { kind : string ; valueAsString : string ; } export interface VMInstanceRef extends VMObjectRef { kind : string ; class : VMClassRef ; valueAsString ? : string ; valueAsStringIsTruncated ? : boolean ; length ? : number ; } export interface VMTypeRef extends VMInstanceRef { name : string ; } export interface VMErrorRef extends VMObjectRef { kind : string ; message : string ; } export interface VMClassRef extends VMObjectRef { name : string ; } export interface VMFunctionRef extends VMObjectRef { name : string ; _kind : string ; static : boolean ; const : boolean ; } export interface VMLogRecord extends VMResponse { message : VMInstanceRef ; time : number ; level : number ; sequenceNumber : number ; loggerName : VMInstanceRef ; zone : VMInstanceRef ; error : VMInstanceRef ; stackTrace : VMInstanceRef ; } export interface VMSourceReport extends VMResponse { ranges : VMSourceReportRange [ ] ; scripts : VMScriptRef [ ] ; } export interface VMSourceReportRange { scriptIndex : number ; startPos : number ; endPos : number ; compiled : boolean ; error ? : Error ; coverage ? : VMSourceReportCoverage ; possibleBreakpoints ? : number [ ] ; } export interface VMSourceReportCoverage { hits : number [ ] ; misses : number [ ] ; } export enum SourceReportKind { Coverage , PossibleBreakpoints , } export class RPCError { public code : number ; public message : string ; public data : any ; constructor ( code , message , data ? ) { this . code = code ; this . message = message ; this . data = data ; } public details ( ) : string | undefined { return this . data ? this . data . details : undefined ; } public toString ( ) { return `template` ; } } export class ObservatoryConnection { public socket : WebSocket ; private completers : { [ key ] : PromiseCompleter < DebuggerResult > } = { } ; private logging ? : ( message ) => void ; private eventListeners : { [ key ] : ( message ) => void } = { } ; constructor ( uri ) { this . socket = new WebSocket ( uri ) ; this . socket . on ( "s" , ( data ) => this . handleData ( data . toString ( ) ) ) ; } public onOpen ( cb : ( ) => void ) { this . socket . on ( "s" , cb ) ; } public onLogging ( callback : ( message ) => void ) { this . logging = callback ; } public getVersion ( ) < DebuggerResult > { return this . callMethod ( "s" ) ; } public getVM ( ) < DebuggerResult > { return this . callMethod ( "s" ) ; } public getIsolate ( isolateId ) < DebuggerResult > { return this . callMethod ( "s" , { isolateId } ) ; } public on ( streamId , callback : ( event ) => void ) < DebuggerResult > { this . eventListeners [ streamId ] = callback ; return this . streamListen ( streamId ) ; } public streamListen ( streamId ) < DebuggerResult > { return this . callMethod ( "s" , { streamId } ) ; } public addBreakpointWithScriptUri ( isolateId , scriptUri , line , column ? ) < DebuggerResult > { let data : { isolateId : string , scriptUri : string , line : number , column ? : number , } ; data = { isolateId , scriptUri , line } ; if ( column ) data . column = column ; return this . callMethod ( "s" , data ) ; } public setExceptionPauseMode ( isolateId , mode ) < DebuggerResult > { return this . callMethod ( "s" , { isolateId , mode } ) ; } public removeBreakpoint ( isolateId , breakpointId ) { return this . callMethod ( "s" , { isolateId , breakpointId } ) ; } public pause ( isolateId ) < DebuggerResult > { return this . callMethod ( "s" , { isolateId } ) ; } public resume ( isolateId , step ? ) < DebuggerResult > { return this . callMethod ( "s" , { isolateId , step } ) ; } public getStack ( isolateId ) < DebuggerResult > { return this . callMethod ( "s" , { isolateId } ) ; } public getSourceReport ( isolate , reports : SourceReportKind [ ] , script ) < DebuggerResult > { return this . callMethod ( "s" , { isolateId : isolate . id , reports : reports . map ( ( r ) => SourceReportKind [ r ] ) , scriptId : script . id } ) ; } public getObject ( isolateId , objectId , offset ? , count ? ) < DebuggerResult > { let data : { isolateId : string , objectId : string , offset ? : number , count ? : number , } ; data = { isolateId , objectId } ; if ( offset ) data . offset = offset ; if ( count ) data . count = count ; return this . callMethod ( "s" , data ) ; } public evaluate ( isolateId , targetId , expression , disableBreakpoints : boolean | undefined ) < DebuggerResult > { return this . callMethod ( "s" , { disableBreakpoints , expression , isolateId , targetId , } ) ; } public evaluateInFrame ( isolateId , frameIndex , expression , disableBreakpoints : boolean | undefined ) < DebuggerResult > { return this . callMethod ( "s" , { disableBreakpoints , expression , frameIndex , isolateId , } ) ; } public setLibraryDebuggable ( isolateId , libraryId , isDebuggable ) < DebuggerResult > { return this . callMethod ( "s" , { isolateId , libraryId , isDebuggable } ) ; } public nextId : number = 0 ; public callMethod ( method , params ? ) < DebuggerResult > { const id = `template` ; const completer = new PromiseCompleter < DebuggerResult > ( ) ; this . completers [ id ] = completer ; let json : { id : string , method : string , params ? : any , } ; json = { id , method } ; if ( params ) json . params = params ; const str = JSON . stringify ( json ) ; this . logTraffic ( `template` ) ; this . socket . send ( str ) ; return completer . promise ; } public handleData ( data ) { this . logTraffic ( `template` ) ; let json : { id : string , error : { code : number , message : string , data : any , } , method : any , result : VMResponse , params : { streamId : string , event : VMEvent , } , } ; json = JSON . parse ( data ) ; const id = json . id ; const method = json . method ; const error = json . error ; const completer < DebuggerResult > = this . completers [ id ] ; if ( completer ) { delete this . completers [ id ] ; if ( error ) completer . reject ( new RPCError ( error . code , error . message , error . data ) ) ; else completer . resolve ( new DebuggerResult ( json . result ) ) ; } else if ( method ) { const params = json . params ; const streamId = params . streamId ; const callback = this . eventListeners [ streamId ] ; if ( callback ) callback ( params . event ) ; } } public onError ( cb : ( err ) => void ) { this . socket . on ( "s" , cb ) ; } public onClose ( cb : ( code , message ) => void ) { this . socket . on ( "s" , cb ) ; } private logTraffic ( message ) { if ( this . logging ) { this . logging ( message ) ; } } public close ( ) { this . socket . close ( ) ; } } export interface FlutterServiceExtensionStateChangedData { extension : string ; value : any ; }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O $VMResponse$ O $any$ O O O $VMResponse$ O O O O $VMResponse$ O $VMResponse$ O O O O O $any$ O $string$ O O O $number$ O O O $VMIsolateRef$ O O $any$ O $VMInstanceRef$ O O $any$ O $VMBreakpoint$ O O $any$ O $VMBreakpoint[]$ O O $any$ O O O $boolean$ O O O O $string$ O O O O $string$ O O O O $any$ O O O O $string$ O O O O $string$ O O O O $VMLogRecord$ O O $any$ O O O O $any$ O $any$ O $number$ O O O $boolean$ O O O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O $VMClassRef$ O O $any$ O $number$ O O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $string$ O O O $boolean$ O O O $VMEvent$ O $any$ O $VMLibraryRef[]$ O $any$ O O O $complex$ O O O $VMHeapSpace$ O $any$ O $VMHeapSpace$ O $any$ O O $VMLibraryRef$ O O $any$ O $string[]$ O O O O O O O O O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $VMFrame[]$ O $any$ O O O $VMFrame[]$ O O $any$ O O O O O O $any$ O $any$ O $string$ O O O $number$ O O O $number$ O O O $number$ O O O O O O $any$ O $any$ O $number$ O O O $string$ O O O $VMCodeRef$ O O $any$ O $VMFuncRef$ O O $any$ O $VMSourceLocation$ O O $any$ O $VMBoundVariable[]$ O O $any$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O $any$ O $any$ O $VMScriptRef$ O $any$ O $number$ O O O $number$ O O O O O O O $any$ O $any$ O $VMScriptRef$ O O $any$ O $string$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O O O O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $string$ O O O $VMLibraryRef$ O $any$ O $string$ O O O $number[][]$ O O O O O O O O O O $any$ O $any$ O $string$ O O O $boolean$ O O O O $boolean$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $string$ O O O O $VMBoundField[]$ O O $any$ O O O $any[]$ O O O O O O $VMMapAssociation[]$ O O $any$ O O O O O O $any$ O $any$ O $string$ O O O $VMFunctionRef[]$ O $any$ O O O $VMClassRef$ O O $any$ O O O O $any$ O $VMFieldRef$ O $any$ O $complex$ O $any$ O $any$ O O O O $any$ O $complex$ O $any$ O $any$ O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O $VMObjectRef$ O $any$ O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O $any$ O $any$ O $VMScriptRef[]$ O $any$ O O O O O O $any$ O $any$ O $string$ O O O $complex$ O $any$ O $any$ O $any$ O $boolean$ O O O $boolean$ O O O O O O $any$ O $string$ O O O $complex$ O $any$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $any$ O $number$ O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $VMIsolateRef[]$ O $any$ O O O $VMLibraryRef[]$ O $any$ O O O O O O $any$ O $any$ O $number$ O O O $number$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O $any$ O $any$ O $string$ O O O $VMClassRef$ O $any$ O $string$ O O O O $boolean$ O O O O $number$ O O O O O O O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O O O O $any$ O $any$ O $VMInstanceRef$ O $any$ O $number$ O O O $number$ O O O $number$ O O O $VMInstanceRef$ O $any$ O $VMInstanceRef$ O $any$ O $VMInstanceRef$ O $any$ O $VMInstanceRef$ O $any$ O O O O $any$ O $any$ O $VMSourceReportRange[]$ O $any$ O O O $VMScriptRef[]$ O $any$ O O O O O O $any$ O $number$ O O O $number$ O O O $number$ O O O $boolean$ O O O $Error$ O O $ErrorConstructor$ O $VMSourceReportCoverage$ O O $any$ O $number[]$ O O O O O O O O O $any$ O $number[]$ O O O O O $number[]$ O O O O O O O O $any$ O $SourceReportKind.Coverage$ O $SourceReportKind.PossibleBreakpoints$ O O O O $any$ O O $number$ O O O O $string$ O O O O $any$ O O O O O $number$ O $string$ O $any$ $any$ O O O O $number$ O $number$ O O O $string$ O $string$ O O O $any$ O $any$ O O O $string$ O O O O O O O O O O $any$ O O O $any$ O $any$ O $undefined$ O O O $string$ O O O O O O O O O O $any$ O O $any$ O $any$ O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O O O $void$ O O O $string$ O O O O O $complex$ O O O $string$ O O O $VMEvent$ O O O O O O O O O O $string$ O O O O $any$ O O $any$ O $string$ O O O O $any$ O $any$ O O O O $any$ O O O O $void$ O $any$ O $any$ O O O O O O O $void$ O $void$ O O O O O O O O O $any$ O $any$ O O O $void$ O O O O $void$ O $void$ O O $string$ O O O O O O O $void$ O $void$ O O O $Promise$ O O O $any$ O O O O O $Promise<DebuggerResult>$ O O O O O O $Promise$ O O O $any$ O O O O O $Promise<DebuggerResult>$ O O O O O O $Promise$ O $string$ O O $any$ O O O O O $Promise<DebuggerResult>$ O O O O $string$ O O O O O $Promise$ O $string$ O $void$ O O $VMEvent$ O O O O O $any$ O O O O $complex$ O $string$ O O $void$ O O O O $Promise<DebuggerResult>$ O $string$ O O O O $Promise$ O $string$ O O $any$ O O O O O $Promise<DebuggerResult>$ O O O O $string$ O O O O O $Promise$ O $string$ O $string$ O $number$ O $number$ $number$ O O $any$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $number$ O O O O O O $complex$ O O $string$ O $string$ O $number$ O O O O $number$ O $complex$ O $number$ O $number$ O O O O $Promise<DebuggerResult>$ O O O $complex$ O O O O $Promise$ O $string$ O $string$ O O $any$ O O O O O $Promise<DebuggerResult>$ O O O O $string$ O $string$ O O O O O $Promise<DebuggerResult>$ O $string$ O $string$ O O O O O $Promise<DebuggerResult>$ O O O O $string$ O $string$ O O O O O $Promise$ O $string$ O O $any$ O O O O O $Promise<DebuggerResult>$ O O O O $string$ O O O O O $Promise$ O $string$ O $string$ $string$ O O $any$ O O O O O $Promise<DebuggerResult>$ O O O O $string$ O $string$ O O O O O $Promise$ O $string$ O O $any$ O O O O O $Promise<DebuggerResult>$ O O O O $string$ O O O O O $Promise$ O $VMIsolateRef$ O $SourceReportKind[]$ O $any$ O O O $VMScriptRef$ O O $any$ O O O O O $Promise<DebuggerResult>$ O O O O $string$ O $VMIsolateRef$ O $string$ O $string[]$ O $SourceReportKind[]$ O $U[]$ O O $SourceReportKind$ O O $any$ O $SourceReportKind$ O O O $string$ O $VMScriptRef$ O $string$ O O O O O $Promise$ O $string$ O $string$ O $number$ $number$ O $number$ $number$ O O $any$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O O $number$ O O O O O O $complex$ O O $string$ O $string$ O O O O $number$ O $complex$ O $number$ O $number$ O O O $number$ O $complex$ O $number$ O $number$ O O O O $Promise<DebuggerResult>$ O O O $complex$ O O O O $Promise$ O $string$ O $string$ O $string$ O $boolean$ O O O O O O $any$ O O O O O $Promise<DebuggerResult>$ O O O O $boolean$ O $string$ O $string$ O $string$ O O O O O O $Promise$ O $string$ O $number$ O $string$ O $boolean$ O O O O O O $any$ O O O O O $Promise<DebuggerResult>$ O O O O $boolean$ O $string$ O $number$ O $string$ O O O O O O $Promise$ O $string$ O $string$ O $boolean$ O O $any$ O O O O O $Promise<DebuggerResult>$ O O O O $string$ O $string$ O $boolean$ O O O O O $number$ O O O O O O $Promise$ O $string$ O $any$ $any$ O O $any$ O O O $string$ O O O O $PromiseCompleter<DebuggerResult>$ O O $any$ O $any$ O O O O O O $complex$ O $string$ O O $PromiseCompleter<DebuggerResult>$ O O $complex$ O O $string$ O O O $string$ O O O $any$ O O O O O O $complex$ O O $string$ O $string$ O O O O $any$ O $complex$ O $any$ O $any$ O O $string$ O $JSON$ O $complex$ O $complex$ O O O O $void$ O O O O O O $any$ O $any$ O $string$ O O O $PromiseCompleter<DebuggerResult>$ O $Promise<DebuggerResult>$ O O O $void$ O $string$ O O O O $void$ O O O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $string$ O O O $any$ O O O O O $any$ O O O $VMResponse$ O $any$ O $complex$ O O $string$ O O O $VMEvent$ O $any$ O O O O O $complex$ O $JSON$ O $any$ O $string$ O O O $string$ O $complex$ O $string$ O O $any$ O $complex$ O $any$ O O $complex$ O $complex$ O $complex$ O O $PromiseCompleter$ O $any$ O O O O $complex$ O $string$ O O O O $PromiseCompleter<DebuggerResult>$ O O O O O $complex$ O $string$ O O O O $complex$ O $PromiseCompleter<DebuggerResult>$ O $void$ O O $any$ O $complex$ O $number$ O $complex$ O $string$ O $complex$ O $any$ O O O O $PromiseCompleter<DebuggerResult>$ O $void$ O O $any$ O $complex$ O $VMResponse$ O O O O O O O $any$ O O O $complex$ O $complex$ O $complex$ O O $string$ O $complex$ O $string$ O O $void$ O O O $complex$ O $string$ O O O O $void$ O $void$ O $complex$ O $VMEvent$ O O O O O $void$ O $void$ O O $Error$ O O O O O O O $any$ O $any$ O O O $void$ O O O O $void$ O $void$ O O $number$ O $string$ O O O O O O O $any$ O $any$ O O O $void$ O O O O $void$ O $string$ O O O O O O $void$ O O O O $void$ O $string$ O O O O O $void$ O O O O O $any$ O $any$ O O O O O O O $any$ O $string$ O O O $any$ O O O O
import { Event } from "s" ; import { DebugProtocol } from "s" ; import { LogCategory , LogSeverity } from "s" ; import { Logger , LogMessage , SomeError } from "s" ; import { errorString } from "s" ; export class DebugAdapterLogger implements Logger { constructor ( private readonly debugClient : { sendEvent : ( event : DebugProtocol . Event ) => void } , private readonly category ) { } private log ( message , severity , category = this . category ) { this . debugClient . sendEvent ( new Event ( "s" , { message , severity , category } as LogMessage ) ) ; } public info ( message , category ? ) { this . log ( message , LogSeverity . Info , category ) ; } public warn ( errorOrMessage , category ? ) { this . log ( errorString ( errorOrMessage ) , LogSeverity . Warn , category ) ; } public error ( errorOrMessage , category ? ) { this . log ( errorString ( errorOrMessage ) , LogSeverity . Error , category ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O O O O $any$ O $any$ O O O O O $complex$ O O $void$ O O $any$ O $any$ O $any$ O O O O O O O $LogCategory$ O O O O $void$ O $string$ O $LogSeverity$ O $LogCategory$ O O O $LogCategory$ O O O O $complex$ O $void$ O O $any$ O O O O $string$ O $LogSeverity$ O $LogCategory$ O O $any$ O O O O O $void$ O $string$ O $LogCategory$ $LogCategory$ O O O O $void$ O $string$ O $any$ O $LogSeverity.Info$ O $LogCategory$ O O O O $void$ O $SomeError$ O $LogCategory$ $LogCategory$ O O O O $void$ O $string$ O $SomeError$ O O $any$ O $LogSeverity.Warn$ O $LogCategory$ O O O O $void$ O $SomeError$ O $LogCategory$ $LogCategory$ O O O O $void$ O $string$ O $SomeError$ O O $any$ O $LogSeverity.Error$ O $LogCategory$ O O O O
const knownInfrastructureThreadPrefixes = [ "s" , "s" ] as const ; export function isKnownInfrastructureThread ( thread : { name : string } ) { return ! ! ( thread && thread . name && knownInfrastructureThreadPrefixes . find ( ( p ) => thread . name . startsWith ( p ) ) ) ; }	O $complex$ O O O O O O O $any$ O O O $boolean$ O $complex$ O O $string$ O O O O O O O O O $complex$ O $complex$ O $string$ O $complex$ O $complex$ O O O O O $complex$ O $string$ O $boolean$ O O O O O O O
import { Thread , ThreadEvent } from "s" ; import { DebugProtocol } from "s" ; import { LogCategory } from "s" ; import { Logger } from "s" ; import { errorString , PromiseCompleter } from "s" ; import { isKnownInfrastructureThread } from "s" ; import { DartDebugSession , InstanceWithEvaluateName , VmExceptionMode } from "s" ; import { DebuggerResult , VMBreakpoint , VMInstanceRef , VMIsolate , VMIsolateRef , VMResponse , VMScript , VMScriptRef } from "s" ; export class ThreadManager { public nextThreadId : number = 0 ; public threads : ThreadInfo [ ] = [ ] ; public bps : { [ uri ] : DebugProtocol . SourceBreakpoint [ ] } = { } ; private hasConfigurationDone = false ; private exceptionMode : VmExceptionMode = "s" ; constructor ( private readonly logger , public readonly debugSession ) { } public async registerThread ( ref , eventKind ) < void > { let thread = this . getThreadInfoFromRef ( ref ) ; if ( ! thread ) { thread = new ThreadInfo ( this , ref , this . nextThreadId ) ; this . nextThreadId ++ ; this . threads . push ( thread ) ; this . debugSession . sendEvent ( new ThreadEvent ( "s" , thread . num ) ) ; if ( this . hasConfigurationDone ) thread . receivedConfigurationDone ( ) ; } if ( eventKind === "s" && ! thread . runnable ) { thread . runnable = true ; if ( this . debugSession . observatory ) { await Promise . all ( [ this . debugSession . observatory . setExceptionPauseMode ( thread . ref . id , this . exceptionMode ) , this . setLibrariesDebuggable ( thread . ref ) , this . resetBreakpoints ( ) , ] ) ; thread . setInitialBreakpoints ( ) ; } } } public receivedConfigurationDone ( ) { this . hasConfigurationDone = true ; for ( const thread of this . threads ) thread . receivedConfigurationDone ( ) ; } public getThreadInfoFromRef ( ref ) : ThreadInfo | undefined { for ( const thread of this . threads ) { if ( thread . ref . id === ref . id ) return thread ; } return undefined ; } public getThreadInfoFromNumber ( num ) : ThreadInfo | undefined { for ( const thread of this . threads ) { if ( thread . num === num ) return thread ; } return undefined ; } public getThreads ( ) : Thread [ ] { return this . threads . map ( ( thread ) => new Thread ( thread . num , thread . ref . name ) ) ; } public setExceptionPauseMode ( mode ) { this . exceptionMode = mode ; if ( ! this . debugSession . observatory ) return ; for ( const thread of this . threads ) { if ( thread . runnable ) { let threadMode = mode ; if ( mode === "s" && thread . isInfrastructure ) threadMode = "s" ; this . debugSession . observatory . setExceptionPauseMode ( thread . ref . id , threadMode ) ; } } } private async setLibrariesDebuggable ( isolateRef ) < void > { if ( this . debugSession . noDebug || ! this . debugSession . observatory ) return ; const response = await this . debugSession . observatory . getIsolate ( isolateRef . id ) ; const isolate = response . result as VMIsolate ; await Promise . all ( isolate . libraries . filter ( ( l ) => this . debugSession . isValidToDebug ( l . uri ) ) . map ( ( library ) : Promise < any > => { if ( ! this . debugSession . observatory ) return Promise . resolve ( true ) ; const shouldDebug = ! ( ( this . debugSession . isSdkLibrary ( library . uri ) && ! this . debugSession . debugSdkLibraries ) || ( this . debugSession . isExternalLibrary ( library . uri ) && ! this . debugSession . debugExternalLibraries ) ) ; return this . debugSession . observatory . setLibraryDebuggable ( isolate . id , library . id , shouldDebug ) ; } ) ) . catch ( ( e ) => { this . logger . info ( errorString ( e ) ) ; } ) ; } public async resetBreakpoints ( ) < void > { const promises = [ ] ; for ( const uri of Object . keys ( this . bps ) ) { promises . push ( this . setBreakpoints ( uri , this . bps [ uri ] ) ) ; } await Promise . all ( promises ) ; } public setBreakpoints ( uri , breakpoints : DebugProtocol . SourceBreakpoint [ ] ) < any [ ] > { if ( breakpoints . length === 0 ) delete this . bps [ uri ] ; else this . bps [ uri ] = breakpoints ; let promise ; for ( const thread of this . threads ) { if ( thread . runnable ) { const result = thread . setBreakpoints ( this . logger , uri , breakpoints ) ; if ( ! promise ) promise = result ; } } if ( promise ) return promise ; const completer = new PromiseCompleter < boolean [ ] > ( ) ; completer . resolve ( breakpoints . map ( ( _ ) => true ) ) ; return completer . promise ; } public nextDataId : number = 0 ; public storedData : { [ id ] : StoredData } = { } ; public storeData ( thread , data ) { const id = this . nextDataId ; this . nextDataId ++ ; this . storedData [ id ] = new StoredData ( thread , data ) ; return id ; } public getStoredData ( id ) { return this . storedData [ id ] ; } public removeStoredData ( thread ) { for ( const id of Object . keys ( this . storedData ) . map ( ( k ) => parseInt ( k , 0 ) ) ) { if ( this . storedData [ id ] . thread . num === thread . num ) delete this . storedData [ id ] ; } } public removeAllStoredData ( ) { for ( const id of Object . keys ( this . storedData ) . map ( ( k ) => parseInt ( k , 0 ) ) ) { delete this . storedData [ id ] ; } } public handleIsolateExit ( ref ) { const threadInfo = this . getThreadInfoFromRef ( ref ) ; if ( threadInfo ) { this . debugSession . sendEvent ( new ThreadEvent ( "s" , threadInfo . num ) ) ; this . threads . splice ( this . threads . indexOf ( threadInfo ) , 0 ) ; this . removeStoredData ( threadInfo ) ; } } } class StoredData { public thread : ThreadInfo ; public data : VMResponse ; constructor ( thread , data ) { this . thread = thread ; this . data = data ; } } export class ThreadInfo { public scriptCompleters : { [ key ] : PromiseCompleter < VMScript > } = { } ; public runnable : boolean = false ; public vmBps : { [ uri ] : VMBreakpoint [ ] } = { } ; public breakpoints : { [ key ] : DebugProtocol . SourceBreakpoint } = { } ; public atAsyncSuspension : boolean = false ; public exceptionReference = 0 ; public paused : boolean = false ; get isInfrastructure ( ) : boolean { return this . ref && this . ref . name ? isKnownInfrastructureThread ( this . ref ) : false ; } constructor ( public readonly manager , public readonly ref , public readonly num ) { } private removeBreakpointsAtUri ( uri ) < DebuggerResult [ ] > { const removeBreakpointPromises = [ ] ; const breakpoints = this . vmBps [ uri ] ; if ( breakpoints ) { for ( const bp of breakpoints ) { removeBreakpointPromises . push ( this . manager . debugSession . observatory . removeBreakpoint ( this . ref . id , bp . id ) ) ; } delete this . vmBps [ uri ] ; } return Promise . all ( removeBreakpointPromises ) ; } public removeAllBreakpoints ( ) < DebuggerResult [ ] > { const removeBreakpointPromises = [ ] ; for ( const uri of Object . keys ( this . vmBps ) ) { removeBreakpointPromises . push ( this . removeBreakpointsAtUri ( uri ) ) ; } return Promise . all ( removeBreakpointPromises ) . then ( ( results ) => { return [ ] . concat . apply ( [ ] , results ) ; } ) ; } public async setBreakpoints ( logger , uri , breakpoints : DebugProtocol . SourceBreakpoint [ ] ) < VMBreakpoint [ ] > { await this . removeBreakpointsAtUri ( uri ) ; this . vmBps [ uri ] = [ ] ; return Promise . all ( breakpoints . map ( async ( bp ) => { try { const result = await this . manager . debugSession . observatory . addBreakpointWithScriptUri ( this . ref . id , uri , bp . line , bp . column ) ; const vmBp = ( result . result as VMBreakpoint ) ; this . vmBps [ uri ] . push ( vmBp ) ; this . breakpoints [ vmBp . id ] = bp ; return vmBp ; } catch ( e ) { logger . error ( e , LogCategory . Observatory ) ; return undefined ; } } ) , ) ; } private gotPauseStart = false ; private initialBreakpoints = false ; private hasConfigurationDone = false ; private hasPendingResume = false ; public receivedPauseStart ( ) { this . gotPauseStart = true ; this . paused = true ; this . checkResume ( ) ; } public setInitialBreakpoints ( ) { this . initialBreakpoints = true ; this . checkResume ( ) ; } public receivedConfigurationDone ( ) { this . hasConfigurationDone = true ; this . checkResume ( ) ; } public checkResume ( ) { if ( this . paused && this . gotPauseStart && this . initialBreakpoints && this . hasConfigurationDone ) this . resume ( ) ; } public handleResumed ( ) { this . manager . removeStoredData ( this ) ; this . atAsyncSuspension = false ; this . exceptionReference = 0 ; this . paused = false ; } public async resume ( step ? ) < void > { if ( ! this . paused || this . hasPendingResume ) return ; this . hasPendingResume = true ; try { await this . manager . debugSession . observatory . resume ( this . ref . id , step ) ; this . handleResumed ( ) ; } finally { this . hasPendingResume = false ; } } public getScript ( scriptRef ) < VMScript > { const scriptId = scriptRef . id ; if ( this . scriptCompleters [ scriptId ] ) { const completer < VMScript > = this . scriptCompleters [ scriptId ] ; return completer . promise ; } else { const completer < VMScript > = new PromiseCompleter ( ) ; this . scriptCompleters [ scriptId ] = completer ; const observatory = this . manager . debugSession . observatory ; observatory . getObject ( this . ref . id , scriptRef . id ) . then ( ( result ) => { const script = result . result as VMScript ; completer . resolve ( script ) ; } ) . catch ( ( error ) => { completer . reject ( error ) ; } ) ; return completer . promise ; } } public storeData ( data ) { return this . manager . storeData ( this , data ) ; } public handlePaused ( atAsyncSuspension ? , exception ? ) { this . atAsyncSuspension = atAsyncSuspension ; if ( exception ) { ( exception as InstanceWithEvaluateName ) . evaluateName = "s" ; this . exceptionReference = this . storeData ( exception ) ; } this . paused = true ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O $any$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $number$ O O O O O O $ThreadInfo[]$ O $any$ O O O O O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O O O O $boolean$ O O O O $VmExceptionMode$ O $any$ O O O O O O O $Logger$ O O O $DartDebugSession$ O O O O O $Promise$ O $VMIsolateRef$ O $string$ O O O O O O $ThreadInfo$ O O O $ThreadInfo$ O $VMIsolateRef$ O O O O O $ThreadInfo$ O O $ThreadInfo$ O O $any$ O O O $VMIsolateRef$ O O O $number$ O O O O $number$ O O O O $ThreadInfo[]$ O $number$ O $ThreadInfo$ O O O O $DartDebugSession$ O $any$ O O $any$ O O O $ThreadInfo$ O $number$ O O O O O O O $boolean$ O $ThreadInfo$ O $void$ O O O O O O $string$ O O O O $ThreadInfo$ O $boolean$ O O $ThreadInfo$ O $boolean$ O O O O O O O $DartDebugSession$ O $ObservatoryConnection$ O O O $PromiseConstructor$ O O O O O O $DartDebugSession$ O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $ThreadInfo$ O $VMIsolateRef$ O $string$ O O O $VmExceptionMode$ O O O O $Promise<void>$ O $ThreadInfo$ O $VMIsolateRef$ O O O O $Promise<void>$ O O O O O O $ThreadInfo$ O $void$ O O O O O O O $void$ O O O O O $boolean$ O O O O O O $ThreadInfo$ O O O $ThreadInfo[]$ O $ThreadInfo$ O $void$ O O O O O $ThreadInfo$ O $VMIsolateRef$ O O $any$ O O O O O O $ThreadInfo$ O O O $ThreadInfo[]$ O O O O $ThreadInfo$ O $VMIsolateRef$ O $string$ O $VMIsolateRef$ O $string$ O O $ThreadInfo$ O O O $undefined$ O O O $ThreadInfo$ O $number$ O O $any$ O O O O O O $ThreadInfo$ O O O $ThreadInfo[]$ O O O O $ThreadInfo$ O $number$ O $number$ O O $ThreadInfo$ O O O $undefined$ O O O $any[]$ O O O $any$ O O O O O O $ThreadInfo[]$ O $U[]$ O O $ThreadInfo$ O O O $any$ O $ThreadInfo$ O $number$ O $ThreadInfo$ O $VMIsolateRef$ O $string$ O O O O O $void$ O $VmExceptionMode$ O O O O $VmExceptionMode$ O $VmExceptionMode$ O O O O O O $DartDebugSession$ O $ObservatoryConnection$ O O O O O O $ThreadInfo$ O O O $ThreadInfo[]$ O O O O $ThreadInfo$ O $boolean$ O O O $VmExceptionMode$ O $VmExceptionMode$ O O O $VmExceptionMode$ O O O $ThreadInfo$ O $boolean$ O $VmExceptionMode$ O O O O O $DartDebugSession$ O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $ThreadInfo$ O $VMIsolateRef$ O $string$ O $VmExceptionMode$ O O O O O O O $Promise$ O $VMIsolateRef$ O O O O O O O O O $DartDebugSession$ O $boolean$ O O O O $DartDebugSession$ O $ObservatoryConnection$ O O O O $DebuggerResult$ O O O O $DartDebugSession$ O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $VMIsolateRef$ O $string$ O O O $VMIsolate$ O $DebuggerResult$ O $VMResponse$ O $any$ O O $PromiseConstructor$ O O O $VMIsolate$ O $VMLibraryRef[]$ O $complex$ O O $VMLibraryRef$ O O O O $DartDebugSession$ O $boolean$ O $VMLibraryRef$ O $string$ O O O $U[]$ O O $VMLibraryRef$ O O $PromiseConstructor$ O O O O O O O O O O $DartDebugSession$ O $ObservatoryConnection$ O O $PromiseConstructor$ O $complex$ O O O O O $boolean$ O O O O O O $DartDebugSession$ O $boolean$ O $VMLibraryRef$ O $string$ O O O O O $DartDebugSession$ O $boolean$ O O O O O $DartDebugSession$ O $boolean$ O $VMLibraryRef$ O $string$ O O O O O $DartDebugSession$ O $boolean$ O O O O O O $DartDebugSession$ O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $VMIsolate$ O $string$ O $VMLibraryRef$ O $string$ O $boolean$ O O O O O O $complex$ O O $any$ O O O O O $Logger$ O $void$ O $string$ O $any$ O O O O O O O O O $Promise$ O O O O O O O $any[]$ O O O O O O O $string$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O O $any[]$ O $number$ O O O $Promise<any[]>$ O $string$ O O O $complex$ O $string$ O O O O O O $PromiseConstructor$ O O O $any[]$ O O O O $Promise$ O $string$ O $any[]$ O $any$ O $any$ O O O O O O O O O O O $any[]$ O $number$ O O O O O O $complex$ O $string$ O O O O O $complex$ O $string$ O O $any[]$ O O $any$ O O O O $ThreadInfo$ O O O $ThreadInfo[]$ O O O O $ThreadInfo$ O $boolean$ O O O $Promise<VMBreakpoint[]>$ O $ThreadInfo$ O $Promise<VMBreakpoint[]>$ O O O $Logger$ O $string$ O $any[]$ O O O O O $any$ O $any$ O $Promise<VMBreakpoint[]>$ O O O O O $any$ O O $any$ O O $PromiseCompleter<boolean[]>$ O O $any$ O O O O O O O O $PromiseCompleter<boolean[]>$ O $void$ O $any[]$ O $U[]$ O O $any$ O O O O O O O $PromiseCompleter<boolean[]>$ O $Promise<boolean[]>$ O O O $number$ O O O O O O $complex$ O O O $number$ O O $any$ O O O O O O $number$ O $ThreadInfo$ O $VMResponse$ O O O $number$ O O O $number$ O O O $number$ O O O O $complex$ O $number$ O O O $any$ O $ThreadInfo$ O $VMResponse$ O O O $number$ O O O $StoredData$ O $number$ O O O O O $complex$ O $number$ O O O O $void$ O $ThreadInfo$ O O O O O $number$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O $U[]$ O O $string$ O O $number$ O $string$ O O O O O O O O O O $complex$ O $number$ O O $ThreadInfo$ O $number$ O $ThreadInfo$ O $number$ O O O O $complex$ O $number$ O O O O O $void$ O O O O O O $number$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O $U[]$ O O $string$ O O $number$ O $string$ O O O O O O O O O $complex$ O $number$ O O O O O $void$ O $VMIsolateRef$ O O O $ThreadInfo$ O O O $ThreadInfo$ O $VMIsolateRef$ O O O O $ThreadInfo$ O O O O $DartDebugSession$ O $any$ O O $any$ O O O $ThreadInfo$ O $number$ O O O O O $ThreadInfo[]$ O $complex$ O O O $ThreadInfo[]$ O $number$ O $ThreadInfo$ O O O O O O O $void$ O $ThreadInfo$ O O O O O O $any$ O O $ThreadInfo$ O $any$ O O $VMResponse$ O $any$ O O O $ThreadInfo$ O $VMResponse$ O O O O $ThreadInfo$ O $ThreadInfo$ O O O $VMResponse$ O $VMResponse$ O O O O O $any$ O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O O O $boolean$ O O O O O O $complex$ O O O $string$ O O $any$ O O O O O O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O O $boolean$ O O O O O O $number$ O O O O $boolean$ O O O O O O $boolean$ O O O O O O O O $VMIsolateRef$ O O O $VMIsolateRef$ O $string$ O $boolean$ O O O $VMIsolateRef$ O O O O O O O O O $ThreadManager$ O O O $VMIsolateRef$ O O O $number$ O O O O $Promise$ O $string$ O O $any$ O O O O O $any[]$ O O O O O $VMBreakpoint[]$ O O O $complex$ O $string$ O O O O $VMBreakpoint[]$ O O O O O $VMBreakpoint$ O $VMBreakpoint[]$ O O $any[]$ O $number$ O O O $ThreadManager$ O $DartDebugSession$ O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O O O $VMIsolateRef$ O $string$ O $VMBreakpoint$ O $string$ O O O O O O O $complex$ O $string$ O O O O $PromiseConstructor$ O O O $any[]$ O O O O $Promise$ O O O $any$ O O O O O $any[]$ O O O O O O O $string$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O O $any[]$ O $number$ O O O $Promise<DebuggerResult[]>$ O $string$ O O O O O $PromiseConstructor$ O O O $any[]$ O O O O O $any[]$ O O O O O O O $complex$ O $any$ O O O O $any[]$ O O O O O O O O $Promise$ O $Logger$ O $string$ O $any[]$ O $any$ O $any$ O O O O $any$ O O O O O O O $Promise<DebuggerResult[]>$ O $string$ O O O O $complex$ O $string$ O O O O O O $PromiseConstructor$ O O O $any[]$ O $U[]$ O O O $any$ O O O O O O $DebuggerResult$ O O O O $ThreadManager$ O $DartDebugSession$ O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O O O $VMIsolateRef$ O $string$ O $string$ O $any$ O $any$ O $any$ O $any$ O O O $VMBreakpoint$ O O $DebuggerResult$ O $VMResponse$ O $any$ O O O O $complex$ O $string$ O O $number$ O $VMBreakpoint$ O O O O $complex$ O $VMBreakpoint$ O $string$ O O $any$ O O $VMBreakpoint$ O O O O $any$ O O $Logger$ O $void$ O $any$ O $any$ O $LogCategory.Observatory$ O O O $undefined$ O O O O O O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $void$ O O O O O $boolean$ O O O O O $boolean$ O O O O O $void$ O O O O O $void$ O O O O O $boolean$ O O O O O $void$ O O O O O $void$ O O O O O $boolean$ O O O O O $void$ O O O O O $void$ O O O O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $Promise<void>$ O O O O O $void$ O O O O O $ThreadManager$ O $void$ O O O O O O $boolean$ O O O O O $number$ O O O O O $boolean$ O O O O O O $Promise$ O $string$ $string$ O O O O O O O O O O $boolean$ O O O $boolean$ O O O O O $boolean$ O O O O O O O O $ThreadManager$ O $DartDebugSession$ O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O O O $VMIsolateRef$ O $string$ O $string$ O O O O $void$ O O O O O O O O $boolean$ O O O O O O $Promise$ O $VMScriptRef$ O O $any$ O O O $string$ O $VMScriptRef$ O $string$ O O O O O $complex$ O $string$ O O O O $PromiseCompleter$ O $any$ O O O O $complex$ O $string$ O O O $PromiseCompleter<VMScript>$ O $Promise<VMScript>$ O O O O O $PromiseCompleter$ O $any$ O O O $any$ O O O O O $complex$ O $string$ O O $PromiseCompleter<VMScript>$ O O $ObservatoryConnection$ O O O $ThreadManager$ O $DartDebugSession$ O $ObservatoryConnection$ O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O O O $VMIsolateRef$ O $string$ O $VMScriptRef$ O $string$ O O O O O $DebuggerResult$ O O O O $VMScript$ O $DebuggerResult$ O $VMResponse$ O $any$ O $PromiseCompleter<VMScript>$ O $void$ O $VMScript$ O O O O O $complex$ O O $any$ O O O $PromiseCompleter<VMScript>$ O $void$ O $any$ O O O O O O $PromiseCompleter<VMScript>$ O $Promise<VMScript>$ O O O O $number$ O $VMResponse$ O O O O O $ThreadManager$ O $number$ O O O $VMResponse$ O O O O $void$ O $boolean$ $boolean$ O $VMInstanceRef$ $VMInstanceRef$ O O O O $boolean$ O $boolean$ O O O $VMInstanceRef$ O O O $VMInstanceRef$ O $any$ O O $string$ O O O O O $number$ O O O $number$ O $VMInstanceRef$ O O O O O $boolean$ O O O O O
import { DebugProtocol } from "s" ; import { forceWindowsDriveLetterToUppercase } from "s" ; export function formatPathForVm ( file ) { file = forceWindowsDriveLetterToUppercase ( file ) ; file = file . replace ( "s" , "s" ) ; file = file . replace ( "s" , "s" ) ; file = file . replace ( "s" , "s" ) ; if ( file . startsWith ( "s" ) ) return file ; else return `template` ; } export interface DartLaunchRequestArguments extends DebugProtocol . LaunchRequestArguments { name : string ; type : string ; request : string ; cwd ? : string ; enableAsserts : boolean ; dartPath : string ; debugSdkLibraries : boolean ; debugExternalLibraries : boolean ; showDartDeveloperLogs : boolean ; useFlutterStructuredErrors : boolean ; debuggerHandlesPathsEverywhereForBreakpoints : boolean ; evaluateGettersInDebugViews : boolean ; env : any ; program : string ; args : string [ ] ; vmAdditionalArgs : string [ ] ; vmServicePort : number ; observatoryLogFile ? : string ; webDaemonLogFile ? : string ; maxLogLineLength : number ; pubPath : string ; pubSnapshotPath : string ; pubTestLogFile ? : string ; showMemoryUsage : boolean ; } export interface FlutterLaunchRequestArguments extends DartLaunchRequestArguments { deviceId ? : string ; deviceName ? : string ; forceFlutterVerboseMode ? : boolean ; flutterTrackWidgetCreation : boolean ; flutterPath : string ; flutterMode ? : "s" | "s" | "s" ; flutterPlatform ? : "s" | "s" | "s" | "s" | "s" ; flutterRunLogFile ? : string ; flutterTestLogFile ? : string ; } export interface DartAttachRequestArguments extends DebugProtocol . AttachRequestArguments { type : string ; request : string ; cwd : string ; program : string ; debugSdkLibraries : boolean ; debugExternalLibraries : boolean ; showDartDeveloperLogs : boolean ; evaluateGettersInDebugViews : boolean ; maxLogLineLength : number ; packages : string ; observatoryUri : string ; observatoryLogFile : string ; } export interface FlutterAttachRequestArguments extends DartAttachRequestArguments { deviceId : string ; flutterPath : string ; } export interface CoverageData { scriptPath : string ; hitLines : number [ ] ; } export interface FileLocation { line : number ; column : number ; }	O O $any$ O O O O O O $string$ O O O O O O $string$ O $string$ O O $string$ O $string$ O $string$ O O $string$ O $string$ O $complex$ O O O O O O $string$ O $string$ O $complex$ O O O O O O $string$ O $string$ O $complex$ O O O O O O O O $string$ O $boolean$ O O O O O $string$ O O O O O O O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $boolean$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $any$ O O O $string$ O O O $string[]$ O O O O O $string[]$ O O O O O $number$ O O O $string$ O O O O $string$ O O O O $number$ O O O $string$ O O O $string$ O O O $string$ O O O O $boolean$ O O O O O O $any$ O $any$ O $string$ O O O O $string$ O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O $string$ O O O O O O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $number$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O $any$ O $string$ O O O $number[]$ O O O O O O O O $any$ O $number$ O O O $number$ O O O O
import * as child_process from "s" ; import * as fs from "s" ; import * as path from "s" ; import { DebugSession , Event , InitializedEvent , OutputEvent , Scope , Source , StackFrame , StoppedEvent , TerminatedEvent } from "s" ; import { DebugProtocol } from "s" ; import { config } from "s" ; import { getLogHeader } from "s" ; import { safeSpawn } from "s" ; import { VmServiceCapabilities } from "s" ; import { observatoryListeningBannerPattern , pleaseReportBug } from "s" ; import { LogCategory , LogSeverity } from "s" ; import { LogMessage } from "s" ; import { PackageMap } from "s" ; import { errorString , flatMap , throttle , uniq , uriToFilePath } from "s" ; import { sortBy } from "s" ; import { applyColor , grey , 0 } from "s" ; import { DebuggerResult , ObservatoryConnection , SourceReportKind , Version , VM , VMClass , VMClassRef , VMErrorRef , VMEvent , VMFrame , VMInstance , VMInstanceRef , VMIsolate , VMIsolateRef , VMLibrary , VMMapEntry , VMObj , VMScript , VMScriptRef , VMSentinel , VMSourceReport , VMStack , VMTypeRef } from "s" ; import { DebugAdapterLogger } from "s" ; import { ThreadInfo , ThreadManager } from "s" ; import { CoverageData , DartAttachRequestArguments , DartLaunchRequestArguments , FileLocation , formatPathForVm } from "s" ; const maxValuesToCallToString = 0 ; const unoptimizedPrefix = "s" ; const stackFrameWithUriPattern = new RegExp ( `template` , "s" ) ; const webStackFrameWithUriPattern = new RegExp ( `template` , "s" ) ; const messageWithUriPattern = new RegExp ( `template` , "s" ) ; export class DartDebugSession extends DebugSession { protected childProcess ? : child_process . ChildProcess ; protected additionalPidsToTerminate : number [ ] = [ ] ; protected allowTerminatingObservatoryVmPid = true ; protected connectVmEvenForNoDebug = false ; protected processExited = false ; public observatory ? : ObservatoryConnection ; protected cwd ? : string ; public noDebug ? : boolean ; private logFile ? : string ; private logStream ? : fs . WriteStream ; public debugSdkLibraries = false ; public debugExternalLibraries = false ; public showDartDeveloperLogs = true ; public useFlutterStructuredErrors = false ; public evaluateGettersInDebugViews = false ; public debuggerHandlesPathsEverywhereForBreakpoints : boolean ; protected threadManager : ThreadManager ; public packageMap ? : PackageMap ; protected sendStdOutToConsole : boolean = true ; protected supportsObservatory : boolean = true ; protected parseObservatoryUriFromStdOut : boolean = true ; protected requiresProgram : boolean = true ; protected pollforMemoryMs ? : number ; protected processExit : Promise < void > = Promise . resolve ( ) ; protected maxLogLineLength : number = 0 ; protected shouldKillProcessOnTerminate = true ; protected logCategory = LogCategory . General ; private readonly logger = new DebugAdapterLogger ( this , LogCategory . Observatory ) ; protected readonly capabilities = VmServiceCapabilities . empty ; protected get shouldConnectDebugger ( ) { return ! this . noDebug || this . connectVmEvenForNoDebug ; } public constructor ( ) { super ( ) ; this . threadManager = new ThreadManager ( this . logger , this ) ; } protected initializeRequest ( response : DebugProtocol . InitializeResponse , args : DebugProtocol . InitializeRequestArguments , ) { response . body = response . body || { } ; response . body . supportsConfigurationDoneRequest = true ; response . body . supportsEvaluateForHovers = true ; response . body . supportsDelayedStackTraceLoading = true ; response . body . supportsConditionalBreakpoints = true ; response . body . supportsLogPoints = true ; response . body . supportsTerminateRequest = true ; response . body . exceptionBreakpointFilters = [ { filter : "s" , label : "s" , default : false } , { filter : "s" , label : "s" , default : true } , ] ; this . sendResponse ( response ) ; } protected launchRequest ( response : DebugProtocol . LaunchResponse , args ) { if ( ! args || ! args . dartPath || ( this . requiresProgram && ! args . program ) ) { this . logToUser ( "s" ) ; this . sendEvent ( new TerminatedEvent ( ) ) ; return ; } if ( args . program && ! path . isAbsolute ( args . program ) ) { if ( ! args . cwd ) { this . logToUser ( "s" ) ; this . sendEvent ( new TerminatedEvent ( ) ) ; return ; } args . program = path . join ( args . cwd , args . program ) ; } this . shouldKillProcessOnTerminate = true ; this . cwd = args . cwd ; this . noDebug = args . noDebug ; this . threadManager . setExceptionPauseMode ( this . noDebug ? "s" : "s" ) ; this . packageMap = new PackageMap ( PackageMap . findPackagesFile ( args . program || args . cwd ) ) ; this . debugSdkLibraries = args . debugSdkLibraries ; this . debugExternalLibraries = args . debugExternalLibraries ; this . showDartDeveloperLogs = args . showDartDeveloperLogs ; this . useFlutterStructuredErrors = args . useFlutterStructuredErrors ; this . evaluateGettersInDebugViews = args . evaluateGettersInDebugViews ; this . debuggerHandlesPathsEverywhereForBreakpoints = args . debuggerHandlesPathsEverywhereForBreakpoints ; this . logFile = args . observatoryLogFile ; this . maxLogLineLength = args . maxLogLineLength ; this . sendResponse ( response ) ; this . childProcess = this . spawnProcess ( args ) ; const process = this . childProcess ; this . processExited = false ; this . processExit = new Promise ( ( resolve ) => process . on ( "s" , resolve ) ) ; process . stdout . setEncoding ( "s" ) ; process . stdout . on ( "s" , ( data ) => { let match : RegExpExecArray | null = null ; if ( this . shouldConnectDebugger && this . parseObservatoryUriFromStdOut && ! this . observatory ) { match = observatoryListeningBannerPattern . exec ( data . toString ( ) ) ; } if ( match ) { this . initDebugger ( this . websocketUriForObservatoryUri ( match [ 0 ] ) ) ; } else if ( this . sendStdOutToConsole ) this . logToUser ( data . toString ( ) , "s" ) ; } ) ; process . stderr . setEncoding ( "s" ) ; process . stderr . on ( "s" , ( data ) => { this . logToUser ( data . toString ( ) , "s" ) ; } ) ; process . on ( "s" , ( error ) => { this . logToUser ( `template` , "s" ) ; } ) ; process . on ( "s" , async ( code , signal ) => { this . processExited = true ; this . log ( `template` ) ; if ( ! code && ! signal ) this . logToUser ( "s" ) ; else this . logToUser ( `template` ) ; await Promise . race ( [ this . lastLoggingEvent , new Promise ( ( resolve ) => setTimeout ( resolve , 0 ) ) , ] ) ; this . sendEvent ( new TerminatedEvent ( ) ) ; } ) ; if ( ! this . shouldConnectDebugger ) this . sendEvent ( new InitializedEvent ( ) ) ; } protected async attachRequest ( response : DebugProtocol . AttachResponse , args ) < void > { if ( ! args || ! args . observatoryUri ) { return this . errorResponse ( response , "s" ) ; } this . shouldKillProcessOnTerminate = false ; this . cwd = args . cwd ; this . debugSdkLibraries = args . debugSdkLibraries ; this . debugExternalLibraries = args . debugExternalLibraries ; this . showDartDeveloperLogs = args . showDartDeveloperLogs ; this . evaluateGettersInDebugViews = args . evaluateGettersInDebugViews ; this . logFile = args . observatoryLogFile ; this . maxLogLineLength = args . maxLogLineLength ; this . log ( `template` ) ; if ( args . packages ) { if ( args . packages && ! path . isAbsolute ( args . packages ) ) args . packages = path . join ( args . cwd , args . packages ) ; try { this . packageMap = new PackageMap ( PackageMap . findPackagesFile ( args . packages ) ) ; } catch ( e ) { this . errorResponse ( response , `template` ) ; } } try { await this . initDebugger ( this . websocketUriForObservatoryUri ( args . observatoryUri ) ) ; this . sendResponse ( response ) ; } catch ( e ) { this . errorResponse ( response , `template` ) ; } } protected sourceFileForArgs ( args ) { return path . relative ( args . cwd ! , args . program ) ; } protected spawnProcess ( args ) { let appArgs = [ ] ; if ( this . shouldConnectDebugger ) { appArgs . push ( `template` ) ; appArgs . push ( "s" ) ; } if ( args . enableAsserts !== false ) { appArgs . push ( "s" ) ; } if ( args . vmAdditionalArgs ) { appArgs = appArgs . concat ( args . vmAdditionalArgs ) ; } appArgs . push ( this . sourceFileForArgs ( args ) ) ; if ( args . args ) { appArgs = appArgs . concat ( args . args ) ; } this . log ( `template` ) ; if ( args . cwd ) this . log ( `template` ) ; const process = safeSpawn ( args . cwd , args . dartPath , appArgs , args . env ) ; this . log ( `template` ) ; return process ; } protected websocketUriForObservatoryUri ( uri ) { const wsUri = uri . trim ( ) ; if ( wsUri . endsWith ( "s" ) ) return wsUri ; else if ( wsUri . endsWith ( "s" ) ) return wsUri . substr ( 0 , wsUri . length - 0 ) ; else if ( wsUri . endsWith ( "s" ) ) return `template` ; else return `template` ; } protected log ( message , severity = LogSeverity . Info ) { if ( this . logFile ) { if ( ! this . logStream ) { this . logStream = fs . createWriteStream ( this . logFile ) ; this . logStream . write ( getLogHeader ( ) ) ; } this . logStream . write ( `template` ) ; if ( this . maxLogLineLength && message . length > this . maxLogLineLength ) this . logStream . write ( message . substring ( 0 , this . maxLogLineLength ) + "s" ) ; else this . logStream . write ( message . trim ( ) + "s" ) ; } this . sendEvent ( new Event ( "s" , { message , severity , category : LogCategory . Observatory } as LogMessage ) ) ; } protected async initDebugger ( uri ) < void > { let browserFriendlyUri ; if ( uri . endsWith ( "s" ) ) { browserFriendlyUri = uri . substring ( 0 , uri . length - 0 ) ; if ( browserFriendlyUri . startsWith ( "s" ) ) browserFriendlyUri = "s" + browserFriendlyUri . substring ( 0 ) ; } else { browserFriendlyUri = uri ; } this . sendEvent ( new Event ( "s" , { observatoryUri : this . supportsObservatory ? browserFriendlyUri . toString ( ) : undefined , vmServiceUri : browserFriendlyUri . toString ( ) , } ) ) ; if ( ! this . shouldConnectDebugger ) return ; return new Promise < void > ( ( resolve , reject ) => { this . log ( `template` ) ; this . observatory = new ObservatoryConnection ( uri ) ; this . observatory . onLogging ( ( message ) => this . log ( message ) ) ; this . observatory . onOpen ( ( ) => { if ( ! this . observatory ) return ; this . observatory . getVersion ( ) . then ( ( versionResult ) => { const version = versionResult . result as Version ; this . capabilities . version = `template` ; if ( ! this . observatory ) return ; this . observatory . getVM ( ) . then ( async ( vmResult ) : Promise < void > => { if ( ! this . observatory ) return ; const vm = vmResult . result as VM ; this . subscribeToStreams ( ) ; if ( this . allowTerminatingObservatoryVmPid && this . childProcess && this . childProcess . pid !== vm . pid ) { this . additionalPidsToTerminate . push ( vm . pid ) ; } const isolates = await Promise . all ( vm . isolates . map ( ( isolateRef ) => this . observatory ! . getIsolate ( isolateRef . id ) ) ) ; const rootIsolateResult = isolates . find ( ( isolate ) => ! ! ( isolate . result as VMIsolate ) . rootLib ) ; const rootIsolate = rootIsolateResult && rootIsolateResult . result as VMIsolate ; if ( rootIsolate && rootIsolate . extensionRPCs ) { rootIsolate . extensionRPCs . forEach ( ( id ) => this . notifyServiceExtensionAvailable ( id , rootIsolate . id ) ) ; } if ( ! this . packageMap ) { if ( rootIsolate && rootIsolate . rootLib ) this . packageMap = new PackageMap ( PackageMap . findPackagesFile ( this . convertVMUriToSourcePath ( rootIsolate . rootLib . uri ) ) ) ; } await Promise . all ( isolates . map ( async ( response ) => { const isolate = response . result as VMIsolate ; this . threadManager . registerThread ( isolate , isolate . runnable ? "s" : "s" , ) ; if ( isolate . pauseEvent . kind . startsWith ( "s" ) ) { await this . handlePauseEvent ( isolate . pauseEvent ) ; } } ) ) ; if ( this . pollforMemoryMs ) setTimeout ( ( ) => this . pollForMemoryUsage ( ) , this . pollforMemoryMs ) ; this . sendEvent ( new InitializedEvent ( ) ) ; } ) ; } ) ; resolve ( ) ; } ) ; this . observatory . onClose ( ( code , message ) => { this . log ( `template` ) ; if ( this . logStream ) { this . logStream . end ( ) ; this . logStream = undefined ; this . logFile = undefined ; } if ( ! this . childProcess ) { this . sendEvent ( new TerminatedEvent ( ) ) ; } else { setTimeout ( ( ) => { if ( ! this . processExited ) this . sendEvent ( new TerminatedEvent ( ) ) ; } , 0 ) ; } } ) ; this . observatory . onError ( ( error ) => { reject ( error ) ; } ) ; } ) ; } private subscribeToStreams ( ) { if ( ! this . observatory ) return ; this . observatory . on ( "s" , ( event ) => this . handleIsolateEvent ( event ) ) ; this . observatory . on ( "s" , ( event ) => this . handleExtensionEvent ( event ) ) ; this . observatory . on ( "s" , ( event ) => this . handleDebugEvent ( event ) ) ; const serviceStreamName = this . capabilities . serviceStreamIsPublic ? "s" : "s" ; this . observatory . on ( serviceStreamName , ( event ) => this . handleServiceEvent ( event ) ) ; if ( this . capabilities . hasLoggingStream && this . showDartDeveloperLogs ) { this . observatory . on ( "s" , ( event ) => this . handleLoggingEvent ( event ) ) . catch ( ( e ) => { this . logger . info ( errorString ( e ) ) ; } ) ; } } protected async terminate ( force ) < void > { const signal = force ? "s" : "s" ; const request = force ? "s" : "s" ; this . log ( `template` ) ; if ( this . shouldKillProcessOnTerminate && this . childProcess && ! this . processExited ) { this . log ( `template` ) ; for ( const pid of this . additionalPidsToTerminate ) { try { this . log ( `template` ) ; process . kill ( pid , signal ) ; } catch ( e ) { } } if ( ! this . processExited ) { try { this . log ( `template` ) ; this . childProcess . kill ( signal ) ; } catch ( e ) { } } else { this . log ( `template` ) ; } } else if ( ! this . shouldKillProcessOnTerminate && this . observatory ) { try { this . log ( `template` ) ; await await Promise . race ( [ Promise . all ( this . threadManager . threads . map ( ( thread ) => thread . removeAllBreakpoints ( ) ) ) , new Promise ( ( resolve ) => setTimeout ( resolve , 0 ) ) , ] ) ; this . log ( `template` ) ; await Promise . race ( [ Promise . all ( this . threadManager . threads . map ( ( thread ) => thread . resume ( ) ) ) , new Promise ( ( resolve ) => setTimeout ( resolve , 0 ) ) , ] ) ; } catch { } try { this . log ( `template` ) ; this . observatory . close ( ) ; } catch { } finally { this . observatory = undefined ; } } else { this . log ( `template` ) ; } this . log ( `template` ) ; this . threadManager . removeAllStoredData ( ) ; this . log ( `template` ) ; await this . processExit ; this . log ( `template` ) ; } protected async terminateRequest ( response : DebugProtocol . TerminateResponse , args : DebugProtocol . TerminateArguments , ) < void > { this . log ( `template` ) ; try { await this . terminate ( false ) ; } catch ( e ) { return this . errorResponse ( response , `template` ) ; } super . terminateRequest ( response , args ) ; } protected async disconnectRequest ( response : DebugProtocol . DisconnectResponse , args : DebugProtocol . DisconnectArguments , ) < void > { this . log ( `template` ) ; try { const didTimeout = await Promise . race ( [ this . terminate ( false ) . then ( ( _ ) => false ) , new Promise ( ( resolve ) => setTimeout ( ( ) => resolve ( true ) , 0 ) ) , ] ) ; if ( didTimeout ) await this . terminate ( true ) ; } catch ( e ) { return this . errorResponse ( response , `template` ) ; } super . disconnectRequest ( response , args ) ; } protected async setBreakPointsRequest ( response : DebugProtocol . SetBreakpointsResponse , args : DebugProtocol . SetBreakpointsArguments , ) < void > { if ( this . noDebug ) { response . body = { breakpoints : ( args . breakpoints || [ ] ) . map ( ( b ) => ( { verified : false } ) ) } ; this . sendResponse ( response ) ; return ; } const source : DebugProtocol . Source = args . source ; const breakpoints : DebugProtocol . SourceBreakpoint [ ] = args . breakpoints || [ ] ; const mapToPackagePath = this . packageMap && ! this . debuggerHandlesPathsEverywhereForBreakpoints ; const uri = mapToPackagePath ? ( this . packageMap . convertFileToPackageUri ( source . path ) || formatPathForVm ( source . path || source . name ) ! ) : formatPathForVm ( source . path || source . name ) ; try { const result = await this . threadManager . setBreakpoints ( uri , breakpoints ) ; const bpResponse = [ ] ; for ( const bpRes of result ) { bpResponse . push ( { verified : ! ! bpRes } ) ; } response . body = { breakpoints : bpResponse } ; this . sendResponse ( response ) ; } catch ( error ) { this . errorResponse ( response , `template` ) ; } } protected setExceptionBreakPointsRequest ( response : DebugProtocol . SetExceptionBreakpointsResponse , args : DebugProtocol . SetExceptionBreakpointsArguments , ) { const filters : string [ ] = args . filters ; let mode = "s" ; if ( ! this . noDebug ) { if ( filters . indexOf ( "s" ) !== - 0 ) mode = "s" ; if ( filters . indexOf ( "s" ) !== - 0 ) mode = "s" ; } this . threadManager . setExceptionPauseMode ( mode ) ; this . sendResponse ( response ) ; } protected configurationDoneRequest ( response : DebugProtocol . ConfigurationDoneResponse , args : DebugProtocol . ConfigurationDoneArguments , ) { this . sendResponse ( response ) ; this . threadManager . receivedConfigurationDone ( ) ; } protected pauseRequest ( response : DebugProtocol . PauseResponse , args : DebugProtocol . PauseArguments ) { const thread = this . threadManager . getThreadInfoFromNumber ( args . threadId ) ; if ( ! thread ) { this . errorResponse ( response , `template` ) ; return ; } if ( ! this . observatory ) { this . errorResponse ( response , `template` ) ; return ; } this . observatory . pause ( thread . ref . id ) . then ( ( _ ) => this . sendResponse ( response ) ) . catch ( ( error ) => this . errorResponse ( response , `template` ) ) ; } protected sourceRequest ( response : DebugProtocol . SourceResponse , args : DebugProtocol . SourceArguments ) { const sourceReference = args . sourceReference ; const data = this . threadManager . getStoredData ( sourceReference ) ; const scriptRef = data . data as VMScriptRef ; data . thread . getScript ( scriptRef ) . then ( ( script ) => { if ( script . source ) { response . body = { content : script . source } ; } else { response . success = false ; response . message = "s" ; } this . sendResponse ( response ) ; } ) . catch ( ( error ) => this . errorResponse ( response , `template` ) ) ; } protected threadsRequest ( response : DebugProtocol . ThreadsResponse ) { response . body = { threads : this . threadManager . getThreads ( ) } ; this . sendResponse ( response ) ; } protected stackTraceRequest ( response : DebugProtocol . StackTraceResponse , args : DebugProtocol . StackTraceArguments ) { const thread = this . threadManager . getThreadInfoFromNumber ( args . threadId ) ; const startFrame = args . startFrame || 0 ; let levels = args . levels ; if ( ! thread ) { this . errorResponse ( response , `template` ) ; return ; } if ( ! this . observatory ) { this . errorResponse ( response , `template` ) ; return ; } this . observatory . getStack ( thread . ref . id ) . then ( ( result ) => { const stack = result . result as VMStack ; let vmFrames = stack . asyncCausalFrames || stack . frames ; const totalFrames = vmFrames . length ; if ( ! levels ) levels = totalFrames ; if ( startFrame + levels > totalFrames ) levels = totalFrames - startFrame ; vmFrames = vmFrames . slice ( startFrame , startFrame + levels ) ; const stackFrames : DebugProtocol . StackFrame [ ] = [ ] ; const promises < Promise < void > > = [ ] ; vmFrames . forEach ( ( frame ) => { const frameId = thread . storeData ( frame ) ; if ( frame . kind === "s" ) { const stackFrame : DebugProtocol . StackFrame = new StackFrame ( frameId , "s" ) ; stackFrame . presentationHint = "s" ; stackFrames . push ( stackFrame ) ; return ; } const frameName = frame && frame . code && frame . code . name ? ( frame . code . name . startsWith ( unoptimizedPrefix ) ? frame . code . name . substring ( unoptimizedPrefix . length ) : frame . code . name ) : "s" ; const location = frame . location ; if ( ! location ) { const stackFrame : DebugProtocol . StackFrame = new StackFrame ( frameId , frameName ) ; stackFrame . presentationHint = "s" ; stackFrames . push ( stackFrame ) ; return ; } const uri = location . script . uri ; let sourcePath = this . convertVMUriToSourcePath ( uri ) ; let canShowSource = sourcePath && fs . existsSync ( sourcePath ) ; let sourceReference : number | undefined ; if ( uri . startsWith ( "s" ) ) { sourcePath = undefined ; sourceReference = thread . storeData ( location . script ) ; canShowSource = true ; } const shortName = this . formatUriForShortDisplay ( uri ) ; const stackFrame : DebugProtocol . StackFrame = new StackFrame ( frameId , frameName , canShowSource ? new Source ( shortName , sourcePath , sourceReference , undefined , location . script ) : undefined , 0 , 0 , ) ; const isTopFrame = stackFrames . length === 0 ; const isStoppedAtException = thread . exceptionReference !== 0 ; const allowDeemphasizingFrame = ! isTopFrame || isStoppedAtException ; if ( stackFrame . source && allowDeemphasizingFrame ) { if ( ! this . isValidToDebug ( uri ) || ( this . isSdkLibrary ( uri ) && ! this . debugSdkLibraries ) ) { stackFrame . source . origin = "s" ; stackFrame . source . presentationHint = "s" ; } else if ( this . isExternalLibrary ( uri ) && ! this . debugExternalLibraries ) { stackFrame . source . origin = uri . startsWith ( "s" ) ? "s" : "s" ; stackFrame . source . presentationHint = "s" ; } } stackFrames . push ( stackFrame ) ; const promise = thread . getScript ( location . script ) . then ( ( script ) => { const fileLocation = this . resolveFileLocation ( script , location . tokenPos ) ; if ( fileLocation ) { stackFrame . line = fileLocation . line ; stackFrame . column = fileLocation . column ; } } ) ; promises . push ( promise ) ; } ) ; response . body = { stackFrames , totalFrames , } ; Promise . all ( promises ) . then ( ( _ ) => { this . sendResponse ( response ) ; } ) . catch ( ( _ ) => { this . sendResponse ( response ) ; } ) ; } ) . catch ( ( error ) => this . errorResponse ( response , `template` ) ) ; } protected scopesRequest ( response : DebugProtocol . ScopesResponse , args : DebugProtocol . ScopesArguments ) { const frameId = args . frameId ; const data = this . threadManager . getStoredData ( frameId ) ; const frame = data . data as VMFrame ; const variablesReference = data . thread . storeData ( frame ) ; const scopes : Scope [ ] = [ ] ; if ( data . thread . exceptionReference ) { scopes . push ( new Scope ( "s" , data . thread . exceptionReference ) ) ; } scopes . push ( new Scope ( "s" , variablesReference ) ) ; response . body = { scopes } ; this . sendResponse ( response ) ; } protected async variablesRequest ( response : DebugProtocol . VariablesResponse , args : DebugProtocol . VariablesArguments ) < void > { if ( ! this . observatory ) { this . errorResponse ( response , `template` ) ; return ; } const variablesReference = args . variablesReference ; const start = args . start || 0 ; const count = args . count ; const data = this . threadManager . getStoredData ( variablesReference ) ; const thread = data . thread ; if ( data . data . type === "s" ) { const frame = data . data as VMFrame ; let variables : DebugProtocol . Variable [ ] = [ ] ; if ( frame . vars ) { const framePromises = frame . vars . filter ( ( variable ) => ! variable . value || variable . value . type !== "s" ) . map ( ( variable , i ) => this . instanceRefToVariable ( thread , true , variable . name , variable . name , variable . value , i <= maxValuesToCallToString ) ) ; const frameVariables = await Promise . all ( framePromises ) ; variables = variables . concat ( frameVariables ) ; } response . body = { variables } ; this . sendResponse ( response ) ; } else if ( data . data . type === "s" ) { const mapRef = data . data as VMMapEntry ; const results = await Promise . all ( [ this . observatory . getObject ( thread . ref . id , mapRef . keyId ) , this . observatory . getObject ( thread . ref . id , mapRef . valueId ) , ] ) ; const variables : DebugProtocol . Variable [ ] = [ ] ; const [ keyDebuggerResult , valueDebuggerResult ] = results ; const keyInstanceRef = keyDebuggerResult . result as VMInstanceRef ; const valueInstanceRef = valueDebuggerResult . result as VMInstanceRef ; variables . push ( await this . instanceRefToVariable ( thread , false , "s" , "s" , keyInstanceRef , true ) ) ; let canEvaluateValueName = false ; let valueEvaluateName = "s" ; if ( this . isSimpleKind ( keyInstanceRef . kind ) ) { canEvaluateValueName = true ; valueEvaluateName = `template` ; } variables . push ( await this . instanceRefToVariable ( thread , canEvaluateValueName , valueEvaluateName , "s" , valueInstanceRef , true ) ) ; response . body = { variables } ; this . sendResponse ( response ) ; } else { const instanceRef = data . data as InstanceWithEvaluateName ; try { const result = await this . observatory . getObject ( thread . ref . id , instanceRef . id , start , count ) ; let variables : DebugProtocol . Variable [ ] = [ ] ; const canEvaluate = instanceRef . evaluateName !== undefined ; if ( result . result . type === "s" ) { variables . push ( { name : "s" , value : ( result . result as VMSentinel ) . valueAsString , variablesReference : 0 , } ) ; } else { const obj = result . result as VMObj ; if ( obj . type === "s" ) { const instance = obj as VMInstance ; if ( this . isSimpleKind ( instance . kind ) ) { variables . push ( await this . instanceRefToVariable ( thread , canEvaluate , `template` , instance . kind , instanceRef , true ) ) ; } else if ( instance . elements ) { const len = instance . elements . length ; const elementPromises = instance . elements . map ( async ( element , i ) => this . instanceRefToVariable ( thread , canEvaluate , `template` , `template` , element , len <= maxValuesToCallToString ) ) ; const elementVariables = await Promise . all ( elementPromises ) ; variables = variables . concat ( elementVariables ) ; } else if ( instance . associations ) { const len = instance . associations . length ; for ( let i = 0 ; i < len ; i ++ ) { const association = instance . associations [ i ] ; const keyName = this . valueAsString ( association . key , true ) ; const valueName = this . valueAsString ( association . value , true ) ; let variablesReference = 0 ; if ( association . key . type !== "s" && association . value . type !== "s" ) { const mapRef = { keyId : ( association . key as VMInstanceRef ) . id , mapEvaluateName : instanceRef . evaluateName , type : "s" , valueId : ( association . value as VMInstanceRef ) . id , } ; variablesReference = thread . storeData ( mapRef ) ; } variables . push ( { name : `template` , type : `template` , value : `template` , variablesReference , } ) ; } } else if ( instance . fields ) { let fieldAndGetterPromises < Promise < DebugProtocol . Variable > > = [ ] ; const fields = sortBy ( instance . fields , ( f ) => f . decl . name ) ; const fieldPromises = fields . map ( async ( field , i ) => this . instanceRefToVariable ( thread , canEvaluate , `template` , field . decl . name , field . value , i <= maxValuesToCallToString ) ) ; fieldAndGetterPromises = fieldAndGetterPromises . concat ( fieldPromises ) ; if ( this . evaluateGettersInDebugViews && instance . class ) { let getterNames = await this . getGetterNamesForHierarchy ( thread . ref , instance . class ) ; getterNames = getterNames . sort ( ) ; const getterPromises = getterNames . map ( async ( getterName , i ) => { try { const getterResult = await this . observatory ! . evaluate ( thread . ref . id , instanceRef . id , getterName , true ) ; if ( getterResult . result . type === "s" ) { return { name : getterName , value : ( getterResult . result as VMErrorRef ) . message , variablesReference : 0 } ; } else if ( getterResult . result . type === "s" ) { return { name : getterName , value : ( getterResult . result as VMSentinel ) . valueAsString , variablesReference : 0 } ; } else { const getterResultInstanceRef = getterResult . result as VMInstanceRef ; return this . instanceRefToVariable ( thread , canEvaluate , `template` , getterName , getterResultInstanceRef , instance . fields ! . length + i <= maxValuesToCallToString , ) ; } } catch ( e ) { return { name : getterName , value : `template` , variablesReference : 0 } ; } } ) ; fieldAndGetterPromises = fieldAndGetterPromises . concat ( getterPromises ) ; const fieldAndGetterVariables = await Promise . all ( fieldAndGetterPromises ) ; variables = variables . concat ( fieldAndGetterVariables ) ; } await Promise . all ( fieldAndGetterPromises ) ; } else { this . logToUser ( `template` ) ; } } else { this . logToUser ( `template` ) ; } } response . body = { variables } ; this . sendResponse ( response ) ; } catch ( error ) { response . body = { variables : [ { name : "s" , value : `template` , variablesReference : 0 } , ] , } ; this . sendResponse ( response ) ; } } } private async getGetterNamesForHierarchy ( thread , classRef : VMClassRef | undefined ) < string [ ] > { let getterNames : string [ ] = [ ] ; while ( this . observatory && classRef ) { const classResponse = await this . observatory . getObject ( thread . id , classRef . id ) ; if ( classResponse . result . type !== "s" ) break ; const c = classResponse . result as VMClass ; getterNames = getterNames . concat ( getterNames , c . functions . filter ( ( f ) => f . _kind === "s" && ! f . static && ! f . const ) . map ( ( f ) => f . name ) ) ; classRef = c . super ; } getterNames = uniq ( getterNames ) ; return getterNames . filter ( ( g ) => g !== "s" ) ; } private isSimpleKind ( kind ) { return kind === "s" || kind === "s" || kind === "s" || kind === "s" || kind === "s" || kind === "s" ; } private async callToString ( isolate , instanceRef , getFullString = false ) < string | undefined > { try { const result = await this . observatory ! . evaluate ( isolate . id , instanceRef . id , "s" , true ) ; if ( result . result . type === "s" ) { return undefined ; } else { let evalResult = result . result as VMInstanceRef ; if ( evalResult . valueAsStringIsTruncated && getFullString ) { const result = await this . observatory ! . getObject ( isolate . id , evalResult . id ) ; evalResult = result . result as VMInstanceRef ; } return this . valueAsString ( evalResult , undefined , true ) ; } } catch ( e ) { this . logger . error ( e , LogCategory . Observatory ) ; return undefined ; } } protected setVariableRequest ( response : DebugProtocol . SetVariableResponse , args : DebugProtocol . SetVariableArguments ) { this . errorResponse ( response , "s" ) ; } protected continueRequest ( response : DebugProtocol . ContinueResponse , args : DebugProtocol . ContinueArguments ) { const thread = this . threadManager . getThreadInfoFromNumber ( args . threadId ) ; if ( ! thread ) { this . errorResponse ( response , `template` ) ; return ; } thread . resume ( ) . then ( ( _ ) => { response . body = { allThreadsContinued : false } ; this . sendResponse ( response ) ; this . requestCoverageUpdate ( "s" ) ; } ) . catch ( ( error ) => this . errorResponse ( response , `template` ) ) ; } protected nextRequest ( response : DebugProtocol . NextResponse , args : DebugProtocol . NextArguments ) { const thread = this . threadManager . getThreadInfoFromNumber ( args . threadId ) ; if ( ! thread ) { this . errorResponse ( response , `template` ) ; return ; } const type = thread . atAsyncSuspension ? "s" : "s" ; thread . resume ( type ) . then ( ( _ ) => { this . sendResponse ( response ) ; this . requestCoverageUpdate ( "s" ) ; } ) . catch ( ( error ) => this . errorResponse ( response , `template` ) ) ; } protected stepInRequest ( response : DebugProtocol . StepInResponse , args : DebugProtocol . StepInArguments ) { const thread = this . threadManager . getThreadInfoFromNumber ( args . threadId ) ; if ( ! thread ) { this . errorResponse ( response , `template` ) ; return ; } thread . resume ( "s" ) . then ( ( _ ) => { this . sendResponse ( response ) ; this . requestCoverageUpdate ( "s" ) ; } ) . catch ( ( error ) => this . errorResponse ( response , `template` ) ) ; } protected stepOutRequest ( response : DebugProtocol . StepOutResponse , args : DebugProtocol . StepOutArguments ) { const thread = this . threadManager . getThreadInfoFromNumber ( args . threadId ) ; if ( ! thread ) { this . errorResponse ( response , `template` ) ; return ; } thread . resume ( "s" ) . then ( ( _ ) => { this . sendResponse ( response ) ; this . requestCoverageUpdate ( "s" ) ; } ) . catch ( ( error ) => this . errorResponse ( response , `template` ) ) ; } protected stepBackRequest ( response : DebugProtocol . StepBackResponse , args : DebugProtocol . StepBackArguments ) { } protected async evaluateRequest ( response : DebugProtocol . EvaluateResponse , args : DebugProtocol . EvaluateArguments ) < void > { const expression = args . expression ; const frameId = args . frameId ; if ( ! frameId ) { this . errorResponse ( response , "s" ) ; return ; } const data = this . threadManager . getStoredData ( frameId ) ; const thread = data . thread ; const frame = data . data as VMFrame ; try { let result : DebuggerResult | undefined ; if ( ( expression === "s" || expression . startsWith ( "s" ) ) && thread . exceptionReference ) { const exceptionData = this . threadManager . getStoredData ( thread . exceptionReference ) ; const exceptionInstanceRef = exceptionData && exceptionData . data as VMInstanceRef ; if ( expression === "s" ) { response . body = { result : await this . fullValueAsString ( thread . ref , exceptionInstanceRef ) || "s" , variablesReference : thread . exceptionReference , } ; this . sendResponse ( response ) ; return ; } const exceptionId = exceptionInstanceRef && exceptionInstanceRef . id ; if ( exceptionId ) result = await this . observatory ! . evaluate ( thread . ref . id , exceptionId , expression . substr ( 0 ) , true ) ; } if ( ! result ) { result = await Promise . race ( [ this . observatory ! . evaluateInFrame ( thread . ref . id , frame . index , expression , true ) , new Promise < never > ( ( resolve , reject ) => setTimeout ( ( ) => reject ( new Error ( "s" ) ) , 0 ) ) , ] ) ; } if ( result . result . type === "s" ) { const error = result . result as VMErrorRef ; let str = error . message ; if ( str ) str = str . split ( "s" ) . slice ( 0 , 0 ) . join ( "s" ) ; this . errorResponse ( response , str ) ; } else { const instanceRef = result . result as InstanceWithEvaluateName ; instanceRef . evaluateName = expression ; const text = await this . fullValueAsString ( thread . ref , instanceRef ) ; response . body = { result : text || "s" , variablesReference : this . isSimpleKind ( instanceRef . kind ) ? 0 : thread . storeData ( instanceRef ) , } ; this . sendResponse ( response ) ; } } catch ( e ) { this . errorResponse ( response , `template` ) ; } } protected async customRequest ( request , response : DebugProtocol . Response , args ) < void > { switch ( request ) { case "s" : this . knownOpenFiles = args . scriptUris ; this . sendResponse ( response ) ; break ; case "s" : this . requestCoverageUpdate ( "s" ) ; this . sendResponse ( response ) ; break ; case "s" : try { await this . callService ( args . type , args . params ) ; this . sendResponse ( response ) ; } catch ( e ) { this . errorResponse ( response , e && e . message ) ; } break ; case "s" : case "s" : case "s" : case "s" : case "s" : this . log ( `template` , LogSeverity . Warn ) ; this . sendResponse ( response ) ; break ; default : this . log ( `template` , LogSeverity . Warn ) ; super . customRequest ( request , response , args ) ; break ; } } public handleIsolateEvent ( event ) { const kind = event . kind ; if ( kind === "s" || kind === "s" ) { this . threadManager . registerThread ( event . isolate ! , kind ) ; } else if ( kind === "s" ) { this . threadManager . handleIsolateExit ( event . isolate ! ) ; } else if ( kind === "s" ) { this . handleServiceExtensionAdded ( event ) ; } } public handleExtensionEvent ( event ) { } public handleServiceEvent ( event ) { const kind = event . kind ; if ( kind === "s" ) this . handleServiceRegistered ( event ) ; } private lastLoggingEvent = Promise . resolve ( ) ; public async handleLoggingEvent ( event ) < void > { this . lastLoggingEvent = this . lastLoggingEvent . then ( ( ) => this . processLoggingEvent ( event ) ) ; } public async processLoggingEvent ( event ) < void > { const kind = event . kind ; if ( kind === "s" && event . logRecord ) { const record = event . logRecord ; if ( record ) { const name = record . loggerName ? this . valueAsString ( record . loggerName , false , true ) : undefined ; const logPrefix = `template` ; let indent = "s" . repeat ( logPrefix . length ) ; if ( record . message ) { const message = ( record . message . valueAsString || "s" ) + ( record . message . valueAsStringIsTruncated ? "s" : "s" ) ; const indentedMessage = `template` ; this . logToUser ( `template` ) ; } indent += "s" ; if ( record . error && record . error . kind !== "s" ) { const message = await this . fullValueAsString ( event . isolate , record . error ) ; if ( message ) { const indentedMessage = `template` ; this . logToUser ( `template` , "s" ) ; } } if ( record . stackTrace && record . stackTrace . kind !== "s" ) { const message = await this . fullValueAsString ( event . isolate , record . stackTrace ) ; if ( message ) { const indentedMessage = `template` ; this . logToUser ( `template` , "s" ) ; } } } } } public async handleDebugEvent ( event ) < void > { try { const kind = event . kind ; if ( kind . startsWith ( "s" ) ) { await this . handlePauseEvent ( event ) ; } else if ( kind === "s" ) { await this . handleInspectEvent ( event ) ; } } catch ( e ) { this . logger . error ( e , LogCategory . Observatory ) ; } } private async handlePauseEvent ( event ) { const kind = event . kind ; const thread = event . isolate ? this . threadManager . getThreadInfoFromRef ( event . isolate ) : undefined ; if ( ! event . isolate || ! thread ) { this . logger . warn ( "s" ) ; return ; } if ( ! this . observatory ) { this . logger . warn ( "s" ) ; return ; } if ( kind === "s" ) { try { await this . threadManager . resetBreakpoints ( ) ; } catch ( e ) { this . logger . error ( e , LogCategory . Observatory ) ; } try { await this . observatory . resume ( event . isolate . id ) ; } catch ( e ) { if ( e . code !== 0 ) throw e ; } } else if ( kind === "s" ) { if ( this . childProcess ) thread . receivedPauseStart ( ) ; else { thread . handlePaused ( event . atAsyncSuspension , event . exception ) ; await thread . resume ( "s" ) ; } } else { let reason = "s" ; let exceptionText ; let shouldRemainedStoppedOnBreakpoint = true ; if ( kind === "s" && event . pauseBreakpoints && event . pauseBreakpoints . length ) { reason = "s" ; const breakpoints = event . pauseBreakpoints . map ( ( bp ) => thread . breakpoints [ bp . id ] ) ; const hasUnknownBreakpoints = breakpoints . indexOf ( undefined ) !== - 0 ; if ( ! hasUnknownBreakpoints ) { const hasUnconditionalBreakpoints = ! ! breakpoints . find ( ( bp ) => ! bp . condition && ! bp . logMessage ) ; const conditionalBreakpoints = breakpoints . filter ( ( bp ) => bp . condition ) ; const logPoints = breakpoints . filter ( ( bp ) => bp . logMessage ) ; shouldRemainedStoppedOnBreakpoint = hasUnconditionalBreakpoints || await this . anyBreakpointConditionReturnsTrue ( conditionalBreakpoints , thread ) ; for ( const logPoint of logPoints ) { const logMessage = logPoint . logMessage . replace ( "s" , "s" ) . replace ( "s" , "s" ) . replace ( "s" , 's' ) ; const printCommand = `template` ; await this . evaluateAndSendErrors ( thread , printCommand ) ; } } } else if ( kind === "s" ) { reason = "s" ; } else if ( kind === "s" ) { reason = "s" ; exceptionText = await this . fullValueAsString ( event . isolate , event . exception ! ) ; } thread . handlePaused ( event . atAsyncSuspension , event . exception ) ; if ( shouldRemainedStoppedOnBreakpoint ) { this . sendEvent ( new StoppedEvent ( reason , thread . num , exceptionText ) ) ; } else { thread . resume ( ) ; } } } protected async handleInspectEvent ( event ) < void > { } private async fullValueAsString ( isolate , instanceRef ) < string | undefined > { let text : string | undefined ; if ( ! instanceRef . valueAsStringIsTruncated ) text = this . valueAsString ( instanceRef , false ) ; if ( ! text ) text = await this . callToString ( isolate , instanceRef , true ) ; if ( instanceRef . kind === "s" && instanceRef . class && instanceRef . class . name ) { if ( text === `template` || text === instanceRef . class . name ) text = instanceRef . class . name ; else text = `template` ; } return text ; } private async anyBreakpointConditionReturnsTrue ( breakpoints : DebugProtocol . SourceBreakpoint [ ] , thread ) { for ( const bp of breakpoints ) { const evalResult = await this . evaluateAndSendErrors ( thread , bp . condition ) ; if ( evalResult ) { const breakpointconditionEvaluatesToTrue = ( evalResult . kind === "s" && evalResult . valueAsString === "s" ) || ( evalResult . kind === "s" && evalResult . valueAsString !== "s" ) ; if ( breakpointconditionEvaluatesToTrue ) return true ; } } return false ; } private callService ( type , args ) < any > { return this . observatory . callMethod ( type , args ) ; } private async evaluateAndSendErrors ( thread , expression ) < VMInstanceRef > { try { const result = await this . observatory . evaluateInFrame ( thread . ref . id , 0 , expression , true ) ; if ( result . result . type !== "s" ) { return result . result as VMInstanceRef ; } else { this . logToUser ( `template` ) ; } } catch { this . logToUser ( `template` ) ; } } public handleServiceExtensionAdded ( event ) { if ( event && event . extensionRPC ) { this . notifyServiceExtensionAvailable ( event . extensionRPC , event . isolate ? event . isolate . id : undefined ) ; } } public handleServiceRegistered ( event ) { if ( event && event . service ) { this . notifyServiceRegistered ( event . service , event . method ) ; } } private notifyServiceExtensionAvailable ( id , isolateId ) { this . sendEvent ( new Event ( "s" , { id , isolateId } ) ) ; } private notifyServiceRegistered ( service , method ) { this . sendEvent ( new Event ( "s" , { service , method } ) ) ; } private knownOpenFiles : string [ ] = [ ] ; protected requestCoverageUpdate = throttle ( async ( reason ) : Promise < void > => { if ( ! this . knownOpenFiles || ! this . knownOpenFiles . length ) return ; const coverageReport = await this . getCoverageReport ( this . knownOpenFiles ) ; const coverageData : CoverageData [ ] = coverageReport . map ( ( r ) => { const allTokens = [ r . startPos , r . endPos , ... r . hits , ... r . misses ] ; const hitLines : number [ ] = [ ] ; r . hits . forEach ( ( h ) => { const startTokenIndex = allTokens . indexOf ( h ) ; const endTokenIndex = startTokenIndex < allTokens . length - 0 ? startTokenIndex + 0 : startTokenIndex ; const startLoc = this . resolveFileLocation ( r . script , allTokens [ startTokenIndex ] ) ; const endLoc = this . resolveFileLocation ( r . script , allTokens [ endTokenIndex ] ) ; if ( startLoc && endLoc ) { for ( let i = startLoc . line ; i <= endLoc . line ; i ++ ) hitLines . push ( i ) ; } } ) ; return { hitLines , scriptPath : r . hostScriptPath , } ; } ) ; this . sendEvent ( new Event ( "s" , coverageData ) ) ; } , 0 ) ; private async getCoverageReport ( scriptUris : string [ ] ) < Array < { hostScriptPath : string , script : VMScript , tokenPosTable : number [ ] [ ] , startPos : number , endPos : number , hits : number [ ] , misses : number [ ] } > > { if ( ! scriptUris || ! scriptUris . length ) return [ ] ; const result = await this . observatory ! . getVM ( ) ; const vm = result . result as VM ; const isolatePromises = vm . isolates . map ( ( isolateRef ) => this . observatory ! . getIsolate ( isolateRef . id ) ) ; const isolatesResponses = await Promise . all ( isolatePromises ) ; const isolates = isolatesResponses . map ( ( response ) => response . result as VMIsolate ) ; const trackedScriptUris : { [ key ] : boolean } = { } ; scriptUris . forEach ( ( uri ) => trackedScriptUris [ uri ] = true ) ; const results < { hostScriptPath : string , script : VMScript , tokenPosTable : number [ ] [ ] , startPos : number , endPos : number , hits : number [ ] , misses : number [ ] } > = [ ] ; for ( const isolate of isolates ) { const libraryPromises = isolate . libraries . map ( ( library ) => this . observatory ! . getObject ( isolate . id , library . id ) ) ; const libraryResponses = await Promise . all ( libraryPromises ) ; const libraries = libraryResponses . map ( ( response ) => response . result as VMLibrary ) ; const scriptRefs = flatMap ( libraries , ( library ) => library . scripts ) ; const scripts = scriptRefs . filter ( ( s ) => trackedScriptUris [ s . uri ] ) ; for ( const scriptRef of scripts ) { const script = ( await this . observatory . getObject ( isolate . id , scriptRef . id ) ) . result as VMScript ; try { const report = await this . observatory . getSourceReport ( isolate , [ SourceReportKind . Coverage ] , scriptRef ) ; const sourceReport = report . result as VMSourceReport ; const ranges = sourceReport . ranges . filter ( ( r ) => r . coverage && r . coverage . hits && r . coverage . hits . length ) ; for ( const range of ranges ) { if ( ! range . coverage ) continue ; results . push ( { endPos : range . endPos , hits : range . coverage . hits , hostScriptPath : uriToFilePath ( script . uri ) , misses : range . coverage . misses , script , startPos : range . startPos , tokenPosTable : script . tokenPosTable , } ) ; } } catch ( e ) { this . logger . error ( e , LogCategory . Observatory ) ; } } } return results ; } public errorResponse ( response : DebugProtocol . Response , message ) { response . success = false ; response . message = message ; this . sendResponse ( response ) ; } private formatUriForShortDisplay ( uri ) { if ( uri . startsWith ( "s" ) ) { uri = uriToFilePath ( uri ) ; if ( this . cwd ) uri = path . relative ( this . cwd , uri ) ; } const sep = uri . indexOf ( "s" ) === - 0 && uri . indexOf ( "s" ) !== - 0 ? "s" : "s" ; const parts = uri . split ( sep ) ; if ( parts . length > 0 ) { return [ parts [ 0 ] , "s" , parts [ parts . length - 0 ] , parts [ parts . length - 0 ] ] . join ( sep ) ; } else { return uri ; } } protected convertVMUriToSourcePath ( uri , returnWindowsPath ? ) : string | undefined { if ( uri . startsWith ( "s" ) ) return uriToFilePath ( uri , returnWindowsPath ) ; if ( uri . startsWith ( "s" ) && this . packageMap ) return this . packageMap . resolvePackageUri ( uri ) ; return uri ; } private valueAsString ( ref : VMInstanceRef | VMSentinel , useClassNameAsFallback = true , suppressQuotesAroundStrings = false ) : string | undefined { if ( ref . type === "s" ) return ref . valueAsString ; const instanceRef = ref as VMInstanceRef ; if ( ref . kind === "s" || ref . valueAsString ) { let str : string | undefined = instanceRef . valueAsString ; if ( instanceRef . valueAsStringIsTruncated ) str += "s" ; if ( instanceRef . kind === "s" && ! suppressQuotesAroundStrings ) str = `template` ; return str ; } else if ( ref . kind === "s" ) { return `template` ; } else if ( ref . kind === "s" ) { return `template` ; } else if ( ref . kind === "s" ) { const typeRef = ref as VMTypeRef ; return `template` ; } else if ( useClassNameAsFallback ) { return this . getFriendlyTypeName ( instanceRef ) ; } else { return undefined ; } } private getFriendlyTypeName ( ref ) { return ref . kind !== "s" ? ref . kind : ref . class . name ; } private async instanceRefToVariable ( thread , canEvaluate , evaluateName , name , ref : VMInstanceRef | VMSentinel , allowFetchFullString , ) < DebugProtocol . Variable > { if ( ref . type === "s" ) { return { name , value : ( ref as VMSentinel ) . valueAsString , variablesReference : 0 , } ; } else { const val = ref as InstanceWithEvaluateName ; val . evaluateName = canEvaluate ? evaluateName : undefined ; const str = config . previewToStringInDebugViews && allowFetchFullString && ! val . valueAsString ? await this . fullValueAsString ( thread . ref , val ) : this . valueAsString ( val ) ; return { evaluateName : canEvaluate ? evaluateName : undefined , indexedVariables : ( val && val . kind && val . kind . endsWith ( "s" ) ? val . length : undefined ) , name , type : `template` , value : str || "s" , variablesReference : val . valueAsString ? 0 : thread . storeData ( val ) , } ; } } public isValidToDebug ( uri ) { return ! uri . startsWith ( "s" ) ; } public isSdkLibrary ( uri ) { return uri . startsWith ( "s" ) ; } public isExternalLibrary ( uri ) { if ( ! uri . startsWith ( "s" ) || ! this . packageMap ) return false ; if ( uri . startsWith ( "s" ) ) return true ; const path = this . packageMap . resolvePackageUri ( uri ) ; if ( ! path ) return false ; return path . indexOf ( "s" ) !== - 0 || path . indexOf ( "s" ) !== - 0 ; } private resolveFileLocation ( script , tokenPos ) : FileLocation | undefined { const table : number [ ] [ ] = script . tokenPosTable ; for ( const entry of table ) { for ( let index = 0 ; index < entry . length ; index += 0 ) { if ( entry [ index ] === tokenPos ) { const line = entry [ 0 ] ; return { line , column : entry [ index + 0 ] } ; } } } return undefined ; } private async pollForMemoryUsage ( ) < void > { if ( ! this . childProcess || this . childProcess . killed || ! this . observatory ) return ; const result = await this . observatory . getVM ( ) ; const vm = result . result as VM ; const isolatePromises = vm . isolates . map ( ( isolateRef ) => this . observatory ! . getIsolate ( isolateRef . id ) ) ; const isolatesResponses = await Promise . all ( isolatePromises ) ; const isolates = isolatesResponses . map ( ( response ) => response . result as VMIsolate ) ; let current = 0 ; let total = 0 ; for ( const isolate of isolates ) { if ( ! isolate . _heaps ) continue ; for ( const heap of [ isolate . _heaps . old , isolate . _heaps . new ] ) { current += heap . used + heap . external ; total += heap . capacity + heap . external ; } } this . sendEvent ( new Event ( "s" , { memory : { current , total } } ) ) ; if ( this . pollforMemoryMs ) setTimeout ( ( ) => this . pollForMemoryUsage ( ) , this . pollforMemoryMs ) ; } private getStackFrameData ( message ) : MessageWithUriData | undefined { const match = message && stackFrameWithUriPattern . exec ( message ) ; if ( match ) { return { col : parseInt ( match [ 0 ] , 0 ) , line : parseInt ( match [ 0 ] , 0 ) , prefix : match [ 0 ] , sourceUri : match [ 0 ] , } ; } return undefined ; } private getWebStackFrameData ( message ) : MessageWithUriData | undefined { const match = message && webStackFrameWithUriPattern . exec ( message ) ; if ( match ) { return { col : parseInt ( match [ 0 ] , 0 ) , line : parseInt ( match [ 0 ] , 0 ) , prefix : match [ 0 ] , sourceUri : match [ 0 ] , } ; } return undefined ; } private getMessageWithUriData ( message ) : MessageWithUriData | undefined { const match = message && messageWithUriPattern . exec ( message ) ; if ( match ) { return { col : parseInt ( match [ 0 ] , 0 ) , line : parseInt ( match [ 0 ] , 0 ) , prefix : match [ 0 ] , sourceUri : match [ 0 ] , } ; } return undefined ; } protected logToUser ( message , category ? , colorText = ( s ) => s ) { const frame = this . getStackFrameData ( message ) || this . getWebStackFrameData ( message ) || this . getMessageWithUriData ( message ) ; const isMultiLine = message . trimRight ( ) . indexOf ( "s" ) !== - 0 ; if ( frame && isMultiLine ) { message . split ( "s" ) . forEach ( ( line ) => this . logToUser ( `template` , category ) ) ; return ; } const output = new OutputEvent ( `template` , category ) as OutputEvent & DebugProtocol . OutputEvent ; if ( frame ) { const sourcePath : string | undefined = this . convertVMUriToSourcePath ( frame . sourceUri ) ; const canShowSource = sourcePath && sourcePath !== frame . sourceUri && fs . existsSync ( sourcePath ) ; const shortName = this . formatUriForShortDisplay ( frame . sourceUri ) ; const source = canShowSource ? new Source ( shortName , sourcePath , undefined , undefined , undefined ) : undefined ; let text = `template` ; if ( source ) { output . body . source = source ; output . body . line = frame . line ; output . body . column = frame . col ; text = frame . prefix ; } const isFramework = this . isSdkLibrary ( frame . sourceUri ) || ( this . isExternalLibrary ( frame . sourceUri ) && frame . sourceUri . startsWith ( "s" ) ) || ( this . isExternalLibrary ( frame . sourceUri ) && frame . sourceUri . startsWith ( "s" ) ) ; const colouredText = isFramework ? applyColor ( text , grey ) : applyColor ( text , 0 ) ; output . body . output = `template` ; } else if ( category === "s" && output . body . output . trim ( ) . startsWith ( "s" ) && output . body . output . trim ( ) . endsWith ( "s" ) ) { output . body . output = `template` ; } this . sendEvent ( output ) ; } } export interface InstanceWithEvaluateName extends VMInstanceRef { evaluateName : string | null | undefined ; } export type VmExceptionMode = "s" | "s" | "s" ; interface MessageWithUriData { col : number ; line : number ; prefix : string ; sourceUri : string ; }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $Config$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O O O O O O $RegExp$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O $void$ O $T[]$ O $string$ O O O O O O $T[]$ O O O O O O $string$ O $string$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O O O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $number[]$ O O O O O O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $ObservatoryConnection$ O O $any$ O O $string$ O O O O O $boolean$ O O O O O $string$ O O O O O $any$ O O $any$ O $any$ O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $ThreadManager$ O $any$ O O $PackageMap$ O O $any$ O O $boolean$ O O O O O O $boolean$ O O O O O O $boolean$ O O O O O O $boolean$ O O O O O O $number$ O O O O O $Promise<void>$ O $PromiseConstructor$ O O O O $PromiseConstructor$ O $complex$ O O O O $number$ O O O O O O $boolean$ O O O O $LogCategory$ O $any$ O $LogCategory.General$ O O O $DebugAdapterLogger$ O O $any$ O O O $any$ O $LogCategory.Observatory$ O O O O $VmServiceCapabilities$ O $any$ O $VmServiceCapabilities$ O O O $boolean$ O O O O O O O $boolean$ O O O $boolean$ O O O O O O O O O O O O O $ThreadManager$ O O $any$ O O O $DebugAdapterLogger$ O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O O O $boolean$ O O O O O $string$ O O O $string$ O O O $boolean$ O O O O O O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O $DartLaunchRequestArguments$ O O O O O $DartLaunchRequestArguments$ O O $DartLaunchRequestArguments$ O $string$ O O O O $boolean$ O O $DartLaunchRequestArguments$ O $string$ O O O O O $void$ O O O O O O $any$ O O $any$ O O O O O O O O O $DartLaunchRequestArguments$ O $string$ O O $any$ O $any$ O $DartLaunchRequestArguments$ O $string$ O O O O O O $DartLaunchRequestArguments$ O $string$ O O O O $void$ O O O O O O $any$ O O $any$ O O O O O O O $DartLaunchRequestArguments$ O $string$ O $any$ O $any$ O $DartLaunchRequestArguments$ O $string$ O $DartLaunchRequestArguments$ O $string$ O O O O O $boolean$ O O O O O $string$ O $DartLaunchRequestArguments$ O $string$ O O O $boolean$ O $DartLaunchRequestArguments$ O $any$ O O O $ThreadManager$ O $void$ O O O $boolean$ O O O O O O O O $PackageMap$ O O $any$ O $any$ O $complex$ O $DartLaunchRequestArguments$ O $string$ O $DartLaunchRequestArguments$ O $string$ O O O O O $boolean$ O $DartLaunchRequestArguments$ O $boolean$ O O O $boolean$ O $DartLaunchRequestArguments$ O $boolean$ O O O $boolean$ O $DartLaunchRequestArguments$ O $boolean$ O O O $boolean$ O $DartLaunchRequestArguments$ O $boolean$ O O O $boolean$ O $DartLaunchRequestArguments$ O $boolean$ O O O $boolean$ O $DartLaunchRequestArguments$ O $boolean$ O O O $string$ O $DartLaunchRequestArguments$ O $string$ O O O $number$ O $DartLaunchRequestArguments$ O $number$ O O O $any$ O $any$ O O O O $any$ O O O $any$ O $DartLaunchRequestArguments$ O O O $any$ O O O $any$ O O O $boolean$ O O O O O $Promise<void>$ O O $PromiseConstructor$ O O $void$ O O $any$ O $any$ O O O $void$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $RegExpExecArray$ O $any$ O O O O O O O O O $boolean$ O O O $boolean$ O O O O $ObservatoryConnection$ O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $any$ O $any$ O O O O O O O $RegExpExecArray$ O O O O $Promise<void>$ O O O $string$ O $RegExpExecArray$ O O O O O O O O O O O O $boolean$ O O O $void$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $void$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O O O O O $void$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $boolean$ O O O O O $void$ O O O O O O O $any$ O O $any$ O O O $void$ O O O O O O O $void$ O O O O O $PromiseConstructor$ O $complex$ O O O O $Promise<void>$ O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O O O O O O O O O O $any$ O O $any$ O O O O O O O O O O O O $boolean$ O O O $any$ O O $any$ O O O O O O O $Promise$ O $any$ O $any$ O $any$ O $DartAttachRequestArguments$ O O O O O O O O $DartAttachRequestArguments$ O O $DartAttachRequestArguments$ O $string$ O O O O O $void$ O $any$ O O O O O O O $boolean$ O O O O O $string$ O $DartAttachRequestArguments$ O $string$ O O O $boolean$ O $DartAttachRequestArguments$ O $boolean$ O O O $boolean$ O $DartAttachRequestArguments$ O $boolean$ O O O $boolean$ O $DartAttachRequestArguments$ O $boolean$ O O O $boolean$ O $DartAttachRequestArguments$ O $boolean$ O O O $string$ O $DartAttachRequestArguments$ O $string$ O O O $number$ O $DartAttachRequestArguments$ O $number$ O O O $void$ O O O O O O $DartAttachRequestArguments$ O $string$ O O O O $DartAttachRequestArguments$ O $string$ O O $any$ O $any$ O $DartAttachRequestArguments$ O $string$ O O $DartAttachRequestArguments$ O $string$ O $any$ O $any$ O $DartAttachRequestArguments$ O $string$ O $DartAttachRequestArguments$ O $string$ O O O O O O $PackageMap$ O O $any$ O $any$ O $complex$ O $DartAttachRequestArguments$ O $string$ O O O O O O $any$ O O O O $void$ O $any$ O O O O O O O O O O O $Promise<void>$ O O O $string$ O $DartAttachRequestArguments$ O $string$ O O O O O $any$ O $any$ O O O O O $any$ O O O O $void$ O $any$ O O O O O O O $any$ O $DartLaunchRequestArguments$ O O O $any$ O $any$ O $DartLaunchRequestArguments$ O $string$ O O $DartLaunchRequestArguments$ O $string$ O O O O $any$ O $DartLaunchRequestArguments$ O O O $any[]$ O O O O O O O O $boolean$ O O $any[]$ O $number$ O O O O $any[]$ O $number$ O O O O O O O $DartLaunchRequestArguments$ O $boolean$ O O O O $any[]$ O $number$ O O O O O O O $DartLaunchRequestArguments$ O $string[]$ O O $any[]$ O $any[]$ O $complex$ O $DartLaunchRequestArguments$ O $string[]$ O O O $any[]$ O $number$ O O O $any$ O $DartLaunchRequestArguments$ O O O O O $DartLaunchRequestArguments$ O $string[]$ O O $any[]$ O $any[]$ O $complex$ O $DartLaunchRequestArguments$ O $string[]$ O O O O O $void$ O O O O O O $DartLaunchRequestArguments$ O $string$ O O O $void$ O O O O O $any$ O $any$ O $DartLaunchRequestArguments$ O $string$ O $DartLaunchRequestArguments$ O $string$ O $any[]$ O $DartLaunchRequestArguments$ O $any$ O O O O $void$ O O O O O $any$ O O O $string$ O $string$ O O O $string$ O $string$ O $string$ O O O O O $string$ O $boolean$ O O O O O $string$ O O O O $string$ O $boolean$ O O O O O $string$ O $string$ O O O $string$ O $number$ O O O O O O O $string$ O $boolean$ O O O O O O O O O O O O O $void$ O $string$ O $LogSeverity$ O $any$ O $LogSeverity.Info$ O O O O O O $string$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $string$ O O O O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O O O O O O O O $number$ O $string$ O $number$ O O O $number$ O O O $any$ O $any$ O $string$ O $string$ O O O O O $number$ O O O O O O O O $any$ O $any$ O $string$ O $string$ O O O O O O O O O $any$ O O $any$ O O O O $string$ O $LogSeverity$ O $LogCategory.Observatory$ O $any$ O $LogCategory.Observatory$ O O $any$ O O O O O O $Promise$ O $string$ O O O O O O $string$ O O O $string$ O $boolean$ O O O O O $string$ O $string$ O $string$ O O O $string$ O $number$ O O O O O O $string$ O $boolean$ O O O O $string$ O O O $string$ O $string$ O O O O O O O $string$ O $string$ O O O O $any$ O O $any$ O O O O $string$ O O O $boolean$ O $string$ O $string$ O O O $undefined$ O $string$ O $string$ O $string$ O O O O O O O O O O O O $boolean$ O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O O $void$ O O O O O O $ObservatoryConnection$ O O $any$ O $string$ O O O O $ObservatoryConnection$ O $void$ O O $string$ O O O O $void$ O $string$ O O O O O $ObservatoryConnection$ O $void$ O O O O O O O O O O $ObservatoryConnection$ O O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O O O O O O $DebuggerResult$ O O O O $Version$ O $DebuggerResult$ O $VMResponse$ O $any$ O O O $VmServiceCapabilities$ O $string$ O O O O O O O O $ObservatoryConnection$ O O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O O O O O O O $DebuggerResult$ O O $PromiseConstructor$ O O O O O O O O O O $ObservatoryConnection$ O O O O $VM$ O $DebuggerResult$ O $VMResponse$ O $any$ O O O $void$ O O O O O O O $boolean$ O O O $any$ O O O $any$ O $any$ O $VM$ O $number$ O O O O $number[]$ O $number$ O $VM$ O $number$ O O O O $DebuggerResult[]$ O O $PromiseConstructor$ O O O $VM$ O $VMIsolateRef[]$ O $U[]$ O O $VMIsolateRef$ O O O O $ObservatoryConnection$ O O $Promise<DebuggerResult>$ O $VMIsolateRef$ O $string$ O O O O O $DebuggerResult$ O $DebuggerResult[]$ O $complex$ O O $DebuggerResult$ O O O O O $DebuggerResult$ O $VMResponse$ O $any$ O O $VMLibraryRef$ O O O $VMIsolate$ O $DebuggerResult$ O $DebuggerResult$ O $VMResponse$ O $any$ O O O $VMIsolate$ O $VMIsolate$ O $string[]$ O O $VMIsolate$ O $string[]$ O $void$ O O $string$ O O O O $void$ O $string$ O $VMIsolate$ O $string$ O O O O O O O O O $PackageMap$ O O O O $VMIsolate$ O $VMIsolate$ O $VMLibraryRef$ O O O $PackageMap$ O O $any$ O $any$ O $complex$ O O O $string$ O $VMIsolate$ O $VMLibraryRef$ O $string$ O O O O O O $PromiseConstructor$ O O O $DebuggerResult[]$ O $U[]$ O O O $DebuggerResult$ O O O O $VMIsolate$ O $DebuggerResult$ O $VMResponse$ O $any$ O O O $ThreadManager$ O $Promise<void>$ O $VMIsolate$ O $VMIsolate$ O $boolean$ O O O O O O O O O $VMIsolate$ O $VMEvent$ O $string$ O $boolean$ O O O O O O O O $Promise<void>$ O $VMIsolate$ O $VMEvent$ O O O O O O O O O O O $number$ O $number$ O O O O O O $Promise<void>$ O O O O O $number$ O O O O $any$ O O $any$ O O O O O O O O O O $void$ O O O O O O O O $ObservatoryConnection$ O $void$ O O $number$ O $string$ O O O O O $void$ O O O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $undefined$ O O O $string$ O $undefined$ O O O O O O O $any$ O O O O $any$ O O $any$ O O O O O O O $number$ O O O O O O O O O O $boolean$ O O O $any$ O O $any$ O O O O O O O O O O O O O O O $ObservatoryConnection$ O $void$ O O $Error$ O O O $void$ O $Error$ O O O O O O O O O O $void$ O O O O O O O O $ObservatoryConnection$ O O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O O O O $VMEvent$ O O O O $void$ O $VMEvent$ O O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O O O O $VMEvent$ O O O O $void$ O $VMEvent$ O O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O O O O $VMEvent$ O O O O $Promise<void>$ O $VMEvent$ O O O O O O O O $VmServiceCapabilities$ O $boolean$ O O O O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O O O O $VMEvent$ O O O O $void$ O $VMEvent$ O O O O O O O $VmServiceCapabilities$ O $boolean$ O O O $boolean$ O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O O O O $VMEvent$ O O O O $Promise<void>$ O $VMEvent$ O O O $complex$ O O $any$ O O O O O $DebugAdapterLogger$ O $void$ O $string$ O $any$ O O O O O O O O O O $Promise$ O $boolean$ O O O O O O O O $boolean$ O O O O O O O O $boolean$ O O O O O O O $void$ O O O O O O O O $boolean$ O O O $any$ O O O O $boolean$ O O O O $void$ O O O O O O O $number$ O O O $number[]$ O O O O O O $void$ O O O O $any$ O $any$ O $number$ O O O O O O O $any$ O O O O O O O O O $boolean$ O O O O O O $void$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $void$ O O O O O O O O O O O O $boolean$ O O O $ObservatoryConnection$ O O O O O O $void$ O O O O O O $PromiseConstructor$ O $complex$ O O $PromiseConstructor$ O O O O O $ThreadManager$ O $ThreadInfo[]$ O $U[]$ O O $ThreadInfo$ O O $ThreadInfo$ O $Promise<DebuggerResult[]>$ O O O O O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O O O O O O O O O O $void$ O O O O O $PromiseConstructor$ O $complex$ O O $PromiseConstructor$ O O O O O $ThreadManager$ O $ThreadInfo[]$ O $U[]$ O O $ThreadInfo$ O O $ThreadInfo$ O $Promise<void>$ O O O O O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O O O O O O O O O O O O O O O O $void$ O O O O O O $ObservatoryConnection$ O $void$ O O O O O O O O O O O $ObservatoryConnection$ O $undefined$ O O O O O O O $void$ O O O O O O O $void$ O O O O O O $ThreadManager$ O $void$ O O O O O $void$ O O O O O O O $Promise<void>$ O O O $void$ O O O O O O O $Promise$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $void$ O O O O O O O O O $Promise<void>$ O O O O O O O $any$ O O O O O $void$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $Promise$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $void$ O O O O O O O $unknown$ O O $PromiseConstructor$ O $complex$ O O O O $Promise<void>$ O O O O O O O $void$ O O O O O O $PromiseConstructor$ O O $void$ O O $number$ O O O O $void$ O O O O O O O O O O O O O $unknown$ O O O O $Promise<void>$ O O O O O O O $any$ O O O O O $void$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $Promise$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $boolean$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O $boolean$ O O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $boolean$ O O O $PackageMap$ O O O O $boolean$ O O $string$ O $boolean$ O O O O $PackageMap$ O $string$ O $any$ O $any$ O O $string$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $any$ O $any$ O $any$ O $any$ O O O O O $any[]$ O O O O $ThreadManager$ O $Promise<any[]>$ O $string$ O $any[]$ O O O $any[]$ O O O O O O O $any$ O $any[]$ O O $any[]$ O $number$ O O $boolean$ O O O $any$ O O O O $any$ O $any$ O O $any[]$ O $any[]$ O O O O $any$ O $any$ O O O O O $any$ O O O O $void$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string[]$ O O O O O $any$ O $any$ O O $VmExceptionMode$ O O O O O O O O $boolean$ O O O O $string[]$ O $number$ O O O O O O O $VmExceptionMode$ O O O O O $string[]$ O $number$ O O O O O O O $VmExceptionMode$ O O O O O O $ThreadManager$ O $void$ O $VmExceptionMode$ O O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $ThreadManager$ O $void$ O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $ThreadInfo$ O O O $ThreadManager$ O $ThreadInfo$ O $any$ O $any$ O O O O O $ThreadInfo$ O O O O $void$ O $any$ O O O O O O O O O O O O $ObservatoryConnection$ O O O O $void$ O $any$ O O O O O O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $ThreadInfo$ O $VMIsolateRef$ O $string$ O O O O O $DebuggerResult$ O O O O $any$ O $any$ O O O $Promise<any>$ O O $any$ O O O O $void$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $StoredData$ O O O $ThreadManager$ O $StoredData$ O $any$ O O O $VMScriptRef$ O $StoredData$ O $VMResponse$ O $any$ O $StoredData$ O $ThreadInfo$ O $Promise<VMScript>$ O $VMScriptRef$ O O O O O $VMScript$ O O O O O $VMScript$ O $string$ O O $any$ O $any$ O O $string$ O $VMScript$ O $string$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $complex$ O O $any$ O O O O $void$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any[]$ O O O $ThreadManager$ O $any[]$ O O O O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $ThreadInfo$ O O O $ThreadManager$ O $ThreadInfo$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $ThreadInfo$ O O O O $void$ O $any$ O O O O O O O O O O O O $ObservatoryConnection$ O O O O $void$ O $any$ O O O O O O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $ThreadInfo$ O $VMIsolateRef$ O $string$ O O O O O $DebuggerResult$ O O O O $VMStack$ O $DebuggerResult$ O $VMResponse$ O $any$ O O $VMFrame[]$ O $VMStack$ O $VMFrame[]$ O $VMStack$ O $VMFrame[]$ O O $number$ O $VMFrame[]$ O $number$ O O O O $any$ O $any$ O $number$ O O O $any$ O $any$ O $number$ O $any$ O $number$ O $any$ O $VMFrame[]$ O $VMFrame[]$ O $VMFrame[]$ O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O O O O O O O $Array$ O $PromiseConstructor$ O O O O O O O O $VMFrame[]$ O $void$ O O $VMFrame$ O O O O $number$ O $ThreadInfo$ O $number$ O $VMFrame$ O O O O $VMFrame$ O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O $number$ O O O O $any$ O $any$ O O O $any[]$ O $number$ O $any$ O O O O O O $string$ O $VMFrame$ O $VMFrame$ O $VMCodeRef$ O $VMFrame$ O $VMCodeRef$ O $string$ O O $VMFrame$ O $VMCodeRef$ O $string$ O $boolean$ O O O O $VMFrame$ O $VMCodeRef$ O $string$ O $string$ O O O $number$ O O $VMFrame$ O $VMCodeRef$ O $string$ O O O O O $VMSourceLocation$ O $VMFrame$ O $VMSourceLocation$ O O O O $VMSourceLocation$ O O O $any$ O $any$ O $any$ O O $any$ O $number$ O $string$ O O $any$ O $any$ O O O $any[]$ O $number$ O $any$ O O O O O O $string$ O $VMSourceLocation$ O $VMScriptRef$ O $string$ O O $string$ O O O $string$ O $string$ O O O $any$ O $string$ O $any$ O $any$ O $string$ O O O $number$ O O O O O O O $string$ O $boolean$ O O O O O $string$ O $undefined$ O $number$ O $ThreadInfo$ O $number$ O $VMSourceLocation$ O $VMScriptRef$ O O $any$ O O O O O $string$ O O O $string$ O $string$ O O O $any$ O $any$ O $any$ O O $any$ O $number$ O $string$ O $any$ O O $any$ O $string$ O $string$ O $number$ O $undefined$ O $VMSourceLocation$ O $VMScriptRef$ O O $undefined$ O O O O O O O O $boolean$ O $any[]$ O $number$ O O O O $boolean$ O $ThreadInfo$ O $number$ O O O O $boolean$ O O $boolean$ O $boolean$ O O O $any$ O $any$ O $boolean$ O O O O O O O $boolean$ O $string$ O O O O O $boolean$ O $string$ O O O O O $boolean$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $boolean$ O $string$ O O O O O $boolean$ O O $any$ O $any$ O $any$ O $string$ O $boolean$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any[]$ O $number$ O $any$ O O O $Promise<void>$ O $ThreadInfo$ O $Promise<VMScript>$ O $VMSourceLocation$ O $VMScriptRef$ O O O O O $VMScript$ O O O O $FileLocation$ O O O $FileLocation$ O $VMScript$ O $VMSourceLocation$ O $number$ O O O O $FileLocation$ O O $any$ O $any$ O $FileLocation$ O $number$ O $any$ O $any$ O $FileLocation$ O $number$ O O O O O $Promise<void>[]$ O $number$ O $Promise<void>$ O O O O O $any$ O $any$ O O $any[]$ O $number$ O O O $PromiseConstructor$ O O O $Promise<void>[]$ O O O O O $void[]$ O O O O O $any$ O $any$ O O O O O $complex$ O O $any$ O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O O O O $void$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $StoredData$ O O O $ThreadManager$ O $StoredData$ O $any$ O O O $VMFrame$ O $StoredData$ O $VMResponse$ O $any$ O O $number$ O $StoredData$ O $ThreadInfo$ O $number$ O $VMFrame$ O O O $any[]$ O $any$ O O O O O O O O $StoredData$ O $ThreadInfo$ O $number$ O O $any[]$ O $number$ O O $any$ O O O $StoredData$ O $ThreadInfo$ O $number$ O O O O $any[]$ O $number$ O O $any$ O O O $number$ O O O $any$ O $any$ O O $any[]$ O O O O $any$ O $any$ O O O O O $Promise$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $ObservatoryConnection$ O O O O $void$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $StoredData$ O O O $ThreadManager$ O $StoredData$ O $any$ O O O $ThreadInfo$ O $StoredData$ O $ThreadInfo$ O O O $StoredData$ O $VMResponse$ O $string$ O O O O O $VMFrame$ O $StoredData$ O $VMResponse$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O O $VMFrame$ O $VMBoundVariable[]$ O O O $Promise<any>[]$ O $VMFrame$ O $VMBoundVariable[]$ O $complex$ O O $VMBoundVariable$ O O O $VMBoundVariable$ O $complex$ O $VMBoundVariable$ O $complex$ O $string$ O O O O $U[]$ O O $VMBoundVariable$ O $number$ O O O O $Promise<any>$ O $ThreadInfo$ O O O $VMBoundVariable$ O $string$ O $VMBoundVariable$ O $string$ O $VMBoundVariable$ O $complex$ O $number$ O O O O O O $any[]$ O O $PromiseConstructor$ O O O $Promise<any>[]$ O O $any[]$ O $any[]$ O $complex$ O $any[]$ O O O $any$ O $any$ O O $any[]$ O O O O $any$ O $any$ O O O O O O $StoredData$ O $VMResponse$ O $string$ O O O O O $VMMapEntry$ O $StoredData$ O $VMResponse$ O $any$ O O $complex$ O O $PromiseConstructor$ O O O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $ThreadInfo$ O $VMIsolateRef$ O $string$ O $VMMapEntry$ O $string$ O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $ThreadInfo$ O $VMIsolateRef$ O $string$ O $VMMapEntry$ O $string$ O O O O O O $any[]$ O $any$ O $any$ O O O O O O O O $DebuggerResult$ O $DebuggerResult$ O O $complex$ O O $VMInstanceRef$ O $DebuggerResult$ O $VMResponse$ O $any$ O O $VMInstanceRef$ O $DebuggerResult$ O $VMResponse$ O $any$ O $any[]$ O $number$ O O O O $Promise<any>$ O $ThreadInfo$ O O O O O O O $VMInstanceRef$ O O O O O O $boolean$ O O O O $string$ O O O O O O O $boolean$ O $VMInstanceRef$ O $string$ O O O $boolean$ O O O $string$ O O O O $any[]$ O $number$ O O O O $Promise<any>$ O $ThreadInfo$ O $boolean$ O $string$ O O O $VMInstanceRef$ O O O O O $any$ O $any$ O O $any[]$ O O O O $any$ O $any$ O O O O O O $InstanceWithEvaluateName$ O $StoredData$ O $VMResponse$ O $any$ O O O O $DebuggerResult$ O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $ThreadInfo$ O $VMIsolateRef$ O $string$ O $InstanceWithEvaluateName$ O $string$ O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O O O O O O O $boolean$ O $InstanceWithEvaluateName$ O $string$ O $undefined$ O O O $DebuggerResult$ O $VMResponse$ O $string$ O O O O $any[]$ O $number$ O O $string$ O O O $string$ O O $DebuggerResult$ O $VMResponse$ O $any$ O O $string$ O $number$ O O O O O O O O O O $VMObj$ O $DebuggerResult$ O $VMResponse$ O $any$ O O O $VMObj$ O $string$ O O O O O $VMInstance$ O $VMObj$ O $any$ O O O O O $boolean$ O $VMInstance$ O $string$ O O O $any[]$ O $number$ O O O O $Promise<any>$ O $ThreadInfo$ O $boolean$ O O O $VMInstance$ O $string$ O $InstanceWithEvaluateName$ O O O O O O O O O $VMInstance$ O $any[]$ O O O $number$ O $VMInstance$ O $any[]$ O $number$ O O $Promise<any>[]$ O $VMInstance$ O $any[]$ O $U[]$ O O O $any$ O $number$ O O O O $Promise<any>$ O $ThreadInfo$ O $boolean$ O O O O O $any$ O $number$ O O O O O O $any[]$ O O $PromiseConstructor$ O O O $Promise<any>[]$ O O $any[]$ O $any[]$ O $complex$ O $any[]$ O O O O O O $VMInstance$ O $VMMapAssociation[]$ O O O $number$ O $VMInstance$ O $VMMapAssociation[]$ O $number$ O O O O $number$ O O O $number$ O $number$ O $number$ O O O O $VMMapAssociation$ O $VMInstance$ O $VMMapAssociation[]$ O $number$ O O O $string$ O O O $string$ O $VMMapAssociation$ O $complex$ O O O O O $string$ O O O $string$ O $VMMapAssociation$ O $complex$ O O O O O $number$ O O O O O $VMMapAssociation$ O $complex$ O $string$ O O O $VMMapAssociation$ O $complex$ O $string$ O O O O O $VMMapEntry$ O O $string$ O O $VMMapAssociation$ O $complex$ O $any$ O O $string$ O $string$ O $InstanceWithEvaluateName$ O $string$ O $string$ O O O $string$ O O $VMMapAssociation$ O $complex$ O $any$ O O $string$ O O O $number$ O $ThreadInfo$ O $number$ O $VMMapEntry$ O O O $any[]$ O $number$ O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O O O O O O O $VMInstance$ O $VMBoundField[]$ O O O $Array$ O $PromiseConstructor$ O $any$ O $any$ O O O O O O O $VMBoundField[]$ O $T[]$ O $VMInstance$ O $VMBoundField[]$ O O $VMBoundField$ O O $VMBoundField$ O $VMFieldRef$ O $string$ O O O $Promise<any>[]$ O $VMBoundField[]$ O $U[]$ O O O $VMBoundField$ O $number$ O O O O $Promise<any>$ O $ThreadInfo$ O $boolean$ O O O $VMBoundField$ O $VMFieldRef$ O $string$ O $VMBoundField$ O $complex$ O $number$ O O O O O $Promise<any>[]$ O $Promise<any>[]$ O $complex$ O $Promise<any>[]$ O O O O O O $boolean$ O $VMInstance$ O $VMClassRef$ O O O $string[]$ O O O O $Promise<string[]>$ O $ThreadInfo$ O $VMIsolateRef$ O $VMInstance$ O $VMClassRef$ O O $string[]$ O $string[]$ O $string[]$ O O O O $Promise<any>[]$ O $string[]$ O $U[]$ O O O $string$ O $number$ O O O O O O $DebuggerResult$ O O O O $ObservatoryConnection$ O O $Promise<DebuggerResult>$ O $ThreadInfo$ O $VMIsolateRef$ O $string$ O $InstanceWithEvaluateName$ O $string$ O $string$ O O O O O O $DebuggerResult$ O $VMResponse$ O $string$ O O O O O O $string$ O $string$ O $string$ O O $DebuggerResult$ O $VMResponse$ O $any$ O O $string$ O $number$ O O O O O O O O $DebuggerResult$ O $VMResponse$ O $string$ O O O O O O $string$ O $string$ O $string$ O O $DebuggerResult$ O $VMResponse$ O $any$ O O $string$ O $number$ O O O O O O O O $VMInstanceRef$ O $DebuggerResult$ O $VMResponse$ O $any$ O O O O $Promise<any>$ O $ThreadInfo$ O $boolean$ O O O $string$ O $VMInstanceRef$ O $VMInstance$ O $VMBoundField[]$ O O $number$ O $number$ O O O O O O O O O $any$ O O O O $string$ O $string$ O $string$ O O O $number$ O O O O O O O O $Promise<any>[]$ O $Promise<any>[]$ O $complex$ O $Promise<any>[]$ O O O $any[]$ O O $PromiseConstructor$ O O O $Promise<any>[]$ O O $any[]$ O $any[]$ O $complex$ O $any[]$ O O O O $PromiseConstructor$ O O O $Promise<any>[]$ O O O O O O O $void$ O O O O O O O O O O $void$ O O O O O O $any$ O $any$ O O $any[]$ O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O $complex$ O O O $string$ O O O $string$ O O O $number$ O O O O O O O O O O $any$ O $any$ O O O O O O O $Promise$ O $VMIsolateRef$ O $VMClassRef$ O $any$ O O O O O O O O O O $string[]$ O O O O O O O O O O O O $ObservatoryConnection$ O $VMClassRef$ O O O $DebuggerResult$ O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $VMIsolateRef$ O $string$ O $VMClassRef$ O $string$ O O O O $DebuggerResult$ O $VMResponse$ O $string$ O O O O O O $VMClass$ O $DebuggerResult$ O $VMResponse$ O $any$ O $string[]$ O $string[]$ O $complex$ O $string[]$ O $VMClass$ O $VMFunctionRef[]$ O $complex$ O O $VMFunctionRef$ O O $VMFunctionRef$ O $string$ O O O O $VMFunctionRef$ O $boolean$ O O $VMFunctionRef$ O $boolean$ O O $U[]$ O O $VMFunctionRef$ O O $VMFunctionRef$ O $string$ O O O $VMClassRef$ O $VMClass$ O $VMClassRef$ O O $string[]$ O $T[]$ O $string[]$ O O O $string[]$ O $complex$ O O $string$ O O $string$ O O O O O O $boolean$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $Promise$ O $VMIsolateRef$ O $VMInstanceRef$ O $boolean$ O O O O O O O O O O O O $DebuggerResult$ O O O O $ObservatoryConnection$ O O $Promise<DebuggerResult>$ O $VMIsolateRef$ O $string$ O $VMInstanceRef$ O $string$ O O O O O O O O $DebuggerResult$ O $VMResponse$ O $string$ O O O O O $undefined$ O O O O O $VMInstanceRef$ O $DebuggerResult$ O $VMResponse$ O $any$ O O O $VMInstanceRef$ O $boolean$ O $boolean$ O O O $DebuggerResult$ O O O O $ObservatoryConnection$ O O $Promise<DebuggerResult>$ O $VMIsolateRef$ O $string$ O $VMInstanceRef$ O $string$ O O $VMInstanceRef$ O $DebuggerResult$ O $VMResponse$ O $any$ O O O O O $string$ O $VMInstanceRef$ O $undefined$ O O O O O O O O $any$ O O O O $DebugAdapterLogger$ O $void$ O $any$ O $any$ O $LogCategory.Observatory$ O O O $undefined$ O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $void$ O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $ThreadInfo$ O O O $ThreadManager$ O $ThreadInfo$ O $any$ O $any$ O O O O O $ThreadInfo$ O O O O $void$ O $any$ O O O O O O O $ThreadInfo$ O $Promise<void>$ O O O O O O $void$ O O O $any$ O $any$ O O $boolean$ O O O O O O $any$ O $any$ O O O O $void$ O O O O O O O $complex$ O O $any$ O O O O $void$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $ThreadInfo$ O O O $ThreadManager$ O $ThreadInfo$ O $any$ O $any$ O O O O O $ThreadInfo$ O O O O $void$ O $any$ O O O O O O O O O O $ThreadInfo$ O $boolean$ O O O O O $ThreadInfo$ O $Promise<void>$ O O O O O O O $void$ O O O O O $any$ O $any$ O O O O $void$ O O O O O O O $complex$ O O $any$ O O O O $void$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $ThreadInfo$ O O O $ThreadManager$ O $ThreadInfo$ O $any$ O $any$ O O O O O $ThreadInfo$ O O O O $void$ O $any$ O O O O O O O $ThreadInfo$ O $Promise<void>$ O O O O O O O $void$ O O O O O $any$ O $any$ O O O O $void$ O O O O O O O $complex$ O O $any$ O O O O $void$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $ThreadInfo$ O O O $ThreadManager$ O $ThreadInfo$ O $any$ O $any$ O O O O O $ThreadInfo$ O O O O $void$ O $any$ O O O O O O O $ThreadInfo$ O $Promise<void>$ O O O O O O O $void$ O O O O O $any$ O $any$ O O O O $void$ O O O O O O O $complex$ O O $any$ O O O O $void$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Promise$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O $void$ O $any$ O O O O O O O O $StoredData$ O O O $ThreadManager$ O $StoredData$ O $any$ O O O $ThreadInfo$ O $StoredData$ O $ThreadInfo$ O O $VMFrame$ O $StoredData$ O $VMResponse$ O $any$ O O O O $DebuggerResult$ O $any$ O O O O O O $string$ O O O $string$ O $boolean$ O O O O O $ThreadInfo$ O $number$ O O O $StoredData$ O O O $ThreadManager$ O $StoredData$ O $ThreadInfo$ O $number$ O O O $VMInstanceRef$ O $StoredData$ O $StoredData$ O $VMResponse$ O $any$ O O O $string$ O O O O $any$ O $any$ O O $string$ O O O O $Promise<string>$ O $ThreadInfo$ O $VMIsolateRef$ O $VMInstanceRef$ O O O O $number$ O $ThreadInfo$ O $number$ O O O O O $any$ O $any$ O O O O O O $string$ O $VMInstanceRef$ O $VMInstanceRef$ O $string$ O O O $string$ O $DebuggerResult$ O O O O $ObservatoryConnection$ O O $Promise<DebuggerResult>$ O $ThreadInfo$ O $VMIsolateRef$ O $string$ O $string$ O $string$ O $string$ O O O O O O O O O O O $DebuggerResult$ O O $DebuggerResult$ O O $PromiseConstructor$ O $complex$ O O O O $ObservatoryConnection$ O O $Promise<DebuggerResult>$ O $ThreadInfo$ O $VMIsolateRef$ O $string$ O $VMFrame$ O $number$ O $string$ O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O $number$ O O O O $void$ O O $ErrorConstructor$ O O O O O O O O O O O O O O O $DebuggerResult$ O $VMResponse$ O $string$ O O O O O $VMErrorRef$ O $DebuggerResult$ O $VMResponse$ O $any$ O O $string$ O $VMErrorRef$ O $string$ O O O $string$ O $string$ O $string$ O $complex$ O O O O $string[]$ O O O O O O $string$ O O O O O O $void$ O $any$ O $string$ O O O O O O $InstanceWithEvaluateName$ O $DebuggerResult$ O $VMResponse$ O $any$ O $InstanceWithEvaluateName$ O $string$ O $string$ O O $string$ O O O O $Promise<string>$ O $ThreadInfo$ O $VMIsolateRef$ O $InstanceWithEvaluateName$ O O $any$ O $any$ O O $string$ O $string$ O O O $number$ O O O $boolean$ O $InstanceWithEvaluateName$ O $string$ O O O O $ThreadInfo$ O $number$ O $InstanceWithEvaluateName$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O $void$ O $any$ O O O O O O O O $Promise$ O $string$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $string$ O O O O O O O $string[]$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $void$ O O O O O O $any$ O $any$ O O O O O O O O O O O O $Promise<any>$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O O $void$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O $void$ O O O $any$ O $LogSeverity.Warn$ O O O O $any$ O $any$ O O O O O O O O $void$ O O O $any$ O $LogSeverity.Warn$ O O O O $any$ O $string$ O $any$ O $any$ O O O O O O O $void$ O $VMEvent$ O O O $string$ O $VMEvent$ O $string$ O O O $string$ O O O $string$ O O O O O O $ThreadManager$ O $Promise<void>$ O $VMEvent$ O $VMIsolateRef$ O O O O O O O O O $string$ O O O O O O $ThreadManager$ O $void$ O $VMEvent$ O $VMIsolateRef$ O O O O O O O $string$ O O O O O O $void$ O $VMEvent$ O O O O O $void$ O $VMEvent$ O O O O $void$ O $VMEvent$ O O O $string$ O $VMEvent$ O $string$ O O O $string$ O O O O O $void$ O $VMEvent$ O O O O $Promise<void>$ O $PromiseConstructor$ O $complex$ O O O O O $Promise$ O $VMEvent$ O O O O O O O $Promise<void>$ O O O $Promise<void>$ O O O O O O O O $Promise<void>$ O $VMEvent$ O O O O O O $Promise$ O $VMEvent$ O O O O O O $string$ O $VMEvent$ O $string$ O O O $string$ O O O $VMEvent$ O $VMLogRecord$ O O O $VMLogRecord$ O $VMEvent$ O $VMLogRecord$ O O O $VMLogRecord$ O O O $string$ O $VMLogRecord$ O $VMInstanceRef$ O O O $string$ O $VMLogRecord$ O $VMInstanceRef$ O O O O O O $undefined$ O O $string$ O O O O $string$ O O O $string$ O $string$ O $number$ O O O O $VMLogRecord$ O $VMInstanceRef$ O O O $string$ O O $VMLogRecord$ O $VMInstanceRef$ O $string$ O O O O O $VMLogRecord$ O $VMInstanceRef$ O $boolean$ O O O O O O O $string$ O O O O O $void$ O O O O O $string$ O O O O O $VMLogRecord$ O $VMInstanceRef$ O $VMLogRecord$ O $VMInstanceRef$ O $string$ O O O O O $string$ O O O O $Promise<string>$ O $VMEvent$ O $VMIsolateRef$ O $VMLogRecord$ O $VMInstanceRef$ O O O O $string$ O O O $string$ O O O O O $void$ O O O O O O O O O O $VMLogRecord$ O $VMInstanceRef$ O $VMLogRecord$ O $VMInstanceRef$ O $string$ O O O O O $string$ O O O O $Promise<string>$ O $VMEvent$ O $VMIsolateRef$ O $VMLogRecord$ O $VMInstanceRef$ O O O O $string$ O O O $string$ O O O O O $void$ O O O O O O O O O O O O O $Promise$ O $VMEvent$ O O O O O O O O $string$ O $VMEvent$ O $string$ O O O $string$ O $boolean$ O O O O O O O O $Promise<void>$ O $VMEvent$ O O O O O O $string$ O O O O O O O $Promise<void>$ O $VMEvent$ O O O O O O $any$ O O O O $DebugAdapterLogger$ O $void$ O $any$ O $any$ O $LogCategory.Observatory$ O O O O O O $Promise<void>$ O $VMEvent$ O O O $string$ O $VMEvent$ O $string$ O O $ThreadInfo$ O $VMEvent$ O $VMIsolateRef$ O O O $ThreadManager$ O $ThreadInfo$ O $VMEvent$ O $VMIsolateRef$ O O $undefined$ O O O O $VMEvent$ O $VMIsolateRef$ O O $ThreadInfo$ O O O O $DebugAdapterLogger$ O $void$ O O O O O O O O O O O O $ObservatoryConnection$ O O O O $DebugAdapterLogger$ O $void$ O O O O O O O O O $string$ O O O O O O O O O $ThreadManager$ O $Promise<void>$ O O O O O O $any$ O O O O $DebugAdapterLogger$ O $void$ O $any$ O $any$ O $LogCategory.Observatory$ O O O O O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $VMEvent$ O $VMIsolateRef$ O $string$ O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O $string$ O O O O O O O O $any$ O $ThreadInfo$ O $void$ O O O O O $ThreadInfo$ O $void$ O $VMEvent$ O $boolean$ O $VMEvent$ O $VMInstanceRef$ O O O $ThreadInfo$ O $Promise<void>$ O O O O O O O O O $string$ O O O O $any$ O O $boolean$ O O O O O $string$ O O O $VMEvent$ O $VMBreakpoint[]$ O $VMEvent$ O $VMBreakpoint[]$ O $number$ O O $string$ O O O O $any[]$ O $VMEvent$ O $VMBreakpoint[]$ O $U[]$ O O $VMBreakpoint$ O O $ThreadInfo$ O $complex$ O $VMBreakpoint$ O $string$ O O O O $boolean$ O $any[]$ O $number$ O $undefined$ O O O O O O O O $boolean$ O O O $boolean$ O O O $any[]$ O $complex$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O $any[]$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O $any[]$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O $boolean$ O $boolean$ O O O O $Promise<boolean>$ O $any[]$ O $ThreadInfo$ O O O O O $any$ O $any[]$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $string$ O O O O O O $Promise<VMInstanceRef>$ O $ThreadInfo$ O $string$ O O O O O O O O $string$ O O O O $string$ O O O O O O O $string$ O O O O $string$ O O O $any$ O O O O $Promise<string>$ O $VMEvent$ O $VMIsolateRef$ O $VMEvent$ O $VMInstanceRef$ O O O O $ThreadInfo$ O $void$ O $VMEvent$ O $boolean$ O $VMEvent$ O $VMInstanceRef$ O O O O $boolean$ O O O O $any$ O O $any$ O $string$ O $ThreadInfo$ O $number$ O $any$ O O O O O O $ThreadInfo$ O $Promise<void>$ O O O O O O O O $Promise$ O $VMEvent$ O O O O O O O O $Promise$ O $VMIsolateRef$ O $VMInstanceRef$ O O O O O O O O $string$ O O O O O O O O $VMInstanceRef$ O $boolean$ O $string$ O O O $string$ O $VMInstanceRef$ O O O O O O O $string$ O $string$ O O O O $Promise<string>$ O $VMIsolateRef$ O $VMInstanceRef$ O O O O O O $VMInstanceRef$ O $string$ O O O $VMInstanceRef$ O $VMClassRef$ O $VMInstanceRef$ O $VMClassRef$ O $string$ O O O O $string$ O O O $string$ O $VMInstanceRef$ O $VMClassRef$ O $string$ O $string$ O $VMInstanceRef$ O $VMClassRef$ O $string$ O O $string$ O O O O O $string$ O O O O $Promise<boolean>$ O $any[]$ O $any$ O $any$ O O O $ThreadInfo$ O O O O O $any$ O $any[]$ O O O $VMInstanceRef$ O O O O $Promise<VMInstanceRef>$ O $ThreadInfo$ O $any$ O $any$ O O O O $VMInstanceRef$ O O O $boolean$ O O $VMInstanceRef$ O $string$ O O O $VMInstanceRef$ O $string$ O O O O O $VMInstanceRef$ O $string$ O O O $VMInstanceRef$ O $string$ O O O O O O $boolean$ O O O O O O O O O O O $Promise$ O $string$ O $any$ O O O O O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $string$ O $any$ O O O O O $Promise$ O $ThreadInfo$ O $string$ O O $any$ O O O O O $DebuggerResult$ O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $ThreadInfo$ O $VMIsolateRef$ O $string$ O O O $string$ O O O O O O $DebuggerResult$ O $VMResponse$ O $string$ O O O O O $DebuggerResult$ O $VMResponse$ O $any$ O O O O O O $void$ O O O O O O O O O O $void$ O O O O O O O $void$ O $VMEvent$ O O O O $VMEvent$ O $VMEvent$ O $string$ O O O O $void$ O $VMEvent$ O $string$ O $VMEvent$ O $VMIsolateRef$ O $VMEvent$ O $VMIsolateRef$ O $string$ O $undefined$ O O O O O $void$ O $VMEvent$ O O O O $VMEvent$ O $VMEvent$ O $string$ O O O O $void$ O $VMEvent$ O $string$ O $VMEvent$ O $string$ O O O O O $void$ O $string$ O $string$ O O O O $any$ O O $any$ O O O O $string$ O $string$ O O O O O O $void$ O $string$ O $string$ O O O O $any$ O O $any$ O O O O $string$ O $string$ O O O O O O $string[]$ O O O O O O O O O $void$ O $void$ O O O $string$ O O $PromiseConstructor$ O O O O O O O O O O $string[]$ O O O O $string[]$ O $number$ O O O O $complex$ O O O O $complex$ O O O $string[]$ O O O $CoverageData[]$ O $any$ O O O $complex$ O O O O $complex$ O O O O $number[]$ O O $complex$ O $number$ O $complex$ O $number$ O O $complex$ O $number[]$ O O $complex$ O $number[]$ O O O $number[]$ O O O O O O O O $complex$ O $number[]$ O $void$ O O $number$ O O O O $number$ O $number[]$ O $number$ O $number$ O O O $number$ O $number$ O $number[]$ O $number$ O O O $number$ O O O $number$ O O $FileLocation$ O O O $FileLocation$ O $complex$ O $VMScript$ O $number[]$ O $number$ O O O O $FileLocation$ O O O $FileLocation$ O $complex$ O $VMScript$ O $number[]$ O $number$ O O O O O $FileLocation$ O $FileLocation$ O O O O O $number$ O $FileLocation$ O $number$ O $number$ O $FileLocation$ O $number$ O $number$ O O $number[]$ O $number$ O $number$ O O O O O O O O $number[]$ O $string$ O $complex$ O $string$ O O O O O O O O $any$ O O $any$ O O O $CoverageData[]$ O O O O O O O O O O $Promise$ O $string[]$ O O O O O O $ArrayConstructor$ O O $string$ O O O $VMScript$ O $any$ O $number[][]$ O O O O O O O $number$ O O O $number$ O O O $number[]$ O O O O O $number[]$ O O O O O O O O O O O $string[]$ O O $string[]$ O $number$ O O O O O O $DebuggerResult$ O O O O $ObservatoryConnection$ O O $Promise<DebuggerResult>$ O O O O $VM$ O $DebuggerResult$ O $VMResponse$ O $any$ O O $Promise<DebuggerResult>[]$ O $VM$ O $VMIsolateRef[]$ O $U[]$ O O $VMIsolateRef$ O O O O $ObservatoryConnection$ O O $Promise<DebuggerResult>$ O $VMIsolateRef$ O $string$ O O O O $DebuggerResult[]$ O O $PromiseConstructor$ O O O $Promise<DebuggerResult>[]$ O O O $VMIsolate[]$ O $DebuggerResult[]$ O $U[]$ O O $DebuggerResult$ O O $DebuggerResult$ O $VMResponse$ O $any$ O O O $complex$ O O O $string$ O O O O O O O O $string[]$ O $void$ O O $string$ O O $complex$ O $string$ O O O O O O $Array$ O O $string$ O O O $VMScript$ O $any$ O $number[][]$ O O O O O O O $number$ O O O $number$ O O O $number[]$ O O O O O $number[]$ O O O O O O O O O O O O O $VMIsolate$ O $VMIsolate[]$ O O O $Promise<DebuggerResult>[]$ O $VMIsolate$ O $VMLibraryRef[]$ O $U[]$ O O $VMLibraryRef$ O O O O $ObservatoryConnection$ O O $Promise<DebuggerResult>$ O $VMIsolate$ O $string$ O $VMLibraryRef$ O $string$ O O O O $DebuggerResult[]$ O O $PromiseConstructor$ O O O $Promise<DebuggerResult>[]$ O O O $VMLibrary[]$ O $DebuggerResult[]$ O $U[]$ O O $DebuggerResult$ O O $DebuggerResult$ O $VMResponse$ O $any$ O O O $VMScriptRef[]$ O O O $VMLibrary[]$ O O $VMLibrary$ O O $VMLibrary$ O $VMScriptRef[]$ O O O $VMScriptRef[]$ O $VMScriptRef[]$ O $complex$ O O $VMScriptRef$ O O $complex$ O $VMScriptRef$ O $string$ O O O O O O $VMScriptRef$ O $VMScriptRef[]$ O O O $VMScript$ O O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $VMIsolate$ O $string$ O $VMScriptRef$ O $string$ O O O $VMResponse$ O $any$ O O O O $DebuggerResult$ O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O $VMIsolate$ O O $any$ O $SourceReportKind.Coverage$ O O $VMScriptRef$ O O O $VMSourceReport$ O $DebuggerResult$ O $VMResponse$ O $any$ O O $VMSourceReportRange[]$ O $VMSourceReport$ O $VMSourceReportRange[]$ O $complex$ O O $VMSourceReportRange$ O O $VMSourceReportRange$ O $VMSourceReportCoverage$ O $VMSourceReportRange$ O $VMSourceReportCoverage$ O $number[]$ O $VMSourceReportRange$ O $VMSourceReportCoverage$ O $number[]$ O $number$ O O O O O $VMSourceReportRange$ O $VMSourceReportRange[]$ O O O O O $VMSourceReportRange$ O $VMSourceReportCoverage$ O O O $complex$ O $number$ O O $number$ O $VMSourceReportRange$ O $number$ O $number[]$ O $VMSourceReportRange$ O $VMSourceReportCoverage$ O $number[]$ O $string$ O $string$ O $VMScript$ O $string$ O O $number[]$ O $VMSourceReportRange$ O $VMSourceReportCoverage$ O $number[]$ O $VMScript$ O $number$ O $VMSourceReportRange$ O $number$ O $number[][]$ O $VMScript$ O $number[][]$ O O O O O O O O $any$ O O O O $DebugAdapterLogger$ O $void$ O $any$ O $any$ O $LogCategory.Observatory$ O O O O O O $complex$ O O O $void$ O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O O O O $string$ O $string$ O O O O $string$ O $boolean$ O O O O O $string$ O $string$ O $string$ O O O O O O $string$ O $string$ O $any$ O $any$ O O O $string$ O $string$ O O O O O O $string$ O $number$ O O O O O O O $string$ O $number$ O O O O O O O O O O O O $string[]$ O $string$ O $complex$ O O O O O O $string[]$ O $number$ O O O O O O $string[]$ O O O O O O $string[]$ O $string[]$ O $number$ O O O O $string[]$ O $string[]$ O $number$ O O O O O $string$ O O O O O O O O $string$ O O O O $string$ O $string$ O $boolean$ $boolean$ O O O O O O O O $string$ O $boolean$ O O O O O $string$ O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O O O $PackageMap$ O O O O $PackageMap$ O $string$ O $string$ O O O $string$ O O O $string$ O $complex$ O $any$ O $any$ O $boolean$ O O O $boolean$ O O O O O O O O O O $complex$ O $string$ O O O O $complex$ O $string$ O O $VMInstanceRef$ O $complex$ O $any$ O O O $complex$ O $string$ O O O $complex$ O $string$ O O O $string$ O O O O O $VMInstanceRef$ O $string$ O O O $VMInstanceRef$ O $boolean$ O $string$ O O O O O $VMInstanceRef$ O $string$ O O O O $boolean$ O $string$ O O O O $string$ O O O O O $complex$ O $string$ O O O O O O O O O O O $complex$ O $string$ O O O O O O O O O O O $complex$ O $string$ O O O O O $VMTypeRef$ O $complex$ O $any$ O O O O O O O O $boolean$ O O O O O $string$ O $VMInstanceRef$ O O O O O O $undefined$ O O O O $string$ O $VMInstanceRef$ O O O $VMInstanceRef$ O $string$ O O O $VMInstanceRef$ O $string$ O $VMInstanceRef$ O $VMClassRef$ O $string$ O O O O $Promise$ O $ThreadInfo$ O $boolean$ O $string$ O $string$ O $complex$ O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O O O O $complex$ O $string$ O O O O O O $string$ O $string$ O O $complex$ O $any$ O O $string$ O $number$ O O O O O O O O O $InstanceWithEvaluateName$ O $complex$ O $any$ O $InstanceWithEvaluateName$ O $string$ O $boolean$ O $string$ O $undefined$ O O $string$ O $Config$ O $boolean$ O $boolean$ O O $InstanceWithEvaluateName$ O $string$ O O O O $Promise<string>$ O $ThreadInfo$ O $VMIsolateRef$ O $InstanceWithEvaluateName$ O O O O $string$ O $InstanceWithEvaluateName$ O O O O $string$ O $boolean$ O $string$ O $undefined$ O $number$ O O $InstanceWithEvaluateName$ O $InstanceWithEvaluateName$ O $string$ O $InstanceWithEvaluateName$ O $string$ O $boolean$ O O O O $InstanceWithEvaluateName$ O $number$ O $undefined$ O O $string$ O $string$ O O O $string$ O $string$ O O O $number$ O $InstanceWithEvaluateName$ O $string$ O O O $ThreadInfo$ O $number$ O $InstanceWithEvaluateName$ O O O O O O O $boolean$ O $string$ O O O O $string$ O $boolean$ O O O O O O $boolean$ O $string$ O O O $string$ O $boolean$ O O O O O O $boolean$ O $string$ O O O O O $string$ O $boolean$ O O O O O O O $PackageMap$ O O O O O O $string$ O $boolean$ O O O O O O O O $string$ O O O $PackageMap$ O $string$ O $string$ O O O O O $string$ O O O O O $string$ O $number$ O O O O O O O $string$ O $number$ O O O O O O O O O $FileLocation$ O $VMScript$ O $number$ O O $any$ O O O O $number[][]$ O O O O O O O $VMScript$ O $number[][]$ O O O O $number[]$ O $number[][]$ O O O O O $number$ O O O $number$ O $number[]$ O $number$ O $number$ O O O O O O $number[]$ O $number$ O O $number$ O O O $number$ O $number[]$ O O O O O O $number$ O $number$ O $number[]$ O $number$ O O O O O O O O O $undefined$ O O O O $Promise$ O O O O O O O O O O O $any$ O O O $any$ O $any$ O O O O $ObservatoryConnection$ O O O O $DebuggerResult$ O O O O $ObservatoryConnection$ O $Promise<DebuggerResult>$ O O O O $VM$ O $DebuggerResult$ O $VMResponse$ O $any$ O O $Promise<DebuggerResult>[]$ O $VM$ O $VMIsolateRef[]$ O $U[]$ O O $VMIsolateRef$ O O O O $ObservatoryConnection$ O O $Promise<DebuggerResult>$ O $VMIsolateRef$ O $string$ O O O O $DebuggerResult[]$ O O $PromiseConstructor$ O O O $Promise<DebuggerResult>[]$ O O O $VMIsolate[]$ O $DebuggerResult[]$ O $U[]$ O O $DebuggerResult$ O O $DebuggerResult$ O $VMResponse$ O $any$ O O O $number$ O O O O $number$ O O O O O O $VMIsolate$ O $VMIsolate[]$ O O O O O $VMIsolate$ O $complex$ O O O O O O $VMHeapSpace$ O O $VMIsolate$ O $complex$ O $VMHeapSpace$ O $VMIsolate$ O $complex$ O $VMHeapSpace$ O O O $number$ O $VMHeapSpace$ O $number$ O $VMHeapSpace$ O $number$ O $number$ O $VMHeapSpace$ O $number$ O $VMHeapSpace$ O $number$ O O O O O $any$ O O $any$ O O O O $complex$ O O $number$ O $number$ O O O O O O O O O $number$ O $number$ O O O O O O $Promise<void>$ O O O O O $number$ O O O O $MessageWithUriData$ O $string$ O O $any$ O O O O $RegExpExecArray$ O $string$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O $number$ O $number$ O $RegExpExecArray$ O O O O O O O $number$ O $number$ O $RegExpExecArray$ O O O O O O O $string$ O $RegExpExecArray$ O O O O $string$ O $RegExpExecArray$ O O O O O O O O $undefined$ O O O $MessageWithUriData$ O $string$ O O $any$ O O O O $RegExpExecArray$ O $string$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O $number$ O $number$ O $RegExpExecArray$ O O O O O O O $number$ O $number$ O $RegExpExecArray$ O O O O O O O $string$ O $RegExpExecArray$ O O O O $string$ O $RegExpExecArray$ O O O O O O O O $undefined$ O O O $MessageWithUriData$ O $string$ O O $any$ O O O O $RegExpExecArray$ O $string$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O $number$ O $number$ O $RegExpExecArray$ O O O O O O O $number$ O $number$ O $RegExpExecArray$ O O O O O O O $string$ O $RegExpExecArray$ O O O O $string$ O $RegExpExecArray$ O O O O O O O O $undefined$ O O O $void$ O $string$ O $string$ $string$ O $string$ O O $string$ O O $string$ O O O $MessageWithUriData$ O O O $MessageWithUriData$ O $string$ O O O O $MessageWithUriData$ O $string$ O O O O $MessageWithUriData$ O $string$ O O O $boolean$ O $string$ O $string$ O O O $number$ O O O O O O O O O $MessageWithUriData$ O $boolean$ O O $string$ O $complex$ O O O O $void$ O O $string$ O O O O $void$ O O O $string$ O O O O O O O $any$ O O $any$ O O O $string$ O O $any$ O $any$ O $any$ O O O $MessageWithUriData$ O O O $string$ O O O O O O O $string$ O $MessageWithUriData$ O $string$ O O O $any$ O $string$ O $string$ O $MessageWithUriData$ O $string$ O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O $MessageWithUriData$ O $string$ O O O $any$ O $any$ O O $any$ O $string$ O $string$ O $undefined$ O $undefined$ O $undefined$ O O $undefined$ O O $string$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $MessageWithUriData$ O $number$ O $any$ O $any$ O $any$ O $MessageWithUriData$ O $number$ O $string$ O $MessageWithUriData$ O $string$ O O O $boolean$ O O O $boolean$ O $MessageWithUriData$ O $string$ O O O O O $boolean$ O $MessageWithUriData$ O $string$ O O $MessageWithUriData$ O $string$ O $boolean$ O O O O O O O O $boolean$ O $MessageWithUriData$ O $string$ O O $MessageWithUriData$ O $string$ O $boolean$ O O O O O O $string$ O $boolean$ O $string$ O $string$ O $string$ O O $string$ O $string$ O $string$ O O $any$ O $any$ O $any$ O O O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O
import { DebugSession } from "s" ; import { DartDebugSession } from "s" ; DebugSession . run ( DartDebugSession ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O
export interface Notification { type : string ; time : number ; } export interface StartNotification extends Notification { protocolVersion : string ; runnerVersion ? : string ; } export interface AllSuitesNotification extends Notification { count : number ; } export interface SuiteNotification extends Notification { suite : Suite ; } export interface Suite { id : number ; platform : string ; path : string ; } export interface TestNotification extends Notification { test : Test ; } export interface Item { id : number ; name ? : string ; suiteID : number ; line ? : number ; column ? : number ; url ? : string ; root_line ? : number ; root_column ? : number ; root_url ? : string ; } export interface Test extends Item { groupIDs : number [ ] ; } export interface GroupNotification extends Notification { group : Group ; } export interface Group extends Item { parentID ? : number ; testCount : number ; } export interface TestStartNotification extends Notification { test : Test ; } export interface TestDoneNotification extends Notification { testID : number ; result : "s" | "s" | "s" ; skipped : boolean ; hidden : boolean ; } export interface DoneNotification extends Notification { success : boolean ; } export interface PrintNotification extends Notification { testID : number ; messageType : string ; message : string ; } export interface ErrorNotification extends Notification { testID : number ; error : string ; stackTrace : string ; isFailure : boolean ; }	O O $any$ O $string$ O O O $number$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $Suite$ O $any$ O O O O $any$ O $number$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $Test$ O $any$ O O O O $any$ O $number$ O O O $string$ O O O O $number$ O O O $number$ O O O O $number$ O O O O $string$ O O O O $number$ O O O O $number$ O O O O $string$ O O O O O O O $any$ O $any$ O $number[]$ O O O O O O O O $any$ O $any$ O $Group$ O $any$ O O O O $any$ O $any$ O $number$ O O O O $number$ O O O O O O $any$ O $any$ O $Test$ O $any$ O O O O $any$ O $any$ O $number$ O O O O O O O O O O O $boolean$ O O O $boolean$ O O O O O O $any$ O $any$ O $boolean$ O O O O O O $any$ O $any$ O $number$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $number$ O O O $string$ O O O $string$ O O O $boolean$ O O O O
import * as child_process from "s" ; import * as fs from "s" ; import { IAmDisposable , Logger } from "s" ; import { UnknownResponse } from "s" ; import { getLogHeader } from "s" ; import { safeSpawn } from "s" ; export abstract class StdIOService < T > implements IAmDisposable { private readonly disposables : IAmDisposable [ ] = [ ] ; public process ? : child_process . ChildProcess ; protected readonly additionalPidsToTerminate : number [ ] = [ ] ; private nextRequestID = 0 ; private readonly activeRequests : { [ key ] : [ ( result ) => void , ( error ) => void , string ] | "s" } = { } ; private messageBuffer : string [ ] = [ ] ; private openLogFile : string | undefined ; private logStream ? : fs . WriteStream ; private readonly requestErrorSubscriptions : Array < ( notification ) => void > = [ ] ; private processExited = false ; constructor ( protected readonly logger , public readonly maxLogLineLength : number | undefined , public messagesWrappedInBrackets = false , public readonly treatHandlingErrorsAsUnhandledMessages = false , private readonly logFile ? ) { } protected createProcess ( workingDirectory : string | undefined , binPath , args : string [ ] , envOverrides ? ) { this . logTraffic ( `template` ) ; if ( workingDirectory ) this . logTraffic ( `template` ) ; if ( envOverrides ) this . logTraffic ( `template` ) ; this . process = safeSpawn ( workingDirectory , binPath , args , envOverrides ) ; this . logTraffic ( `template` ) ; this . process . stdout . on ( "s" , ( data ) => { const message = data . toString ( ) ; this . messageBuffer . push ( message ) ; if ( message . indexOf ( "s" ) >= 0 ) this . processMessageBuffer ( ) ; } ) ; this . process . stderr . on ( "s" , ( data ) => { this . logTraffic ( `template` , true ) ; } ) ; this . process . on ( "s" , ( code , signal ) => { this . logTraffic ( `template` ) ; this . processExited = true ; } ) ; this . process . on ( "s" , ( error ) => { this . logTraffic ( `template` ) ; } ) ; } protected buildRequest < TReq > ( id , method , params ? ) : { id : string , method : string , params ? : TReq } { return { id : id . toString ( ) , method , params , } ; } protected sendRequest < TReq , TResp > ( method , params ? ) < TResp > { const id = this . nextRequestID ++ ; return new Promise < TResp > ( ( resolve , reject ) => { this . activeRequests [ id . toString ( ) ] = [ resolve , reject , method ] ; const req = this . buildRequest ( id , method , params ) ; const json = this . messagesWrappedInBrackets ? "s" + JSON . stringify ( req ) + "s" : JSON . stringify ( req ) + "s" ; this . sendMessage ( json ) ; } ) ; } public cancelAllRequests ( ) { Object . keys ( this . activeRequests ) . forEach ( ( key ) => this . activeRequests [ key ] = "s" ) ; } protected sendMessage < T > ( json ) { this . logTraffic ( `template` ) ; if ( this . process ) this . process . stdin . write ( json ) ; else this . logTraffic ( `template` ) ; } protected processMessageBuffer ( ) { let fullBuffer = this . messageBuffer . join ( "s" ) ; this . messageBuffer = [ ] ; if ( ! fullBuffer . endsWith ( "s" ) ) { const lastNewline = fullBuffer . lastIndexOf ( "s" ) ; const incompleteMessage = fullBuffer . substring ( lastNewline + 0 ) ; fullBuffer = fullBuffer . substring ( 0 , lastNewline ) ; this . messageBuffer . push ( incompleteMessage ) ; } fullBuffer . split ( "s" ) . filter ( ( m ) => m . trim ( ) !== "s" ) . forEach ( ( m ) => this . handleMessage ( `template` ) ) ; } protected abstract shouldHandleMessage ( message ) ; protected processUnhandledMessage ( message ) { } public handleMessage ( message ) { this . logTraffic ( `template` ) ; if ( ! this . shouldHandleMessage ( message . trim ( ) ) ) { this . processUnhandledMessage ( message ) ; return ; } let msg ; try { msg = JSON . parse ( message ) ; if ( this . messagesWrappedInBrackets && msg && msg . length === 0 ) msg = msg [ 0 ] ; } catch ( e ) { if ( this . treatHandlingErrorsAsUnhandledMessages ) { this . logger . error ( `template` ) ; this . processUnhandledMessage ( message ) ; return ; } else { throw e ; } } try { if ( msg && this . isNotification ( msg ) ) this . handleNotification ( msg as T ) ; else if ( msg && this . isResponse ( msg ) ) this . handleResponse ( msg as UnknownResponse ) ; else { this . logger . error ( `template` ) ; this . processUnhandledMessage ( message ) ; } } catch ( e ) { if ( this . treatHandlingErrorsAsUnhandledMessages ) { this . logger . error ( `template` ) ; this . processUnhandledMessage ( message ) ; } else { throw e ; } } } protected abstract handleNotification ( evt : T ) ; protected isNotification ( msg ) { return ! ! msg . event ; } protected isResponse ( msg ) { return ! ! msg . id ; } private handleResponse ( evt ) { const handler = this . activeRequests [ evt . id ] ; delete this . activeRequests [ evt . id ] ; if ( handler === "s" ) { this . logger . info ( `template` ) ; return ; } else if ( ! handler ) { this . logger . error ( `template` ) ; return ; } const method = handler [ 0 ] ; const error = evt . error ; if ( error && error . code === "s" ) { error . method = method ; this . notify ( this . requestErrorSubscriptions , error ) ; } if ( error ) { handler [ 0 ] ( error ) ; } else { handler [ 0 ] ( evt . result ) ; } } protected async notify < T > ( subscriptions < ( notification : T ) => void > , notification : T ) < void > { await Promise . all ( subscriptions . slice ( ) . map ( ( sub ) => sub ( notification ) ) ) ; } protected subscribe < T > ( subscriptions < ( notification : T ) => void > , subscriber : ( notification : T ) => void ) { subscriptions . push ( subscriber ) ; const disposable = { dispose : ( ) => { let index = subscriptions . indexOf ( subscriber ) ; if ( index >= 0 ) { subscriptions . splice ( index , 0 ) ; } index = this . disposables . indexOf ( disposable ) ; if ( index >= 0 ) { this . disposables . splice ( index , 0 ) ; } } , } ; this . disposables . push ( disposable ) ; return disposable ; } public registerForRequestError ( subscriber : ( notification ) => void ) { return this . subscribe ( this . requestErrorSubscriptions , subscriber ) ; } protected logTraffic ( message , isError = false ) { if ( isError ) this . logger . error ( message ) ; else this . logger . info ( message ) ; if ( this . openLogFile !== this . logFile && this . logStream ) { this . logStream . end ( ) ; this . logStream = undefined ; this . openLogFile = undefined ; } if ( ! this . logFile ) return ; if ( ! this . logStream ) { this . logStream = fs . createWriteStream ( this . logFile ) ; this . logStream . write ( getLogHeader ( ) ) ; this . openLogFile = this . logFile ; } this . logStream . write ( `template` ) ; if ( this . maxLogLineLength && message . length > this . maxLogLineLength ) this . logStream . write ( message . substring ( 0 , this . maxLogLineLength ) + "s" ) ; else this . logStream . write ( message . trim ( ) + "s" ) ; } public dispose ( ) { if ( this . logStream ) { this . logStream . end ( ) ; this . logStream = undefined ; this . openLogFile = undefined ; } for ( const pid of this . additionalPidsToTerminate ) { try { process . kill ( pid ) ; } catch ( e ) { this . logger . error ( { message : e . toString ( ) } ) ; } } this . additionalPidsToTerminate . length = 0 ; try { if ( ! this . processExited && this . process && ! this . process . killed ) this . process . kill ( ) ; } catch ( e ) { } this . process = undefined ; this . disposables . forEach ( ( d ) => d . dispose ( ) ) ; } }	O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O $any$ O O O $IAmDisposable[]$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O O O $number[]$ O O O O O O O O O $number$ O O O O O $complex$ O O O $string$ O O O O $any$ O O O O O $any$ O O O O O O O O O O O O O O $string[]$ O O O O O O O O O $string$ O O O O O O $any$ O O $any$ O $any$ O O O $void)[]$ O $ArrayConstructor$ O O $any$ O O O O O O O O O $boolean$ O O O O O O O $Logger$ O O O $number$ O O O O O O $boolean$ O O O O O $boolean$ O O O O O $string$ $string$ O O O O $void$ O $string$ O O O O O $string$ O $string[]$ O O O O O $any$ $any$ O O O O $void$ O O O O O O $string$ O O O $void$ O O O O O O $any$ O O O $void$ O O O O O O $any$ O $any$ O $string$ O $string$ O $string[]$ O $any$ O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O O O $Buffer$ O O O O $any$ O $any$ O $any$ O O O O O $string[]$ O $number$ O $any$ O O O O $any$ O $any$ O O O O O O O O $void$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Buffer$ O O O O O $void$ O O O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $void$ O O O O O O $boolean$ O O O O O O O O $any$ O $any$ O O O O $any$ O O O O O $void$ O O O O O O O O O $complex$ O $any$ O O $number$ O $string$ O $TReq$ $TReq$ O O O $string$ O O O $string$ O O O $TReq$ O O $any$ O O O O $string$ O $number$ O $string$ O O O $string$ O $TReq$ O O O O O $Promise$ O $any$ O $any$ O O $string$ O $TReq$ $TReq$ O O $any$ O O O $number$ O O O $number$ O O O O $PromiseConstructor$ O $any$ O O O $void$ O $void$ O O O O O $complex$ O $number$ O $string$ O O O O O $void$ O $void$ O $string$ O O O $complex$ O O O $complex$ O $number$ O $string$ O $TReq$ O O O $string$ O O O $boolean$ O O O $JSON$ O $complex$ O $complex$ O O O O $JSON$ O $complex$ O $complex$ O O O O O O $void$ O $string$ O O O O O O O $void$ O O O $ObjectConstructor$ O $complex$ O O O $complex$ O O $void$ O O $string$ O O O O $complex$ O $string$ O O O O O O O $void$ O $any$ O O $string$ O O O O $void$ O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O O $void$ O O O O O O $void$ O O O O $string$ O O O $string[]$ O $string$ O O O O O O $string[]$ O O O O O O O $string$ O $boolean$ O O O O O O $number$ O $string$ O $number$ O O O O O $string$ O $string$ O $string$ O $number$ O O O O $string$ O $string$ O $string$ O O O $number$ O O O O $string[]$ O $number$ O $string$ O O O $string$ O $complex$ O O O O $complex$ O O $string$ O O $string$ O $string$ O O O O O O $void$ O O $string$ O O O O $void$ O O O O O O O O $boolean$ O $string$ O O O $void$ O $string$ O O O O $void$ O $string$ O O O O $void$ O O O O O O O O O $boolean$ O $string$ O $string$ O O O O O O O $void$ O $string$ O O O O O O $any$ O O O $any$ O $JSON$ O $any$ O $string$ O O O O O O $boolean$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O O O O O O $boolean$ O O O O $Logger$ O $void$ O O O O O O $void$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O $boolean$ O $any$ O O O O $void$ O $any$ O $any$ O O O O O $any$ O O O $boolean$ O $any$ O O O O $void$ O $any$ O $any$ O O O O O O $Logger$ O $void$ O O O O O O $void$ O $string$ O O O O O O $any$ O O O O O O $boolean$ O O O O $Logger$ O $void$ O O O O O O $void$ O $string$ O O O O O O $any$ O O O O O O $void$ O $T$ O $any$ O O O $boolean$ O $any$ O O O O O $any$ O $any$ O O O $boolean$ O $any$ O O O O O $any$ O $any$ O O O $void$ O $UnknownResponse$ O O O $complex$ O O O $complex$ O $UnknownResponse$ O $string$ O O O O O $complex$ O $UnknownResponse$ O $string$ O O O O $complex$ O O O O O O $Logger$ O $void$ O O O O O O O O O O O $complex$ O O O O $Logger$ O $void$ O O O O O O O O $string$ O $complex$ O O O O O $any$ O $UnknownResponse$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O $Promise<void>$ O O O $void)[]$ O $any$ O O O O O $any$ O O $complex$ O O O O $any$ O O O O O $complex$ O O O O $UnknownResponse$ O $any$ O O O O O O $Promise$ O $any$ O O $Array$ O O $T$ O $any$ O O O O O $T$ O $any$ O O O O O O $PromiseConstructor$ O O O $void)[]$ O $void)[]$ O O O $U[]$ O O $void$ O O $void$ O $T$ O O O O O O $IAmDisposable$ O $any$ O O $Array$ O O $T$ O $any$ O O O O O $void$ O O $T$ O $any$ O O O O O $void)[]$ O $number$ O $void$ O O O $complex$ O O $void$ O O O O O O $number$ O $void)[]$ O $number$ O $void$ O O O O $number$ O O O O $void)[]$ O $complex$ O $number$ O O O O O $number$ O O O $IAmDisposable[]$ O $number$ O $complex$ O O O O $number$ O O O O O O $IAmDisposable[]$ O $complex$ O $number$ O O O O O O O O O O O $IAmDisposable[]$ O $number$ O $complex$ O O O $complex$ O O O $IAmDisposable$ O $void$ O O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $void$ O $string$ O $boolean$ O O O O O O $boolean$ O O O $Logger$ O $void$ O $string$ O O O O O $Logger$ O $void$ O $string$ O O O O O O $string$ O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $undefined$ O O O $string$ O $undefined$ O O O O O O O $string$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $string$ O O O O $any$ O $any$ O $string$ O O O O O O $string$ O O O $string$ O O O O $any$ O $any$ O O O O O O O O $number$ O $string$ O $number$ O O O $number$ O O O $any$ O $any$ O $string$ O $string$ O O O O O $number$ O O O O O O O O $any$ O $any$ O $string$ O $string$ O O O O O O O O $void$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $undefined$ O O O $string$ O $undefined$ O O O O O $number$ O O O $number[]$ O O O O $any$ O $any$ O $number$ O O O O O $any$ O O O O $Logger$ O $void$ O O $any$ O $any$ O $any$ O O O O O O O O O $number[]$ O $number$ O O O O O O O O O O $boolean$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $undefined$ O O O $IAmDisposable[]$ O $void$ O O $IAmDisposable$ O O $IAmDisposable$ O $complex$ O O O O O O
import { StdIOService } from "s" ; import { IAmDisposable , Logger } from "s" ; export class TestRunner extends StdIOService < { type : string } > { constructor ( executable , projectFolder : string | undefined , args : string [ ] , envOverrides , logFile : string | undefined , logger , maxLogLineLength ) { super ( logger , maxLogLineLength , true , true , logFile ) ; this . createProcess ( projectFolder , executable , args , envOverrides ) ; } protected shouldHandleMessage ( message ) { return ( message . startsWith ( "s" ) && message . endsWith ( "s" ) ) || ( message . startsWith ( "s" ) && message . endsWith ( "s" ) ) ; } protected isNotification ( msg ) { return ! ! ( msg . type || msg . event ) ; } protected isResponse ( msg ) { return false ; } protected processUnhandledMessage ( message ) { this . notify ( this . unhandledMessageSubscriptions , message ) ; } private unhandledMessageSubscriptions : Array < ( notification ) => void > = [ ] ; public registerForUnhandledMessages ( subscriber : ( notification ) => void ) { return this . subscribe ( this . unhandledMessageSubscriptions , subscriber ) ; } protected handleNotification ( evt ) { switch ( evt . event ) { case "s" : this . notify ( this . testStartedProcessSubscriptions , evt . params as TestStartedProcess ) ; break ; } this . notify ( this . allTestNotificationsSubscriptions , evt ) ; } private testStartedProcessSubscriptions : Array < ( notification ) => void > = [ ] ; private allTestNotificationsSubscriptions : Array < ( notification ) => void > = [ ] ; public registerForTestStartedProcess ( subscriber : ( notification ) => void ) { return this . subscribe ( this . testStartedProcessSubscriptions , subscriber ) ; } public registerForAllTestNotifications ( subscriber : ( notification : { type : string } ) => void ) { return this . subscribe ( this . allTestNotificationsSubscriptions , subscriber ) ; } } export interface TestStartedProcess { observatoryUri : string ; }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $string$ O O O O O O O $string$ O $string$ O O O O O $string[]$ O O O O O $any$ O $string$ O O O O O $Logger$ O $number$ O O O O $Logger$ O $number$ O O O O O $string$ O O O O $void$ O $string$ O $string$ O $string[]$ O $any$ O O O O $boolean$ O $string$ O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O O O O $boolean$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O $any$ O O O O O O O $void$ O $string$ O O O O $Promise<void>$ O O O $void)[]$ O $string$ O O O O $void)[]$ O $ArrayConstructor$ O O $string$ O O O O O O O O O $IAmDisposable$ O $void$ O O $string$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $void$ O $any$ O O O O $any$ O $any$ O O O O O O O $Promise<void>$ O O O $void)[]$ O $any$ O $any$ O $any$ O O O O O O O $Promise<void>$ O O O $void)[]$ O $any$ O O O O $void)[]$ O $ArrayConstructor$ O O $TestStartedProcess$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $any$ O O O O O O O O O $IAmDisposable$ O $void$ O O $TestStartedProcess$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $complex$ O O $string$ O O O O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O O O $any$ O $string$ O O O O
import * as path from "s" ; import { Event , OutputEvent } from "s" ; import { observatoryHttpLinkPattern } from "s" ; import { LogCategory } from "s" ; import { Logger } from "s" ; import { ErrorNotification , GroupNotification , PrintNotification , SuiteNotification , Test , TestDoneNotification , TestStartNotification } from "s" ; import { DartDebugSession } from "s" ; import { DebugAdapterLogger } from "s" ; import { TestRunner } from "s" ; import { DartLaunchRequestArguments } from "s" ; const tick = "s" ; const cross = "s" ; export class DartTestDebugSession extends DartDebugSession { constructor ( ) { super ( ) ; this . sendStdOutToConsole = false ; this . requiresProgram = false ; } protected spawnProcess ( args ) { let appArgs : string [ ] = [ ] ; if ( this . shouldConnectDebugger ) { appArgs . push ( "s" ) ; appArgs . push ( "s" ) ; } if ( args . vmAdditionalArgs ) { appArgs = appArgs . concat ( args . vmAdditionalArgs ) ; } appArgs . push ( args . pubSnapshotPath ) ; appArgs = appArgs . concat ( [ "s" , "s" , "s" , "s" ] ) ; appArgs . push ( "s" ) ; if ( args . program ) appArgs . push ( this . sourceFileForArgs ( args ) ) ; if ( args . args ) { appArgs = appArgs . concat ( args . args ) ; } const logger = new DebugAdapterLogger ( this , LogCategory . PubTest ) ; return this . createRunner ( args . dartPath , args . cwd , args . program , appArgs , args . env , args . pubTestLogFile , logger , args . maxLogLineLength ) ; } protected createRunner ( executable , projectFolder : string | undefined , program , args : string [ ] , envOverrides , logFile : string | undefined , logger , maxLogLineLength ) { const runner = new TestRunner ( executable , projectFolder , args , envOverrides , logFile , logger , maxLogLineLength ) ; runner . registerForUnhandledMessages ( ( msg ) => this . logToUserIfAppropriate ( msg , "s" ) ) ; runner . registerForTestStartedProcess ( ( n ) => this . initDebugger ( `template` ) ) ; runner . registerForAllTestNotifications ( ( n ) => { try { this . handleTestEvent ( n ) ; } catch ( e ) { this . log ( e ) ; this . logToUser ( `template` ) ; } try { this . sendTestEventToEditor ( n ) ; } catch ( e ) { this . log ( e ) ; this . logToUser ( `template` ) ; } } ) ; return runner . process ; } protected logToUserIfAppropriate ( message , category ? ) { if ( message && message . startsWith ( "s" ) ) return ; if ( message && message . startsWith ( "s" ) ) return ; this . logToUser ( message , category ) ; } private readonly suitePaths : string [ ] = [ ] ; private readonly tests : Test [ ] = [ ] ; protected handleTestEvent ( notification ) { switch ( notification . type ) { case "s" : const pid = notification . pid ; if ( pid ) { this . additionalPidsToTerminate . push ( pid ) ; } break ; case "s" : const observatoryUri = notification . observatory ; if ( observatoryUri ) { const match = observatoryHttpLinkPattern . exec ( observatoryUri ) ; if ( match ) { this . initDebugger ( this . websocketUriForObservatoryUri ( match [ 0 ] ) ) ; } } break ; case "s" : const suite = notification as SuiteNotification ; if ( ! path . isAbsolute ( suite . suite . path ) && this . cwd ) suite . suite . path = path . join ( this . cwd , suite . suite . path ) ; this . suitePaths [ suite . suite . id ] = suite . suite . path ; break ; case "s" : const testStart = notification as TestStartNotification ; this . tests [ testStart . test . id ] = testStart . test ; break ; case "s" : const testDone = notification as TestDoneNotification ; if ( testDone . hidden ) return ; const pass = testDone . result === "s" ; const symbol = pass ? tick : cross ; this . sendEvent ( new OutputEvent ( `template` , "s" ) ) ; break ; case "s" : const print = notification as PrintNotification ; this . sendEvent ( new OutputEvent ( `template` , "s" ) ) ; break ; case "s" : const error = notification as ErrorNotification ; this . sendEvent ( new OutputEvent ( `template` , "s" ) ) ; this . sendEvent ( new OutputEvent ( `template` , "s" ) ) ; break ; } } protected sendTestEventToEditor ( notification ) { let suiteID : number | undefined ; switch ( notification . type ) { case "s" : const suite = notification as SuiteNotification ; suiteID = suite . suite . id ; break ; case "s" : const group = notification as GroupNotification ; suiteID = group . group . suiteID ; break ; case "s" : const testStart = notification as TestStartNotification ; suiteID = testStart . test . suiteID ; break ; case "s" : const testDone = notification as TestDoneNotification ; suiteID = this . tests [ testDone . testID ] . suiteID ; break ; case "s" : const print = notification as PrintNotification ; suiteID = this . tests [ print . testID ] . suiteID ; break ; case "s" : const error = notification as ErrorNotification ; suiteID = this . tests [ error . testID ] . suiteID ; break ; } const suitePath = suiteID !== undefined ? this . suitePaths [ suiteID ] : undefined ; if ( suitePath ) { this . sendEvent ( new Event ( "s" , { suitePath , notification } , ) ) ; } } }	O O O $any$ O O O O O $any$ O $any$ O O O O O O $RegExp$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O $boolean$ O O O O O $boolean$ O O O O O $any$ O $DartLaunchRequestArguments$ O O O $string[]$ O O O O O O O O O O O O $boolean$ O O $string[]$ O $number$ O O O O $string[]$ O $number$ O O O O O O O $DartLaunchRequestArguments$ O $string[]$ O O $string[]$ O $string[]$ O $complex$ O $DartLaunchRequestArguments$ O $string[]$ O O O $string[]$ O $number$ O $DartLaunchRequestArguments$ O $string$ O O $string[]$ O $string[]$ O $complex$ O O O O O O O O O O O O $string[]$ O $number$ O O O O O O $DartLaunchRequestArguments$ O $string$ O $string[]$ O $number$ O O O $any$ O $DartLaunchRequestArguments$ O O O O O $DartLaunchRequestArguments$ O $string[]$ O O $string[]$ O $string[]$ O $complex$ O $DartLaunchRequestArguments$ O $string[]$ O O O O $DebugAdapterLogger$ O O $any$ O O O $any$ O $LogCategory.PubTest$ O O O O O $any$ O $DartLaunchRequestArguments$ O $string$ O $DartLaunchRequestArguments$ O $string$ O $DartLaunchRequestArguments$ O $string$ O $string[]$ O $DartLaunchRequestArguments$ O $any$ O $DartLaunchRequestArguments$ O $string$ O $DebugAdapterLogger$ O $DartLaunchRequestArguments$ O $number$ O O O O $any$ O $string$ O $string$ O O O O O $string$ O $string[]$ O O O O O $any$ O $string$ O O O O O $Logger$ O $number$ O O O $TestRunner$ O O $any$ O $string$ O $string$ O $string[]$ O $any$ O $string$ O $Logger$ O $number$ O O $TestRunner$ O $IAmDisposable$ O O $string$ O O O O $void$ O $string$ O O O O O $TestRunner$ O $IAmDisposable$ O O $TestStartedProcess$ O O O O $Promise<void>$ O O O O O $TestRunner$ O $IAmDisposable$ O O $complex$ O O O O O O O $void$ O $complex$ O O O O O $any$ O O O O $void$ O $any$ O O O O $void$ O O O O O O O O O $void$ O $complex$ O O O O O $any$ O O O O $void$ O $any$ O O O O $void$ O O O O O O O O O $TestRunner$ O $any$ O O O $void$ O $string$ O $string$ $string$ O O O O $string$ O $string$ O $boolean$ O O O O O O O O $string$ O $string$ O $boolean$ O O O O O O O O $void$ O $string$ O $string$ O O O O O $string[]$ O O O O O O O O O O $Test[]$ O $any$ O O O O O O O $void$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $number[]$ O $number$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $any$ O O O O $RegExpExecArray$ O O O O $Promise<void>$ O O O $string$ O $RegExpExecArray$ O O O O O O O O O O O O O O $SuiteNotification$ O $any$ O $any$ O O O O $any$ O $any$ O $SuiteNotification$ O $Suite$ O $string$ O O O O $string$ O $SuiteNotification$ O $Suite$ O $string$ O $any$ O $any$ O O O $string$ O $SuiteNotification$ O $Suite$ O $string$ O O O O $string[]$ O $SuiteNotification$ O $Suite$ O $number$ O O $SuiteNotification$ O $Suite$ O $string$ O O O O O O O $TestStartNotification$ O $any$ O $any$ O O O $Test[]$ O $TestStartNotification$ O $Test$ O $number$ O O $TestStartNotification$ O $Test$ O O O O O O O $TestDoneNotification$ O $any$ O $any$ O O O $TestDoneNotification$ O $boolean$ O O O O $boolean$ O $TestDoneNotification$ O O O O O O O O $boolean$ O O O O O O O $any$ O O $any$ O O O O O O O O O O O O O $PrintNotification$ O $any$ O $any$ O O O $any$ O O $any$ O O O O O O O O O O O O O $ErrorNotification$ O $any$ O $any$ O O O $any$ O O $any$ O O O O O O O O O $any$ O O $any$ O O O O O O O O O O O O $void$ O $any$ O O O $number$ O O O O O O O $any$ O $any$ O O O O O O $SuiteNotification$ O $any$ O $any$ O $number$ O $SuiteNotification$ O $Suite$ O $number$ O O O O O O O $GroupNotification$ O $any$ O $any$ O $number$ O $GroupNotification$ O $Group$ O $number$ O O O O O O O $TestStartNotification$ O $any$ O $any$ O $number$ O $TestStartNotification$ O $Test$ O $number$ O O O O O O O $TestDoneNotification$ O $any$ O $any$ O $number$ O O O $Test[]$ O $TestDoneNotification$ O $number$ O O $number$ O O O O O O O $PrintNotification$ O $any$ O $any$ O $number$ O O O $Test[]$ O $PrintNotification$ O $number$ O O $number$ O O O O O O O $ErrorNotification$ O $any$ O $any$ O $number$ O O O $Test[]$ O $ErrorNotification$ O $number$ O O $number$ O O O O O $string$ O $number$ O $undefined$ O O O $string[]$ O $number$ O O $undefined$ O O O $string$ O O O O $any$ O O $any$ O O O O $string$ O $any$ O O O O O O O O
import { DebugSession } from "s" ; import { DartTestDebugSession } from "s" ; DebugSession . run ( DartTestDebugSession ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O
export interface FlutterErrorData extends DiagnosticsNode { errorsSinceReload : number | undefined ; } export interface DiagnosticsNode { type : DiagnosticsNodeType ; level : DiagnosticsNodeLevel ; description : string ; name : string ; showName : boolean | undefined ; showSeparator : boolean | undefined ; properties : DiagnosticsNode [ ] ; children : DiagnosticsNode [ ] ; style : DiagnosticsNodeStyle ; } export enum DiagnosticsNodeType { ErrorDescription = "s" , ErrorSpacer = "s" , DiagnosticsStackTrace = "s" , } export enum DiagnosticsNodeLevel { Error = "s" , Summary = "s" , Hint = "s" , } export enum DiagnosticsNodeStyle { Flat = "s" , Shallow = "s" , }	O O $any$ O $any$ O $number$ O O O O O O O O $any$ O $DiagnosticsNodeType$ O $any$ O $DiagnosticsNodeLevel$ O $any$ O $string$ O O O $string$ O O O $boolean$ O O O O O $boolean$ O O O O O $DiagnosticsNode[]$ O $any$ O O O $DiagnosticsNode[]$ O $any$ O O O $DiagnosticsNodeStyle$ O $any$ O O O O $any$ O $DiagnosticsNodeType.ErrorDescription$ O O O $DiagnosticsNodeType.ErrorSpacer$ O O O $DiagnosticsNodeType.DiagnosticsStackTrace$ O O O O O O $any$ O $DiagnosticsNodeLevel.Error$ O O O $DiagnosticsNodeLevel.Summary$ O O O $DiagnosticsNodeLevel.Hint$ O O O O O O $any$ O $DiagnosticsNodeStyle.Flat$ O O O $DiagnosticsNodeStyle.Shallow$ O O O O
import { StdIOService } from "s" ; import * as f from "s" ; import { IAmDisposable , Logger } from "s" ; import { UnknownNotification , UnknownResponse } from "s" ; export abstract class FlutterRunBase extends StdIOService < UnknownNotification > { constructor ( public readonly mode , logFile : string | undefined , logger , maxLogLineLength , messagesWrappedInBrackets = false , treatHandlingErrorsAsUnhandledMessages = false ) { super ( logger , maxLogLineLength , messagesWrappedInBrackets , treatHandlingErrorsAsUnhandledMessages , logFile ) ; } protected shouldHandleMessage ( message ) { return message . startsWith ( "s" ) && message . endsWith ( "s" ) ; } protected processUnhandledMessage ( message ) { this . notify ( this . unhandledMessageSubscriptions , message ) ; } private unhandledMessageSubscriptions : Array < ( notification ) => void > = [ ] ; public registerForUnhandledMessages ( subscriber : ( notification ) => void ) { return this . subscribe ( this . unhandledMessageSubscriptions , subscriber ) ; } protected handleNotification ( evt ) { if ( evt . params . error ) { this . notify ( this . errorSubscriptions , evt . params . error as string ) ; } switch ( evt . event ) { case "s" : this . notify ( this . daemonConnectedSubscriptions , evt . params as f . DaemonConnected ) ; break ; case "s" : this . notify ( this . appStartSubscriptions , evt . params as f . AppStart ) ; break ; case "s" : this . notify ( this . appDebugPortSubscriptions , evt . params as f . AppDebugPort ) ; break ; case "s" : this . notify ( this . appStartedSubscriptions , evt . params as f . AppEvent ) ; break ; case "s" : this . notify ( this . appStopSubscriptions , evt . params as f . AppEvent ) ; break ; case "s" : this . notify ( this . appProgressSubscriptions , evt . params as f . AppProgress ) ; break ; case "s" : this . notify ( this . appLogSubscriptions , evt . params as f . AppLog ) ; break ; case "s" : this . notify ( this . daemonLogMessageSubscriptions , evt . params as f . DaemonLogMessage ) ; break ; case "s" : this . notify ( this . daemonLogSubscriptions , evt . params as f . AppLog ) ; break ; } } private daemonConnectedSubscriptions : Array < ( notification : f . DaemonConnected ) => void > = [ ] ; private appStartSubscriptions : Array < ( notification : f . AppStart ) => void > = [ ] ; private appDebugPortSubscriptions : Array < ( notification : f . AppDebugPort ) => void > = [ ] ; private appStartedSubscriptions : Array < ( notification : f . AppEvent ) => void > = [ ] ; private appStopSubscriptions : Array < ( notification : f . AppEvent ) => void > = [ ] ; private appProgressSubscriptions : Array < ( notification : f . AppProgress ) => void > = [ ] ; private appLogSubscriptions : Array < ( notification : f . AppLog ) => void > = [ ] ; private errorSubscriptions : Array < ( notification ) => void > = [ ] ; private daemonLogMessageSubscriptions : Array < ( notification : f . DaemonLogMessage ) => void > = [ ] ; private daemonLogSubscriptions : Array < ( notification : f . AppLog ) => void > = [ ] ; public restart ( appId , pause , hotRestart , reason ) < any > { return this . sendRequest ( "s" , { appId , fullRestart : hotRestart === true , pause , reason } ) ; } public detach ( appId ) < UnknownResponse > { return this . sendRequest ( "s" , { appId } ) ; } public stop ( appId ) < UnknownResponse > { return this . sendRequest ( "s" , { appId } ) ; } public callServiceExtension ( appId , methodName , params ) < any > { return this . sendRequest ( "s" , { appId , methodName , params } ) ; } public registerForDaemonConnect ( subscriber : ( notification : f . DaemonConnected ) => void ) { return this . subscribe ( this . daemonConnectedSubscriptions , subscriber ) ; } public registerForAppStart ( subscriber : ( notification : f . AppStart ) => void ) { return this . subscribe ( this . appStartSubscriptions , subscriber ) ; } public registerForAppDebugPort ( subscriber : ( notification : f . AppDebugPort ) => void ) { return this . subscribe ( this . appDebugPortSubscriptions , subscriber ) ; } public registerForAppStarted ( subscriber : ( notification : f . AppEvent ) => void ) { return this . subscribe ( this . appStartedSubscriptions , subscriber ) ; } public registerForAppStop ( subscriber : ( notification : f . AppEvent ) => void ) { return this . subscribe ( this . appStopSubscriptions , subscriber ) ; } public registerForAppProgress ( subscriber : ( notification : f . AppProgress ) => void ) { return this . subscribe ( this . appProgressSubscriptions , subscriber ) ; } public registerForAppLog ( subscriber : ( notification : f . AppLog ) => void ) { return this . subscribe ( this . appLogSubscriptions , subscriber ) ; } public registerForError ( subscriber : ( error ) => void ) { return this . subscribe ( this . errorSubscriptions , subscriber ) ; } public registerForDaemonLogMessage ( subscriber : ( notification : f . DaemonLogMessage ) => void ) { return this . subscribe ( this . daemonLogMessageSubscriptions , subscriber ) ; } public registerForDaemonLog ( subscriber : ( notification : f . AppLog ) => void ) { return this . subscribe ( this . daemonLogSubscriptions , subscriber ) ; } } export enum RunMode { Run , Attach , }	O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $RunMode$ O $string$ O O O O O $Logger$ O $number$ O $boolean$ O O O $boolean$ O O O O O O $Logger$ O $number$ O $boolean$ O $boolean$ O $string$ O O O O $boolean$ O $string$ O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O O O $void$ O $string$ O O O O $Promise<void>$ O O O $void)[]$ O $string$ O O O O $void)[]$ O $ArrayConstructor$ O O $string$ O O O O O O O O O $IAmDisposable$ O $void$ O O $string$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $void$ O $UnknownNotification$ O O O O $UnknownNotification$ O $any$ O $any$ O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O O O O O O O $UnknownNotification$ O $string$ O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O $void)[]$ O $ArrayConstructor$ O O $DaemonConnected$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $AppStart$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $AppDebugPort$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $AppEvent$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $AppEvent$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $AppProgress$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $AppLog$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $string$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $DaemonLogMessage$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $AppLog$ O $any$ O $any$ O O O O O O O O O $Thenable$ O $string$ O $boolean$ O $boolean$ O $string$ O O O O O O O O $Promise<TResp>$ O O O O $string$ O $boolean$ O $boolean$ O O O $boolean$ O $string$ O O O O O $Thenable$ O $string$ O O $any$ O O O O O $Promise<TResp>$ O O O O $string$ O O O O O $Thenable$ O $string$ O O $any$ O O O O O $Promise<TResp>$ O O O O $string$ O O O O O $Thenable$ O $string$ O $string$ O $any$ O O O O O O O O $Promise<TResp>$ O O O O $string$ O $string$ O $any$ O O O O O $IAmDisposable$ O $void$ O O $DaemonConnected$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $AppStart$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $AppDebugPort$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $AppEvent$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $AppEvent$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $AppProgress$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $AppLog$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $string$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $DaemonLogMessage$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $AppLog$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O O O $any$ O $RunMode.Run$ O $RunMode.Attach$ O O
import { globalFlutterArgs } from "s" ; import { LogCategory } from "s" ; import { Logger } from "s" ; import { CategoryLogger } from "s" ; import { FlutterRunBase , RunMode } from "s" ; export class FlutterRun extends FlutterRunBase { constructor ( mode , flutterBinPath , projectFolder , args : string [ ] , envOverrides , logFile : string | undefined , logger , maxLogLineLength ) { super ( mode , logFile , new CategoryLogger ( logger , LogCategory . FlutterRun ) , maxLogLineLength , true , true ) ; const command = mode === RunMode . Attach ? "s" : "s" ; this . createProcess ( projectFolder , flutterBinPath , globalFlutterArgs . concat ( [ command , "s" ] ) . concat ( args ) , envOverrides ) ; } }	O O $string[]$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $RunMode$ O $string$ O $string$ O $string[]$ O O O O O $any$ O $string$ O O O O O $Logger$ O $number$ O O O O $RunMode$ O $string$ O O $any$ O $Logger$ O $any$ O $LogCategory.FlutterRun$ O O $number$ O O O O O O O O O $RunMode$ O $any$ O $RunMode.Attach$ O O O O O O O $void$ O $string$ O $string$ O $string[]$ O $complex$ O O O O O O O O $complex$ O $string[]$ O O $any$ O O O O
import { DebugSession } from "s" ; import { FlutterDebugSession } from "s" ; DebugSession . run ( FlutterDebugSession ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O
import { globalFlutterArgs } from "s" ; import { LogCategory } from "s" ; import { DartTestDebugSession } from "s" ; import { DebugAdapterLogger } from "s" ; import { FlutterLaunchRequestArguments } from "s" ; export class FlutterTestDebugSession extends DartTestDebugSession { protected spawnProcess ( args ) { let appArgs : string [ ] = [ ] ; if ( this . shouldConnectDebugger ) { appArgs . push ( "s" ) ; } if ( args . args ) { appArgs = appArgs . concat ( args . args ) ; } if ( args . program ) appArgs . push ( this . sourceFileForArgs ( args ) ) ; const logger = new DebugAdapterLogger ( this , LogCategory . FlutterTest ) ; return this . createRunner ( args . flutterPath , args . cwd , args . program , globalFlutterArgs . concat ( [ "s" , "s" ] ) . concat ( appArgs ) , args . env , args . flutterTestLogFile , logger , args . maxLogLineLength ) ; } }	O O $string[]$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O $any$ O $FlutterLaunchRequestArguments$ O O O $string[]$ O O O O O O O O O O O O $boolean$ O O $string[]$ O $number$ O O O O O O O $FlutterLaunchRequestArguments$ O $string[]$ O O $string[]$ O $string[]$ O $complex$ O $FlutterLaunchRequestArguments$ O $string[]$ O O O O O $FlutterLaunchRequestArguments$ O $string$ O $string[]$ O $number$ O O O $any$ O $FlutterLaunchRequestArguments$ O O O O $DebugAdapterLogger$ O O $any$ O O O $any$ O $LogCategory.FlutterTest$ O O O O O $any$ O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $string[]$ O $complex$ O O O O O O O O $complex$ O $string[]$ O O $FlutterLaunchRequestArguments$ O $any$ O $FlutterLaunchRequestArguments$ O $string$ O $DebugAdapterLogger$ O $FlutterLaunchRequestArguments$ O $number$ O O O O
import { DebugSession } from "s" ; import { FlutterTestDebugSession } from "s" ; DebugSession . run ( FlutterTestDebugSession ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O
import { Logger } from "s" ; import { FlutterRunBase , RunMode } from "s" ; export class FlutterWebRun extends FlutterRunBase { constructor ( mode , pubBinPath , projectFolder : string | undefined , args : string [ ] , envOverrides , logFile : string | undefined , logger , maxLogLineLength ) { super ( mode , logFile , logger , maxLogLineLength , true , true ) ; this . createProcess ( projectFolder , pubBinPath , [ "s" , "s" , "s" , "s" ] . concat ( args ) , envOverrides ) ; } }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $RunMode$ O $string$ O $string$ O O O O O $string[]$ O O O O O $any$ O $string$ O O O O O $Logger$ O $number$ O O O O $RunMode$ O $string$ O $Logger$ O $number$ O O O O O O O O $void$ O $string$ O $string$ O O O O O O O O O O O $complex$ O $string[]$ O O $any$ O O O O
import { LogCategory } from "s" ; import { Logger } from "s" ; import { FlutterDebugSession } from "s" ; import { FlutterRunBase , RunMode } from "s" ; import { FlutterWebRun } from "s" ; import { FlutterLaunchRequestArguments } from "s" ; export class FlutterWebDebugSession extends FlutterDebugSession { constructor ( ) { super ( ) ; this . supportsObservatory = false ; this . logCategory = LogCategory . WebDaemon ; } protected spawnRunDaemon ( isAttach , args , logger ) { let appArgs : string [ ] = [ ] ; if ( args . args ) { appArgs = appArgs . concat ( args . args ) ; } return new FlutterWebRun ( isAttach ? RunMode . Attach : RunMode . Run , args . pubPath , args . cwd , appArgs , args . env , args . webDaemonLogFile , logger , this . maxLogLineLength ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O $boolean$ O O O O O $LogCategory$ O $any$ O $LogCategory.WebDaemon$ O O O $FlutterRunBase$ O $boolean$ O $FlutterLaunchRequestArguments$ O $Logger$ O O O $string[]$ O O O O O O O O O O $FlutterLaunchRequestArguments$ O $string[]$ O O $string[]$ O $string[]$ O $complex$ O $FlutterLaunchRequestArguments$ O $string[]$ O O O O O $any$ O $boolean$ O $any$ O $RunMode.Attach$ O $any$ O $RunMode.Run$ O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $string[]$ O $FlutterLaunchRequestArguments$ O $any$ O $FlutterLaunchRequestArguments$ O $string$ O $Logger$ O O O $number$ O O O O
import { DebugSession } from "s" ; import { FlutterWebDebugSession } from "s" ; DebugSession . run ( FlutterWebDebugSession ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O
import { DartTestDebugSession } from "s" ; import { FlutterLaunchRequestArguments } from "s" ; export class FlutterWebTestDebugSession extends DartTestDebugSession { protected spawnProcess ( args ) { } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O $any$ O $FlutterLaunchRequestArguments$ O O O O
import { DebugSession } from "s" ; import { FlutterWebTestDebugSession } from "s" ; DebugSession . run ( FlutterWebTestDebugSession ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O
export interface ServerGetVersionResponse { version : string ; } export interface ServerSetSubscriptionsRequest { subscriptions : ServerService [ ] ; } export interface AnalysisGetErrorsRequest { file : FilePath ; } export interface AnalysisGetErrorsResponse { errors : AnalysisError [ ] ; } export interface AnalysisGetHoverRequest { file : FilePath ; offset : number ; } export interface AnalysisGetHoverResponse { hovers : HoverInformation [ ] ; } export interface AnalysisGetImportedElementsRequest { file : FilePath ; offset : number ; length : number ; } export interface AnalysisGetImportedElementsResponse { elements : ImportedElements [ ] ; } export interface AnalysisGetLibraryDependenciesResponse { libraries : FilePath [ ] ; packageMap : { [ key ] : { [ key ] : FilePath [ ] | undefined ; } | undefined ; } ; } export interface AnalysisGetNavigationRequest { file : FilePath ; offset : number ; length : number ; } export interface AnalysisGetNavigationResponse { files : FilePath [ ] ; targets : NavigationTarget [ ] ; regions : NavigationRegion [ ] ; } export interface AnalysisGetReachableSourcesRequest { file : FilePath ; } export interface AnalysisGetReachableSourcesResponse { sources : { [ key ] : string [ ] | undefined ; } ; } export interface AnalysisGetSignatureRequest { file : FilePath ; offset : number ; } export interface AnalysisGetSignatureResponse { name : string ; parameters : ParameterInfo [ ] ; dartdoc ? : string ; } export interface AnalysisSetAnalysisRootsRequest { included : FilePath [ ] ; excluded : FilePath [ ] ; packageRoots ? : { [ key ] : FilePath | undefined ; } ; } export interface AnalysisSetGeneralSubscriptionsRequest { subscriptions : GeneralAnalysisService [ ] ; } export interface AnalysisSetPriorityFilesRequest { files : FilePath [ ] ; } export interface AnalysisSetSubscriptionsRequest { subscriptions : { [ key ] : FilePath [ ] | undefined ; } ; } export interface AnalysisUpdateContentRequest { files : { [ key ] : AddContentOverlay | ChangeContentOverlay | RemoveContentOverlay | undefined ; } ; } export interface AnalysisUpdateOptionsRequest { options : AnalysisOptions ; } export interface CompletionGetSuggestionsRequest { file : FilePath ; offset : number ; } export interface CompletionGetSuggestionsResponse { id : CompletionId ; } export interface CompletionSetSubscriptionsRequest { subscriptions : CompletionService [ ] ; } export interface CompletionRegisterLibraryPathsRequest { paths : LibraryPathSet [ ] ; } export interface CompletionGetSuggestionDetailsRequest { file : FilePath ; id : number ; label : string ; offset : number ; } export interface CompletionGetSuggestionDetailsResponse { completion : string ; change ? : SourceChange ; } export interface CompletionListTokenDetailsRequest { file : FilePath ; } export interface CompletionListTokenDetailsResponse { tokens : TokenDetails [ ] ; } export interface SearchFindElementReferencesRequest { file : FilePath ; offset : number ; includePotential : boolean ; } export interface SearchFindElementReferencesResponse { id ? : SearchId ; element ? : Element ; } export interface SearchFindMemberDeclarationsRequest { name : string ; } export interface SearchFindMemberDeclarationsResponse { id : SearchId ; } export interface SearchFindMemberReferencesRequest { name : string ; } export interface SearchFindMemberReferencesResponse { id : SearchId ; } export interface SearchFindTopLevelDeclarationsRequest { pattern : string ; } export interface SearchFindTopLevelDeclarationsResponse { id : SearchId ; } export interface SearchGetElementDeclarationsRequest { file ? : FilePath ; pattern ? : string ; maxResults ? : number ; } export interface SearchGetElementDeclarationsResponse { declarations : ElementDeclaration [ ] ; files : FilePath [ ] ; } export interface SearchGetTypeHierarchyRequest { file : FilePath ; offset : number ; superOnly ? : boolean ; } export interface SearchGetTypeHierarchyResponse { hierarchyItems ? : TypeHierarchyItem [ ] ; } export interface EditFormatRequest { file : FilePath ; selectionOffset : number ; selectionLength : number ; lineLength ? : number ; } export interface EditFormatResponse { edits : SourceEdit [ ] ; selectionOffset : number ; selectionLength : number ; } export interface EditGetAssistsRequest { file : FilePath ; offset : number ; length : number ; } export interface EditGetAssistsResponse { assists : SourceChange [ ] ; } export interface EditGetAvailableRefactoringsRequest { file : FilePath ; offset : number ; length : number ; } export interface EditGetAvailableRefactoringsResponse { kinds : RefactoringKind [ ] ; } export interface EditGetDartfixInfoResponse { fixes : DartFix [ ] ; } export interface EditDartfixRequest { included : FilePath [ ] ; includedFixes ? : string [ ] ; includePedanticFixes ? : boolean ; includeRequiredFixes ? : boolean ; excludedFixes ? : string [ ] ; outputDir ? : FilePath ; } export interface EditDartfixResponse { suggestions : DartFixSuggestion [ ] ; otherSuggestions : DartFixSuggestion [ ] ; hasErrors : boolean ; edits : SourceFileEdit [ ] ; details ? : string [ ] ; } export interface EditGetFixesRequest { file : FilePath ; offset : number ; } export interface EditGetFixesResponse { fixes : AnalysisErrorFixes [ ] ; } export interface EditGetPostfixCompletionRequest { file : FilePath ; key : string ; offset : number ; } export interface EditGetPostfixCompletionResponse { change : SourceChange ; } export interface EditGetRefactoringRequest { kind : RefactoringKind ; file : FilePath ; offset : number ; length : number ; validateOnly : boolean ; options ? : RefactoringOptions ; } export interface EditGetRefactoringResponse { initialProblems : RefactoringProblem [ ] ; optionsProblems : RefactoringProblem [ ] ; finalProblems : RefactoringProblem [ ] ; feedback ? : RefactoringFeedback ; change ? : SourceChange ; potentialEdits ? : string [ ] ; } export interface EditGetStatementCompletionRequest { file : FilePath ; offset : number ; } export interface EditGetStatementCompletionResponse { change : SourceChange ; whitespaceOnly : boolean ; } export interface EditIsPostfixCompletionApplicableRequest { file : FilePath ; key : string ; offset : number ; } export interface EditIsPostfixCompletionApplicableResponse { value : boolean ; } export interface EditListPostfixCompletionTemplatesResponse { templates : PostfixTemplateDescriptor [ ] ; } export interface EditImportElementsRequest { file : FilePath ; elements : ImportedElements [ ] ; offset ? : number ; } export interface EditImportElementsResponse { edit ? : SourceFileEdit ; } export interface EditSortMembersRequest { file : FilePath ; } export interface EditSortMembersResponse { edit : SourceFileEdit ; } export interface EditOrganizeDirectivesRequest { file : FilePath ; } export interface EditOrganizeDirectivesResponse { edit : SourceFileEdit ; } export interface ExecutionCreateContextRequest { contextRoot : FilePath ; } export interface ExecutionCreateContextResponse { id : ExecutionContextId ; } export interface ExecutionDeleteContextRequest { id : ExecutionContextId ; } export interface ExecutionGetSuggestionsRequest { code : string ; offset : number ; contextFile : FilePath ; contextOffset : number ; variables : RuntimeCompletionVariable [ ] ; expressions ? : RuntimeCompletionExpression [ ] ; } export interface ExecutionGetSuggestionsResponse { suggestions ? : CompletionSuggestion [ ] ; expressions ? : RuntimeCompletionExpression [ ] ; } export interface ExecutionMapUriRequest { id : ExecutionContextId ; file ? : FilePath ; uri ? : string ; } export interface ExecutionMapUriResponse { file ? : FilePath ; uri ? : string ; } export interface ExecutionSetSubscriptionsRequest { subscriptions : ExecutionService [ ] ; } export interface DiagnosticGetDiagnosticsResponse { contexts : ContextData [ ] ; } export interface DiagnosticGetServerPortResponse { port : number ; } export interface AnalyticsIsEnabledResponse { enabled : boolean ; } export interface AnalyticsEnableRequest { value : boolean ; } export interface AnalyticsSendEventRequest { action : string ; } export interface AnalyticsSendTimingRequest { event : string ; millis : number ; } export interface KytheGetKytheEntriesRequest { file : FilePath ; } export interface KytheGetKytheEntriesResponse { entries : KytheEntry [ ] ; files : FilePath [ ] ; } export interface FlutterGetWidgetDescriptionRequest { file : FilePath ; offset : number ; } export interface FlutterGetWidgetDescriptionResponse { properties : FlutterWidgetProperty [ ] ; } export interface FlutterSetWidgetPropertyValueRequest { id : number ; value ? : FlutterWidgetPropertyValue ; } export interface FlutterSetWidgetPropertyValueResponse { change : SourceChange ; } export interface FlutterSetSubscriptionsRequest { subscriptions : { [ key ] : FilePath [ ] | undefined ; } ; } export interface ServerConnectedNotification { version : string ; pid : number ; sessionId ? : string ; } export interface ServerErrorNotification { isFatal : boolean ; message : string ; stackTrace : string ; } export interface ServerLogNotification { entry : ServerLogEntry ; } export interface ServerStatusNotification { analysis ? : AnalysisStatus ; pub ? : PubStatus ; } export interface AnalysisAnalyzedFilesNotification { directories : FilePath [ ] ; } export interface AnalysisClosingLabelsNotification { file : FilePath ; labels : ClosingLabel [ ] ; } export interface AnalysisErrorsNotification { file : FilePath ; errors : AnalysisError [ ] ; } export interface AnalysisFlushResultsNotification { files : FilePath [ ] ; } export interface AnalysisFoldingNotification { file : FilePath ; regions : FoldingRegion [ ] ; } export interface AnalysisHighlightsNotification { file : FilePath ; regions : HighlightRegion [ ] ; } export interface AnalysisImplementedNotification { file : FilePath ; classes : ImplementedClass [ ] ; members : ImplementedMember [ ] ; } export interface AnalysisInvalidateNotification { file : FilePath ; offset : number ; length : number ; delta : number ; } export interface AnalysisNavigationNotification { file : FilePath ; regions : NavigationRegion [ ] ; targets : NavigationTarget [ ] ; files : FilePath [ ] ; } export interface AnalysisOccurrencesNotification { file : FilePath ; occurrences : Occurrences [ ] ; } export interface AnalysisOutlineNotification { file : FilePath ; kind : FileKind ; libraryName ? : string ; outline : Outline ; } export interface AnalysisOverridesNotification { file : FilePath ; overrides : Override [ ] ; } export interface CompletionResultsNotification { id : CompletionId ; replacementOffset : number ; replacementLength : number ; results : CompletionSuggestion [ ] ; isLast : boolean ; libraryFile ? : FilePath ; includedSuggestionSets ? : IncludedSuggestionSet [ ] ; includedElementKinds ? : ElementKind [ ] ; includedSuggestionRelevanceTags ? : IncludedSuggestionRelevanceTag [ ] ; } export interface CompletionAvailableSuggestionsNotification { changedLibraries ? : AvailableSuggestionSet [ ] ; removedLibraries ? : number [ ] ; } export interface CompletionExistingImportsNotification { file : FilePath ; imports : ExistingImports ; } export interface SearchResultsNotification { id : SearchId ; results : SearchResult [ ] ; isLast : boolean ; } export interface ExecutionLaunchDataNotification { file : FilePath ; kind ? : ExecutableKind ; referencedFiles ? : FilePath [ ] ; } export interface FlutterOutlineNotification { file : FilePath ; outline : FlutterOutline ; } export interface AnalysisErrorFixes { error : AnalysisError ; fixes : SourceChange [ ] ; } export interface AnalysisOptions { enableAsync ? : boolean ; enableDeferredLoading ? : boolean ; enableEnums ? : boolean ; enableNullAwareOperators ? : boolean ; enableSuperMixins ? : boolean ; 0 ? : boolean ; generateHints ? : boolean ; generateLints ? : boolean ; } export type AnalysisService = "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" ; export interface AnalysisStatus { isAnalyzing : boolean ; analysisTarget ? : string ; } export interface ClosingLabel { offset : number ; length : number ; label : string ; } export type CompletionId = string ; export interface ContextData { name : string ; explicitFileCount : number ; implicitFileCount : number ; workItemQueueLength : number ; cacheEntryExceptions : string [ ] ; } export interface ElementDeclaration { name : string ; kind : ElementKind ; fileIndex : number ; offset : number ; line : number ; column : number ; codeOffset : number ; codeLength : number ; className ? : string ; mixinName ? : string ; parameters ? : string ; } export interface ExecutableFile { file : FilePath ; kind : ExecutableKind ; } export type ExecutableKind = "s" | "s" | "s" | "s" ; export type ExecutionContextId = string ; export interface AvailableSuggestion { label : string ; declaringLibraryUri : string ; element : Element ; defaultArgumentListString ? : string ; defaultArgumentListTextRanges ? : number [ ] ; parameterNames ? : string [ ] ; parameterTypes ? : string [ ] ; relevanceTags ? : AvailableSuggestionRelevanceTag [ ] ; requiredParameterCount ? : number ; } export type AvailableSuggestionRelevanceTag = string ; export interface AvailableSuggestionSet { id : number ; uri : string ; items : AvailableSuggestion [ ] ; } export interface ExistingImport { uri : number ; elements : number [ ] ; } export interface ExistingImports { elements : ImportedElementSet ; imports : ExistingImport [ ] ; } export interface ImportedElementSet { strings : string [ ] ; uris : number [ ] ; names : number [ ] ; } export interface IncludedSuggestionSet { id : number ; relevance : number ; displayUri ? : string ; } export interface IncludedSuggestionRelevanceTag { tag : AvailableSuggestionRelevanceTag ; relevanceBoost : number ; } export type CompletionService = "s" ; export interface LibraryPathSet { scope : FilePath ; libraryPaths : FilePath [ ] ; } export interface RuntimeCompletionExpression { offset : number ; length : number ; type ? : RuntimeCompletionExpressionType ; } export interface RuntimeCompletionVariable { name : string ; type : RuntimeCompletionExpressionType ; } export interface RuntimeCompletionExpressionType { libraryPath ? : FilePath ; kind : RuntimeCompletionExpressionTypeKind ; name ? : string ; typeArguments ? : RuntimeCompletionExpressionType [ ] ; returnType ? : RuntimeCompletionExpressionType ; parameterTypes ? : RuntimeCompletionExpressionType [ ] ; parameterNames ? : string [ ] ; } export type RuntimeCompletionExpressionTypeKind = "s" | "s" | "s" ; export interface TokenDetails { lexeme : string ; type ? : string ; validElementKinds ? : string [ ] ; offset : number ; } export type ExecutionService = "s" ; export type FileKind = "s" | "s" ; export interface FlutterWidgetProperty { documentation ? : string ; expression ? : string ; id : number ; isRequired : boolean ; isSafeToUpdate : boolean ; name : string ; children ? : FlutterWidgetProperty [ ] ; editor ? : FlutterWidgetPropertyEditor ; value ? : FlutterWidgetPropertyValue ; } export interface FlutterWidgetPropertyEditor { kind : FlutterWidgetPropertyEditorKind ; enumItems ? : FlutterWidgetPropertyValueEnumItem [ ] ; } export type FlutterWidgetPropertyEditorKind = "s" | "s" | "s" | "s" | "s" | "s" ; export interface FlutterWidgetPropertyValue { boolValue ? : boolean ; doubleValue ? : number ; intValue ? : number ; stringValue ? : string ; enumValue ? : FlutterWidgetPropertyValueEnumItem ; expression ? : string ; } export interface FlutterWidgetPropertyValueEnumItem { libraryUri : string ; className : string ; name : string ; documentation ? : string ; } export type FlutterService = "s" ; export interface FlutterOutline { kind : FlutterOutlineKind ; offset : number ; length : number ; codeOffset : number ; codeLength : number ; label ? : string ; dartElement ? : Element ; attributes ? : FlutterOutlineAttribute [ ] ; className ? : string ; parentAssociationLabel ? : string ; variableName ? : string ; children ? : FlutterOutline [ ] ; } export interface FlutterOutlineAttribute { name : string ; label : string ; literalValueBoolean ? : boolean ; literalValueInteger ? : number ; literalValueString ? : string ; nameLocation ? : Location ; valueLocation ? : Location ; } export type FlutterOutlineKind = "s" | "s" | "s" | "s" | "s" | "s" ; export type GeneralAnalysisService = "s" ; export interface HoverInformation { offset : number ; length : number ; containingLibraryPath ? : string ; containingLibraryName ? : string ; containingClassDescription ? : string ; dartdoc ? : string ; elementDescription ? : string ; elementKind ? : string ; isDeprecated ? : boolean ; parameter ? : string ; propagatedType ? : string ; staticType ? : string ; } export interface ImplementedClass { offset : number ; length : number ; } export interface ImplementedMember { offset : number ; length : number ; } export interface ImportedElements { path : FilePath ; prefix : string ; elements : string [ ] ; } export interface Override { offset : number ; length : number ; superclassMember ? : OverriddenMember ; interfaceMembers ? : OverriddenMember [ ] ; } export interface OverriddenMember { element : Element ; className : string ; } export interface PostfixTemplateDescriptor { name : string ; key : string ; example : string ; } export interface PubStatus { isListingPackageDirs : boolean ; } export interface RefactoringFeedback { } export interface RefactoringOptions { } export interface RequestError { code : RequestErrorCode ; message : string ; stackTrace ? : string ; } export type RequestErrorCode = "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" ; export type SearchId = string ; export interface DartFix { name : string ; description ? : string ; isRequired ? : boolean ; } export interface DartFixSuggestion { description : string ; location ? : Location ; } export interface SearchResult { location : Location ; kind : SearchResultKind ; isPotential : boolean ; path : Element [ ] ; } export type SearchResultKind = "s" | "s" | "s" | "s" | "s" | "s" | "s" ; export type ServerService = "s" | "s" ; export interface TypeHierarchyItem { classElement : Element ; displayName ? : string ; memberElement ? : Element ; superclass ? : number ; interfaces : number [ ] ; mixins : number [ ] ; subclasses : number [ ] ; } export interface ServerLogEntry { time : number ; kind : ServerLogEntryKind ; data : string ; } export type ServerLogEntryKind = "s" | "s" | "s" | "s" ; export interface ExtractLocalVariableFeedback extends RefactoringFeedback { coveringExpressionOffsets ? : number [ ] ; coveringExpressionLengths ? : number [ ] ; names : string [ ] ; offsets : number [ ] ; lengths : number [ ] ; } export interface ExtractMethodFeedback extends RefactoringFeedback { offset : number ; length : number ; returnType : string ; names : string [ ] ; canCreateGetter : boolean ; parameters : RefactoringMethodParameter [ ] ; offsets : number [ ] ; lengths : number [ ] ; } export interface InlineLocalVariableFeedback extends RefactoringFeedback { name : string ; occurrences : number ; } export interface InlineMethodFeedback extends RefactoringFeedback { className ? : string ; methodName : string ; isDeclaration : boolean ; } export interface RenameFeedback extends RefactoringFeedback { offset : number ; length : number ; elementKindName : string ; oldName : string ; } export interface AddContentOverlay { type : "s" ; content : string ; } export interface AnalysisError { severity : AnalysisErrorSeverity ; type : AnalysisErrorType ; location : Location ; message : string ; correction ? : string ; code : string ; url ? : string ; contextMessages ? : DiagnosticMessage [ ] ; hasFix ? : boolean ; } export type AnalysisErrorSeverity = "s" | "s" | "s" ; export type AnalysisErrorType = "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" ; export interface ChangeContentOverlay { type : "s" ; edits : SourceEdit [ ] ; } export interface CompletionSuggestion { kind : CompletionSuggestionKind ; relevance : number ; completion : string ; displayText ? : string ; selectionOffset : number ; selectionLength : number ; isDeprecated : boolean ; isPotential : boolean ; docSummary ? : string ; docComplete ? : string ; declaringType ? : string ; defaultArgumentListString ? : string ; defaultArgumentListTextRanges ? : number [ ] ; element ? : Element ; returnType ? : string ; parameterNames ? : string [ ] ; parameterTypes ? : string [ ] ; requiredParameterCount ? : number ; hasNamedParameters ? : boolean ; parameterName ? : string ; parameterType ? : string ; } export type CompletionSuggestionKind = "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" ; export interface DiagnosticMessage { message : string ; location : Location ; } export interface Element { kind : ElementKind ; name : string ; location ? : Location ; flags : number ; parameters ? : string ; returnType ? : string ; typeParameters ? : string ; } export type ElementKind = "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" ; export type FilePath = string ; export type FoldingKind = "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" ; export interface FoldingRegion { kind : FoldingKind ; offset : number ; length : number ; } export interface HighlightRegion { type : HighlightRegionType ; offset : number ; length : number ; } export type HighlightRegionType = "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" ; export interface KytheEntry { source : KytheVName ; kind ? : string ; target ? : KytheVName ; fact : string ; value ? : number [ ] ; } export interface KytheVName { signature : string ; corpus : string ; root : string ; path : string ; language : string ; } export interface LinkedEditGroup { positions : Position [ ] ; length : number ; suggestions : LinkedEditSuggestion [ ] ; } export interface LinkedEditSuggestion { value : string ; kind : LinkedEditSuggestionKind ; } export type LinkedEditSuggestionKind = "s" | "s" | "s" | "s" ; export interface Location { file : FilePath ; offset : number ; length : number ; startLine : number ; startColumn : number ; } export interface NavigationRegion { offset : number ; length : number ; targets : number [ ] ; } export interface NavigationTarget { kind : ElementKind ; fileIndex : number ; offset : number ; length : number ; startLine : number ; startColumn : number ; } export interface Occurrences { element : Element ; offsets : number [ ] ; length : number ; } export interface Outline { element : Element ; offset : number ; length : number ; codeOffset : number ; codeLength : number ; children ? : Outline [ ] ; } export interface ParameterInfo { kind : ParameterKind ; name : string ; type : string ; defaultValue ? : string ; } export type ParameterKind = "s" | "s" | "s" ; export interface Position { file : FilePath ; offset : number ; } export type RefactoringKind = "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" ; export interface RefactoringMethodParameter { id ? : string ; kind : RefactoringMethodParameterKind ; type : string ; name : string ; parameters ? : string ; } export type RefactoringMethodParameterKind = "s" | "s" | "s" ; export interface RefactoringProblem { severity : RefactoringProblemSeverity ; message : string ; location ? : Location ; } export type RefactoringProblemSeverity = "s" | "s" | "s" | "s" ; export interface RemoveContentOverlay { type : "s" ; } export interface SourceChange { message : string ; edits : SourceFileEdit [ ] ; linkedEditGroups : LinkedEditGroup [ ] ; selection ? : Position ; id ? : string ; } export interface SourceEdit { offset : number ; length : number ; replacement : string ; id ? : string ; } export interface SourceFileEdit { file : FilePath ; fileStamp : number ; edits : SourceEdit [ ] ; }	O O $any$ O $string$ O O O O O O $any$ O $ServerService[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O O O O $any$ O $AnalysisError[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $number$ O O O O O O $any$ O $HoverInformation[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $number$ O O O $number$ O O O O O O $any$ O $ImportedElements[]$ O $any$ O O O O O O $any$ O $string[]$ O $any$ O O O $complex$ O O O $string$ O O O O $string$ O O $any$ O O O O O O O O O O O O O O $any$ O $string$ O $any$ O $number$ O O O $number$ O O O O O O $any$ O $string[]$ O $any$ O O O $NavigationTarget[]$ O $any$ O O O $NavigationRegion[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O O O O $any$ O $complex$ O O O $string$ O O O O O O O O O O O O O $any$ O $string$ O $any$ O $number$ O O O O O O $any$ O $string$ O O O $ParameterInfo[]$ O $any$ O O O $string$ O O O O O O O $any$ O $string[]$ O $any$ O O O $string[]$ O $any$ O O O $complex$ O O O O $string$ O O $any$ O O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $string[]$ O $any$ O O O O O O $any$ O $complex$ O O O $string$ O O $any$ O O O O O O O O O O $any$ O $complex$ O O O $string$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $AnalysisOptions$ O $any$ O O O O $any$ O $string$ O $any$ O $number$ O O O O O O $any$ O $string$ O $any$ O O O O $any$ O O O $any$ O O O O O O $any$ O $LibraryPathSet[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $number$ O O O $string$ O O O $number$ O O O O O O $any$ O $string$ O O O $SourceChange$ O O $any$ O O O O $any$ O $string$ O $any$ O O O O $any$ O $TokenDetails[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $number$ O O O $boolean$ O O O O O O $any$ O $string$ O O $any$ O $Element$ O O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $string$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $string$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $string$ O $any$ O O O O $any$ O $string$ O O $any$ O $string$ O O O O $number$ O O O O O O O $any$ O $ElementDeclaration[]$ O $any$ O O O $string[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $number$ O O O $boolean$ O O O O O O O $any$ O $TypeHierarchyItem[]$ O O $any$ O O O O O O $any$ O $string$ O $any$ O $number$ O O O $number$ O O O $number$ O O O O O O O $any$ O $SourceEdit[]$ O $any$ O O O $number$ O O O $number$ O O O O O O $any$ O $string$ O $any$ O $number$ O O O $number$ O O O O O O $any$ O $SourceChange[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $number$ O O O $number$ O O O O O O $any$ O $RefactoringKind[]$ O $any$ O O O O O O $any$ O $DartFix[]$ O $any$ O O O O O O $any$ O $string[]$ O $any$ O O O $string[]$ O O O O O O $boolean$ O O O O $boolean$ O O O O $string[]$ O O O O O O $string$ O O $any$ O O O O $any$ O $DartFixSuggestion[]$ O $any$ O O O $DartFixSuggestion[]$ O $any$ O O O $boolean$ O O O $SourceFileEdit[]$ O $any$ O O O $string[]$ O O O O O O O O O $any$ O $string$ O $any$ O $number$ O O O O O O $any$ O $AnalysisErrorFixes[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $string$ O O O $number$ O O O O O O $any$ O $SourceChange$ O $any$ O O O O $any$ O $RefactoringKind$ O $any$ O $string$ O $any$ O $number$ O O O $number$ O O O $boolean$ O O O $RefactoringOptions$ O O $any$ O O O O $any$ O $RefactoringProblem[]$ O $any$ O O O $RefactoringProblem[]$ O $any$ O O O $RefactoringProblem[]$ O $any$ O O O $RefactoringFeedback$ O O $any$ O $SourceChange$ O O $any$ O $string[]$ O O O O O O O O O $any$ O $string$ O $any$ O $number$ O O O O O O $any$ O $SourceChange$ O $any$ O $boolean$ O O O O O O $any$ O $string$ O $any$ O $string$ O O O $number$ O O O O O O $any$ O $boolean$ O O O O O O $any$ O $PostfixTemplateDescriptor[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $ImportedElements[]$ O $any$ O O O $number$ O O O O O O O $any$ O $SourceFileEdit$ O O $any$ O O O O $any$ O $string$ O $any$ O O O O $any$ O $SourceFileEdit$ O $any$ O O O O $any$ O $string$ O $any$ O O O O $any$ O $SourceFileEdit$ O $any$ O O O O $any$ O $string$ O $any$ O O O O $any$ O $string$ O $any$ O O O O $any$ O $string$ O $any$ O O O O $any$ O $string$ O O O $number$ O O O $string$ O $any$ O $number$ O O O $RuntimeCompletionVariable[]$ O $any$ O O O $RuntimeCompletionExpression[]$ O O $any$ O O O O O O $any$ O $CompletionSuggestion[]$ O O $any$ O O O $RuntimeCompletionExpression[]$ O O $any$ O O O O O O $any$ O $string$ O $any$ O $string$ O O $any$ O $string$ O O O O O O O $any$ O $string$ O O $any$ O $string$ O O O O O O O $any$ O O O $any$ O O O O O O $any$ O $ContextData[]$ O $any$ O O O O O O $any$ O $number$ O O O O O O $any$ O $boolean$ O O O O O O $any$ O $boolean$ O O O O O O $any$ O $string$ O O O O O O $any$ O $string$ O O O $number$ O O O O O O $any$ O $string$ O $any$ O O O O $any$ O $KytheEntry[]$ O $any$ O O O $string[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $number$ O O O O O O $any$ O $FlutterWidgetProperty[]$ O $any$ O O O O O O $any$ O $number$ O O O $FlutterWidgetPropertyValue$ O O $any$ O O O O $any$ O $SourceChange$ O $any$ O O O O $any$ O $complex$ O O O $string$ O O $any$ O O O O O O O O O O $any$ O $string$ O O O $number$ O O O $string$ O O O O O O O $any$ O $boolean$ O O O $string$ O O O $string$ O O O O O O $any$ O $ServerLogEntry$ O $any$ O O O O $any$ O $AnalysisStatus$ O O $any$ O $PubStatus$ O O $any$ O O O O $any$ O $string[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $ClosingLabel[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $AnalysisError[]$ O $any$ O O O O O O $any$ O $string[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $FoldingRegion[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $HighlightRegion[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $ImplementedClass[]$ O $any$ O O O $ImplementedMember[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $number$ O O O $number$ O O O $number$ O O O O O O $any$ O $string$ O $any$ O $NavigationRegion[]$ O $any$ O O O $NavigationTarget[]$ O $any$ O O O $string[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $Occurrences[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $FileKind$ O $any$ O $string$ O O O O $Outline$ O $any$ O O O O $any$ O $string$ O $any$ O $Override[]$ O $any$ O O O O O O $any$ O $string$ O $any$ O $number$ O O O $number$ O O O $CompletionSuggestion[]$ O $any$ O O O $boolean$ O O O $string$ O O $any$ O $IncludedSuggestionSet[]$ O O $any$ O O O $ElementKind[]$ O O $any$ O O O $IncludedSuggestionRelevanceTag[]$ O O $any$ O O O O O O $any$ O $AvailableSuggestionSet[]$ O O $any$ O O O $number[]$ O O O O O O O O O $any$ O $string$ O $any$ O $ExistingImports$ O $any$ O O O O $any$ O $string$ O $any$ O $SearchResult[]$ O $any$ O O O $boolean$ O O O O O O $any$ O $string$ O $any$ O $ExecutableKind$ O O $any$ O $string[]$ O O $any$ O O O O O O $any$ O $string$ O $any$ O $FlutterOutline$ O $any$ O O O O $any$ O $AnalysisError$ O $any$ O $SourceChange[]$ O $any$ O O O O O O $any$ O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O $any$ O $boolean$ O O O $string$ O O O O O O O $any$ O $number$ O O O $number$ O O O $string$ O O O O O O $any$ O O O O O $any$ O $string$ O O O $number$ O O O $number$ O O O $number$ O O O $string[]$ O O O O O O O O $any$ O $string$ O O O $ElementKind$ O $any$ O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O O $string$ O O O O $string$ O O O O O O O $any$ O $string$ O $any$ O $ExecutableKind$ O $any$ O O O O $any$ O O O O O O O O O O O $any$ O O O O O $any$ O $string$ O O O $string$ O O O $Element$ O $any$ O $string$ O O O O $number[]$ O O O O O O $string[]$ O O O O O O $string[]$ O O O O O O $string[]$ O O $any$ O O O $number$ O O O O O O O $any$ O O O O O $any$ O $number$ O O O $string$ O O O $AvailableSuggestion[]$ O $any$ O O O O O O $any$ O $number$ O O O $number[]$ O O O O O O O O $any$ O $ImportedElementSet$ O $any$ O $ExistingImport[]$ O $any$ O O O O O O $any$ O $string[]$ O O O O O $number[]$ O O O O O $number[]$ O O O O O O O O $any$ O $number$ O O O $number$ O O O $string$ O O O O O O O $any$ O $string$ O $any$ O $number$ O O O O O O $any$ O O O O O $any$ O $string$ O $any$ O $string[]$ O $any$ O O O O O O $any$ O $number$ O O O $number$ O O O $RuntimeCompletionExpressionType$ O O $any$ O O O O $any$ O $string$ O O O $RuntimeCompletionExpressionType$ O $any$ O O O O $any$ O $string$ O O $any$ O $RuntimeCompletionExpressionTypeKind$ O $any$ O $string$ O O O O $RuntimeCompletionExpressionType[]$ O O $any$ O O O $RuntimeCompletionExpressionType$ O O $any$ O $RuntimeCompletionExpressionType[]$ O O $any$ O O O $string[]$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $string$ O O O $string$ O O O O $string[]$ O O O O O O $number$ O O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O $string$ O O O O $string$ O O O O $number$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O $FlutterWidgetProperty[]$ O O $any$ O O O $FlutterWidgetPropertyEditor$ O O $any$ O $FlutterWidgetPropertyValue$ O O $any$ O O O O $any$ O $FlutterWidgetPropertyEditorKind$ O $any$ O $FlutterWidgetPropertyValueEnumItem[]$ O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O $any$ O $boolean$ O O O O $number$ O O O O $number$ O O O O $string$ O O O O $FlutterWidgetPropertyValueEnumItem$ O O $any$ O $string$ O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $any$ O O O O O $any$ O $FlutterOutlineKind$ O $any$ O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O O $Element$ O O $any$ O $FlutterOutlineAttribute[]$ O O $any$ O O O $string$ O O O O $string$ O O O O $string$ O O O O $FlutterOutline[]$ O O $any$ O O O O O O $any$ O $string$ O O O $string$ O O O $boolean$ O O O O $number$ O O O O $string$ O O O O $Location$ O O $any$ O $Location$ O O $any$ O O O O $any$ O O O O O O O O O O O O O O O $any$ O O O O O $any$ O $number$ O O O $number$ O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $boolean$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O O O O $any$ O $number$ O O O $number$ O O O O O O $any$ O $number$ O O O $number$ O O O O O O $any$ O $string$ O $any$ O $string$ O O O $string[]$ O O O O O O O O $any$ O $number$ O O O $number$ O O O $OverriddenMember$ O O $any$ O $OverriddenMember[]$ O O $any$ O O O O O O $any$ O $Element$ O $any$ O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $boolean$ O O O O O O $any$ O O O O $any$ O O O O $any$ O $RequestErrorCode$ O $any$ O $string$ O O O $string$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O $any$ O $string$ O O O $string$ O O O O $boolean$ O O O O O O O $any$ O $string$ O O O $Location$ O O $any$ O O O O $any$ O $Location$ O $any$ O $SearchResultKind$ O $any$ O $boolean$ O O O $Element[]$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O $Element$ O $any$ O $string$ O O O O $Element$ O O $any$ O $number$ O O O O $number[]$ O O O O O $number[]$ O O O O O $number[]$ O O O O O O O O $any$ O $number$ O O O $ServerLogEntryKind$ O $any$ O $string$ O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O $number[]$ O O O O O O $number[]$ O O O O O O $string[]$ O O O O O $number[]$ O O O O O $number[]$ O O O O O O O O $any$ O $any$ O $number$ O O O $number$ O O O $string$ O O O $string[]$ O O O O O $boolean$ O O O $RefactoringMethodParameter[]$ O $any$ O O O $number[]$ O O O O O $number[]$ O O O O O O O O $any$ O $any$ O $string$ O O O $number$ O O O O O O $any$ O $any$ O $string$ O O O O $string$ O O O $boolean$ O O O O O O $any$ O $any$ O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O O O $any$ O O O O O $string$ O O O O O O $any$ O $AnalysisErrorSeverity$ O $any$ O $AnalysisErrorType$ O $any$ O $Location$ O $any$ O $string$ O O O $string$ O O O O $string$ O O O $string$ O O O O $DiagnosticMessage[]$ O O $any$ O O O $boolean$ O O O O O O O $any$ O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O O O O $SourceEdit[]$ O $any$ O O O O O O $any$ O $CompletionSuggestionKind$ O $any$ O $number$ O O O $string$ O O O $string$ O O O O $number$ O O O $number$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $number[]$ O O O O O O $Element$ O O $any$ O $string$ O O O O $string[]$ O O O O O O $string[]$ O O O O O O $number$ O O O O $boolean$ O O O O $string$ O O O O $string$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O $Location$ O $any$ O O O O $any$ O $ElementKind$ O $any$ O $string$ O O O $Location$ O O $any$ O $number$ O O O $string$ O O O O $string$ O O O O $string$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O $FoldingKind$ O $any$ O $number$ O O O $number$ O O O O O O $any$ O $HighlightRegionType$ O $any$ O $number$ O O O $number$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $KytheVName$ O $any$ O $string$ O O O O $KytheVName$ O O $any$ O $string$ O O O $number[]$ O O O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $Position[]$ O $any$ O O O $number$ O O O $LinkedEditSuggestion[]$ O $any$ O O O O O O $any$ O $string$ O O O $LinkedEditSuggestionKind$ O $any$ O O O O $any$ O O O O O O O O O O O $any$ O $string$ O $any$ O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O O $any$ O $number$ O O O $number$ O O O $number[]$ O O O O O O O O $any$ O $ElementKind$ O $any$ O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O O $any$ O $Element$ O $any$ O $number[]$ O O O O O $number$ O O O O O O $any$ O $Element$ O $any$ O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $Outline[]$ O O $any$ O O O O O O $any$ O $ParameterKind$ O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O O $any$ O O O O O O O O O $any$ O $string$ O $any$ O $number$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O $RefactoringMethodParameterKind$ O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O O $any$ O O O O O O O O O $any$ O $RefactoringProblemSeverity$ O $any$ O $string$ O O O $Location$ O O $any$ O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $string$ O O O $SourceFileEdit[]$ O $any$ O O O $LinkedEditGroup[]$ O $any$ O O O $Position$ O O $any$ O $string$ O O O O O O O $any$ O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O O O O $any$ O $string$ O $any$ O $number$ O O O $SourceEdit[]$ O $any$ O O O O
import * as vs from "s" ; import * as as from "s" ; import { LogCategory } from "s" ; import { Logger } from "s" ; import { CategoryLogger } from "s" ; import { UnknownNotification , UnknownResponse } from "s" ; import { StdIOService } from "s" ; export abstract class AnalyzerGen extends StdIOService < UnknownNotification > { constructor ( logger , maxLogLineLength : number | undefined ) { super ( new CategoryLogger ( logger , LogCategory . Analyzer ) , maxLogLineLength ) ; } protected buildRequest < TReq > ( id , method , params ? ) : { id : string , method : string , params ? : TReq } { return Object . assign ( super . buildRequest ( id , method , params ) , { clientRequestTime : Date . now ( ) } , ) ; } private serverConnectedSubscriptions : ( ( notification : as . ServerConnectedNotification ) => void ) [ ] = [ ] ; private serverErrorSubscriptions : ( ( notification : as . ServerErrorNotification ) => void ) [ ] = [ ] ; private serverStatusSubscriptions : ( ( notification : as . ServerStatusNotification ) => void ) [ ] = [ ] ; private analysisAnalyzedFilesSubscriptions : ( ( notification : as . AnalysisAnalyzedFilesNotification ) => void ) [ ] = [ ] ; private analysisClosingLabelsSubscriptions : ( ( notification : as . AnalysisClosingLabelsNotification ) => void ) [ ] = [ ] ; private analysisErrorsSubscriptions : ( ( notification : as . AnalysisErrorsNotification ) => void ) [ ] = [ ] ; private analysisFlushResultsSubscriptions : ( ( notification : as . AnalysisFlushResultsNotification ) => void ) [ ] = [ ] ; private analysisFoldingSubscriptions : ( ( notification : as . AnalysisFoldingNotification ) => void ) [ ] = [ ] ; private analysisHighlightsSubscriptions : ( ( notification : as . AnalysisHighlightsNotification ) => void ) [ ] = [ ] ; private analysisImplementedSubscriptions : ( ( notification : as . AnalysisImplementedNotification ) => void ) [ ] = [ ] ; private analysisInvalidateSubscriptions : ( ( notification : as . AnalysisInvalidateNotification ) => void ) [ ] = [ ] ; private analysisNavigationSubscriptions : ( ( notification : as . AnalysisNavigationNotification ) => void ) [ ] = [ ] ; private analysisOccurrencesSubscriptions : ( ( notification : as . AnalysisOccurrencesNotification ) => void ) [ ] = [ ] ; private analysisOutlineSubscriptions : ( ( notification : as . AnalysisOutlineNotification ) => void ) [ ] = [ ] ; private analysisOverridesSubscriptions : ( ( notification : as . AnalysisOverridesNotification ) => void ) [ ] = [ ] ; private completionResultsSubscriptions : ( ( notification : as . CompletionResultsNotification ) => void ) [ ] = [ ] ; private completionAvailableSuggestionsSubscriptions : ( ( notification : as . CompletionAvailableSuggestionsNotification ) => void ) [ ] = [ ] ; private completionExistingImportsSubscriptions : ( ( notification : as . CompletionExistingImportsNotification ) => void ) [ ] = [ ] ; private searchResultsSubscriptions : ( ( notification : as . SearchResultsNotification ) => void ) [ ] = [ ] ; private executionLaunchDataSubscriptions : ( ( notification : as . ExecutionLaunchDataNotification ) => void ) [ ] = [ ] ; private flutterOutlineSubscriptions : ( ( notification : as . FlutterOutlineNotification ) => void ) [ ] = [ ] ; protected handleNotification ( evt ) { switch ( evt . event ) { case "s" : this . notify ( this . serverConnectedSubscriptions , < as . ServerConnectedNotification > evt . params ) ; break ; case "s" : this . notify ( this . serverErrorSubscriptions , < as . ServerErrorNotification > evt . params ) ; break ; case "s" : this . notify ( this . serverStatusSubscriptions , < as . ServerStatusNotification > evt . params ) ; break ; case "s" : this . notify ( this . analysisAnalyzedFilesSubscriptions , < as . AnalysisAnalyzedFilesNotification > evt . params ) ; break ; case "s" : this . notify ( this . analysisClosingLabelsSubscriptions , < as . AnalysisClosingLabelsNotification > evt . params ) ; break ; case "s" : this . notify ( this . analysisErrorsSubscriptions , < as . AnalysisErrorsNotification > evt . params ) ; break ; case "s" : this . notify ( this . analysisFlushResultsSubscriptions , < as . AnalysisFlushResultsNotification > evt . params ) ; break ; case "s" : this . notify ( this . analysisFoldingSubscriptions , < as . AnalysisFoldingNotification > evt . params ) ; break ; case "s" : this . notify ( this . analysisHighlightsSubscriptions , < as . AnalysisHighlightsNotification > evt . params ) ; break ; case "s" : this . notify ( this . analysisImplementedSubscriptions , < as . AnalysisImplementedNotification > evt . params ) ; break ; case "s" : this . notify ( this . analysisInvalidateSubscriptions , < as . AnalysisInvalidateNotification > evt . params ) ; break ; case "s" : this . notify ( this . analysisNavigationSubscriptions , < as . AnalysisNavigationNotification > evt . params ) ; break ; case "s" : this . notify ( this . analysisOccurrencesSubscriptions , < as . AnalysisOccurrencesNotification > evt . params ) ; break ; case "s" : this . notify ( this . analysisOutlineSubscriptions , < as . AnalysisOutlineNotification > evt . params ) ; break ; case "s" : this . notify ( this . analysisOverridesSubscriptions , < as . AnalysisOverridesNotification > evt . params ) ; break ; case "s" : this . notify ( this . completionResultsSubscriptions , < as . CompletionResultsNotification > evt . params ) ; break ; case "s" : this . notify ( this . completionAvailableSuggestionsSubscriptions , < as . CompletionAvailableSuggestionsNotification > evt . params ) ; break ; case "s" : this . notify ( this . completionExistingImportsSubscriptions , < as . CompletionExistingImportsNotification > evt . params ) ; break ; case "s" : this . notify ( this . searchResultsSubscriptions , < as . SearchResultsNotification > evt . params ) ; break ; case "s" : this . notify ( this . executionLaunchDataSubscriptions , < as . ExecutionLaunchDataNotification > evt . params ) ; break ; case "s" : this . notify ( this . flutterOutlineSubscriptions , < as . FlutterOutlineNotification > evt . params ) ; break ; } } registerForServerConnected ( subscriber : ( notification : as . ServerConnectedNotification ) => void ) : vs . Disposable { return this . subscribe ( this . serverConnectedSubscriptions , subscriber ) ; } registerForServerError ( subscriber : ( notification : as . ServerErrorNotification ) => void ) : vs . Disposable { return this . subscribe ( this . serverErrorSubscriptions , subscriber ) ; } registerForServerStatus ( subscriber : ( notification : as . ServerStatusNotification ) => void ) : vs . Disposable { return this . subscribe ( this . serverStatusSubscriptions , subscriber ) ; } registerForAnalysisAnalyzedFiles ( subscriber : ( notification : as . AnalysisAnalyzedFilesNotification ) => void ) : vs . Disposable { return this . subscribe ( this . analysisAnalyzedFilesSubscriptions , subscriber ) ; } registerForAnalysisClosingLabels ( subscriber : ( notification : as . AnalysisClosingLabelsNotification ) => void ) : vs . Disposable { return this . subscribe ( this . analysisClosingLabelsSubscriptions , subscriber ) ; } registerForAnalysisErrors ( subscriber : ( notification : as . AnalysisErrorsNotification ) => void ) : vs . Disposable { return this . subscribe ( this . analysisErrorsSubscriptions , subscriber ) ; } registerForAnalysisFlushResults ( subscriber : ( notification : as . AnalysisFlushResultsNotification ) => void ) : vs . Disposable { return this . subscribe ( this . analysisFlushResultsSubscriptions , subscriber ) ; } registerForAnalysisFolding ( subscriber : ( notification : as . AnalysisFoldingNotification ) => void ) : vs . Disposable { return this . subscribe ( this . analysisFoldingSubscriptions , subscriber ) ; } registerForAnalysisHighlights ( subscriber : ( notification : as . AnalysisHighlightsNotification ) => void ) : vs . Disposable { return this . subscribe ( this . analysisHighlightsSubscriptions , subscriber ) ; } registerForAnalysisImplemented ( subscriber : ( notification : as . AnalysisImplementedNotification ) => void ) : vs . Disposable { return this . subscribe ( this . analysisImplementedSubscriptions , subscriber ) ; } registerForAnalysisInvalidate ( subscriber : ( notification : as . AnalysisInvalidateNotification ) => void ) : vs . Disposable { return this . subscribe ( this . analysisInvalidateSubscriptions , subscriber ) ; } registerForAnalysisNavigation ( subscriber : ( notification : as . AnalysisNavigationNotification ) => void ) : vs . Disposable { return this . subscribe ( this . analysisNavigationSubscriptions , subscriber ) ; } registerForAnalysisOccurrences ( subscriber : ( notification : as . AnalysisOccurrencesNotification ) => void ) : vs . Disposable { return this . subscribe ( this . analysisOccurrencesSubscriptions , subscriber ) ; } registerForAnalysisOutline ( subscriber : ( notification : as . AnalysisOutlineNotification ) => void ) : vs . Disposable { return this . subscribe ( this . analysisOutlineSubscriptions , subscriber ) ; } registerForAnalysisOverrides ( subscriber : ( notification : as . AnalysisOverridesNotification ) => void ) : vs . Disposable { return this . subscribe ( this . analysisOverridesSubscriptions , subscriber ) ; } registerForCompletionResults ( subscriber : ( notification : as . CompletionResultsNotification ) => void ) : vs . Disposable { return this . subscribe ( this . completionResultsSubscriptions , subscriber ) ; } registerForCompletionAvailableSuggestions ( subscriber : ( notification : as . CompletionAvailableSuggestionsNotification ) => void ) : vs . Disposable { return this . subscribe ( this . completionAvailableSuggestionsSubscriptions , subscriber ) ; } registerForCompletionExistingImports ( subscriber : ( notification : as . CompletionExistingImportsNotification ) => void ) : vs . Disposable { return this . subscribe ( this . completionExistingImportsSubscriptions , subscriber ) ; } registerForSearchResults ( subscriber : ( notification : as . SearchResultsNotification ) => void ) : vs . Disposable { return this . subscribe ( this . searchResultsSubscriptions , subscriber ) ; } registerForExecutionLaunchData ( subscriber : ( notification : as . ExecutionLaunchDataNotification ) => void ) : vs . Disposable { return this . subscribe ( this . executionLaunchDataSubscriptions , subscriber ) ; } registerForFlutterOutline ( subscriber : ( notification : as . FlutterOutlineNotification ) => void ) : vs . Disposable { return this . subscribe ( this . flutterOutlineSubscriptions , subscriber ) ; } serverGetVersion ( ) < as . ServerGetVersionResponse > { return this . sendRequest ( "s" ) ; } serverShutdown ( ) < UnknownResponse > { return this . sendRequest ( "s" ) ; } serverSetSubscriptions ( request : as . ServerSetSubscriptionsRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } analysisGetErrors ( request : as . AnalysisGetErrorsRequest ) < as . AnalysisGetErrorsResponse > { return this . sendRequest ( "s" , request ) ; } analysisGetHover ( request : as . AnalysisGetHoverRequest ) < as . AnalysisGetHoverResponse > { return this . sendRequest ( "s" , request ) ; } analysisGetImportedElements ( request : as . AnalysisGetImportedElementsRequest ) < as . AnalysisGetImportedElementsResponse > { return this . sendRequest ( "s" , request ) ; } analysisGetLibraryDependencies ( ) < as . AnalysisGetLibraryDependenciesResponse > { return this . sendRequest ( "s" ) ; } analysisGetNavigation ( request : as . AnalysisGetNavigationRequest ) < as . AnalysisGetNavigationResponse > { return this . sendRequest ( "s" , request ) ; } analysisGetReachableSources ( request : as . AnalysisGetReachableSourcesRequest ) < as . AnalysisGetReachableSourcesResponse > { return this . sendRequest ( "s" , request ) ; } analysisGetSignature ( request : as . AnalysisGetSignatureRequest ) < as . AnalysisGetSignatureResponse > { return this . sendRequest ( "s" , request ) ; } analysisReanalyze ( ) < UnknownResponse > { return this . sendRequest ( "s" ) ; } analysisSetAnalysisRoots ( request : as . AnalysisSetAnalysisRootsRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } analysisSetGeneralSubscriptions ( request : as . AnalysisSetGeneralSubscriptionsRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } analysisSetPriorityFiles ( request : as . AnalysisSetPriorityFilesRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } analysisSetSubscriptions ( request : as . AnalysisSetSubscriptionsRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } analysisUpdateContent ( request : as . AnalysisUpdateContentRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } analysisUpdateOptions ( request : as . AnalysisUpdateOptionsRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } completionGetSuggestions ( request : as . CompletionGetSuggestionsRequest ) < as . CompletionGetSuggestionsResponse > { return this . sendRequest ( "s" , request ) ; } completionSetSubscriptions ( request : as . CompletionSetSubscriptionsRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } completionRegisterLibraryPaths ( request : as . CompletionRegisterLibraryPathsRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } completionGetSuggestionDetails ( request : as . CompletionGetSuggestionDetailsRequest ) < as . CompletionGetSuggestionDetailsResponse > { return this . sendRequest ( "s" , request ) ; } completionListTokenDetails ( request : as . CompletionListTokenDetailsRequest ) < as . CompletionListTokenDetailsResponse > { return this . sendRequest ( "s" , request ) ; } searchFindElementReferences ( request : as . SearchFindElementReferencesRequest ) < as . SearchFindElementReferencesResponse > { return this . sendRequest ( "s" , request ) ; } searchFindMemberDeclarations ( request : as . SearchFindMemberDeclarationsRequest ) < as . SearchFindMemberDeclarationsResponse > { return this . sendRequest ( "s" , request ) ; } searchFindMemberReferences ( request : as . SearchFindMemberReferencesRequest ) < as . SearchFindMemberReferencesResponse > { return this . sendRequest ( "s" , request ) ; } searchFindTopLevelDeclarations ( request : as . SearchFindTopLevelDeclarationsRequest ) < as . SearchFindTopLevelDeclarationsResponse > { return this . sendRequest ( "s" , request ) ; } searchGetElementDeclarations ( request : as . SearchGetElementDeclarationsRequest ) < as . SearchGetElementDeclarationsResponse > { return this . sendRequest ( "s" , request ) ; } searchGetTypeHierarchy ( request : as . SearchGetTypeHierarchyRequest ) < as . SearchGetTypeHierarchyResponse > { return this . sendRequest ( "s" , request ) ; } editFormat ( request : as . EditFormatRequest ) < as . EditFormatResponse > { return this . sendRequest ( "s" , request ) ; } editGetAssists ( request : as . EditGetAssistsRequest ) < as . EditGetAssistsResponse > { return this . sendRequest ( "s" , request ) ; } editGetAvailableRefactorings ( request : as . EditGetAvailableRefactoringsRequest ) < as . EditGetAvailableRefactoringsResponse > { return this . sendRequest ( "s" , request ) ; } editGetDartfixInfo ( ) < as . EditGetDartfixInfoResponse > { return this . sendRequest ( "s" ) ; } editDartfix ( request : as . EditDartfixRequest ) < as . EditDartfixResponse > { return this . sendRequest ( "s" , request ) ; } editGetFixes ( request : as . EditGetFixesRequest ) < as . EditGetFixesResponse > { return this . sendRequest ( "s" , request ) ; } editGetPostfixCompletion ( request : as . EditGetPostfixCompletionRequest ) < as . EditGetPostfixCompletionResponse > { return this . sendRequest ( "s" , request ) ; } editGetRefactoring ( request : as . EditGetRefactoringRequest ) < as . EditGetRefactoringResponse > { return this . sendRequest ( "s" , request ) ; } editGetStatementCompletion ( request : as . EditGetStatementCompletionRequest ) < as . EditGetStatementCompletionResponse > { return this . sendRequest ( "s" , request ) ; } editIsPostfixCompletionApplicable ( request : as . EditIsPostfixCompletionApplicableRequest ) < as . EditIsPostfixCompletionApplicableResponse > { return this . sendRequest ( "s" , request ) ; } editListPostfixCompletionTemplates ( ) < as . EditListPostfixCompletionTemplatesResponse > { return this . sendRequest ( "s" ) ; } editImportElements ( request : as . EditImportElementsRequest ) < as . EditImportElementsResponse > { return this . sendRequest ( "s" , request ) ; } editSortMembers ( request : as . EditSortMembersRequest ) < as . EditSortMembersResponse > { return this . sendRequest ( "s" , request ) ; } editOrganizeDirectives ( request : as . EditOrganizeDirectivesRequest ) < as . EditOrganizeDirectivesResponse > { return this . sendRequest ( "s" , request ) ; } executionCreateContext ( request : as . ExecutionCreateContextRequest ) < as . ExecutionCreateContextResponse > { return this . sendRequest ( "s" , request ) ; } executionDeleteContext ( request : as . ExecutionDeleteContextRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } executionGetSuggestions ( request : as . ExecutionGetSuggestionsRequest ) < as . ExecutionGetSuggestionsResponse > { return this . sendRequest ( "s" , request ) ; } executionMapUri ( request : as . ExecutionMapUriRequest ) < as . ExecutionMapUriResponse > { return this . sendRequest ( "s" , request ) ; } executionSetSubscriptions ( request : as . ExecutionSetSubscriptionsRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } diagnosticGetDiagnostics ( ) < as . DiagnosticGetDiagnosticsResponse > { return this . sendRequest ( "s" ) ; } diagnosticGetServerPort ( ) < as . DiagnosticGetServerPortResponse > { return this . sendRequest ( "s" ) ; } analyticsIsEnabled ( ) < as . AnalyticsIsEnabledResponse > { return this . sendRequest ( "s" ) ; } analyticsEnable ( request : as . AnalyticsEnableRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } analyticsSendEvent ( request : as . AnalyticsSendEventRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } analyticsSendTiming ( request : as . AnalyticsSendTimingRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } kytheGetKytheEntries ( request : as . KytheGetKytheEntriesRequest ) < as . KytheGetKytheEntriesResponse > { return this . sendRequest ( "s" , request ) ; } flutterSetSubscriptions ( request : as . FlutterSetSubscriptionsRequest ) < UnknownResponse > { return this . sendRequest ( "s" , request ) ; } }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $Logger$ O $number$ O O O O O O O O O $any$ O $Logger$ O $any$ O $LogCategory.Analyzer$ O O $number$ O O O O $complex$ O $any$ O O $number$ O $string$ O $TReq$ $TReq$ O O O $string$ O O O $string$ O O O $TReq$ O O $any$ O O O $ObjectConstructor$ O O O O O $complex$ O $number$ O $string$ O $TReq$ O O O $number$ O $DateConstructor$ O $number$ O O O O O O O O $void)[]$ O O O $ServerConnectedNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $ServerErrorNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $ServerStatusNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $AnalysisAnalyzedFilesNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $AnalysisClosingLabelsNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $AnalysisErrorsNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $AnalysisFlushResultsNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $AnalysisFoldingNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $AnalysisHighlightsNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $AnalysisImplementedNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $AnalysisInvalidateNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $AnalysisNavigationNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $AnalysisOccurrencesNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $AnalysisOutlineNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $AnalysisOverridesNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $CompletionResultsNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $CompletionAvailableSuggestionsNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $CompletionExistingImportsNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $SearchResultsNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $ExecutionLaunchDataNotification$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O O O $FlutterOutlineNotification$ O $any$ O $any$ O O O O O O O O O O O $void$ O $UnknownNotification$ O O O O $UnknownNotification$ O $string$ O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O O $any$ O $any$ O $UnknownNotification$ O $any$ O O O O O O $any$ O $void$ O O $ServerConnectedNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $ServerErrorNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $ServerStatusNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $AnalysisAnalyzedFilesNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $AnalysisClosingLabelsNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $AnalysisErrorsNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $AnalysisFlushResultsNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $AnalysisFoldingNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $AnalysisHighlightsNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $AnalysisImplementedNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $AnalysisInvalidateNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $AnalysisNavigationNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $AnalysisOccurrencesNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $AnalysisOutlineNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $AnalysisOverridesNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $CompletionResultsNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $CompletionAvailableSuggestionsNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $CompletionExistingImportsNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $SearchResultsNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $ExecutionLaunchDataNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $any$ O $void$ O O $FlutterOutlineNotification$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O $Promise$ O O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O O O $Promise$ O O O $any$ O O O O O $Promise<TResp>$ O O O O O $Promise$ O $ServerSetSubscriptionsRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $ServerSetSubscriptionsRequest$ O O O $Promise$ O $AnalysisGetErrorsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $AnalysisGetErrorsRequest$ O O O $Promise$ O $AnalysisGetHoverRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $AnalysisGetHoverRequest$ O O O $Promise$ O $AnalysisGetImportedElementsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $AnalysisGetImportedElementsRequest$ O O O $Promise$ O O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O O O $Promise$ O $AnalysisGetNavigationRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $AnalysisGetNavigationRequest$ O O O $Promise$ O $AnalysisGetReachableSourcesRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $AnalysisGetReachableSourcesRequest$ O O O $Promise$ O $AnalysisGetSignatureRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $AnalysisGetSignatureRequest$ O O O $Promise$ O O O $any$ O O O O O $Promise<TResp>$ O O O O O $Promise$ O $AnalysisSetAnalysisRootsRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $AnalysisSetAnalysisRootsRequest$ O O O $Promise$ O $AnalysisSetGeneralSubscriptionsRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $AnalysisSetGeneralSubscriptionsRequest$ O O O $Promise$ O $AnalysisSetPriorityFilesRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $AnalysisSetPriorityFilesRequest$ O O O $Promise$ O $AnalysisSetSubscriptionsRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $AnalysisSetSubscriptionsRequest$ O O O $Promise$ O $AnalysisUpdateContentRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $AnalysisUpdateContentRequest$ O O O $Promise$ O $AnalysisUpdateOptionsRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $AnalysisUpdateOptionsRequest$ O O O $Promise$ O $CompletionGetSuggestionsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $CompletionGetSuggestionsRequest$ O O O $Promise$ O $CompletionSetSubscriptionsRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $CompletionSetSubscriptionsRequest$ O O O $Promise$ O $CompletionRegisterLibraryPathsRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $CompletionRegisterLibraryPathsRequest$ O O O $Promise$ O $CompletionGetSuggestionDetailsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $CompletionGetSuggestionDetailsRequest$ O O O $Promise$ O $CompletionListTokenDetailsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $CompletionListTokenDetailsRequest$ O O O $Promise$ O $SearchFindElementReferencesRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $SearchFindElementReferencesRequest$ O O O $Promise$ O $SearchFindMemberDeclarationsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $SearchFindMemberDeclarationsRequest$ O O O $Promise$ O $SearchFindMemberReferencesRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $SearchFindMemberReferencesRequest$ O O O $Promise$ O $SearchFindTopLevelDeclarationsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $SearchFindTopLevelDeclarationsRequest$ O O O $Promise$ O $SearchGetElementDeclarationsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $SearchGetElementDeclarationsRequest$ O O O $Promise$ O $SearchGetTypeHierarchyRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $SearchGetTypeHierarchyRequest$ O O O $Promise$ O $EditFormatRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $EditFormatRequest$ O O O $Promise$ O $EditGetAssistsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $EditGetAssistsRequest$ O O O $Promise$ O $EditGetAvailableRefactoringsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $EditGetAvailableRefactoringsRequest$ O O O $Promise$ O O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O O O $Promise$ O $EditDartfixRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $EditDartfixRequest$ O O O $Promise$ O $EditGetFixesRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $EditGetFixesRequest$ O O O $Promise$ O $EditGetPostfixCompletionRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $EditGetPostfixCompletionRequest$ O O O $Promise$ O $EditGetRefactoringRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $EditGetRefactoringRequest$ O O O $Promise$ O $EditGetStatementCompletionRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $EditGetStatementCompletionRequest$ O O O $Promise$ O $EditIsPostfixCompletionApplicableRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $EditIsPostfixCompletionApplicableRequest$ O O O $Promise$ O O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O O O $Promise$ O $EditImportElementsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $EditImportElementsRequest$ O O O $Promise$ O $EditSortMembersRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $EditSortMembersRequest$ O O O $Promise$ O $EditOrganizeDirectivesRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $EditOrganizeDirectivesRequest$ O O O $Promise$ O $ExecutionCreateContextRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $ExecutionCreateContextRequest$ O O O $Promise$ O $ExecutionDeleteContextRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $ExecutionDeleteContextRequest$ O O O $Promise$ O $ExecutionGetSuggestionsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $ExecutionGetSuggestionsRequest$ O O O $Promise$ O $ExecutionMapUriRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $ExecutionMapUriRequest$ O O O $Promise$ O $ExecutionSetSubscriptionsRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $ExecutionSetSubscriptionsRequest$ O O O $Promise$ O O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O O O $Promise$ O O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O O O $Promise$ O O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O O O $Promise$ O $AnalyticsEnableRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $AnalyticsEnableRequest$ O O O $Promise$ O $AnalyticsSendEventRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $AnalyticsSendEventRequest$ O O O $Promise$ O $AnalyticsSendTimingRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $AnalyticsSendTimingRequest$ O O O $Promise$ O $KytheGetKytheEntriesRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O $KytheGetKytheEntriesRequest$ O O O $Promise$ O $FlutterSetSubscriptionsRequest$ O $any$ O $any$ O O $any$ O O O O O $Promise<TResp>$ O O O $FlutterSetSubscriptionsRequest$ O O O O
import * as vs from "s" ; import * as as from "s" ; import { LogCategory } from "s" ; import { Logger } from "s" ; import { PromiseCompleter , versionIsAtLeast } from "s" ; import { extensionVersion } from "s" ; import { config } from "s" ; import { escapeShell , reloadExtension } from "s" ; import { AnalyzerGen } from "s" ; export class AnalyzerCapabilities { public static get empty ( ) { return new AnalyzerCapabilities ( "s" ) ; } public version : string ; constructor ( analyzerVersion ) { this . version = analyzerVersion ; } get hasCompleteStatementFix ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsPriorityFilesOutsideAnalysisRoots ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsDiagnostics ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsClosingLabels ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsCustomFolding ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsFlutterOutline ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsGetDeclerations ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsGetDeclerationsForFile ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsGetSignature ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get 0 ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get hasNewSignatureFormat ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get hasNewHoverLibraryFormat ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsAvailableSuggestions ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsIncludedImports ( ) { return versionIsAtLeast ( this . version , "s" ) ; } } export class DasAnalyzer extends AnalyzerGen { private lastDiagnostics ? : as . ContextData [ ] ; private launchArgs : string [ ] ; private version ? : string ; private isAnalyzing = false ; private currentAnalysisCompleter ? : PromiseCompleter < void > ; public capabilities : AnalyzerCapabilities = AnalyzerCapabilities . empty ; constructor ( logger , dartVMPath , analyzerPath ) { super ( logger , config . maxLogLineLength ) ; let analyzerArgs = [ ] ; if ( config . analyzerObservatoryPort ) analyzerArgs . push ( `template` ) ; analyzerArgs . push ( analyzerPath ) ; if ( config . analyzerDiagnosticsPort ) analyzerArgs . push ( `template` ) ; analyzerArgs . push ( `template` ) ; analyzerArgs . push ( `template` ) ; if ( config . analyzerInstrumentationLogFile ) analyzerArgs . push ( `template` ) ; if ( config . analyzerAdditionalArgs ) analyzerArgs = analyzerArgs . concat ( config . analyzerAdditionalArgs ) ; this . launchArgs = analyzerArgs ; this . registerForServerError ( ( e ) => this . requestDiagnosticsUpdate ( ) ) ; this . registerForRequestError ( ( e ) => this . requestDiagnosticsUpdate ( ) ) ; this . registerForServerConnected ( ( e ) => { this . version = e . version ; this . capabilities . version = this . version ; } ) ; let binaryPath = dartVMPath ; let processArgs = analyzerArgs . slice ( ) ; if ( config . analyzerSshHost ) { binaryPath = "s" ; processArgs . unshift ( dartVMPath ) ; processArgs = [ "s" , config . analyzerSshHost , escapeShell ( processArgs ) , ] ; } this . createProcess ( undefined , binaryPath , processArgs ) ; this . serverSetSubscriptions ( { subscriptions : [ "s" ] , } ) ; this . registerForServerStatus ( ( n ) => { if ( n . analysis ) { if ( n . analysis . isAnalyzing ) { this . isAnalyzing = true ; } else { this . isAnalyzing = false ; if ( this . currentAnalysisCompleter ) { this . currentAnalysisCompleter . resolve ( ) ; this . currentAnalysisCompleter = undefined ; } } } } ) ; } private resolvedPromise = Promise . resolve ( ) ; public get currentAnalysis ( ) : Promise < void > { if ( ! this . isAnalyzing ) return this . resolvedPromise ; if ( ! this . currentAnalysisCompleter ) this . currentAnalysisCompleter = new PromiseCompleter < void > ( ) ; return this . currentAnalysisCompleter . promise ; } protected sendMessage < T > ( json ) { try { super . sendMessage ( json ) ; } catch ( e ) { const message = this . version ? "s" : "s" ; reloadExtension ( message , undefined , true ) ; throw e ; } } protected shouldHandleMessage ( message ) { return ! message . startsWith ( "s" ) && ! message . startsWith ( "s" ) && ! message . startsWith ( "s" ) && ! message . startsWith ( "s" ) ; } private async requestDiagnosticsUpdate ( ) { this . lastDiagnostics = undefined ; if ( ! this . capabilities . supportsDiagnostics ) return ; this . lastDiagnostics = ( await this . diagnosticGetDiagnostics ( ) ) . contexts ; } public getLastDiagnostics ( ) : as . ContextData [ ] | undefined { return this . lastDiagnostics ; } public getAnalyzerLaunchArgs ( ) : string [ ] { return this . launchArgs ; } public forceNotificationsFor ( file ) { const files : { [ key ] : as . ChangeContentOverlay } = { } ; files [ file ] = { edits : [ { offset : 0 , length : 0 , replacement : "s" , id : "s" } ] , type : "s" , } ; this . analysisUpdateContent ( { files } ) ; } public completionGetSuggestionsResults ( request : as . CompletionGetSuggestionsRequest ) < as . CompletionResultsNotification > { return this . requestWithStreamedResults ( ( ) => this . completionGetSuggestions ( request ) , this . registerForCompletionResults , ) ; } public searchFindElementReferencesResults ( request : as . SearchFindElementReferencesRequest ) < as . SearchResultsNotification > { return this . requestWithStreamedResults ( ( ) => this . searchFindElementReferences ( request ) , this . registerForSearchResults , ) ; } public searchFindTopLevelDeclarationsResults ( request : as . SearchFindTopLevelDeclarationsRequest ) < as . SearchResultsNotification > { return this . requestWithStreamedResults ( ( ) => this . searchFindTopLevelDeclarations ( request ) , this . registerForSearchResults , ) ; } public searchFindMemberDeclarationsResults ( request : as . SearchFindMemberDeclarationsRequest ) < as . SearchResultsNotification > { return this . requestWithStreamedResults ( ( ) => this . searchFindMemberDeclarations ( request ) , this . registerForSearchResults , ) ; } private requestWithStreamedResults < TResponse extends { id : string ; isLast : boolean } > ( sendRequest : ( ) => Thenable < { id ? : string } > , registerForResults : ( subscriber : ( notification ) => void ) => vs . Disposable , ) < TResponse > { return new Promise < TResponse > ( ( resolve , reject ) => { const buffer : TResponse [ ] = [ ] ; let searchResultsID : string | undefined ; const disposable = registerForResults . bind ( this ) ( ( notification ) => { if ( searchResultsID && notification . id === searchResultsID && notification . isLast ) { disposable . dispose ( ) ; resolve ( notification ) ; } else if ( ! searchResultsID && notification . isLast ) buffer . push ( notification ) ; } ) ; sendRequest . bind ( this ) ( ) . then ( ( resp : { id ? : string } ) => { if ( ! resp . id ) { disposable . dispose ( ) ; reject ( ) ; } searchResultsID = resp . id ; const result = buffer . find ( ( b ) => b . id === searchResultsID ) ; if ( result ) { disposable . dispose ( ) ; resolve ( result ) ; } } , ( ) => reject ( ) ) ; } ) ; } } export function getSymbolKindForElementKind ( logger , kind : as . ElementKind ) : vs . SymbolKind { switch ( kind ) { case "s" : case "s" : case "s" : return vs . SymbolKind . Class ; case "s" : case "s" : return vs . SymbolKind . Module ; case "s" : case "s" : return vs . SymbolKind . Constructor ; case "s" : return vs . SymbolKind . Enum ; case "s" : return vs . SymbolKind . EnumMember ; case "s" : return vs . SymbolKind . Field ; case "s" : return vs . SymbolKind . File ; case "s" : case "s" : case "s" : return vs . SymbolKind . Function ; case "s" : return vs . SymbolKind . Property ; case "s" : return vs . SymbolKind . Module ; case "s" : return vs . SymbolKind . Namespace ; case "s" : return vs . SymbolKind . Variable ; case "s" : return vs . SymbolKind . Method ; case "s" : case "s" : return vs . SymbolKind . Variable ; case "s" : return vs . SymbolKind . Property ; case "s" : case "s" : return vs . SymbolKind . Variable ; case "s" : return vs . SymbolKind . Module ; case "s" : return vs . SymbolKind . Method ; case "s" : return vs . SymbolKind . Object ; default : logger . error ( `template` , LogCategory . Analyzer ) ; return vs . SymbolKind . Object ; } }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $boolean$ O O O O O O $string$ O O O O O O $Config$ O O O O O O $string$ O $Promise<void>$ O O O O O O $any$ O O O O O O $any$ O O O O $AnalyzerCapabilities$ O O O O O $any$ O O O O O O $string$ O O O O O $string$ O O O O $string$ O $string$ O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O O O $any$ O $any$ O O $ContextData[]$ O O $any$ O $any$ O O O O $string[]$ O O O O O O $string$ O O O O O $boolean$ O O O O $PromiseCompleter<void>$ O O $any$ O O O O O $AnalyzerCapabilities$ O $any$ O $any$ O $AnalyzerCapabilities$ O O O $Logger$ O $string$ O $string$ O O O O $Logger$ O $Config$ O $number$ O O O $any[]$ O O O O O O $Config$ O $number$ O $any[]$ O $number$ O O O O $any[]$ O $number$ O $string$ O O O O $Config$ O $number$ O $any[]$ O $number$ O O O O $any[]$ O $number$ O O O O $any[]$ O $number$ O O O O O O $Config$ O $string$ O $any[]$ O $number$ O O O O O O $Config$ O $string[]$ O $any[]$ O $any[]$ O $complex$ O $Config$ O $string[]$ O O O O $string[]$ O $any[]$ O O O $any$ O O $ServerErrorNotification$ O O O O $Promise<void>$ O O O O O O $IAmDisposable$ O O $any$ O O O O $Promise<void>$ O O O O O O $any$ O O $ServerConnectedNotification$ O O O O O $string$ O $ServerConnectedNotification$ O $string$ O O O $AnalyzerCapabilities$ O $string$ O O O $string$ O O O O O $string$ O $string$ O O $any[]$ O $any[]$ O $any[]$ O O O O O $Config$ O $string$ O O $string$ O O O $any[]$ O $number$ O $string$ O O $any[]$ O O O O $Config$ O $string$ O $string$ O $any[]$ O O O O O O O $void$ O $undefined$ O $string$ O $any[]$ O O O O $Promise<UnknownResponse>$ O O O O O O O O O O O O O $any$ O O $ServerStatusNotification$ O O O O O $ServerStatusNotification$ O $AnalysisStatus$ O O O O $ServerStatusNotification$ O $AnalysisStatus$ O $boolean$ O O O O $boolean$ O O O O O O O O $boolean$ O O O O O O O $PromiseCompleter<void>$ O O O O $PromiseCompleter<void>$ O $void$ O O O O O $PromiseCompleter<void>$ O $undefined$ O O O O O O O O O $Promise<void>$ O $PromiseConstructor$ O $complex$ O O O O O $Promise<void>$ O O O $PromiseConstructor$ O O O O O O O O O $boolean$ O O O O $Promise<void>$ O O O O O O $PromiseCompleter<void>$ O O O $PromiseCompleter<void>$ O O $any$ O O O O O O O O O $PromiseCompleter<void>$ O $Promise<void>$ O O O $void$ O $any$ O O $string$ O O O O O O $void$ O $string$ O O O O O $any$ O O O O O O O $string$ O O O O O $Promise<void>$ O O O $undefined$ O O O O O $any$ O O O O $boolean$ O $string$ O O O O $string$ O $boolean$ O O O O O $string$ O $boolean$ O O O O O $string$ O $boolean$ O O O O O $string$ O $boolean$ O O O O O O O $Promise<void>$ O O O O O $ContextData[]$ O $undefined$ O O O O O O $AnalyzerCapabilities$ O $boolean$ O O O O O $ContextData[]$ O O O O O $Promise<DiagnosticGetDiagnosticsResponse>$ O O O O $ContextData[]$ O O O $ContextData[]$ O O O $any$ O $any$ O O O O O O O O $ContextData[]$ O O O $string[]$ O O O O O O O O O O $string[]$ O O O $void$ O $string$ O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O $complex$ O $string$ O O O $complex$ O O O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O O O O O O O O O O $Promise<UnknownResponse>$ O O $complex$ O O O O O $Promise$ O $CompletionGetSuggestionsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResponse>$ O O O O O O $Promise<CompletionGetSuggestionsResponse>$ O $CompletionGetSuggestionsRequest$ O O O O $any$ O O O O O $Promise$ O $SearchFindElementReferencesRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResponse>$ O O O O O O $Promise<SearchFindElementReferencesResponse>$ O $SearchFindElementReferencesRequest$ O O O O $any$ O O O O O $Promise$ O $SearchFindTopLevelDeclarationsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResponse>$ O O O O O O $Promise<SearchFindTopLevelDeclarationsResponse>$ O $SearchFindTopLevelDeclarationsRequest$ O O O O $any$ O O O O O $Promise$ O $SearchFindMemberDeclarationsRequest$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise<TResponse>$ O O O O O O $Promise<SearchFindMemberDeclarationsResponse>$ O $SearchFindMemberDeclarationsRequest$ O O O O $any$ O O O O O $Promise$ O $any$ O O $string$ O O O $boolean$ O O O O O $any$ O O O O $any$ O O $string$ O O O O O O $any$ O O $void$ O O $TResponse$ O O O O O $any$ O $any$ O O O $any$ O O O O $PromiseConstructor$ O $any$ O O O $void$ O $void$ O O O O $TResponse[]$ O $any$ O O O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O $TResponse$ O O O O O $string$ O $TResponse$ O $string$ O $string$ O $TResponse$ O $boolean$ O O $any$ O $any$ O O O $void$ O $TResponse$ O O O O O O O $string$ O $TResponse$ O $boolean$ O $TResponse[]$ O $number$ O $TResponse$ O O O O O $any$ O $any$ O O O O O O $any$ O O $complex$ O O $string$ O O O O O O O O O O $complex$ O $string$ O O $any$ O $any$ O O O $void$ O O O O $string$ O $complex$ O $string$ O O $TResponse$ O $TResponse[]$ O $complex$ O O $TResponse$ O O $TResponse$ O $string$ O $string$ O O O O $TResponse$ O O $any$ O $any$ O O O $void$ O $TResponse$ O O O O O O O O $void$ O O O O O O O O O O O $any$ O $Logger$ O $ElementKind$ O $any$ O $any$ O O $any$ O $any$ O O O $ElementKind$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $Logger$ O $void$ O O O $any$ O $LogCategory.Analyzer$ O O O $any$ O $any$ O $any$ O O O
import * as fs from "s" ; import * as path from "s" ; import * as vs from "s" ; import { analyzerSnapshotPath } from "s" ; import { DartSdks , Logger } from "s" ; import { extensionVersion } from "s" ; import { config } from "s" ; import { DasAnalyzer } from "s" ; export class Analyzer extends DasAnalyzer { constructor ( logger , dartVMPath , analyzerPath ) { super ( logger , dartVMPath , analyzerPath ) ; } } export function getAnalyzerArgs ( logger , sdks , isLsp ) { const analyzerPath = config . analyzerPath || path . join ( sdks . dart , analyzerSnapshotPath ) ; if ( ! config . analyzerSshHost && ! fs . existsSync ( analyzerPath ) ) { const msg = "s" + analyzerPath ; vs . window . showErrorMessage ( msg ) ; logger . error ( msg ) ; throw new Error ( msg ) ; } return buildAnalyzerArgs ( analyzerPath , isLsp ) ; } function buildAnalyzerArgs ( analyzerPath , isLsp ) { let analyzerArgs = [ ] ; if ( config . analyzerObservatoryPort ) analyzerArgs . push ( `template` ) ; analyzerArgs . push ( analyzerPath ) ; if ( isLsp ) analyzerArgs . push ( "s" ) ; if ( config . analyzerDiagnosticsPort ) analyzerArgs . push ( `template` ) ; analyzerArgs . push ( `template` ) ; analyzerArgs . push ( `template` ) ; if ( config . analyzerInstrumentationLogFile ) analyzerArgs . push ( `template` ) ; if ( config . analyzerAdditionalArgs ) analyzerArgs = analyzerArgs . concat ( config . analyzerAdditionalArgs ) ; return analyzerArgs ; }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O O $string$ O O O O O O $Config$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O $Logger$ O $string$ O $string$ O O O O $Logger$ O $string$ O $string$ O O O O O O $any[]$ O $Logger$ O $DartSdks$ O $boolean$ O O O $any$ O $Config$ O $string$ O $any$ O $any$ O $DartSdks$ O $string$ O O O O O O O $Config$ O $string$ O O $any$ O $any$ O $any$ O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O $Logger$ O $void$ O $string$ O O O O $ErrorConstructor$ O $string$ O O O O $any[]$ O $any$ O $boolean$ O O O O $any[]$ O $string$ O $boolean$ O O O $any[]$ O O O O O O $Config$ O $number$ O $any[]$ O $number$ O O O O $any[]$ O $number$ O $string$ O O O O $boolean$ O $any[]$ O $number$ O O O O O O $Config$ O $number$ O $any[]$ O $number$ O O O O $any[]$ O $number$ O O O O $any[]$ O $number$ O O O O O O $Config$ O $string$ O $any[]$ O $number$ O O O O O O $Config$ O $string[]$ O $any[]$ O $any[]$ O $complex$ O $Config$ O $string[]$ O O O $any[]$ O O
import * as fs from "s" ; import * as os from "s" ; import * as path from "s" ; import { env , ProgressLocation , version as codeVersion , window , workspace } from "s" ; import { RequestError , ServerErrorNotification , ServerStatusNotification } from "s" ; import { LogCategory } from "s" ; import { Logger } from "s" ; import { isStableSdk , PromiseCompleter } from "s" ; import { getRandomInt } from "s" ; import { extensionVersion } from "s" ; import { WorkspaceContext } from "s" ; import { Analytics } from "s" ; import { config } from "s" ; import { getSdkVersion } from "s" ; import { Analyzer } from "s" ; const maxErrorReportCount = 0 ; const sendFakeErrorAtStartup = false ; let errorCount = 0 ; export class AnalyzerStatusReporter { private analysisInProgress = false ; private analyzingPromise ? : PromiseCompleter < void > ; constructor ( private readonly logger , private readonly analyzer , private readonly workspaceContext , private readonly analytics ) { analyzer . registerForServerStatus ( ( n ) => this . handleServerStatus ( n ) ) ; analyzer . registerForServerError ( ( e ) => this . handleServerError ( e ) ) ; analyzer . registerForRequestError ( ( e ) => this . handleRequestError ( e ) ) ; if ( sendFakeErrorAtStartup ) { setTimeout ( ( ) => { this . handleServerError ( { isFatal : false , message : "s" , stackTrace : new Error ( ) . stack || "s" , } , "s" , ) ; } , 0 ) ; } } private handleServerStatus ( status ) { if ( ! status . analysis ) return ; this . analysisInProgress = status . analysis . isAnalyzing ; if ( this . analysisInProgress ) { setTimeout ( ( ) => { if ( this . analysisInProgress && ! this . analyzingPromise ) { window . withProgress ( { location : ProgressLocation . Window , title : "s" } , ( _ ) => { if ( ! this . analyzingPromise ) this . analyzingPromise = new PromiseCompleter ( ) ; return this . analyzingPromise . promise ; } ) ; } } , 0 ) ; } else { if ( this . analyzingPromise ) { this . analyzingPromise . resolve ( ) ; this . analyzingPromise = undefined ; } } } private handleRequestError ( error : RequestError & { method ? : string } ) { this . handleServerError ( { isFatal : false , message : error . message , stackTrace : error . stackTrace || "s" , } , error . method , ) ; } private handleServerError ( error , method ? ) { this . logger . error ( error . message , LogCategory . Analyzer ) ; if ( error . stackTrace ) this . logger . error ( error . stackTrace , LogCategory . Analyzer ) ; this . analytics . logAnalyzerError ( ( method ? `template` : "s" ) + error . message , error . isFatal ) ; errorCount ++ ; if ( config . reportAnalyzerErrors && errorCount <= maxErrorReportCount && this . shouldReportErrors ( ) ) { const shouldReport = "s" ; window . showErrorMessage ( `template` , shouldReport ) . then ( ( res ) => { if ( res === shouldReport ) this . reportError ( error , method ) ; } ) ; } } private shouldReportErrors ( ) { const sdks = this . workspaceContext . sdks ; if ( this . workspaceContext . hasAnyFlutterProjects && sdks . flutter ) return ! isStableSdk ( getSdkVersion ( this . logger , sdks . flutter ) ) ; else return ! isStableSdk ( getSdkVersion ( this . logger , sdks . dart ) ) ; } private reportError ( error , method ? ) { const sdkVersion = getSdkVersion ( this . logger , this . workspaceContext . sdks . dart ) ; const flutterSdkVersion = this . workspaceContext . sdks . dartSdkIsFromFlutter ? getSdkVersion ( this . logger , this . workspaceContext . sdks . flutter ) : undefined ; const diagnostics = this . analyzer . getLastDiagnostics ( ) ; const analyzerArgs = this . analyzer . getAnalyzerLaunchArgs ( ) ; const data = `template` ; const fileName = `template` ; const tempPath = path . join ( os . tmpdir ( ) , fileName ) ; fs . writeFileSync ( tempPath , data ) ; workspace . openTextDocument ( tempPath ) . then ( ( document ) => { window . showTextDocument ( document ) ; } ) ; } }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $boolean$ O $any$ O O O O O O $number$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Config$ O O O O O O $string$ O O O O O O $any$ O O O O O O O O O O $false$ O O O O $number$ O O O O O $any$ O O $boolean$ O O O O $PromiseCompleter<void>$ O O $any$ O O O O O O O O $Logger$ O O O $Analyzer$ O O O $WorkspaceContext$ O O O $Analytics$ O O $Analyzer$ O $any$ O O $ServerStatusNotification$ O O O O $void$ O $ServerStatusNotification$ O O O $Analyzer$ O $any$ O O $ServerErrorNotification$ O O O O $void$ O $ServerErrorNotification$ O O O $Analyzer$ O $IAmDisposable$ O O $any$ O O O O $void$ O $any$ O O O O O $false$ O O $number$ O O O O O O O $void$ O O $false$ O O O $string$ O O O $string$ O O $ErrorConstructor$ O O O $string$ O O O O O O O O O O O O O O O O O $void$ O $ServerStatusNotification$ O O O O O $ServerStatusNotification$ O $AnalysisStatus$ O O O O O $boolean$ O $ServerStatusNotification$ O $AnalysisStatus$ O $boolean$ O O O O O $boolean$ O O $number$ O O O O O O O O O $boolean$ O O O O $PromiseCompleter<void>$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O $PromiseCompleter<void>$ O O O $PromiseCompleter<void>$ O O $any$ O O O O O O $PromiseCompleter<void>$ O $Promise<void>$ O O O O O O O O O O O O O O O O O $PromiseCompleter<void>$ O O O O $PromiseCompleter<void>$ O $void$ O O O O O $PromiseCompleter<void>$ O $undefined$ O O O O O $void$ O $complex$ O $any$ O O $string$ O O O O O O O O $void$ O O $false$ O O O $string$ O $complex$ O $string$ O $string$ O $complex$ O $string$ O O O O O $complex$ O $string$ O O O O O $void$ O $ServerErrorNotification$ O $string$ $string$ O O O O $Logger$ O $void$ O $ServerErrorNotification$ O $string$ O $any$ O $LogCategory.Analyzer$ O O O O $ServerErrorNotification$ O $string$ O O O $Logger$ O $void$ O $ServerErrorNotification$ O $string$ O $any$ O $LogCategory.Analyzer$ O O O O $Analytics$ O $void$ O O $string$ O O O O O O $ServerErrorNotification$ O $string$ O $ServerErrorNotification$ O $boolean$ O O $number$ O O O O $Config$ O $boolean$ O $number$ O O O O O $boolean$ O O O O O $string$ O O O $any$ O $any$ O O O $string$ O O $any$ O O $any$ O O O O O $any$ O $string$ O O O $void$ O $ServerErrorNotification$ O $string$ O O O O O O O O $boolean$ O O O O $Sdks$ O O O $WorkspaceContext$ O $Sdks$ O O O O O $WorkspaceContext$ O $boolean$ O $Sdks$ O $string$ O O O $boolean$ O $string$ O O O $Logger$ O $Sdks$ O $string$ O O O O O O $boolean$ O $string$ O O O $Logger$ O $Sdks$ O $string$ O O O O O $void$ O $ServerErrorNotification$ O $string$ $string$ O O O $string$ O $string$ O O O $Logger$ O O O $WorkspaceContext$ O $Sdks$ O $string$ O O O $string$ O O O $WorkspaceContext$ O $Sdks$ O $boolean$ O $string$ O O O $Logger$ O O O $WorkspaceContext$ O $Sdks$ O $string$ O O $undefined$ O O $ContextData[]$ O O O $Analyzer$ O $ContextData[]$ O O O O $string[]$ O O O $Analyzer$ O $string[]$ O O O O $string$ O O O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O
import * as vs from "s" ; import * as as from "s" ; import { fsPath } from "s" ; import { config } from "s" ; import * as util from "s" ; import { Analyzer } from "s" ; export class FileChangeHandler implements vs . Disposable { private readonly disposables : vs . Disposable [ ] = [ ] ; private readonly filesWarnedAbout = new Set < string > ( ) ; constructor ( private readonly analyzer ) { this . disposables . push ( vs . workspace . onDidOpenTextDocument ( ( td ) => this . onDidOpenTextDocument ( td ) ) , vs . workspace . onDidChangeTextDocument ( ( e ) => this . onDidChangeTextDocument ( e ) ) , vs . workspace . onDidCloseTextDocument ( ( td ) => this . onDidCloseTextDocument ( td ) ) , ) ; vs . workspace . textDocuments . forEach ( ( td ) => this . onDidOpenTextDocument ( td ) ) ; } public onDidOpenTextDocument ( document : vs . TextDocument ) { if ( ! util . isAnalyzable ( document ) ) return ; const files : { [ key ] : as . AddContentOverlay } = { } ; files [ fsPath ( document . uri ) ] = { content : document . getText ( ) , type : "s" , } ; this . analyzer . analysisUpdateContent ( { files } ) ; } public onDidChangeTextDocument ( e : vs . TextDocumentChangeEvent ) { if ( ! util . isAnalyzable ( e . document ) ) return ; if ( e . contentChanges . length === 0 ) return ; const filePath = fsPath ( e . document . uri ) ; if ( vs . workspace . workspaceFolders && vs . workspace . workspaceFolders . length && config . warnWhenEditingFilesOutsideWorkspace && ! this . filesWarnedAbout . has ( filePath ) && ! util . isWithinWorkspace ( filePath ) ) { const dontShowAgainAction = "s" ; vs . window . showWarningMessage ( "s" , dontShowAgainAction ) . then ( ( action ) => { if ( action === dontShowAgainAction ) config . setWarnWhenEditingFilesOutsideWorkspace ( false ) ; } ) ; this . filesWarnedAbout . add ( filePath ) ; } const files : { [ key ] : as . ChangeContentOverlay } = { } ; files [ filePath ] = { edits : e . contentChanges . map ( ( c ) => this . convertChange ( e . document , c ) ) , type : "s" , } ; this . analyzer . analysisUpdateContent ( { files } ) ; } public onDidCloseTextDocument ( document : vs . TextDocument ) { if ( ! util . isAnalyzable ( document ) ) return ; const files : { [ key ] : as . RemoveContentOverlay } = { } ; files [ fsPath ( document . uri ) ] = { type : "s" , } ; this . analyzer . analysisUpdateContent ( { files } ) ; } private convertChange ( document : vs . TextDocument , change : vs . TextDocumentContentChangeEvent ) : as . SourceEdit { return { id : "s" , length : change . rangeLength , offset : change . rangeOffset , replacement : change . text , } ; } public dispose ( ) { this . disposables . forEach ( ( d ) => d . dispose ( ) ) ; } }	O O O $any$ O O O O O O $any$ O O O O O $string$ O O O O O O $Config$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O O O O O O O O $Set<string>$ O O $SetConstructor$ O O O O O O O O O O $Analyzer$ O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $boolean$ O $any$ O O O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O $complex$ O $string$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $Analyzer$ O $Promise<UnknownResponse>$ O O $complex$ O O O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $boolean$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O $string$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Config$ O $boolean$ O O O O $Set<string>$ O $boolean$ O $string$ O O O $any$ O $boolean$ O $string$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O O $any$ O O O $Config$ O $any$ O O O O O O O O O $Set<string>$ O $Set<string>$ O $string$ O O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O $complex$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $SourceEdit$ O $any$ O $any$ O $any$ O O O O O O O O O O O $Analyzer$ O $Promise<UnknownResponse>$ O O $complex$ O O O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $boolean$ O $any$ O O O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O $complex$ O $string$ O $any$ O $any$ O O O O O O O O O O O O $Analyzer$ O $Promise<UnknownResponse>$ O O $complex$ O O O O O $SourceEdit$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O
import { Disposable , TextDocument , Uri , window , workspace } from "s" ; import { FlutterOutline , FoldingRegion , Occurrences , Outline } from "s" ; import { IAmDisposable , Logger } from "s" ; import { fsPath } from "s" ; import { WorkspaceContext } from "s" ; import { locateBestProjectRoot } from "s" ; import * as util from "s" ; import { Analyzer } from "s" ; const outlines : { [ key ] : Outline } = { } ; const flutterOutlines : { [ key ] : FlutterOutline } = { } ; const occurrences : { [ key ] : Occurrences [ ] } = { } ; const folding : { [ key ] : FoldingRegion [ ] } = { } ; const pubRunTestSupport : { [ key ] : boolean } = { } ; let lastPriorityFiles : string [ ] = [ ] ; let lastSubscribedFiles : string [ ] = [ ] ; class OpenFileTracker implements IAmDisposable { private disposables : Disposable [ ] = [ ] ; constructor ( private readonly logger , private readonly analyzer , private readonly wsContext ) { lastPriorityFiles = [ ] ; lastSubscribedFiles = [ ] ; this . disposables . push ( workspace . onDidOpenTextDocument ( ( td ) => { this . updateSubscriptions ( ) ; } ) ) ; this . disposables . push ( workspace . onDidCloseTextDocument ( ( td ) => { const path = fsPath ( td . uri ) ; delete outlines [ path ] ; delete flutterOutlines [ path ] ; delete occurrences [ path ] ; delete folding [ path ] ; delete pubRunTestSupport [ path ] ; this . updateSubscriptions ( ) ; } ) ) ; this . disposables . push ( window . onDidChangeVisibleTextEditors ( ( e ) => this . updatePriorityFiles ( ) ) ) ; this . disposables . push ( this . analyzer . registerForAnalysisOutline ( ( o ) => outlines [ o . file ] = o . outline ) ) ; this . disposables . push ( this . analyzer . registerForFlutterOutline ( ( o ) => flutterOutlines [ o . file ] = o . outline ) ) ; this . disposables . push ( this . analyzer . registerForAnalysisOccurrences ( ( o ) => occurrences [ o . file ] = o . occurrences ) ) ; this . disposables . push ( this . analyzer . registerForAnalysisFolding ( ( f ) => folding [ f . file ] = f . regions ) ) ; this . updatePriorityFiles ( ) ; this . updateSubscriptions ( ) ; } public async updatePriorityFiles ( ) { const visibleFiles = this . validPathsFor ( window . visibleTextEditors . map ( ( editor ) => editor . document ) ) ; if ( ! this . pathsHaveChanged ( lastPriorityFiles , visibleFiles ) ) return ; lastPriorityFiles = visibleFiles ; try { await this . analyzer . analysisSetPriorityFiles ( { files : visibleFiles } ) ; } catch ( e ) { this . logger . error ( e ) ; } } public async updateSubscriptions ( ) { const openFiles = this . validPathsFor ( workspace . textDocuments ) ; if ( ! this . pathsHaveChanged ( lastSubscribedFiles , openFiles ) ) return ; lastSubscribedFiles = openFiles ; try { await this . analyzer . analysisSetSubscriptions ( { subscriptions : { CLOSING_LABELS : this . analyzer . capabilities . supportsClosingLabels ? openFiles : undefined , FOLDING : openFiles , OCCURRENCES : openFiles , OUTLINE : openFiles , } , } ) ; } catch ( e ) { this . logger . error ( e ) ; } if ( this . wsContext . hasAnyFlutterProjects && this . analyzer . capabilities . supportsFlutterOutline ) { try { await this . analyzer . flutterSetSubscriptions ( { subscriptions : { OUTLINE : openFiles , } , } ) ; } catch ( e ) { this . logger . error ( e ) ; } } } private pathsHaveChanged ( last : string [ ] , current : string [ ] ) { return last . length !== current . length || last . some ( ( f , i ) => f !== current [ i ] ) ; } private validPathsFor ( paths : TextDocument [ ] ) : string [ ] { const isAnalyzeable = this . analyzer . capabilities . supportsPriorityFilesOutsideAnalysisRoots ? util . isAnalyzable : util . isAnalyzableAndInWorkspace ; return paths . filter ( ( doc ) => ! doc . isClosed && isAnalyzeable ( doc ) ) . map ( ( doc ) => fsPath ( doc . uri ) ) . sort ( ( 0 , 0 ) => 0 . localeCompare ( 0 ) ) ; } public dispose ( ) { this . disposables . forEach ( ( d ) => d . dispose ( ) ) ; } } export const openFileTracker = { create ( logger , analyzer , wsContext ) { return new OpenFileTracker ( logger , analyzer , wsContext ) ; } , getOutlineFor ( file ) : Outline | undefined { return outlines [ fsPath ( file ) ] ; } , getFlutterOutlineFor ( file ) : FlutterOutline | undefined { return flutterOutlines [ fsPath ( file ) ] ; } , getOccurrencesFor ( file ) : Occurrences [ ] | undefined { return occurrences [ fsPath ( file ) ] ; } , supportsPubRunTest ( file ) : boolean | undefined { const path = fsPath ( file ) ; if ( ! util . isPubRunnableTestFile ( path ) ) return false ; if ( pubRunTestSupport [ path ] === undefined ) { const projectRoot = locateBestProjectRoot ( path ) ; pubRunTestSupport [ path ] = ! ! ( projectRoot && util . checkProjectSupportsPubRunTest ( projectRoot ) ) ; } return pubRunTestSupport [ fsPath ( file ) ] ; } , getFoldingRegionsFor ( file ) : FoldingRegion [ ] | undefined { return folding [ fsPath ( file ) ] ; } , getLastPriorityFiles ( ) : string [ ] { return lastPriorityFiles . slice ( ) ; } , getLastSubscribedFiles ( ) : string [ ] { return lastSubscribedFiles . slice ( ) ; } , } ;	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $string$ O O O O O O O $any$ O O O O O $any$ O O O O O $complex$ O O O $string$ O O $any$ O O O O O O $complex$ O O O $string$ O O $any$ O O O O O O $complex$ O O O $string$ O O $any$ O O O O O O O O $complex$ O O O $string$ O O $any$ O O O O O O O O $complex$ O O O $string$ O O O O O O O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O O $any$ O $any$ O O $any[]$ O $any$ O O O O O O O O O O $Logger$ O O O $Analyzer$ O O O $WorkspaceContext$ O O $string[]$ O O O O $string[]$ O O O O O O $any[]$ O $number$ O $any$ O $any$ O O $any$ O O O O O $Promise<void>$ O O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O O $any$ O O O O $string$ O $string$ O $any$ O $any$ O O O $complex$ O $string$ O O O $complex$ O $string$ O O O $complex$ O $string$ O O O $complex$ O $string$ O O O $complex$ O $string$ O O O O $Promise<void>$ O O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O O $any$ O O O O $Promise<void>$ O O O O O O O $any[]$ O $number$ O O O $Analyzer$ O $any$ O O $AnalysisOutlineNotification$ O O $complex$ O $AnalysisOutlineNotification$ O $string$ O O $AnalysisOutlineNotification$ O $Outline$ O O O O O $any[]$ O $number$ O O O $Analyzer$ O $any$ O O $FlutterOutlineNotification$ O O $complex$ O $FlutterOutlineNotification$ O $string$ O O $FlutterOutlineNotification$ O $FlutterOutline$ O O O O O $any[]$ O $number$ O O O $Analyzer$ O $any$ O O $AnalysisOccurrencesNotification$ O O $complex$ O $AnalysisOccurrencesNotification$ O $string$ O O $AnalysisOccurrencesNotification$ O $Occurrences[]$ O O O O O $any[]$ O $number$ O O O $Analyzer$ O $any$ O O $AnalysisFoldingNotification$ O O $complex$ O $AnalysisFoldingNotification$ O $string$ O O $AnalysisFoldingNotification$ O $FoldingRegion[]$ O O O O O $Promise<void>$ O O O O O $Promise<void>$ O O O O O O $Promise<void>$ O O O O $string[]$ O O O $string[]$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O $boolean$ O $string[]$ O $string[]$ O O O O $string[]$ O $string[]$ O O O O O O $Analyzer$ O $Promise<UnknownResponse>$ O O $string[]$ O $string[]$ O O O O O O $any$ O O O O $Logger$ O $void$ O $any$ O O O O O O $Promise<void>$ O O O O $string[]$ O O O $string[]$ O $any$ O $any$ O O O O O O O $boolean$ O $string[]$ O $string[]$ O O O O $string[]$ O $string[]$ O O O O O O $Analyzer$ O $Promise<UnknownResponse>$ O O $complex$ O O $string[]$ O O O $Analyzer$ O $AnalyzerCapabilities$ O $boolean$ O $string[]$ O $undefined$ O $string[]$ O $string[]$ O $string[]$ O $string[]$ O $string[]$ O $string[]$ O O O O O O O O O $any$ O O O O $Logger$ O $void$ O $any$ O O O O O O O $WorkspaceContext$ O $boolean$ O O O $Analyzer$ O $AnalyzerCapabilities$ O $boolean$ O O O O O O O $Analyzer$ O $Promise<UnknownResponse>$ O O $complex$ O O $string[]$ O $string[]$ O O O O O O O O O $any$ O O O O $Logger$ O $void$ O $any$ O O O O O O $boolean$ O $string[]$ O O O O O $string[]$ O O O O O O O $string[]$ O $number$ O $string[]$ O $number$ O $string[]$ O $boolean$ O O $string$ O $number$ O O $string$ O $string[]$ O $number$ O O O O O $string[]$ O $any[]$ O $any$ O O O O O O O O O $boolean$ O O O $Analyzer$ O $AnalyzerCapabilities$ O $boolean$ O $any$ O $boolean$ O $any$ O $boolean$ O O $any[]$ O $complex$ O O $any$ O O O $any$ O $any$ O $boolean$ O $any$ O O O $U[]$ O O $any$ O O $string$ O $any$ O $any$ O O O $string[]$ O O $string$ O $string$ O O $string$ O $complex$ O $string$ O O O O O $any$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O O O O O O $IAmDisposable$ O $Logger$ O $Analyzer$ O $WorkspaceContext$ O O O O $any$ O $Logger$ O $Analyzer$ O $WorkspaceContext$ O O O O $Outline$ O $Uri$ O O $any$ O O O O $complex$ O $string$ O $any$ O O O O O $FlutterOutline$ O $Uri$ O O $any$ O O O O $complex$ O $string$ O $any$ O O O O O $Occurrences[]$ O $Uri$ O O $any$ O O O O O O $complex$ O $string$ O $any$ O O O O O $boolean$ O $Uri$ O O O O O O O $string$ O $string$ O $any$ O O O O O $any$ O $boolean$ O $string$ O O O O O O O $complex$ O $string$ O O $undefined$ O O O $string$ O $string$ O $string$ O O $complex$ O $string$ O O O O O $string$ O $any$ O $boolean$ O $string$ O O O O O $complex$ O $string$ O $any$ O O O O O $FoldingRegion[]$ O $Uri$ O O $any$ O O O O O O $complex$ O $string$ O $any$ O O O O O $string[]$ O O O O O O O O $string[]$ O $string[]$ O O O O O $string[]$ O O O O O O O O $string[]$ O $string[]$ O O O O O O O
import * as vs from "s" ; export class DartExtensionApi { public readonly version = 0 ; public flutterCreateSampleProject = ( ) => vs . commands . executeCommand ( "s" ) ; }	O O O $any$ O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O
import * as as from "s" ; import { Logger } from "s" ; export abstract class OutlineVisitor { constructor ( private logger ) { } public visit ( outline : as . Outline ) { this . visitNode ( outline ) ; } private visitChildren ( outline : as . Outline ) { if ( outline . children ) { for ( const child of outline . children ) { this . visit ( child ) ; } } } private visitNode ( outline : as . Outline ) { switch ( outline && outline . element && outline . element . kind ) { case "s" : this . visitClass ( outline ) ; break ; case "s" : this . visitClassTypeAlias ( outline ) ; break ; case "s" : this . visitCompilationUnit ( outline ) ; break ; case "s" : this . visitConstructor ( outline ) ; break ; case "s" : this . visitContructorInvocation ( outline ) ; break ; case "s" : this . visitEnum ( outline ) ; break ; case "s" : this . visitEnumConstant ( outline ) ; break ; case "s" : this . visitField ( outline ) ; break ; case "s" : this . visitXXX ( outline ) ; break ; case "s" : this . visitFile ( outline ) ; break ; case "s" : this . visitFunctionInvocation ( outline ) ; break ; case "s" : this . visitFunctionTypeAlias ( outline ) ; break ; case "s" : this . visitGetter ( outline ) ; break ; case "s" : this . visitLabel ( outline ) ; break ; case "s" : this . visitLibrary ( outline ) ; break ; case "s" : this . visitLocalVariable ( outline ) ; break ; case "s" : this . visitMethod ( outline ) ; break ; case "s" : this . visitParameter ( outline ) ; break ; case "s" : this . visitPrefix ( outline ) ; break ; case "s" : this . visitSetter ( outline ) ; break ; case "s" : this . visitTopLevelVariable ( outline ) ; break ; case "s" : this . visitTypeParameter ( outline ) ; break ; case "s" : this . visitUnitTestGroup ( outline ) ; break ; case "s" : this . visitUnitTestTest ( outline ) ; break ; case "s" : this . visitUnknown ( outline ) ; break ; default : this . logger . error ( `template` ) ; } } protected visitClass ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitClassTypeAlias ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitCompilationUnit ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitConstructor ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitContructorInvocation ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitEnum ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitEnumConstant ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitField ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitXXX ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitFile ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitFunctionInvocation ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitFunctionTypeAlias ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitGetter ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitLabel ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitLibrary ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitLocalVariable ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitMethod ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitParameter ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitPrefix ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitSetter ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitTopLevelVariable ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitTypeParameter ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitUnitTestGroup ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitUnitTestTest ( outline : as . Outline ) { this . visitChildren ( outline ) ; } protected visitUnknown ( outline : as . Outline ) { this . visitChildren ( outline ) ; } } export class TestOutlineVisitor extends OutlineVisitor { public readonly tests : TestOutlineInfo [ ] = [ ] ; private readonly names : string [ ] = [ ] ; protected visitUnitTestTest ( outline : as . Outline ) { this . addTest ( outline , super . visitUnitTestTest ) ; } protected visitUnitTestGroup ( outline : as . Outline ) { this . addTest ( outline , super . visitUnitTestGroup ) ; } private addTest ( outline : as . Outline , base : ( outline : as . Outline ) => void ) { const name = this . extractTestName ( outline . element . name ) ; if ( ! name || ! outline . element . location ) return ; this . names . push ( name ) ; const fullName = this . names . join ( "s" ) ; const isGroup = outline . element . kind === "s" ; this . tests . push ( { file : outline . element . location . file , fullName , isGroup , length : outline . codeLength || outline . element . location . length , offset : outline . codeOffset || outline . element . location . offset , } ) ; try { base . bind ( this ) ( outline ) ; } finally { this . names . pop ( ) ; } } private extractTestName ( elementName ) : string | undefined { if ( ! elementName ) return ; const openParen = elementName . indexOf ( "s" ) ; const closeParen = elementName . lastIndexOf ( "s" ) ; if ( openParen === - 0 || closeParen === - 0 || openParen > closeParen ) return ; elementName = elementName . substring ( openParen + 0 , closeParen ) ; const quoteCharacter = elementName . substr ( 0 , 0 ) ; if ( elementName . slice ( - 0 ) !== quoteCharacter ) return ; elementName = elementName . slice ( 0 , - 0 ) ; if ( elementName . indexOf ( quoteCharacter ) !== - 0 || elementName . indexOf ( "s" ) !== - 0 ) return ; return elementName ; } } export interface TestOutlineInfo { fullName : string ; file : string ; offset : number ; length : number ; isGroup : boolean ; }	O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O $Logger$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $Outline$ O $Outline[]$ O O O O O $Outline$ O $Outline$ O $Outline[]$ O O O O $void$ O $Outline$ O O O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $Outline$ O $Outline$ O $Element$ O $Outline$ O $Element$ O $ElementKind$ O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O O $void$ O $Outline$ O O O O O O O O $Logger$ O $void$ O O O O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O O O O $any$ O $any$ O O O $TestOutlineInfo[]$ O $any$ O O O O O O O O $string[]$ O O O O O O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O $void$ O O O O $void$ O $Outline$ O $any$ O $any$ O O O O $void$ O $Outline$ O O O $void$ O O O O $void$ O $Outline$ O $any$ O $any$ O $void$ O O $Outline$ O $any$ O $any$ O O O O O O $string$ O O O $string$ O $Outline$ O $Element$ O $string$ O O O O O $string$ O O $Outline$ O $Element$ O $Location$ O O O O O $string[]$ O $number$ O $string$ O O O $string$ O O O $string[]$ O $string$ O O O O O $boolean$ O $Outline$ O $Element$ O $ElementKind$ O O O O O $TestOutlineInfo[]$ O $number$ O O $string$ O $Outline$ O $Element$ O $Location$ O $string$ O $string$ O $boolean$ O $number$ O $Outline$ O $number$ O $Outline$ O $Element$ O $Location$ O $number$ O $number$ O $Outline$ O $number$ O $Outline$ O $Element$ O $Location$ O $number$ O O O O O O $void$ O $any$ O O O O $Outline$ O O O O O O O $string[]$ O $string$ O O O O O O $string$ O $string$ O O O O O O O O O $string$ O O O O $number$ O $string$ O $number$ O O O O O $number$ O $string$ O $number$ O O O O O O $number$ O O O O $number$ O O O O $number$ O $number$ O O O $string$ O $string$ O $string$ O $number$ O O O $number$ O O O $string$ O $string$ O $string$ O O O O O O O O $string$ O $string$ O O O O O $string$ O O O $string$ O $string$ O $string$ O O O O O O O O O $string$ O $number$ O $string$ O O O O O $string$ O $number$ O O O O O O O O O O $string$ O O O O O $any$ O $string$ O O O $string$ O O O $number$ O O O $number$ O O O $boolean$ O O O O
import { escapeRegExp } from "s" ; export function getLaunchConfig ( noDebug , path , testName : string | undefined , isGroup , template ? : any | undefined ) { return Object . assign ( { } , template , { args : ( template ? ( template . args || [ ] ) : [ ] ) . concat ( testName ? [ "s" , makeRegexForTest ( testName , isGroup ) ] : [ ] ) , name : "s" , noDebug , program : path , request : "s" , type : "s" , } , ) ; } export function makeRegexForTest ( name , isGroup ) { const prefix = "s" ; const suffix = isGroup ? "s" : "s" ; return prefix + escapeRegExp ( name ) + suffix ; }	O O $string$ O O O O O O $any$ O $boolean$ O $string$ O $string$ O O O O O $boolean$ O $any$ O O O O O O O O $ObjectConstructor$ O O O O O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O $any$ O $string$ O O O O $string$ O $string$ O $boolean$ O O O O O O O $string$ O O O $boolean$ O $string$ O $string$ O $string$ O O O $string$ O O O O O O O O O O $string$ O $string$ O $boolean$ O O O O O O O O O O $boolean$ O O O O O O O O $string$ O $string$ O O O O O
import { CancellationToken , CodeLens , CodeLensProvider , commands , debug , Event , EventEmitter , TextDocument , Uri , workspace } from "s" ; import { IAmDisposable , Logger } from "s" ; import { flatMap } from "s" ; import { TestOutlineInfo , TestOutlineVisitor } from "s" ; import { getLaunchConfig } from "s" ; import { toRange } from "s" ; import { Analyzer } from "s" ; import { openFileTracker } from "s" ; export class TestCodeLensProvider implements CodeLensProvider , IAmDisposable { private disposables : IAmDisposable [ ] = [ ] ; private onDidChangeCodeLensesEmitter : EventEmitter < void > = new EventEmitter < void > ( ) ; public readonly onDidChangeCodeLenses : Event < void > = this . onDidChangeCodeLensesEmitter . event ; constructor ( private readonly logger , private readonly analyzer ) { this . disposables . push ( this . analyzer . registerForAnalysisOutline ( ( n ) => { this . onDidChangeCodeLensesEmitter . fire ( ) ; } ) ) ; this . disposables . push ( commands . registerCommand ( "s" , ( test , launchTemplate : any | undefined ) => { debug . startDebugging ( workspace . getWorkspaceFolder ( Uri . file ( test . file ) ) , getLaunchConfig ( false , test . file , test . fullName , test . isGroup , launchTemplate ) , ) ; } ) ) ; this . disposables . push ( commands . registerCommand ( "s" , ( test , launchTemplate : any | undefined ) => { debug . startDebugging ( workspace . getWorkspaceFolder ( Uri . file ( test . file ) ) , getLaunchConfig ( true , test . file , test . fullName , test . isGroup , launchTemplate ) , ) ; } ) ) ; } public provideCodeLenses ( document , token ) : CodeLens [ ] | undefined { const outline = openFileTracker . getOutlineFor ( document . uri ) ; if ( ! outline || ! outline . children || ! outline . children . length ) return ; if ( ! openFileTracker . supportsPubRunTest ( document . uri ) ) return ; const runConfigs = workspace . getConfiguration ( "s" , document . uri ) . get < any [ ] > ( "s" ) || [ ] ; const runTestTemplates = runConfigs . filter ( ( c ) => c && c . type === "s" && c . template && ( c . template === "s" || c . template === "s" ) ) ; const visitor = new TestOutlineVisitor ( this . logger ) ; visitor . visit ( outline ) ; return flatMap ( visitor . tests . filter ( ( test ) => test . offset && test . length ) . map ( ( test ) => { return [ new CodeLens ( toRange ( document , test . offset , test . length ) , { arguments : [ test ] , command : "s" , title : "s" , } , ) , new CodeLens ( toRange ( document , test . offset , test . length ) , { arguments : [ test ] , command : "s" , title : "s" , } , ) , ] . concat ( runTestTemplates . map ( ( t ) => new CodeLens ( toRange ( document , test . offset , test . length ) , { arguments : [ test , t ] , command : t . template === "s" ? "s" : "s" , title : t . name , } , ) ) ) ; } ) , ( x ) => x , ) ; } public dispose ( ) { this . disposables . forEach ( ( d ) => d . dispose ( ) ) ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O $IAmDisposable[]$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $Logger$ O O O $Analyzer$ O O O O $IAmDisposable[]$ O $number$ O O O $Analyzer$ O $any$ O O $AnalysisOutlineNotification$ O O O O O $any$ O $any$ O O O O O O O O O $IAmDisposable[]$ O $number$ O $any$ O $any$ O O O O $TestOutlineInfo$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $TestOutlineInfo$ O $string$ O O O $any$ O O O $TestOutlineInfo$ O $string$ O $TestOutlineInfo$ O $string$ O $TestOutlineInfo$ O $boolean$ O $any$ O O O O O O O O O O $IAmDisposable[]$ O $number$ O $any$ O $any$ O O O O $TestOutlineInfo$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $TestOutlineInfo$ O $string$ O O O $any$ O O O $TestOutlineInfo$ O $string$ O $TestOutlineInfo$ O $string$ O $TestOutlineInfo$ O $boolean$ O $any$ O O O O O O O O O O $any[]$ O $TextDocument$ O $CancellationToken$ O O $any$ O O O O O O $Outline$ O O O $Outline$ O $any$ O $any$ O O O O O $Outline$ O O $Outline$ O $Outline[]$ O O $Outline$ O $Outline[]$ O $number$ O O O O O O O O $boolean$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $TestOutlineVisitor$ O O $any$ O O O $Logger$ O O $TestOutlineVisitor$ O $void$ O $Outline$ O O O O O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O $complex$ O O $TestOutlineInfo$ O O $TestOutlineInfo$ O $number$ O $TestOutlineInfo$ O $number$ O O $U[]$ O O $TestOutlineInfo$ O O O O O O $any$ O $any$ O $any$ O $TestOutlineInfo$ O $number$ O $TestOutlineInfo$ O $number$ O O O $TestOutlineInfo[]$ O O $TestOutlineInfo$ O O $string$ O O O $string$ O O O O O O O O $any$ O $any$ O $any$ O $TestOutlineInfo$ O $number$ O $TestOutlineInfo$ O $number$ O O O $TestOutlineInfo[]$ O O $TestOutlineInfo$ O O $string$ O O O $string$ O O O O O O O O O $complex$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $TestOutlineInfo$ O $number$ O $TestOutlineInfo$ O $number$ O O O $any[]$ O O $TestOutlineInfo$ O $any$ O O $string$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any[]$ O O $any[]$ O O O O O $any$ O O O O O $IAmDisposable[]$ O $void$ O O $IAmDisposable$ O O $IAmDisposable$ O $complex$ O O O O O O
import * as vs from "s" ; import { Analyzer } from "s" ; import { envUtils } from "s" ; export class AnalyzerCommands { constructor ( context : vs . ExtensionContext , analyzer ) { context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( ) => { const res = await analyzer . diagnosticGetServerPort ( ) ; await envUtils . openInBrowser ( `template` ) ; } ) ) ; } }	O O O $any$ O O O O O $any$ O O O O O O $EnvUtils$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O $Analyzer$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $DiagnosticGetServerPortResponse$ O O $Analyzer$ O $Promise<DiagnosticGetServerPortResponse>$ O O O O $EnvUtils$ O $Promise<boolean>$ O O O O O O O O O O
import * as child_process from "s" ; import * as vs from "s" ; const channels : { [ key ] : vs . OutputChannel } = { } ; export function createChannel ( name ) : vs . OutputChannel { if ( ! channels [ name ] ) channels [ name ] = vs . window . createOutputChannel ( name ) ; return channels [ name ] ; } export function getChannel ( name ) : vs . OutputChannel { if ( ! channels [ name ] ) return createChannel ( name ) ; return channels [ name ] ; } export function runProcessInChannel ( process : child_process . ChildProcess , channel : vs . OutputChannel ) { process . stdout . on ( "s" , ( data ) => channel . append ( data . toString ( ) ) ) ; process . stderr . on ( "s" , ( data ) => channel . append ( data . toString ( ) ) ) ; process . on ( "s" , ( code ) => channel . appendLine ( `template` ) ) ; }	O O O $any$ O O O O O O $any$ O O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O O O $any$ O $string$ O O $any$ O $any$ O O O O $complex$ O $string$ O O $complex$ O $string$ O O $any$ O $any$ O $any$ O $string$ O O O $complex$ O $string$ O O O O O $any$ O $string$ O O $any$ O $any$ O O O O $complex$ O $string$ O O O $any$ O $string$ O O O $complex$ O $string$ O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O
import { ExtensionContext } from "s" ; export class Context { private context : ExtensionContext ; private constructor ( context ) { this . context = context ; } public static for ( context ) { return new Context ( context ) ; } get devToolsNotificationsShown ( ) : number | undefined { return ( this . context . globalState . get ( "s" ) as number ) || 0 ; } set devToolsNotificationsShown ( value : number | undefined ) { this . context . globalState . update ( "s" , value ) ; } get devToolsNotificationLastShown ( ) : number | undefined { return this . context . globalState . get ( "s" ) as number ; } set devToolsNotificationLastShown ( value : number | undefined ) { this . context . globalState . update ( "s" , value ) ; } get devToolsNotificationDoNotShow ( ) : boolean | undefined { return ! ! this . context . globalState . get ( "s" ) ; } set devToolsNotificationDoNotShow ( value : boolean | undefined ) { this . context . globalState . update ( "s" , value ) ; } get 0 ( ) : number | undefined { return this . context . globalState . get ( "s" ) as number ; } set 0 ( value : number | undefined ) { this . context . globalState . update ( "s" , value ) ; } get 0 ( ) : boolean | undefined { return ! ! this . context . globalState . get ( "s" ) ; } set 0 ( value : boolean | undefined ) { this . context . globalState . update ( "s" , value ) ; } get hasWarnedAboutFormatterSyntaxLimitation ( ) : boolean { return ! ! this . context . globalState . get ( "s" ) ; } set hasWarnedAboutFormatterSyntaxLimitation ( value ) { this . context . globalState . update ( "s" , value ) ; } get lastSeenVersion ( ) : string | undefined { return this . context . globalState . get ( "s" ) ; } set lastSeenVersion ( value : string | undefined ) { this . context . globalState . update ( "s" , value ) ; } public getPackageLastCheckedForUpdates ( packageID ) : number | undefined { return this . context . globalState . get ( `template` ) as number ; } public setPackageLastCheckedForUpdates ( packageID , value : number | undefined ) { this . context . globalState . update ( `template` , value ) ; } public update ( key , value ) { return this . context . globalState . update ( key , value ) ; } public get ( key ) { return this . context . globalState . get ( key ) ; } get subscriptions ( ) : Array < { dispose ( ) : any } > { return this . context . subscriptions ; } }	O O $any$ O O O O O O $any$ O O $any$ O $any$ O O O O $ExtensionContext$ O O O O $any$ O $any$ O O O O $Context$ O $ExtensionContext$ O O O O $any$ O $any$ O O O O $number$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $number$ O $number$ O O O O O O O O $any$ O $any$ O $any$ O O O $number$ O O O O $number$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $number$ O $number$ O O O O O O O O $any$ O $any$ O $any$ O O O $number$ O O O O $boolean$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O $boolean$ O O O O O O O O $any$ O $any$ O $any$ O O O $boolean$ O O O O $number$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $number$ O $number$ O O O O O O O O $any$ O $any$ O $any$ O O O $number$ O O O O $boolean$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O $boolean$ O O O O O O O O $any$ O $any$ O $any$ O O O $boolean$ O O O O $boolean$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $boolean$ O $boolean$ O O O O $any$ O $any$ O $any$ O O O $boolean$ O O O O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O $string$ O O O O O O O O $any$ O $any$ O $any$ O O O $string$ O O O O $number$ O $string$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $void$ O $string$ O $number$ O O O O O O O O $any$ O $any$ O $any$ O O O $number$ O O O O $any$ O $string$ O $any$ O O O O O $any$ O $any$ O $any$ O $string$ O $any$ O O O O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $string$ O O O O $complex$ O O O $ArrayConstructor$ O O $any$ O O O O O O O O O O $any$ O $any$ O O O
import * as fs from "s" ; import * as os from "s" ; import * as path from "s" ; import * as vs from "s" ; import { doNotAskAgainAction , flutterSurveyPromptWithAnalytics , flutterSurveyPromptWithoutAnalytics , isWin , longRepeatPromptThreshold , noRepeatPromptThreshold , noThanksAction , openDevToolsAction , takeSurveyAction , wantToTryDevToolsPrompt } from "s" ; import { Logger } from "s" ; import { Context } from "s" ; export const surveyStart = Date . UTC ( 0 , 0 , 0 , 0 , 0 ) ; export const surveyEnd = Date . UTC ( 0 , 0 , 0 , 0 , 0 ) ; export function showFlutterSurveyNotificationIfAppropriate ( context , openInBrowser : ( url ) => Promise < boolean > , now , logger ) { if ( now <= surveyStart || now >= surveyEnd ) return false ; const lastShown = context . 0 ; const doNotShow = context . 0 ; if ( doNotShow ) return false ; if ( lastShown && now - lastShown < longRepeatPromptThreshold ) return false ; let clientID : string | undefined ; try { const flutterSettingsFolder = isWin ? process . env . APPDATA || os . homedir ( ) : os . homedir ( ) ; const flutterSettingsPath = path . join ( flutterSettingsFolder , "s" ) ; if ( fs . existsSync ( flutterSettingsPath ) ) { const json = fs . readFileSync ( flutterSettingsPath ) . toString ( ) ; const settings = JSON . parse ( json ) ; if ( settings . enabled !== false ) { clientID = settings . clientId ; } } } catch { logger . warn ( "s" ) ; } const prompt = clientID ? flutterSurveyPromptWithAnalytics : flutterSurveyPromptWithoutAnalytics ; const surveyUrl = "s" + ( clientID ? `template` : "s" ) ; context . 0 = Date . now ( ) ; vs . window . showInformationMessage ( prompt , takeSurveyAction , doNotAskAgainAction ) . then ( async ( choice ) => { if ( choice === doNotAskAgainAction ) { context . 0 = true ; } else if ( choice === takeSurveyAction ) { context . 0 = true ; await openInBrowser ( surveyUrl ) ; } } ) ; return true ; } export async function showDevToolsNotificationIfAppropriate ( context ) < boolean > { const lastShown = context . devToolsNotificationLastShown ; const timesShown = context . devToolsNotificationsShown || 0 ; const doNotShow = context . devToolsNotificationDoNotShow ; if ( doNotShow || timesShown >= 0 ) return false ; if ( lastShown && Date . now ( ) - lastShown < noRepeatPromptThreshold ) return false ; context . devToolsNotificationsShown = timesShown + 0 ; context . devToolsNotificationLastShown = Date . now ( ) ; const choice = await vs . window . showInformationMessage ( wantToTryDevToolsPrompt , openDevToolsAction , noThanksAction , doNotAskAgainAction ) ; if ( choice === doNotAskAgainAction ) { context . devToolsNotificationDoNotShow = true ; return false ; } else if ( choice === openDevToolsAction ) { vs . commands . executeCommand ( "s" ) ; return true ; } else { return false ; } }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O $boolean$ O $number$ O $number$ O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $number$ O $DateConstructor$ O $number$ O O O O O O O O O O O O O O $number$ O $DateConstructor$ O $number$ O O O O O O O O O O O O O O $boolean$ O $Context$ O $Promise<boolean>$ O O $string$ O O $PromiseConstructor$ O O O O $number$ O $Logger$ O O O O $number$ O $number$ O $number$ O $number$ O O O O O $number$ O $Context$ O $number$ O O $boolean$ O $Context$ O $boolean$ O O O $boolean$ O O O O O O $number$ O $number$ O $number$ O $number$ O O O O O $string$ O O O O O O O O $any$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $JSON$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $string$ O $any$ O $any$ O O O O O O $Logger$ O $void$ O O O O O O O O $string$ O O O O O O $string$ O O O O $string$ O O O O O O $Context$ O $number$ O $DateConstructor$ O $number$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O O O O O $any$ O O O O $Context$ O $boolean$ O O O O O O O $any$ O O O O $Context$ O $boolean$ O O O O $Promise<boolean>$ O $string$ O O O O O O O O O O O O O $Promise$ O $Context$ O O O O O O $number$ O $Context$ O $number$ O O $number$ O $Context$ O $number$ O O O O $boolean$ O $Context$ O $boolean$ O O O $boolean$ O $number$ O O O O O O O O $number$ O $DateConstructor$ O $number$ O O O $number$ O $number$ O O O O $Context$ O $number$ O $number$ O O O $Context$ O $number$ O $DateConstructor$ O $number$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O $Context$ O $boolean$ O O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O
export const internalApiSymbol = "s" ;	O O O O O O
import * as vs from "s" ; import { flatMap } from "s" ; import { findProjectFolders } from "s" ; import { fsPath , getDartWorkspaceFolders } from "s" ; import * as f from "s" ; import { IFlutterDaemon , Logger } from "s" ; import { unique } from "s" ; import { isRunningLocally } from "s" ; export class FlutterDeviceManager implements vs . Disposable { private subscriptions : vs . Disposable [ ] = [ ] ; private statusBarItem : vs . StatusBarItem ; private devices : f . Device [ ] = [ ] ; public currentDevice ? : f . Device ; private readonly knownEmulatorNames : { [ key ] : string } = { } ; constructor ( private readonly logger , private daemon , private readonly autoSelectNewlyConnectedDevices ) { this . statusBarItem = vs . window . createStatusBarItem ( vs . StatusBarAlignment . Right , 0 ) ; this . statusBarItem . tooltip = "s" ; this . statusBarItem . command = "s" ; this . statusBarItem . show ( ) ; this . updateStatusBar ( ) ; this . getEmulators ( ) . then ( ( ) => this . updateStatusBar ( ) ) ; this . subscriptions . push ( this . statusBarItem ) ; daemon . registerForDeviceAdded ( this . deviceAdded . bind ( this ) ) ; daemon . registerForDeviceRemoved ( this . deviceRemoved . bind ( this ) ) ; } public dispose ( ) { this . subscriptions . forEach ( ( s ) => s . dispose ( ) ) ; } public isSupported ( types : f . PlatformType [ ] | undefined , device : { platformType : f . PlatformType | null | undefined } | undefined ) { return device && ( ! types || ! types . length || ! device . platformType || types . indexOf ( device . platformType ) !== - 0 ) ; } public async deviceAdded ( dev : f . Device ) < void > { dev = { ... dev , type : "s" } ; this . devices . push ( dev ) ; const canAutoSelectDevice = dev . ephemeral !== false ; const maySelectThisDevice = ( ) => ! this . currentDevice || ( this . autoSelectNewlyConnectedDevices && canAutoSelectDevice ) ; if ( maySelectThisDevice ( ) ) { const supportedPlatforms = await this . getSupportedPlatformsForWorkspace ( ) ; if ( maySelectThisDevice ( ) && this . isSupported ( supportedPlatforms , dev ) ) { this . currentDevice = dev ; this . updateStatusBar ( ) ; } } } public async deviceRemoved ( dev : f . Device ) { this . devices = this . devices . filter ( ( d ) => d . id !== dev . id ) ; if ( this . currentDevice && this . currentDevice . id === dev . id ) { this . currentDevice = undefined ; if ( this . devices . length ) { const supportedPlatforms = await this . getSupportedPlatformsForWorkspace ( ) ; const supportedDevices = this . devices . filter ( ( d ) => this . isSupported ( supportedPlatforms , d ) ) ; if ( supportedDevices && supportedDevices . length ) this . currentDevice = supportedDevices [ 0 ] ; } this . updateStatusBar ( ) ; } } public async showDevicePicker ( supportedTypes ? : f . PlatformType [ ] ) < f . Device | undefined > { if ( ! supportedTypes && this . daemon . capabilities . providesPlatformTypes ) { supportedTypes = await this . getSupportedPlatformsForWorkspace ( ) ; } const quickPick = vs . window . createQuickPick < PickableDevice > ( ) ; quickPick . placeholder = "s" ; quickPick . busy = true ; let quickPickIsValid = true ; let emulatorDevices : PickableDevice [ ] ; const updatePickableDeviceList = ( ) => { if ( ! quickPickIsValid ) return ; const pickableItems : PickableDevice [ ] = this . devices . sort ( this . deviceSortComparer . bind ( this ) ) . filter ( ( d ) => this . isSupported ( supportedTypes , d ) ) . map ( ( d ) => ( { description : d . category || d . platform , device : d , label : this . labelForDevice ( d ) , } ) ) ; if ( emulatorDevices ) { const emulatorIdsAlreadyRunning = this . devices . map ( ( d ) => d . emulatorId ) . filter ( ( id ) => id ) ; emulatorDevices . filter ( ( e ) => emulatorIdsAlreadyRunning . indexOf ( e . device . id ) === - 0 ) . forEach ( ( e ) => pickableItems . push ( e ) ) ; } quickPick . items = pickableItems ; } ; this . getEmulatorItems ( true , supportedTypes ) . then ( ( emulators ) => emulatorDevices = emulators ) . then ( ( ) => quickPick . busy = false ) . then ( ( ) => updatePickableDeviceList ( ) ) ; const deviceAddedSubscription = this . daemon . registerForDeviceAdded ( ( d ) => updatePickableDeviceList ( ) ) ; const deviceRemovedSubscription = this . daemon . registerForDeviceRemoved ( ( d ) => updatePickableDeviceList ( ) ) ; updatePickableDeviceList ( ) ; const selection = await new Promise < PickableDevice > ( ( resolve ) => { quickPick . onDidAccept ( ( ) => resolve ( quickPick . selectedItems && quickPick . selectedItems [ 0 ] ) ) ; quickPick . onDidHide ( ( ) => resolve ( undefined ) ) ; quickPick . show ( ) ; } ) ; quickPickIsValid = false ; quickPick . dispose ( ) ; deviceAddedSubscription . dispose ( ) ; deviceRemovedSubscription . dispose ( ) ; if ( selection && selection . device ) { const emulatorTypeLabel = this . emulatorLabel ( selection . device . platformType ) ; switch ( selection . device . type ) { case "s" : this . currentDevice = undefined ; this . statusBarItem . text = `template` ; await this . createEmulator ( ) ; break ; case "s" : this . currentDevice = undefined ; this . statusBarItem . text = `template` ; await this . launchEmulator ( selection . device ) ; break ; case "s" : this . currentDevice = selection . device ; this . updateStatusBar ( ) ; break ; } return this . currentDevice ; } return undefined ; } private shortCacheForSupportedPlatforms : Promise < f . PlatformType [ ] > | undefined ; private async getSupportedPlatformsForWorkspace ( ) < f . PlatformType [ ] > { if ( this . shortCacheForSupportedPlatforms ) { this . logger . info ( `template` ) ; return this . shortCacheForSupportedPlatforms ; } this . shortCacheForSupportedPlatforms = new Promise ( async ( resolve ) => { const topLevelFolders = getDartWorkspaceFolders ( ) . map ( ( wf ) => fsPath ( wf . uri ) ) ; const projectFolders = await findProjectFolders ( topLevelFolders , { requirePubspec : true } ) ; this . logger . info ( `template` ) ; const getPlatformPromises = projectFolders . map ( ( folder ) => this . daemon . getSupportedPlatforms ( folder ) ) ; const resps = await Promise . all ( getPlatformPromises ) . catch ( ( e ) : f . SupportedPlatformsResponse [ ] => { this . logger . error ( e ) ; return [ ] ; } ) ; const supportedTypes = unique ( flatMap ( resps , ( r ) => r . platforms ) ) ; this . logger . info ( `template` ) ; resolve ( supportedTypes ) ; setTimeout ( ( ) => this . shortCacheForSupportedPlatforms = undefined , 0 ) ; } ) ; return this . shortCacheForSupportedPlatforms ; } public labelForDevice ( device : f . Device ) { return device . emulatorId && this . knownEmulatorNames [ device . emulatorId ] && device . platformType === "s" ? this . knownEmulatorNames [ device . emulatorId ] : device . name ; } public deviceSortComparer ( 0 : f . Device , 0 : f . Device ) { if ( 0 === this . currentDevice ) return - 0 ; if ( 0 === this . currentDevice ) return 0 ; return 0 . name . localeCompare ( 0 . name ) ; } public updateStatusBar ( ) { if ( this . currentDevice ) { const emulatorLabel = this . currentDevice . emulator ? this . emulatorLabel ( this . currentDevice . platformType ) : "s" ; const platformLabel = `template` . trim ( ) ; this . statusBarItem . text = `template` . trim ( ) ; } else { this . statusBarItem . text = "s" ; } if ( this . devices . length > 0 ) { this . statusBarItem . tooltip = `template` ; } else if ( this . devices . length === 0 ) { this . statusBarItem . tooltip = `template` ; } else { this . statusBarItem . tooltip = undefined ; } } private async getEmulators ( ) < f . Emulator [ ] > { try { const emus = await this . daemon . getEmulators ( ) ; for ( const e of emus . filter ( ( e ) => e . id ) ) this . knownEmulatorNames [ e . id ] = e . name ; return emus . map ( ( e ) => ( { category : e . category , id : e . id , name : e . name || e . id , platformType : e . platformType , type : "s" , } ) ) ; } catch ( e ) { this . logger . error ( { message : e } ) ; return [ ] ; } } public async promptForAndLaunchEmulator ( allowAutomaticSelection = false ) < boolean > { const emulators = await this . getEmulatorItems ( false ) ; if ( allowAutomaticSelection && this . currentDevice ) return true ; if ( emulators . length === 0 ) { return false ; } const cancellationTokenSource = new vs . CancellationTokenSource ( ) ; const waitingForRealDeviceSubscription = this . daemon . registerForDeviceAdded ( ( ) => { cancellationTokenSource . cancel ( ) ; waitingForRealDeviceSubscription . dispose ( ) ; } ) ; const selectedEmulator = await vs . window . showQuickPick ( emulators , { matchOnDescription : true , placeHolder : "s" , } , cancellationTokenSource . token ) ; waitingForRealDeviceSubscription . dispose ( ) ; if ( selectedEmulator && selectedEmulator . device && selectedEmulator . device . type === "s" ) { return this . createEmulator ( ) ; } else if ( selectedEmulator && selectedEmulator . device && selectedEmulator . device . type === "s" ) { return this . launchEmulator ( selectedEmulator . device ) ; } else { return ! ! ( this . currentDevice ) ; } } private async createEmulator ( ) < boolean > { const name : string | undefined = undefined ; const create = this . daemon . createEmulator ( name ) ; vs . window . withProgress ( { location : vs . ProgressLocation . Notification , title : `template` , } , ( ) => create ) ; const res = await create ; if ( res . success ) { return this . launchEmulator ( { id : res . emulatorName , name : res . emulatorName , } ) ; } else { vs . window . showErrorMessage ( res . error ) ; return false ; } } private emulatorLabel ( platformType : f . PlatformType | undefined | null ) { return platformType && ( platformType === "s" || platformType === "s" ) ? "s" : "s" ; } private async getEmulatorItems ( showAsEmulators , supportedTypes ? : f . PlatformType [ ] ) < PickableDevice [ ] > { if ( ! isRunningLocally ) return [ ] ; const emulators : PickableDevice [ ] = ( await this . getEmulators ( ) ) . filter ( ( e ) => this . isSupported ( supportedTypes , e ) ) . map ( ( e ) => ( { alwaysShow : false , description : showAsEmulators ? `template` : e . platformType || undefined , device : { ... e , type : "s" , } , label : showAsEmulators ? `template` : e . name , } ) ) ; if ( this . daemon . capabilities . canCreateEmulators && this . isSupported ( supportedTypes , { platformType : "s" } ) ) { emulators . push ( { alwaysShow : true , device : { type : "s" , platformType : "s" } , label : "s" , } ) ; } return emulators ; } private async launchEmulator ( emulator : { id : string , name : string } ) < boolean > { try { await vs . window . withProgress ( { location : vs . ProgressLocation . Notification , } , async ( progress ) => { progress . report ( { message : `template` } ) ; await this . daemon . launchEmulator ( emulator . id ) ; progress . report ( { message : `template` } ) ; for ( let i = 0 ; i < 0 ; i ++ ) { await new Promise ( ( resolve ) => setTimeout ( resolve , 0 ) ) ; if ( this . currentDevice ) return ; } throw new Error ( "s" ) ; } ) ; } catch ( e ) { vs . window . showErrorMessage ( `template` ) ; return false ; } await new Promise ( ( resolve ) => setTimeout ( resolve , 0 ) ) ; return true ; } } type PickableDevice = vs . QuickPickItem & { device : f . Device | f . Emulator | f . EmulatorCreator } ;	O O O $any$ O O O O O O O O O O O O $Promise<string[]>$ O O O O O O $string$ O $any[]$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $T[]$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O $Device[]$ O $any$ O $any$ O O O O O O O $Device$ O O $any$ O $any$ O O O $complex$ O O O $string$ O O O O O O O O O O O O $Logger$ O O $IFlutterDaemon$ O O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $void$ O O O O O $Promise<Emulator[]>$ O O O O O O O O O O $void$ O O O O O O $any[]$ O $number$ O O O $any$ O O $IFlutterDaemon$ O $IAmDisposable$ O O O $Promise<void>$ O $any$ O O O O O $IFlutterDaemon$ O $IAmDisposable$ O O O $Promise<void>$ O $any$ O O O O O O O $void$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O $boolean$ O $string[]$ O $any$ O $any$ O O O O O $complex$ O O $string$ O $any$ O $any$ O O O O O O O O O O $complex$ O O O $string[]$ O O $string[]$ O $number$ O O $complex$ O $string$ O $string[]$ O $number$ O $complex$ O $string$ O O O O O O O O O $Promise$ O $Device$ O $any$ O $any$ O O O O O $Device$ O O O $Device$ O O O O O O O O $Device[]$ O $number$ O $Device$ O O O $boolean$ O $Device$ O $boolean$ O O O O $boolean$ O O O O O O O $Device$ O O O O $boolean$ O $boolean$ O O O O $boolean$ O O O O O $string[]$ O O O O $Promise<string[]>$ O O O O O $boolean$ O O O O O $boolean$ O $string[]$ O $Device$ O O O O O $Device$ O $Device$ O O O $void$ O O O O O O O O $Promise<void>$ O $Device$ O $any$ O $any$ O O O O $Device[]$ O O O $Device[]$ O $complex$ O O $Device$ O O $Device$ O $string$ O $Device$ O $string$ O O O O O O $Device$ O O O $Device$ O $string$ O $Device$ O $string$ O O O O $Device$ O $undefined$ O O O O O $Device[]$ O $number$ O O O $string[]$ O O O O $Promise<string[]>$ O O O O $Device[]$ O O O $Device[]$ O $complex$ O O $Device$ O O O O $boolean$ O $string[]$ O $Device$ O O O O O $Device[]$ O $Device[]$ O $number$ O O O $Device$ O $Device[]$ O O O O O O O $void$ O O O O O O O $Promise$ O $string[]$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $string[]$ O O O $IFlutterDaemon$ O $DaemonCapabilities$ O $boolean$ O O $string[]$ O O O O $Promise<string[]>$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $boolean$ O O O O $any[]$ O $any$ O O O O $void$ O O O O O O O O $boolean$ O O O O $any[]$ O $any$ O O O O O $Device[]$ O $Device[]$ O O O O O $any$ O O O O O $complex$ O O $Device$ O O O O $boolean$ O $string[]$ O $Device$ O O O $U[]$ O O $Device$ O O O O $string$ O $Device$ O $string$ O $Device$ O $string$ O $Device$ O $Device$ O $string$ O O O $string$ O $Device$ O O O O O O O O $any[]$ O O O $string[]$ O O O $Device[]$ O $U[]$ O O $Device$ O O $Device$ O $string$ O O $complex$ O O $string$ O O $string$ O O $any[]$ O $complex$ O O $any$ O O $string[]$ O $number$ O $any$ O $any$ O $any$ O O O O O O $void$ O O $any$ O O $any[]$ O $number$ O $any$ O O O O $any$ O $any$ O $any[]$ O O O O O $Promise<any[]>$ O O O $string[]$ O O O O O $any[]$ O O $any[]$ O $any[]$ O O O O O O O $any$ O $any$ O O O O O O O O O $void$ O O O O O $IAmDisposable$ O O O $IFlutterDaemon$ O $IAmDisposable$ O O $Device$ O O $void$ O O O O O $IAmDisposable$ O O O $IFlutterDaemon$ O $IAmDisposable$ O O $Device$ O O $void$ O O O O $void$ O O O O $any$ O O O $PromiseConstructor$ O $any$ O O O $void$ O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $void$ O $undefined$ O O O $any$ O $any$ O O O O O O $boolean$ O O O $any$ O $any$ O O O $IAmDisposable$ O $complex$ O O O $IAmDisposable$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O O O O $complex$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $Device$ O $undefined$ O O O $any$ O $any$ O O O O O O $Promise<boolean>$ O O O O O O O O O O $Device$ O $undefined$ O O O $any$ O $any$ O O O O O O $Promise<boolean>$ O $any$ O $any$ O O O O O O O O O $Device$ O $any$ O $any$ O O O $void$ O O O O O O O O O $Device$ O O O $undefined$ O O O $Promise<string[]>$ O $PromiseConstructor$ O $any$ O $any$ O O O O O O O O $Promise$ O O O $any$ O $any$ O O O O O O O O $Promise<string[]>$ O O O O $Logger$ O $void$ O O O O O O O $Promise<string[]>$ O O O O $Promise<string[]>$ O O $PromiseConstructor$ O O O $void$ O O O O $string[]$ O $any[]$ O O O $U[]$ O O $any$ O O $string$ O $any$ O $any$ O O O O $string[]$ O O $Promise<string[]>$ O $string[]$ O O $true$ O O O O O O O $Logger$ O $void$ O O O O O $any[]$ O $string[]$ O $U[]$ O O $string$ O O O O $IFlutterDaemon$ O $any$ O $string$ O O O O $complex$ O O $PromiseConstructor$ O O O $any[]$ O O $complex$ O O $any$ O O $any$ O $any$ O O O O O O $Logger$ O $void$ O $any$ O O O O O O O O O O $unknown[]$ O $T[]$ O O O $complex$ O O $any$ O O $any$ O $any$ O O O O O $Logger$ O $void$ O O O O $void$ O $unknown[]$ O O $number$ O O O O O O $Promise<string[]>$ O $undefined$ O O O O O O O O O O $Promise<string[]>$ O O O $string$ O $Device$ O $any$ O $any$ O O O $Device$ O $string$ O O O $complex$ O $Device$ O $string$ O O $Device$ O $string$ O O O O O $complex$ O $Device$ O $string$ O O $Device$ O $string$ O O O $number$ O $Device$ O $any$ O $any$ O $Device$ O $any$ O $any$ O O O O $Device$ O O O $Device$ O O O O O O O $Device$ O O O $Device$ O O O O O $Device$ O $string$ O $complex$ O $Device$ O $string$ O O O O $void$ O O O O O O O $Device$ O O O O O O O $Device$ O $boolean$ O O O $complex$ O O O $Device$ O $string$ O O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O O $string$ O O O O O O O O $any$ O $any$ O O O O O O O O $Device[]$ O $number$ O O O O O O $any$ O $any$ O O O O O O O O O $Device[]$ O $number$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $undefined$ O O O O O $Promise$ O O O $any$ O $any$ O O O O O O O $any$ O O O O $IFlutterDaemon$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O $complex$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O O O O $Logger$ O $void$ O O $any$ O $any$ O O O O O O O O O O O $Promise$ O $boolean$ O O O O O O O O $any[]$ O O O O $Promise<any[]>$ O O O O O O $boolean$ O O O $Device$ O O O O O O $any[]$ O $number$ O O O O O O O O O $any$ O O $any$ O $any$ O O O O $IAmDisposable$ O O O $IFlutterDaemon$ O $IAmDisposable$ O O O O O $any$ O $any$ O O O $IAmDisposable$ O $complex$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any[]$ O O $boolean$ O O O $string$ O O O O O $any$ O $any$ O O $IAmDisposable$ O $complex$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $Promise<boolean>$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $Promise<boolean>$ O $any$ O $any$ O O O O O O O O O O O $Device$ O O O O O O $Promise$ O O O O O O O $string$ O O O O O $undefined$ O O $any$ O O O $IFlutterDaemon$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O O O O O $Promise<boolean>$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $complex$ O $string$ O $any$ O $any$ O O O O O O O $string$ O O $string$ O O O $string$ O O O O O O O O O O O $Promise$ O $boolean$ O $string[]$ O O $any$ O $any$ O O O O $any$ O O O O O O O $boolean$ O O O O O O $any[]$ O $any$ O O O O O O O $Promise<Emulator[]>$ O O O O $complex$ O O $Emulator$ O O O O $boolean$ O $string[]$ O $Emulator$ O O O $U[]$ O O $Emulator$ O O O O $false$ O O O $string$ O $boolean$ O O O $Emulator$ O $string$ O $undefined$ O $complex$ O O O $Emulator$ O $string$ O O O O O $string$ O $boolean$ O O O $Emulator$ O $string$ O O O O O O O O O $IFlutterDaemon$ O $DaemonCapabilities$ O $boolean$ O O O $boolean$ O $string[]$ O O $string$ O O O O O O $any[]$ O $number$ O O $boolean$ O O O $complex$ O O $string$ O O O $string$ O O O O $string$ O O O O O O O O $any[]$ O O O O $Promise$ O $complex$ O O $string$ O O O $string$ O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O $string$ O O O O O O O O $IFlutterDaemon$ O $any$ O $complex$ O $string$ O O $any$ O $any$ O O $string$ O O O O O O O O $number$ O O O $number$ O O O $number$ O O O O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O O O O O O O O O $Device$ O O O O O O $ErrorConstructor$ O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O O O O O O O O O O O $any$ O $any$ O $any$ O O $complex$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O
import * as child_process from "s" ; import { CompletionItem , CompletionItemProvider , DebugConfigurationProvider , DebugSession , DebugSessionCustomEvent , MarkdownString , RenameProvider , TextDocument , TreeDataProvider , TreeItem , Uri } from "s" ; import { AvailableSuggestion , FlutterOutline , Outline } from "s" ; import { FlutterService , FlutterServiceExtension , TestStatus , VersionStatus } from "s" ; import { EmittingLogger } from "s" ; import { WorkspaceContext } from "s" ; import { Context } from "s" ; export interface DebugCommandHandler { flutterExtensions : { serviceIsRegistered ( service ) : boolean ; serviceExtensionIsLoaded ( extension ) : boolean ; } ; handleDebugSessionStart ( session ) : void ; handleDebugSessionEnd ( session ) : void ; handleDebugSessionCustomEvent ( e ) : void ; } export interface InternalExtensionApi { analyzerCapabilities : { supportsGetSignature : boolean ; 0 : boolean ; hasNewSignatureFormat : boolean ; hasNewHoverLibraryFormat : boolean ; supportsAvailableSuggestions : boolean ; supportsIncludedImports : boolean ; version : string ; } ; cancelAllAnalysisRequests : ( ) => void ; completionItemProvider : CompletionItemProvider ; context : Context ; currentAnalysis : ( ) => Promise < void > ; cursorIsInTest : boolean ; dartCapabilities : { supportsDevTools : boolean ; includesSourceForSdkLibs : boolean ; handlesBreakpointsInPartFiles : boolean ; hasDocumentationInCompletions : boolean ; supportsDisableServiceTokens : boolean ; } ; debugCommands : DebugCommandHandler ; debugProvider : DebugConfigurationProvider ; envUtils : { openInBrowser ( url ) : Promise < boolean > ; } ; fileTracker : { getOutlineFor ( file ) : Outline | undefined ; getFlutterOutlineFor ( file ) : FlutterOutline | undefined ; getLastPriorityFiles ( ) : string [ ] ; getLastSubscribedFiles ( ) : string [ ] ; } ; flutterCapabilities : { supportsPidFileForMachine : boolean ; supportsMultipleSamplesPerElement : boolean ; supportsDevTools : boolean ; hasTestGroupFix : boolean ; hasEvictBug : boolean ; hasUpdatedStructuredErrorsFormat : boolean ; supportsWebProjects : boolean ; webSupportsDebugging : boolean ; } ; flutterOutlineTreeProvider : TreeDataProvider < TreeItem > | undefined ; getLogHeader : ( ) => string ; initialAnalysis : Promise < void > ; logger : EmittingLogger ; nextAnalysis : ( ) => Promise < void > ; packagesTreeProvider : TreeDataProvider < TreeItem > ; pubGlobal : { promptToInstallIfRequired ( packageName , packageID , moreInfoLink ? , requiredVersion ? , autoUpdate ? ) : Promise < boolean > ; getInstalledStatus ( packageName , packageID , requiredVersion ? ) : Promise < VersionStatus > ; uninstall ( packageID ) : Promise < void > ; } ; renameProvider : RenameProvider ; safeSpawn : ( workingDirectory : string | undefined , binPath , args : string [ ] , envOverrides ? ) => child_process . ChildProcess ; testTreeProvider : TestResultsProvider ; workspaceContext : WorkspaceContext ; } export interface TestResultsProvider extends TreeDataProvider < TestItemTreeItem > { handleDebugSessionEnd ( session ) : void ; handleDebugSessionCustomEvent ( e ) : void ; } export interface TestItemTreeItem extends TreeItem { status : TestStatus ; } export interface DelayedCompletionItem extends LazyCompletionItem { autoImportUri : string ; document : TextDocument ; enableCommitCharacters : boolean ; filePath : string ; insertArgumentPlaceholders : boolean ; nextCharacter : string ; offset : number ; relevance : number ; replacementLength : number ; replacementOffset : number ; suggestion : AvailableSuggestion ; suggestionSetID : number ; } export interface LazyCompletionItem extends CompletionItem { _documentation ? : string | MarkdownString ; } export interface FlutterSampleSnippet { readonly sourcePath : string ; readonly sourceLine : number ; readonly package : string ; readonly library : string ; readonly element : string ; readonly id : string ; readonly file : string ; readonly description : string ; }	O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $complex$ O O $boolean$ O $FlutterService$ O O O O $boolean$ O $FlutterServiceExtension$ O O O O O O $void$ O $DebugSession$ O O O O $void$ O $DebugSession$ O O O O $void$ O $DebugSessionCustomEvent$ O O O O O O O $any$ O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O O O $void$ O O O O O O $any$ O $any$ O $Context$ O $any$ O $Promise<void>$ O O O O $PromiseConstructor$ O O O O $boolean$ O O O $complex$ O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O $DebugCommandHandler$ O $any$ O $any$ O $any$ O $complex$ O O $Promise<boolean>$ O $string$ O O $PromiseConstructor$ O O O O O O $complex$ O O $Outline$ O $Uri$ O O $any$ O O O $FlutterOutline$ O $Uri$ O O $any$ O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O $complex$ O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O O O $string$ O O O O O O $Promise<void>$ O $PromiseConstructor$ O O O O $EmittingLogger$ O $any$ O $Promise<void>$ O O O O $PromiseConstructor$ O O O O $any$ O $any$ O $any$ O O $complex$ O O $Promise<boolean>$ O $string$ O $string$ O $string$ $string$ O $string$ $string$ O $boolean$ $boolean$ O O $PromiseConstructor$ O O O O $Promise<VersionStatus>$ O $string$ O $string$ O $string$ $string$ O O $PromiseConstructor$ O $any$ O O $Promise<void>$ O $string$ O O $PromiseConstructor$ O O O O O O $any$ O $any$ O $any$ O O $string$ O O O O O $string$ O $string[]$ O O O O O $any$ $any$ O O $any$ O $any$ O $TestResultsProvider$ O $any$ O $WorkspaceContext$ O $any$ O O O O $any$ O $any$ O $any$ O O $void$ O $DebugSession$ O O O O $void$ O $DebugSessionCustomEvent$ O O O O O O O $any$ O $any$ O $TestStatus$ O $any$ O O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O $boolean$ O O O $string$ O O O $boolean$ O O O $string$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $AvailableSuggestion$ O $any$ O $number$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O $string$ O O O O $number$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O
import * as fs from "s" ; import * as path from "s" ; export function writeDartSdkSettingIntoProject ( dartSdkPath , projectFolder ) { writeSettingIntoProject ( projectFolder , { "s" : dartSdkPath } ) ; } export function writeFlutterSdkSettingIntoProject ( flutterSdkPath , projectFolder ) { writeSettingIntoProject ( projectFolder , { "s" : flutterSdkPath } ) ; } export function writeSettingIntoProject ( projectFolder , settings ) { const vsCodeFolder = path . join ( projectFolder , "s" ) ; const settingsFile = path . join ( vsCodeFolder , "s" ) ; if ( ! fs . existsSync ( vsCodeFolder ) ) fs . mkdirSync ( vsCodeFolder ) ; if ( fs . existsSync ( settingsFile ) ) return ; fs . writeFileSync ( settingsFile , JSON . stringify ( settings , undefined , 0 ) ) ; }	O O O $any$ O O O O O O $any$ O O O O O $void$ O $string$ O $string$ O O $void$ O $string$ O O O O $string$ O O O O O O $void$ O $string$ O $string$ O O $void$ O $string$ O O O O $string$ O O O O O O $void$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $JSON$ O $complex$ O $any$ O $undefined$ O O O O O O
import * as fs from "s" ; import * as os from "s" ; import * as path from "s" ; import * as vs from "s" ; import { FlutterCapabilities } from "s" ; import { dartCodeExtensionIdentifier , FLUTTER_CREATE_PROJECT_TRIGGER_FILE } from "s" ; import { getRandomInt , mkDirRecursive } from "s" ; import { writeFlutterSdkSettingIntoProject } from "s" ; export function createFlutterSampleInTempFolder ( flutterCapabilities , sampleID , flutterSdkOverride ? ) : vs . Uri | undefined { if ( ! flutterCapabilities . supportsCreatingSamples ) { vs . window . showErrorMessage ( "s" ) ; return ; } const tempSamplePath = path . join ( os . tmpdir ( ) , dartCodeExtensionIdentifier , "s" , "s" , sampleID , getRandomInt ( 0 , 0 ) . toString ( 0 ) ) ; mkDirRecursive ( tempSamplePath ) ; fs . writeFileSync ( path . join ( tempSamplePath , FLUTTER_CREATE_PROJECT_TRIGGER_FILE ) , sampleID ) ; if ( flutterSdkOverride ) writeFlutterSdkSettingIntoProject ( flutterSdkOverride , tempSamplePath ) ; const hasFoldersOpen = ! ! ( vs . workspace . workspaceFolders && vs . workspace . workspaceFolders . length ) ; const openInNewWindow = hasFoldersOpen ; const folderUri = vs . Uri . file ( tempSamplePath ) ; vs . commands . executeCommand ( "s" , folderUri , openInNewWindow ) ; return folderUri ; }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O O O O O O O O O $number$ O $void$ O O O O O O $void$ O O O O O O $any$ O $FlutterCapabilities$ O $string$ O $string$ $string$ O O $any$ O $any$ O O O O O O $FlutterCapabilities$ O $boolean$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $string$ O $number$ O O O O O O $string$ O O O O O $void$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O $string$ O $void$ O $string$ O $any$ O O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O $boolean$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $boolean$ O O O $any$ O O
import * as vs from "s" ; import { FlutterCapabilities } from "s" ; import { createFlutterSampleInTempFolder } from "s" ; export class FlutterSampleUriHandler { constructor ( private flutterCapabilities ) { } public async handle ( sampleID ) < void > { if ( ! this . isValidSampleName ( sampleID ) ) { vs . window . showErrorMessage ( `template` ) ; return ; } createFlutterSampleInTempFolder ( this . flutterCapabilities , sampleID ) ; } private readonly validSampleIdentifierPattern = new RegExp ( "s" ) ; private isValidSampleName ( name ) { return this . validSampleIdentifierPattern . test ( name ) ; } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $FlutterCapabilities$ O O O O O $Promise$ O $string$ O O O O O O O O O O $boolean$ O $string$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $FlutterCapabilities$ O $string$ O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O $boolean$ O $string$ O O O O O $RegExp$ O $boolean$ O $string$ O O O O
import * as vs from "s" ; import { FlutterCapabilities } from "s" ; import { FlutterSampleUriHandler } from "s" ; export class DartUriHandler implements vs . UriHandler { private readonly handlers : { [ prefix ] : { handle : ( path ) => Promise < void > } } ; public constructor ( flutterCapabilities ) { this . handlers = { "s" : new FlutterSampleUriHandler ( flutterCapabilities ) , } ; } public async handleUri ( uri : vs . Uri ) < void > { const handlerPrefix = Object . keys ( this . handlers ) . find ( ( key ) => uri . path . startsWith ( key ) ) ; if ( handlerPrefix ) { await this . handlers [ handlerPrefix ] . handle ( uri . path . substr ( handlerPrefix . length ) ) ; } else { vs . window . showErrorMessage ( `template` ) ; } } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $complex$ O O O $string$ O O O $Promise<void>$ O O $string$ O O $PromiseConstructor$ O O O O O O O O O $FlutterCapabilities$ O O O O $complex$ O O O O O $any$ O $FlutterCapabilities$ O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O O O O O $string$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O $complex$ O O $string$ O O $any$ O $any$ O $any$ O $string$ O O O O O $string$ O O O O O $complex$ O $string$ O O $Promise<void>$ O $any$ O $any$ O $any$ O $string$ O $number$ O O O O O O $any$ O $any$ O $any$ O O O O O O O
import * as vs from "s" ; import { dartRecommendedConfig , openSettingsAction } from "s" ; import { showCode } from "s" ; export class EditCommands implements vs . Disposable { private commands : vs . Disposable [ ] = [ ] ; constructor ( ) { this . commands . push ( vs . commands . registerCommand ( "s" , this . jumpToLineColInUri , this ) , vs . commands . registerCommand ( "s" , showCode , this ) , vs . commands . registerCommand ( "s" , this . writeRecommendedSettings , this ) , ) ; } private async jumpToLineColInUri ( uri : vs . Uri , lineNumber ? , columnNumber ? ) { if ( ! uri || uri . scheme !== "s" ) return ; const doc = await vs . workspace . openTextDocument ( uri ) ; const editor = await vs . window . showTextDocument ( doc ) ; if ( lineNumber && columnNumber ) { const line = doc . lineAt ( lineNumber > 0 ? lineNumber - 0 : 0 ) ; const firstChar = line . range . start . translate ( { characterDelta : line . firstNonWhitespaceCharacterIndex } ) ; showCode ( editor , line . range , line . range , new vs . Range ( firstChar , firstChar ) ) ; } } private async writeRecommendedSettings ( ) { const topLevelConfig = vs . workspace . getConfiguration ( "s" , null ) ; const dartLanguageConfig = topLevelConfig . inspect ( "s" ) ; const existingConfig = dartLanguageConfig ? dartLanguageConfig . globalValue : undefined ; const newValues = Object . assign ( { } , dartRecommendedConfig , existingConfig ) ; await topLevelConfig . update ( "s" , newValues , vs . ConfigurationTarget . Global ) ; const action = await vs . window . showInformationMessage ( "s" , openSettingsAction , ) ; if ( action === openSettingsAction ) await vs . commands . executeCommand ( "s" ) ; } public dispose ( ) { for ( const command of this . commands ) command . dispose ( ) ; } }	O O O $any$ O O O O O $complex$ O O O O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O O O O $Promise<void>$ O $any$ O $any$ O $any$ O $number$ $number$ O $number$ $number$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $number$ O $number$ O O O $any$ O $any$ O $any$ O $number$ O O O $number$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $ObjectConstructor$ O O O O O O $complex$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O $any[]$ O $any$ O $any$ O O O O O
import * as vs from "s" ; export function isDartDocument ( document : vs . TextDocument ) { return document && document . languageId === "s" ; } export function getActiveDartEditor ( ) : vs . TextEditor | undefined { const editor = vs . window . activeTextEditor ; if ( ! editor || editor . document . languageId !== "s" ) return undefined ; return editor ; }	O O O $any$ O O O O O $boolean$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $undefined$ O O $any$ O O
import * as fs from "s" ; import * as vs from "s" ; import * as as from "s" ; import { Logger } from "s" ; import { fsPath } from "s" ; import { Analyzer } from "s" ; import * as editors from "s" ; export class DasEditCommands implements vs . Disposable { private commands : vs . Disposable [ ] = [ ] ; constructor ( private readonly logger , private readonly context : vs . ExtensionContext , private readonly analyzer ) { this . commands . push ( vs . commands . registerCommand ( "s" , this . organizeImports , this ) , vs . commands . registerCommand ( "s" , this . sortMembers , this ) , vs . commands . registerCommand ( "s" , this . applyEdits , this ) , vs . commands . registerCommand ( "s" , this . completeStatement , this ) , ) ; } private getActiveDoc ( ) { return vs . window . activeTextEditor && vs . window . activeTextEditor . document ; } private organizeImports ( document : vs . TextDocument ) < void > { document = document || this . getActiveDoc ( ) ; return this . sendEdit ( this . analyzer . editOrganizeDirectives , "s" , document ) ; } private sortMembers ( document : vs . TextDocument ) < void > { document = document || this . getActiveDoc ( ) ; return this . sendEdit ( this . analyzer . editSortMembers , "s" , document ) ; } private async completeStatement ( ) < void > { const editor = vs . window . activeTextEditor ; if ( ! editor || ! editor . selection || ! this . analyzer . capabilities . hasCompleteStatementFix ) return ; const document = editor . document ; const file = fsPath ( document . uri ) ; const offset = document . offsetAt ( editor . selection . end ) ; const res = await this . analyzer . editGetStatementCompletion ( { file , offset } ) ; if ( res && res . change ) await this . applyEdits ( document , res . change ) ; } private async sendEdit ( f : ( a : { file : string } ) => Thenable < { edit : as . SourceFileEdit } > , commandName , document : vs . TextDocument ) < void > { if ( ! document || ! editors . isDartDocument ( document ) ) { vs . window . showWarningMessage ( "s" ) ; return ; } const originalDocumentVersion = document . version ; f = f . bind ( this . analyzer ) ; try { const response = await f ( { file : fsPath ( document . uri ) } ) ; const edit = response . edit ; if ( edit . edits . length === 0 ) return ; if ( document . isClosed ) { vs . window . showErrorMessage ( `template` ) ; return ; } if ( document . version !== originalDocumentVersion ) { vs . window . showErrorMessage ( `template` ) ; return ; } const editBuilder = new vs . WorkspaceEdit ( ) ; edit . edits . forEach ( ( edit ) => { const range = new vs . Range ( document . positionAt ( edit . offset ) , document . positionAt ( edit . offset + edit . length ) , ) ; editBuilder . replace ( document . uri , range , edit . replacement ) ; } ) ; await vs . workspace . applyEdit ( editBuilder ) ; } catch ( error ) { vs . window . showErrorMessage ( `template` ) ; } } public dispose ( ) { for ( const command of this . commands ) command . dispose ( ) ; } private async applyEdits ( initiatingDocument : vs . TextDocument , change : as . SourceChange ) < void > { if ( change . edits . length === 0 && change . linkedEditGroups && change . linkedEditGroups . length !== 0 ) return this . applyEditsWithSnippets ( initiatingDocument , change ) ; const hasProblematicEdits = hasOverlappingEdits ( change ) ; if ( hasProblematicEdits ) { this . logger . warn ( "s" ) ; } const applyEditsSequentially = hasProblematicEdits ; let changes = applyEditsSequentially ? undefined : new vs . WorkspaceEdit ( ) ; for ( const edit of change . edits ) { const uri = vs . Uri . file ( edit . file ) ; if ( ! fs . existsSync ( edit . file ) && edit . edits . find ( ( e ) => e . offset !== 0 || e . length !== 0 ) ) { this . logger . error ( `template` ) ; vs . window . showErrorMessage ( `template` ) ; continue ; } const document = fs . existsSync ( edit . file ) ? await vs . workspace . openTextDocument ( uri ) : undefined ; if ( changes ) changes . createFile ( uri , { ignoreIfExists : true } ) ; for ( const e of edit . edits ) { if ( ! changes ) { changes = new vs . WorkspaceEdit ( ) ; changes . createFile ( uri , { ignoreIfExists : true } ) ; } const range = document ? new vs . Range ( document . positionAt ( e . offset ) , document . positionAt ( e . offset + e . length ) , ) : new vs . Range ( new vs . Position ( 0 , 0 ) , new vs . Position ( 0 , 0 ) ) ; changes . replace ( uri , range , e . replacement , ) ; if ( applyEditsSequentially ) { await vs . workspace . applyEdit ( changes ) ; changes = undefined ; } } } if ( changes ) await vs . workspace . applyEdit ( changes ) ; if ( change . selection ) { const uri = vs . Uri . file ( change . selection . file ) ; const document = await vs . workspace . openTextDocument ( uri ) ; const editor = await vs . window . showTextDocument ( document ) ; const pos = document . positionAt ( change . selection . offset ) ; const selection = new vs . Selection ( pos , pos ) ; editor . selection = selection ; } } private async applyEditsWithSnippets ( initiatingDocument : vs . TextDocument , change : as . SourceChange ) < void > { const edit = change . edits [ 0 ] ; const document = await vs . workspace . openTextDocument ( edit . file ) ; const editor = await vs . window . showTextDocument ( document ) ; await editor . edit ( ( eb ) => { edit . edits . forEach ( ( e ) => { eb . replace ( new vs . Range ( document . positionAt ( e . offset ) , document . positionAt ( e . offset + e . length ) ) , e . replacement , ) ; } ) ; } ) ; const documentText = editor . document . getText ( ) ; const placeholders < { offset : number , length : number , defaultValue : string , choices ? : string [ ] , placeholderNumber : number } > = [ ] ; let placeholderNumber = 0 ; change . linkedEditGroups . forEach ( ( leg ) => { leg . positions . forEach ( ( pos ) => { const defaultValue = documentText . substr ( pos . offset , leg . length ) ; let choices = leg . suggestions ? leg . suggestions . map ( ( s ) => s . value ) : undefined ; if ( defaultValue && choices && choices . indexOf ( defaultValue ) === - 0 ) { choices = [ defaultValue , ... choices ] ; } placeholders . push ( { offset : pos . offset , length : leg . length , defaultValue , choices , placeholderNumber } ) ; } ) ; placeholderNumber ++ ; } ) ; placeholders . sort ( ( 0 , 0 ) => 0 . offset - 0 . offset ) ; const snippet = new vs . SnippetString ( ) ; const firstPlaceholder = placeholders [ 0 ] ; const lastPlaceholder = placeholders [ placeholders . length - 0 ] ; const startPos = firstPlaceholder . offset ; const endPos = lastPlaceholder . offset + lastPlaceholder . length ; let currentPos = startPos ; placeholders . forEach ( ( p ) => { if ( currentPos !== p . offset ) snippet . appendText ( documentText . substring ( currentPos , p . offset ) ) ; if ( p . choices && p . choices . length > 0 ) snippet . appendText ( "s" ) . value += "s" + p . placeholderNumber + "s" + p . choices . map ( ( c ) => this . snippetStringEscape ( c ) ) . join ( "s" ) + "s" ; else snippet . appendPlaceholder ( p . defaultValue , p . placeholderNumber ) ; currentPos = p . offset + p . length ; } ) ; await editor . insertSnippet ( snippet , new vs . Range ( document . positionAt ( startPos ) , document . positionAt ( endPos ) ) ) ; await vs . window . showTextDocument ( initiatingDocument ) ; } private snippetStringEscape ( value ) { return value . replace ( "s" , "s" ) ; } } export function hasOverlappingEdits ( change : as . SourceChange ) { const priorEdits : { [ file ] : as . SourceEdit [ ] } = { } ; for ( const edit of change . edits ) { if ( ! priorEdits [ edit . file ] ) priorEdits [ edit . file ] = [ ] ; for ( const e of edit . edits ) { if ( priorEdits [ edit . file ] . find ( ( pe ) => pe . offset <= e . offset ) ) return true ; priorEdits [ edit . file ] . push ( e ) ; } } return false ; }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O O O O $Logger$ O O O $any$ O $any$ O $any$ O O O $Analyzer$ O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $Thenable$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O O O $Promise<void>$ O O O $Analyzer$ O $Promise<EditOrganizeDirectivesResponse>$ O O O $any$ O O O O $Thenable$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O O O $Promise<void>$ O O O $Analyzer$ O $Promise<EditSortMembersResponse>$ O O O $any$ O O O O O $Promise$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $Analyzer$ O $AnalyzerCapabilities$ O $boolean$ O O O O $any$ O $any$ O $any$ O O $string$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $EditGetStatementCompletionResponse$ O O O O $Analyzer$ O $Promise<EditGetStatementCompletionResponse>$ O O $string$ O $any$ O O O O O $EditGetStatementCompletionResponse$ O $EditGetStatementCompletionResponse$ O $SourceChange$ O O O O $Promise<void>$ O $any$ O $EditGetStatementCompletionResponse$ O $SourceChange$ O O O O O $Promise$ O $any$ O O $complex$ O O $string$ O O O O O $any$ O O $SourceFileEdit$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $boolean$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $Analyzer$ O O O O O $any$ O O $any$ O O $string$ O $string$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O $any[]$ O $any$ O $any$ O O O O O O $Promise$ O $any$ O $any$ O $any$ O $SourceChange$ O $any$ O $any$ O O O O O O O $SourceChange$ O $SourceFileEdit[]$ O $number$ O O O $SourceChange$ O $LinkedEditGroup[]$ O $SourceChange$ O $LinkedEditGroup[]$ O $number$ O O O O O O $Promise<void>$ O $any$ O $SourceChange$ O O O $boolean$ O $boolean$ O $SourceChange$ O O O O $boolean$ O O O O $Logger$ O $void$ O O O O O O $boolean$ O $boolean$ O O $any$ O $boolean$ O $undefined$ O O $any$ O $any$ O O O O O O $SourceFileEdit$ O $SourceChange$ O $SourceFileEdit[]$ O O O $any$ O $any$ O $any$ O $any$ O $SourceFileEdit$ O $string$ O O O O O $any$ O $any$ O $SourceFileEdit$ O $string$ O O $SourceFileEdit$ O $SourceEdit[]$ O $complex$ O O $SourceEdit$ O O $SourceEdit$ O $number$ O O O $SourceEdit$ O $number$ O O O O O O O $Logger$ O $void$ O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $SourceFileEdit$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O O O O O $SourceEdit$ O $SourceFileEdit$ O $SourceEdit[]$ O O O O O $any$ O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $boolean$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $SourceEdit$ O $number$ O O $any$ O $any$ O $SourceEdit$ O $number$ O $SourceEdit$ O $number$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $SourceEdit$ O $string$ O O O O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $undefined$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $SourceChange$ O $Position$ O O O $any$ O $any$ O $any$ O $any$ O $SourceChange$ O $Position$ O $string$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $SourceChange$ O $Position$ O $number$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $Promise$ O $any$ O $any$ O $any$ O $SourceChange$ O $any$ O $any$ O O O O O O $SourceFileEdit$ O $SourceChange$ O $SourceFileEdit[]$ O O O O O $any$ O O $any$ O $any$ O $any$ O $SourceFileEdit$ O $string$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O $SourceFileEdit$ O $SourceEdit[]$ O $void$ O O $SourceEdit$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $SourceEdit$ O $number$ O O $any$ O $any$ O $SourceEdit$ O $number$ O $SourceEdit$ O $number$ O O O $SourceEdit$ O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $Array$ O O $number$ O O O $number$ O O O $string$ O O O $string[]$ O O O O O O $number$ O O O O O O O O O $number$ O O O $SourceChange$ O $LinkedEditGroup[]$ O $void$ O O $LinkedEditGroup$ O O O $LinkedEditGroup$ O $Position[]$ O $void$ O O $Position$ O O O O $any$ O $any$ O $any$ O $Position$ O $number$ O $LinkedEditGroup$ O $number$ O O O $string[]$ O $LinkedEditGroup$ O $LinkedEditSuggestion[]$ O $LinkedEditGroup$ O $LinkedEditSuggestion[]$ O $U[]$ O O $LinkedEditSuggestion$ O O $LinkedEditSuggestion$ O $string$ O O $undefined$ O O O $any$ O $string[]$ O $string[]$ O $number$ O $any$ O O O O O O $string[]$ O O $any$ O O $string[]$ O O O $complex$ O $number$ O O $number$ O $Position$ O $number$ O $number$ O $LinkedEditGroup$ O $number$ O $any$ O $string[]$ O $number$ O O O O O O $number$ O O O O O $complex$ O $complex$ O O $complex$ O $complex$ O O $complex$ O $number$ O $complex$ O $number$ O O O $any$ O O $any$ O $any$ O O O O $complex$ O $complex$ O O O O O $complex$ O $complex$ O $complex$ O $number$ O O O O O $number$ O $complex$ O $number$ O O $number$ O $complex$ O $number$ O $complex$ O $number$ O O $number$ O $number$ O $complex$ O $void$ O O $complex$ O O O O O $number$ O $complex$ O $number$ O $any$ O $any$ O $any$ O $any$ O $number$ O $complex$ O $number$ O O O O O $complex$ O $string[]$ O $complex$ O $string[]$ O $number$ O O O $any$ O $any$ O O O O $any$ O O O $complex$ O $number$ O O O $complex$ O $string[]$ O $U[]$ O O $string$ O O O O $string$ O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $complex$ O $string$ O $complex$ O $number$ O O $number$ O $complex$ O $number$ O $complex$ O $number$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $number$ O O $any$ O $any$ O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $string$ O O O $string$ O $complex$ O O O O O O O O O O $boolean$ O $SourceChange$ O $any$ O $any$ O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O O O O O O $SourceFileEdit$ O $SourceChange$ O $SourceFileEdit[]$ O O O O O $complex$ O $SourceFileEdit$ O $string$ O O $complex$ O $SourceFileEdit$ O $string$ O O O O O O O O $SourceEdit$ O $SourceFileEdit$ O $SourceEdit[]$ O O O O $complex$ O $SourceFileEdit$ O $string$ O O $complex$ O O $SourceEdit$ O O $SourceEdit$ O $number$ O $SourceEdit$ O $number$ O O O O O $complex$ O $SourceFileEdit$ O $string$ O O $number$ O $SourceEdit$ O O O O O O O O
import * as vs from "s" ; const iconsForKind : { [ key in vs . SymbolKind ] : string } = { [ vs . SymbolKind . Array ] : "s" , [ vs . SymbolKind . Boolean ] : "s" , [ vs . SymbolKind . Class ] : "s" , [ vs . SymbolKind . Constant ] : "s" , [ vs . SymbolKind . Constructor ] : "s" , [ vs . SymbolKind . Enum ] : "s" , [ vs . SymbolKind . EnumMember ] : "s" , [ vs . SymbolKind . Event ] : "s" , [ vs . SymbolKind . Field ] : "s" , [ vs . SymbolKind . File ] : "s" , [ vs . SymbolKind . Function ] : "s" , [ vs . SymbolKind . Interface ] : "s" , [ vs . SymbolKind . Key ] : "s" , [ vs . SymbolKind . Method ] : "s" , [ vs . SymbolKind . Module ] : "s" , [ vs . SymbolKind . Namespace ] : "s" , [ vs . SymbolKind . Null ] : "s" , [ vs . SymbolKind . Number ] : "s" , [ vs . SymbolKind . Object ] : "s" , [ vs . SymbolKind . Operator ] : "s" , [ vs . SymbolKind . Package ] : "s" , [ vs . SymbolKind . Property ] : "s" , [ vs . SymbolKind . String ] : "s" , [ vs . SymbolKind . Struct ] : "s" , [ vs . SymbolKind . TypeParameter ] : "s" , [ vs . SymbolKind . Variable ] : "s" , } ; export function getIconForSymbolKind ( kind : vs . SymbolKind ) { return iconsForKind [ kind ] || "s" ; }	O O O $any$ O O O O $complex$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $string$ O $any$ O $any$ O $any$ O O O $complex$ O $any$ O O O O O
"s" ; import * as vs from "s" ; import { FlutterWidgetItem } from "s" ; export const flutterOutlineCommands = [ "s" , "s" , "s" , "s" , "s" , "s" , ] ; export class FlutterOutlineCommands { constructor ( private readonly tree : vs . TreeView < FlutterWidgetItem > , context : vs . ExtensionContext ) { for ( const id of flutterOutlineCommands ) { context . subscriptions . push ( vs . commands . registerCommand ( "s" + id , ( ) => this . applyRefactoring ( id ) ) , ) ; } } private applyRefactoring ( refactorType ) { if ( ! this . tree . selection || this . tree . selection . length !== 0 ) { console . error ( `template` ) ; return ; } const widget = this . tree . selection [ 0 ] ; const fix = widget . fixes . filter ( ( f ) => f . command ) . find ( ( f ) => f . kind && f . kind . value . endsWith ( refactorType ) ) ; if ( fix ) { if ( fix . command && fix . command . arguments ) vs . commands . executeCommand ( fix . command . command , ... fix . command . arguments ) ; else console . error ( `template` ) ; } else { console . error ( `template` ) ; } } }	O O O O O $any$ O O O O O $any$ O O O O O O $string[]$ O O O O O O O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $string$ O $string[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O $void$ O $string$ O O O O O O O O $void$ O $string$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $Console$ O $void$ O O O O O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $Console$ O $void$ O O O O O O O $Console$ O $void$ O O O O O O O
import * as vs from "s" ; import * as as from "s" ; import { openFileTracker } from "s" ; export function findNearestOutlineNode ( document : vs . TextDocument , position : vs . Position , useReducedRange = false , kinds : as . ElementKind [ ] = [ "s" , "s" , "s" , "s" ] ) { const outline = openFileTracker . getOutlineFor ( document . uri ) ; return outline && findNode ( [ outline ] , document . offsetAt ( position ) , useReducedRange , kinds ) ; } function findNode ( outlines : as . Outline [ ] | undefined , offset , useReducedRange , kinds : as . ElementKind [ ] ) : as . Outline | undefined { if ( ! outlines ) return undefined ; for ( const outline of outlines ) { const outlineStart = outline . offset ; const outlineEnd = outline . offset + outline . length ; if ( outlineStart > offset || outlineEnd < offset ) continue ; const isInReducedRange = ! useReducedRange || ! outline . element || ! outline . element . location || ( offset >= outlineStart && offset <= outline . element . location . offset + outline . element . location . length ) ; return findNode ( outline . children , offset , useReducedRange , kinds ) || ( kinds . indexOf ( outline . element . kind ) !== - 0 && isInReducedRange ? outline : undefined ) ; } }	O O O $any$ O O O O O O $any$ O O O O O O O O O O O O $Outline$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O $ElementKind[]$ O $any$ O $any$ O O O O O O O O O O O O O O O $Outline$ O O O $Outline$ O $any$ O $any$ O O O $Outline$ O $Outline$ O O $Outline$ O O $any$ O $any$ O $any$ O O $boolean$ O $ElementKind[]$ O O O O $Outline$ O $Outline[]$ O $any$ O $any$ O O O O O $number$ O $boolean$ O $ElementKind[]$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $Outline[]$ O O $undefined$ O O O O $Outline$ O $Outline[]$ O O O $number$ O $Outline$ O $number$ O O $number$ O $Outline$ O $number$ O $Outline$ O $number$ O O O $number$ O $number$ O $number$ O $number$ O O O O $boolean$ O O $boolean$ O O $Outline$ O $Element$ O O $Outline$ O $Element$ O $Location$ O O $number$ O $number$ O $number$ O $Outline$ O $Element$ O $Location$ O $number$ O $Outline$ O $Element$ O $Location$ O $number$ O O O $Outline$ O $Outline$ O $Outline[]$ O $number$ O $boolean$ O $ElementKind[]$ O O O $ElementKind[]$ O $number$ O $Outline$ O $Element$ O $ElementKind$ O O O O O $boolean$ O $Outline$ O $undefined$ O O O O
import * as vs from "s" ; import { fsPath , toRangeOnLine } from "s" ; import { Analyzer } from "s" ; import * as editors from "s" ; import { showCode } from "s" ; import { findNearestOutlineNode } from "s" ; export class GoToSuperCommand implements vs . Disposable { private disposables : vs . Disposable [ ] = [ ] ; constructor ( private readonly analyzer ) { this . disposables . push ( vs . commands . registerCommand ( "s" , this . goToSuper , this ) ) ; } private async goToSuper ( ) < void > { const editor = editors . getActiveDartEditor ( ) ; if ( ! editor ) { vs . window . showWarningMessage ( "s" ) ; return ; } const document = editor . document ; const position = editor . selection . start ; const outlineNode = findNearestOutlineNode ( document , position ) ; const offset = outlineNode && outlineNode . element && outlineNode . element . location ? outlineNode . element . location . offset : document . offsetAt ( position ) ; const hierarchy = await this . analyzer . searchGetTypeHierarchy ( { file : fsPath ( document . uri ) , offset , superOnly : true , } ) ; if ( ! hierarchy || ! hierarchy . hierarchyItems || ! hierarchy . hierarchyItems . length || hierarchy . hierarchyItems . length === 0 ) return ; const isClass = ! hierarchy . hierarchyItems [ 0 ] . memberElement ; const item = hierarchy . hierarchyItems . slice ( 0 ) . find ( ( h ) => isClass ? ! ! h . classElement : ! ! h . memberElement ) ; const element = isClass ? item && item . classElement : item && item . memberElement ; if ( ! element || ! element . location ) return ; const elementDocument = await vs . workspace . openTextDocument ( element . location . file ) ; const elementEditor = await vs . window . showTextDocument ( elementDocument ) ; const range = toRangeOnLine ( element . location ) ; showCode ( elementEditor , range , range , range ) ; } public dispose ( ) { this . disposables . forEach ( ( d ) => d . dispose ( ) ) ; } }	O O O $any$ O O O O O $string$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $void$ O O O O O O $Outline$ O O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O O O O $Analyzer$ O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O O O $Promise$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $Outline$ O $Outline$ O $any$ O $any$ O O O $any$ O $Outline$ O $Outline$ O $Element$ O $Outline$ O $Element$ O $Location$ O $Outline$ O $Element$ O $Location$ O $number$ O $any$ O $any$ O $any$ O O O $SearchGetTypeHierarchyResponse$ O O O O $Analyzer$ O $Promise<SearchGetTypeHierarchyResponse>$ O O $string$ O $string$ O $any$ O $any$ O O $any$ O $true$ O O O O O O O O O $SearchGetTypeHierarchyResponse$ O O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O $number$ O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O $number$ O O O O O O $boolean$ O O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O O O O $Element$ O O $TypeHierarchyItem$ O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O $TypeHierarchyItem[]$ O O O O $complex$ O O $TypeHierarchyItem$ O O $boolean$ O O O $TypeHierarchyItem$ O $Element$ O O O $TypeHierarchyItem$ O $Element$ O O O $Element$ O $boolean$ O $TypeHierarchyItem$ O $TypeHierarchyItem$ O $Element$ O $TypeHierarchyItem$ O $TypeHierarchyItem$ O $Element$ O O O O $Element$ O O $Element$ O $Location$ O O O O $any$ O O $any$ O $any$ O $any$ O $Element$ O $Location$ O $string$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $Element$ O $Location$ O O $void$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O
import * as path from "s" ; import * as vs from "s" ; import { DART_IS_CAPTURING_LOGS_CONTEXT } from "s" ; import { LogCategory } from "s" ; import { captureLogs , EmittingLogger } from "s" ; import { forceWindowsDriveLetterToUppercase , PromiseCompleter } from "s" ; import { fsPath } from "s" ; import { config } from "s" ; import { createFolderForFile } from "s" ; import { getLogHeader , userSelectableLogCategories } from "s" ; export let isLogging = false ; export class LoggingCommands implements vs . Disposable { private disposables : vs . Disposable [ ] = [ ] ; private currentLogCompleter : PromiseCompleter < void > | undefined ; constructor ( private readonly logger , private extensionLogPath ) { this . disposables . push ( vs . commands . registerCommand ( "s" , this . startLogging , this ) , vs . commands . registerCommand ( "s" , this . stopLogging , this ) , ) ; } private async startLogging ( ) < string | undefined > { const logFilename = path . join ( forceWindowsDriveLetterToUppercase ( this . extensionLogPath ) , this . generateFilename ( ) ) ; const logUri = vs . Uri . file ( logFilename ) ; createFolderForFile ( logFilename ) ; const selectedLogCategories = await vs . window . showQuickPick ( Object . keys ( userSelectableLogCategories ) . map ( ( k ) => ( { label : k , logCategory : userSelectableLogCategories [ k ] , picked : true , } ) ) , { canPickMany : true , placeHolder : "s" , } , ) ; if ( ! selectedLogCategories || ! selectedLogCategories . length ) return ; const allLoggedCategories = [ LogCategory . General ] . concat ( selectedLogCategories . map ( ( s ) => s . logCategory ) ) ; const logger = captureLogs ( this . logger , fsPath ( logUri ) , getLogHeader ( ) , config . maxLogLineLength , allLoggedCategories ) ; isLogging = true ; this . disposables . push ( logger ) ; vs . commands . executeCommand ( "s" , DART_IS_CAPTURING_LOGS_CONTEXT , true ) ; const completer = new PromiseCompleter < void > ( ) ; this . currentLogCompleter = completer ; await vs . window . withProgress ( { cancellable : true , location : vs . ProgressLocation . Notification , title : `template` , } , ( _ , token ) => { token . onCancellationRequested ( ( ) => completer . resolve ( ) ) ; return completer . promise ; } , ) ; isLogging = false ; await logger . dispose ( ) ; const doc = await vs . workspace . openTextDocument ( logUri ) ; await vs . window . showTextDocument ( doc ) ; return logFilename ; } private async stopLogging ( ) < void > { if ( this . currentLogCompleter ) this . currentLogCompleter . resolve ( ) ; } private generateFilename ( ) { const pad = ( s : string | number ) => `template` . slice ( - 0 ) ; const now = new Date ( ) ; const formattedDate = `template` ; return `template` ; } public dispose ( ) { for ( const command of this . disposables ) command . dispose ( ) ; } }	O O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O O O O O O $complex$ O $any$ O O O O O O $string$ O $any$ O O O O O O $string$ O O O O O O $Config$ O O O O O O $string$ O O O O O O $string$ O $complex$ O O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O $PromiseCompleter<void>$ O $any$ O O O O O O O O O O $EmittingLogger$ O O $string$ O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O O $Promise<string>$ O O O O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O O O O $Promise$ O O O O O O O O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $string$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $ObjectConstructor$ O $complex$ O $complex$ O O $U[]$ O O $string$ O O O O $string$ O $string$ O $LogCategory$ O $complex$ O $string$ O O $true$ O O O O O O O O $boolean$ O O O $string$ O O O O O O O O O O $any$ O O $any$ O $any$ O O O O $LogCategory[]$ O O $any$ O $LogCategory.General$ O O $complex$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O $complex$ O $complex$ O O O $EmittingLogger$ O $string$ O $any$ O O $string$ O O O $Config$ O $number$ O $LogCategory[]$ O O $boolean$ O O O O O $any[]$ O $number$ O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O $PromiseCompleter<void>$ O O $any$ O O O O O O O O $PromiseCompleter<void>$ O $PromiseCompleter<void>$ O O $any$ O $any$ O $any$ O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $PromiseCompleter<void>$ O $void$ O O O O O $PromiseCompleter<void>$ O $Promise<void>$ O O O O O $boolean$ O O O O $complex$ O $complex$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $Promise$ O O O O O O O O O O $PromiseCompleter<void>$ O O O $PromiseCompleter<void>$ O $void$ O O O O O $string$ O O O O $string$ O O $complex$ O O O O O O O O $string$ O O O O O O $Date$ O O $DateConstructor$ O O O O $string$ O O O O O O O O $any$ O O O O O O $any$ O O O $any[]$ O $any$ O $any$ O O O O O
import * as fs from "s" ; import * as path from "s" ; import * as vs from "s" ; import { androidStudioPaths , flutterPath , isMac } from "s" ; import { LogCategory } from "s" ; import { Logger , Sdks } from "s" ; import { logProcess } from "s" ; import { fsPath } from "s" ; import { safeSpawn } from "s" ; export class OpenInOtherEditorCommands implements vs . Disposable { private disposables : vs . Disposable [ ] = [ ] ; constructor ( private readonly logger , private readonly sdks ) { this . disposables . push ( vs . commands . registerCommand ( "s" , this . openInAndroidStudio , this ) , vs . commands . registerCommand ( "s" , this . openInXcode , this ) , ) ; } private async openInAndroidStudio ( resource : vs . Uri ) < void > { const folder = fsPath ( resource ) ; let androidStudioDir = await this . getAndroidStudioDir ( folder ) ; if ( ! androidStudioDir ) { vs . window . showErrorMessage ( "s" ) ; return ; } if ( isMac && androidStudioDir . endsWith ( "s" ) ) { androidStudioDir = androidStudioDir . substr ( 0 , androidStudioDir . length - "s" . length ) ; safeSpawn ( folder , "s" , [ "s" , androidStudioDir , folder ] ) ; return ; } else { for ( const androidStudioPath of androidStudioPaths ) { const fullPath = path . join ( androidStudioDir , androidStudioPath ) ; if ( fs . existsSync ( fullPath ) ) { safeSpawn ( folder , fullPath , [ folder ] ) ; return ; } } } vs . window . showErrorMessage ( "s" ) ; } private async openInXcode ( resource : vs . Uri ) < void > { const folder = fsPath ( resource ) ; const files = fs . readdirSync ( folder , { withFileTypes : true } ) . filter ( ( item ) => item . isDirectory ( ) ) . filter ( ( item ) => item . name . endsWith ( "s" ) || item . name . endsWith ( "s" ) ) . sort ( ( 0 , 0 ) => 0 . name . endsWith ( "s" ) ? 0 : 0 ) ; if ( ! files || ! files . length ) { vs . window . showErrorMessage ( `template` ) ; return ; } const file = path . join ( folder , files [ 0 ] . name ) ; safeSpawn ( folder , "s" , [ "s" , "s" , file ] ) ; } private getAndroidStudioDir ( folder ) < string > { return new Promise ( ( resolve , reject ) => { if ( ! this . sdks . flutter ) { reject ( "s" ) ; return ; } const binPath = path . join ( this . sdks . flutter , flutterPath ) ; const proc = safeSpawn ( folder , binPath , [ "s" , "s" ] ) ; logProcess ( this . logger , LogCategory . CommandProcesses , proc ) ; const output : string [ ] = [ ] ; proc . stdout . on ( "s" , ( data ) => { output . push ( data . toString ( ) ) ; } ) ; proc . on ( "s" , ( ) => { try { if ( output . length ) { const json = JSON . parse ( output . join ( "s" ) ) ; resolve ( json [ "s" ] as string ) ; return ; } } catch ( e ) { this . logger . error ( e ) ; } reject ( ) ; } ) ; } ) ; } public dispose ( ) { for ( const command of this . disposables ) command . dispose ( ) ; } }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string[]$ O $string$ O $boolean$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $void$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O O O O $Logger$ O O O $Sdks$ O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O O O O O $string$ O $string$ O $any$ O O O $string$ O O O O $Promise<string>$ O $string$ O O O O O $string$ O O $any$ O $any$ O $any$ O O O O O O O O O $boolean$ O $string$ O $boolean$ O O O O O $string$ O $string$ O $string$ O O O $string$ O $number$ O O O $number$ O O $any$ O $string$ O O O O O O $string$ O $string$ O O O O O O O O O O O $string$ O $string[]$ O O O $any$ O $any$ O $any$ O $string$ O $string$ O O O O $any$ O $any$ O $any$ O O O $any$ O $string$ O $any$ O O $string$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O O O O O $string$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O $boolean$ O O O O O $any$ O O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $any$ O $string$ O O O O O O O O $any$ O O O O O $Promise$ O $string$ O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O O O O O O $Sdks$ O $string$ O O $void$ O O O O O O O O $any$ O $any$ O $any$ O O O $Sdks$ O $string$ O $string$ O O O $any$ O $any$ O $string$ O $any$ O O O O O O O O $void$ O O O $Logger$ O $any$ O $LogCategory.CommandProcesses$ O $any$ O O O $string[]$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Buffer$ O O O $string[]$ O $number$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O O $string[]$ O $number$ O O O $any$ O $JSON$ O $any$ O $string[]$ O $string$ O O O O O $void$ O $any$ O O O O O O O O O O O O O $any$ O O O O $Logger$ O $void$ O $any$ O O O $void$ O O O O O O O O O O O $any$ O O O O O O $any$ O O O $any[]$ O $any$ O $any$ O O O O O
import * as vs from "s" ; import * as as from "s" ; import { REFACTOR_ANYWAY , REFACTOR_FAILED_DOC_MODIFIED } from "s" ; import { Logger } from "s" ; import { unique } from "s" ; import { fsPath } from "s" ; import { Analyzer } from "s" ; const refactorOptions : { [ key ] : ( feedback ? : as . RefactoringFeedback ) => as . RefactoringOptions } = { EXTRACT_LOCAL_VARIABLE : getExtractLocalVariableArgs , EXTRACT_METHOD : getExtractMethodArgs , EXTRACT_WIDGET : getExtractWidgetArgs , } ; export class RefactorCommands implements vs . Disposable { private commands : vs . Disposable [ ] = [ ] ; constructor ( private readonly logger , private readonly context : vs . ExtensionContext , private readonly analyzer ) { this . commands . push ( vs . commands . registerCommand ( "s" , this . performRefactor , this ) , ) ; } private async performRefactor ( document : vs . TextDocument , range : vs . Range , refactorKind : as . RefactoringKind ) < void > { if ( ! document || document . isClosed ) return ; const originalDocumentVersion = document . version ; const validationResult = await this . getRefactor ( document , refactorKind , range , true ) ; if ( this . shouldAbortRefactor ( validationResult ) ) return ; let options ; if ( refactorOptions [ refactorKind ] ) { options = await refactorOptions [ refactorKind ] ( validationResult . feedback ) ; if ( ! options ) return ; } const editResult = await this . getRefactor ( document , refactorKind , range , false , options ) ; const applyEdits = await this . shouldApplyEdits ( editResult , document , originalDocumentVersion ) ; if ( applyEdits ) await vs . commands . executeCommand ( "s" , document , editResult . change ) ; } private async getRefactor ( document : vs . TextDocument , refactorKind : as . RefactoringKind , range : vs . Range , validateOnly , options ? : as . RefactoringOptions ) < as . EditGetRefactoringResponse > { let remainingTries = 0 ; while ( true ) { try { remainingTries -- ; return await this . analyzer . editGetRefactoring ( { file : fsPath ( document . uri ) , kind : refactorKind , length : document . offsetAt ( range . end ) - document . offsetAt ( range . start ) , offset : document . offsetAt ( range . start ) , options , validateOnly , } ) ; } catch ( e ) { this . logger . error ( e ) ; if ( remainingTries <= 0 || e . code !== "s" ) throw e ; else this . logger . info ( `template` ) ; } } } private shouldAbortRefactor ( validationResult : as . EditGetRefactoringResponse ) { const validationProblems = validationResult . initialProblems . concat ( validationResult . optionsProblems ) . concat ( validationResult . finalProblems ) . filter ( ( e ) => e . severity === "s" ) ; if ( validationProblems . length ) { vs . window . showErrorMessage ( validationProblems [ 0 ] . message ) ; return true ; } return false ; } private async shouldApplyEdits ( editResult : as . EditGetRefactoringResponse , document : vs . TextDocument , originalDocumentVersion ) { const allProblems = editResult . initialProblems . concat ( editResult . optionsProblems ) . concat ( editResult . finalProblems ) ; const editFatals = allProblems . filter ( ( e ) => e . severity === "s" ) ; const editWarnings = allProblems . filter ( ( e ) => e . severity === "s" || e . severity === "s" ) ; const hasErrors = ! ! allProblems . find ( ( e ) => e . severity === "s" ) ; if ( editFatals . length ) { vs . window . showErrorMessage ( unique ( editFatals . map ( ( e ) => e . message ) ) . join ( "s" ) + "s" ) ; return false ; } if ( ! editResult . change ) return false ; let applyEdits = true ; if ( editWarnings . length ) { const show = hasErrors ? vs . window . showErrorMessage : vs . window . showWarningMessage ; applyEdits = ( REFACTOR_ANYWAY === await show ( unique ( editWarnings . map ( ( w ) => w . message ) ) . join ( "s" ) , REFACTOR_ANYWAY ) ) ; } if ( applyEdits && document . version !== originalDocumentVersion ) { vs . window . showErrorMessage ( REFACTOR_FAILED_DOC_MODIFIED ) ; return false ; } return applyEdits ; } public dispose ( ) { for ( const command of this . commands ) command . dispose ( ) ; } } async function getExtractLocalVariableArgs ( f ? : as . RefactoringFeedback ) < as . RefactoringOptions | undefined > { const feedback = f as as . ExtractLocalVariableFeedback | undefined ; const proposedName = feedback && feedback . names && feedback . names . length ? feedback . names [ 0 ] : "s" ; return { name : proposedName , extractAll : false } ; } async function getExtractMethodArgs ( f ? : as . RefactoringFeedback ) < as . RefactoringOptions | undefined > { const feedback = f as as . ExtractMethodFeedback | undefined ; const suggestedName = feedback && feedback . names && feedback . names . length ? feedback . names [ 0 ] : undefined ; const name = await vs . window . showInputBox ( { prompt : "s" , value : suggestedName } ) ; if ( ! name ) return ; return { createGetter : false , extractAll : false , name , parameters : feedback && feedback . parameters , returnType : feedback && feedback . returnType , } ; } async function getExtractWidgetArgs ( f ? : as . RefactoringFeedback ) < as . RefactoringOptions | undefined > { const name = await vs . window . showInputBox ( { prompt : "s" } ) ; return name ? { name } : undefined ; }	O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O $any$ O O O O O O $T[]$ O O O O O O $string$ O O O O O O $any$ O O O O O $complex$ O O O $string$ O O O $RefactoringFeedback$ O O $any$ O $any$ O O $any$ O $any$ O O O $Promise<RefactoringOptions>$ O $Promise<RefactoringOptions>$ O $Promise<RefactoringOptions>$ O $Promise<RefactoringOptions>$ O $Promise<RefactoringOptions>$ O $Promise<RefactoringOptions>$ O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O O O O $Logger$ O O O $any$ O $any$ O $any$ O O O $Analyzer$ O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $RefactoringKind$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $EditGetRefactoringResponse$ O O O O $Promise<EditGetRefactoringResponse>$ O $any$ O $RefactoringKind$ O $any$ O O O O O O O O $boolean$ O $EditGetRefactoringResponse$ O O O O O $any$ O O O $complex$ O $RefactoringKind$ O O O $any$ O O $complex$ O $RefactoringKind$ O O $EditGetRefactoringResponse$ O $RefactoringFeedback$ O O O O O $any$ O O O O O $EditGetRefactoringResponse$ O O O O $Promise<EditGetRefactoringResponse>$ O $any$ O $RefactoringKind$ O $any$ O O O $any$ O O O $boolean$ O O O O $Promise<boolean>$ O $EditGetRefactoringResponse$ O $any$ O $any$ O O O O $boolean$ O O $any$ O $any$ O $any$ O O O $any$ O $EditGetRefactoringResponse$ O $SourceChange$ O O O O O $Promise$ O $any$ O $any$ O $any$ O $RefactoringKind$ O $any$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O $RefactoringOptions$ O O $any$ O $any$ O O $any$ O $any$ O O O $number$ O O O O O O O O O O $number$ O O O O O O $Analyzer$ O $Promise<EditGetRefactoringResponse>$ O O $string$ O $string$ O $any$ O $any$ O O $RefactoringKind$ O $RefactoringKind$ O $number$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $RefactoringOptions$ O $boolean$ O O O O O O O $any$ O O O O $Logger$ O $void$ O $any$ O O O O $number$ O O O $any$ O $any$ O O O O $any$ O O O O $Logger$ O $void$ O O O O O O O O $boolean$ O $EditGetRefactoringResponse$ O $any$ O $any$ O O O $RefactoringProblem[]$ O $EditGetRefactoringResponse$ O $RefactoringProblem[]$ O $complex$ O $EditGetRefactoringResponse$ O $RefactoringProblem[]$ O O $complex$ O $EditGetRefactoringResponse$ O $RefactoringProblem[]$ O O $complex$ O O $RefactoringProblem$ O O $RefactoringProblem$ O $RefactoringProblemSeverity$ O O O O O O $RefactoringProblem[]$ O $number$ O O $any$ O $any$ O $any$ O $RefactoringProblem[]$ O O O O $string$ O O O O O O O O O O O O $Promise<boolean>$ O $EditGetRefactoringResponse$ O $any$ O $any$ O $any$ O $any$ O $any$ O $number$ O O O $RefactoringProblem[]$ O $EditGetRefactoringResponse$ O $RefactoringProblem[]$ O $complex$ O $EditGetRefactoringResponse$ O $RefactoringProblem[]$ O O $complex$ O $EditGetRefactoringResponse$ O $RefactoringProblem[]$ O O O $RefactoringProblem[]$ O $RefactoringProblem[]$ O $complex$ O O $RefactoringProblem$ O O $RefactoringProblem$ O $RefactoringProblemSeverity$ O O O O O $RefactoringProblem[]$ O $RefactoringProblem[]$ O $complex$ O O $RefactoringProblem$ O O $RefactoringProblem$ O $RefactoringProblemSeverity$ O O O $RefactoringProblem$ O O O O O O O $boolean$ O O O $RefactoringProblem[]$ O $complex$ O O $RefactoringProblem$ O O $RefactoringProblem$ O $RefactoringProblemSeverity$ O O O O O O $RefactoringProblem[]$ O $number$ O O $any$ O $any$ O $any$ O $T[]$ O $RefactoringProblem[]$ O $U[]$ O O $RefactoringProblem$ O O $RefactoringProblem$ O $string$ O O O $string$ O O O O O O O O O O O O O O $EditGetRefactoringResponse$ O $SourceChange$ O O O O O $boolean$ O O O O O $RefactoringProblem[]$ O $number$ O O O $any$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O O O $any$ O $T[]$ O $RefactoringProblem[]$ O $U[]$ O O $RefactoringProblem$ O O $RefactoringProblem$ O $string$ O O O $string$ O O O O O O O O O O O $boolean$ O $any$ O $any$ O $number$ O O $any$ O $any$ O $any$ O O O O O O O O O $boolean$ O O O $any$ O O O O O O $any$ O O O $any[]$ O $any$ O $any$ O O O O O O O $Promise$ O $RefactoringFeedback$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $ExtractLocalVariableFeedback$ O $RefactoringFeedback$ O $any$ O $any$ O O O O $string$ O $ExtractLocalVariableFeedback$ O $ExtractLocalVariableFeedback$ O $string[]$ O $ExtractLocalVariableFeedback$ O $string[]$ O $number$ O $ExtractLocalVariableFeedback$ O $string[]$ O O O O O O O O $string$ O $string$ O $boolean$ O O O O O O O $Promise$ O $RefactoringFeedback$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $ExtractMethodFeedback$ O $RefactoringFeedback$ O $any$ O $any$ O O O O $string$ O $ExtractMethodFeedback$ O $ExtractMethodFeedback$ O $string[]$ O $ExtractMethodFeedback$ O $string[]$ O $number$ O $ExtractMethodFeedback$ O $string[]$ O O O O $undefined$ O O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O $string$ O O O O O O $any$ O O O O O $boolean$ O O O $boolean$ O O O $any$ O $RefactoringMethodParameter[]$ O $ExtractMethodFeedback$ O $ExtractMethodFeedback$ O $RefactoringMethodParameter[]$ O $string$ O $ExtractMethodFeedback$ O $ExtractMethodFeedback$ O $string$ O O O O O O $Promise$ O $RefactoringFeedback$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O O O O $any$ O O $any$ O O $undefined$ O O
import { escapeRegExp } from "s" ; export const iconUrlFormat = "s" ; const iconRegex = new RegExp ( `template` + escapeRegExp ( 's' ) + "s" + escapeRegExp ( 's' ) + "s" + escapeRegExp ( 's' ) + `template` , "s" , ) ; const dartDocDirectives = new RegExp ( `template` , "s" , ) ; const dartDocCodeBlockSections = new RegExp ( `template` , "s" , ) ; export function cleanDartdoc ( doc : string | undefined ) { if ( ! doc ) return "s" ; const index = doc . indexOf ( "s" ) ; if ( index !== - 0 ) doc = doc . substring ( 0 , index ) ; doc = doc . replace ( "s" , ( match ) => `template` ) ; doc = doc . replace ( iconRegex , `template` ) ; doc = doc . replace ( dartDocDirectives , "s" ) ; doc = doc . replace ( dartDocCodeBlockSections , "s" ) ; return doc ; } export function stripMarkdown ( doc ) { if ( ! doc ) return "s" ; doc = doc . replace ( "s" , "s" ) ; doc = doc . replace ( "s" , "s" ) ; return doc ; }	O O $string$ O O O O O O O O O O O $RegExp$ O O $RegExpConstructor$ O O O $string$ O O O O O O $string$ O O O O O O $string$ O O O O O O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O O O $string$ O $string$ O O O O O O O O O $string$ O O O O O $number$ O $string$ O $number$ O O O O O O $number$ O O O O $string$ O $string$ O $string$ O O O $number$ O O $string$ O $string$ O $complex$ O O O O $string$ O O O O O $string$ O $string$ O $complex$ O $RegExp$ O O O O $string$ O $string$ O $complex$ O $RegExp$ O O O O $string$ O $string$ O $complex$ O $RegExp$ O O O O O $string$ O O O O $string$ O $string$ O O O O O $string$ O O O O $string$ O $string$ O $complex$ O O O O O O $string$ O $string$ O $complex$ O O O O O O O $string$ O O
import { CancellationToken , Hover , HoverProvider , Position , Range , TextDocument , Uri } from "s" ; import * as as from "s" ; import { Logger } from "s" ; import { PackageMap } from "s" ; import { cleanDartdoc } from "s" ; import { fsPath } from "s" ; import { Analyzer } from "s" ; export class DartHoverProvider implements HoverProvider { constructor ( private readonly logger , private readonly analyzer ) { } public async provideHover ( document , position , token ) < Hover | undefined > { try { const resp = await this . analyzer . analysisGetHover ( { file : fsPath ( document . uri ) , offset : document . offsetAt ( position ) , } ) ; if ( token . isCancellationRequested || resp . hovers . length === 0 ) return ; const hover = resp . hovers [ 0 ] ; const data = this . getHoverData ( document . uri , hover ) ; if ( ! data ) return ; const range = new Range ( document . positionAt ( hover . offset ) , document . positionAt ( hover . offset + hover . length ) , ) ; return new Hover ( [ { language : "s" , value : data . displayString } , data . documentation || undefined ] , range . isSingleLine ? range : undefined , ) ; } catch ( e ) { this . logger . error ( e ) ; } } private getHoverData ( documentUri , hover : as . HoverInformation ) { if ( ! hover . elementDescription ) return undefined ; if ( hover . elementKind === "s" ) return undefined ; const elementDescription = hover . elementDescription ; const dartdoc : string | undefined = hover . dartdoc ; const propagatedType = hover . propagatedType ; let displayString = "s" ; if ( elementDescription ) displayString += ( hover . isDeprecated ? "s" : "s" ) + `template` ; if ( propagatedType ) displayString += `template` ; let documentation = cleanDartdoc ( dartdoc ) ; if ( this . analyzer . capabilities . hasNewHoverLibraryFormat ) { if ( hover . containingLibraryName ) documentation = `template` + documentation ; } else { const containingLibraryName = hover . containingLibraryName ; const containingLibraryPath = hover . containingLibraryPath ; if ( containingLibraryName ) { documentation = `template` + documentation ; } else if ( containingLibraryPath ) { const packageMap = DartHoverProvider . getPackageMapFor ( documentUri ) ; const packagePath = packageMap && packageMap . convertFileToPackageUri ( containingLibraryPath , false ) ; const packageName = packagePath && packagePath . split ( "s" ) [ 0 ] ; if ( packageName ) documentation = `template` + documentation ; } } return { displayString : displayString . trim ( ) , documentation : documentation . trim ( ) , } ; } private static packageMaps : { [ key ] : PackageMap } = { } ; private static getPackageMapFor ( uri ) : PackageMap | undefined { const path = fsPath ( uri ) ; if ( this . packageMaps [ path ] ) return this . packageMaps [ path ] ; const packagesFile = PackageMap . findPackagesFile ( path ) ; const map = packagesFile ? new PackageMap ( packagesFile ) : undefined ; if ( map ) this . packageMaps [ path ] = map ; return map ; } public static clearPackageMapCaches ( ) { this . packageMaps = { } ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $Logger$ O O O $Analyzer$ O O O O O $Promise$ O $TextDocument$ O $Position$ O $CancellationToken$ O O $any$ O O O O O O O $AnalysisGetHoverResponse$ O O O O $Analyzer$ O $Promise<AnalysisGetHoverResponse>$ O O $string$ O $string$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $AnalysisGetHoverResponse$ O $HoverInformation[]$ O $number$ O O O O O O $HoverInformation$ O $AnalysisGetHoverResponse$ O $HoverInformation[]$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $HoverInformation$ O O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $HoverInformation$ O $number$ O O $any$ O $any$ O $HoverInformation$ O $number$ O $HoverInformation$ O $number$ O O O O O O $any$ O O O $string$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $undefined$ O O O O O O $any$ O O O O $Logger$ O $void$ O $any$ O O O O O $any$ O $Uri$ O $HoverInformation$ O $any$ O $any$ O O O O O $HoverInformation$ O $string$ O O $undefined$ O O O $HoverInformation$ O $string$ O O O O $undefined$ O O $string$ O $HoverInformation$ O $string$ O O $string$ O O O O O $HoverInformation$ O $string$ O O $string$ O $HoverInformation$ O $string$ O O $string$ O O O O O $string$ O $string$ O O $HoverInformation$ O $boolean$ O O O O O O O O O O $string$ O $string$ O O O O $string$ O $string$ O $string$ O O O O O O $Analyzer$ O $AnalyzerCapabilities$ O $boolean$ O O O O $HoverInformation$ O $string$ O $string$ O O O $string$ O O O O O $string$ O $HoverInformation$ O $string$ O O $string$ O $HoverInformation$ O $string$ O O O $string$ O O $string$ O O O $string$ O O O O O $string$ O O O $PackageMap$ O $any$ O $PackageMap$ O $any$ O O O $string$ O $PackageMap$ O $PackageMap$ O $string$ O $string$ O O O O O $string$ O $string$ O $string$ O $complex$ O O O O O O O O O $string$ O $string$ O O O $string$ O O O O O $string$ O $string$ O $string$ O O O $string$ O $string$ O $string$ O O O O O O O O $complex$ O O O $string$ O O $any$ O O O O O O O $PackageMap$ O $Uri$ O O $any$ O O O O $string$ O $string$ O $any$ O O O O O O $complex$ O $string$ O O O O O $complex$ O $string$ O O O $string$ O $any$ O $complex$ O $string$ O O O $PackageMap$ O $string$ O O $any$ O $string$ O O $undefined$ O O O $PackageMap$ O O O $complex$ O $string$ O O $PackageMap$ O O $PackageMap$ O O O O $void$ O O O O O $complex$ O O O O O O
import * as http from "s" ; import * as https from "s" ; import * as url from "s" ; export function fetch ( urlString ) { const u = url . parse ( urlString ) ; if ( u . protocol === "s" ) return fetchHttps ( u . hostname , u . port , u . path ) ; else if ( u . protocol === "s" ) return fetchHttp ( u . hostname , u . port , u . path ) ; else throw new Error ( `template` ) ; } function fetchHttps ( hostname : string | undefined , port : string | undefined , path : string | undefined ) < string > { return new Promise < string > ( ( resolve , reject ) => { const options : https . RequestOptions = { hostname , method : "s" , path , port , } ; const req = https . request ( options , ( resp ) => { if ( ! resp || ! resp . statusCode || resp . statusCode < 0 || resp . statusCode > 0 ) { reject ( { message : `template` } ) ; } else { const chunks : string [ ] = [ ] ; resp . on ( "s" , ( b ) => chunks . push ( b . toString ( ) ) ) ; resp . on ( "s" , ( ) => { const data = chunks . join ( "s" ) ; resolve ( data ) ; } ) ; } } ) ; req . end ( ) ; } ) ; } function fetchHttp ( hostname : string | undefined , port : string | undefined , path : string | undefined ) < string > { return new Promise < string > ( ( resolve , reject ) => { const options : http . RequestOptions = { hostname , method : "s" , path , port , } ; const req = http . request ( options , ( resp ) => { if ( ! resp || ! resp . statusCode || resp . statusCode < 0 || resp . statusCode > 0 ) { reject ( { message : `template` } ) ; } else { const chunks : string [ ] = [ ] ; resp . on ( "s" , ( b ) => chunks . push ( b . toString ( ) ) ) ; resp . on ( "s" , ( ) => { const data = chunks . join ( "s" ) ; resolve ( data ) ; } ) ; } } ) ; req . end ( ) ; } ) ; }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $Promise<string>$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $any$ O O O O $Promise<string>$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $Promise<string>$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $ErrorConstructor$ O O O O O O $Promise$ O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O $any$ O $any$ O $any$ O O $string$ O $string$ O O O $string$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O O $string$ O O O O O O O O O $string[]$ O O O O O O O O $any$ O $any$ O O O O $any$ O O $string[]$ O $number$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $string$ O $string[]$ O $string$ O O O O $void$ O $string$ O O O O O O O O O $any$ O $any$ O O O O O O O O $Promise$ O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O $any$ O $any$ O $any$ O O $string$ O $string$ O O O $string$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O O $string$ O O O O O O O O O $string[]$ O O O O O O O O $any$ O $any$ O O O O $any$ O O $string[]$ O $number$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $string$ O $string[]$ O $string$ O O O O $void$ O $string$ O O O O O O O O O $any$ O $any$ O O O O O O O
import * as path from "s" ; import * as vs from "s" ; import { noRepeatPromptThreshold , pubGlobalDocsUrl , pubPath } from "s" ; import { LogCategory , VersionStatus } from "s" ; import { fetch } from "s" ; import { DartSdks , Logger } from "s" ; import { logProcess } from "s" ; import { versionIsAtLeast } from "s" ; import { Context } from "s" ; import { safeSpawn } from "s" ; import { envUtils } from "s" ; export class PubGlobal { constructor ( private readonly logger , private context , private sdks ) { } public async promptToInstallIfRequired ( packageName , packageID , moreInfoLink = pubGlobalDocsUrl , requiredVersion ? , autoUpdate = false ) < boolean > { const versionStatus = await this . getInstalledStatus ( packageName , packageID , requiredVersion ) ; if ( versionStatus === VersionStatus . Valid ) return true ; const moreInfo = "s" ; const activateForMe = versionStatus === VersionStatus . NotInstalled ? `template` : `template` ; const message = versionStatus === VersionStatus . NotInstalled ? `template` : ( versionStatus === VersionStatus . UpdateRequired ? `template` : `template` ) ; let action = ( versionStatus === VersionStatus . UpdateRequired || versionStatus === VersionStatus . UpdateAvailable ) && autoUpdate ? activateForMe : await vs . window . showWarningMessage ( message , activateForMe , moreInfo ) ; if ( action === moreInfo ) { await envUtils . openInBrowser ( moreInfoLink ) ; return false ; } else if ( action === activateForMe ) { const actionName = versionStatus === VersionStatus . NotInstalled ? `template` : `template` ; const args = [ "s" , "s" , packageID ] ; await this . runCommandWithProgress ( packageName , `template` , args ) ; if ( await this . getInstalledStatus ( packageName , packageID ) === VersionStatus . Valid ) { return true ; } else { action = await vs . window . showErrorMessage ( `template` , moreInfo ) ; if ( action === moreInfo ) { await envUtils . openInBrowser ( moreInfoLink ) ; } return false ; } } return false ; } public async uninstall ( packageID ) < void > { const args = [ "s" , "s" , packageID ] ; await this . runCommand ( packageID , args ) ; } public async getInstalledStatus ( packageName , packageID , requiredVersion ? ) < VersionStatus > { const output = await this . runCommand ( packageName , [ "s" , "s" ] ) ; const versionMatch = new RegExp ( `template` , "s" ) ; const match = versionMatch . exec ( output ) ; if ( ! match ) return VersionStatus . NotInstalled ; if ( requiredVersion && ! versionIsAtLeast ( match [ 0 ] , requiredVersion ) ) return VersionStatus . UpdateRequired ; const lastChecked = this . context . getPackageLastCheckedForUpdates ( packageID ) ; if ( ! lastChecked || lastChecked <= Date . now ( ) - noRepeatPromptThreshold ) { this . context . setPackageLastCheckedForUpdates ( packageID , Date . now ( ) ) ; try { const packageJson = JSON . parse ( await fetch ( `template` ) ) ; if ( ! versionIsAtLeast ( match [ 0 ] , packageJson . latest . version ) ) return VersionStatus . UpdateAvailable ; } catch ( e ) { this . logger . warn ( `template` , LogCategory . CommandProcesses ) ; return VersionStatus . Valid ; } } return VersionStatus . Valid ; } private runCommandWithProgress ( packageName , title , args : string [ ] ) < string > { return vs . window . withProgress ( { location : vs . ProgressLocation . Notification , title , } , ( _ ) => this . runCommand ( packageName , args ) ) ; } private runCommand ( packageName , args : string [ ] ) < string > { const dartSdkPath = this . sdks . dart ; const pubBinPath = path . join ( dartSdkPath , pubPath ) ; return new Promise ( ( resolve , reject ) => { const proc = safeSpawn ( undefined , pubBinPath , args ) ; logProcess ( this . logger , LogCategory . CommandProcesses , proc ) ; const stdout : string [ ] = [ ] ; const stderr : string [ ] = [ ] ; proc . stdout . on ( "s" , ( data ) => stdout . push ( data . toString ( ) ) ) ; proc . stderr . on ( "s" , ( data ) => stderr . push ( data . toString ( ) ) ) ; proc . on ( "s" , ( code ) => { if ( ! code ) { resolve ( stdout . join ( "s" ) ) ; } else { reject ( `template` ) ; } } ) ; } ) ; } }	O O O $any$ O O O O O O $any$ O O O O O $number$ O O O $string$ O O O O O O $any$ O $any$ O O O O O O $Promise<string>$ O O O O O O $any$ O $any$ O O O O O O $void$ O O O O O O $boolean$ O O O O O O $any$ O O O O O O $any$ O O O O O O $EnvUtils$ O O O O O O $any$ O O O O O $Logger$ O O $Context$ O O $DartSdks$ O O O O O $Promise$ O $string$ O $string$ O $string$ O O O $string$ $string$ O $boolean$ O O O O O O O O $VersionStatus$ O O O O $Promise<VersionStatus>$ O $string$ O $string$ O $string$ O O O O $VersionStatus$ O $any$ O $VersionStatus.Valid$ O O O O O O O O O O $string$ O $complex$ O $any$ O $VersionStatus.NotInstalled$ O O O O O O $string$ O $complex$ O $any$ O $VersionStatus.NotInstalled$ O O O O $complex$ O $any$ O $VersionStatus.UpdateRequired$ O O O O O O O $any$ O O $complex$ O $any$ O $VersionStatus.UpdateRequired$ O $complex$ O $any$ O $VersionStatus.UpdateAvailable$ O O $boolean$ O $string$ O O $any$ O $any$ O $any$ O $string$ O $string$ O O O O O O $any$ O O O O O $EnvUtils$ O $Promise<boolean>$ O $string$ O O O O O O O O O $any$ O $string$ O O O $string$ O $complex$ O $any$ O $VersionStatus.NotInstalled$ O O O O O O $string[]$ O O O O O O $string$ O O O O O $any$ O $string$ O O O $string[]$ O O O O O O O $Promise<VersionStatus>$ O $string$ O $string$ O O $any$ O $VersionStatus.Valid$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $EnvUtils$ O $Promise<boolean>$ O $string$ O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O $string[]$ O O O O O O $string$ O O O O O $any$ O $string$ O $string[]$ O O O O O $Promise$ O $string$ O $string$ O $string$ $string$ O O $any$ O O O $any$ O O O O $any$ O $string$ O O O O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $any$ O O O O O $RegExpExecArray$ O O $any$ O $VersionStatus.NotInstalled$ O O O $string$ O O $boolean$ O $RegExpExecArray$ O O O O $string$ O O O $any$ O $VersionStatus.UpdateRequired$ O O $number$ O O O $Context$ O $number$ O $string$ O O O O O $number$ O $number$ O $DateConstructor$ O $number$ O O O $number$ O O O O $Context$ O $void$ O $string$ O $DateConstructor$ O $number$ O O O O O O O $any$ O $JSON$ O $any$ O O $Promise<string>$ O O O O O O O O $boolean$ O $RegExpExecArray$ O O O O $any$ O $any$ O $any$ O O O $any$ O $VersionStatus.UpdateAvailable$ O O O O $any$ O O O O $Logger$ O $void$ O O O $any$ O $LogCategory.CommandProcesses$ O O O $any$ O $VersionStatus.Valid$ O O O O $any$ O $VersionStatus.Valid$ O O O $Thenable$ O $string$ O $string$ O $string[]$ O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O $any$ O O O O $any$ O $string$ O $string[]$ O O O O O $Thenable$ O $string$ O $string[]$ O O O O O O O O O O $string$ O O O $DartSdks$ O $string$ O O $any$ O $any$ O $any$ O $string$ O $string$ O O O O $PromiseConstructor$ O O $void$ O $void$ O O O O $any$ O $any$ O $undefined$ O $any$ O $string[]$ O O $void$ O O O $Logger$ O $any$ O $LogCategory.CommandProcesses$ O $any$ O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $string[]$ O $number$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $string[]$ O $number$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O O $void$ O $string[]$ O $string$ O O O O O O O O $void$ O O O O O O O O O O O O O
import * as fs from "s" ; import * as path from "s" ; import { commands , Uri , window } from "s" ; import { fsPath } from "s" ; export function isPubGetProbablyRequired ( folderUri ) { const folder = fsPath ( folderUri ) ; const pubspecPath = path . join ( folder , "s" ) ; const packagesPath = path . join ( folder , "s" ) ; if ( ! folder || ! fs . existsSync ( pubspecPath ) ) return false ; const regex = new RegExp ( "s" , "s" ) ; if ( ! regex . test ( fs . readFileSync ( pubspecPath ) . toString ( ) ) ) return false ; if ( ! fs . existsSync ( packagesPath ) ) return true ; const pubspecModified = fs . statSync ( pubspecPath ) . mtime ; const packagesModified = fs . statSync ( packagesPath ) . mtime ; return pubspecModified > packagesModified ; } export function promptToRunPubGet ( folders : Uri [ ] ) { const label = "s" ; window . showInformationMessage ( "s" , label ) . then ( ( clickedButton ) => { if ( clickedButton === label ) getPackages ( folders ) ; } ) ; } function getPackages ( folders : Uri [ ] ) { let task = commands . executeCommand ( "s" , folders [ 0 ] ) ; for ( let i = 0 ; i < folders . length ; i ++ ) { task = task . then ( ( code ) => { if ( code === 0 ) return commands . executeCommand ( "s" , folders [ i ] ) ; } ) ; } }	O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O O O O $boolean$ O $Uri$ O O O $string$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $string$ O O O O O O O $string$ O O $any$ O $any$ O $any$ O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O O O $RegExp$ O $boolean$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O $void$ O $any[]$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O O $any$ O O O $void$ O $any[]$ O O O O O O O $void$ O $any[]$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any[]$ O O O O O O O O $number$ O O O $number$ O $any[]$ O $number$ O $number$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O $any[]$ O $number$ O O O O O O O O
import * as path from "s" ; import * as vs from "s" ; import { pubPath , stagehandInstallationInstructionsUrl } from "s" ; import { LogCategory } from "s" ; import { DartSdks , Logger , StagehandTemplate } from "s" ; import { logProcess } from "s" ; import { safeSpawn } from "s" ; import { PubGlobal } from "s" ; const packageName = "s" ; const packageID = "s" ; export class Stagehand { constructor ( private logger , private sdks , private pubGlobal ) { } public promptToInstallIfRequired ( ) { return this . pubGlobal . promptToInstallIfRequired ( packageName , packageID , stagehandInstallationInstructionsUrl , "s" ) ; } public async getTemplates ( ) < StagehandTemplate [ ] > { const json = await this . getTemplateJson ( ) ; return JSON . parse ( json ) ; } private async getTemplateJson ( ) < string > { return this . runCommandWithProgress ( "s" , [ "s" , "s" , "s" , "s" ] ) ; } private runCommandWithProgress ( title , args : string [ ] ) < string > { return vs . window . withProgress ( { location : vs . ProgressLocation . Notification , title , } , ( _ ) => this . runCommand ( args ) ) ; } private runCommand ( args : string [ ] ) < string > { const dartSdkPath = this . sdks . dart ; const pubBinPath = path . join ( dartSdkPath , pubPath ) ; return new Promise ( ( resolve , reject ) => { const proc = safeSpawn ( undefined , pubBinPath , args ) ; logProcess ( this . logger , LogCategory . CommandProcesses , proc ) ; const stdout : string [ ] = [ ] ; const stderr : string [ ] = [ ] ; proc . stdout . on ( "s" , ( data ) => stdout . push ( data . toString ( ) ) ) ; proc . stderr . on ( "s" , ( data ) => stderr . push ( data . toString ( ) ) ) ; proc . on ( "s" , ( code ) => { if ( ! code ) { resolve ( stdout . join ( "s" ) ) ; } else { reject ( `template` ) ; } } ) ; } ) ; } }	O O O $any$ O O O O O O $any$ O O O O O $string$ O O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O $any$ O O O O $Logger$ O O $DartSdks$ O O $PubGlobal$ O O O O $Promise<boolean>$ O O O O O O $PubGlobal$ O $Promise<boolean>$ O O O O O O O O O O O O O $Promise$ O O O $any$ O O O O O $string$ O O O O $Promise<string>$ O O O O $JSON$ O $any$ O $string$ O O O O O $Promise$ O O O O O O O O O $any$ O O O O O O O O O O O O O O O O $Thenable$ O $string$ O $string[]$ O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O $any$ O O O O $any$ O $string[]$ O O O O O $Thenable$ O $string[]$ O O O O O O O O O O $string$ O O O $DartSdks$ O $string$ O O $any$ O $any$ O $any$ O $string$ O $string$ O O O O $PromiseConstructor$ O O $void$ O $void$ O O O O $any$ O $any$ O $undefined$ O $any$ O $string[]$ O O $void$ O O O $Logger$ O $any$ O $LogCategory.CommandProcesses$ O $any$ O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $string[]$ O $number$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $string[]$ O $number$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O O $void$ O $string[]$ O $string$ O O O O O O O O $void$ O O O O O O O O O O O O O
import * as fs from "s" ; import * as https from "s" ; import * as os from "s" ; import * as path from "s" ; import { FlutterCapabilities } from "s" ; import { flutterPath } from "s" ; import { Logger , Sdks } from "s" ; import { getRandomInt , tryDeleteFile } from "s" ; import { FlutterSampleSnippet } from "s" ; import { runProcess } from "s" ; export function getFlutterSnippets ( logger , sdks , capabilities ) < FlutterSampleSnippet [ ] > { if ( capabilities . supportsFlutterCreateListSamples ) return getFlutterSnippetsFromSdk ( logger , sdks ) ; return getFlutterSnippetsFromWeb ( ) ; } async function getFlutterSnippetsFromSdk ( logger , sdks ) < FlutterSampleSnippet [ ] > { if ( ! sdks . flutter ) throw new Error ( "s" ) ; const binPath = path . join ( sdks . flutter , flutterPath ) ; const fileName = `template` ; const tempPath = path . join ( os . tmpdir ( ) , fileName ) ; try { const res = await runProcess ( logger , undefined , binPath , [ "s" , "s" , tempPath ] ) ; if ( res . exitCode !== 0 ) throw new Error ( `template` ) ; const json = fs . readFileSync ( tempPath , { encoding : "s" } ) ; return JSON . parse ( json ) ; } finally { tryDeleteFile ( tempPath ) ; } } function getFlutterSnippetsFromWeb ( ) < FlutterSampleSnippet [ ] > { return new Promise < FlutterSampleSnippet [ ] > ( ( resolve , reject ) => { const options : https . RequestOptions = { hostname : "s" , method : "s" , path : "s" , port : 0 , } ; const req = https . request ( options , ( resp ) => { if ( ! resp || ! resp . statusCode || resp . statusCode < 0 || resp . statusCode > 0 ) { reject ( { message : `template` } ) ; } else { const chunks : string [ ] = [ ] ; resp . on ( "s" , ( b ) => chunks . push ( b . toString ( ) ) ) ; resp . on ( "s" , ( ) => { const json = chunks . join ( "s" ) ; resolve ( JSON . parse ( json ) ) ; } ) ; } } ) ; req . end ( ) ; } ) ; }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O $any$ O O O O O O $number$ O $void$ O O O O O O $any$ O O O O O O $Promise<RunProcessResult>$ O O O O O O $Promise$ O $Logger$ O $Sdks$ O $FlutterCapabilities$ O O $any$ O O O O O O $FlutterCapabilities$ O $boolean$ O O $Promise<FlutterSampleSnippet[]>$ O $Logger$ O $Sdks$ O O O $Promise<FlutterSampleSnippet[]>$ O O O O O O $Promise$ O $Logger$ O $Sdks$ O O $any$ O O O O O O O $Sdks$ O $string$ O O O $ErrorConstructor$ O O O O O $any$ O $any$ O $any$ O $Sdks$ O $string$ O $string$ O O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O $RunProcessResult$ O O $Promise<RunProcessResult>$ O $Logger$ O $undefined$ O $any$ O O O O O O $any$ O O O O O $RunProcessResult$ O $number$ O O O O O $ErrorConstructor$ O O O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O O $JSON$ O $any$ O $any$ O O O O O $void$ O $any$ O O O O O $Promise$ O O O $any$ O O O O O O $PromiseConstructor$ O $any$ O O O O O $void$ O $void$ O O O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O O $string$ O O O O O O O O O $string[]$ O O O O O O O O $any$ O $any$ O O O O $any$ O O $string[]$ O $number$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $string$ O $string[]$ O $string$ O O O O $void$ O $JSON$ O $any$ O $string$ O O O O O O O O O O $any$ O $any$ O O O O O O O
import * as fs from "s" ; import * as path from "s" ; import * as vs from "s" ; import { dartVMPath , flutterPath } from "s" ; import { Logger , Sdks } from "s" ; import { versionIsAtLeast } from "s" ; import { getChildFolders } from "s" ; import { config } from "s" ; import { getSdkVersion } from "s" ; abstract class SdkManager { constructor ( private readonly logger , protected readonly sdks ) { } protected abstract get sdkPaths ( ) : string [ ] ; protected abstract get currentSdk ( ) : string | undefined ; protected abstract get configuredSdk ( ) : string | undefined ; protected abstract get configName ( ) : string ; protected abstract get executablePath ( ) : string ; protected abstract getLabel ( version ) ; protected abstract setSdk ( folder : string | undefined ) ; public changeSdk ( ) { if ( this . sdkPaths ) this . searchForSdks ( this . sdkPaths ) ; else vs . window . showWarningMessage ( "s" ) ; } public async searchForSdks ( sdkPaths : string [ ] ) { let allPaths : string [ ] = [ ] ; for ( const sdkPath of sdkPaths . filter ( fs . existsSync ) ) { allPaths . push ( sdkPath ) ; allPaths = allPaths . concat ( await getChildFolders ( sdkPath ) ) ; } if ( this . currentSdk && allPaths . indexOf ( this . currentSdk ) === - 0 ) allPaths . push ( this . currentSdk ) ; const sdkFolders = allPaths . filter ( ( f ) => fs . existsSync ( path . join ( f , this . executablePath ) ) ) ; const sdkItems : SdkPickItem [ ] = sdkFolders . map ( ( f ) => { const actualBinary = fs . realpathSync ( path . join ( f , this . executablePath ) ) ; const actualFolder = path . dirname ( path . dirname ( actualBinary ) ) ; const version = getSdkVersion ( this . logger , actualFolder ) ; return { description : f === this . currentSdk && this . configuredSdk ? "s" : "s" , detail : f , folder : f , label : version ? this . getLabel ( version ) : "s" , version , } ; } ) . sort ( ( a , b ) => versionIsAtLeast ( a . version || "s" , b . version || "s" ) ? 0 : - 0 ) ; if ( sdkItems . length === 0 ) return ; const items = [ { description : ! this . configuredSdk ? "s" : "s" , detail : ! this . configuredSdk ? `template` : undefined , folder : undefined , label : "s" , version : undefined , } as SdkPickItem ] . concat ( sdkItems ) ; vs . window . showQuickPick ( items , { placeHolder : "s" } ) . then ( ( sdk ) => { if ( sdk ) this . setSdk ( sdk . folder ) ; } ) ; } } export class DartSdkManager extends SdkManager { protected get sdkPaths ( ) : string [ ] { return config . sdkPaths ; } protected get currentSdk ( ) : string | undefined { return this . sdks . dart ; } protected get configuredSdk ( ) : string | undefined { return config . sdkPath ; } protected get configName ( ) : string { return "s" ; } protected get executablePath ( ) { return dartVMPath ; } protected getLabel ( version ) { return `template` ; } protected setSdk ( folder : string | undefined ) { config . setSdkPath ( folder ) ; } } export class FlutterSdkManager extends SdkManager { protected get sdkPaths ( ) : string [ ] { return config . flutterSdkPaths ; } protected get currentSdk ( ) : string | undefined { return this . sdks . flutter ; } protected get configuredSdk ( ) : string | undefined { return config . flutterSdkPath ; } protected get configName ( ) : string { return "s" ; } protected get executablePath ( ) { return flutterPath ; } protected getLabel ( version ) { return `template` ; } protected setSdk ( folder : string | undefined ) { config . setFlutterSdkPath ( folder ) ; } } interface SdkPickItem { description : string ; detail : string | undefined ; folder : string | undefined ; label : string ; version : string | undefined ; }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O $string$ O O O O O O $any$ O $any$ O O O O O O $boolean$ O O O O O O $Promise<string[]>$ O O O O O O $Config$ O O O O O O $string$ O O O O O O $any$ O O O O O $Logger$ O O O $Sdks$ O O O O O O $string[]$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O $string$ O $string$ O O O O $void$ O $string$ O O O O O O O $void$ O O O O O O O $string[]$ O O O $Promise<void>$ O O O $string[]$ O O O $any$ O $any$ O $any$ O O O O O O O $Promise<void>$ O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O $string$ O $string[]$ O $complex$ O $any$ O $any$ O O O $string[]$ O $number$ O $string$ O O $string[]$ O $string[]$ O $complex$ O O $Promise<string[]>$ O $string$ O O O O O O O O $string$ O $string[]$ O $number$ O O O $string$ O O O O O $string[]$ O $number$ O O O $string$ O O O $string[]$ O $string[]$ O $complex$ O O $string$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O O O $SdkPickItem[]$ O $any$ O O O $string[]$ O $U[]$ O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $string$ O O O $Logger$ O $any$ O O O O $string$ O $string$ O O O $string$ O O O $string$ O O O O O $string$ O $string$ O $string$ O $string$ O $string$ O $string$ O O O $string$ O $string$ O O O O $string$ O O O O O O $complex$ O O $complex$ O $complex$ O O $boolean$ O $complex$ O $string$ O O O $complex$ O $string$ O O O O O O O O O O O O $SdkPickItem[]$ O $number$ O O O O O O $SdkPickItem[]$ O O O $string$ O O O O $string$ O O O O O $string$ O O O O $string$ O O O $undefined$ O $undefined$ O $undefined$ O $string$ O O O $undefined$ O $undefined$ O O O $any$ O O $complex$ O $SdkPickItem[]$ O O $any$ O $any$ O $any$ O $SdkPickItem[]$ O O $string$ O O O O O $any$ O O $any$ O O O O O $any$ O O O $void$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O $string[]$ O O O O O O O O $Config$ O $string[]$ O O O O $string$ O O O O O O O O O O $Sdks$ O $string$ O O O O $string$ O O O O O O O O $Config$ O $string$ O O O O $string$ O O O O O O O O O O O $string$ O O O O $string$ O O O $string$ O $string$ O O O O O O O $void$ O $string$ O O O O O O $Config$ O $any$ O $string$ O O O O O O $any$ O $any$ O O O $string[]$ O O O O O O O O $Config$ O $string[]$ O O O O $string$ O O O O O O O O O O $Sdks$ O $string$ O O O O $string$ O O O O O O O O $Config$ O $string$ O O O O $string$ O O O O O O O O O O O $string$ O O O O $string$ O O O $string$ O $string$ O O O O O O O $void$ O $string$ O O O O O O $Config$ O $any$ O $string$ O O O O O $any$ O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O $string$ O O O O O O
import * as child_process from "s" ; import * as fs from "s" ; import * as os from "s" ; import * as path from "s" ; import * as vs from "s" ; import { ProgressLocation , Uri , window } from "s" ; import { FlutterCapabilities } from "s" ; import { DART_STAGEHAND_PROJECT_TRIGGER_FILE , flutterPath , FLUTTER_CREATE_PROJECT_TRIGGER_FILE , pubPath } from "s" ; import { LogCategory } from "s" ; import { DartSdks , DartWorkspaceContext , Logger , StagehandTemplate } from "s" ; import { logProcess } from "s" ; import { PromiseCompleter , uniq } from "s" ; import { sortBy } from "s" ; import { stripMarkdown } from "s" ; import { findProjectFolders , mkDirRecursive } from "s" ; import { writeDartSdkSettingIntoProject , writeFlutterSdkSettingIntoProject } from "s" ; import { FlutterDeviceManager } from "s" ; import { createFlutterSampleInTempFolder } from "s" ; import { FlutterSampleSnippet } from "s" ; import { fsPath , getDartWorkspaceFolders } from "s" ; import { config } from "s" ; import { locateBestProjectRoot } from "s" ; import { DartHoverProvider } from "s" ; import { PubGlobal } from "s" ; import { isPubGetProbablyRequired , promptToRunPubGet } from "s" ; import { Stagehand } from "s" ; import { getFlutterSnippets } from "s" ; import { DartSdkManager , FlutterSdkManager } from "s" ; import { SdkUtils } from "s" ; import * as util from "s" ; import { globalFlutterArgs , safeSpawn } from "s" ; import * as channels from "s" ; const packageNameRegex = new RegExp ( "s" ) ; let isFetchingPackages = false ; let runPubGetDelayTimer : NodeJS . Timer | undefined ; let lastPubspecSaveReason : vs . TextDocumentSaveReason | undefined ; let numProjectCreationsInProgress = 0 ; export class SdkCommands { private readonly sdks : DartSdks ; private flutterScreenshotPath ? : string ; private runningCommands : { [ workspaceUriAndCommand ] : ChainedProcess | undefined ; } = { } ; constructor ( private readonly logger , readonly context : vs . ExtensionContext , private readonly workspace , private readonly sdkUtils , private readonly pubGlobal , private readonly flutterCapabilities , private readonly deviceManager ) { this . sdks = workspace . sdks ; const dartSdkManager = new DartSdkManager ( this . logger , this . workspace . sdks ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => dartSdkManager . changeSdk ( ) ) ) ; if ( workspace . hasAnyFlutterProjects ) { const flutterSdkManager = new FlutterSdkManager ( this . logger , workspace . sdks ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => flutterSdkManager . changeSdk ( ) ) ) ; } context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( uri : string | Uri | undefined ) => { if ( ! uri || ! ( uri instanceof Uri ) ) { uri = await this . getFolderToRunCommandIn ( "s" ) ; if ( ! uri ) return ; } if ( typeof uri === "s" ) uri = vs . Uri . file ( uri ) ; try { if ( util . isInsideFlutterProject ( uri ) ) return this . runFlutter ( [ "s" , "s" ] , uri ) ; else return this . runPub ( [ "s" ] , uri ) ; } finally { DartHoverProvider . clearPackageMapCaches ( ) ; } } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( uri : string | Uri | undefined ) => { if ( ! uri || ! ( uri instanceof Uri ) ) uri = await this . getFolderToRunCommandIn ( "s" ) ; if ( typeof uri === "s" ) uri = vs . Uri . file ( uri ) ; if ( util . isInsideFlutterProject ( uri ) ) return this . runFlutter ( [ "s" , "s" ] , uri ) ; else return this . runPub ( [ "s" ] , uri ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( selection ) => { return vs . commands . executeCommand ( "s" , selection ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( selection ) => { return vs . commands . executeCommand ( "s" , selection ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( selection ) : Promise < number | undefined > => { if ( ! selection ) { const path = await this . getFolderToRunCommandIn ( `template` , selection ) ; if ( ! path ) return ; selection = vs . Uri . file ( path ) ; } if ( selection && fsPath ( selection ) === workspace . sdks . flutter ) { return this . runFlutter ( [ "s" ] , selection ) ; } try { return this . runFlutter ( [ "s" , "s" ] , selection ) ; } finally { DartHoverProvider . clearPackageMapCaches ( ) ; } } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( selection ) : Promise < number | undefined > => { if ( ! selection ) { const path = await this . getFolderToRunCommandIn ( `template` , selection , true ) ; if ( ! path ) return ; selection = vs . Uri . file ( path ) ; } return this . runFlutter ( [ "s" ] , selection ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( args ) => vs . commands . executeCommand ( "s" , args ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( ) => { let shouldNotify = false ; if ( ! this . flutterScreenshotPath || ( config . flutterScreenshotPath && this . flutterScreenshotPath !== config . flutterScreenshotPath ) ) { this . flutterScreenshotPath = config . flutterScreenshotPath ; shouldNotify = true ; } if ( ! this . flutterScreenshotPath ) { const selectedFolder = await window . showOpenDialog ( { canSelectFolders : true , openLabel : "s" } ) ; if ( selectedFolder && selectedFolder . length > 0 ) { this . flutterScreenshotPath = selectedFolder [ 0 ] . path ; shouldNotify = true ; } else { return ; } } mkDirRecursive ( this . flutterScreenshotPath ) ; const deviceId = this . deviceManager && this . deviceManager . currentDevice ? this . deviceManager . currentDevice . id : undefined ; const args = deviceId ? [ "s" , "s" , deviceId ] : [ "s" ] ; await this . runFlutterInFolder ( this . flutterScreenshotPath , args , "s" ) ; if ( shouldNotify ) { const res = await vs . window . showInformationMessage ( `template` , "s" ) ; if ( res ) await vs . commands . executeCommand ( "s" , Uri . file ( this . flutterScreenshotPath ) ) ; } } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( selection ) => { return vs . commands . executeCommand ( "s" , selection ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( selection ) => { if ( ! workspace . sdks . flutter ) { this . sdkUtils . showFlutterActivationFailure ( "s" ) ; return ; } const tempDir = path . join ( os . tmpdir ( ) , "s" ) ; if ( ! fs . existsSync ( tempDir ) ) fs . mkdirSync ( tempDir ) ; return this . runFlutterInFolder ( tempDir , [ "s" , "s" ] , "s" ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( selection ) => { if ( ! workspace . sdks . flutter ) { this . sdkUtils . showFlutterActivationFailure ( "s" ) ; return ; } const tempDir = path . join ( os . tmpdir ( ) , "s" ) ; if ( ! fs . existsSync ( tempDir ) ) fs . mkdirSync ( tempDir ) ; await this . runFlutterInFolder ( tempDir , [ "s" ] , "s" ) ; await util . reloadExtension ( ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( _ ) => this . createFlutterProject ( ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( _ ) => this . createFlutterSampleProject ( ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( _ ) => this . createDartProject ( ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( projectPath , templateName ) => { const args = [ "s" , "s" , "s" , templateName ] ; return this . runPubInFolder ( projectPath , args , templateName ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( projectPath , projectName ? , sampleID ? ) => { const args = [ "s" ] ; if ( projectName ) { args . push ( "s" ) ; args . push ( projectName ) ; } if ( config . flutterCreateOrganization ) { args . push ( "s" ) ; args . push ( config . flutterCreateOrganization ) ; } if ( config . flutterCreateIOSLanguage ) { args . push ( "s" ) ; args . push ( config . flutterCreateIOSLanguage ) ; } if ( config . flutterCreateAndroidLanguage ) { args . push ( "s" ) ; args . push ( config . flutterCreateAndroidLanguage ) ; } if ( config . flutterAndroidX ) { args . push ( "s" ) ; } if ( sampleID ) { args . push ( "s" ) ; args . push ( sampleID ) ; args . push ( "s" ) ; } args . push ( "s" ) ; return this . runFlutterInFolder ( projectPath , args , projectName ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( projectPath , projectName ? ) => { projectName = projectName || path . basename ( projectPath ) ; const args = [ "s" ] ; return this . runFlutterInFolder ( projectPath , args , projectName ) ; } ) ) ; this . setupPubspecWatcher ( context ) ; } private setupPubspecWatcher ( context : vs . ExtensionContext ) { context . subscriptions . push ( vs . workspace . onWillSaveTextDocument ( ( e ) => { if ( path . basename ( fsPath ( e . document . uri ) ) . toLowerCase ( ) === "s" ) lastPubspecSaveReason = e . reason ; } ) ) ; const watcher = vs . workspace . createFileSystemWatcher ( "s" ) ; context . subscriptions . push ( watcher ) ; watcher . onDidChange ( this . handlePubspecChange , this ) ; watcher . onDidCreate ( this . handlePubspecChange , this ) ; } private handlePubspecChange ( uri : vs . Uri ) { const conf = config . for ( uri ) ; if ( ! conf . runPubGetOnPubspecChanges ) return ; if ( fsPath ( uri ) . indexOf ( `template` ) !== - 0 ) return ; if ( numProjectCreationsInProgress > 0 ) { this . logger . info ( "s" ) ; return ; } if ( this . workspace . shouldAvoidFetchingPackages && ! conf . runPubGetOnPubspecChangesIsConfiguredExplicitly ) return ; if ( runPubGetDelayTimer ) { clearTimeout ( runPubGetDelayTimer ) ; } const debounceDuration = lastPubspecSaveReason === vs . TextDocumentSaveReason . FocusOut || lastPubspecSaveReason === vs . TextDocumentSaveReason . AfterDelay ? 0 : 0 ; runPubGetDelayTimer = setTimeout ( ( ) => { runPubGetDelayTimer = undefined ; lastPubspecSaveReason = undefined ; this . fetchPackagesOrPrompt ( uri ) ; } , debounceDuration ) ; } public async fetchPackagesOrPrompt ( uri : vs . Uri | undefined , options ? : { alwaysPrompt ? : boolean } ) < void > { if ( isFetchingPackages ) return ; isFetchingPackages = true ; const forcePrompt = options && options . alwaysPrompt ; const topLevelFolders = getDartWorkspaceFolders ( ) . map ( ( wf ) => fsPath ( wf . uri ) ) ; const folders = await findProjectFolders ( topLevelFolders , { requirePubspec : true } ) ; const foldersRequiringPackageGet = uniq ( folders ) . map ( vs . Uri . file ) . filter ( ( uri ) => config . for ( uri ) . promptToGetPackages ) . filter ( isPubGetProbablyRequired ) ; if ( ! forcePrompt && foldersRequiringPackageGet . length === 0 ) await vs . commands . executeCommand ( "s" , uri ) ; else if ( ! forcePrompt && foldersRequiringPackageGet . length === 0 ) await vs . commands . executeCommand ( "s" , foldersRequiringPackageGet [ 0 ] ) ; else if ( foldersRequiringPackageGet . length ) promptToRunPubGet ( foldersRequiringPackageGet ) ; isFetchingPackages = false ; } private async runCommandForWorkspace ( handler : ( folder , args : string [ ] , shortPath ) => Thenable < number | undefined > , placeHolder , args : string [ ] , selection ? : vs . Uri , ) < number | undefined > { const folderToRunCommandIn = await this . getFolderToRunCommandIn ( placeHolder , selection ) ; if ( ! folderToRunCommandIn ) return ; const containingWorkspace = vs . workspace . getWorkspaceFolder ( vs . Uri . file ( folderToRunCommandIn ) ) ; if ( ! containingWorkspace ) { this . logger . error ( `template` ) ; throw new Error ( `template` ) ; } const containingWorkspacePath = fsPath ( containingWorkspace . uri ) ; const shortPath = path . relative ( containingWorkspacePath , folderToRunCommandIn ) || path . basename ( folderToRunCommandIn ) ; return handler ( folderToRunCommandIn , args , shortPath ) ; } private async getFolderToRunCommandIn ( placeHolder , selection ? : vs . Uri , flutterOnly = false ) < string | undefined > { let file = selection && fsPath ( selection ) ; file = file || ( vs . window . activeTextEditor && fsPath ( vs . window . activeTextEditor . document . uri ) ) ; const folder = file && locateBestProjectRoot ( file ) ; if ( folder ) return folder ; const topLevelFolders = getDartWorkspaceFolders ( ) . map ( ( wf ) => fsPath ( wf . uri ) ) ; const selectableFolders = ( await findProjectFolders ( topLevelFolders , { sort : true } ) ) . filter ( flutterOnly ? util . isFlutterProjectFolder : ( ) => true ) ; if ( ! selectableFolders || ! selectableFolders . length ) { const projectTypes = flutterOnly ? "s" : "s" ; vs . window . showWarningMessage ( `template` ) ; return undefined ; } return this . showFolderPicker ( selectableFolders , placeHolder ) ; } private async showFolderPicker ( folders : string [ ] , placeHolder ) < string | undefined > { if ( folders . length === 0 ) { return folders [ 0 ] ; } const items = folders . map ( ( f ) => { const workspaceFolder = vs . workspace . getWorkspaceFolder ( Uri . file ( f ) ) ; if ( ! workspaceFolder ) return undefined ; const workspacePathParent = path . dirname ( fsPath ( workspaceFolder . uri ) ) ; return { description : util . homeRelativePath ( workspacePathParent ) , label : path . relative ( workspacePathParent , f ) , path : f , } as vs . QuickPickItem & { path : string } ; } ) . filter ( util . notUndefined ) ; const selectedFolder = await vs . window . showQuickPick ( items , { placeHolder } ) ; return selectedFolder && selectedFolder . path ; } private runFlutter ( args : string [ ] , selection ? : vs . Uri ) < number | undefined > { return this . runCommandForWorkspace ( this . runFlutterInFolder . bind ( this ) , `template` , args , selection ) ; } private runFlutterInFolder ( folder , args : string [ ] , shortPath : string | undefined ) < number | undefined > { if ( ! this . sdks . flutter ) throw new Error ( "s" ) ; const binPath = path . join ( this . sdks . flutter , flutterPath ) ; args = globalFlutterArgs . concat ( config . for ( vs . Uri . file ( folder ) ) . flutterAdditionalArgs ) . concat ( args ) ; return this . runCommandInFolder ( shortPath , "s" , folder , binPath , args ) ; } private runPub ( args : string [ ] , selection ? : vs . Uri ) < number | undefined > { return this . runCommandForWorkspace ( this . runPubInFolder . bind ( this ) , `template` , args , selection ) ; } private runPubInFolder ( folder , args : string [ ] , shortPath ) < number | undefined > { if ( ! this . sdks . dart ) throw new Error ( "s" ) ; const binPath = path . join ( this . sdks . dart , pubPath ) ; args = args . concat ( ... config . for ( vs . Uri . file ( folder ) ) . pubAdditionalArgs ) ; return this . runCommandInFolder ( shortPath , "s" , folder , binPath , args ) ; } private runCommandInFolder ( shortPath : string | undefined , commandName , folder , binPath , args : string [ ] , isStartingBecauseOfTermination = false ) < number | undefined > { shortPath = shortPath || path . basename ( folder ) ; const channelName = commandName . substr ( 0 , 0 ) . toUpperCase ( ) + commandName . substr ( 0 ) ; const channel = channels . createChannel ( channelName ) ; channel . show ( true ) ; const commandId = `template` ; const existingProcess = this . runningCommands [ commandId ] ; if ( existingProcess && ! existingProcess . hasStarted ) { return Promise . resolve ( undefined ) ; } return vs . window . withProgress ( { cancellable : true , location : ProgressLocation . Notification , title : `template` , } , ( progress , token ) => { if ( existingProcess ) { progress . report ( { message : "s" } ) ; existingProcess . cancel ( ) ; } else { channel . clear ( ) ; } const process = new ChainedProcess ( ( ) => { channel . appendLine ( `template` ) ; progress . report ( { message : "s" } ) ; const proc = safeSpawn ( folder , binPath , args ) ; channels . runProcessInChannel ( proc , channel ) ; this . logger . info ( `template` , LogCategory . CommandProcesses ) ; logProcess ( this . logger , LogCategory . CommandProcesses , proc ) ; return proc ; } , existingProcess ) ; this . runningCommands [ commandId ] = process ; token . onCancellationRequested ( ( ) => process . cancel ( ) ) ; return process . completed ; } ) ; } private async createDartProject ( ) < void > { return this . createStagehandProject ( "s" , DART_STAGEHAND_PROJECT_TRIGGER_FILE , false ) ; } private async createStagehandProject ( command , triggerFilename , autoPickIfSingleItem , filter ? : ( t ) => boolean ) < void > { if ( ! this . sdks || ! this . sdks . dart ) { this . sdkUtils . showDartActivationFailure ( command ) ; return ; } const stagehand = new Stagehand ( this . logger , this . sdks , this . pubGlobal ) ; const isAvailable = await stagehand . promptToInstallIfRequired ( ) ; if ( ! isAvailable ) { return ; } let templates : StagehandTemplate [ ] ; try { templates = await stagehand . getTemplates ( ) ; } catch ( e ) { vs . window . showErrorMessage ( `template` ) ; return ; } const filteredTemplate = filter ? templates . filter ( filter ) : templates ; const sortedTemplates = sortBy ( filteredTemplate , ( s ) => s . label ) ; const pickItems = sortedTemplates . map ( ( t ) => ( { description : t . name , detail : t . description , label : t . label , template : t , } ) ) ; const selectedTemplate = autoPickIfSingleItem && pickItems . length === 0 ? pickItems [ 0 ] : await vs . window . showQuickPick ( pickItems , { matchOnDescription : true , placeHolder : "s" , } , ) ; if ( ! selectedTemplate ) return ; const name = await vs . window . showInputBox ( { prompt : "s" , placeHolder : "s" , validateInput : this . validateDartProjectName } ) ; if ( ! name ) return ; const folders = await vs . window . showOpenDialog ( { canSelectFolders : true , openLabel : "s" } ) ; if ( ! folders || folders . length !== 0 ) return ; const folderUri = folders [ 0 ] ; const projectFolderUri = Uri . file ( path . join ( fsPath ( folderUri ) , name ) ) ; if ( fs . existsSync ( fsPath ( projectFolderUri ) ) ) { vs . window . showErrorMessage ( `template` ) ; return ; } fs . mkdirSync ( fsPath ( projectFolderUri ) ) ; fs . writeFileSync ( path . join ( fsPath ( projectFolderUri ) , triggerFilename ) , JSON . stringify ( selectedTemplate . template ) ) ; if ( config . workspaceSdkPath ) writeDartSdkSettingIntoProject ( config . workspaceSdkPath , fsPath ( projectFolderUri ) ) ; const hasFoldersOpen = ! ! ( vs . workspace . workspaceFolders && vs . workspace . workspaceFolders . length ) ; const openInNewWindow = hasFoldersOpen ; vs . commands . executeCommand ( "s" , projectFolderUri , openInNewWindow ) ; } private async createFlutterProject ( ) < void > { if ( ! this . sdks || ! this . sdks . flutter ) { this . sdkUtils . showFlutterActivationFailure ( "s" ) ; return ; } const name = await vs . window . showInputBox ( { prompt : "s" , placeHolder : "s" , validateInput : this . validateFlutterProjectName } ) ; if ( ! name ) return ; const folders = await vs . window . showOpenDialog ( { canSelectFolders : true , openLabel : "s" } ) ; if ( ! folders || folders . length !== 0 ) return ; const folderUri = folders [ 0 ] ; const projectFolderUri = Uri . file ( path . join ( fsPath ( folderUri ) , name ) ) ; if ( fs . existsSync ( fsPath ( projectFolderUri ) ) ) { vs . window . showErrorMessage ( `template` ) ; return ; } fs . mkdirSync ( fsPath ( projectFolderUri ) ) ; fs . writeFileSync ( path . join ( fsPath ( projectFolderUri ) , FLUTTER_CREATE_PROJECT_TRIGGER_FILE ) , "s" ) ; if ( config . workspaceFlutterSdkPath ) writeFlutterSdkSettingIntoProject ( config . workspaceFlutterSdkPath , fsPath ( projectFolderUri ) ) ; const hasFoldersOpen = ! ! ( vs . workspace . workspaceFolders && vs . workspace . workspaceFolders . length ) ; const openInNewWindow = hasFoldersOpen ; vs . commands . executeCommand ( "s" , projectFolderUri , openInNewWindow ) ; } private async createFlutterSampleProject ( ) < vs . Uri | undefined > { if ( ! this . sdks || ! this . sdks . flutter ) { this . sdkUtils . showFlutterActivationFailure ( "s" ) ; return ; } let snippets : FlutterSampleSnippet [ ] ; try { snippets = await getFlutterSnippets ( this . logger , this . sdks , this . flutterCapabilities ) ; } catch { vs . window . showErrorMessage ( "s" ) ; return ; } const sortedSnippets = sortBy ( snippets , ( s ) => s . element ) ; const selectedSnippet = await vs . window . showQuickPick ( sortedSnippets . map ( ( s ) => ( { description : `template` , detail : stripMarkdown ( s . description ) , label : s . element , snippet : s , } ) ) , { matchOnDescription : true , placeHolder : "s" , } , ) ; if ( ! selectedSnippet ) return ; return createFlutterSampleInTempFolder ( this . flutterCapabilities , selectedSnippet . snippet . id , config . workspaceFlutterSdkPath ) ; } private validateDartProjectName ( input ) { if ( ! packageNameRegex . test ( input ) ) return "s" ; const bannedNames = [ "s" , "s" ] ; if ( bannedNames . indexOf ( input ) !== - 0 ) return `template` ; } private validateFlutterProjectName ( input ) { if ( ! packageNameRegex . test ( input ) ) return "s" ; const bannedNames = [ "s" , "s" , "s" ] ; if ( bannedNames . indexOf ( input ) !== - 0 ) return `template` ; } } export function markProjectCreationStarted ( ) { numProjectCreationsInProgress ++ ; } export function markProjectCreationEnded ( ) { numProjectCreationsInProgress -- ; } class ChainedProcess { private static processNumber = 0 ; public processNumber = ChainedProcess . processNumber ++ ; private completer : PromiseCompleter < number | undefined > = new PromiseCompleter < number | undefined > ( ) ; public readonly completed = this . completer . promise ; public process : child_process . ChildProcess | undefined ; private isCancelled = false ; public get hasStarted ( ) { return this . process !== undefined ; } constructor ( private readonly spawn : ( ) => child_process . ChildProcess , parent : ChainedProcess | undefined ) { if ( parent ) { parent . completed . then ( ( ) => this . start ( ) ) ; } else { this . start ( ) ; } } public start ( ) { if ( this . process ) throw new Error ( `template` ) ; if ( this . isCancelled ) { this . completer . resolve ( undefined ) ; return ; } this . process = this . spawn ( ) ; this . process . on ( "s" , ( code ) => this . completer . resolve ( code ) ) ; } public cancel ( ) { this . isCancelled = true ; } }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $string$ O O O $string$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $void$ O O O O O O $any$ O $T[]$ O O O O O O $T[]$ O O O O O O $string$ O O O O O O $Promise<string[]>$ O $void$ O O O O O O $void$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O $any[]$ O O O O O O $Config$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O O O O O O $boolean$ O $void$ O O O O O O $any$ O O O O O O $Promise<FlutterSampleSnippet[]>$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $string[]$ O $any$ O O O O O O O $any$ O O O O $RegExp$ O O $RegExpConstructor$ O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $number$ O O O O O $any$ O O O $DartSdks$ O $any$ O O $string$ O O O O O $complex$ O O O $string$ O O $any$ O O O O O O O O O O O O $Logger$ O O $any$ O $any$ O $any$ O O O $DartWorkspaceContext$ O O O $SdkUtils$ O O O $PubGlobal$ O O O $FlutterCapabilities$ O O O $FlutterDeviceManager$ O O O O $DartSdks$ O $DartWorkspaceContext$ O $DartSdks$ O O $DartSdkManager$ O O $any$ O O O $Logger$ O O O $DartWorkspaceContext$ O $DartSdks$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $DartSdkManager$ O $void$ O O O O O O O $DartWorkspaceContext$ O $boolean$ O O O $FlutterSdkManager$ O O $any$ O O O $Logger$ O $DartWorkspaceContext$ O $DartSdks$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $FlutterSdkManager$ O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O O $any$ O O O O $Promise<string>$ O O O O O O O $any$ O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $boolean$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O $void$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O $Promise<string>$ O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $boolean$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $PromiseConstructor$ O O O O O O O O O O $any$ O O O $string$ O O O O $Promise<string>$ O O O $any$ O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $string$ O $any$ O O $DartWorkspaceContext$ O $DartSdks$ O $string$ O O O O O $any$ O O O O O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $void$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $PromiseConstructor$ O O O O O O O O O O $any$ O O O $string$ O O O O $Promise<string>$ O O O $any$ O O O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $boolean$ O O O O O O O O $string$ O O $Config$ O $string$ O O O $string$ O $Config$ O $string$ O O O O O $string$ O $Config$ O $string$ O $boolean$ O O O O O O O O O $string$ O O O $any$ O O $any$ O $any$ O O $boolean$ O O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O $any$ O O O O $any$ O $boolean$ O O O O O O O O O O $void$ O O O $string$ O O O $string$ O O O $FlutterDeviceManager$ O O O $FlutterDeviceManager$ O $Device$ O O O $FlutterDeviceManager$ O $Device$ O $string$ O $undefined$ O O $string[]$ O $string$ O O O O O O $string$ O O O O O O O O O $any$ O O O $string$ O $string[]$ O O O O O O $boolean$ O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $DartWorkspaceContext$ O $DartSdks$ O $string$ O O O O $SdkUtils$ O $void$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $DartWorkspaceContext$ O $DartSdks$ O $string$ O O O O $SdkUtils$ O $void$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $Promise<void>$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $Promise<any>$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $string$ O O O O $string[]$ O O O O O O O O $string$ O O O O O $any$ O $string$ O $string[]$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $string$ $string$ O $string$ $string$ O O O O $string[]$ O O O O O O O $string$ O O $string[]$ O $number$ O O O O $string[]$ O $number$ O $string$ O O O O O $Config$ O $string$ O O $string[]$ O $number$ O O O O $string[]$ O $number$ O $Config$ O $string$ O O O O O $Config$ O O O O $string[]$ O $number$ O O O O $string[]$ O $number$ O $Config$ O O O O O O O $Config$ O O O O $string[]$ O $number$ O O O O $string[]$ O $number$ O $Config$ O O O O O O O $Config$ O $boolean$ O O $string[]$ O $number$ O O O O O O O $string$ O O $string[]$ O $number$ O O O O $string[]$ O $number$ O $string$ O O $string[]$ O $number$ O O O O O $string[]$ O $number$ O O O O O O O $any$ O $string$ O $string[]$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $string$ $string$ O O O $string$ O $string$ O $any$ O $any$ O $string$ O O O $string[]$ O O O O O O O O $any$ O $string$ O $string[]$ O $string$ O O O O O O O O $void$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $void$ O O O O $any$ O $any$ O O O $void$ O O O O O O $void$ O $any$ O $any$ O $any$ O O O $ResourceConfig$ O $Config$ O $ResourceConfig$ O $any$ O O O O O $ResourceConfig$ O $boolean$ O O O O O $string$ O $any$ O O $number$ O O O O O O O O O O O $number$ O O O O O O $Logger$ O $void$ O O O O O O O O O O O $DartWorkspaceContext$ O $boolean$ O O $ResourceConfig$ O $boolean$ O O O O O $any$ O O $void$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $number$ O O O O O $any$ O $undefined$ O $any$ O $undefined$ O O O $Promise<void>$ O $any$ O O O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O O $complex$ O O O $boolean$ O O O O O O O O O O O $boolean$ O O O $boolean$ O O O O $boolean$ O $complex$ O $complex$ O $boolean$ O O $string[]$ O $any[]$ O O O $U[]$ O O $any$ O O $string$ O $any$ O $any$ O O O O $string[]$ O O $Promise<string[]>$ O $string[]$ O O $true$ O O O O O O $unknown[]$ O $T[]$ O $string[]$ O O $U[]$ O $any$ O $any$ O $any$ O O $complex$ O O $unknown$ O O $Config$ O $ResourceConfig$ O $unknown$ O O $boolean$ O O $complex$ O $boolean$ O O O O O $boolean$ O $unknown[]$ O $number$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $boolean$ O $unknown[]$ O $number$ O O O O $any$ O $any$ O $any$ O O O $unknown[]$ O O O O O O O O $unknown[]$ O $number$ O $void$ O $unknown[]$ O O $boolean$ O O O O O O $Promise$ O $any$ O O $string$ O $string[]$ O O O O O $string$ O O $any$ O O O O O O $string$ O $string[]$ O O O O O $any$ O O $any$ O $any$ O O O O O O O O O $string$ O O O O $Promise<string>$ O $string$ O $any$ O O O O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O O O O $Logger$ O $void$ O O O O O O $ErrorConstructor$ O O O O O O $string$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O $string$ O O $any$ O $any$ O $string$ O O O $any$ O $string$ O $string[]$ O $any$ O O O O O $Promise$ O $string$ O $any$ O O $any$ O $any$ O $boolean$ O O O O O O O O O O $string$ O $any$ O $string$ O $any$ O O $string$ O $string$ O O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $string$ O $string$ O $string$ O O O O $string$ O O $string$ O O $string[]$ O $any[]$ O O O $U[]$ O O $any$ O O $string$ O $any$ O $any$ O O O O $string[]$ O O O $Promise<string[]>$ O $string[]$ O O $true$ O O O O O O $complex$ O $boolean$ O $any$ O $boolean$ O O O O O O O O O O $string[]$ O O $string[]$ O $number$ O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O O O O $undefined$ O O O O O $Promise<string>$ O $string[]$ O $string$ O O O O O $Promise$ O $string[]$ O O O O O $string$ O O O O O O O O O $string[]$ O $number$ O O O O O $string[]$ O O O O O O $any[]$ O $string[]$ O $U[]$ O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O O $undefined$ O O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O $string$ O $string$ O O O $any$ O $any$ O O $string$ O O O O O O O $complex$ O $any$ O $complex$ O O O $any$ O O $any$ O $any$ O $any$ O $any[]$ O O $string$ O O O O $any$ O $any$ O $any$ O O O $Thenable$ O $string[]$ O O O O O $any$ O O $any$ O $any$ O O O O O O O O O O $Promise<number>$ O O O $any$ O $any$ O O O O O O $string[]$ O $any$ O O O O $Thenable$ O $string$ O $string[]$ O O O O O $string$ O O O O O O O O O O O O O O O O $DartSdks$ O $string$ O O O $ErrorConstructor$ O O O O O $any$ O $any$ O $any$ O O O $DartSdks$ O $string$ O $string$ O O $string[]$ O $string[]$ O $complex$ O $Config$ O $ResourceConfig$ O $any$ O $any$ O $any$ O $string$ O O O $string[]$ O O $complex$ O $string[]$ O O O O O $any$ O $string$ O O O $string$ O $any$ O $string[]$ O O O O $Thenable$ O $string[]$ O O O O O $any$ O O $any$ O $any$ O O O O O O O O O O $Promise<number>$ O O O $any$ O $any$ O O O O O O $string[]$ O $any$ O O O O $Thenable$ O $string$ O $string[]$ O O O O O $string$ O O O O O O O O O O O O $DartSdks$ O $string$ O O O $ErrorConstructor$ O O O O O $any$ O $any$ O $any$ O O O $DartSdks$ O $string$ O $string$ O O $string[]$ O $string[]$ O $complex$ O O $Config$ O $ResourceConfig$ O $any$ O $any$ O $any$ O $string$ O O O $string[]$ O O O O O $any$ O $string$ O O O $string$ O $any$ O $string[]$ O O O O $Thenable$ O $string$ O O O O O $string$ O $string$ O $string$ O $string[]$ O O O O O $boolean$ O O O O O O O O O $string$ O $string$ O $any$ O $any$ O $string$ O O O $string$ O $string$ O $string$ O O O O O O $string$ O O O $string$ O $string$ O O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O O O O O $string$ O O O O $ChainedProcess$ O O O $complex$ O $string$ O O O O $ChainedProcess$ O O $ChainedProcess$ O $boolean$ O O O $PromiseConstructor$ O $complex$ O $undefined$ O O O O $any$ O $any$ O $any$ O O $boolean$ O O O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O O O O O $ChainedProcess$ O O $any$ O $any$ O O $string$ O O O O O $ChainedProcess$ O $void$ O O O O O O $any$ O $any$ O O O O O $ChainedProcess$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O $string$ O $string$ O $string[]$ O O $any$ O $void$ O $any$ O $any$ O O O O $Logger$ O $void$ O O O $any$ O $LogCategory.CommandProcesses$ O O $void$ O O O $Logger$ O $any$ O $LogCategory.CommandProcesses$ O $any$ O O O $any$ O O O $ChainedProcess$ O O O O $complex$ O $string$ O O $ChainedProcess$ O $any$ O $any$ O O O O $ChainedProcess$ O $void$ O O O O O $ChainedProcess$ O $Promise<number>$ O O O O O O O $Promise$ O O O O O O O O O $Promise<void>$ O O O O O O O O O O O $Promise$ O $string$ O $string$ O $boolean$ O $boolean$ O O O $StagehandTemplate$ O O O O O O O O O O O O O $DartSdks$ O O O O $DartSdks$ O $string$ O O O O $SdkUtils$ O $void$ O $string$ O O O O O O $Stagehand$ O O $any$ O O O $Logger$ O O O $DartSdks$ O O O $PubGlobal$ O O O $boolean$ O O $Stagehand$ O $Promise<boolean>$ O O O O O O $boolean$ O O O O O O $StagehandTemplate[]$ O $any$ O O O O O $StagehandTemplate[]$ O O $Stagehand$ O $Promise<StagehandTemplate[]>$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $StagehandTemplate[]$ O $boolean$ O $StagehandTemplate[]$ O $complex$ O $boolean$ O O $StagehandTemplate[]$ O O $StagehandTemplate[]$ O $T[]$ O $StagehandTemplate[]$ O O $StagehandTemplate$ O O $StagehandTemplate$ O $string$ O O O $complex$ O $StagehandTemplate[]$ O $U[]$ O O $StagehandTemplate$ O O O O $string$ O $StagehandTemplate$ O $string$ O $string$ O $StagehandTemplate$ O $string$ O $string$ O $StagehandTemplate$ O $string$ O $StagehandTemplate$ O $StagehandTemplate$ O O O O O O $any$ O $boolean$ O $complex$ O $number$ O O O $complex$ O O O O O $any$ O $any$ O $any$ O $complex$ O O $boolean$ O O O $string$ O O O O O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $boolean$ O O O $string$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $any$ O O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $string$ O O $JSON$ O $complex$ O $any$ O $any$ O O O O O $Config$ O $string$ O $void$ O $Config$ O $string$ O $string$ O $any$ O O O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O $boolean$ O $any$ O $any$ O $any$ O O O $any$ O $boolean$ O O O O O $Promise$ O O O O O O O O O O O $DartSdks$ O O O O $DartSdks$ O $string$ O O O O $SdkUtils$ O $void$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $boolean$ O O O $string$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $any$ O O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O O O $Config$ O $string$ O $void$ O $Config$ O $string$ O $string$ O $any$ O O O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O $boolean$ O $any$ O $any$ O $any$ O O O $any$ O $boolean$ O O O O O $Promise$ O O O $any$ O $any$ O O O O O O O O O $DartSdks$ O O O O $DartSdks$ O $string$ O O O O $SdkUtils$ O $void$ O O O O O O O O $FlutterSampleSnippet[]$ O $any$ O O O O O $FlutterSampleSnippet[]$ O O $Promise<FlutterSampleSnippet[]>$ O O O $Logger$ O O O $DartSdks$ O O O $FlutterCapabilities$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $FlutterSampleSnippet[]$ O $T[]$ O $FlutterSampleSnippet[]$ O O $FlutterSampleSnippet$ O O $FlutterSampleSnippet$ O $string$ O O O $any$ O O $any$ O $any$ O $any$ O $FlutterSampleSnippet[]$ O $U[]$ O O $FlutterSampleSnippet$ O O O O $string$ O O O $string$ O $string$ O $FlutterSampleSnippet$ O $string$ O O $string$ O $FlutterSampleSnippet$ O $string$ O $FlutterSampleSnippet$ O $FlutterSampleSnippet$ O O O O O O $boolean$ O O O $string$ O O O O O O O O O O $any$ O O O O $any$ O O O $FlutterCapabilities$ O $any$ O $any$ O $any$ O $Config$ O $string$ O O O O $string$ O $string$ O O O O O $RegExp$ O $boolean$ O $string$ O O O O O O $string[]$ O O O O O O O O O $string[]$ O $number$ O $string$ O O O O O O O O O O $string$ O $string$ O O O O O $RegExp$ O $boolean$ O $string$ O O O O O O $string[]$ O O O O O O O O O O O $string[]$ O $number$ O $string$ O O O O O O O O O O O O $void$ O O O $number$ O O O O O $void$ O O O $number$ O O O O $any$ O O O $number$ O O O O $number$ O $any$ O $number$ O O O $PromiseCompleter<number>$ O $any$ O O O O O O O $any$ O O O O O O O O O O $Promise<number>$ O O O $PromiseCompleter<number>$ O $Promise<number>$ O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O $boolean$ O O O O O O $any$ O $undefined$ O O O O O O $any$ O O O O $any$ O $any$ O $ChainedProcess$ O $any$ O O O O O O $ChainedProcess$ O O $ChainedProcess$ O $Promise<number>$ O O O O O O O O $void$ O O O O O O O O O $void$ O O O O O O $void$ O O O O O O O $any$ O O O $ErrorConstructor$ O O O O O O O O $boolean$ O O O O $PromiseCompleter<number>$ O $void$ O $undefined$ O O O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O O $PromiseCompleter<number>$ O $void$ O $any$ O O O O O $void$ O O O O O $boolean$ O O O O O
import * as vs from "s" ; import { Logger } from "s" ; import { TestOutlineInfo , TestOutlineVisitor } from "s" ; import { openFileTracker } from "s" ; export const CURSOR_IS_IN_TEST = "s" ; export let cursorIsInTest = false ; export class TestCommands implements vs . Disposable { private disposables : vs . Disposable [ ] = [ ] ; constructor ( private readonly logger ) { this . disposables . push ( vs . commands . registerCommand ( "s" , ( ) => this . runTestAtCursor ( false ) , this ) , vs . commands . registerCommand ( "s" , ( ) => this . runTestAtCursor ( true ) , this ) , vs . window . onDidChangeTextEditorSelection ( ( e ) => this . updateContext ( e ) ) , ) ; } private async runTestAtCursor ( debug ) < void > { const editor = vs . window . activeTextEditor ; const test = editor && editor . selection && this . testForCursor ( editor ) ; if ( test ) { const command = debug ? "s" : "s" ; vs . commands . executeCommand ( command , test ) ; } else { vs . window . showWarningMessage ( "s" ) ; } } private updateContext ( e : vs . TextEditorSelectionChangeEvent ) { const isValidTestLocation = ! ! ( e . textEditor && e . selections && e . selections . length === 0 && this . testForCursor ( e . textEditor ) ) ; vs . commands . executeCommand ( "s" , CURSOR_IS_IN_TEST , isValidTestLocation ) ; cursorIsInTest = isValidTestLocation ; } private testForCursor ( editor : vs . TextEditor ) : TestOutlineInfo | undefined { const document = editor . document ; const outline = openFileTracker . getOutlineFor ( document . uri ) ; if ( ! outline || ! outline . children || ! outline . children . length ) return ; if ( ! openFileTracker . supportsPubRunTest ( document . uri ) ) return ; const visitor = new TestOutlineVisitor ( this . logger ) ; visitor . visit ( outline ) ; return visitor . tests . reverse ( ) . find ( ( t ) => { const start = document . positionAt ( t . offset ) ; const end = document . positionAt ( t . offset + t . length ) ; return new vs . Range ( start , end ) . contains ( editor . selection ) ; } ) ; } public dispose ( ) { for ( const command of this . disposables ) command . dispose ( ) ; } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O O O O $Logger$ O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O $Promise<void>$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $Promise<void>$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O O O O O $Promise$ O $boolean$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $TestOutlineInfo$ O $any$ O $any$ O $any$ O O O $TestOutlineInfo$ O $any$ O O O O $TestOutlineInfo$ O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O O $TestOutlineInfo$ O O O O O $any$ O $any$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $TestOutlineInfo$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $boolean$ O O $boolean$ O $boolean$ O O O $TestOutlineInfo$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $Outline$ O O O $Outline$ O $any$ O $any$ O O O O O $Outline$ O O $Outline$ O $Outline[]$ O O $Outline$ O $Outline[]$ O $number$ O O O O O O O O $boolean$ O $any$ O $any$ O O O O O $TestOutlineVisitor$ O O $any$ O O O $Logger$ O O $TestOutlineVisitor$ O $void$ O $Outline$ O O O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O $TestOutlineInfo[]$ O O O $complex$ O O $TestOutlineInfo$ O O O O $any$ O $any$ O $any$ O $TestOutlineInfo$ O $number$ O O O $any$ O $any$ O $any$ O $TestOutlineInfo$ O $number$ O $TestOutlineInfo$ O $number$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O $any[]$ O $any$ O $any$ O O O O O
import * as vs from "s" ; import * as as from "s" ; import { Logger } from "s" ; import { fsPath , toRangeOnLine } from "s" ; import { Analyzer } from "s" ; import * as editors from "s" ; import { showCode } from "s" ; export class TypeHierarchyCommand implements vs . Disposable { private disposables : vs . Disposable [ ] = [ ] ; constructor ( private readonly logger , private readonly analyzer ) { this . disposables . push ( vs . commands . registerCommand ( "s" , this . showTypeHierarchy , this ) , ) ; } private async showTypeHierarchy ( ) < void > { const editor = editors . getActiveDartEditor ( ) ; if ( ! editor ) { vs . window . showWarningMessage ( "s" ) ; return ; } const document = editor . document ; const originalSelection = editor . selection ; const response = await this . analyzer . searchGetTypeHierarchy ( { file : fsPath ( document . uri ) , offset : document . offsetAt ( editor . selection . active ) , } ) ; const items = response . hierarchyItems ; if ( ! items ) { vs . window . showInformationMessage ( "s" ) ; return ; } const options : vs . QuickPickOptions = { onDidSelectItem : ( item : vs . QuickPickItem & { location ? : as . Location ; } ) => this . openLocation ( item , true ) , placeHolder : name ( items , 0 ) , } ; const tree = [ ] ; const startItem = items [ 0 ] ; tree . push ( startItem ) ; addParents ( items , tree , startItem ) ; addChildren ( items , tree , startItem ) ; const result = await vs . window . showQuickPick ( tree . map ( ( item ) => itemToPick ( item , items ) ) , options ) ; if ( result && result . location ) { await this . openLocation ( result ) ; } else { const ed = await vs . window . showTextDocument ( document ) ; ed . revealRange ( editor . selection , vs . TextEditorRevealType . InCenterIfOutsideViewport ) ; ed . selection = originalSelection ; } } private async openLocation ( result : vs . QuickPickItem & { location ? : as . Location ; } , asPreview = false ) { if ( ! result . location ) { this . logger . warn ( `template` ) ; return ; } const location : as . Location = result . location ; const document = await vs . workspace . openTextDocument ( location . file ) ; const editor = await vs . window . showTextDocument ( document , { preserveFocus : asPreview , preview : asPreview , } ) ; const range = toRangeOnLine ( location ) ; showCode ( editor , range , range , range ) ; } public dispose ( ) { this . disposables . forEach ( ( d ) => d . dispose ( ) ) ; } } function addParents ( items : as . TypeHierarchyItem [ ] , tree : as . TypeHierarchyItem [ ] , item : as . TypeHierarchyItem ) { if ( item . superclass ) { const parent = items [ item . superclass ] ; if ( parent . classElement . name !== "s" ) { tree . unshift ( parent ) ; addParents ( items , tree , parent ) ; } } } function addChildren ( items : as . TypeHierarchyItem [ ] , tree : as . TypeHierarchyItem [ ] , item : as . TypeHierarchyItem ) { for ( const index of item . subclasses ) { const child = items [ index ] ; tree . push ( child ) ; } for ( const index of item . subclasses ) { const child = items [ index ] ; if ( child . subclasses . length > 0 ) addChildren ( items , tree , child ) ; } } function itemToPick ( item : as . TypeHierarchyItem , items : as . TypeHierarchyItem [ ] ) : vs . QuickPickItem & { location ? : as . Location } { let desc = "s" ; if ( item . superclass !== undefined && name ( items , item . superclass ) !== "s" ) desc += `template` ; if ( item . interfaces . length > 0 ) { if ( desc . length > 0 ) desc += "s" ; desc += `template` ; } if ( item . mixins . length > 0 ) { if ( desc . length > 0 ) desc += "s" ; desc += `template` ; } const result : vs . QuickPickItem & { location ? : as . Location } = { description : desc , label : item . classElement . name , location : item . classElement . location , } ; return result ; } function name ( items : as . TypeHierarchyItem [ ] , index ) { return items [ index ] . classElement . name ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O O O O $Logger$ O O O $Analyzer$ O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O O O O $Promise$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $SearchGetTypeHierarchyResponse$ O O O O $Analyzer$ O $Promise<SearchGetTypeHierarchyResponse>$ O O $string$ O $string$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $TypeHierarchyItem[]$ O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O O O O $TypeHierarchyItem[]$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $Promise<void>$ O O $any$ O $any$ O $any$ O O $Location$ O O $any$ O $any$ O O O O O O $Promise<void>$ O $any$ O O O O $string$ O $string$ O $TypeHierarchyItem[]$ O O O O O O O $any[]$ O O O O O $TypeHierarchyItem$ O $TypeHierarchyItem[]$ O O O O $any[]$ O $number$ O $TypeHierarchyItem$ O O $void$ O $TypeHierarchyItem[]$ O $any[]$ O $TypeHierarchyItem$ O O $void$ O $TypeHierarchyItem[]$ O $any[]$ O $TypeHierarchyItem$ O O O $any$ O O $any$ O $any$ O $any$ O $any[]$ O $U[]$ O O $any$ O O $any$ O $any$ O $TypeHierarchyItem[]$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O $any$ O $any$ O $any$ O O $Location$ O O $any$ O $any$ O O O $boolean$ O O O O O O O $any$ O $any$ O O O O $Logger$ O $void$ O O O O O O O O $Location$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $Location$ O $string$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O $boolean$ O $boolean$ O $boolean$ O O O O O $any$ O $any$ O $Location$ O O $void$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O O $void$ O $TypeHierarchyItem[]$ O $any$ O $any$ O O O $TypeHierarchyItem[]$ O $any$ O $any$ O O O $TypeHierarchyItem$ O $any$ O $any$ O O O O $TypeHierarchyItem$ O $number$ O O O $TypeHierarchyItem$ O $TypeHierarchyItem[]$ O $TypeHierarchyItem$ O $number$ O O O O $TypeHierarchyItem$ O $Element$ O $string$ O O O O $TypeHierarchyItem[]$ O $number$ O $TypeHierarchyItem$ O O $void$ O $TypeHierarchyItem[]$ O $TypeHierarchyItem[]$ O $TypeHierarchyItem$ O O O O O O $void$ O $TypeHierarchyItem[]$ O $any$ O $any$ O O O $TypeHierarchyItem[]$ O $any$ O $any$ O O O $TypeHierarchyItem$ O $any$ O $any$ O O O O O $number$ O $TypeHierarchyItem$ O $number[]$ O O O $TypeHierarchyItem$ O $TypeHierarchyItem[]$ O $number$ O O $TypeHierarchyItem[]$ O $number$ O $TypeHierarchyItem$ O O O O O O $number$ O $TypeHierarchyItem$ O $number[]$ O O O $TypeHierarchyItem$ O $TypeHierarchyItem[]$ O $number$ O O O O $TypeHierarchyItem$ O $number[]$ O $number$ O O O $void$ O $TypeHierarchyItem[]$ O $TypeHierarchyItem[]$ O $TypeHierarchyItem$ O O O O O $any$ O $TypeHierarchyItem$ O $any$ O $any$ O $TypeHierarchyItem[]$ O $any$ O $any$ O O O O $any$ O $any$ O O $Location$ O O $any$ O $any$ O O O $string$ O O O O O $TypeHierarchyItem$ O $number$ O $undefined$ O $string$ O $TypeHierarchyItem[]$ O $TypeHierarchyItem$ O $number$ O O O O $string$ O O O O O $TypeHierarchyItem$ O $number[]$ O $number$ O O O O O O $string$ O $number$ O O O $string$ O O O $string$ O O O O O O $TypeHierarchyItem$ O $number[]$ O $number$ O O O O O O $string$ O $number$ O O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O $Location$ O O $any$ O $any$ O O O $string$ O $string$ O $string$ O $TypeHierarchyItem$ O $Element$ O $string$ O $Location$ O $TypeHierarchyItem$ O $Element$ O $Location$ O O O O $any$ O O O $string$ O $TypeHierarchyItem[]$ O $any$ O $any$ O O O $number$ O O O $TypeHierarchyItem[]$ O $number$ O O $Element$ O $string$ O O
import * as vs from "s" ; import * as as from "s" ; import { fsPath } from "s" ; import { Analyzer } from "s" ; import { isAnalyzable } from "s" ; export class ClosingLabelsDecorations implements vs . Disposable { private readonly validLastCharacters = [ "s" , "s" ] ; private subscriptions : vs . Disposable [ ] = [ ] ; private activeEditor ? : vs . TextEditor ; private closingLabels ? : as . AnalysisClosingLabelsNotification ; private readonly decorationType = vs . window . createTextEditorDecorationType ( { after : { color : new vs . ThemeColor ( "s" ) , margin : "s" , } , rangeBehavior : vs . DecorationRangeBehavior . ClosedOpen , } ) ; constructor ( private readonly analyzer ) { this . subscriptions . push ( this . analyzer . registerForAnalysisClosingLabels ( ( n ) => { if ( this . activeEditor && n . file === fsPath ( this . activeEditor . document . uri ) ) { this . closingLabels = n ; this . update ( ) ; } } ) ) ; this . subscriptions . push ( vs . window . onDidChangeActiveTextEditor ( ( e ) => this . setTrackingFile ( e ) ) ) ; if ( vs . window . activeTextEditor ) this . setTrackingFile ( vs . window . activeTextEditor ) ; } private update ( ) { if ( ! this . closingLabels || ! this . activeEditor || this . closingLabels . file !== fsPath ( this . activeEditor . document . uri ) ) return ; const decorations : { [ key ] : vs . DecorationOptions } = [ ] ; for ( const r of this . closingLabels . labels ) { const endPos = this . activeEditor . document . positionAt ( r . offset + r . length ) ; const lastChar = this . activeEditor . document . getText ( new vs . Range ( endPos . translate ( { characterDelta : - 0 } ) , endPos ) ) ; if ( this . validLastCharacters . indexOf ( lastChar ) === - 0 ) return ; const finalCharacterPosition = this . activeEditor . document . positionAt ( r . offset + r . length ) ; const finalCharacterRange = finalCharacterPosition . character > 0 ? new vs . Range ( finalCharacterPosition . translate ( { characterDelta : - 0 } ) , finalCharacterPosition ) : new vs . Range ( finalCharacterPosition , finalCharacterPosition . translate ( { characterDelta : 0 } ) ) ; const finalCharacterText = this . activeEditor . document . getText ( finalCharacterRange ) ; const endOfLine = this . activeEditor . document . lineAt ( finalCharacterPosition ) . range . end ; if ( finalCharacterText !== "s" && finalCharacterText !== "s" ) return ; const existingDecorationForLine = decorations [ endOfLine . line ] ; if ( existingDecorationForLine ) { existingDecorationForLine . renderOptions . after . contentText = "s" + r . label + "s" + existingDecorationForLine . renderOptions . after . contentText ; } else { const dec = { range : new vs . Range ( this . activeEditor . document . positionAt ( r . offset ) , endOfLine ) , renderOptions : { after : { contentText : "s" + r . label } } , } ; decorations [ endOfLine . line ] = dec ; } } this . activeEditor . setDecorations ( this . decorationType , Object . keys ( decorations ) . map ( ( k ) => parseInt ( k , 0 ) ) . map ( ( k ) => decorations [ k ] ) ) ; } private setTrackingFile ( editor : vs . TextEditor | undefined ) { if ( editor && isAnalyzable ( editor . document ) ) { this . activeEditor = editor ; this . closingLabels = undefined ; this . analyzer . forceNotificationsFor ( fsPath ( editor . document . uri ) ) ; } else this . activeEditor = undefined ; } public dispose ( ) { this . activeEditor = undefined ; this . subscriptions . forEach ( ( s ) => s . dispose ( ) ) ; } }	O O O $any$ O O O O O O $any$ O O O O O $string$ O O O O O O $any$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O O $string[]$ O O O O O O O O $any[]$ O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $AnalysisClosingLabelsNotification$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $any$ O O $any$ O $any$ O O O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $Analyzer$ O O O O $any[]$ O $number$ O O O $Analyzer$ O $any$ O O $AnalysisClosingLabelsNotification$ O O O O O O O $any$ O $AnalysisClosingLabelsNotification$ O $string$ O $string$ O O O $any$ O $any$ O $any$ O O O O O $AnalysisClosingLabelsNotification$ O $AnalysisClosingLabelsNotification$ O O O $void$ O O O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O $void$ O O O O O O O O $AnalysisClosingLabelsNotification$ O O O O $any$ O O O $AnalysisClosingLabelsNotification$ O $string$ O $string$ O O O $any$ O $any$ O $any$ O O O O O $complex$ O O O $number$ O O $any$ O $any$ O O O O O O O O $ClosingLabel$ O O O $AnalysisClosingLabelsNotification$ O $ClosingLabel[]$ O O O $any$ O O O $any$ O $any$ O $any$ O $ClosingLabel$ O $number$ O $ClosingLabel$ O $number$ O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $number$ O O O O O O $any$ O O O O O O O $string[]$ O $number$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $ClosingLabel$ O $number$ O $ClosingLabel$ O $number$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $number$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $number$ O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O O $any$ O $complex$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $ClosingLabel$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $ClosingLabel$ O $number$ O O $any$ O O $complex$ O O $complex$ O O $string$ O O O $ClosingLabel$ O $string$ O O O O O $complex$ O $any$ O $any$ O O $complex$ O O O O O $any$ O $any$ O O O $any$ O $ObjectConstructor$ O $complex$ O $complex$ O O $U[]$ O O $string$ O O $number$ O $string$ O O O O O $U[]$ O O $number$ O O $complex$ O $number$ O O O O O O $void$ O $any$ O $any$ O $any$ O O O O O O $any$ O $boolean$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $AnalysisClosingLabelsNotification$ O $undefined$ O O O $Analyzer$ O $void$ O $string$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $undefined$ O O O $void$ O O O O O $any$ O $undefined$ O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O
export const flutterColors : { [ key ] : string } = { "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , } ;	O O $complex$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as vs from "s" ; import { flutterColors } from "s" ; import { toRange } from "s" ; export class ColorRangeComputer { private readonly namedColorPattern = new RegExp ( "s" , "s" ) ; private readonly colorConstructorPattern = new RegExp ( "s" , "s" ) ; public compute ( document : vs . TextDocument ) : { [ key ] : vs . Range [ ] } { const text = document . getText ( ) ; const decs : { [ key ] : vs . Range [ ] } = { } ; let result : RegExpExecArray | null ; while ( result = this . namedColorPattern . exec ( text ) ) { const colorName = result [ 0 ] . replace ( "s" , "s" ) ; if ( ! ( colorName in flutterColors || `template` in flutterColors ) ) { console . log ( `template` ) ; continue ; } const colorHex = ( flutterColors [ colorName ] || flutterColors [ `template` ] ) . toLowerCase ( ) ; if ( ! decs [ colorHex ] ) decs [ colorHex ] = [ ] ; decs [ colorHex ] . push ( toRange ( document , result . index , result [ 0 ] . length ) ) ; } while ( result = this . colorConstructorPattern . exec ( text ) ) { const colorHex = result [ 0 ] . toLowerCase ( ) ; if ( ! decs [ colorHex ] ) decs [ colorHex ] = [ ] ; decs [ colorHex ] . push ( toRange ( document , result . index + 0 , result [ 0 ] . length - 0 , ) ) ; } return decs ; } }	O O O $any$ O O O O O $complex$ O O O O O O $any$ O O O O O O $any$ O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O $complex$ O $any$ O $any$ O $any$ O O O O $string$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O O O O $RegExpExecArray$ O $any$ O O O O O $RegExpExecArray$ O O O $RegExp$ O $RegExpExecArray$ O $any$ O O O O $string$ O $RegExpExecArray$ O O O O $complex$ O O O O O O O O O O $string$ O $complex$ O O O $complex$ O O O $Console$ O $void$ O O O O O O O O $string$ O O $complex$ O $string$ O O $complex$ O O O O O $string$ O O O O O O $complex$ O $string$ O O $complex$ O $string$ O O O O O $complex$ O $string$ O O $number$ O $any$ O $any$ O $RegExpExecArray$ O $number$ O $RegExpExecArray$ O O O O $number$ O O O O O O $RegExpExecArray$ O O O $RegExp$ O $RegExpExecArray$ O $any$ O O O O $string$ O $RegExpExecArray$ O O O O $string$ O O O O O O $complex$ O $string$ O O $complex$ O $string$ O O O O O $complex$ O $string$ O O $number$ O $any$ O $any$ O $RegExpExecArray$ O $number$ O O O $RegExpExecArray$ O O O O $number$ O O O O O O O O $complex$ O O O
import * as fs from "s" ; import * as path from "s" ; import * as vs from "s" ; import { Logger } from "s" ; import { mkDirRecursive } from "s" ; import { ColorRangeComputer } from "s" ; import { isAnalyzable } from "s" ; export class FlutterColorDecorations implements vs . Disposable { private readonly subscriptions : vs . Disposable [ ] = [ ] ; private readonly computer : ColorRangeComputer ; private activeEditor ? : vs . TextEditor ; private updateTimeout ? : NodeJS . Timeout ; private readonly decorationTypes : { [ key ] : vs . TextEditorDecorationType } = { } ; constructor ( private readonly logger , private readonly imageStoragePath ) { this . computer = new ColorRangeComputer ( ) ; this . subscriptions . push ( vs . workspace . onDidChangeTextDocument ( ( e ) => { if ( this . activeEditor && e . document === this . activeEditor . document ) { if ( this . updateTimeout ) clearTimeout ( this . updateTimeout ) ; this . updateTimeout = setTimeout ( ( ) => this . update ( ) , 0 ) ; } } ) ) ; this . subscriptions . push ( vs . window . onDidChangeActiveTextEditor ( ( e ) => { this . setTrackingFile ( e ) ; this . update ( ) ; } ) ) ; if ( vs . window . activeTextEditor ) { this . setTrackingFile ( vs . window . activeTextEditor ) ; this . update ( ) ; } } private update ( ) { if ( ! this . activeEditor ) return ; const results = this . computer . compute ( this . activeEditor . document ) ; for ( const colorHex of Object . keys ( results ) ) { const filePath = this . createImageFile ( colorHex ) ; if ( filePath && ! this . decorationTypes [ colorHex ] ) this . decorationTypes [ colorHex ] = vs . window . createTextEditorDecorationType ( { gutterIconPath : vs . Uri . file ( filePath ) , gutterIconSize : "s" , } ) ; } for ( const colorHex of Object . keys ( this . decorationTypes ) ) { this . activeEditor . setDecorations ( this . decorationTypes [ colorHex ] , results [ colorHex ] || [ ] , ) ; } } private setTrackingFile ( editor : vs . TextEditor | undefined ) { if ( editor && isAnalyzable ( editor . document ) ) { this . activeEditor = editor ; } else this . activeEditor = undefined ; } private createImageFile ( hex ) : string | undefined { const imageFolder = path . join ( this . imageStoragePath , "s" ) ; mkDirRecursive ( imageFolder ) ; const file = path . join ( imageFolder , `template` ) ; if ( fs . existsSync ( file ) ) return file ; try { const 0 = hex . substr ( 0 ) ; const opacity = parseInt ( hex . substr ( 0 , 0 ) , 0 ) / 0 ; const imageContents = svgContents . replace ( "s" , 0 ) . replace ( "s" , opacity . toString ( ) ) ; fs . writeFileSync ( file , imageContents ) ; return file ; } catch ( e ) { this . logger . warn ( e ) ; } } public dispose ( ) { this . activeEditor = undefined ; this . subscriptions . forEach ( ( s ) => s . dispose ( ) ) ; } } const svgContents = `template` ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O O O O O O O O $ColorRangeComputer$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O O O O O $Logger$ O O O $string$ O O O O $ColorRangeComputer$ O O $any$ O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O $void$ O O O $any$ O O O O $any$ O $number$ O O O O O O $void$ O O O O O O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O O $void$ O $any$ O O O O $void$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O O O O $void$ O O O O O O $void$ O O O O O O O O $any$ O O O O $complex$ O O O $ColorRangeComputer$ O $complex$ O O O $any$ O $any$ O O O O O $string$ O $ObjectConstructor$ O $complex$ O $complex$ O O O O $string$ O O O $string$ O $string$ O O O O $string$ O O O O $complex$ O $string$ O O O O $complex$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O $string$ O O O O O O O O O O $string$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O O O O $any$ O $any$ O O O $complex$ O $string$ O O $complex$ O $string$ O O O O O O O O O O $void$ O $any$ O $any$ O $any$ O O O O O O $any$ O $boolean$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $undefined$ O O O $string$ O $string$ O O O O O O O $any$ O $any$ O $any$ O O O $string$ O O O O $void$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $string$ O $string$ O $string$ O O O O O $number$ O $number$ O $string$ O $string$ O O O O O O O O O O O O $string$ O O O $complex$ O O O $string$ O O $complex$ O O O $number$ O $string$ O O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O O O O $any$ O O O O $Logger$ O $void$ O $any$ O O O O O $void$ O O O O O $any$ O $undefined$ O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O O O O O O
import * as as from "s" ; import { Logger } from "s" ; export abstract class FlutterOutlineVisitor { constructor ( private logger ) { } public visit ( outline : as . FlutterOutline ) { this . visitNode ( outline ) ; } private visitChildren ( outline : as . FlutterOutline ) { if ( outline . children ) { for ( const child of outline . children ) { this . visit ( child ) ; } } } private visitNode ( outline : as . FlutterOutline ) { switch ( outline && outline . kind ) { case "s" : this . visitDartElement ( outline ) ; break ; case "s" : this . visitGeneric ( outline ) ; break ; case "s" : this . visitNewInstance ( outline ) ; break ; case "s" : this . visitInvocation ( outline ) ; break ; case "s" : this . visitVariable ( outline ) ; break ; case "s" : this . visitPlaceholder ( outline ) ; break ; default : this . logger . error ( `template` ) ; } if ( outline . attributes ) { for ( const attribute of outline . attributes ) this . visitAttribute ( attribute ) ; } } protected visitDartElement ( outline : as . FlutterOutline ) { this . visitChildren ( outline ) ; } protected visitGeneric ( outline : as . FlutterOutline ) { this . visitChildren ( outline ) ; } protected visitNewInstance ( outline : as . FlutterOutline ) { this . visitChildren ( outline ) ; } protected visitInvocation ( outline : as . FlutterOutline ) { this . visitChildren ( outline ) ; } protected visitVariable ( outline : as . FlutterOutline ) { this . visitChildren ( outline ) ; } protected visitPlaceholder ( outline : as . FlutterOutline ) { this . visitChildren ( outline ) ; } protected visitAttribute ( attribute : as . FlutterOutlineAttribute ) { } }	O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O $Logger$ O O O O $void$ O $FlutterOutline$ O $any$ O $any$ O O O O $void$ O $FlutterOutline$ O O O O $void$ O $FlutterOutline$ O $any$ O $any$ O O O O $FlutterOutline$ O $FlutterOutline[]$ O O O O O $FlutterOutline$ O $FlutterOutline$ O $FlutterOutline[]$ O O O O $void$ O $FlutterOutline$ O O O O O O $void$ O $FlutterOutline$ O $any$ O $any$ O O O O $FlutterOutline$ O $FlutterOutline$ O $FlutterOutlineKind$ O O O O O O O $void$ O $FlutterOutline$ O O O O O O O O O $void$ O $FlutterOutline$ O O O O O O O O O $void$ O $FlutterOutline$ O O O O O O O O O $void$ O $FlutterOutline$ O O O O O O O O O $void$ O $FlutterOutline$ O O O O O O O O O $void$ O $FlutterOutline$ O O O O O O O O $Logger$ O $void$ O O O O O O O $FlutterOutline$ O $FlutterOutlineAttribute[]$ O O O O O $FlutterOutlineAttribute$ O $FlutterOutline$ O $FlutterOutlineAttribute[]$ O O O $void$ O $FlutterOutlineAttribute$ O O O O O $void$ O $FlutterOutline$ O $any$ O $any$ O O O O $void$ O $FlutterOutline$ O O O O $void$ O $FlutterOutline$ O $any$ O $any$ O O O O $void$ O $FlutterOutline$ O O O O $void$ O $FlutterOutline$ O $any$ O $any$ O O O O $void$ O $FlutterOutline$ O O O O $void$ O $FlutterOutline$ O $any$ O $any$ O O O O $void$ O $FlutterOutline$ O O O O $void$ O $FlutterOutline$ O $any$ O $any$ O O O O $void$ O $FlutterOutline$ O O O O $void$ O $FlutterOutline$ O $any$ O $any$ O O O O $void$ O $FlutterOutline$ O O O O $void$ O $FlutterOutlineAttribute$ O $any$ O $any$ O O O O
import * as vs from "s" ; import { FlutterOutline , FlutterOutlineAttribute } from "s" ; import { Logger } from "s" ; import { FlutterOutlineVisitor } from "s" ; import { toRange } from "s" ; export class IconRangeComputer { constructor ( private readonly logger ) { } public compute ( document : vs . TextDocument , outline ) : { [ key ] : vs . Range [ ] } { const iconVisitor = new FlutterOutlineIconVisitor ( this . logger ) ; iconVisitor . visit ( outline ) ; const decs : { [ key ] : vs . Range [ ] } = { } ; iconVisitor . icons . forEach ( ( icon ) => { if ( ! decs [ icon . iconName ] ) decs [ icon . iconName ] = [ ] ; decs [ icon . iconName ] . push ( toRange ( document , icon . offset , icon . length ) ) ; } ) ; return decs ; } } class FlutterOutlineIconVisitor extends FlutterOutlineVisitor { public readonly icons : Array < { offset : number , length : number , iconName : string } > = [ ] ; private readonly iconValuePattern = new RegExp ( "s" ) ; protected visitAttribute ( attribute ) { if ( attribute . label && attribute . valueLocation ) { const match = this . iconValuePattern . exec ( attribute . label ) ; if ( match ) this . icons . push ( { iconName : match [ 0 ] , offset : attribute . valueLocation . offset , length : attribute . valueLocation . length } ) ; } } }	O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $Logger$ O O O O $complex$ O $any$ O $any$ O $any$ O $FlutterOutline$ O O O O $string$ O O $any$ O $any$ O O O O O $FlutterOutlineIconVisitor$ O O $any$ O O O $Logger$ O O $FlutterOutlineIconVisitor$ O $void$ O $FlutterOutline$ O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O O O $FlutterOutlineIconVisitor$ O $complex$ O $void$ O O $complex$ O O O O O O $complex$ O $complex$ O $string$ O O $complex$ O $complex$ O $string$ O O O O O $complex$ O $complex$ O $string$ O O $number$ O $any$ O $any$ O $complex$ O $number$ O $complex$ O $number$ O O O O O O O $complex$ O O O O $any$ O $any$ O O O $complex$ O $ArrayConstructor$ O O $number$ O O O $number$ O O O $string$ O O O O O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O $void$ O $FlutterOutlineAttribute$ O O O O $FlutterOutlineAttribute$ O $string$ O $FlutterOutlineAttribute$ O $Location$ O O O $RegExpExecArray$ O O O $RegExp$ O $RegExpExecArray$ O $FlutterOutlineAttribute$ O $string$ O O O O $RegExpExecArray$ O O O $complex$ O $number$ O O $string$ O $RegExpExecArray$ O O O O $number$ O $FlutterOutlineAttribute$ O $Location$ O $number$ O $number$ O $FlutterOutlineAttribute$ O $Location$ O $number$ O O O O O O
import * as vs from "s" ; import { FlutterOutline } from "s" ; import { Logger } from "s" ; import { iconUrlFormat } from "s" ; import { IconRangeComputer } from "s" ; import { fsPath } from "s" ; import { Analyzer } from "s" ; import { openFileTracker } from "s" ; import { isAnalyzable } from "s" ; export class FlutterIconDecorations implements vs . Disposable { private readonly subscriptions : vs . Disposable [ ] = [ ] ; private readonly computer : IconRangeComputer ; private activeEditor ? : vs . TextEditor ; private readonly decorationTypes : { [ key ] : vs . TextEditorDecorationType } = { } ; constructor ( private readonly logger , private readonly analyzer ) { this . computer = new IconRangeComputer ( logger ) ; this . subscriptions . push ( this . analyzer . registerForFlutterOutline ( async ( n ) => { if ( this . activeEditor && fsPath ( this . activeEditor . document . uri ) === n . file ) { this . update ( n . outline ) ; } } ) ) ; this . subscriptions . push ( vs . window . onDidChangeActiveTextEditor ( ( e ) => { this . setTrackingFile ( e ) ; this . update ( ) ; } ) ) ; if ( vs . window . activeTextEditor ) { this . setTrackingFile ( vs . window . activeTextEditor ) ; this . update ( ) ; } } private update ( outline ? ) { if ( ! this . activeEditor ) return ; if ( ! outline ) outline = openFileTracker . getFlutterOutlineFor ( this . activeEditor . document . uri ) ; if ( ! outline ) return ; const results = this . computer . compute ( this . activeEditor . document , outline ) ; for ( const iconName of Object . keys ( results ) ) { if ( ! this . decorationTypes [ iconName ] ) this . decorationTypes [ iconName ] = vs . window . createTextEditorDecorationType ( { gutterIconPath : vs . Uri . parse ( iconUrlFormat . replace ( "s" , iconName ) ) , gutterIconSize : "s" , } ) ; } for ( const iconName of Object . keys ( this . decorationTypes ) ) { this . activeEditor . setDecorations ( this . decorationTypes [ iconName ] , results [ iconName ] || [ ] , ) ; } } private setTrackingFile ( editor : vs . TextEditor | undefined ) { if ( editor && isAnalyzable ( editor . document ) ) { this . activeEditor = editor ; } else this . activeEditor = undefined ; } public dispose ( ) { this . activeEditor = undefined ; this . subscriptions . forEach ( ( s ) => s . dispose ( ) ) ; } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O O O O O O O O $IconRangeComputer$ O $any$ O O $any$ O O $any$ O $any$ O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O O O O O $Logger$ O O O $Analyzer$ O O O O $IconRangeComputer$ O O $any$ O $Logger$ O O O O $any[]$ O $number$ O O O $Analyzer$ O $any$ O O O $FlutterOutlineNotification$ O O O O O O O $any$ O $string$ O O O $any$ O $any$ O $any$ O O $FlutterOutlineNotification$ O $string$ O O O O $void$ O $FlutterOutlineNotification$ O $FlutterOutline$ O O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O O $void$ O $any$ O O O O $void$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O O O O $void$ O O O O O O $void$ O $FlutterOutline$ $FlutterOutline$ O O O O O O O $any$ O O O O O O $FlutterOutline$ O $FlutterOutline$ O O O $FlutterOutline$ O O O $any$ O $any$ O $any$ O O O O O $FlutterOutline$ O O O O $complex$ O O O $IconRangeComputer$ O $complex$ O O O $any$ O $any$ O $FlutterOutline$ O O O O O $string$ O $ObjectConstructor$ O $complex$ O $complex$ O O O O O O O O $complex$ O $string$ O O O O $complex$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O $string$ O O O $string$ O O O O O O O O O O $string$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O O O O $any$ O $any$ O O O $complex$ O $string$ O O $complex$ O $string$ O O O O O O O O O O $void$ O $any$ O $any$ O $any$ O O O O O O $any$ O $boolean$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $undefined$ O O O $void$ O O O O O $any$ O $undefined$ O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O
import * as vs from "s" ; export class DocumentPositionTracker implements vs . Disposable { private readonly disposables : vs . Disposable [ ] = [ ] ; private readonly tracker : DocumentOffsetTracker = new DocumentOffsetTracker ( ) ; private readonly positionMap : Map < vs . Position , number > = new Map < vs . Position , number > ( ) ; private onPositionsChangedEmitter = new vs . EventEmitter < [ vs . TextDocument , Map < vs . Position , vs . Position > ] > ( ) ; public readonly onPositionsChanged = this . onPositionsChangedEmitter . event ; constructor ( ) { this . disposables . push ( this . tracker ) ; this . tracker . onOffsetsChanged ( ( [ doc , offsets ] ) => { const newPositions = new Map < vs . Position , vs . Position > ( ) ; for ( const position of this . positionMap . keys ( ) ) { const currentOffset = this . positionMap . get ( position ) ! ; const newOffset = offsets . get ( currentOffset ) ; if ( newOffset ) newPositions . set ( position , doc . positionAt ( newOffset ) ) ; else newPositions . delete ( position ) ; } this . onPositionsChangedEmitter . fire ( [ doc , newPositions ] ) ; } ) ; } public clear ( ) { this . positionMap . clear ( ) ; this . tracker . clear ( ) ; } public trackDoc ( document : vs . TextDocument , positions : vs . Position [ ] ) { this . positionMap . clear ( ) ; for ( const position of positions ) this . positionMap . set ( position , document . offsetAt ( position ) ) ; this . tracker . trackDoc ( document , [ ... this . positionMap . values ( ) ] ) ; } public dispose ( ) { this . disposables . forEach ( ( s ) => s . dispose ( ) ) ; } } export class DocumentOffsetTracker implements vs . Disposable { private readonly disposables : vs . Disposable [ ] = [ ] ; private document : vs . TextDocument | undefined ; private readonly offsetMap : Map < number , number > = new Map < number , number > ( ) ; private onOffsetsChangedEmitter = new vs . EventEmitter < [ vs . TextDocument , Map < number , number > ] > ( ) ; public readonly onOffsetsChanged = this . onOffsetsChangedEmitter . event ; constructor ( ) { this . disposables . push ( vs . workspace . onDidChangeTextDocument ( ( e ) => this . handleUpdate ( e ) ) ) ; } public trackDoc ( document : vs . TextDocument , offsets : number [ ] ) { this . document = document ; this . offsetMap . clear ( ) ; for ( const offset of offsets ) this . offsetMap . set ( offset , offset ) ; } public clear ( ) { this . document = undefined ; this . offsetMap . clear ( ) ; } private handleUpdate ( e : vs . TextDocumentChangeEvent ) { if ( e . document !== this . document ) return ; for ( const offset of [ ... this . offsetMap . keys ( ) ] ) { const currentOffset = this . offsetMap . get ( offset ) ! ; const newOffset = this . updateOffset ( currentOffset , e ) ; if ( newOffset ) this . offsetMap . set ( offset , newOffset ) ; else this . offsetMap . delete ( offset ) ; } this . onOffsetsChangedEmitter . fire ( [ e . document , this . offsetMap ] ) ; } private updateOffset ( offset , change : vs . TextDocumentChangeEvent ) : number | undefined { if ( change . contentChanges . find ( ( edit ) => edit . rangeOffset < offset && edit . rangeOffset + edit . rangeLength > offset ) ) { return undefined ; } const totalDiff = change . contentChanges . filter ( ( edit ) => edit . rangeOffset + edit . rangeLength <= offset ) . map ( ( edit ) => edit . text . length - edit . rangeLength ) . reduce ( ( total , n ) => total + n , 0 ) ; return offset + totalDiff ; } public dispose ( ) { this . disposables . forEach ( ( s ) => s . dispose ( ) ) ; } }	O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O O O O O O O O $DocumentOffsetTracker$ O $any$ O O $any$ O O O O O $complex$ O $MapConstructor$ O $any$ O $any$ O O O O O $MapConstructor$ O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $MapConstructor$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O O O O O O $any[]$ O $number$ O O O $DocumentOffsetTracker$ O O O O $DocumentOffsetTracker$ O $any$ O O O $any$ O $any$ O O O O O $complex$ O O $MapConstructor$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $complex$ O $IterableIterator<any>$ O O O O O $number$ O O O $complex$ O $number$ O $any$ O O O O $any$ O $any$ O $any$ O $number$ O O O O $any$ O $complex$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O $complex$ O $boolean$ O $any$ O O O O O $any$ O $any$ O O $any$ O $complex$ O O O O O O O O $void$ O O O O O $complex$ O $void$ O O O O O $DocumentOffsetTracker$ O $void$ O O O O O $void$ O $any$ O $any$ O $any$ O $any[]$ O $any$ O $any$ O O O O O O $complex$ O $void$ O O O O O O $any$ O $any[]$ O O O $complex$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O $DocumentOffsetTracker$ O $void$ O $any$ O O O O O $complex$ O $IterableIterator<number>$ O O O O O O O $void$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $complex$ O $MapConstructor$ O O O O O O O $MapConstructor$ O O O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $MapConstructor$ O O O O O O O O O O O O $any$ O O O $any$ O $any$ O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O $number[]$ O O O O O O O O $any$ O $any$ O O O $complex$ O $void$ O O O O O O $number$ O $number[]$ O O O $complex$ O $complex$ O $number$ O $number$ O O O O $void$ O O O O O $any$ O $undefined$ O O O $complex$ O $void$ O O O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O O O O O O $number$ O O O O O $complex$ O $IterableIterator<number>$ O O O O O O $number$ O O O $complex$ O $number$ O $number$ O O O O $number$ O O O $number$ O $number$ O $any$ O O O O $number$ O O O $complex$ O $complex$ O $number$ O $number$ O O O O O $complex$ O $boolean$ O $number$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $complex$ O O O O O $number$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $number$ O $any$ O $any$ O $any$ O $any$ O $number$ O O O O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $number$ O O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $number$ O $any$ O O O $void$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O
import * as vs from "s" ; import { FlutterOutline } from "s" ; import { flatMap } from "s" ; import { DocumentPositionTracker } from "s" ; import { fsPath } from "s" ; import { Analyzer } from "s" ; import { openFileTracker } from "s" ; import { config } from "s" ; const nonBreakingSpace = "s" ; const verticalLine = "s" ; const horizontalLine = "s" ; const bottomCorner = "s" ; const middleCorner = "s" ; export class FlutterUiGuideDecorations implements vs . Disposable { private disposables : vs . Disposable [ ] = [ ] ; private tracker : WidgetGuideTracker | undefined ; private readonly borderDecoration = vs . window . createTextEditorDecorationType ( { rangeBehavior : vs . DecorationRangeBehavior . OpenOpen , } ) ; constructor ( private readonly analyzer ) { this . disposables . push ( vs . window . onDidChangeActiveTextEditor ( ( e ) => this . buildForTextEditor ( e ) ) ) ; if ( config . previewFlutterUiGuidesCustomTracking ) { this . tracker = new WidgetGuideTracker ( ) ; this . disposables . push ( this . tracker ) ; this . tracker . onGuidesChanged ( ( [ doc , guides ] ) => this . buildFromUpdatedGuides ( doc , guides ) ) ; } if ( vs . window . activeTextEditor ) this . buildForTextEditor ( vs . window . activeTextEditor ) ; this . disposables . push ( this . analyzer . registerForFlutterOutline ( ( on ) => { const editor = vs . window . activeTextEditor ; if ( editor && editor . document && fsPath ( editor . document . uri ) === on . file ) this . buildFromOutline ( editor , on . outline ) ; } ) ) ; } private buildForTextEditor ( editor : vs . TextEditor | undefined ) { if ( editor && editor . document ) this . buildFromOutline ( editor , openFileTracker . getFlutterOutlineFor ( editor . document . uri ) ) ; } private buildFromOutline ( editor : vs . TextEditor , outline : FlutterOutline | undefined ) { if ( this . tracker ) this . tracker . clear ( ) ; if ( ! editor || ! editor . document || ! outline ) return ; if ( editor . document . getText ( ) . length !== outline . length ) return ; const guides = this . extractGuides ( editor . document , outline ) ; if ( this . tracker ) this . tracker . trackDoc ( editor . document , guides ) ; this . renderGuides ( editor , guides , "s" ) ; } private buildFromUpdatedGuides ( doc : vs . TextDocument , guides : WidgetGuide [ ] ) { if ( vs . window . activeTextEditor && vs . window . activeTextEditor . document === doc ) this . renderGuides ( vs . window . activeTextEditor , guides , "s" ) ; } private renderGuides ( editor : vs . TextEditor , guides : WidgetGuide [ ] , color ) { const guidesByLine : { [ key ] : WidgetGuide [ ] ; } = { } ; for ( const guide of guides ) { for ( let line = guide . start . line ; line <= guide . end . line ; line ++ ) { guidesByLine [ line ] = guidesByLine [ line ] || [ ] ; guidesByLine [ line ] . push ( guide ) ; } } const decorations = this . buildDecorations ( editor . document , editor . options . tabSize as number , guidesByLine , color ) ; editor . setDecorations ( this . borderDecoration , decorations ) ; } private buildDecorations ( doc : vs . TextDocument , tabSize , guidesByLine : { [ key ] : WidgetGuide [ ] } , color ) : vs . DecorationOptions [ ] { const decorations : vs . DecorationOptions [ ] = [ ] ; for ( const line of Object . keys ( guidesByLine ) . map ( ( k ) => parseInt ( k , 0 ) ) ) { const lineInfo = doc . lineAt ( line ) ; const firstGuideChar = Math . min ( ... guidesByLine [ line ] . map ( ( g ) => Math . min ( g . start . character , g . end . character ) ) ) ; const lastGuideChar = Math . max ( ... guidesByLine [ line ] . map ( ( g ) => Math . max ( g . start . character , g . end . character ) ) ) ; const lastLineCharacter = lineInfo . range . end . character ; const anchorPoint = Math . max ( lastLineCharacter < firstGuideChar ? 0 : firstGuideChar , 0 ) ; const decorationString : string [ ] = new Array ( lastGuideChar ) . fill ( nonBreakingSpace ) ; for ( const guide of guidesByLine [ line ] ) { if ( line !== guide . end . line ) { if ( decorationString [ guide . start . character ] === nonBreakingSpace ) decorationString [ guide . start . character ] = verticalLine ; else if ( decorationString [ guide . start . character ] === bottomCorner ) decorationString [ guide . start . character ] = middleCorner ; } else { for ( let c = guide . start . character ; c <= guide . end . character ; c ++ ) { if ( c === guide . start . character ) { decorationString [ c ] = bottomCorner ; } else { decorationString [ c ] = horizontalLine ; } } } } decorationString . fill ( nonBreakingSpace , lineInfo . firstNonWhitespaceCharacterIndex , lineInfo . range . end . character ) ; decorationString . splice ( 0 , anchorPoint ) ; const tabAdjustedDecorationString : string [ ] = [ ] ; for ( let i = 0 ; i < decorationString . length ; i ++ ) { tabAdjustedDecorationString . push ( decorationString [ i ] ) ; if ( lineInfo . text [ anchorPoint + i ] === "s" ) { const padCharacter = decorationString [ i ] === horizontalLine || decorationString [ i ] === bottomCorner || decorationString [ i ] === middleCorner ? horizontalLine : nonBreakingSpace ; for ( let c = 0 ; c < tabSize - 0 ; c ++ ) tabAdjustedDecorationString . push ( padCharacter ) ; } } decorations . push ( { range : new vs . Range ( new vs . Position ( line , anchorPoint ) , new vs . Position ( line , anchorPoint ) , ) , renderOptions : { before : { color , contentText : tabAdjustedDecorationString . join ( "s" ) , margin : "s" , width : "s" , } , } , } ) ; } return decorations ; } private firstNonWhitespace ( document : vs . TextDocument , lineNumber ) : vs . Position { return new vs . Position ( lineNumber , document . lineAt ( lineNumber ) . firstNonWhitespaceCharacterIndex , ) ; } private extractGuides ( document : vs . TextDocument , node ) : WidgetGuide [ ] { let guides : WidgetGuide [ ] = [ ] ; if ( node . kind === "s" ) { const parentLine = document . positionAt ( node . offset ) . line ; const childLines = node . children && node . children . map ( ( c ) => document . positionAt ( c . offset ) . line ) . filter ( ( cl ) => cl > parentLine ) ; if ( childLines ) { const startPos = this . firstNonWhitespace ( document , parentLine ) ; childLines . forEach ( ( childLine , i ) => { const firstCodeChar = this . firstNonWhitespace ( document , childLine ) ; guides . push ( new WidgetGuide ( startPos , firstCodeChar ) ) ; } ) ; } } if ( node . children ) guides = guides . concat ( flatMap ( node . children , ( c ) => this . extractGuides ( document , c ) ) ) ; return guides ; } public dispose ( ) { this . disposables . forEach ( ( s ) => s . dispose ( ) ) ; } } export class WidgetGuide { constructor ( public readonly start : vs . Position , public readonly end : vs . Position ) { } } class WidgetGuideTracker implements vs . Disposable { private readonly disposables : vs . Disposable [ ] = [ ] ; private readonly tracker : DocumentPositionTracker = new DocumentPositionTracker ( ) ; private readonly guideMap : Map < WidgetGuide , [ vs . Position , vs . Position ] > = new Map < WidgetGuide , [ vs . Position , vs . Position ] > ( ) ; private onGuidesChangedEmitter = new vs . EventEmitter < [ vs . TextDocument , WidgetGuide [ ] ] > ( ) ; public readonly onGuidesChanged = this . onGuidesChangedEmitter . event ; constructor ( ) { this . disposables . push ( this . tracker ) ; this . tracker . onPositionsChanged ( ( [ doc , positions ] ) => { const newGuides : WidgetGuide [ ] = [ ] ; for ( const guide of this . guideMap . keys ( ) ) { const data = this . guideMap . get ( guide ) ! ; const currentStartPos = data [ 0 ] ; const currentEndPos = data [ 0 ] ; const newStartPos = positions . get ( currentStartPos ) ; const newEndPos = positions . get ( currentEndPos ) ; if ( newStartPos && newEndPos ) newGuides . push ( new WidgetGuide ( newStartPos , newEndPos ) ) ; } this . onGuidesChangedEmitter . fire ( [ doc , newGuides ] ) ; } ) ; } public clear ( ) { this . guideMap . clear ( ) ; this . tracker . clear ( ) ; } public trackDoc ( document : vs . TextDocument , guides : WidgetGuide [ ] ) { this . guideMap . clear ( ) ; for ( const guide of guides ) this . guideMap . set ( guide , [ guide . start , guide . end ] ) ; const positions = flatMap ( [ ... this . guideMap . values ( ) ] , ( g ) => [ g [ 0 ] , g [ 0 ] ] ) ; this . tracker . trackDoc ( document , positions ) ; } public dispose ( ) { this . disposables . forEach ( ( s ) => s . dispose ( ) ) ; } }	O O O $any$ O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O O O O O O O O $Config$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O $WidgetGuideTracker$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $Analyzer$ O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O O O $Config$ O $boolean$ O O O O $WidgetGuideTracker$ O O $any$ O O O O O $any[]$ O $number$ O O O $WidgetGuideTracker$ O O O O $WidgetGuideTracker$ O $any$ O O O $any$ O $any$ O O O O O $void$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O O $any[]$ O $number$ O O O $Analyzer$ O $any$ O O $FlutterOutlineNotification$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O $FlutterOutlineNotification$ O $string$ O O O $void$ O $any$ O $FlutterOutlineNotification$ O $FlutterOutline$ O O O O O O O O $void$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O O O $FlutterOutline$ O $any$ O $any$ O $any$ O O O O O $void$ O $any$ O $any$ O $any$ O $FlutterOutline$ O $any$ O O O O O O O O $WidgetGuideTracker$ O O O $WidgetGuideTracker$ O $void$ O O O O O O $any$ O O $any$ O $any$ O O $FlutterOutline$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $FlutterOutline$ O $number$ O O O O $WidgetGuide[]$ O O O $WidgetGuide[]$ O $any$ O $any$ O $FlutterOutline$ O O O O O O $WidgetGuideTracker$ O O O $WidgetGuideTracker$ O $void$ O $any$ O $any$ O $WidgetGuide[]$ O O O O $void$ O $any$ O $WidgetGuide[]$ O O O O O O $void$ O $any$ O $any$ O $any$ O $WidgetGuide[]$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O $WidgetGuide[]$ O O O O O O $void$ O $any$ O $any$ O $any$ O $WidgetGuide[]$ O $any$ O O O $string$ O O O $complex$ O O O $number$ O O $any$ O O O O O O O O O O O $WidgetGuide$ O $WidgetGuide[]$ O O O O O $any$ O $WidgetGuide$ O $any$ O $any$ O $any$ O $WidgetGuide$ O $any$ O $any$ O $any$ O O O $complex$ O $any$ O O $complex$ O $any$ O O O O O $complex$ O $any$ O O $number$ O $WidgetGuide$ O O O O O $any[]$ O O O $any[]$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O $string$ O O $any$ O $any$ O O O $any$ O $any[]$ O O O O $any[]$ O $any$ O $any$ O $any$ O $number$ O $complex$ O O O $number$ O O $any$ O O O O $string$ O O $any$ O $any$ O O O O $any[]$ O $any$ O $any$ O O O O O O O O O $number$ O $ObjectConstructor$ O $complex$ O $complex$ O O $U[]$ O O $string$ O O $number$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $number$ O O O $number$ O $Math$ O $number$ O O $complex$ O $number$ O O $U[]$ O O $WidgetGuide$ O O $Math$ O $number$ O $WidgetGuide$ O $any$ O $any$ O $WidgetGuide$ O $any$ O $any$ O O O O O $number$ O $Math$ O $number$ O O $complex$ O $number$ O O $U[]$ O O $WidgetGuide$ O O $Math$ O $number$ O $WidgetGuide$ O $any$ O $any$ O $WidgetGuide$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $number$ O $Math$ O $number$ O $any$ O $number$ O O O $number$ O O O O O $string[]$ O O O O O O $ArrayConstructor$ O $number$ O O $any[]$ O O O O O O O $WidgetGuide$ O $complex$ O $number$ O O O O O $number$ O $WidgetGuide$ O $any$ O $any$ O O O O $string[]$ O $WidgetGuide$ O $any$ O $any$ O O O O $string[]$ O $WidgetGuide$ O $any$ O $any$ O O O O O O O $string[]$ O $WidgetGuide$ O $any$ O $any$ O O O O $string[]$ O $WidgetGuide$ O $any$ O $any$ O O O O O O O O O O $any$ O $WidgetGuide$ O $any$ O $any$ O $any$ O $WidgetGuide$ O $any$ O $any$ O $any$ O O O O O $any$ O $WidgetGuide$ O $any$ O $any$ O O $string[]$ O $any$ O O O O O O O $string[]$ O $any$ O O O O O O O O $string[]$ O $string[]$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $string[]$ O $complex$ O O O $number$ O O O $string[]$ O O O O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O $string[]$ O $number$ O $string[]$ O $number$ O O O O O $any$ O $any$ O $number$ O $number$ O O O O O O O O $string[]$ O $number$ O O O O $string[]$ O $number$ O O O O $string[]$ O $number$ O O O O O O O O O O O $number$ O O O $number$ O $number$ O O O $number$ O O $string[]$ O $number$ O O O O O O $any[]$ O $number$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $number$ O $number$ O O O $any$ O $any$ O $number$ O $number$ O O O O $complex$ O O $complex$ O O $string$ O $string$ O $string[]$ O $string$ O O O O $string$ O O O $string$ O O O O O O O O O O O O $any[]$ O O O $any$ O $any$ O $any$ O $any$ O $number$ O O $any$ O $any$ O O O $any$ O $any$ O $number$ O $any$ O $any$ O $number$ O O $any$ O O O O O $WidgetGuide[]$ O $any$ O $any$ O $any$ O $FlutterOutline$ O O $any$ O O O O $WidgetGuide[]$ O $any$ O O O O O O O O $FlutterOutline$ O $FlutterOutlineKind$ O O O O O $any$ O $any$ O $any$ O $FlutterOutline$ O $number$ O O $any$ O O $any[]$ O $FlutterOutline$ O $FlutterOutline[]$ O $FlutterOutline$ O $FlutterOutline[]$ O $U[]$ O O $FlutterOutline$ O O $any$ O $any$ O $FlutterOutline$ O $number$ O O $any$ O O $complex$ O O $any$ O O $any$ O $any$ O O O O $any[]$ O O O $any$ O O O $any$ O $any$ O $any$ O O $any[]$ O $void$ O O $any$ O $number$ O O O O $any$ O O O $any$ O $any$ O $any$ O O $WidgetGuide[]$ O $number$ O O $any$ O $any$ O $any$ O O O O O O O O O O $FlutterOutline$ O $FlutterOutline[]$ O $WidgetGuide[]$ O $WidgetGuide[]$ O $complex$ O O O $FlutterOutline$ O $FlutterOutline[]$ O O $FlutterOutline$ O O O O $WidgetGuide[]$ O $any$ O $FlutterOutline$ O O O O O $WidgetGuide[]$ O O O $void$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O O O O O O O O $DocumentPositionTracker$ O $any$ O O $any$ O O O O O $complex$ O $MapConstructor$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $MapConstructor$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O $any$ O $any$ O O O O O O O $any[]$ O $number$ O O O $DocumentPositionTracker$ O O O O $DocumentPositionTracker$ O $any$ O O O $any$ O $any$ O O O O O $WidgetGuide[]$ O $any$ O O O O O O O O O $WidgetGuide$ O O O $complex$ O $IterableIterator<WidgetGuide>$ O O O O O $complex$ O O O $complex$ O $complex$ O $WidgetGuide$ O O O O $any$ O $complex$ O O O O O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $WidgetGuide[]$ O $number$ O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $WidgetGuide[]$ O O O O O O O O $void$ O O O O O $complex$ O $void$ O O O O O $DocumentPositionTracker$ O $void$ O O O O O $void$ O $any$ O $any$ O $any$ O $WidgetGuide[]$ O $any$ O O O O O O $complex$ O $void$ O O O O O O $WidgetGuide$ O $WidgetGuide[]$ O O O $complex$ O $complex$ O $WidgetGuide$ O O $WidgetGuide$ O $any$ O $WidgetGuide$ O $any$ O O O O $any[]$ O O O O O O O $complex$ O $complex$ O O O O O $complex$ O O O $complex$ O O O O $complex$ O O O O O O O O $DocumentPositionTracker$ O $void$ O $any$ O $any[]$ O O O O $void$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O
import * as path from "s" ; import * as vs from "s" ; import { CoverageData } from "s" ; import { Logger } from "s" ; import { uniq } from "s" ; import { extensionPath } from "s" ; import { fsPath } from "s" ; import { DebugCommands } from "s" ; export class HotReloadCoverageDecorations implements vs . Disposable { private subscriptions : vs . Disposable [ ] = [ ] ; private fileState : { [ key ] : { modified : number [ ] , notRun : number [ ] , } , } = { } ; private isDebugging = false ; private readonly modifiedDecorationType = vs . window . createTextEditorDecorationType ( { gutterIconPath : vs . Uri . file ( path . join ( extensionPath , `template` ) ) , isWholeLine : true , rangeBehavior : vs . DecorationRangeBehavior . OpenOpen , } ) ; private readonly notRunDecorationType = vs . window . createTextEditorDecorationType ( { gutterIconPath : vs . Uri . file ( path . join ( extensionPath , `template` ) ) , isWholeLine : true , rangeBehavior : vs . DecorationRangeBehavior . OpenOpen , } ) ; constructor ( private readonly logger , debug ) { this . subscriptions . push ( vs . workspace . onDidChangeTextDocument ( ( e ) => this . onDidChangeTextDocument ( e ) ) ) ; this . subscriptions . push ( debug . onFirstFrame ( ( ) => this . onFirstFrame ( ) ) ) ; this . subscriptions . push ( vs . window . onDidChangeVisibleTextEditors ( ( e ) => this . onDidChangeVisibleTextEditors ( e ) ) ) ; this . subscriptions . push ( debug . onWillHotReload ( ( ) => this . onWillHotReload ( ) ) ) ; this . subscriptions . push ( debug . onWillHotRestart ( ( ) => this . onWillFullRestart ( ) ) ) ; this . subscriptions . push ( vs . debug . onDidStartDebugSession ( ( e ) => this . onDidStartDebugSession ( ) ) ) ; this . subscriptions . push ( vs . debug . onDidTerminateDebugSession ( ( e ) => this . onDidTerminateDebugSession ( ) ) ) ; this . subscriptions . push ( debug . onReceiveCoverage ( ( c ) => this . onReceiveCoverage ( c ) ) ) ; } private async onFirstFrame ( ) < void > { await this . coverageFilesUpdate ( ) ; } private async onDidChangeVisibleTextEditors ( editors : vs . TextEditor [ ] ) < void > { this . redrawDecorations ( editors ) ; await this . coverageFilesUpdate ( ) ; await this . requestCoverageUpdate ( ) ; } private onDidChangeTextDocument ( e : vs . TextDocumentChangeEvent ) { if ( ! this . isDebugging ) return ; const editor = vs . window . visibleTextEditors . find ( ( editor ) => fsPath ( editor . document . uri ) === fsPath ( e . document . uri ) ) ; if ( ! editor ) return ; let fileState = this . fileState [ fsPath ( e . document . uri ) ] ; if ( ! fileState ) { fileState = this . fileState [ fsPath ( e . document . uri ) ] = { modified : [ ] , notRun : [ ] } ; } fileState . modified = fileState . modified . concat ( fileState . notRun ) ; fileState . notRun = [ ] ; for ( const change of e . contentChanges ) { const startLine = change . range . start . line ; const endLine = change . range . end . line ; const linesInRange = endLine - startLine ; const linesInserted = change . text . split ( "s" ) . length - 0 ; const diff = linesInserted - linesInRange ; if ( diff === 0 ) continue ; fileState . modified = this . translateChanges ( fileState . modified , startLine , endLine , diff ) ; } for ( const change of e . contentChanges ) { const originalText = editor . document . getText ( change . range ) ; const newText = change . text ; if ( newText === originalText ) continue ; if ( originalText . trim ( ) === "s" && ! newText ) continue ; if ( ! originalText && newText . trim ( ) === "s" ) continue ; const linesInserted = change . text . split ( "s" ) . length - 0 ; for ( let l = change . range . start . line ; l <= change . range . start . line + linesInserted ; l ++ ) fileState . modified . push ( l ) ; } fileState . modified = uniq ( fileState . modified ) ; fileState . modified = fileState . modified . filter ( ( lineNumber ) => { try { const lineText = editor . document . lineAt ( lineNumber ) . text . trim ( ) ; if ( lineText === "s" || lineText === "s" || lineText === "s" || lineText === "s" || lineText . startsWith ( "s" ) || lineText . startsWith ( "s" ) ) return false ; return true ; } catch ( e ) { this . logger . error ( e ) ; return false ; } } ) ; this . redrawDecorations ( [ editor ] ) ; } private translateChanges ( lines : number [ ] , startLine , endLine , diff ) : number [ ] { return lines . map ( ( l ) => { if ( startLine >= l ) { return l ; } else if ( startLine <= l && endLine >= l ) { return undefined ; } else { return l + diff ; } } ) . filter ( ( l ) => l ) ; } private async onWillHotReload ( ) < void > { for ( const file of Object . keys ( this . fileState ) ) { const fileState = this . fileState [ file ] ; fileState . modified . forEach ( ( r ) => fileState . notRun . push ( r ) ) ; fileState . modified . length = 0 ; } await this . coverageFilesUpdate ( ) ; this . redrawDecorations ( vs . window . visibleTextEditors ) ; } private onWillFullRestart ( ) { this . clearAllMarkers ( ) ; } private onDidStartDebugSession ( ) { this . isDebugging = true ; } private onDidTerminateDebugSession ( ) { this . isDebugging = false ; this . clearAllMarkers ( ) ; } private clearAllMarkers ( ) { for ( const file of Object . keys ( this . fileState ) ) { delete this . fileState [ file ] ; } this . redrawDecorations ( vs . window . visibleTextEditors ) ; } private redrawDecorations ( editors : vs . TextEditor [ ] ) { if ( ! editors ) return ; for ( const editor of editors ) { const fileState = this . fileState [ fsPath ( editor . document . uri ) ] ; editor . setDecorations ( this . modifiedDecorationType , fileState ? this . toRanges ( editor , fileState . modified ) : [ ] , ) ; editor . setDecorations ( this . notRunDecorationType , fileState ? this . toRanges ( editor , fileState . notRun ) : [ ] , ) ; } } private toRanges ( editor : vs . TextEditor , lines : number [ ] ) : vs . Range [ ] { return lines . map ( ( l ) => editor . document . lineAt ( l ) . range ) ; } private async coverageFilesUpdate ( ) < void > { if ( ! this . isDebugging ) return ; const openFilesWithChanges = vs . window . visibleTextEditors . map ( ( e ) => fsPath ( e . document . uri ) ) . filter ( ( file ) => this . fileState [ file ] && this . fileState [ file ] . notRun . length !== 0 ) ; await vs . commands . executeCommand ( "s" , openFilesWithChanges , ) ; } private async requestCoverageUpdate ( ) < void > { if ( ! this . isDebugging ) return ; const hasAnyChanges = ! ! Object . keys ( this . fileState ) . find ( ( file ) => this . fileState [ file ] . notRun . length !== 0 ) ; if ( hasAnyChanges ) await vs . commands . executeCommand ( "s" ) ; } private onReceiveCoverage ( coverageData : CoverageData [ ] ) { for ( const data of coverageData ) { const fileState = this . fileState [ fsPath ( data . scriptPath ) ] ; if ( ! fileState ) continue ; const editor = vs . window . visibleTextEditors . find ( ( editor ) => fsPath ( editor . document . uri ) === data . scriptPath ) ; for ( const line of data . hitLines ) { fileState . notRun = fileState . notRun . filter ( ( l ) => l !== line - 0 ) ; } this . redrawDecorations ( [ editor ] ) ; } } public dispose ( ) { this . subscriptions . forEach ( ( s ) => s . dispose ( ) ) ; } }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $T[]$ O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O $complex$ O O O $string$ O O O $number[]$ O O O O O $number[]$ O O O O O O O O O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $Logger$ O $DebugCommands$ O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O O O $any[]$ O $number$ O $DebugCommands$ O $any$ O O O O O O $Promise<void>$ O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $Promise<void>$ O $any$ O O O O O O $any[]$ O $number$ O $DebugCommands$ O $any$ O O O O O O $Promise<void>$ O O O O O O O $any[]$ O $number$ O $DebugCommands$ O $any$ O O O O O O $void$ O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O O O O O O O $any[]$ O $number$ O $DebugCommands$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O O O O $Promise$ O O O O O O O O O $Promise<void>$ O O O O O O $Promise$ O $any[]$ O $any$ O $any$ O O O O O O O O O $void$ O $any[]$ O O O O O $Promise<void>$ O O O O O O $Promise<void>$ O O O O O $void$ O $any$ O $any$ O $any$ O O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $string$ O $any$ O $any$ O $any$ O O $string$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $complex$ O O O $complex$ O $string$ O $any$ O $any$ O $any$ O O O O O O $complex$ O O $complex$ O O O $complex$ O $string$ O $any$ O $any$ O $any$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O $complex$ O $number[]$ O $complex$ O $number[]$ O $complex$ O $complex$ O $number[]$ O O $complex$ O $number[]$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $number$ O $any$ O $any$ O O $number$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $number$ O $number$ O $number$ O O O $number$ O O O O O $complex$ O $number[]$ O O O $number[]$ O $complex$ O $number[]$ O $any$ O $any$ O $number$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $number$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $number$ O $any$ O O $complex$ O $number[]$ O $number$ O $any$ O O O $complex$ O $number[]$ O $T[]$ O $complex$ O $number[]$ O O $complex$ O $number[]$ O $complex$ O $number[]$ O $complex$ O O $number$ O O O O O O $any$ O $any$ O $any$ O $any$ O $number$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O $any$ O O O O $Logger$ O $void$ O $any$ O O O O O O O O O O O $void$ O O $any$ O O O O O $number[]$ O $number[]$ O O O O O $number$ O $number$ O $number$ O O O O O O O $number[]$ O $U[]$ O O $number$ O O O O O $number$ O $number$ O O O $number$ O O O O O $number$ O $number$ O $number$ O $number$ O O O $undefined$ O O O O O $number$ O $number$ O O O O O $complex$ O O $number$ O O $number$ O O O O O $Promise$ O O O O O O O O O $string$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O O O $complex$ O O O $complex$ O $string$ O O $complex$ O $number[]$ O $void$ O O $number$ O O $complex$ O $number[]$ O $number$ O $number$ O O O $complex$ O $number[]$ O $number$ O O O O O O O $Promise<void>$ O O O O O $void$ O $any$ O $any$ O $any$ O O O O $void$ O O O O O $void$ O O O O O $void$ O O O O O $boolean$ O O O O O $void$ O O O O O $boolean$ O O O O O $void$ O O O O O $void$ O O O O O O $string$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O O O O O $complex$ O $string$ O O O O O $void$ O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O $any$ O $any$ O O O O O O O $any[]$ O O O O O O $any$ O $any[]$ O O O $complex$ O O O $complex$ O $string$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $complex$ O O O $any[]$ O $any$ O $complex$ O $number[]$ O O O O O O O $any$ O $any$ O O O $any$ O $complex$ O O O $any[]$ O $any$ O $complex$ O $number[]$ O O O O O O O O O O $any[]$ O $any$ O $any$ O $any$ O $number[]$ O O O O O O $any$ O $any$ O O O O $number[]$ O $U[]$ O O $number$ O O $any$ O $any$ O $any$ O $number$ O O $any$ O O O O O $Promise$ O O O O O O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $string$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O O $complex$ O $any$ O O O O $complex$ O $any$ O O $number[]$ O $number$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $Promise$ O O O O O O O O O O O $boolean$ O O O O $boolean$ O O O $ObjectConstructor$ O $complex$ O O O $complex$ O O $complex$ O O $string$ O O O O $complex$ O $string$ O O $number[]$ O $number$ O O O O O O $boolean$ O O $any$ O $any$ O $any$ O O O O O O $void$ O $CoverageData[]$ O $any$ O O O O O O O $CoverageData$ O $CoverageData[]$ O O O $complex$ O O O $complex$ O $string$ O $CoverageData$ O $string$ O O O O O O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $string$ O $any$ O $any$ O $any$ O O $CoverageData$ O $string$ O O O O O $number$ O $CoverageData$ O $number[]$ O O $complex$ O $number[]$ O $complex$ O $number[]$ O $complex$ O O $number$ O O $number$ O $number$ O O O O O O O $void$ O O $any$ O O O O O O $void$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O
import { ExtensionContext , window } from "s" ; import { DaemonLog , ShowMessage } from "s" ; import { IFlutterDaemon , Logger } from "s" ; import { getChannel } from "s" ; export function setUpDaemonMessageHandler ( logger , context , daemon ) { context . subscriptions . push ( daemon . registerForDaemonLog ( ( l ) => { const channel = getChannel ( "s" ) ; channel . appendLine ( `template` ) ; } ) ) ; context . subscriptions . push ( daemon . registerForDaemonShowMessage ( ( l ) => { const title = l . title . trim ( ) . endsWith ( "s" ) ? l . title . trim ( ) : `template` ; const message = `template` . trim ( ) ; switch ( l . level ) { case "s" : window . showInformationMessage ( message ) ; break ; case "s" : window . showWarningMessage ( message ) ; break ; case "s" : window . showErrorMessage ( message ) ; break ; default : logger . warn ( `template` ) ; } } ) ) ; }	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O $Logger$ O $ExtensionContext$ O $IFlutterDaemon$ O O $any$ O $any$ O $any$ O $IFlutterDaemon$ O $IAmDisposable$ O O $DaemonLog$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $IFlutterDaemon$ O $IAmDisposable$ O O $ShowMessage$ O O O O $string$ O $ShowMessage$ O $string$ O $string$ O O O $boolean$ O O O O $ShowMessage$ O $string$ O $string$ O O O O O O $string$ O O O $string$ O O O O O $ShowMessage$ O O O O O O O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $string$ O O O O O O $Logger$ O $void$ O O O O O O O O O O
import * as vs from "s" ; import { ProgressLocation } from "s" ; import { DaemonCapabilities } from "s" ; import { isChromeOS } from "s" ; import { LogCategory } from "s" ; import * as f from "s" ; import { IFlutterDaemon , Logger } from "s" ; import { CategoryLogger , logProcess } from "s" ; import { UnknownNotification , UnknownResponse } from "s" ; import { PromiseCompleter } from "s" ; import { config } from "s" ; import { FLUTTER_SUPPORTS_ATTACH } from "s" ; import { StdIOService } from "s" ; import { reloadExtension } from "s" ; import { globalFlutterArgs , safeSpawn } from "s" ; export class FlutterDaemon extends StdIOService < UnknownNotification > implements IFlutterDaemon { private hasStarted = false ; private startupReporter : vs . Progress < { message ? : string ; increment ? : number } > ; private daemonStartedCompleter = new PromiseCompleter ( ) ; public capabilities : DaemonCapabilities = DaemonCapabilities . empty ; constructor ( logger , flutterBinPath , projectFolder ) { super ( new CategoryLogger ( logger , LogCategory . FlutterDaemon ) , config . maxLogLineLength , true ) ; this . registerForDaemonConnected ( ( e ) => { this . additionalPidsToTerminate . push ( e . pid ) ; this . capabilities . version = e . version ; vs . commands . executeCommand ( "s" , FLUTTER_SUPPORTS_ATTACH , this . capabilities . canFlutterAttach ) ; this . deviceEnable ( ) ; } ) ; const flutterAdditionalArgs = config . for ( vs . Uri . file ( projectFolder ) ) . flutterAdditionalArgs ; const args = globalFlutterArgs . concat ( flutterAdditionalArgs ) . concat ( [ "s" ] ) ; this . createProcess ( projectFolder , flutterBinPath , args ) ; if ( isChromeOS && config . flutterAdbConnectOnChromeOs ) { logger . info ( "s" ) ; const adbConnectProc = safeSpawn ( undefined , "s" , [ "s" , "s" ] ) ; logProcess ( logger , LogCategory . General , adbConnectProc ) ; } } public dispose ( ) { super . dispose ( ) ; } protected sendMessage < T > ( json ) { try { super . sendMessage ( json ) ; } catch ( e ) { reloadExtension ( "s" , undefined , true ) ; throw e ; } } protected shouldHandleMessage ( message ) { if ( message . startsWith ( "s" ) && message . endsWith ( "s" ) ) { if ( ! this . hasStarted ) { this . hasStarted = true ; this . daemonStartedCompleter . resolve ( ) ; } return true ; } return false ; } private static readonly outOfDateWarning = new RegExp ( "s" ) ; private static readonly newVersionMessage = "s" ; private hasShownStartupError = false ; protected async processUnhandledMessage ( message ) < void > { let upgradeMessage : string | undefined ; const matches = FlutterDaemon . outOfDateWarning . exec ( message ) ; if ( matches && matches . length === 0 ) upgradeMessage = `template` ; else if ( message . indexOf ( FlutterDaemon . newVersionMessage ) !== - 0 ) upgradeMessage = "s" ; if ( upgradeMessage ) { if ( await vs . window . showWarningMessage ( upgradeMessage , "s" ) ) vs . commands . executeCommand ( "s" ) ; return ; } if ( ! this . hasShownStartupError && message . startsWith ( "s" ) ) { this . logger . error ( message , LogCategory . FlutterDaemon ) ; vs . window . showErrorMessage ( message ) ; this . hasShownStartupError = true ; return ; } if ( ( message . startsWith ( "s" ) || message . startsWith ( "s" ) || message . startsWith ( "s" ) || message . startsWith ( "s" ) ) && ! message . startsWith ( "s" ) ) { if ( ! this . hasStarted ) { if ( this . startupReporter ) { this . startupReporter . report ( { message } ) ; } else { vs . window . withProgress ( { location : ProgressLocation . Notification , title : "s" , } , ( progressReporter ) => { this . startupReporter = progressReporter ; this . startupReporter . report ( { message } ) ; return this . daemonStartedCompleter . promise ; } ) ; } } } } protected handleNotification ( evt ) { switch ( evt . event ) { case "s" : this . notify ( this . daemonConnectedSubscriptions , evt . params as f . DaemonConnected ) ; break ; case "s" : this . notify ( this . deviceAddedSubscriptions , evt . params as f . Device ) ; break ; case "s" : this . notify ( this . deviceRemovedSubscriptions , evt . params as f . Device ) ; break ; case "s" : this . notify ( this . daemonLogMessageSubscriptions , evt . params as f . DaemonLogMessage ) ; break ; case "s" : this . notify ( this . daemonLogSubscriptions , evt . params as f . DaemonLog ) ; break ; case "s" : this . notify ( this . daemonShowMessageSubscriptions , evt . params as f . ShowMessage ) ; break ; } } private daemonConnectedSubscriptions : Array < ( notification : f . DaemonConnected ) => void > = [ ] ; private deviceAddedSubscriptions : Array < ( notification : f . Device ) => void > = [ ] ; private deviceRemovedSubscriptions : Array < ( notification : f . Device ) => void > = [ ] ; private daemonLogMessageSubscriptions : Array < ( notification : f . DaemonLogMessage ) => void > = [ ] ; private daemonLogSubscriptions : Array < ( notification : f . DaemonLog ) => void > = [ ] ; private daemonShowMessageSubscriptions : Array < ( notification : f . ShowMessage ) => void > = [ ] ; public deviceEnable ( ) < UnknownResponse > { return this . sendRequest ( "s" ) ; } public getEmulators ( ) < f . Emulator [ ] > { return this . sendRequest ( "s" ) ; } public launchEmulator ( emulatorId ) < void > { return this . sendRequest ( "s" , { emulatorId } ) ; } public createEmulator ( name ? ) < { success : boolean , emulatorName : string , error : string } > { return this . sendRequest ( "s" , { name } ) ; } public getSupportedPlatforms ( projectRoot ) < f . SupportedPlatformsResponse > { return this . sendRequest ( "s" , { projectRoot } ) ; } public registerForDaemonConnected ( subscriber : ( notification : f . DaemonConnected ) => void ) : vs . Disposable { return this . subscribe ( this . daemonConnectedSubscriptions , subscriber ) ; } public registerForDeviceAdded ( subscriber : ( notification : f . Device ) => void ) : vs . Disposable { return this . subscribe ( this . deviceAddedSubscriptions , subscriber ) ; } public registerForDeviceRemoved ( subscriber : ( notification : f . Device ) => void ) : vs . Disposable { return this . subscribe ( this . deviceRemovedSubscriptions , subscriber ) ; } public registerForDaemonLogMessage ( subscriber : ( notification : f . DaemonLogMessage ) => void ) : vs . Disposable { return this . subscribe ( this . daemonLogMessageSubscriptions , subscriber ) ; } public registerForDaemonLog ( subscriber : ( notification : f . DaemonLog ) => void ) : vs . Disposable { return this . subscribe ( this . daemonLogSubscriptions , subscriber ) ; } public registerForDaemonShowMessage ( subscriber : ( notification : f . ShowMessage ) => void ) : vs . Disposable { return this . subscribe ( this . daemonShowMessageSubscriptions , subscriber ) ; } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $void$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $Config$ O O O O O O O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O O $string[]$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O $boolean$ O O O O $any$ O $any$ O $any$ O O $string$ O O O O $number$ O O O O O O O $PromiseCompleter<unknown>$ O O $any$ O O O O $DaemonCapabilities$ O $any$ O $any$ O $DaemonCapabilities$ O O O $Logger$ O $string$ O $string$ O O O O O $any$ O $Logger$ O $any$ O $LogCategory.FlutterDaemon$ O O $Config$ O $number$ O O O O O O $any$ O O $DaemonConnected$ O O O O O $number[]$ O $number$ O $DaemonConnected$ O $number$ O O O O $DaemonCapabilities$ O $string$ O $DaemonConnected$ O $string$ O $any$ O $any$ O $any$ O O O O O O O $DaemonCapabilities$ O $boolean$ O O O O $any$ O O O O O O O $string[]$ O $Config$ O $ResourceConfig$ O $any$ O $any$ O $any$ O $string$ O O O $string[]$ O O $string[]$ O $string[]$ O $complex$ O $string[]$ O O $complex$ O O O O O O O O $void$ O $string$ O $string$ O $string[]$ O O O O $any$ O $Config$ O $boolean$ O O $Logger$ O $void$ O O O O O $any$ O $any$ O $undefined$ O O O O O O O O O O $void$ O $Logger$ O $any$ O $LogCategory.General$ O $any$ O O O O O $void$ O O O O O $void$ O O O O O $void$ O $any$ O O $string$ O O O O O O $void$ O $string$ O O O O O $any$ O O $Promise<void>$ O O O $undefined$ O O O O O $any$ O O O O $boolean$ O $string$ O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O O O O O O O $boolean$ O O O O $boolean$ O O O O O $PromiseCompleter<unknown>$ O $void$ O O O O O O O O O O O O O O O $RegExp$ O O $RegExpConstructor$ O O O O O O O O O O O O $boolean$ O O O O O $Promise$ O $string$ O O O O O O $string$ O O O O O O $RegExpExecArray$ O $any$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O $RegExpExecArray$ O $number$ O O O $string$ O O O O O O $string$ O $number$ O $any$ O O O O O O O $string$ O O O O O $string$ O O O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $boolean$ O $string$ O $boolean$ O O O O O O O $Logger$ O $void$ O $string$ O $any$ O $LogCategory.FlutterDaemon$ O O $any$ O $any$ O $any$ O $string$ O O O O $boolean$ O O O O O O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O O O $string$ O $boolean$ O O O O O O O O O O $boolean$ O O O O O O $any$ O O O O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O $string$ O O O O O O $PromiseCompleter<unknown>$ O $Promise<unknown>$ O O O O O O O O O $void$ O $UnknownNotification$ O O O O $UnknownNotification$ O $string$ O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O $any$ O O O O O O O $void)[]$ O $ArrayConstructor$ O O $DaemonConnected$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $Device$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $Device$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $DaemonLogMessage$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $DaemonLog$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $ShowMessage$ O $any$ O $any$ O O O O O O O O O $Thenable$ O O O $any$ O O O O O $Promise<TResp>$ O O O O O O $Thenable$ O O O $any$ O $any$ O O O O O O O $Promise<TResp>$ O O O O O O $Thenable$ O $string$ O O O O O O O O $Promise<TResp>$ O O O O $string$ O O O O O $Thenable$ O $string$ $string$ O O O $boolean$ O O O $string$ O O O $string$ O O O O O O O O $Promise<TResp>$ O O O O $string$ O O O O O $Thenable$ O $string$ O O $any$ O $any$ O O O O O $Promise<TResp>$ O O O O $string$ O O O O O $any$ O $void$ O O $DaemonConnected$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $any$ O $void$ O O $Device$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $any$ O $void$ O O $Device$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $any$ O $void$ O O $DaemonLogMessage$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $any$ O $void$ O O $DaemonLog$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $any$ O $void$ O O $ShowMessage$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O
import * as path from "s" ; import { commands , debug , DiagnosticSeverity , ExtensionContext , languages , workspace } from "s" ; import { restartReasonSave } from "s" ; import { FlutterService } from "s" ; import { fsPath } from "s" ; import { DebugCommands } from "s" ; import { config } from "s" ; import { isAnalyzableAndInWorkspace } from "s" ; export function setUpHotReloadOnSave ( context , debugCommands ) { let hotReloadDelayTimer : NodeJS . Timer | undefined ; context . subscriptions . push ( workspace . onDidSaveTextDocument ( ( td ) => { if ( ! debug . activeDebugSession ) return ; const shouldHotReload = debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotReload ) && config . flutterHotReloadOnSave ; const shouldHotRestart = ! debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotReload ) && debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotRestart ) && config . flutterHotRestartOnSave ; if ( ! shouldHotReload && ! shouldHotRestart ) return ; const commandToRun = shouldHotReload ? "s" : "s" ; if ( ! isAnalyzableAndInWorkspace ( td ) || path . extname ( fsPath ( td . uri ) ) !== "s" ) return ; const errors = languages . getDiagnostics ( td . uri ) ; const hasErrors = errors && errors . find ( ( d ) => d . source === "s" && d . severity === DiagnosticSeverity . Error ) != null ; if ( hasErrors ) return ; if ( hotReloadDelayTimer ) { clearTimeout ( hotReloadDelayTimer ) ; } hotReloadDelayTimer = setTimeout ( ( ) => { hotReloadDelayTimer = undefined ; commands . executeCommand ( commandToRun , { reason : restartReasonSave } ) ; } , 0 ) ; } ) ) ; }	O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $Config$ O O O O O O $boolean$ O O O O O O $void$ O $ExtensionContext$ O $DebugCommands$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O $boolean$ O $DebugCommands$ O $FlutterVmServiceExtensions$ O $boolean$ O $any$ O $FlutterService.HotReload$ O O $Config$ O $boolean$ O O $boolean$ O O $DebugCommands$ O $FlutterVmServiceExtensions$ O $boolean$ O $any$ O $FlutterService.HotReload$ O O $DebugCommands$ O $FlutterVmServiceExtensions$ O $boolean$ O $any$ O $FlutterService.HotRestart$ O O $Config$ O $boolean$ O O O O $boolean$ O O $boolean$ O O O O O O $boolean$ O O O O O O O O $boolean$ O $any$ O O $any$ O $any$ O $string$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O O O $any$ O O $void$ O $any$ O O O $any$ O $number$ O O O O O $any$ O $undefined$ O $any$ O $any$ O O O O $string$ O O O O O O O O O O O O O O O
import { CancellationToken , CodeAction , CodeActionContext , CodeActionProvider , CodeActionProviderMetadata , Command , DocumentSelector , languages , Range , TextDocument } from "s" ; import { flatMap , uniq } from "s" ; import { sortBy } from "s" ; export class RankingCodeActionProvider implements CodeActionProvider { private codeActionProviders : RankedCodeActionProvider [ ] = [ ] ; public registerProvider ( provider ) { this . codeActionProviders . push ( provider ) ; sortBy ( this . codeActionProviders , ( p ) => p . rank ) ; } get metadata ( ) : CodeActionProviderMetadata { const allKinds = flatMap ( this . codeActionProviders , ( p ) => p . metadata . providedCodeActionKinds || [ ] ) ; return { providedCodeActionKinds : uniq ( allKinds ) } ; } public async provideCodeActions ( document , range , context , token ) < Array < CodeAction | Command > > { const applicableProviders = this . codeActionProviders . filter ( ( p ) => languages . match ( p . selector , document ) ) ; const promises = applicableProviders . map ( ( p ) => p . provideCodeActions ( document , range , context , token ) ) ; const allResults = await Promise . all ( promises ) ; const flatResults = flatMap ( allResults , ( x ) => x || [ ] ) ; return flatResults ; } } export type RankedCodeActionProvider = CodeActionProvider & { selector : DocumentSelector } & { metadata : CodeActionProviderMetadata } & { rank : number } ;	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $T[]$ O O O O O O $T[]$ O O O O O O $any$ O $any$ O O $any[]$ O $any$ O O O O O O O $void$ O $RankedCodeActionProvider$ O O O O $any[]$ O $number$ O $any$ O O $T[]$ O O O $any[]$ O O $any$ O O $any$ O $any$ O O O O $any$ O O O $any$ O O $unknown[]$ O O O O O $any[]$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O O $unknown[]$ O $T[]$ O $unknown[]$ O O O O O O $Promise$ O $TextDocument$ O $Range$ O $CodeActionContext$ O $CancellationToken$ O O $ArrayConstructor$ O $any$ O $any$ O O O O $any[]$ O O O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O $any[]$ O $U[]$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O O $PromiseConstructor$ O O O $any[]$ O O O $unknown[]$ O O O $any[]$ O O $any$ O O $any$ O O O O O O $unknown[]$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $number$ O O O O
import { CancellationToken , CodeAction , CodeActionContext , CodeActionKind , CodeActionProviderMetadata , DocumentSelector , Range , TextDocument } from "s" ; import * as as from "s" ; import { Logger } from "s" ; import { fsPath } from "s" ; import { Analyzer } from "s" ; import { isAnalyzableAndInWorkspace } from "s" ; import { RankedCodeActionProvider } from "s" ; export class AssistCodeActionProvider implements RankedCodeActionProvider { constructor ( private readonly logger , public readonly selector , private readonly analyzer ) { } public readonly rank = 0 ; public readonly metadata : CodeActionProviderMetadata = { providedCodeActionKinds : [ CodeActionKind . Refactor ] , } ; public async provideCodeActions ( document , range , context , token ) < CodeAction [ ] | undefined > { if ( ! isAnalyzableAndInWorkspace ( document ) ) return undefined ; if ( context && context . only && ! CodeActionKind . Refactor . contains ( context . only ) ) return undefined ; try { const assists = await this . analyzer . editGetAssists ( { file : fsPath ( document . uri ) , length : range . end . character - range . start . character , offset : document . offsetAt ( range . start ) , } ) ; return assists . assists . map ( ( assist ) => this . convertResult ( document , assist ) ) ; } catch ( e ) { this . logger . error ( e ) ; } } private convertResult ( document , change : as . SourceChange ) { const title = change . message ; const refactorId = change . id ? CodeActionKind . Refactor . append ( change . id . replace ( "s" , "s" ) ) : CodeActionKind . Refactor ; const action = new CodeAction ( title , refactorId ) ; action . command = { arguments : [ document , change ] , command : "s" , title , } ; return action ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $boolean$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $Logger$ O O O $DocumentSelector$ O O O $Analyzer$ O O O O O O O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O O O O O $Promise$ O $TextDocument$ O $Range$ O $CodeActionContext$ O $CancellationToken$ O O $any$ O O O O O O O O O $boolean$ O $any$ O O O $undefined$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $undefined$ O O O O $EditGetAssistsResponse$ O O O O $Analyzer$ O $Promise<EditGetAssistsResponse>$ O O $string$ O $string$ O $any$ O $any$ O O $number$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $EditGetAssistsResponse$ O $SourceChange[]$ O $U[]$ O O $SourceChange$ O O O O $any$ O $any$ O $SourceChange$ O O O O O O $any$ O O O O $Logger$ O $void$ O $any$ O O O O O $CodeAction$ O $TextDocument$ O $SourceChange$ O $any$ O $any$ O O O $string$ O $SourceChange$ O $string$ O O $any$ O $SourceChange$ O $string$ O $any$ O $any$ O $any$ O $SourceChange$ O $string$ O $complex$ O O O O O O O $any$ O $any$ O O $any$ O O $any$ O $string$ O $any$ O O $any$ O $any$ O O $any[]$ O O $any$ O $SourceChange$ O O $string$ O O O $string$ O O O O $any$ O O O
export const resolvedPromise = Promise . resolve ( true ) ; export async function waitFor < T > ( action : ( ) => T , checkEveryMilliseconds = 0 , tryForMilliseconds = 0 , token ? : { isCancellationRequested : boolean } ) < T | undefined > { let timeRemaining = tryForMilliseconds ; while ( timeRemaining > 0 && ! ( token && token . isCancellationRequested ) ) { const res = action ( ) ; if ( res ) return res ; await new Promise ( ( resolve ) => setTimeout ( resolve , checkEveryMilliseconds ) ) ; timeRemaining -= checkEveryMilliseconds ; } }	O O $Promise<boolean>$ O $PromiseConstructor$ O $complex$ O O O O O O O $Promise$ O $any$ O O $T$ O O O O $any$ O $number$ O O O $number$ O O O $complex$ O O O $boolean$ O O O O O $any$ O O O O O $number$ O $number$ O O O $number$ O O O O O $complex$ O $complex$ O $boolean$ O O O O $T$ O $T$ O O O O O $T$ O O $T$ O O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O $number$ O O O $number$ O $number$ O O O
import * as path from "s" ; import * as vs from "s" ; import { CancellationToken , CompletionContext , CompletionItem , CompletionItemKind , CompletionItemProvider , CompletionList , CompletionTriggerKind , Disposable , MarkdownString , Position , Range , SnippetString , TextDocument } from "s" ; import * as as from "s" ; import { IAmDisposable , Logger } from "s" ; import { flatMap } from "s" ; import { cleanDartdoc } from "s" ; import { resolvedPromise } from "s" ; import { DelayedCompletionItem , LazyCompletionItem } from "s" ; import { fsPath } from "s" ; import { Analyzer } from "s" ; import { hasOverlappingEdits } from "s" ; import { config } from "s" ; export class DartCompletionItemProvider implements CompletionItemProvider , IAmDisposable { private disposables : Disposable [ ] = [ ] ; private cachedCompletions : { [ key ] : as . AvailableSuggestionSet } = { } ; private existingImports : { [ key ] : { [ key ] : { [ key ] : boolean } } } = { } ; constructor ( private readonly logger , private readonly analyzer ) { this . disposables . push ( analyzer . registerForCompletionAvailableSuggestions ( ( n ) => this . storeCompletionSuggestions ( n ) ) ) ; this . disposables . push ( analyzer . registerForCompletionExistingImports ( ( n ) => this . storeExistingImports ( n ) ) ) ; } public async provideCompletionItems ( document , position , token , context , ) < CompletionList | undefined > { const line = document . lineAt ( position . line ) . text . slice ( 0 , position . character ) ; const nextCharacter = document . getText ( new Range ( position , position . translate ( { characterDelta : 0 } ) ) ) . trim ( ) . substr ( 0 , 0 ) ; const conf = config . for ( document . uri ) ; const enableCommitCharacters = conf . enableCompletionCommitCharacters ; const insertArgumentPlaceholders = ! enableCommitCharacters && conf . insertArgumentPlaceholders && this . shouldAllowArgPlaceholders ( line ) ; if ( ! this . shouldAllowCompletion ( line , context ) ) return ; const resp = await this . analyzer . completionGetSuggestionsResults ( { file : fsPath ( document . uri ) , offset : document . offsetAt ( position ) , } ) ; if ( token && token . isCancellationRequested ) { return undefined ; } const includedResults = resp . results . map ( ( r ) => this . convertResult ( document , nextCharacter , enableCommitCharacters , insertArgumentPlaceholders , resp , r ) ) ; const cachedResults = await this . getCachedResults ( document , token , nextCharacter , enableCommitCharacters , insertArgumentPlaceholders , document . offsetAt ( position ) , resp ) ; await resolvedPromise ; if ( token && token . isCancellationRequested ) { return undefined ; } const allResults = [ ... includedResults , ... cachedResults ] ; return new CompletionList ( allResults ) ; } private shouldAllowCompletion ( line , context ) { line = line . trim ( ) ; if ( context . triggerKind === CompletionTriggerKind . TriggerCharacter ) { switch ( context . triggerCharacter ) { case "s" : return line . endsWith ( "s" ) ; case "s" : return line . endsWith ( "s" ) || line . endsWith ( "s" ) ; case "s" : return line . endsWith ( "s" ) || line . endsWith ( "s" ) ; case "s" : case "s" : return line . startsWith ( "s" ) || line . startsWith ( "s" ) || line . startsWith ( "s" ) || line . startsWith ( "s" ) ; } } return true ; } private shouldAllowArgPlaceholders ( line ) { line = line . trim ( ) ; if ( line . startsWith ( "s" ) || line . startsWith ( "s" ) || line . startsWith ( "s" ) || line . startsWith ( "s" ) ) { return false ; } return true ; } private storeCompletionSuggestions ( notification : as . CompletionAvailableSuggestionsNotification ) { if ( notification . changedLibraries ) { for ( const completionSet of notification . changedLibraries ) { this . cachedCompletions [ completionSet . id ] = completionSet ; } } if ( notification . removedLibraries ) { for ( const completionSetID of notification . removedLibraries ) { delete this . cachedCompletions [ completionSetID ] ; } } } private storeExistingImports ( notification : as . CompletionExistingImportsNotification ) { const existingImports = notification . imports ; const alreadyImportedSymbols : { [ key ] : { [ key ] : boolean } } = { } ; for ( const existingImport of existingImports . imports ) { for ( const importedElement of existingImport . elements ) { const elementName = existingImports . elements . strings [ existingImports . elements . names [ importedElement ] ] ; const elementDeclaringLibraryUri = existingImports . elements . strings [ existingImports . elements . uris [ importedElement ] ] ; const importedUri = existingImports . elements . strings [ existingImport . uri ] ; const key = `template` ; if ( ! alreadyImportedSymbols [ key ] ) alreadyImportedSymbols [ key ] = { } ; alreadyImportedSymbols [ key ] [ importedUri ] = true ; } } this . existingImports [ notification . file ] = alreadyImportedSymbols ; } public async resolveCompletionItem ( item , token ) < CompletionItem | undefined > { if ( ! item . suggestion ) { if ( ! item . documentation && item . _documentation ) { item . documentation = item . _documentation ; } return item ; } const res = await this . analyzer . completionGetSuggestionDetails ( { file : item . filePath , id : item . suggestionSetID , label : item . suggestion . label , offset : item . offset , } ) ; if ( token && token . isCancellationRequested ) { return ; } return this . createCompletionItemFromSuggestion ( item . document , item . nextCharacter , item . enableCommitCharacters , item . insertArgumentPlaceholders , item . replacementOffset , item . replacementLength , item . autoImportUri , item . relevance , item . suggestion , res , ) ; } private createCompletionItemFromSuggestion ( document , nextCharacter , enableCommitCharacters , insertArgumentPlaceholders , replacementOffset , replacementLength , displayUri : string | undefined , relevance , suggestion : as . AvailableSuggestion , resolvedResult : as . CompletionGetSuggestionDetailsResponse | undefined , ) { const completionItem = this . makeCompletion ( document , nextCharacter , enableCommitCharacters , insertArgumentPlaceholders , { autoImportUri : displayUri , completionText : ( resolvedResult && resolvedResult . completion ) || suggestion . label , displayText : suggestion . label , elementKind : suggestion . element ? suggestion . element . kind : undefined , isDeprecated : false , kind : undefined , parameterNames : suggestion . parameterNames , parameterType : undefined , parameters : suggestion . element ? suggestion . element . parameters : undefined , relevance , replacementLength , replacementOffset , requiredParameterCount : suggestion . requiredParameterCount , returnType : suggestion . element ? suggestion . element . returnType : undefined , selectionLength : resolvedResult && resolvedResult . change && resolvedResult . change . selection ? 0 : undefined , selectionOffset : resolvedResult && resolvedResult . change && resolvedResult . change . selection ? resolvedResult . change . selection . offset : undefined , } ) ; if ( resolvedResult && resolvedResult . change && resolvedResult . change . edits && resolvedResult . change . edits . length ) { this . appendAdditionalEdits ( completionItem , document , resolvedResult . change ) ; if ( displayUri ) completionItem . detail = `template` + ( completionItem . detail ? `template` : "s" ) ; } if ( resolvedResult && ! completionItem . documentation && completionItem . _documentation ) { completionItem . documentation = completionItem . _documentation ; } return completionItem ; } private async getCachedResults ( document , token , nextCharacter , enableCommitCharacters , insertArgumentPlaceholders , offset , resp : as . CompletionResultsNotification , ) < CompletionItem [ ] > { if ( ! resp . includedSuggestionSets || ! resp . includedElementKinds ) return [ ] ; const existingImports = resp . libraryFile ? this . existingImports [ resp . libraryFile ] : undefined ; const elementKinds : { [ key ] : boolean } = { } ; resp . includedElementKinds . forEach ( ( k ) => elementKinds [ k ] = true ) ; const tagBoosts : { [ key ] : number } = { } ; if ( resp . includedSuggestionRelevanceTags ) resp . includedSuggestionRelevanceTags . forEach ( ( r ) => tagBoosts [ r . tag ] = r . relevanceBoost ) ; const filePath = fsPath ( document . uri ) ; const suggestionSetResults : CompletionItem [ ] [ ] = [ ] ; const usedSuggestionSets : { [ key ] : boolean } = { } ; const includedItems : { [ key ] : boolean ; } = { } ; for ( const includedSuggestionSet of resp . includedSuggestionSets ) { if ( usedSuggestionSets [ includedSuggestionSet . id ] ) continue ; usedSuggestionSets [ includedSuggestionSet . id ] = true ; await resolvedPromise ; if ( token && token . isCancellationRequested ) { return [ ] ; } const suggestionSet = this . cachedCompletions [ includedSuggestionSet . id ] ; if ( ! suggestionSet ) { this . logger . warn ( `template` ) ; return [ ] ; } const unresolvedItems = suggestionSet . items . filter ( ( r ) => elementKinds [ r . element . kind ] ) . filter ( ( suggestion ) => { const key = `template` ; const importingUris = existingImports && existingImports [ key ] ; if ( ! importingUris ) return true ; if ( ! importingUris [ suggestionSet . uri ] ) return false ; const fullItemKey = `template` ; const itemHasAlreadyBeenIncluded = includedItems [ fullItemKey ] ; includedItems [ fullItemKey ] = true ; return ! itemHasAlreadyBeenIncluded ; } ) . map ( ( suggestion ) : DelayedCompletionItem => { let relevanceBoost = 0 ; if ( suggestion . relevanceTags ) suggestion . relevanceTags . forEach ( ( t ) => relevanceBoost = Math . max ( relevanceBoost , tagBoosts [ t ] || 0 ) ) ; const completionItem = this . createCompletionItemFromSuggestion ( document , nextCharacter , enableCommitCharacters , insertArgumentPlaceholders , resp . replacementOffset , resp . replacementLength , undefined , includedSuggestionSet . relevance + relevanceBoost , suggestion , undefined , ) ; const delayedCompletionItem = { autoImportUri : includedSuggestionSet . displayUri || suggestionSet . uri , document , enableCommitCharacters , filePath , insertArgumentPlaceholders , nextCharacter , offset , relevance : includedSuggestionSet . relevance + relevanceBoost , replacementLength : resp . replacementLength , replacementOffset : resp . replacementOffset , suggestion , suggestionSetID : includedSuggestionSet . id , ... completionItem , } ; return delayedCompletionItem ; } ) ; suggestionSetResults . push ( unresolvedItems ) ; } return ( [ ] as vs . CompletionItem [ ] ) . concat ( ... suggestionSetResults ) ; } private convertResult ( document , nextCharacter , enableCommitCharacters , insertArgumentPlaceholders , notification : as . CompletionResultsNotification , suggestion : as . CompletionSuggestion , ) { return this . makeCompletion ( document , nextCharacter , enableCommitCharacters , insertArgumentPlaceholders , { completionText : suggestion . completion , displayText : suggestion . displayText , docSummary : suggestion . docSummary , elementKind : suggestion . element ? suggestion . element . kind : undefined , isDeprecated : suggestion . isDeprecated , kind : suggestion . kind , parameterNames : suggestion . parameterNames , parameterType : suggestion . parameterType , parameters : suggestion . element ? suggestion . element . parameters : undefined , relevance : suggestion . relevance , replacementLength : notification . replacementLength , replacementOffset : notification . replacementOffset , requiredParameterCount : suggestion . requiredParameterCount , returnType : suggestion . returnType || ( suggestion . element ? suggestion . element . returnType : undefined ) , selectionLength : suggestion . selectionLength , selectionOffset : suggestion . selectionOffset , } ) ; } private makeCompletion ( document , nextCharacter , enableCommitCharacters , insertArgumentPlaceholders , suggestion : { autoImportUri ? : string , completionText : string , displayText : string | undefined , docSummary ? : string | undefined , elementKind : as . ElementKind | undefined , isDeprecated : boolean , kind : as . CompletionSuggestionKind | undefined , parameterNames : string [ ] | undefined , parameters : string | undefined , parameterType : string | undefined , relevance : number , replacementLength : number , replacementOffset : number , requiredParameterCount : number | undefined , returnType : string | undefined , selectionLength : number | undefined , selectionOffset : number | undefined , } , ) { const completionItemKind = suggestion . elementKind ? this . getElementKind ( suggestion . elementKind ) : undefined ; let label = suggestion . displayText || suggestion . completionText ; let detail : string | undefined ; const completionText = new SnippetString ( ) ; let triggerCompletion = false ; const nextCharacterIsOpenParen = nextCharacter === "s" ; if ( suggestion . parameters && completionItemKind !== CompletionItemKind . Property && suggestion . kind !== "s" && label . indexOf ( "s" ) === - 0 ) { label += suggestion . parameters . length === 0 ? "s" : "s" ; detail = suggestion . parameters ; const hasParams = suggestion . parameterNames && suggestion . parameterNames . length > 0 ; if ( insertArgumentPlaceholders && hasParams && ! nextCharacterIsOpenParen ) { completionText . appendText ( suggestion . completionText ) ; const args = suggestion . parameterNames ! . slice ( 0 , suggestion . requiredParameterCount ) ; completionText . appendText ( "s" ) ; if ( args . length ) { completionText . appendPlaceholder ( args [ 0 ] ) ; for ( const arg of args . slice ( 0 ) ) { completionText . appendText ( "s" ) ; completionText . appendPlaceholder ( arg ) ; } } else completionText . appendTabstop ( 0 ) ; completionText . appendText ( "s" ) ; } else if ( insertArgumentPlaceholders && ! nextCharacterIsOpenParen ) { completionText . appendText ( suggestion . completionText ) ; completionText . appendText ( "s" ) ; if ( hasParams ) completionText . appendTabstop ( 0 ) ; completionText . appendText ( "s" ) ; } else { completionText . appendText ( suggestion . completionText ) ; } } else if ( suggestion . selectionOffset ) { const before = suggestion . completionText . slice ( 0 , suggestion . selectionOffset ) ; const selection = suggestion . completionText . slice ( suggestion . selectionOffset , suggestion . selectionOffset + ( suggestion . selectionLength || 0 ) ) ; if ( ! selection && suggestion . completionText . slice ( suggestion . selectionOffset - 0 , suggestion . selectionOffset ) === "s" ) triggerCompletion = true ; const after = suggestion . completionText . slice ( suggestion . selectionOffset + ( suggestion . selectionLength || 0 ) ) ; completionText . appendText ( before ) ; if ( selection ) completionText . appendPlaceholder ( selection ) ; else completionText . appendTabstop ( 0 ) ; completionText . appendText ( after ) ; } else { completionText . appendText ( suggestion . completionText ) ; } if ( completionItemKind === CompletionItemKind . Property ) { detail = suggestion . elementKind === "s" ? suggestion . returnType : suggestion . parameters ? suggestion . parameters . substring ( 0 , suggestion . parameters . lastIndexOf ( "s" ) ) : "s" ; } else if ( suggestion . returnType ) { detail = detail ? detail + "s" + suggestion . returnType : suggestion . returnType ; } else if ( suggestion . parameterType ) { detail = suggestion . parameterType ; } if ( label . endsWith ( "s" ) ) label = label . substr ( 0 , label . length - 0 ) . trim ( ) ; const kind = completionItemKind || ( suggestion . kind ? this . getSuggestionKind ( suggestion . kind , label ) : undefined ) ; const docs = cleanDartdoc ( suggestion . docSummary ) ; const completion = new CompletionItem ( label , kind ) ; completion . filterText = label . split ( "s" ) [ 0 ] ; completion . detail = suggestion . isDeprecated || detail ? ( suggestion . isDeprecated ? "s" : "s" ) + ( detail || "s" ) : undefined ; completion . _documentation = docs ? new MarkdownString ( docs ) : undefined ; completion . insertText = completionText ; completion . keepWhitespace = true ; completion . range = new Range ( document . positionAt ( suggestion . replacementOffset ) , document . positionAt ( suggestion . replacementOffset + suggestion . replacementLength ) , ) ; if ( enableCommitCharacters ) completion . commitCharacters = this . getCommitCharacters ( suggestion . kind ) ; const triggerCompletionsFor = [ "s" ] ; if ( triggerCompletionsFor . indexOf ( label ) !== - 0 ) triggerCompletion = true ; if ( suggestion . kind === "s" && label . endsWith ( "s" ) ) triggerCompletion = true ; if ( triggerCompletion ) { completion . command = { command : "s" , title : "s" , } ; } completion . sortText = ( 0 - suggestion . relevance ) . toString ( ) + label . trim ( ) ; return completion ; } private getSuggestionKind ( kind : as . CompletionSuggestionKind , label ) : CompletionItemKind | undefined { switch ( kind ) { case "s" : return CompletionItemKind . Variable ; case "s" : return label . startsWith ( "s" ) ? CompletionItemKind . Module : path . extname ( label . toLowerCase ( ) ) === "s" ? CompletionItemKind . File : CompletionItemKind . Folder ; case "s" : return CompletionItemKind . Variable ; case "s" : return CompletionItemKind . Method ; case "s" : return CompletionItemKind . Keyword ; case "s" : return CompletionItemKind . Variable ; case "s" : return CompletionItemKind . Variable ; case "s" : return CompletionItemKind . Value ; } return undefined ; } private getElementKind ( kind : as . ElementKind ) : CompletionItemKind | undefined { switch ( kind ) { case "s" : case "s" : return CompletionItemKind . Class ; case "s" : return CompletionItemKind . Module ; case "s" : case "s" : return CompletionItemKind . Constructor ; case "s" : return CompletionItemKind . Enum ; case "s" : return CompletionItemKind . EnumMember ; case "s" : return CompletionItemKind . Field ; case "s" : return CompletionItemKind . File ; case "s" : case "s" : return CompletionItemKind . Function ; case "s" : return CompletionItemKind . Property ; case "s" : case "s" : return CompletionItemKind . Module ; case "s" : return CompletionItemKind . Variable ; case "s" : return CompletionItemKind . Method ; case "s" : case "s" : return CompletionItemKind . Variable ; case "s" : return CompletionItemKind . Property ; case "s" : case "s" : return CompletionItemKind . Variable ; case "s" : return CompletionItemKind . Module ; case "s" : return CompletionItemKind . Method ; case "s" : return CompletionItemKind . Value ; } return undefined ; } private getCommitCharacters ( kind : as . CompletionSuggestionKind | undefined ) : string [ ] | undefined { switch ( kind ) { case "s" : case "s" : return [ "s" , "s" , "s" , "s" ] ; } return undefined ; } private appendAdditionalEdits ( completionItem : vs . CompletionItem , document : vs . TextDocument , change : as . SourceChange | undefined ) { if ( ! change ) return undefined ; const hasProblematicEdits = hasOverlappingEdits ( change ) ; if ( hasProblematicEdits ) { this . logger . error ( "s" ) ; vs . window . showErrorMessage ( `template` ) ; return undefined ; } const filePath = fsPath ( document . uri ) ; const thisFilesEdits = change . edits . filter ( ( e ) => e . file === filePath ) ; const otherFilesEdits = change . edits . filter ( ( e ) => e . file !== filePath ) ; if ( thisFilesEdits . length ) { completionItem . additionalTextEdits = flatMap ( thisFilesEdits , ( edit ) => { return edit . edits . map ( ( edit ) => { const range = new vs . Range ( document . positionAt ( edit . offset ) , document . positionAt ( edit . offset + edit . length ) , ) ; return new vs . TextEdit ( range , edit . replacement ) ; } ) ; } ) ; } if ( otherFilesEdits . length ) { const filteredSourceChange : as . SourceChange = { edits : otherFilesEdits , id : change . id , linkedEditGroups : [ ] , message : change . message , selection : change . selection , } ; completionItem . command = { arguments : [ document , filteredSourceChange ] , command : "s" , title : "s" , } ; } } public dispose ( ) { this . disposables . forEach ( ( d ) => d . dispose ( ) ) ; } }	O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O O $string$ O O O O O O $Promise<boolean>$ O O O O O O $any$ O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $boolean$ O O O O O O $Config$ O O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O O O O O O O $complex$ O O O $number$ O O $any$ O $any$ O O O O O O $complex$ O O O $string$ O O O O $string$ O O O O $string$ O O O O O O O O O O O O O O $Logger$ O O O $Analyzer$ O O O O $any[]$ O $number$ O $Analyzer$ O $any$ O O $CompletionAvailableSuggestionsNotification$ O O O O $void$ O $CompletionAvailableSuggestionsNotification$ O O O O O O $any[]$ O $number$ O $Analyzer$ O $any$ O O $CompletionExistingImportsNotification$ O O O O $void$ O $CompletionExistingImportsNotification$ O O O O O O O $Promise$ O $TextDocument$ O $Position$ O $CancellationToken$ O $CompletionContext$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $number$ O O O O O O O $any$ O O O $any$ O O O O O O O $ResourceConfig$ O $Config$ O $ResourceConfig$ O $any$ O $any$ O O O $boolean$ O $ResourceConfig$ O $boolean$ O O $boolean$ O O $boolean$ O $ResourceConfig$ O $boolean$ O O O $boolean$ O $any$ O O O O O O O $boolean$ O $any$ O $any$ O O O O O $CompletionResultsNotification$ O O O O $Analyzer$ O $Promise<CompletionResultsNotification>$ O O $string$ O $string$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $undefined$ O O O $any[]$ O $CompletionResultsNotification$ O $CompletionSuggestion[]$ O $U[]$ O O $CompletionSuggestion$ O O O O $any$ O $any$ O $any$ O $boolean$ O $boolean$ O $CompletionResultsNotification$ O $CompletionSuggestion$ O O O O $any[]$ O O O O $Promise<...>$ O $any$ O $any$ O $any$ O $boolean$ O $boolean$ O $any$ O $any$ O $any$ O O $CompletionResultsNotification$ O O O $Promise<boolean>$ O O O $any$ O $any$ O $any$ O O O $undefined$ O O O $any[]$ O O O $any[]$ O O $any[]$ O O O O $any$ O $any[]$ O O O O $boolean$ O $string$ O $CompletionContext$ O O $string$ O $string$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $string$ O $boolean$ O O O O O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O O O O O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O O O O O O O O $boolean$ O $string$ O O $string$ O $string$ O $string$ O O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O O O O O O O O O O O $void$ O $CompletionAvailableSuggestionsNotification$ O $any$ O $any$ O O O O $CompletionAvailableSuggestionsNotification$ O $AvailableSuggestionSet[]$ O O O O O $AvailableSuggestionSet$ O $CompletionAvailableSuggestionsNotification$ O $AvailableSuggestionSet[]$ O O O O $complex$ O $AvailableSuggestionSet$ O $number$ O O $AvailableSuggestionSet$ O O O O O $CompletionAvailableSuggestionsNotification$ O $number[]$ O O O O O $number$ O $CompletionAvailableSuggestionsNotification$ O $number[]$ O O O O O $complex$ O $number$ O O O O O O $void$ O $CompletionExistingImportsNotification$ O $any$ O $any$ O O O $ExistingImports$ O $CompletionExistingImportsNotification$ O $ExistingImports$ O O $complex$ O O O $string$ O O O O $string$ O O O O O O O O O O O O $ExistingImport$ O $ExistingImports$ O $ExistingImport[]$ O O O O O $number$ O $ExistingImport$ O $number[]$ O O O $string$ O $ExistingImports$ O $ImportedElementSet$ O $string[]$ O $ExistingImports$ O $ImportedElementSet$ O $number[]$ O $number$ O O O O $string$ O $ExistingImports$ O $ImportedElementSet$ O $string[]$ O $ExistingImports$ O $ImportedElementSet$ O $number[]$ O $number$ O O O O $string$ O $ExistingImports$ O $ImportedElementSet$ O $string[]$ O $ExistingImport$ O $number$ O O O $string$ O O O O O O $complex$ O $string$ O O $complex$ O $string$ O O O O O $complex$ O $string$ O O $string$ O O O O O O O O $complex$ O $CompletionExistingImportsNotification$ O $string$ O O $complex$ O O O O $Promise$ O $DelayedCompletionItem$ O $CancellationToken$ O O $any$ O O O O O O O $DelayedCompletionItem$ O $AvailableSuggestion$ O O O O O $DelayedCompletionItem$ O $any$ O $DelayedCompletionItem$ O $any$ O O $DelayedCompletionItem$ O $any$ O $DelayedCompletionItem$ O $any$ O O O $DelayedCompletionItem$ O O O $CompletionGetSuggestionDetailsResponse$ O O O O $Analyzer$ O $Promise<CompletionGetSuggestionDetailsResponse>$ O O $string$ O $DelayedCompletionItem$ O $string$ O $number$ O $DelayedCompletionItem$ O $number$ O $string$ O $DelayedCompletionItem$ O $AvailableSuggestion$ O $string$ O $number$ O $DelayedCompletionItem$ O $number$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O $LazyCompletionItem$ O $DelayedCompletionItem$ O $any$ O $DelayedCompletionItem$ O $string$ O $DelayedCompletionItem$ O $boolean$ O $DelayedCompletionItem$ O $boolean$ O $DelayedCompletionItem$ O $number$ O $DelayedCompletionItem$ O $number$ O $DelayedCompletionItem$ O $string$ O $DelayedCompletionItem$ O $number$ O $DelayedCompletionItem$ O $AvailableSuggestion$ O $CompletionGetSuggestionDetailsResponse$ O O O O O $LazyCompletionItem$ O $TextDocument$ O $string$ O $boolean$ O $boolean$ O $number$ O $number$ O $string$ O O O O O $number$ O $AvailableSuggestion$ O $any$ O $any$ O $CompletionGetSuggestionDetailsResponse$ O $any$ O $any$ O O O O O O $LazyCompletionItem$ O O O O O $any$ O $string$ O $boolean$ O $boolean$ O O $string$ O $string$ O $string$ O O $CompletionGetSuggestionDetailsResponse$ O $CompletionGetSuggestionDetailsResponse$ O $string$ O O $AvailableSuggestion$ O $string$ O $string$ O $AvailableSuggestion$ O $string$ O $ElementKind$ O $AvailableSuggestion$ O $Element$ O $AvailableSuggestion$ O $Element$ O $ElementKind$ O $undefined$ O $false$ O O O $undefined$ O $undefined$ O $string[]$ O $AvailableSuggestion$ O $string[]$ O $undefined$ O $undefined$ O $string$ O $AvailableSuggestion$ O $Element$ O $AvailableSuggestion$ O $Element$ O $string$ O $undefined$ O $number$ O $number$ O $number$ O $number$ O $AvailableSuggestion$ O $number$ O $string$ O $AvailableSuggestion$ O $Element$ O $AvailableSuggestion$ O $Element$ O $string$ O $undefined$ O $number$ O $CompletionGetSuggestionDetailsResponse$ O $CompletionGetSuggestionDetailsResponse$ O $SourceChange$ O $CompletionGetSuggestionDetailsResponse$ O $SourceChange$ O $Position$ O O O $undefined$ O $number$ O $CompletionGetSuggestionDetailsResponse$ O $CompletionGetSuggestionDetailsResponse$ O $SourceChange$ O $CompletionGetSuggestionDetailsResponse$ O $SourceChange$ O $Position$ O $CompletionGetSuggestionDetailsResponse$ O $SourceChange$ O $Position$ O $number$ O $undefined$ O O O O O O $CompletionGetSuggestionDetailsResponse$ O $CompletionGetSuggestionDetailsResponse$ O $SourceChange$ O $CompletionGetSuggestionDetailsResponse$ O $SourceChange$ O $SourceFileEdit[]$ O $CompletionGetSuggestionDetailsResponse$ O $SourceChange$ O $SourceFileEdit[]$ O $number$ O O O O $void$ O $LazyCompletionItem$ O $any$ O $CompletionGetSuggestionDetailsResponse$ O $SourceChange$ O O O O $string$ O $LazyCompletionItem$ O $any$ O O O O $LazyCompletionItem$ O $any$ O O O O O O O O O $CompletionGetSuggestionDetailsResponse$ O O $LazyCompletionItem$ O $any$ O $LazyCompletionItem$ O $any$ O O $LazyCompletionItem$ O $any$ O $LazyCompletionItem$ O $any$ O O O $LazyCompletionItem$ O O O O $Promise$ O $TextDocument$ O $CancellationToken$ O $string$ O $boolean$ O $boolean$ O $number$ O $CompletionResultsNotification$ O $any$ O $any$ O O O $any$ O O O O O O O $CompletionResultsNotification$ O $IncludedSuggestionSet[]$ O O $CompletionResultsNotification$ O $ElementKind[]$ O O O O O O $complex$ O $CompletionResultsNotification$ O $string$ O O O $complex$ O $CompletionResultsNotification$ O $string$ O O $undefined$ O O $complex$ O O O $string$ O O O O O O O O $CompletionResultsNotification$ O $ElementKind[]$ O $void$ O O $ElementKind$ O O $complex$ O $ElementKind$ O O O O O O $complex$ O O O $string$ O O O O O O O O O O $CompletionResultsNotification$ O $IncludedSuggestionRelevanceTag[]$ O $CompletionResultsNotification$ O $IncludedSuggestionRelevanceTag[]$ O $void$ O O $IncludedSuggestionRelevanceTag$ O O $complex$ O $IncludedSuggestionRelevanceTag$ O $string$ O O $IncludedSuggestionRelevanceTag$ O $number$ O O O $string$ O $string$ O $any$ O $any$ O O O $any[][]$ O $any$ O O O O O O O O O $complex$ O O O $number$ O O O O O O O O O $complex$ O O O $string$ O O O O O O O O O O O O $IncludedSuggestionSet$ O $CompletionResultsNotification$ O $IncludedSuggestionSet[]$ O O O O $complex$ O $IncludedSuggestionSet$ O $number$ O O O O $complex$ O $IncludedSuggestionSet$ O $number$ O O O O O $Promise<boolean>$ O O O $any$ O $any$ O $any$ O O O O O O O O $AvailableSuggestionSet$ O O O $complex$ O $IncludedSuggestionSet$ O $number$ O O O O O $AvailableSuggestionSet$ O O O O $Logger$ O $void$ O O O O O O O O O O $DelayedCompletionItem[]$ O $AvailableSuggestionSet$ O $AvailableSuggestion[]$ O $complex$ O O $AvailableSuggestion$ O O $complex$ O $AvailableSuggestion$ O $Element$ O $ElementKind$ O O O $complex$ O O $AvailableSuggestion$ O O O O $string$ O O O O $complex$ O $complex$ O $complex$ O $string$ O O O O O $complex$ O O O O O O O $complex$ O $AvailableSuggestionSet$ O $string$ O O O O O O $string$ O O O O $boolean$ O $complex$ O $string$ O O $complex$ O $string$ O O O O O O $boolean$ O O O O $U[]$ O O $AvailableSuggestion$ O O $any$ O O O $number$ O O O O O $AvailableSuggestion$ O $string[]$ O $AvailableSuggestion$ O $string[]$ O $void$ O O $string$ O O $number$ O $Math$ O $number$ O $number$ O $complex$ O $string$ O O O O O O O $LazyCompletionItem$ O O O $LazyCompletionItem$ O $any$ O $string$ O $boolean$ O $boolean$ O $CompletionResultsNotification$ O $number$ O $CompletionResultsNotification$ O $number$ O $undefined$ O $IncludedSuggestionSet$ O $number$ O $number$ O $AvailableSuggestion$ O $undefined$ O O O O $DelayedCompletionItem$ O O $string$ O $IncludedSuggestionSet$ O $string$ O $AvailableSuggestionSet$ O $string$ O $any$ O $boolean$ O $string$ O $boolean$ O $string$ O $number$ O $number$ O $IncludedSuggestionSet$ O $number$ O $number$ O $number$ O $CompletionResultsNotification$ O $number$ O $number$ O $CompletionResultsNotification$ O $number$ O $AvailableSuggestion$ O $number$ O $IncludedSuggestionSet$ O $number$ O O $LazyCompletionItem$ O O O O $DelayedCompletionItem$ O O O O $any[][]$ O $number$ O $DelayedCompletionItem[]$ O O O O O O O O $any$ O $any$ O O O O $complex$ O O $any[][]$ O O O O $CompletionItem$ O $TextDocument$ O $string$ O $boolean$ O $boolean$ O $CompletionResultsNotification$ O $any$ O $any$ O $CompletionSuggestion$ O $any$ O $any$ O O O O O O O O $any$ O $string$ O $boolean$ O $boolean$ O O $string$ O $CompletionSuggestion$ O $string$ O $string$ O $CompletionSuggestion$ O $string$ O $string$ O $CompletionSuggestion$ O $string$ O $ElementKind$ O $CompletionSuggestion$ O $Element$ O $CompletionSuggestion$ O $Element$ O $ElementKind$ O $undefined$ O $boolean$ O $CompletionSuggestion$ O $boolean$ O $CompletionSuggestionKind$ O $CompletionSuggestion$ O $CompletionSuggestionKind$ O $string[]$ O $CompletionSuggestion$ O $string[]$ O $string$ O $CompletionSuggestion$ O $string$ O $string$ O $CompletionSuggestion$ O $Element$ O $CompletionSuggestion$ O $Element$ O $string$ O $undefined$ O $number$ O $CompletionSuggestion$ O $number$ O $number$ O $CompletionResultsNotification$ O $number$ O $number$ O $CompletionResultsNotification$ O $number$ O $number$ O $CompletionSuggestion$ O $number$ O $string$ O $CompletionSuggestion$ O $string$ O O $CompletionSuggestion$ O $Element$ O $CompletionSuggestion$ O $Element$ O $string$ O $undefined$ O O $number$ O $CompletionSuggestion$ O $number$ O $number$ O $CompletionSuggestion$ O $number$ O O O O O O $LazyCompletionItem$ O $TextDocument$ O $string$ O $boolean$ O $boolean$ O O O O $string$ O O O O $string$ O O O $string$ O O O O O $string$ O O O O O O $ElementKind$ O $any$ O $any$ O O O $boolean$ O O O $CompletionSuggestionKind$ O $any$ O $any$ O O O $string[]$ O O O O O O O $string$ O O O O O $string$ O O O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O $string$ O O O O O $number$ O O O O O $number$ O O O O O O O O O O $any$ O O O $ElementKind$ O O O $any$ O O O $ElementKind$ O O $undefined$ O O $string$ O O O $string$ O O O $string$ O O $string$ O O O O O O $any$ O O $any$ O O O O $boolean$ O O O O $boolean$ O $string$ O O O O O O O $string$ O $any$ O $any$ O $any$ O O O $CompletionSuggestionKind$ O O O $string$ O $number$ O O O O O O O O $string$ O O O $string$ O $number$ O O O O O O O $string$ O O O $string$ O O $boolean$ O O O $string[]$ O O O $string[]$ O $number$ O O O O O $boolean$ O $boolean$ O O $boolean$ O O $any$ O $any$ O O O $string$ O O O $string[]$ O O O $string[]$ O O $string[]$ O O O O O $number$ O O $any$ O $any$ O O O O O O $string[]$ O $number$ O O $any$ O $any$ O $string[]$ O O O O O O O O $string$ O $string[]$ O $string[]$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $boolean$ O O $boolean$ O O $any$ O $any$ O O O $string$ O O $any$ O $any$ O O O O O O $boolean$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $string$ O O O O O O O O O $number$ O O O $string$ O O O $string$ O $string$ O O O O O $number$ O O O $string$ O O O $string$ O $string$ O O O $number$ O O O $number$ O O O O $number$ O O O O O O O O $string$ O O O $string$ O $string$ O O O $number$ O O O O O $number$ O O O O $boolean$ O O O O $string$ O O O $string$ O $string$ O O O $number$ O O O O $number$ O O O O O $any$ O $any$ O $string$ O O O O $string$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O $string$ O O O $ElementKind$ O O O O O $string$ O O O $string$ O O O $string$ O $string$ O O O O O $string$ O $number$ O O O O O O O O O O O O O $string$ O O $string$ O $string$ O $string$ O O O O O $string$ O O O $string$ O O O O O O O $string$ O O $string$ O O O $string$ O O O O $string$ O $boolean$ O O O O $string$ O $string$ O $string$ O O O $string$ O $number$ O O O O $string$ O O O O $any$ O $any$ O O O O $CompletionSuggestionKind$ O O O $any$ O O O $CompletionSuggestionKind$ O $string$ O O $undefined$ O O O $string$ O $string$ O O O $string$ O O O $LazyCompletionItem$ O O $any$ O $string$ O $any$ O O $LazyCompletionItem$ O $any$ O $string$ O $complex$ O O O O O O O $LazyCompletionItem$ O $any$ O O O $boolean$ O $string$ O O O O $boolean$ O O O O O O O $string$ O O O O $undefined$ O $LazyCompletionItem$ O $any$ O $string$ O O $any$ O $string$ O O $undefined$ O $LazyCompletionItem$ O $any$ O $any$ O $LazyCompletionItem$ O $any$ O O O $LazyCompletionItem$ O $any$ O O $any$ O $any$ O $any$ O O O $number$ O O $any$ O $any$ O O O $number$ O O O $number$ O O O O O O $boolean$ O $LazyCompletionItem$ O $any$ O O O $string[]$ O O O $CompletionSuggestionKind$ O O O $string[]$ O O O O O O O $string[]$ O $number$ O $string$ O O O O O $boolean$ O O O O O O O $CompletionSuggestionKind$ O O O $string$ O $boolean$ O O O O $boolean$ O O O O O $boolean$ O O $LazyCompletionItem$ O $any$ O O $string$ O O O $string$ O O O O O O $LazyCompletionItem$ O $any$ O O O O O O $number$ O O $string$ O O O $string$ O $string$ O O O O $LazyCompletionItem$ O O O $any$ O $CompletionSuggestionKind$ O $any$ O $any$ O $string$ O O $any$ O O O O O $CompletionSuggestionKind$ O O O O O O $any$ O $any$ O O O O O $string$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $undefined$ O O O $any$ O $ElementKind$ O $any$ O $any$ O O $any$ O O O O O $ElementKind$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $undefined$ O O O $string[]$ O $CompletionSuggestionKind$ O $any$ O $any$ O O O O O O O O O O O O $CompletionSuggestionKind$ O O O O O O O O O O O O O O O O O O O O O $undefined$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $SourceChange$ O $any$ O $any$ O O O O O O O $SourceChange$ O O $undefined$ O O $boolean$ O $boolean$ O $SourceChange$ O O O O $boolean$ O O O O $Logger$ O $void$ O O O O $any$ O $any$ O $any$ O O O O O $undefined$ O O O $string$ O $string$ O $any$ O $any$ O O O $SourceFileEdit[]$ O $SourceChange$ O $SourceFileEdit[]$ O $complex$ O O $SourceFileEdit$ O O $SourceFileEdit$ O $string$ O $string$ O O O $SourceFileEdit[]$ O $SourceChange$ O $SourceFileEdit[]$ O $complex$ O O $SourceFileEdit$ O O $SourceFileEdit$ O $string$ O $string$ O O O O $SourceFileEdit[]$ O $number$ O O $any$ O $any$ O O O $SourceFileEdit[]$ O O $SourceFileEdit$ O O O O $SourceFileEdit$ O $SourceEdit[]$ O $U[]$ O O $SourceEdit$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $SourceEdit$ O $number$ O O $any$ O $any$ O $SourceEdit$ O $number$ O $SourceEdit$ O $number$ O O O O O O $any$ O $any$ O $any$ O $SourceEdit$ O $string$ O O O O O O O O O O O $SourceFileEdit[]$ O $number$ O O O $SourceChange$ O $any$ O $any$ O O $SourceFileEdit[]$ O $SourceFileEdit[]$ O $string$ O $SourceChange$ O $string$ O $undefined[]$ O O O O $string$ O $SourceChange$ O $string$ O $Position$ O $SourceChange$ O $Position$ O O O $any$ O $any$ O O $any[]$ O O $any$ O $SourceChange$ O O $string$ O O O $string$ O O O O O O O O $any$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O
import { Diagnostic , DiagnosticCollection , DiagnosticRelatedInformation , DiagnosticSeverity , DiagnosticTag , Location , Uri } from "s" ; import * as as from "s" ; import { toRangeOnLine } from "s" ; import { Analyzer } from "s" ; import { config } from "s" ; export class DartDiagnosticProvider { private lastErrorJson : string | undefined ; constructor ( private readonly analyzer , private readonly diagnostics ) { this . analyzer . registerForAnalysisErrors ( ( es ) => this . handleErrors ( es ) ) ; this . analyzer . registerForAnalysisFlushResults ( ( es ) => this . flushResults ( es ) ) ; } private handleErrors ( notification : as . AnalysisErrorsNotification ) { const notificationJson = JSON . stringify ( notification ) ; if ( this . lastErrorJson === notificationJson ) { return ; } let errors = notification . errors ; if ( ! config . showTodos ) errors = errors . filter ( ( error ) => error . type !== "s" ) ; this . diagnostics . set ( Uri . file ( notification . file ) , errors . map ( ( e ) => DartDiagnosticProvider . createDiagnostic ( e ) ) , ) ; this . lastErrorJson = notificationJson ; } public static createDiagnostic ( error : as . AnalysisError ) { const diag = new DartDiagnostic ( toRangeOnLine ( error . location ) , error . message , DartDiagnosticProvider . getSeverity ( error . severity , error . type ) , ) ; diag . code = error . code ; diag . source = "s" ; diag . tags = DartDiagnosticProvider . getTags ( error ) ; diag . type = error . type ; if ( error . correction ) diag . message += `template` ; if ( error . contextMessages && error . contextMessages . length ) diag . relatedInformation = error . contextMessages . map ( DartDiagnosticProvider . createRelatedInformation ) ; return diag ; } public static createRelatedInformation ( related : as . DiagnosticMessage ) { return new DiagnosticRelatedInformation ( new Location ( Uri . file ( related . location . file ) , toRangeOnLine ( related . location ) , ) , related . message , ) ; } public static getSeverity ( severity : as . AnalysisErrorSeverity , type : as . AnalysisErrorType ) { switch ( severity ) { case "s" : return DiagnosticSeverity . Error ; case "s" : return DiagnosticSeverity . Warning ; case "s" : switch ( type ) { case "s" : return DiagnosticSeverity . Information ; default : return DiagnosticSeverity . Information ; } default : throw new Error ( "s" + severity ) ; } } public static getTags ( error : as . AnalysisError ) : DiagnosticTag [ ] { const tags : DiagnosticTag [ ] = [ ] ; if ( error . code === "s" || error . code === "s" || error . code === "s" ) tags . push ( DiagnosticTag . Unnecessary ) ; return tags ; } private flushResults ( notification : as . AnalysisFlushResultsNotification ) { this . lastErrorJson = undefined ; const entries = notification . files . map < [ Uri , Diagnostic [ ] | undefined ] > ( ( file ) => [ Uri . file ( file ) , undefined ] ) ; this . diagnostics . set ( entries ) ; } } export class DartDiagnostic extends Diagnostic { public type : string ; }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $Config$ O O O O O O $any$ O O $string$ O O O O O O O O O $Analyzer$ O O O $DiagnosticCollection$ O O O O $Analyzer$ O $any$ O O $AnalysisErrorsNotification$ O O O O $void$ O $AnalysisErrorsNotification$ O O O O O $Analyzer$ O $any$ O O $AnalysisFlushResultsNotification$ O O O O $void$ O $AnalysisFlushResultsNotification$ O O O O O $void$ O $AnalysisErrorsNotification$ O $any$ O $any$ O O O $string$ O $JSON$ O $complex$ O $AnalysisErrorsNotification$ O O O O O O $string$ O $string$ O O O O O O $AnalysisError[]$ O $AnalysisErrorsNotification$ O $AnalysisError[]$ O O O O $Config$ O $boolean$ O $AnalysisError[]$ O $AnalysisError[]$ O $complex$ O O $AnalysisError$ O O $AnalysisError$ O $AnalysisErrorType$ O O O O O O $any$ O $any$ O $any$ O $any$ O $AnalysisErrorsNotification$ O $string$ O O $AnalysisError[]$ O $U[]$ O O $AnalysisError$ O O $any$ O $any$ O $AnalysisError$ O O O O O O O $string$ O $string$ O O O O $Diagnostic$ O $AnalysisError$ O $any$ O $any$ O O O $DartDiagnostic$ O O $any$ O $any$ O $AnalysisError$ O $Location$ O O $AnalysisError$ O $string$ O $any$ O $any$ O $AnalysisError$ O $AnalysisErrorSeverity$ O $AnalysisError$ O $AnalysisErrorType$ O O O O $DartDiagnostic$ O $any$ O $AnalysisError$ O $string$ O $DartDiagnostic$ O $any$ O O O $DartDiagnostic$ O $any$ O $any$ O $any[]$ O $AnalysisError$ O O $DartDiagnostic$ O $string$ O $AnalysisError$ O $AnalysisErrorType$ O O O $AnalysisError$ O $string$ O $DartDiagnostic$ O $any$ O O O O O $AnalysisError$ O $DiagnosticMessage[]$ O $AnalysisError$ O $DiagnosticMessage[]$ O $number$ O $DartDiagnostic$ O $any$ O $AnalysisError$ O $DiagnosticMessage[]$ O $U[]$ O $any$ O $any$ O O O $DartDiagnostic$ O O O O $any$ O $DiagnosticMessage$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $DiagnosticMessage$ O $Location$ O $string$ O O $any$ O $DiagnosticMessage$ O $Location$ O O O O $DiagnosticMessage$ O $string$ O O O O O O $DiagnosticSeverity$ O $AnalysisErrorSeverity$ O $any$ O $any$ O $AnalysisErrorType$ O $any$ O $any$ O O O O $AnalysisErrorSeverity$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $AnalysisErrorType$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $ErrorConstructor$ O O O $never$ O O O O O O $any[]$ O $AnalysisError$ O $any$ O $any$ O O $any$ O O O O $any[]$ O $any$ O O O O O O O O $AnalysisError$ O $string$ O O O $AnalysisError$ O $string$ O O O $AnalysisError$ O $string$ O O O $any[]$ O $number$ O $any$ O $any$ O O O $any[]$ O O O $void$ O $AnalysisFlushResultsNotification$ O $any$ O $any$ O O O O $string$ O $undefined$ O O $complex$ O $AnalysisFlushResultsNotification$ O $string[]$ O $U[]$ O O $any$ O $any$ O O O O O O O O $string$ O O O $any$ O $any$ O $string$ O O $undefined$ O O O O O $any$ O $any$ O $complex$ O O O O O O $any$ O $any$ O O $string$ O O O O
import { CancellationToken , DocumentSymbol , DocumentSymbolProvider , TextDocument } from "s" ; import { Outline } from "s" ; import { Logger } from "s" ; import { waitFor } from "s" ; import { toRange } from "s" ; import { getSymbolKindForElementKind } from "s" ; import { openFileTracker } from "s" ; export class DartDocumentSymbolProvider implements DocumentSymbolProvider { constructor ( private readonly logger ) { } public async provideDocumentSymbols ( document , token ) < DocumentSymbol [ ] | undefined > { const outline = await waitFor ( ( ) => openFileTracker . getOutlineFor ( document . uri ) , 0 , 0 , token ) ; if ( token . isCancellationRequested || ! outline || ! outline . children || ! outline . children . length ) return ; return outline . children . map ( ( r ) => this . convertResult ( document , r ) ) ; } private convertResult ( document , outline ) { const name = outline . element . name ? outline . element . name : ( outline . element . kind === "s" ? "s" : "s" ) ; const location = outline . element . location || outline ; const symbol = new DocumentSymbol ( name , outline . element . parameters || "s" , getSymbolKindForElementKind ( this . logger , outline . element . kind ) , this . getCodeOffset ( document , outline ) , toRange ( document , location . offset , location . length ) , ) ; if ( outline . children && outline . children . length ) { symbol . children = outline . children . filter ( this . shouldShow ) . map ( ( r ) => this . convertResult ( document , r ) ) ; } return symbol ; } private shouldShow ( outline ) { if ( outline . element . kind === "s" || outline . element . kind === "s" ) return false ; return true ; } private getCodeOffset ( document , outline : Outline & { codeOffset ? : number , codeLength ? : number } ) { return toRange ( document , outline . codeOffset || outline . offset , outline . codeLength || outline . length ) ; } }	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Promise<T>$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O O $Logger$ O O O O O $Promise$ O $TextDocument$ O $CancellationToken$ O O $any$ O O O O O O O $Outline$ O O $Promise<T>$ O O O O O O $Outline$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O $Outline$ O O $Outline$ O $Outline[]$ O O $Outline$ O $Outline[]$ O $number$ O O O O $Outline$ O $Outline[]$ O $U[]$ O O $Outline$ O O O O $any$ O $any$ O $Outline$ O O O O O $DocumentSymbol$ O $TextDocument$ O $Outline$ O O O $string$ O $Outline$ O $Element$ O $string$ O $Outline$ O $Element$ O $string$ O O $Outline$ O $Element$ O $ElementKind$ O O O O O O O O O $complex$ O $Outline$ O $Element$ O $Location$ O $Outline$ O O $any$ O O $any$ O $string$ O $Outline$ O $Element$ O $string$ O O O $any$ O O O $Logger$ O $Outline$ O $Element$ O $ElementKind$ O O O O $any$ O $any$ O $Outline$ O O $any$ O $any$ O $complex$ O $number$ O $complex$ O $number$ O O O O O O $Outline$ O $Outline[]$ O $Outline$ O $Outline[]$ O $number$ O O $any$ O $any$ O $Outline$ O $Outline[]$ O $complex$ O O O $boolean$ O O $U[]$ O O $Outline$ O O O O $any$ O $any$ O $Outline$ O O O O O $any$ O O O $boolean$ O $Outline$ O O O O $Outline$ O $Element$ O $ElementKind$ O O O $Outline$ O $Element$ O O O O O O O O O O O O O $any$ O $TextDocument$ O $complex$ O $any$ O O $number$ O O O O $number$ O O O O O O O $any$ O $any$ O $complex$ O $number$ O $complex$ O $number$ O $complex$ O $number$ O $complex$ O $number$ O O O O
import { CancellationToken , FoldingContext , FoldingRange , FoldingRangeKind , FoldingRangeProvider , TextDocument } from "s" ; import { FoldingKind , FoldingRegion } from "s" ; import { Analyzer } from "s" ; import { openFileTracker } from "s" ; export class DartFoldingProvider implements FoldingRangeProvider { constructor ( private readonly analyzer ) { } public async provideFoldingRanges ( document , context , token ) < FoldingRange [ ] | undefined > { await this . analyzer . currentAnalysis ; if ( token && token . isCancellationRequested ) return ; let foldingRegions : FoldingRegion [ ] | undefined ; for ( let i = 0 ; i < 0 ; i ++ ) { foldingRegions = openFileTracker . getFoldingRegionsFor ( document . uri ) ; if ( foldingRegions ) break ; await new Promise ( ( resolve ) => setTimeout ( resolve , i * 0 ) ) ; if ( token && token . isCancellationRequested ) return ; } if ( token . isCancellationRequested || ! foldingRegions ) return ; return foldingRegions . map ( ( f ) => new FoldingRange ( document . positionAt ( f . offset ) . line , document . positionAt ( f . offset + f . length ) . line , this . getKind ( f . kind ) , ) ) ; } private getKind ( kind ) : FoldingRangeKind | undefined { switch ( kind ) { case "s" : case "s" : return FoldingRangeKind . Comment ; case "s" : return FoldingRangeKind . Imports ; } } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O O $Analyzer$ O O O O O $Promise$ O $TextDocument$ O $FoldingContext$ O $CancellationToken$ O O $any$ O O O O O O O O O $Analyzer$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O O O O $FoldingRegion[]$ O $any$ O O O O O O O O $number$ O O O $number$ O O O $number$ O O O $FoldingRegion[]$ O O O $FoldingRegion[]$ O $any$ O $any$ O O O O $FoldingRegion[]$ O O O O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O $number$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $FoldingRegion[]$ O O O O $FoldingRegion[]$ O $U[]$ O O $FoldingRegion$ O O O $any$ O $any$ O $any$ O $FoldingRegion$ O $number$ O O $any$ O $any$ O $any$ O $FoldingRegion$ O $number$ O $FoldingRegion$ O $number$ O O $any$ O O O $any$ O $FoldingRegion$ O $FoldingKind$ O O O O O O O $any$ O $FoldingKind$ O O $any$ O O O O O $FoldingKind$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O
import * as minimatch from "s" ; import { CancellationToken , DocumentFormattingEditProvider , DocumentSelector , FormattingOptions , languages , OnTypeFormattingEditProvider , Position , Range , TextDocument , TextEdit , window , workspace } from "s" ; import * as as from "s" ; import { IAmDisposable , Logger } from "s" ; import { fsPath } from "s" ; import { Context } from "s" ; import { Analyzer } from "s" ; import { config } from "s" ; export class DartFormattingEditProvider implements DocumentFormattingEditProvider , OnTypeFormattingEditProvider , IAmDisposable { constructor ( private readonly logger , private readonly analyzer , private readonly context ) { workspace . onDidChangeConfiguration ( ( e ) => { if ( e . affectsConfiguration ( "s" ) ) { if ( config . enableSdkFormatter ) this . registerAllFormatters ( ) ; else this . unregisterAllFormatters ( ) ; } } ) ; } private readonly registeredFormatters : IAmDisposable [ ] = [ ] ; private readonly formatterRegisterFuncs : Array < ( ) => void > = [ ] ; public registerDocumentFormatter ( filter ) { this . registerFormatter ( ( ) => languages . registerDocumentFormattingEditProvider ( filter , this ) ) ; } public registerTypingFormatter ( filter , firstTriggerCharacter , ... moreTriggerCharacters : string [ ] ) { this . registerFormatter ( ( ) => languages . registerOnTypeFormattingEditProvider ( filter , this , firstTriggerCharacter , ... moreTriggerCharacters ) ) ; } private registerFormatter ( reg : ( ) => IAmDisposable ) { const registerAndTrack = ( ) => this . registeredFormatters . push ( reg ( ) ) ; if ( config . enableSdkFormatter ) registerAndTrack ( ) ; this . formatterRegisterFuncs . push ( registerAndTrack ) ; } private registerAllFormatters ( ) { for ( const formatterReg of this . formatterRegisterFuncs ) { formatterReg ( ) ; } } private unregisterAllFormatters ( ) { this . registeredFormatters . forEach ( ( s ) => s . dispose ( ) ) ; this . registeredFormatters . length = 0 ; } public async provideDocumentFormattingEdits ( document , options , token ) < TextEdit [ ] | undefined > { try { return await this . doFormat ( document , true ) ; } catch { if ( ! this . context . hasWarnedAboutFormatterSyntaxLimitation ) { this . context . hasWarnedAboutFormatterSyntaxLimitation = true ; window . showInformationMessage ( "s" ) ; } return undefined ; } } public async provideOnTypeFormattingEdits ( document , position , ch , options , token ) < TextEdit [ ] | undefined > { try { return await this . doFormat ( document , false ) ; } catch { return undefined ; } } private async doFormat ( document , doLogError = true ) < TextEdit [ ] | undefined > { if ( ! this . shouldFormat ( document ) ) return undefined ; try { const resp = await this . analyzer . editFormat ( { file : fsPath ( document . uri ) , lineLength : config . for ( document . uri ) . lineLength , selectionLength : 0 , selectionOffset : 0 , } ) ; if ( resp . edits . length === 0 ) return undefined ; else return resp . edits . map ( ( e ) => this . convertData ( document , e ) ) ; } catch ( e ) { if ( doLogError ) this . logger . error ( e ) ; throw e ; } } private shouldFormat ( document ) { if ( ! document || ! document . uri || document . uri . scheme !== "s" ) return false ; const resourceConf = config . for ( document . uri ) ; const path = fsPath ( document . uri ) ; return undefined === resourceConf . doNotFormat . find ( ( p ) => minimatch ( path , p , { dot : true } ) ) ; } private convertData ( document , edit : as . SourceEdit ) { return new TextEdit ( new Range ( document . positionAt ( edit . offset ) , document . positionAt ( edit . offset + edit . length ) ) , edit . replacement , ) ; } public dispose ( ) { this . unregisterAllFormatters ( ) ; } }	O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Config$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $Logger$ O O O $Analyzer$ O O O $Context$ O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O O $Config$ O $boolean$ O O O $void$ O O O O O O $void$ O O O O O O O O O O $IAmDisposable[]$ O $any$ O O O O O O O O $void)[]$ O $ArrayConstructor$ O O O O O O O O O O O $void$ O $DocumentSelector$ O O O O $void$ O O O O $any$ O $any$ O $any$ O O O O O O O $void$ O $DocumentSelector$ O $string$ O O $string[]$ O O O O O O O O $void$ O O O O $any$ O $any$ O $any$ O O O $string$ O O $string[]$ O O O O O $void$ O $IAmDisposable$ O O O O $any$ O O O $number$ O O O O O O $IAmDisposable[]$ O $number$ O $IAmDisposable$ O O O O O O $Config$ O $boolean$ O $number$ O O O O O $void)[]$ O $number$ O $number$ O O O O $void$ O O O O O O $void$ O O O $void)[]$ O O $void$ O O O O O O $void$ O O O O O $IAmDisposable[]$ O $void$ O O $IAmDisposable$ O O $IAmDisposable$ O $complex$ O O O O O O $IAmDisposable[]$ O $number$ O O O O O O $Promise$ O $TextDocument$ O $FormattingOptions$ O $CancellationToken$ O O $any$ O O O O O O O O O O O O $Promise<any[]>$ O $any$ O O O O O O O O O O O O $Context$ O $boolean$ O O O O $Context$ O $boolean$ O O O $any$ O $any$ O O O O O O $undefined$ O O O O O $Promise$ O $TextDocument$ O $Position$ O $string$ O $FormattingOptions$ O $CancellationToken$ O O $any$ O O O O O O O O O O O O $Promise<any[]>$ O $any$ O O O O O O O O $undefined$ O O O O O $Promise$ O $TextDocument$ O $boolean$ O O O O $any$ O O O O O O O O O O O $boolean$ O $any$ O O O $undefined$ O O O O $EditFormatResponse$ O O O O $Analyzer$ O $Promise<EditFormatResponse>$ O O $string$ O $string$ O $any$ O $any$ O O $number$ O $Config$ O $ResourceConfig$ O $any$ O $any$ O O $number$ O $number$ O O O $number$ O O O O O O O O $EditFormatResponse$ O $SourceEdit[]$ O $number$ O O O O $undefined$ O O O $EditFormatResponse$ O $SourceEdit[]$ O $U[]$ O O $SourceEdit$ O O O O $any$ O $any$ O $SourceEdit$ O O O O O O $any$ O O O O $boolean$ O O O $Logger$ O $void$ O $any$ O O O $any$ O O O O $boolean$ O $TextDocument$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $ResourceConfig$ O $Config$ O $ResourceConfig$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O $any$ O O O $undefined$ O $ResourceConfig$ O $string[]$ O $complex$ O O $string$ O O $any$ O $string$ O $string$ O O $boolean$ O O O O O O O O $TextEdit$ O $TextDocument$ O $SourceEdit$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $SourceEdit$ O $number$ O O $any$ O $any$ O $SourceEdit$ O $number$ O $SourceEdit$ O $number$ O O O $SourceEdit$ O $string$ O O O O O $void$ O O O O O $void$ O O O O O
import { CancellationToken , DocumentHighlight , DocumentHighlightProvider , Position , Range , TextDocument } from "s" ; import { openFileTracker } from "s" ; export class DartDocumentHighlightProvider implements DocumentHighlightProvider { public provideDocumentHighlights ( document , position , token , ) : DocumentHighlight [ ] | undefined { const offset = document . offsetAt ( position ) ; const occurrences = openFileTracker . getOccurrencesFor ( document . uri ) ; if ( ! occurrences ) return ; for ( const occurrence of occurrences ) { if ( occurrence . offsets . find ( ( o ) => o <= offset && o + occurrence . length >= offset ) ) { return occurrence . offsets . map ( ( o ) => new DocumentHighlight ( new Range ( document . positionAt ( o ) , document . positionAt ( o + occurrence . length ) , ) ) ) ; } } } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O O $any[]$ O $TextDocument$ O $Position$ O $CancellationToken$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $Occurrences[]$ O O O $Occurrences[]$ O $any$ O $any$ O O O O O $Occurrences[]$ O O O O O O $Occurrences$ O $Occurrences[]$ O O O O $Occurrences$ O $number[]$ O $complex$ O O $number$ O O $number$ O $any$ O $number$ O $Occurrences$ O $number$ O $any$ O O O O $Occurrences$ O $number[]$ O $U[]$ O O $number$ O O O $any$ O O $any$ O $any$ O $any$ O $number$ O O $any$ O $any$ O $number$ O $Occurrences$ O $number$ O O O O O O O O O O
import * as vs from "s" ; import * as as from "s" ; import { flatMap } from "s" ; import { fsPath , toRange } from "s" ; import { Analyzer } from "s" ; import { findNearestOutlineNode } from "s" ; export class DartImplementationProvider implements vs . ImplementationProvider { constructor ( readonly analyzer ) { } public async provideImplementation ( document : vs . TextDocument , position : vs . Position , token : vs . CancellationToken ) < vs . Definition | undefined > { const outlineNode = findNearestOutlineNode ( document , position , true ) ; const offset = outlineNode && outlineNode . element && outlineNode . element . location ? outlineNode . element . location . offset : document . offsetAt ( position ) ; const hierarchy = await this . analyzer . searchGetTypeHierarchy ( { file : fsPath ( document . uri ) , offset , } ) ; if ( token . isCancellationRequested || ! hierarchy || ! hierarchy . hierarchyItems || ! hierarchy . hierarchyItems . length || hierarchy . hierarchyItems . length === 0 ) return ; const currentItem = hierarchy . hierarchyItems . find ( ( h ) => { const elm = h . memberElement || h . classElement ; return elm . location && elm . location . offset <= offset && elm . location . offset + elm . location . length >= offset ; } ) || hierarchy . hierarchyItems [ 0 ] ; const isClass = ! currentItem . memberElement ; function getDescendants ( item : as . TypeHierarchyItem ) : as . TypeHierarchyItem [ ] { return [ ... item . subclasses . map ( ( i ) => hierarchy . hierarchyItems [ i ] ) , ... flatMap ( item . subclasses , ( i ) => getDescendants ( hierarchy . hierarchyItems [ i ] ) ) , ] ; } const descendants = getDescendants ( currentItem ) . map ( ( d ) => isClass ? d . classElement : d . memberElement ) . filter ( ( d ) => d ) ; const locations : vs . Location [ ] = [ ] ; for ( const element of descendants ) { const range = toRange ( await vs . workspace . openTextDocument ( element . location . file ) , element . location . offset , element . location . length , ) ; locations . push ( new vs . Location ( vs . Uri . file ( element . location . file ) , range ) ) ; } return locations ; } }	O O O $any$ O O O O O O $any$ O O O O O O O O O O O O $string$ O $any$ O O O O O O $any$ O O O O O O $Outline$ O O O O O O $any$ O $any$ O $any$ O O O O $Analyzer$ O O O O O $Promise$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $Outline$ O $Outline$ O $any$ O $any$ O O O O O $any$ O $Outline$ O $Outline$ O $Element$ O $Outline$ O $Element$ O $Location$ O $Outline$ O $Element$ O $Location$ O $number$ O $any$ O $any$ O $any$ O O O $SearchGetTypeHierarchyResponse$ O O O O $Analyzer$ O $Promise<SearchGetTypeHierarchyResponse>$ O O $string$ O $string$ O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O $SearchGetTypeHierarchyResponse$ O O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O $number$ O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O $number$ O O O O O O $TypeHierarchyItem$ O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O $complex$ O O $TypeHierarchyItem$ O O O O $Element$ O $TypeHierarchyItem$ O $Element$ O $TypeHierarchyItem$ O $Element$ O O $Element$ O $Location$ O $Element$ O $Location$ O $number$ O $any$ O $Element$ O $Location$ O $number$ O $Element$ O $Location$ O $number$ O $any$ O O O O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O O O O O $boolean$ O O $TypeHierarchyItem$ O $Element$ O O $TypeHierarchyItem[]$ O $TypeHierarchyItem$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $TypeHierarchyItem$ O $number[]$ O $U[]$ O O $number$ O O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O $number$ O O O O O O $TypeHierarchyItem$ O $number[]$ O O $number$ O O $TypeHierarchyItem[]$ O $SearchGetTypeHierarchyResponse$ O $TypeHierarchyItem[]$ O $number$ O O O O O O O O $Element[]$ O $TypeHierarchyItem[]$ O $TypeHierarchyItem$ O O $U[]$ O O $TypeHierarchyItem$ O O $boolean$ O $TypeHierarchyItem$ O $Element$ O $TypeHierarchyItem$ O $Element$ O O $complex$ O O $Element$ O O $Element$ O O O $any[]$ O $any$ O $any$ O O O O O O O O O $Element$ O $Element[]$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $Element$ O $Location$ O $string$ O O $Element$ O $Location$ O $number$ O $Element$ O $Location$ O $number$ O O O $any[]$ O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $Element$ O $Location$ O $string$ O O $any$ O O O O O $any[]$ O O O
import { IndentAction , LanguageConfiguration } from "s" ; export class DartLanguageConfiguration implements LanguageConfiguration { public onEnterRules = [ { action : { indentAction : IndentAction . None , appendText : "s" } , beforeText : "s" , } , { action : { indentAction : IndentAction . None , appendText : "s" } , beforeText : "s" , } , { action : { indentAction : IndentAction . IndentOutdent , appendText : "s" } , afterText : "s" , beforeText : "s" , } , { action : { indentAction : IndentAction . None , appendText : "s" } , beforeText : "s" , } , { action : { indentAction : IndentAction . None , appendText : "s" } , beforeText : "s" , } , { action : { indentAction : IndentAction . None , removeText : 0 } , beforeText : "s" , } , ] ; }	O O $any$ O $any$ O O O O O O $any$ O $any$ O O $complex$ O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O $RegExp$ O O O O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O $RegExp$ O O O O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O $RegExp$ O O O $RegExp$ O O O O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O $RegExp$ O O O O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O $RegExp$ O O O O O O $complex$ O O $any$ O $any$ O $any$ O $number$ O O O O $RegExp$ O O O O O O O O
import { CancellationToken , DefinitionLink , DefinitionProvider , Location , Position , ReferenceContext , ReferenceProvider , TextDocument , Uri } from "s" ; import { flatMap } from "s" ; import { fsPath , toRange , toRangeOnLine } from "s" ; import { Analyzer } from "s" ; export class DartReferenceProvider implements ReferenceProvider , DefinitionProvider { constructor ( private readonly analyzer ) { } public async provideReferences ( document , position , context , token ) < Location [ ] | undefined > { const definitions = context . includeDeclaration ? await this . provideDefinition ( document , position , token ) : undefined ; const resp = await this . analyzer . searchFindElementReferencesResults ( { file : fsPath ( document . uri ) , includePotential : true , offset : document . offsetAt ( position ) , } ) ; if ( token && token . isCancellationRequested ) return ; const locations = resp . results . map ( ( result ) => { return new Location ( Uri . file ( result . location . file ) , toRangeOnLine ( result . location ) , ) ; } ) ; return definitions ? locations . concat ( definitions . map ( ( dl ) => new Location ( dl . targetUri , dl . targetRange ) ) ) : locations ; } public async provideDefinition ( document , position , token ) < DefinitionLink [ ] | undefined > { const resp = await this . analyzer . analysisGetNavigation ( { file : fsPath ( document . uri ) , length : 0 , offset : document . offsetAt ( position ) , } ) ; if ( token && token . isCancellationRequested ) return ; return flatMap ( resp . regions , ( region ) => { return region . targets . map ( ( targetIndex ) => { const target = resp . targets [ targetIndex ] ; if ( target . startColumn === 0 ) target . startColumn = 0 ; return { originSelectionRange : toRange ( document , region . offset , region . length ) , targetRange : toRangeOnLine ( target ) , targetUri : Uri . file ( resp . files [ target . fileIndex ] ) , } as DefinitionLink ; } ) ; } ) ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O $string$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $Analyzer$ O O O O O $Promise$ O $TextDocument$ O $Position$ O $ReferenceContext$ O $CancellationToken$ O O $any$ O O O O O O O $any[]$ O $any$ O $any$ O O O O $Promise<any[]>$ O $any$ O $any$ O $any$ O O $undefined$ O O $SearchResultsNotification$ O O O O $Analyzer$ O $Promise<SearchResultsNotification>$ O O $string$ O $string$ O $any$ O $any$ O O $true$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $any[]$ O $SearchResultsNotification$ O $SearchResult[]$ O $U[]$ O O $SearchResult$ O O O O O $any$ O $any$ O $any$ O $SearchResult$ O $Location$ O $string$ O O $any$ O $SearchResult$ O $Location$ O O O O O O O O $any[]$ O $any[]$ O $complex$ O $any[]$ O $U[]$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O O O O $Promise$ O $TextDocument$ O $Position$ O $CancellationToken$ O O $any$ O O O O O O O $AnalysisGetNavigationResponse$ O O O O $Analyzer$ O $Promise<AnalysisGetNavigationResponse>$ O O $string$ O $string$ O $any$ O $any$ O O $number$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $AnalysisGetNavigationResponse$ O $NavigationRegion[]$ O O $NavigationRegion$ O O O O $NavigationRegion$ O $number[]$ O $U[]$ O O $number$ O O O O $NavigationTarget$ O $AnalysisGetNavigationResponse$ O $NavigationTarget[]$ O $number$ O O O O $NavigationTarget$ O $number$ O O O $NavigationTarget$ O $number$ O O O O O $any$ O $any$ O $any$ O $NavigationRegion$ O $number$ O $NavigationRegion$ O $number$ O O $any$ O $any$ O $NavigationTarget$ O O $any$ O $any$ O $any$ O $AnalysisGetNavigationResponse$ O $string[]$ O $NavigationTarget$ O $number$ O O O O O $any$ O O O O O O O O O
import { CancellationToken , OutputChannel , Position , Range , RenameProvider , TextDocument , Uri , workspace , WorkspaceEdit } from "s" ; import * as as from "s" ; import { fsPath , toRange } from "s" ; import { Analyzer } from "s" ; import * as channels from "s" ; export class DartRenameProvider implements RenameProvider { constructor ( private readonly analyzer ) { } public provideRenameEdits ( document , position , newName , token ) < WorkspaceEdit | undefined > { return this . doRename ( document , position , newName , token ) ; } public prepareRename ( document , position , token ) < { range : Range , placeholder : string } | undefined > { return this . getLocation ( document , position , token ) ; } private async doRename ( document , position , newName , token ) < WorkspaceEdit | undefined > { const outputChannel = channels . getChannel ( "s" ) ; outputChannel . appendLine ( "s" ) ; const resp = await this . analyzer . editGetRefactoring ( { file : fsPath ( document . uri ) , kind : "s" , length : 0 , offset : document . offsetAt ( position ) , options : { newName , } , validateOnly : false , } ) ; if ( token && token . isCancellationRequested ) { outputChannel . appendLine ( "s" ) ; return ; } const workspaceEdit = new WorkspaceEdit ( ) ; if ( resp . change && resp . change . message ) outputChannel . appendLine ( `template` ) ; this . handleProblem ( resp . initialProblems . concat ( resp . optionsProblems ) . concat ( resp . finalProblems ) , outputChannel , ) ; const promises < Thenable < void > > = [ ] ; if ( resp . change ) { resp . change . edits . forEach ( ( changeEdit ) => { changeEdit . edits . forEach ( ( fileEdit ) => { const uri = Uri . file ( changeEdit . file ) ; const promise = workspace . openTextDocument ( uri ) ; promises . push ( promise . then ( ( document ) => workspaceEdit . replace ( uri , new Range ( document . positionAt ( fileEdit . offset ) , document . positionAt ( fileEdit . offset + fileEdit . length ) , ) , fileEdit . replacement , ) , ) , ) ; } ) ; } ) ; } await Promise . all ( promises ) ; if ( token && token . isCancellationRequested ) { outputChannel . appendLine ( "s" ) ; return ; } outputChannel . appendLine ( "s" ) ; return workspaceEdit ; } private handleProblem ( problems : as . RefactoringProblem [ ] , outputChannel ) { problems . forEach ( ( problem ) => outputChannel . appendLine ( `template` ) ) ; const errors = problems . filter ( ( p ) => p . severity !== "s" && p . severity !== "s" ) . sort ( ( 0 , 0 ) => 0 . severity . localeCompare ( 0 . severity ) ) ; if ( errors . length !== 0 ) { outputChannel . appendLine ( "s" ) ; throw errors [ 0 ] . message ; } } private async getLocation ( document , position , token ) < { range : Range , placeholder : string } | undefined > { const resp = await this . analyzer . editGetRefactoring ( { file : fsPath ( document . uri ) , kind : "s" , length : 0 , offset : document . offsetAt ( position ) , validateOnly : true , } ) ; if ( token && token . isCancellationRequested ) return ; if ( ! resp . feedback ) throw new Error ( "s" ) ; const feedback = ( resp . feedback as as . RenameFeedback ) ; const range = feedback . offset === - 0 ? new Range ( position , position ) : toRange ( document , feedback . offset , feedback . length ) ; if ( feedback ) { return { placeholder : feedback . oldName , range , } ; } else { const fatalProblems = resp . initialProblems . concat ( resp . optionsProblems ) . concat ( resp . finalProblems ) . filter ( ( p ) => p . severity === "s" ) ; if ( fatalProblems && fatalProblems . length ) { throw new Error ( fatalProblems [ 0 ] . message ) ; } else { throw new Error ( "s" ) ; } } } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $string$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O $Analyzer$ O O O O $Promise$ O $TextDocument$ O $Position$ O $string$ O $CancellationToken$ O O $any$ O O O O O O O $Promise<any>$ O $any$ O $any$ O $string$ O $any$ O O O O $Promise$ O $TextDocument$ O $Position$ O $CancellationToken$ O O O $any$ O $any$ O $string$ O O O O O O O O O O $complex$ O $any$ O $any$ O $any$ O O O O O $Promise$ O $TextDocument$ O $Position$ O $string$ O $CancellationToken$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $EditGetRefactoringResponse$ O O O O $Analyzer$ O $Promise<EditGetRefactoringResponse>$ O O $string$ O $string$ O $any$ O $any$ O O O O O O $number$ O O O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $string$ O O O $false$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O O $any$ O O O O O $EditGetRefactoringResponse$ O $SourceChange$ O $EditGetRefactoringResponse$ O $SourceChange$ O $string$ O $any$ O $any$ O O O O O O $void$ O $EditGetRefactoringResponse$ O $RefactoringProblem[]$ O $complex$ O $EditGetRefactoringResponse$ O $RefactoringProblem[]$ O O $complex$ O $EditGetRefactoringResponse$ O $RefactoringProblem[]$ O O $any$ O O O O $Array$ O $any$ O O O O O O O O O O $EditGetRefactoringResponse$ O $SourceChange$ O O $EditGetRefactoringResponse$ O $SourceChange$ O $SourceFileEdit[]$ O $void$ O O $SourceFileEdit$ O O O $SourceFileEdit$ O $SourceEdit[]$ O $void$ O O $SourceEdit$ O O O O $any$ O $any$ O $any$ O $SourceFileEdit$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $number$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $SourceEdit$ O $number$ O O $any$ O $any$ O $SourceEdit$ O $number$ O $SourceEdit$ O $number$ O O O O $SourceEdit$ O $string$ O O O O O O O O O O O O O O O $PromiseConstructor$ O O O $any[]$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O $void$ O $RefactoringProblem[]$ O $any$ O $any$ O O O $OutputChannel$ O O $RefactoringProblem[]$ O $void$ O O $RefactoringProblem$ O O $any$ O $any$ O O O O O O $RefactoringProblem[]$ O $RefactoringProblem[]$ O $complex$ O O $RefactoringProblem$ O O $RefactoringProblem$ O $RefactoringProblemSeverity$ O O O $RefactoringProblem$ O O O O O O $RefactoringProblem[]$ O O $RefactoringProblem$ O $RefactoringProblem$ O O $RefactoringProblem$ O $RefactoringProblemSeverity$ O $complex$ O $RefactoringProblem$ O $RefactoringProblemSeverity$ O O O O O $RefactoringProblem[]$ O $number$ O O O O $any$ O $any$ O O O O O $RefactoringProblem[]$ O O O O $string$ O O O O O $Promise$ O $TextDocument$ O $Position$ O $CancellationToken$ O O O $any$ O $any$ O $string$ O O O O O O O O $EditGetRefactoringResponse$ O O O O $Analyzer$ O $Promise<EditGetRefactoringResponse>$ O O $string$ O $string$ O $any$ O $any$ O O O O O O $number$ O O O $any$ O $any$ O $any$ O $any$ O O $true$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $EditGetRefactoringResponse$ O $RefactoringFeedback$ O O O $ErrorConstructor$ O O O O O $RenameFeedback$ O O $EditGetRefactoringResponse$ O $RefactoringFeedback$ O $any$ O $any$ O O O $any$ O $RenameFeedback$ O $number$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $RenameFeedback$ O $number$ O $RenameFeedback$ O $number$ O O O O $RenameFeedback$ O O O O $string$ O $RenameFeedback$ O $string$ O $any$ O O O O O O O $RefactoringProblem[]$ O $EditGetRefactoringResponse$ O $RefactoringProblem[]$ O $complex$ O $EditGetRefactoringResponse$ O $RefactoringProblem[]$ O O $complex$ O $EditGetRefactoringResponse$ O $RefactoringProblem[]$ O O $complex$ O O $RefactoringProblem$ O O $RefactoringProblem$ O $RefactoringProblemSeverity$ O O O O O O $RefactoringProblem[]$ O $RefactoringProblem[]$ O $number$ O O O O $ErrorConstructor$ O $RefactoringProblem[]$ O O O O $string$ O O O O O O O $ErrorConstructor$ O O O O O O O O
import * as vs from "s" ; import { AnalysisGetSignatureResponse , ParameterInfo } from "s" ; import { cleanDartdoc } from "s" ; import { fsPath } from "s" ; import { Analyzer } from "s" ; export class DartSignatureHelpProvider implements vs . SignatureHelpProvider { constructor ( private readonly analyzer ) { } public async provideSignatureHelp ( document : vs . TextDocument , position : vs . Position , token : vs . CancellationToken ) < vs . SignatureHelp | undefined > { try { const resp = await this . analyzer . analysisGetSignature ( { file : fsPath ( document . uri ) , offset : document . offsetAt ( position ) , } ) ; if ( token && token . isCancellationRequested ) return undefined ; const sig = new vs . SignatureInformation ( this . getSignatureLabel ( resp ) , new vs . MarkdownString ( cleanDartdoc ( resp . dartdoc ) ) ) ; sig . parameters = resp . parameters . map ( ( p ) => new vs . ParameterInformation ( this . getLabel ( p ) ) ) ; const sigs = new vs . SignatureHelp ( ) ; sigs . signatures = [ sig ] ; sigs . activeSignature = 0 ; sigs . activeParameter = - 0 ; return sigs ; } catch { return undefined ; } } private getSignatureLabel ( resp ) { const req = resp . parameters . filter ( ( p ) => p . kind === "s" ) ; const opt = resp . parameters . filter ( ( p ) => p . kind === "s" ) ; const named = resp . parameters . filter ( ( p ) => p . kind === "s" ) ; const params = [ ] ; if ( req . length ) params . push ( req . map ( this . getLabel ) . join ( "s" ) ) ; if ( opt . length ) params . push ( "s" + opt . map ( this . getLabel ) . join ( "s" ) + "s" ) ; if ( named . length ) params . push ( "s" + named . map ( this . getLabel ) . join ( "s" ) + "s" ) ; return `template` ; } private getLabel ( p ) { const def = p . defaultValue ? `template` : "s" ; return `template` ; } }	O O O $any$ O O O O O $any$ O $any$ O O O O O O $string$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $Analyzer$ O O O O O $Promise$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $AnalysisGetSignatureResponse$ O O O O $Analyzer$ O $Promise<AnalysisGetSignatureResponse>$ O O $string$ O $string$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O $undefined$ O O $any$ O O $any$ O $any$ O O O $string$ O $AnalysisGetSignatureResponse$ O O O $any$ O $any$ O $string$ O $AnalysisGetSignatureResponse$ O $string$ O O O O $any$ O $any$ O $AnalysisGetSignatureResponse$ O $ParameterInfo[]$ O $U[]$ O O $ParameterInfo$ O O O $any$ O $any$ O O O $string$ O $ParameterInfo$ O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $undefined$ O O O O $string$ O $AnalysisGetSignatureResponse$ O O O $ParameterInfo[]$ O $AnalysisGetSignatureResponse$ O $ParameterInfo[]$ O $complex$ O O $ParameterInfo$ O O $ParameterInfo$ O $ParameterKind$ O O O O O $ParameterInfo[]$ O $AnalysisGetSignatureResponse$ O $ParameterInfo[]$ O $complex$ O O $ParameterInfo$ O O $ParameterInfo$ O $ParameterKind$ O O O O O $ParameterInfo[]$ O $AnalysisGetSignatureResponse$ O $ParameterInfo[]$ O $complex$ O O $ParameterInfo$ O O $ParameterInfo$ O $ParameterKind$ O O O O O $any[]$ O O O O O O $ParameterInfo[]$ O $number$ O $any[]$ O $number$ O $ParameterInfo[]$ O $U[]$ O O O $string$ O O $string$ O O O O O O O $ParameterInfo[]$ O $number$ O $any[]$ O $number$ O O O $ParameterInfo[]$ O $U[]$ O O O $string$ O O $string$ O O O O O O O O O $ParameterInfo[]$ O $number$ O $any[]$ O $number$ O O O $ParameterInfo[]$ O $U[]$ O O O $string$ O O $string$ O O O O O O O O O O O O $string$ O $ParameterInfo$ O O O $string$ O $ParameterInfo$ O $string$ O O O O O O O O O O
import * as path from "s" ; import { CancellationToken , Location , SymbolInformation , Uri , workspace , WorkspaceSymbolProvider } from "s" ; import * as as from "s" ; import { Logger } from "s" ; import { escapeRegExp } from "s" ; import { fsPath , toRange } from "s" ; import { Analyzer } from "s" ; import { getSymbolKindForElementKind } from "s" ; export class DartWorkspaceSymbolProvider implements WorkspaceSymbolProvider { private badChars : RegExp = new RegExp ( "s" , "s" ) ; constructor ( private readonly logger , private readonly analyzer ) { } public async provideWorkspaceSymbols ( query , token ) < SymbolInformation [ ] | undefined > { if ( query . length === 0 ) return undefined ; const pattern = "s" + query . replace ( this . badChars , "s" ) . split ( "s" ) . map ( ( c ) => `template` ) . join ( "s" ) + "s" ; const results = await this . analyzer . searchGetElementDeclarations ( { pattern , maxResults : 0 } ) ; if ( token && token . isCancellationRequested ) return ; return results . declarations . map ( ( d ) => this . convertWorkspaceResult ( d , results . files [ d . fileIndex ] ) ) ; } public async resolveWorkspaceSymbol ( symbol , token ) < SymbolInformation | undefined > { if ( ! ( symbol instanceof PartialSymbolInformation ) ) return undefined ; const document = await workspace . openTextDocument ( Uri . file ( symbol . locationData . file ) ) ; symbol . location = new Location ( document . uri , toRange ( document , symbol . locationData . offset , symbol . locationData . length ) , ) ; return symbol ; } private convertWorkspaceResult ( result : as . ElementDeclaration , file ) { const names = this . getNames ( result , true , file ) ; const symbol = new PartialSymbolInformation ( names . name , getSymbolKindForElementKind ( this . logger , result . kind ) , names . containerName || "s" , new Location ( Uri . file ( file ) , undefined ) , ) ; symbol . locationData = { file , length : result . codeLength , offset : result . codeOffset , } ; return symbol ; } private getNames ( result : as . ElementDeclaration , includeFilename , file ) { let name = result . name ; let nameIsPrefixedWithClass = false ; if ( result . kind === "s" && result . className ) { if ( name ) { nameIsPrefixedWithClass = true ; name = `template` ; } else { name = result . className ; } } if ( result . parameters && result . kind !== "s" ) name += result . parameters ; let containerName : string | undefined ; if ( includeFilename ) { containerName = this . createDisplayPath ( file ) ; if ( result . className && ! nameIsPrefixedWithClass ) name = `template` ; } else { containerName = result . className ; } return { name , containerName } ; } private createDisplayPath ( inputPath ) : string | undefined { const root = workspace . getWorkspaceFolder ( Uri . file ( inputPath ) ) ; if ( root ) { inputPath = root && path . relative ( fsPath ( root . uri ) , inputPath ) ; } else { const pathSlash = escapeRegExp ( path . sep ) ; const notSlashes = `template` ; const pattern = new RegExp ( `template` ) ; const matches = pattern . exec ( inputPath ) ; if ( matches && matches . length === 0 ) { const packageName = matches [ 0 ] . split ( "s" ) [ 0 ] ; const libPrefix = `template` ; const libIndex = matches [ 0 ] . indexOf ( libPrefix ) ; const filePath = libIndex !== - 0 ? matches [ 0 ] . substr ( libIndex + libPrefix . length ) : matches [ 0 ] ; inputPath = `template` ; } else { return undefined ; } } return inputPath ; } } class PartialSymbolInformation extends SymbolInformation { public locationData : { file : string ; offset : number ; length : number ; } ; }	O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O O O O O O $string$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O $RegExp$ O $RegExpConstructor$ O O $RegExpConstructor$ O O O O O O O O O O $Logger$ O O O $Analyzer$ O O O O O $Promise$ O $string$ O $CancellationToken$ O O $any$ O O O O O O O O $string$ O $number$ O O O O $undefined$ O O $string$ O O O $string$ O $complex$ O O O $RegExp$ O O O O $complex$ O O O O $U[]$ O O $string$ O O O O O $string$ O O O O O O O $SearchGetElementDeclarationsResponse$ O O O O $Analyzer$ O $Promise<SearchGetElementDeclarationsResponse>$ O O $string$ O $number$ O O O O O O O $any$ O $any$ O $any$ O O O O $SearchGetElementDeclarationsResponse$ O $ElementDeclaration[]$ O $U[]$ O O $ElementDeclaration$ O O O O $any$ O $ElementDeclaration$ O $SearchGetElementDeclarationsResponse$ O $string[]$ O $ElementDeclaration$ O $number$ O O O O O O O $Promise$ O $SymbolInformation$ O $CancellationToken$ O O $any$ O O O O O O O O $any$ O $any$ O O O $undefined$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $PartialSymbolInformation$ O $complex$ O $string$ O O O $PartialSymbolInformation$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $PartialSymbolInformation$ O $complex$ O $number$ O $PartialSymbolInformation$ O $complex$ O $number$ O O O O O $PartialSymbolInformation$ O O O $SymbolInformation$ O $ElementDeclaration$ O $any$ O $any$ O $string$ O O O $complex$ O O O $complex$ O $ElementDeclaration$ O O O $string$ O O O $any$ O O $any$ O $complex$ O $string$ O $any$ O O O $Logger$ O $ElementDeclaration$ O $ElementKind$ O O $complex$ O $string$ O O O O $any$ O $any$ O $any$ O $string$ O O $undefined$ O O O O $any$ O $any$ O O $string$ O $number$ O $ElementDeclaration$ O $number$ O $number$ O $ElementDeclaration$ O $number$ O O O O $any$ O O O $complex$ O $ElementDeclaration$ O $any$ O $any$ O $boolean$ O $string$ O O O $string$ O $ElementDeclaration$ O $string$ O O $boolean$ O O O O O $ElementDeclaration$ O $ElementKind$ O O O $ElementDeclaration$ O $string$ O O O O $string$ O O $boolean$ O O O $string$ O O O O O O $string$ O $ElementDeclaration$ O $string$ O O O O O $ElementDeclaration$ O $string$ O $ElementDeclaration$ O $ElementKind$ O O O $string$ O $ElementDeclaration$ O $string$ O O $string$ O O O O O O O $boolean$ O O $string$ O O O $string$ O $string$ O O O O $ElementDeclaration$ O $string$ O O $boolean$ O $string$ O O O O O O $string$ O $ElementDeclaration$ O $string$ O O O O $string$ O $string$ O O O O $string$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O $string$ O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O O $string$ O O O O O O $string$ O $string$ O $any$ O $any$ O O O $string$ O O O O $RegExp$ O O $RegExpConstructor$ O O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O $RegExpExecArray$ O $number$ O O O O O $string$ O $RegExpExecArray$ O O O O $complex$ O O O O O O O O $string$ O O O O $number$ O $RegExpExecArray$ O O O O $number$ O $string$ O O O $string$ O $number$ O O O O $RegExpExecArray$ O O O O $string$ O $number$ O $string$ O $number$ O O $RegExpExecArray$ O O O O $string$ O O O O O O O $undefined$ O O O O $string$ O O O O $any$ O $any$ O O $complex$ O O $string$ O O O $number$ O O O $number$ O O O O O O
import { PubGlobal } from "s" ; const packageName = "s" ; const packageID = "s" ; export class WebDev { constructor ( private pubGlobal ) { } public promptToInstallIfRequired ( ) { return this . pubGlobal . promptToInstallIfRequired ( packageName , packageID , undefined , "s" ) ; } }	O O $any$ O O O O O O O O O O O O O O O O $any$ O O O O $PubGlobal$ O O O O $Promise<boolean>$ O O O O O O $PubGlobal$ O $Promise<boolean>$ O O O O O $undefined$ O O O O O O
import { versionIsAtLeast } from "s" ; export class DartCapabilities { public static get empty ( ) { return new DartCapabilities ( "s" ) ; } public version : string ; constructor ( dartVersion ) { this . version = dartVersion ; } get supportsDevTools ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get includesSourceForSdkLibs ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get handlesBreakpointsInPartFiles ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get hasDocumentationInCompletions ( ) { return ! versionIsAtLeast ( this . version , "s" ) ; } get handlesPathsEverywhereForBreakpoints ( ) { return versionIsAtLeast ( this . version , "s" ) ; } get supportsDisableServiceTokens ( ) { return versionIsAtLeast ( this . version , "s" ) ; } }	O O $boolean$ O O O O O O $any$ O O O O $DartCapabilities$ O O O O O $any$ O O O O O O $string$ O O O O O $string$ O O O O $string$ O $string$ O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O $boolean$ O O O O $boolean$ O O O $string$ O O O O O O
import * as path from "s" ; import * as vs from "s" ; import { DART_TEST_GROUP_NODE_CONTEXT , DART_TEST_SUITE_NODE_CONTEXT , DART_TEST_TEST_NODE_CONTEXT } from "s" ; import { TestStatus } from "s" ; import { ErrorNotification , Group , GroupNotification , PrintNotification , Suite , SuiteNotification , Test , TestDoneNotification , TestStartNotification } from "s" ; import { flatMap , uniq } from "s" ; import { sortBy } from "s" ; import { getLaunchConfig } from "s" ; import { extensionPath } from "s" ; import { fsPath } from "s" ; import { getChannel } from "s" ; const suites : { [ key ] : SuiteData } = { } ; export class TestResultsProvider implements vs . Disposable , vs . TreeDataProvider < TestItemTreeItem > { private disposables : vs . Disposable [ ] = [ ] ; private onDidChangeTreeDataEmitter : vs . EventEmitter < TestItemTreeItem | undefined > = new vs . EventEmitter < TestItemTreeItem | undefined > ( ) ; public readonly onDidChangeTreeData : vs . Event < TestItemTreeItem | undefined > = this . onDidChangeTreeDataEmitter . event ; private onDidStartTestsEmitter : vs . EventEmitter < TestItemTreeItem > = new vs . EventEmitter < TestItemTreeItem > ( ) ; public readonly onDidStartTests : vs . Event < TestItemTreeItem > = this . onDidStartTestsEmitter . event ; private onFirstFailureEmitter : vs . EventEmitter < TestItemTreeItem > = new vs . EventEmitter < TestItemTreeItem > ( ) ; public readonly onFirstFailure : vs . Event < TestItemTreeItem > = this . onFirstFailureEmitter . event ; private currentSelectedNode : TestItemTreeItem | undefined ; private static isNewTestRun = true ; private static nextFailureIsFirst = true ; public static flagSuiteStart ( suitePath , isRunningWholeSuite ) { TestResultsProvider . isNewTestRun = true ; TestResultsProvider . nextFailureIsFirst = true ; if ( isRunningWholeSuite && suitePath && path . isAbsolute ( suitePath ) ) { const suite = suites [ fsPath ( suitePath ) ] ; const suitesBeingRun = suite ? [ suite ] : Object . values ( suites ) ; for ( const suite of suitesBeingRun ) { suite . getAllGroups ( ) . forEach ( ( g ) => g . isPotentiallyDeleted = true ) ; suite . getAllTests ( ) . forEach ( ( t ) => t . isPotentiallyDeleted = true ) ; } } Object . keys ( suites ) . forEach ( ( p ) => { const suite = suites [ fsPath ( p ) ] ; suite . currentRunNumber ++ ; suite . getAllGroups ( ) . forEach ( ( g ) => g . isStale = true ) ; suite . getAllTests ( ) . forEach ( ( t ) => t . isStale = true ) ; } ) ; } public setSelectedNodes ( item : TestItemTreeItem | undefined ) { this . currentSelectedNode = item ; } private owningDebugSessions : { [ key ] : vs . DebugSession | undefined } = { } ; constructor ( ) { this . disposables . push ( vs . debug . onDidReceiveDebugSessionCustomEvent ( ( e ) => this . handleDebugSessionCustomEvent ( e ) ) ) ; this . disposables . push ( vs . debug . onDidTerminateDebugSession ( ( session ) => this . handleDebugSessionEnd ( session ) ) ) ; this . disposables . push ( vs . commands . registerCommand ( "s" , ( treeNode : SuiteTreeItem | GroupTreeItem | TestTreeItem ) => { const testName = treeNode instanceof TestTreeItem ? treeNode . test . name : treeNode instanceof GroupTreeItem ? treeNode . group . name : undefined ; vs . debug . startDebugging ( vs . workspace . getWorkspaceFolder ( treeNode . resourceUri ! ) , getLaunchConfig ( false , fsPath ( treeNode . resourceUri ! ) , testName , treeNode instanceof GroupTreeItem , ) , ) ; } ) ) ; this . disposables . push ( vs . commands . registerCommand ( "s" , ( treeNode : SuiteTreeItem | GroupTreeItem | TestTreeItem ) => { const testName = treeNode instanceof TestTreeItem ? treeNode . test . name : treeNode instanceof GroupTreeItem ? treeNode . group . name : undefined ; vs . debug . startDebugging ( vs . workspace . getWorkspaceFolder ( treeNode . resourceUri ! ) , getLaunchConfig ( true , fsPath ( treeNode . resourceUri ! ) , testName , treeNode instanceof GroupTreeItem , ) , ) ; } ) ) ; this . disposables . push ( vs . commands . registerCommand ( "s" , ( treeNode ) => { return vs . commands . executeCommand ( "s" , vs . Uri . file ( treeNode . suite . path ) ) ; } ) ) ; this . disposables . push ( vs . commands . registerCommand ( "s" , ( treeNode ) => { if ( ! treeNode . group . url && ! treeNode . group . root_url ) return ; return vs . commands . executeCommand ( "s" , vs . Uri . parse ( ( treeNode . group . url || treeNode . group . root_url ) ! ) , treeNode . group . root_line || treeNode . group . line , treeNode . group . root_column || treeNode . group . column , ) ; } ) ) ; this . disposables . push ( vs . commands . registerCommand ( "s" , ( treeNode ) => { this . writeTestOutput ( treeNode , true ) ; if ( ! treeNode . test . url && ! treeNode . test . root_url ) return ; return vs . commands . executeCommand ( "s" , vs . Uri . parse ( ( treeNode . test . root_url || treeNode . test . url ) ! ) , treeNode . test . root_line || treeNode . test . line , treeNode . test . root_column || treeNode . test . column , ) ; } ) ) ; } private writeTestOutput ( treeNode , forceShow = false ) { const output = getChannel ( "s" ) ; output . clear ( ) ; if ( forceShow ) output . show ( true ) ; output . appendLine ( `template` ) ; if ( ! treeNode . outputEvents . length ) output . appendLine ( `template` ) ; for ( const o of treeNode . outputEvents ) { this . appendTestOutput ( o , output ) ; } } private appendTestOutput ( event : PrintNotification | ErrorNotification , output = getChannel ( "s" ) ) { if ( event . type === "s" ) { event = event as ErrorNotification ; output . appendLine ( `template` ) ; output . appendLine ( event . stackTrace ) ; } else if ( event . type === "s" ) { event = event as PrintNotification ; output . appendLine ( event . message ) ; } else { output . appendLine ( `template` ) ; } } public handleDebugSessionCustomEvent ( e : vs . DebugSessionCustomEvent ) { if ( e . event === "s" ) { if ( e . body . notification . type === "s" ) this . owningDebugSessions [ e . body . suitePath ] = e . session ; this . handleNotification ( e . body . suitePath , e . body . notification ) ; } } public getTreeItem ( element : vs . TreeItem ) : vs . TreeItem { return element ; } public getChildren ( element ? : vs . TreeItem ) : TestItemTreeItem [ ] { let items = ! element ? Object . keys ( suites ) . map ( ( k ) => suites [ k ] . node ) : ( element instanceof SuiteTreeItem || element instanceof GroupTreeItem ) ? element . children : [ ] ; items = items . filter ( ( item ) => item ) ; if ( ! element ) { items = items . sort ( ( a , b ) => { if ( a . sort > b . sort ) return 0 ; if ( a . sort < b . sort ) return - 0 ; const aLabel = a . label || ( a . resourceUri ? a . resourceUri . toString ( ) : "s" ) ; const bLabel = b . label || ( b . resourceUri ? b . resourceUri . toString ( ) : "s" ) ; if ( aLabel > bLabel ) return 0 ; if ( aLabel < bLabel ) return - 0 ; return 0 ; } ) ; } return items ; } public getParent ? ( element : vs . TreeItem ) : SuiteTreeItem | GroupTreeItem | undefined { if ( element instanceof TestTreeItem || element instanceof GroupTreeItem ) return element . parent ; } private updateNode ( node ? ) { this . onDidChangeTreeDataEmitter . fire ( node ) ; } private updateAllStatuses ( suite ) { this . updateStatusFromChildren ( suite . node ) ; this . updateNode ( ) ; } private updateStatusFromChildren ( node : SuiteTreeItem | GroupTreeItem ) { const childStatuses = node . children . length ? node . children . filter ( ( c ) => ( c instanceof GroupTreeItem && ! c . isPhantomGroup ) || ( c instanceof TestTreeItem && ! c . hidden ) , ) . map ( ( c ) => { if ( c instanceof GroupTreeItem ) return this . updateStatusFromChildren ( c ) ; if ( c instanceof TestTreeItem ) return c . status ; return TestStatus . Unknown ; } ) : [ TestStatus . Unknown ] ; const newStatus = Math . max . apply ( Math , childStatuses ) ; if ( newStatus !== node . status ) { node . status = newStatus ; node . iconPath = getIconPath ( node . status , false ) ; this . updateNode ( node ) ; } return node . status ; } public dispose ( ) { this . disposables . forEach ( ( d ) => d . dispose ( ) ) ; } private handleNotification ( suitePath , evt ) { const suite = suites [ suitePath ] ; switch ( evt . type ) { case "s" : this . handleSuiteNotification ( suitePath , evt as SuiteNotification ) ; break ; case "s" : this . handleTestStartNotifcation ( suite , evt as TestStartNotification ) ; break ; case "s" : this . handleTestDoneNotification ( suite , evt as TestDoneNotification ) ; break ; case "s" : this . handleGroupNotification ( suite , evt as GroupNotification ) ; break ; case "s" : this . handlePrintNotification ( suite , evt as PrintNotification ) ; break ; case "s" : this . handleErrorNotification ( suite , evt as ErrorNotification ) ; break ; } } private handleSuiteNotification ( suitePath , evt ) { let suite = suites [ evt . suite . path ] ; if ( ! suite ) { suite = new SuiteData ( suitePath , new SuiteTreeItem ( evt . suite ) ) ; suites [ evt . suite . path ] = suite ; } suite . node . status = TestStatus . Waiting ; this . updateNode ( suite . node ) ; this . updateNode ( ) ; if ( TestResultsProvider . isNewTestRun ) { TestResultsProvider . isNewTestRun = false ; this . onDidStartTestsEmitter . fire ( suite . node ) ; } } private handleTestStartNotifcation ( suite , evt ) { let oldParent : SuiteTreeItem | GroupTreeItem | undefined ; const existingTest = suite . getCurrentTest ( evt . test . id ) || suite . reuseMatchingTest ( suite . currentRunNumber , evt . test , ( parent ) => oldParent = parent ) ; const testNode = existingTest || new TestTreeItem ( suite , evt . test ) ; if ( ! existingTest ) suite . storeTest ( evt . test . id , testNode ) ; testNode . test = evt . test ; if ( testNode . test . name && testNode . test . name . startsWith ( "s" ) && testNode . parent instanceof SuiteTreeItem ) testNode . hidden = true ; else testNode . hidden = false ; const hasChangedParent = oldParent && oldParent !== testNode . parent ; if ( oldParent && hasChangedParent ) { oldParent . tests . splice ( oldParent . tests . indexOf ( testNode ) , 0 ) ; this . updateNode ( oldParent ) ; } if ( ! existingTest || hasChangedParent ) testNode . parent . tests . push ( testNode ) ; testNode . status = TestStatus . Running ; this . updateNode ( testNode ) ; this . updateNode ( testNode . parent ) ; if ( ! testNode . hidden ) this . updateAllStatuses ( suite ) ; } private handleTestDoneNotification ( suite , evt ) { const testNode = suite . getCurrentTest ( evt . testID ) ; testNode . hidden = evt . hidden ; if ( evt . skipped ) { testNode . status = TestStatus . Skipped ; } else if ( evt . result === "s" ) { testNode . status = TestStatus . Passed ; } else if ( evt . result === "s" ) { testNode . status = TestStatus . Failed ; } else if ( evt . result === "s" ) testNode . status = TestStatus . Errored ; else { testNode . status = TestStatus . Unknown ; } this . updateNode ( testNode ) ; this . updateNode ( testNode . parent ) ; this . updateAllStatuses ( suite ) ; if ( testNode . status === TestStatus . Failed && TestResultsProvider . nextFailureIsFirst ) { TestResultsProvider . nextFailureIsFirst = false ; this . onFirstFailureEmitter . fire ( suite . node ) ; } } private handleGroupNotification ( suite , evt ) { let oldParent : SuiteTreeItem | GroupTreeItem | undefined ; const existingGroup = suite . getCurrentGroup ( evt . group . id ) || suite . reuseMatchingGroup ( suite . currentRunNumber , evt . group , ( parent ) => oldParent = parent ) ; const groupNode = existingGroup || new GroupTreeItem ( suite , evt . group ) ; if ( ! existingGroup ) suite . storeGroup ( evt . group . id , groupNode ) ; groupNode . group = evt . group ; const hasChangedParent = oldParent && oldParent !== groupNode . parent ; if ( oldParent && hasChangedParent ) { oldParent . groups . splice ( oldParent . groups . indexOf ( groupNode ) , 0 ) ; this . updateNode ( oldParent ) ; } if ( ! existingGroup || hasChangedParent ) groupNode . parent . groups . push ( groupNode ) ; groupNode . status = TestStatus . Running ; this . updateNode ( groupNode ) ; this . updateNode ( groupNode . parent ) ; } public handleDebugSessionEnd ( session : vs . DebugSession ) { const suitePaths = Object . keys ( this . owningDebugSessions ) . filter ( ( suitePath ) => { const owningSession = this . owningDebugSessions [ suitePath ] ; return session && owningSession && owningSession . id === session . id ; } ) ; for ( const suitePath of suitePaths ) { this . handleSuiteEnd ( suites [ suitePath ] ) ; this . owningDebugSessions [ suitePath ] = undefined ; delete this . owningDebugSessions [ suitePath ] ; } } private handleSuiteEnd ( suite ) { if ( ! suite ) return ; suite . getAllTests ( true ) . filter ( ( t ) => t . isPotentiallyDeleted || t . hidden ) . forEach ( ( t ) => { t . hidden = true ; this . updateNode ( t . parent ) ; } ) ; suite . getAllTests ( ) . filter ( ( t ) => t . status === TestStatus . Running ) . forEach ( ( t ) => { t . status = TestStatus . Unknown ; this . updateNode ( t ) ; } ) ; this . updateAllStatuses ( suite ) ; } private handlePrintNotification ( suite , evt ) { const test = suite . getCurrentTest ( evt . testID ) ; test . outputEvents . push ( evt ) ; if ( test === this . currentSelectedNode ) this . appendTestOutput ( evt ) ; } private handleErrorNotification ( suite , evt ) { const test = suite . getCurrentTest ( evt . testID ) ; test . outputEvents . push ( evt ) ; if ( test === this . currentSelectedNode ) this . appendTestOutput ( evt ) ; } } class SuiteData { public currentRunNumber = 0 ; private readonly groups : { [ key ] : GroupTreeItem } = { } ; private readonly tests : { [ key ] : TestTreeItem } = { } ; constructor ( public readonly path , public readonly node ) { } public getAllGroups ( includeHidden = false ) { return uniq ( Object . keys ( this . groups ) . map ( ( gKey ) => this . groups [ gKey ] ) . filter ( ( g ) => includeHidden || ( ! g . hidden && ! g . isPhantomGroup ) ) , ) ; } public getAllTests ( includeHidden = false ) { return uniq ( Object . keys ( this . tests ) . map ( ( tKey ) => this . tests [ tKey ] ) . filter ( ( t ) => includeHidden || ! t . hidden ) , ) ; } public getCurrentGroup ( id ) { return this . groups [ `template` ] ; } public getCurrentTest ( id ) { return this . tests [ `template` ] ; } public getMyGroup ( suiteRunNumber , id ) { return this . groups [ `template` ] ; } public getMyTest ( suiteRunNumber , id ) { return this . tests [ `template` ] ; } public storeGroup ( id , node ) { return this . groups [ `template` ] = node ; } public storeTest ( id , node ) { return this . tests [ `template` ] = node ; } public reuseMatchingGroup ( currentSuiteRunNumber , group , handleOldParent : ( parent : SuiteTreeItem | GroupTreeItem ) => void ) : GroupTreeItem | undefined { const matches = this . getAllGroups ( ) . filter ( ( g ) => { return g . group . name === group . name && g . suiteRunNumber !== currentSuiteRunNumber ; } ) ; const sortedMatches = matches . sort ( ( 0 , 0 ) => Math . abs ( ( 0 . group . line || 0 ) - ( group . line || 0 ) ) - Math . abs ( ( 0 . group . line || 0 ) - ( group . line || 0 ) ) ) ; const match = sortedMatches . length ? sortedMatches [ 0 ] : undefined ; if ( match ) { handleOldParent ( match . parent ) ; match . suiteRunNumber = this . currentRunNumber ; this . storeGroup ( group . id , match ) ; } return match ; } public reuseMatchingTest ( currentSuiteRunNumber , test , handleOldParent : ( parent : SuiteTreeItem | GroupTreeItem ) => void ) : TestTreeItem | undefined { const matches = this . getAllTests ( ) . filter ( ( t ) => { return t . test . name === test . name && t . suiteRunNumber !== currentSuiteRunNumber ; } ) ; const sortedMatches = sortBy ( matches , ( t ) => Math . abs ( ( t . test . line || 0 ) - ( test . line || 0 ) ) ) ; const match = sortedMatches . length ? sortedMatches [ 0 ] : undefined ; if ( match ) { handleOldParent ( match . parent ) ; match . suiteRunNumber = this . currentRunNumber ; this . storeTest ( test . id , match ) ; } return match ; } } export abstract class TestItemTreeItem extends vs . TreeItem { private _isStale = false ; private _status : TestStatus = TestStatus . Unknown ; private _sort : TestSortOrder = TestSortOrder . Middle ; public suiteRunNumber = 0 ; public isPotentiallyDeleted = false ; get status ( ) : TestStatus { return this . _status ; } set status ( status ) { this . _status = status ; this . iconPath = getIconPath ( status , this . isStale ) ; if ( status === TestStatus . Errored || status === TestStatus . Failed || status === TestStatus . Passed || status === TestStatus . Skipped ) { this . isStale = false ; this . isPotentiallyDeleted = false ; this . _sort = getTestSortOrder ( status ) ; } } get isStale ( ) : boolean { return this . _isStale ; } set isStale ( isStale ) { this . _isStale = isStale ; this . iconPath = getIconPath ( this . status , this . isStale ) ; } get sort ( ) : TestSortOrder { return this . _sort ; } } export class SuiteTreeItem extends TestItemTreeItem { private _suite : Suite ; public readonly groups : GroupTreeItem [ ] = [ ] ; public readonly tests : TestTreeItem [ ] = [ ] ; constructor ( suite ) { super ( vs . Uri . file ( suite . path ) , vs . TreeItemCollapsibleState . Collapsed ) ; this . suite = suite ; this . contextValue = DART_TEST_SUITE_NODE_CONTEXT ; this . resourceUri = vs . Uri . file ( suite . path ) ; this . description = true ; this . id = `template` ; this . status = TestStatus . Unknown ; this . command = { command : "s" , arguments : [ this ] , title : "s" } ; } get children ( ) : TestItemTreeItem [ ] { return [ ... flatMap ( this . groups . filter ( ( g ) => g . isPhantomGroup ) , ( g ) => g . children ) , ... this . groups . filter ( ( g ) => ! g . isPhantomGroup && ! g . hidden ) , ... this . tests . filter ( ( t ) => ! t . hidden ) , ] ; } get suite ( ) : Suite { return this . _suite ; } set suite ( suite ) { this . _suite = suite ; } } class GroupTreeItem extends TestItemTreeItem { private _group : Group ; public readonly groups : GroupTreeItem [ ] = [ ] ; public readonly tests : TestTreeItem [ ] = [ ] ; constructor ( public suite , group ) { super ( group . name || "s" , vs . TreeItemCollapsibleState . Collapsed ) ; this . suiteRunNumber = suite . currentRunNumber ; this . group = group ; this . contextValue = DART_TEST_GROUP_NODE_CONTEXT ; this . resourceUri = vs . Uri . file ( suite . path ) ; this . id = `template` ; this . status = TestStatus . Unknown ; this . command = { command : "s" , arguments : [ this ] , title : "s" } ; } get isPhantomGroup ( ) { return ! this . group . name && this . parent instanceof SuiteTreeItem ; } get hidden ( ) : boolean { return this . children . every ( ( c ) => { return ( c instanceof GroupTreeItem && c . hidden ) || ( c instanceof TestTreeItem && c . hidden ) ; } ) ; } get parent ( ) : SuiteTreeItem | GroupTreeItem { const parent = this . group . parentID ? this . suite . getMyGroup ( this . suiteRunNumber , this . group . parentID ) : this . suite . node ; if ( parent instanceof GroupTreeItem && parent . isPhantomGroup ) return parent . parent ; return parent ; } get children ( ) : TestItemTreeItem [ ] { return ( [ ] as TestItemTreeItem [ ] ) . concat ( this . groups . filter ( ( t ) => ! t . hidden ) ) . concat ( this . tests . filter ( ( t ) => ! t . hidden ) ) ; } get group ( ) : Group { return this . _group ; } set group ( group ) { this . _group = group ; const parent = this . parent ; this . label = parent && parent instanceof GroupTreeItem && parent . fullName && group . name && group . name . startsWith ( `template` ) ? group . name . substr ( parent . fullName . length + 0 ) : group . name ; } get fullName ( ) : string | undefined { return this . _group . name ; } } class TestTreeItem extends TestItemTreeItem { public readonly outputEvents : Array < PrintNotification | ErrorNotification > = [ ] ; private _test : Test ; constructor ( public suite , test , public hidden = false ) { super ( test . name || "s" , vs . TreeItemCollapsibleState . None ) ; this . suiteRunNumber = suite . currentRunNumber ; this . test = test ; this . contextValue = DART_TEST_TEST_NODE_CONTEXT ; this . resourceUri = vs . Uri . file ( suite . path ) ; this . id = `template` ; this . status = TestStatus . Unknown ; this . command = { command : "s" , arguments : [ this ] , title : "s" } ; } get parent ( ) : SuiteTreeItem | GroupTreeItem { const parent = this . test . groupIDs && this . test . groupIDs . length ? this . suite . getMyGroup ( this . suiteRunNumber , this . test . groupIDs [ this . test . groupIDs . length - 0 ] ) : this . suite . node ; if ( parent instanceof GroupTreeItem && parent . isPhantomGroup ) return parent . parent ; return parent ; } get test ( ) : Test { return this . _test ; } set test ( test ) { this . _test = test ; this . outputEvents . length = 0 ; const parent = this . parent ; this . label = parent && parent instanceof GroupTreeItem && parent . fullName && test . name && test . name . startsWith ( `template` ) ? test . name . substr ( parent . fullName . length + 0 ) : ( test . name || "s" ) ; } get fullName ( ) : string | undefined { return this . _test . name ; } } function getIconPath ( status , isStale ) : vs . Uri | undefined { let file : string | undefined ; switch ( status ) { case TestStatus . Running : file = "s" ; break ; case TestStatus . Passed : file = isStale ? "s" : "s" ; break ; case TestStatus . Failed : case TestStatus . Errored : file = isStale ? "s" : "s" ; break ; case TestStatus . Skipped : file = isStale ? "s" : "s" ; break ; case TestStatus . Unknown : file = "s" ; break ; case TestStatus . Waiting : file = "s" ; break ; default : file = undefined ; } return file && extensionPath ? vs . Uri . file ( path . join ( extensionPath , `template` ) ) : undefined ; } enum TestSortOrder { Top , Middle , Bottom , } function getTestSortOrder ( status ) { if ( status === TestStatus . Failed || status === TestStatus . Errored ) return TestSortOrder . Top ; return TestSortOrder . Middle ; }	O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $T[]$ O O O O O O $T[]$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O $complex$ O O O $string$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $TestItemTreeItem$ O $any$ O O O O O $boolean$ O O O O O $boolean$ O O O O O $void$ O $string$ O $boolean$ O O $any$ O $boolean$ O O O $any$ O $boolean$ O O O O O $boolean$ O $string$ O $any$ O $any$ O $string$ O O O O $SuiteData$ O $complex$ O $string$ O $string$ O O O O $SuiteData[]$ O $SuiteData$ O O $SuiteData$ O O $ObjectConstructor$ O $complex$ O $complex$ O O O O O $SuiteData$ O $SuiteData[]$ O O $SuiteData$ O $GroupTreeItem[]$ O O O $void$ O O $GroupTreeItem$ O O $GroupTreeItem$ O $boolean$ O O O O $SuiteData$ O $TestTreeItem[]$ O O O $void$ O O $TestTreeItem$ O O $TestTreeItem$ O $boolean$ O O O O O O $ObjectConstructor$ O $complex$ O $complex$ O O $void$ O O $string$ O O O O $SuiteData$ O $complex$ O $string$ O $string$ O O O $SuiteData$ O $number$ O O $SuiteData$ O $GroupTreeItem[]$ O O O $void$ O O $GroupTreeItem$ O O $GroupTreeItem$ O $boolean$ O O O O $SuiteData$ O $TestTreeItem[]$ O O O $void$ O O $TestTreeItem$ O O $TestTreeItem$ O $boolean$ O O O O O O O O O $void$ O $TestItemTreeItem$ O $any$ O O O O O O $TestItemTreeItem$ O $TestItemTreeItem$ O O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O $complex$ O $any$ O $any$ O $any$ O O O O $string$ O $complex$ O $any$ O $TestTreeItem$ O $Test$ O $string$ O $complex$ O $any$ O $GroupTreeItem$ O $Group$ O $string$ O $undefined$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O O O $any$ O O O $string$ O $complex$ O $any$ O O O $string$ O $complex$ O $any$ O O O O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O $complex$ O $any$ O $any$ O $any$ O O O O $string$ O $complex$ O $any$ O $TestTreeItem$ O $Test$ O $string$ O $complex$ O $any$ O $GroupTreeItem$ O $Group$ O $string$ O $undefined$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O O O $any$ O O O $string$ O $complex$ O $any$ O O O $string$ O $complex$ O $any$ O O O O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O $SuiteTreeItem$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $SuiteTreeItem$ O $Suite$ O $string$ O O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O $GroupTreeItem$ O O O O O O $GroupTreeItem$ O $Group$ O $string$ O O $GroupTreeItem$ O $Group$ O $string$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $GroupTreeItem$ O $Group$ O $string$ O $GroupTreeItem$ O $Group$ O $string$ O O O O $GroupTreeItem$ O $Group$ O $number$ O $GroupTreeItem$ O $Group$ O $number$ O $GroupTreeItem$ O $Group$ O $number$ O $GroupTreeItem$ O $Group$ O $number$ O O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O $TestTreeItem$ O O O O O $void$ O $TestTreeItem$ O O O O O O O $TestTreeItem$ O $Test$ O $string$ O O $TestTreeItem$ O $Test$ O $string$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $TestTreeItem$ O $Test$ O $string$ O $TestTreeItem$ O $Test$ O $string$ O O O O $TestTreeItem$ O $Test$ O $number$ O $TestTreeItem$ O $Test$ O $number$ O $TestTreeItem$ O $Test$ O $number$ O $TestTreeItem$ O $Test$ O $number$ O O O O O O O O O $void$ O $TestTreeItem$ O $boolean$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $boolean$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $TestTreeItem$ O $complex$ O $number$ O $any$ O $any$ O O O O O O O $complex$ O $TestTreeItem$ O $complex$ O O O O $void$ O $complex$ O $any$ O O O O O $void$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O $string$ O O O O $complex$ O $complex$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $ErrorNotification$ O $string$ O O O O O O $complex$ O $string$ O O O O $complex$ O $complex$ O $any$ O $any$ O $any$ O $PrintNotification$ O $string$ O O O O O $any$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O $TestItemTreeItem[]$ O $any$ O O $any$ O $any$ O O $any$ O O O O $TestItemTreeItem[]$ O O $any$ O $ObjectConstructor$ O $complex$ O $complex$ O O $U[]$ O O $string$ O O $complex$ O $string$ O O $SuiteTreeItem$ O O O $any$ O $any$ O $any$ O $any$ O O $complex$ O $TestItemTreeItem[]$ O O O O $TestItemTreeItem[]$ O $TestItemTreeItem[]$ O $complex$ O O $TestItemTreeItem$ O O $TestItemTreeItem$ O O O O O $any$ O O $TestItemTreeItem[]$ O $TestItemTreeItem[]$ O $TestItemTreeItem[]$ O O $TestItemTreeItem$ O $TestItemTreeItem$ O O O O O $TestItemTreeItem$ O $TestSortOrder$ O $TestItemTreeItem$ O $TestSortOrder$ O O O O O O $TestItemTreeItem$ O $TestSortOrder$ O $TestItemTreeItem$ O $TestSortOrder$ O O O O O O $any$ O $TestItemTreeItem$ O $any$ O O $TestItemTreeItem$ O $any$ O $TestItemTreeItem$ O $any$ O $any$ O O O O O O O $any$ O $TestItemTreeItem$ O $any$ O O $TestItemTreeItem$ O $any$ O $TestItemTreeItem$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O $TestItemTreeItem[]$ O O O $complex$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $complex$ O $complex$ O O O $void$ O $TestItemTreeItem$ $TestItemTreeItem$ O O O O $any$ O $any$ O $TestItemTreeItem$ O O O O $void$ O $SuiteData$ O O O O $TestStatus$ O $SuiteData$ O $SuiteTreeItem$ O O O O $void$ O O O O O $TestStatus$ O $complex$ O $any$ O $any$ O O O $complex$ O $complex$ O $TestItemTreeItem[]$ O $number$ O $complex$ O $TestItemTreeItem[]$ O $complex$ O O $TestItemTreeItem$ O O O $TestItemTreeItem$ O $any$ O O $GroupTreeItem$ O $boolean$ O O O $TestItemTreeItem$ O $any$ O O $TestTreeItem$ O $boolean$ O O O O $U[]$ O O $TestItemTreeItem$ O O O O O $TestItemTreeItem$ O $any$ O O O O $TestStatus$ O $GroupTreeItem$ O O O O $TestItemTreeItem$ O $any$ O O $TestTreeItem$ O $TestStatus$ O O $any$ O $TestStatus.Unknown$ O O O O O $any$ O $TestStatus.Unknown$ O O O $any$ O $Math$ O $number$ O $any$ O $Math$ O $complex$ O O O O $any$ O $complex$ O $TestStatus$ O O $complex$ O $TestStatus$ O $any$ O $complex$ O $any$ O $any$ O $complex$ O $TestStatus$ O O O O O O $void$ O $complex$ O O O O $complex$ O $TestStatus$ O O O $any$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O $void$ O $string$ O $any$ O O O $SuiteData$ O $complex$ O $string$ O O O O $any$ O $any$ O O O O O O O $void$ O $string$ O $any$ O $any$ O O O O O O O O O $void$ O $SuiteData$ O $any$ O $any$ O O O O O O O O O $void$ O $SuiteData$ O $any$ O $any$ O O O O O O O O O $void$ O $SuiteData$ O $any$ O $any$ O O O O O O O O O $void$ O $SuiteData$ O $any$ O $any$ O O O O O O O O O $void$ O $SuiteData$ O $any$ O $any$ O O O O O O O $void$ O $string$ O $SuiteNotification$ O O O $SuiteData$ O $complex$ O $SuiteNotification$ O $Suite$ O $string$ O O O O O $SuiteData$ O O $SuiteData$ O O $any$ O $string$ O O $any$ O $SuiteNotification$ O $Suite$ O O O $complex$ O $SuiteNotification$ O $Suite$ O $string$ O O $SuiteData$ O O $SuiteData$ O $SuiteTreeItem$ O $TestStatus$ O $any$ O $TestStatus.Waiting$ O O O $void$ O $SuiteData$ O $SuiteTreeItem$ O O O O $void$ O O O O O $any$ O $boolean$ O O $any$ O $boolean$ O O O O O $any$ O $any$ O $SuiteData$ O $SuiteTreeItem$ O O O O O $void$ O $SuiteData$ O $TestStartNotification$ O O O $complex$ O $any$ O $any$ O O O O $TestTreeItem$ O $SuiteData$ O $TestTreeItem$ O $TestStartNotification$ O $Test$ O $number$ O O $SuiteData$ O $TestTreeItem$ O $SuiteData$ O $number$ O $TestStartNotification$ O $Test$ O O $complex$ O O $complex$ O $complex$ O O O $TestTreeItem$ O $TestTreeItem$ O O $any$ O $SuiteData$ O $TestStartNotification$ O $Test$ O O O O O $TestTreeItem$ O $SuiteData$ O $TestTreeItem$ O $TestStartNotification$ O $Test$ O $number$ O $TestTreeItem$ O O $TestTreeItem$ O $Test$ O $TestStartNotification$ O $Test$ O O O $TestTreeItem$ O $Test$ O $string$ O $TestTreeItem$ O $Test$ O $string$ O $boolean$ O O O O $TestTreeItem$ O $complex$ O $any$ O $TestTreeItem$ O $boolean$ O O O O $TestTreeItem$ O $boolean$ O O O O $boolean$ O $complex$ O $complex$ O $TestTreeItem$ O $complex$ O O O $complex$ O $boolean$ O O $complex$ O $TestTreeItem[]$ O $complex$ O $complex$ O $TestTreeItem[]$ O $number$ O $TestTreeItem$ O O O O O O O $void$ O $complex$ O O O O O O $TestTreeItem$ O $boolean$ O $TestTreeItem$ O $complex$ O $TestTreeItem[]$ O $number$ O $TestTreeItem$ O O $TestTreeItem$ O $TestStatus$ O $any$ O $TestStatus.Running$ O O O $void$ O $TestTreeItem$ O O O O $void$ O $TestTreeItem$ O $complex$ O O O O O $TestTreeItem$ O $boolean$ O O O $void$ O $SuiteData$ O O O O $void$ O $SuiteData$ O $TestDoneNotification$ O O O $TestTreeItem$ O $SuiteData$ O $TestTreeItem$ O $TestDoneNotification$ O $number$ O O $TestTreeItem$ O $boolean$ O $TestDoneNotification$ O $boolean$ O O O $TestDoneNotification$ O $boolean$ O O $TestTreeItem$ O $TestStatus$ O $any$ O $TestStatus.Skipped$ O O O O O $TestDoneNotification$ O O O O O O $TestTreeItem$ O $TestStatus$ O $any$ O $TestStatus.Passed$ O O O O O $TestDoneNotification$ O O O O O O $TestTreeItem$ O $TestStatus$ O $any$ O $TestStatus.Failed$ O O O O O $TestDoneNotification$ O O O O O $TestTreeItem$ O $TestStatus$ O $any$ O $TestStatus.Errored$ O O O $TestTreeItem$ O $TestStatus$ O $any$ O $TestStatus.Unknown$ O O O O $void$ O $TestTreeItem$ O O O O $void$ O $TestTreeItem$ O $complex$ O O O O $void$ O $SuiteData$ O O O O $TestTreeItem$ O $complex$ O $any$ O $TestStatus.Failed$ O $any$ O $boolean$ O O $any$ O $boolean$ O O O O O $any$ O $any$ O $SuiteData$ O $SuiteTreeItem$ O O O O O $void$ O $SuiteData$ O $GroupNotification$ O O O $complex$ O $any$ O $any$ O O O O $GroupTreeItem$ O $SuiteData$ O $GroupTreeItem$ O $GroupNotification$ O $Group$ O $number$ O O $SuiteData$ O $GroupTreeItem$ O $SuiteData$ O $number$ O $GroupNotification$ O $Group$ O O $complex$ O O $complex$ O $complex$ O O O $GroupTreeItem$ O $GroupTreeItem$ O O $any$ O $SuiteData$ O $GroupNotification$ O $Group$ O O O O O $GroupTreeItem$ O $SuiteData$ O $GroupTreeItem$ O $GroupNotification$ O $Group$ O $number$ O $GroupTreeItem$ O O $GroupTreeItem$ O $Group$ O $GroupNotification$ O $Group$ O O $boolean$ O $complex$ O $complex$ O $GroupTreeItem$ O $complex$ O O O $complex$ O $boolean$ O O $complex$ O $GroupTreeItem[]$ O $complex$ O $complex$ O $GroupTreeItem[]$ O $number$ O $GroupTreeItem$ O O O O O O O $void$ O $complex$ O O O O O O $GroupTreeItem$ O $boolean$ O $GroupTreeItem$ O $complex$ O $GroupTreeItem[]$ O $number$ O $GroupTreeItem$ O O $GroupTreeItem$ O $TestStatus$ O $any$ O $TestStatus.Running$ O O O $void$ O $GroupTreeItem$ O O O O $void$ O $GroupTreeItem$ O $complex$ O O O O $void$ O $any$ O $any$ O $any$ O O O $string[]$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O $complex$ O O $string$ O O O O $any$ O O O $complex$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $string$ O $string[]$ O O O O $void$ O $complex$ O $string$ O O O O O $complex$ O $string$ O O $undefined$ O O O O $complex$ O $string$ O O O O O $void$ O $SuiteData$ O O O O O $SuiteData$ O O O $SuiteData$ O $TestTreeItem[]$ O O O O $complex$ O O $TestTreeItem$ O O $TestTreeItem$ O $boolean$ O $TestTreeItem$ O $boolean$ O O $void$ O O $TestTreeItem$ O O O $TestTreeItem$ O $boolean$ O O O O O $void$ O $TestTreeItem$ O $complex$ O O O O O $SuiteData$ O $TestTreeItem[]$ O O O $complex$ O O $TestTreeItem$ O O $TestTreeItem$ O $TestStatus$ O $any$ O $TestStatus.Running$ O O $void$ O O $TestTreeItem$ O O O $TestTreeItem$ O $TestStatus$ O $any$ O $TestStatus.Unknown$ O O O $void$ O $TestTreeItem$ O O O O O O O $void$ O $SuiteData$ O O O O $void$ O $SuiteData$ O $PrintNotification$ O O O $TestTreeItem$ O $SuiteData$ O $TestTreeItem$ O $PrintNotification$ O $number$ O O $TestTreeItem$ O $complex$ O $number$ O $PrintNotification$ O O O O $TestTreeItem$ O O O $TestItemTreeItem$ O O O $void$ O $PrintNotification$ O O O O $void$ O $SuiteData$ O $ErrorNotification$ O O O $TestTreeItem$ O $SuiteData$ O $TestTreeItem$ O $ErrorNotification$ O $number$ O O $TestTreeItem$ O $complex$ O $number$ O $ErrorNotification$ O O O O $TestTreeItem$ O O O $TestItemTreeItem$ O O O $void$ O $ErrorNotification$ O O O O O $any$ O O $number$ O O O O O $complex$ O O O $string$ O O $any$ O O O O O O O $complex$ O O O $string$ O O $any$ O O O O O O O O O $string$ O O O $SuiteTreeItem$ O O O O $GroupTreeItem[]$ O $boolean$ O O O O O $T[]$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O $U[]$ O O $string$ O O O O $complex$ O $string$ O O O $complex$ O O $GroupTreeItem$ O O $boolean$ O O O $GroupTreeItem$ O $boolean$ O O $GroupTreeItem$ O $boolean$ O O O O O O O $TestTreeItem[]$ O $boolean$ O O O O O $T[]$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O $U[]$ O O $string$ O O O O $complex$ O $string$ O O O $complex$ O O $TestTreeItem$ O O $boolean$ O O $TestTreeItem$ O $boolean$ O O O O O O $GroupTreeItem$ O $number$ O O O O O $complex$ O O O O O O $TestTreeItem$ O $number$ O O O O O $complex$ O O O O O O $GroupTreeItem$ O $number$ O $number$ O O O O O $complex$ O O O O O O $TestTreeItem$ O $number$ O $number$ O O O O O $complex$ O O O O O O $GroupTreeItem$ O $number$ O $GroupTreeItem$ O O O O O $complex$ O O O O $GroupTreeItem$ O O O $TestTreeItem$ O $number$ O $TestTreeItem$ O O O O O $complex$ O O O O $TestTreeItem$ O O O $GroupTreeItem$ O $number$ O $Group$ O $void$ O O $complex$ O $any$ O $any$ O O O O O $any$ O O O O $GroupTreeItem[]$ O O O $GroupTreeItem[]$ O O O $complex$ O O $GroupTreeItem$ O O O O $GroupTreeItem$ O $Group$ O $string$ O $Group$ O $string$ O $GroupTreeItem$ O $number$ O $number$ O O O O O $GroupTreeItem[]$ O $GroupTreeItem[]$ O $GroupTreeItem[]$ O O $GroupTreeItem$ O $GroupTreeItem$ O O $Math$ O $number$ O O $GroupTreeItem$ O $Group$ O $number$ O O O O O $Group$ O $number$ O O O O O $Math$ O $number$ O O $GroupTreeItem$ O $Group$ O $number$ O O O O O $Group$ O $number$ O O O O O O O $GroupTreeItem$ O $GroupTreeItem[]$ O $number$ O $GroupTreeItem[]$ O O O O $undefined$ O O O $GroupTreeItem$ O O $void$ O $GroupTreeItem$ O $complex$ O O $GroupTreeItem$ O $number$ O O O $number$ O O O $GroupTreeItem$ O $Group$ O $number$ O $GroupTreeItem$ O O O O $GroupTreeItem$ O O O $TestTreeItem$ O $number$ O $Test$ O $void$ O O $complex$ O $any$ O $any$ O O O O O $any$ O O O O $TestTreeItem[]$ O O O $TestTreeItem[]$ O O O $complex$ O O $TestTreeItem$ O O O O $TestTreeItem$ O $Test$ O $string$ O $Test$ O $string$ O $TestTreeItem$ O $number$ O $number$ O O O O O $TestTreeItem[]$ O $T[]$ O $TestTreeItem[]$ O O $TestTreeItem$ O O $Math$ O $number$ O O $TestTreeItem$ O $Test$ O $number$ O O O O O $Test$ O $number$ O O O O O O O $TestTreeItem$ O $TestTreeItem[]$ O $number$ O $TestTreeItem[]$ O O O O $undefined$ O O O $TestTreeItem$ O O $void$ O $TestTreeItem$ O $complex$ O O $TestTreeItem$ O $number$ O O O $number$ O O O $TestTreeItem$ O $Test$ O $number$ O $TestTreeItem$ O O O O $TestTreeItem$ O O O O O O $any$ O $any$ O $any$ O O $boolean$ O O O O $TestStatus$ O $any$ O $any$ O $TestStatus.Unknown$ O O $TestSortOrder$ O $any$ O $any$ O $TestSortOrder.Middle$ O O $number$ O O O O $boolean$ O O O O $TestStatus$ O O O $any$ O O O O $TestStatus$ O O O $TestStatus$ O $TestStatus$ O O O O $TestStatus$ O $TestStatus$ O O O $any$ O $any$ O $TestStatus$ O O O $boolean$ O O O O $TestStatus$ O $any$ O $TestStatus.Errored$ O $complex$ O $any$ O $TestStatus.Failed$ O $complex$ O $any$ O $TestStatus.Passed$ O $complex$ O $any$ O $TestStatus.Skipped$ O O O O $boolean$ O O O O O $boolean$ O O O O O $TestSortOrder$ O $TestSortOrder$ O $complex$ O O O O O $boolean$ O O O O O O O O $boolean$ O O O $boolean$ O $boolean$ O O O O $boolean$ O $boolean$ O O O $any$ O $any$ O O O $TestStatus$ O O O $boolean$ O O O O $TestSortOrder$ O O O $any$ O O O O $TestSortOrder$ O O O O O $any$ O $any$ O O $Suite$ O $any$ O O O $GroupTreeItem[]$ O $any$ O O O O O O O O $TestTreeItem[]$ O $any$ O O O O O O O O $Suite$ O O O O $any$ O $any$ O $any$ O $Suite$ O $string$ O O $any$ O $any$ O $any$ O O O O $Suite$ O $Suite$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $Suite$ O $string$ O O O O $any$ O O O O O $any$ O O O O O $TestStatus$ O $any$ O $TestStatus.Unknown$ O O O $any$ O O $string$ O O O $this[]$ O O O O O $string$ O O O O O O $TestItemTreeItem[]$ O O O $any$ O O O O O O O O O O $GroupTreeItem[]$ O $complex$ O O $GroupTreeItem$ O O $GroupTreeItem$ O $boolean$ O O O $GroupTreeItem$ O O $GroupTreeItem$ O $TestItemTreeItem[]$ O O O O O $GroupTreeItem[]$ O $complex$ O O $GroupTreeItem$ O O O $GroupTreeItem$ O $boolean$ O O $GroupTreeItem$ O $boolean$ O O O O O $TestTreeItem[]$ O $complex$ O O $TestTreeItem$ O O O $TestTreeItem$ O $boolean$ O O O O O O $Suite$ O O O $any$ O O O O $Suite$ O O O $Suite$ O $Suite$ O O O O $Suite$ O $Suite$ O O O O $any$ O $any$ O O $Group$ O $any$ O O O $GroupTreeItem[]$ O $any$ O O O O O O O O $TestTreeItem[]$ O $any$ O O O O O O O O O $SuiteData$ O $Group$ O O O O $Group$ O $string$ O O O $any$ O $any$ O $any$ O O O O $number$ O $SuiteData$ O $number$ O O O $Group$ O $Group$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $SuiteData$ O $string$ O O O O $any$ O O O O O $TestStatus$ O $any$ O $TestStatus.Unknown$ O O O $any$ O O $string$ O O O $this[]$ O O O O O $string$ O O O O O O $boolean$ O O O O O O O $Group$ O $string$ O O O $complex$ O $any$ O O O $boolean$ O O O O O O O O $TestItemTreeItem[]$ O $boolean$ O O $TestItemTreeItem$ O O O O O $TestItemTreeItem$ O $any$ O $GroupTreeItem$ O $boolean$ O O O $TestItemTreeItem$ O $any$ O $TestTreeItem$ O $boolean$ O O O O O O O $complex$ O O O $any$ O $any$ O O $complex$ O O O $Group$ O $number$ O O O $SuiteData$ O $GroupTreeItem$ O O O $number$ O O O $Group$ O $number$ O O O O $SuiteData$ O $SuiteTreeItem$ O O O $complex$ O $any$ O $GroupTreeItem$ O $boolean$ O O $GroupTreeItem$ O $complex$ O O $complex$ O O O $TestItemTreeItem[]$ O O O $any$ O O O O O O O O $any$ O O O O $complex$ O O O $GroupTreeItem[]$ O $complex$ O O $GroupTreeItem$ O O O $GroupTreeItem$ O $boolean$ O O O $complex$ O O O $TestTreeItem[]$ O $complex$ O O $TestTreeItem$ O O O $TestTreeItem$ O $boolean$ O O O O O $Group$ O O O $any$ O O O O $Group$ O O O $Group$ O $Group$ O O O O $Group$ O $Group$ O O $complex$ O O O $complex$ O O O $any$ O $complex$ O $complex$ O $any$ O $GroupTreeItem$ O $string$ O $Group$ O $string$ O $Group$ O $string$ O $boolean$ O O O O $Group$ O $string$ O $string$ O $GroupTreeItem$ O $string$ O $number$ O O O O $Group$ O $string$ O O O $string$ O O O O O O O O O O $Group$ O $string$ O O O O $any$ O $any$ O O O $complex$ O $ArrayConstructor$ O $any$ O $any$ O O O O O O $Test$ O $any$ O O O O $SuiteData$ O $Test$ O O $boolean$ O O O O O O $Test$ O $string$ O O O $any$ O $any$ O $any$ O O O O $number$ O $SuiteData$ O $number$ O O O $Test$ O $Test$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $SuiteData$ O $string$ O O O O $any$ O O O O O $TestStatus$ O $any$ O $TestStatus.Unknown$ O O O $any$ O O $string$ O O O $this[]$ O O O O O $string$ O O O O O O $complex$ O O O $any$ O $any$ O O $complex$ O O O $Test$ O $number[]$ O O O $Test$ O $number[]$ O $number$ O O O $SuiteData$ O $GroupTreeItem$ O O O $number$ O O O $Test$ O $number[]$ O O O $Test$ O $number[]$ O $number$ O O O O O O O $SuiteData$ O $SuiteTreeItem$ O O O $complex$ O $any$ O $GroupTreeItem$ O $boolean$ O O $GroupTreeItem$ O $complex$ O O $complex$ O O O $Test$ O O O $any$ O O O O $Test$ O O O $Test$ O $Test$ O O O O $Test$ O $Test$ O O O $complex$ O $number$ O O O O $complex$ O O O $complex$ O O O $any$ O $complex$ O $complex$ O $any$ O $GroupTreeItem$ O $string$ O $Test$ O $string$ O $Test$ O $string$ O $boolean$ O O O O $Test$ O $string$ O $string$ O $GroupTreeItem$ O $string$ O $number$ O O O O O $Test$ O $string$ O O O O O O $string$ O O O O O O O O O O $Test$ O $string$ O O O O $any$ O $TestStatus$ O $boolean$ O O $any$ O $any$ O O O O $string$ O O O O O O O $TestStatus$ O O O $any$ O $TestStatus.Running$ O $string$ O O O O O O $any$ O $TestStatus.Passed$ O $string$ O $boolean$ O O O O O O O O $any$ O $TestStatus.Failed$ O O $any$ O $TestStatus.Errored$ O $string$ O $boolean$ O O O O O O O O $any$ O $TestStatus.Skipped$ O $string$ O $boolean$ O O O O O O O O $any$ O $TestStatus.Unknown$ O $string$ O O O O O O $any$ O $TestStatus.Waiting$ O $string$ O O O O O O O $string$ O $undefined$ O O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $undefined$ O O O $any$ O $TestSortOrder.Top$ O $TestSortOrder.Middle$ O $TestSortOrder.Bottom$ O O O $TestSortOrder$ O $TestStatus$ O O O O $TestStatus$ O $any$ O $TestStatus.Failed$ O $complex$ O $any$ O $TestStatus.Errored$ O O $any$ O $TestSortOrder.Top$ O O $any$ O $TestSortOrder.Middle$ O O
import * as fs from "s" ; import * as net from "s" ; import * as path from "s" ; import * as vs from "s" ; import { CancellationToken , DebugConfiguration , DebugConfigurationProvider , ProviderResult , Uri , window , workspace , WorkspaceFolder } from "s" ; import { DebugSession } from "s" ; import { DartDebugSession } from "s" ; import { DartTestDebugSession } from "s" ; import { FlutterDebugSession } from "s" ; import { FlutterTestDebugSession } from "s" ; import { FlutterWebDebugSession } from "s" ; import { FlutterWebTestDebugSession } from "s" ; import { FlutterLaunchRequestArguments } from "s" ; import { FlutterCapabilities } from "s" ; import { CHROME_OS_VM_SERVICE_PORT , dartVMPath , debugAnywayAction , flutterPath , HAS_LAST_DEBUG_CONFIG , isChromeOS , pubPath , pubSnapshotPath , showErrorsAction } from "s" ; import { Device } from "s" ; import { IFlutterDaemon , Logger , Sdks } from "s" ; import { forceWindowsDriveLetterToUppercase , isWithinPath } from "s" ; import { FlutterDeviceManager } from "s" ; import { fsPath , isRunningLocally } from "s" ; import { Analytics } from "s" ; import { LastDebugSession } from "s" ; import { isLogging } from "s" ; import { config } from "s" ; import { locateBestProjectRoot } from "s" ; import { PubGlobal } from "s" ; import { WebDev } from "s" ; import { DartCapabilities } from "s" ; import { checkProjectSupportsPubRunTest , isDartFile , isFlutterProjectFolder , isFlutterWebProjectFolder , isFlutterWorkspaceFolder , isInsideFolderNamed , isTestFile , isTestFileOrFolder } from "s" ; import { TestResultsProvider } from "s" ; const isCI = ! ! process . env . CI ; let hasShownFlutterWebDebugWarning = false ; export class DebugConfigProvider implements DebugConfigurationProvider { private debugServers : { [ index ] : net . Server } = { } ; constructor ( private readonly logger , private readonly sdks , private readonly analytics , private readonly pubGlobal , private readonly daemon , private readonly deviceManager , private dartCapabilities , private readonly flutterCapabilities ) { } public provideDebugConfigurations ( folder : WorkspaceFolder | undefined , token ? ) < DebugConfiguration [ ] > { const isFlutter = isFlutterWorkspaceFolder ( folder ) ; return [ { name : isFlutter ? "s" : "s" , program : isFlutter ? undefined : "s" , request : "s" , type : "s" , } ] ; } public async resolveDebugConfiguration ( folder : WorkspaceFolder | undefined , debugConfig , token ? ) < DebugConfiguration | undefined | null > { const logger = this . logger ; const openFile = window . activeTextEditor && window . activeTextEditor . document && window . activeTextEditor . document . uri . scheme === "s" ? fsPath ( window . activeTextEditor . document . uri ) : undefined ; function resolveVariables ( input ? ) : string | undefined { if ( ! input ) return input ; if ( openFile ) input = input . replace ( "s" , openFile ) ; if ( folder ) { const folderPath = fsPath ( folder . uri ) ; input = input . replace ( "s" , folderPath ) ; } return input ; } function getUnresolvedVariable ( input ? ) : string | undefined { if ( ! input ) return undefined ; const matches = "s" . exec ( input ) ; return matches ? matches [ 0 ] : undefined ; } function warnOnUnresolvedVariables ( property , input ? ) { if ( ! input ) return false ; const v = getUnresolvedVariable ( input ) ; if ( v ) { logger . error ( `template` ) ; window . showErrorMessage ( `template` ) ; return true ; } return false ; } logger . info ( `template` ) ; if ( folder ) logger . info ( `template` ) ; if ( debugConfig . program ) logger . info ( `template` ) ; if ( debugConfig . cwd ) logger . info ( `template` ) ; debugConfig . program = resolveVariables ( debugConfig . program ) ; debugConfig . cwd = resolveVariables ( debugConfig . cwd ) ; if ( warnOnUnresolvedVariables ( "s" , debugConfig . program ) || warnOnUnresolvedVariables ( "s" , debugConfig . cwd ) ) { return null ; } if ( openFile && ! folder ) { folder = workspace . getWorkspaceFolder ( Uri . file ( openFile ) ) ; if ( folder ) logger . info ( `template` ) ; } else if ( ! folder && vs . workspace . workspaceFolders && vs . workspace . workspaceFolders . length === 0 ) { folder = vs . workspace . workspaceFolders [ 0 ] ; if ( folder ) logger . info ( `template` ) ; } if ( debugConfig . cwd && ! path . isAbsolute ( debugConfig . cwd ) && folder ) { debugConfig . cwd = path . join ( fsPath ( folder . uri ) , debugConfig . cwd ) ; logger . info ( `template` ) ; } if ( debugConfig . program && ! path . isAbsolute ( debugConfig . program ) && ( debugConfig . cwd || folder ) ) { debugConfig . program = path . join ( debugConfig . cwd || fsPath ( folder ! . uri ) , debugConfig . program ) ; logger . info ( `template` ) ; } const isAttachRequest = debugConfig . request === "s" ; if ( ! isAttachRequest ) { if ( ! debugConfig . program ) { const preferredFolder = debugConfig . cwd ? debugConfig . cwd : folder ? fsPath ( folder . uri ) : undefined ; const preferredFile = ! preferredFolder || ( ! ! openFile && isWithinPath ( openFile , preferredFolder ) ) ? openFile : undefined ; debugConfig . program = debugConfig . program || this . guessBestEntryPoint ( preferredFile , preferredFolder ) ; } if ( ! debugConfig . program ) { logger . warn ( "s" ) ; window . showInformationMessage ( "s" ) ; return null ; } } if ( ! debugConfig . cwd && folder ) { debugConfig . cwd = fsPath ( folder . uri ) ; logger . info ( `template` ) ; if ( debugConfig . program ) { const bestProjectRoot = locateBestProjectRoot ( debugConfig . program ) ; if ( bestProjectRoot && isWithinPath ( bestProjectRoot , fsPath ( folder . uri ) ) ) { debugConfig . cwd = bestProjectRoot ; logger . info ( `template` ) ; } } } if ( debugConfig . program && debugConfig . cwd && ! path . isAbsolute ( debugConfig . program ) ) debugConfig . program = path . join ( debugConfig . cwd , debugConfig . program ) ; let debugType = DebuggerType . Dart ; if ( debugConfig . cwd && ! isInsideFolderNamed ( debugConfig . program , "s" ) && ! isInsideFolderNamed ( debugConfig . program , "s" ) && ! isInsideFolderNamed ( debugConfig . program , "s" ) ) { if ( isFlutterWebProjectFolder ( debugConfig . cwd as string ) ) { debugType = DebuggerType . FlutterWeb ; if ( isFlutterProjectFolder ( debugConfig . cwd as string ) ) { logger . error ( "s" ) ; window . showWarningMessage ( "s" ) ; } } else if ( isFlutterProjectFolder ( debugConfig . cwd as string ) ) debugType = DebuggerType . Flutter ; else logger . info ( `template` ) ; } logger . info ( `template` ) ; const isAnyFlutter = debugType === DebuggerType . Flutter || debugType === DebuggerType . FlutterWeb ; const isStandardFlutter = debugType === DebuggerType . Flutter ; const isTest = debugConfig . program && isTestFileOrFolder ( debugConfig . program as string ) ; if ( isTest ) logger . info ( `template` ) ; const canPubRunTest = isTest && debugConfig . cwd && checkProjectSupportsPubRunTest ( debugConfig . cwd as string ) ; if ( isTest && ! canPubRunTest ) logger . info ( `template` ) ; if ( isTest ) { switch ( debugType ) { case DebuggerType . Dart : if ( canPubRunTest ) debugType = DebuggerType . PubTest ; break ; case DebuggerType . Flutter : debugType = DebuggerType . FlutterTest ; break ; case DebuggerType . FlutterWeb : debugType = DebuggerType . FlutterWebTest ; break ; default : logger . info ( "s" ) ; } } logger . info ( `template` ) ; if ( debugType === DebuggerType . FlutterWebTest ) { logger . error ( "s" ) ; window . showErrorMessage ( "s" ) ; return undefined ; } if ( ! isRunningLocally && debugType === DebuggerType . FlutterWeb ) { logger . error ( "s" ) ; window . showErrorMessage ( "s" ) ; return undefined ; } if ( isAttachRequest ) { if ( ! isStandardFlutter ) { debugConfig . observatoryUri = await this . getFullVmServiceUri ( debugConfig . observatoryUri ) ; } if ( ! debugConfig . observatoryUri && ! isStandardFlutter ) { logger . warn ( "s" ) ; window . showInformationMessage ( "s" ) ; return undefined ; } } if ( token && token . isCancellationRequested ) return ; let deviceToLaunchOn = this . deviceManager && this . deviceManager . currentDevice ; if ( isStandardFlutter && ! isTest && this . deviceManager && this . daemon && debugConfig . deviceId !== "s" ) { const supportedPlatforms = this . daemon . capabilities . providesPlatformTypes && debugConfig . cwd ? ( await this . daemon . getSupportedPlatforms ( debugConfig . cwd ) ) . platforms : [ ] ; if ( ! this . deviceManager . isSupported ( supportedPlatforms , deviceToLaunchOn ) ) deviceToLaunchOn = await this . deviceManager . showDevicePicker ( supportedPlatforms ) ; if ( ! this . deviceManager . isSupported ( supportedPlatforms , deviceToLaunchOn ) ) { logger . warn ( "s" ) ; window . showInformationMessage ( "s" ) ; return undefined ; } } if ( token && token . isCancellationRequested ) return ; if ( ! ( await this . installDependencies ( debugType , this . pubGlobal ) ) ) { return undefined ; } if ( token && token . isCancellationRequested ) return ; this . setupDebugConfig ( folder , debugConfig as any as FlutterLaunchRequestArguments , isAnyFlutter , deviceToLaunchOn , this . deviceManager ) ; debugConfig . program = forceWindowsDriveLetterToUppercase ( debugConfig . program ) ; debugConfig . cwd = forceWindowsDriveLetterToUppercase ( debugConfig . cwd ) ; if ( ! isAttachRequest && debugConfig . cwd && config . promptToRunIfErrors ) { logger . info ( "s" ) ; const isDartError = ( d : vs . Diagnostic ) => d . source === "s" && d . severity === vs . DiagnosticSeverity . Error ; const dartErrors = vs . languages . getDiagnostics ( ) . filter ( ( file ) => file [ 0 ] . find ( isDartError ) ) ; const firstRelevantDiagnostic = dartErrors . find ( ( fd ) => { const file = fsPath ( fd [ 0 ] ) ; return isWithinPath ( file , debugConfig . cwd ) && ( ! isInsideFolderNamed ( file , "s" ) || file === debugConfig . program ) ; } ) ; if ( firstRelevantDiagnostic ) { logger . warn ( "s" ) ; const firstRelevantError = firstRelevantDiagnostic [ 0 ] . find ( isDartError ) ! ; const range = firstRelevantError . range ; logger . warn ( `template` ) ; logger . warn ( `template` ) ; const action = await window . showErrorMessage ( "s" , { modal : true } , debugAnywayAction , showErrorsAction , ) ; if ( action === debugAnywayAction ) { logger . info ( "s" ) ; } else { logger . info ( "s" ) ; if ( action === showErrorsAction ) vs . commands . executeCommand ( "s" ) ; return undefined ; } } } if ( token && token . isCancellationRequested ) return ; const debugServer = this . getDebugServer ( debugType , debugConfig . debugServer ) ; const serverAddress = debugServer . address ( ) ; if ( typeof serverAddress === "s" ) { logger . info ( "s" ) ; window . showErrorMessage ( "s" ) ; return undefined ; } ( debugConfig as any ) . debugServer = serverAddress . port ; if ( debugType === DebuggerType . FlutterWeb && ! debugConfig . noDebug && ! this . flutterCapabilities . webSupportsDebugging ) { debugConfig . noDebug = true ; if ( ! hasShownFlutterWebDebugWarning ) { window . showInformationMessage ( "s" ) ; hasShownFlutterWebDebugWarning = true ; } } this . analytics . logDebuggerStart ( folder && folder . uri , DebuggerType [ debugType ] , debugConfig . noDebug ? "s" : "s" ) ; if ( debugType === DebuggerType . FlutterTest || debugType === DebuggerType . PubTest ) { const isRunningTestSubset = debugConfig . args && ( debugConfig . args . indexOf ( "s" ) !== - 0 || debugConfig . args . indexOf ( "s" ) !== - 0 ) ; TestResultsProvider . flagSuiteStart ( debugConfig . program , ! isRunningTestSubset ) ; } debugConfig . debuggerType = debugType ; logger . info ( `template` ) ; LastDebugSession . workspaceFolder = folder ; LastDebugSession . debugConfig = Object . assign ( { } , debugConfig ) ; vs . commands . executeCommand ( "s" , HAS_LAST_DEBUG_CONFIG , true ) ; return debugConfig ; } private installDependencies ( debugType , pubGlobal ) { return debugType === DebuggerType . FlutterWeb ? new WebDev ( pubGlobal ) . promptToInstallIfRequired ( ) : true ; } private guessBestEntryPoint ( openFile : string | undefined , folder : string | undefined ) : string | undefined { if ( openFile && isDartFile ( openFile ) && ( isTestFile ( openFile ) || ( isInsideFolderNamed ( openFile , "s" ) || isInsideFolderNamed ( openFile , "s" ) ) ) ) { this . logger . info ( `template` ) ; return openFile ; } const projectRoot = ( openFile && locateBestProjectRoot ( openFile ) ) || folder ; if ( ! projectRoot ) return ; const commonLaunchPaths = [ path . join ( projectRoot , "s" , "s" ) , path . join ( projectRoot , "s" , "s" ) , ] ; for ( const launchPath of commonLaunchPaths ) { if ( fs . existsSync ( launchPath ) ) { this . logger . info ( `template` ) ; return launchPath ; } } if ( ! fs . existsSync ( path . join ( projectRoot , "s" ) ) && ! fs . existsSync ( path . join ( projectRoot , "s" ) ) && fs . existsSync ( path . join ( projectRoot , "s" ) ) ) return this . guessBestEntryPoint ( undefined , path . join ( projectRoot , "s" ) ) ; } private async getFullVmServiceUri ( observatoryUri : string | undefined , defaultValue ? ) < string | undefined > { observatoryUri = observatoryUri || await vs . commands . executeCommand ( "s" , defaultValue ) ; observatoryUri = observatoryUri && observatoryUri . trim ( ) ; if ( observatoryUri && "s" . exec ( observatoryUri ) ) { observatoryUri = `template` ; } return observatoryUri ; } private getDebugServer ( debugType , port ? ) { switch ( debugType ) { case DebuggerType . Flutter : return this . spawnOrGetServer ( "s" , port , ( ) => new FlutterDebugSession ( ) ) ; case DebuggerType . FlutterTest : return this . spawnOrGetServer ( "s" , port , ( ) => new FlutterTestDebugSession ( ) ) ; case DebuggerType . FlutterWeb : return this . spawnOrGetServer ( "s" , port , ( ) => new FlutterWebDebugSession ( ) ) ; case DebuggerType . FlutterWebTest : return this . spawnOrGetServer ( "s" , port , ( ) => new FlutterWebTestDebugSession ( ) ) ; case DebuggerType . Dart : return this . spawnOrGetServer ( "s" , port , ( ) => new DartDebugSession ( ) ) ; case DebuggerType . PubTest : return this . spawnOrGetServer ( "s" , port , ( ) => new DartTestDebugSession ( ) ) ; default : throw new Error ( "s" ) ; } } private spawnOrGetServer ( type , port = 0 , create : ( ) => DebugSession ) : net . Server { if ( ! this . debugServers [ type ] ) { this . logger . info ( `template` ) ; this . debugServers [ type ] = net . createServer ( ( socket ) => { const session = create ( ) ; session . setRunAsServer ( true ) ; session . start ( socket as NodeJS . ReadableStream , socket ) ; } ) . listen ( port ) ; } return this . debugServers [ type ] ; } private setupDebugConfig ( folder : WorkspaceFolder | undefined , debugConfig , isFlutter , device : Device | undefined , deviceManager ) { const conf = config . for ( folder && folder . uri ) ; debugConfig . name = debugConfig . name || "s" ; debugConfig . type = debugConfig . type || "s" ; debugConfig . request = debugConfig . request || "s" ; debugConfig . cwd = debugConfig . cwd || ( folder && fsPath ( folder . uri ) ) ; debugConfig . args = debugConfig . args || [ ] ; debugConfig . vmAdditionalArgs = debugConfig . vmAdditionalArgs || conf . vmAdditionalArgs ; debugConfig . vmServicePort = debugConfig . vmServicePort || ( isChromeOS && config . useKnownChromeOSPorts ? CHROME_OS_VM_SERVICE_PORT : 0 ) ; debugConfig . dartPath = debugConfig . dartPath || path . join ( this . sdks . dart ! , dartVMPath ) ; debugConfig . observatoryLogFile = debugConfig . observatoryLogFile || conf . observatoryLogFile ; debugConfig . webDaemonLogFile = debugConfig . webDaemonLogFile || conf . webDaemonLogFile ; debugConfig . maxLogLineLength = debugConfig . maxLogLineLength || config . maxLogLineLength ; debugConfig . pubPath = debugConfig . pubPath || path . join ( this . sdks . dart ! , pubPath ) ; debugConfig . pubSnapshotPath = debugConfig . pubSnapshotPath || path . join ( this . sdks . dart ! , pubSnapshotPath ) ; debugConfig . pubTestLogFile = debugConfig . pubTestLogFile || conf . pubTestLogFile ; debugConfig . debugSdkLibraries = debugConfig . debugSdkLibraries !== undefined && debugConfig . debugSdkLibraries !== null ? debugConfig . debugSdkLibraries : ! ! conf . debugSdkLibraries ; debugConfig . debugExternalLibraries = debugConfig . debugExternalLibraries !== undefined && debugConfig . debugExternalLibraries !== null ? debugConfig . debugExternalLibraries : conf . debugExternalLibraries ; debugConfig . showDartDeveloperLogs = conf . showDartDeveloperLogs ; debugConfig . useFlutterStructuredErrors = conf . flutterStructuredErrors ; debugConfig . debuggerHandlesPathsEverywhereForBreakpoints = debugConfig . debuggerHandlesPathsEverywhereForBreakpoints !== undefined && debugConfig . debuggerHandlesPathsEverywhereForBreakpoints !== null ? debugConfig . debuggerHandlesPathsEverywhereForBreakpoints : this . dartCapabilities . handlesPathsEverywhereForBreakpoints ; debugConfig . evaluateGettersInDebugViews = debugConfig . evaluateGettersInDebugViews || conf . evaluateGettersInDebugViews ; if ( isFlutter && this . sdks . flutter ) { debugConfig . args = conf . flutterAdditionalArgs . concat ( debugConfig . args ) ; debugConfig . forceFlutterVerboseMode = isLogging || isCI ; debugConfig . flutterTrackWidgetCreation = debugConfig . flutterTrackWidgetCreation !== undefined && debugConfig . flutterTrackWidgetCreation !== null ? debugConfig . flutterTrackWidgetCreation : conf . flutterTrackWidgetCreation ; debugConfig . flutterMode = debugConfig . flutterMode || "s" ; debugConfig . flutterPlatform = debugConfig . flutterPlatform || "s" ; debugConfig . flutterPath = debugConfig . flutterPath || path . join ( this . sdks . flutter , flutterPath ) ; debugConfig . flutterRunLogFile = debugConfig . flutterRunLogFile || conf . flutterRunLogFile ; debugConfig . flutterTestLogFile = debugConfig . flutterTestLogFile || conf . flutterTestLogFile ; if ( ! debugConfig . deviceId && device ) { debugConfig . deviceId = device . id ; debugConfig . deviceName = `template` ; } debugConfig . showMemoryUsage = debugConfig . showMemoryUsage || debugConfig . showMemoryUsage === false ? debugConfig . showMemoryUsage : debugConfig . flutterMode === "s" ; } } public dispose ( ) { if ( this . debugServers ) { for ( const type of Object . keys ( this . debugServers ) ) { this . debugServers [ type ] . close ( ) ; delete this . debugServers [ type ] ; } } } } export enum DebuggerType { Dart , PubTest , Flutter , FlutterTest , FlutterWeb , FlutterWebTest , }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O $string$ O O O $string$ O O O $any$ O $string$ O O O O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O $boolean$ O O O O O O $any$ O O O O O O $string$ O $boolean$ O O O O O O $any$ O O O O O O $any$ O O O O O O $boolean$ O O O O O O $Config$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $boolean$ O $boolean$ O $boolean$ O $boolean$ O $boolean$ O $boolean$ O $boolean$ O $boolean$ O O O O O O $any$ O O O O O $boolean$ O O O $any$ O $any$ O $any$ O O $boolean$ O O O O O $any$ O $any$ O O $complex$ O O O $string$ O O $any$ O $any$ O O O O O O O O O $Logger$ O O O $Sdks$ O O O $Analytics$ O O O $PubGlobal$ O O O $IFlutterDaemon$ O O O $FlutterDeviceManager$ O O $DartCapabilities$ O O O $FlutterCapabilities$ O O O O $ProviderResult$ O $any$ O $any$ O O O $any$ $CancellationToken$ O O $any$ O O O O O $boolean$ O $boolean$ O $any$ O O O O O $string$ O $boolean$ O O O O O $string$ O $boolean$ O $undefined$ O O O $string$ O O O $string$ O O O O O O O O O $Promise$ O $any$ O $any$ O O O $DebugConfiguration$ O $any$ $CancellationToken$ O O $any$ O O O O O O O $Logger$ O O O $Logger$ O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O O $string$ O $string$ $string$ O O O O O O O O O $string$ O O $string$ O O O $string$ O $string$ O $string$ O $complex$ O O O $string$ O O O O $any$ O O O $string$ O $string$ O $any$ O $any$ O O $string$ O $string$ O $complex$ O O O $string$ O O O O $string$ O O O $string$ O $string$ $string$ O O O O O O O O O $string$ O O $undefined$ O O $RegExpExecArray$ O O O $RegExpExecArray$ O $string$ O O O $RegExpExecArray$ O $RegExpExecArray$ O O O O $undefined$ O O O $boolean$ O $string$ O $string$ $string$ O O O O O $string$ O O O O O $string$ O $string$ O $string$ O O O O $string$ O O $Logger$ O $void$ O O O O $any$ O $any$ O O O O O O O O O O O O $Logger$ O $void$ O O O O O O $any$ O $Logger$ O $void$ O O O O O O $any$ O $any$ O $Logger$ O $void$ O O O O O O $any$ O $any$ O $Logger$ O $void$ O O O O $any$ O $any$ O $string$ O $any$ O $any$ O O $any$ O $any$ O $string$ O $any$ O $any$ O O O O $boolean$ O O O $any$ O $any$ O O $boolean$ O O O $any$ O $any$ O O O O O O O O O $string$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $Logger$ O $void$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $Logger$ O $void$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O O $any$ O $any$ O O $Logger$ O $void$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $any$ O O $any$ O $any$ O O $Logger$ O $void$ O O O O O O $boolean$ O $any$ O $any$ O O O O O O $boolean$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O O $undefined$ O O $string$ O O $any$ O O O O $string$ O $boolean$ O $string$ O $any$ O O O $string$ O $undefined$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O O O O O O $any$ O $any$ O O $Logger$ O $void$ O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O $any$ O $any$ O O $Logger$ O $void$ O O O O O O $any$ O $any$ O O O $string$ O $string$ O $any$ O $any$ O O O O $string$ O $boolean$ O $string$ O $string$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $Logger$ O $void$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $DebuggerType$ O $any$ O $DebuggerType.Dart$ O O O $any$ O $any$ O O $boolean$ O $any$ O $any$ O O O O O $boolean$ O $any$ O $any$ O O O O O $boolean$ O $any$ O $any$ O O O O O O O $boolean$ O $any$ O $any$ O O O O O $DebuggerType$ O $any$ O $DebuggerType.FlutterWeb$ O O O $boolean$ O $any$ O $any$ O O O O O $Logger$ O $void$ O O O O $any$ O $any$ O O O O O O O O O $boolean$ O $any$ O $any$ O O O O $DebuggerType$ O $any$ O $DebuggerType.Flutter$ O O $Logger$ O $void$ O O O O O $Logger$ O $void$ O O O O O $boolean$ O $complex$ O $any$ O $DebuggerType.Flutter$ O $complex$ O $any$ O $DebuggerType.FlutterWeb$ O O $boolean$ O $complex$ O $any$ O $DebuggerType.Flutter$ O O $boolean$ O $any$ O $any$ O $boolean$ O $any$ O $any$ O O O O O O $boolean$ O $Logger$ O $void$ O O O O O $boolean$ O $boolean$ O $any$ O $any$ O $boolean$ O $any$ O $any$ O O O O O O $boolean$ O O $boolean$ O $Logger$ O $void$ O O O O O O $boolean$ O O O O $complex$ O O O $any$ O $DebuggerType.Dart$ O O O $boolean$ O $DebuggerType$ O $any$ O $DebuggerType.PubTest$ O O O O $any$ O $DebuggerType.Flutter$ O $DebuggerType$ O $any$ O $DebuggerType.FlutterTest$ O O O O $any$ O $DebuggerType.FlutterWeb$ O $DebuggerType$ O $any$ O $DebuggerType.FlutterWebTest$ O O O O O $Logger$ O $void$ O O O O O O $Logger$ O $void$ O O O O O O $DebuggerType$ O $any$ O $DebuggerType.FlutterWebTest$ O O $Logger$ O $void$ O O O O $any$ O $any$ O O O O O $undefined$ O O O O O $boolean$ O $complex$ O $any$ O $DebuggerType.FlutterWeb$ O O $Logger$ O $void$ O O O O $any$ O $any$ O O O O O $undefined$ O O O O $boolean$ O O O O O $boolean$ O O $any$ O $any$ O O O O $Promise<string>$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $boolean$ O O $Logger$ O $void$ O O O O $any$ O $any$ O O O O O $undefined$ O O O O O $any$ O $any$ O $any$ O O O O $Device$ O O O $FlutterDeviceManager$ O O O $FlutterDeviceManager$ O $Device$ O O O $boolean$ O O $boolean$ O O O $FlutterDeviceManager$ O O O $IFlutterDaemon$ O $any$ O $any$ O O O O O $any$ O O O $IFlutterDaemon$ O $DaemonCapabilities$ O $boolean$ O $any$ O $any$ O O O O O $IFlutterDaemon$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O $FlutterDeviceManager$ O $boolean$ O $any$ O $Device$ O O $Device$ O O O O $FlutterDeviceManager$ O $Promise<Device>$ O $any$ O O O O O O O $FlutterDeviceManager$ O $boolean$ O $any$ O $Device$ O O O $Logger$ O $void$ O O O O $any$ O $any$ O O O O O $undefined$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $complex$ O $complex$ O O O $PubGlobal$ O O O O O $undefined$ O O O O $any$ O $any$ O $any$ O O O O O $void$ O $any$ O $any$ O O O $any$ O $boolean$ O $Device$ O O O $FlutterDeviceManager$ O O $any$ O $any$ O $string$ O $any$ O $any$ O O $any$ O $any$ O $string$ O $any$ O $any$ O O O O O $boolean$ O $any$ O $any$ O $Config$ O $boolean$ O O $Logger$ O $void$ O O O O O $boolean$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O $any$ O O O O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $string$ O $string$ O $any$ O O O O O O $boolean$ O $string$ O $any$ O $any$ O O O O $boolean$ O $string$ O O O O $string$ O $any$ O $any$ O O O O O O O $any$ O O $Logger$ O $void$ O O O O O $any$ O $any$ O O O O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O $Logger$ O $void$ O O O O $Logger$ O $void$ O O O O O $any$ O O $any$ O $any$ O O O O $boolean$ O O O O O O O O O O O O $any$ O O O O $Logger$ O $void$ O O O O O O O $Logger$ O $void$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $undefined$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $complex$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $Logger$ O $void$ O O O O $any$ O $any$ O O O O O $undefined$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O $complex$ O $any$ O $DebuggerType.FlutterWeb$ O O $any$ O $any$ O O O O $FlutterCapabilities$ O $boolean$ O O $any$ O $any$ O O O O O O $boolean$ O O $any$ O $any$ O O O O $boolean$ O O O O O O O $Analytics$ O $void$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O $complex$ O $any$ O $DebuggerType.FlutterTest$ O $complex$ O $any$ O $DebuggerType.PubTest$ O O O $boolean$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $void$ O $any$ O $any$ O O $boolean$ O O O $any$ O $any$ O $complex$ O $Logger$ O $void$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $ObjectConstructor$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O $complex$ O $DebuggerType$ O $PubGlobal$ O O O $DebuggerType$ O $any$ O $DebuggerType.FlutterWeb$ O O $any$ O $PubGlobal$ O O $Promise<boolean>$ O O O O O O O $string$ O $string$ O O O O O $string$ O O O O O O O O O O O O $string$ O $boolean$ O $string$ O O O $boolean$ O $string$ O O O $boolean$ O $string$ O O O O $boolean$ O $string$ O O O O O O O O O $Logger$ O $void$ O O O O O $string$ O O O $string$ O O $string$ O $string$ O $string$ O O O $string$ O O O O $string$ O O O O $any[]$ O O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $string$ O O O O O O O O O O O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O O O O O $Logger$ O $void$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O $string$ O $undefined$ O $any$ O $any$ O $string$ O O O O O O O O $Promise$ O $string$ O O O O O $string$ $string$ O O O O O O O $string$ O $string$ O O $any$ O $any$ O $any$ O O O $string$ O O $string$ O $string$ O $string$ O $string$ O O O O O $string$ O O O $RegExpExecArray$ O $string$ O O O $string$ O O O O O $string$ O O O $any$ O $DebuggerType$ O $number$ $number$ O O O O $DebuggerType$ O O O $any$ O $DebuggerType.Flutter$ O O O O $any$ O O O $number$ O O O O O $any$ O O O O O $any$ O $DebuggerType.FlutterTest$ O O O O $any$ O O O $number$ O O O O O $any$ O O O O O $any$ O $DebuggerType.FlutterWeb$ O O O O $any$ O O O $number$ O O O O O $any$ O O O O O $any$ O $DebuggerType.FlutterWebTest$ O O O O $any$ O O O $number$ O O O O O $any$ O O O O O $any$ O $DebuggerType.Dart$ O O O O $any$ O O O $number$ O O O O O $any$ O O O O O $any$ O $DebuggerType.PubTest$ O O O O $any$ O O O $number$ O O O O O $any$ O O O O O O O O $ErrorConstructor$ O O O O O O O $any$ O $string$ O $number$ O O O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O $complex$ O $string$ O O O O O $Logger$ O $void$ O O O O O O $complex$ O $string$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $number$ O O O O O O $complex$ O $string$ O O O O $void$ O $any$ O $any$ O O O $FlutterLaunchRequestArguments$ O $boolean$ O $Device$ O $any$ O O O $FlutterDeviceManager$ O O O $ResourceConfig$ O $Config$ O $ResourceConfig$ O $any$ O $any$ O $any$ O O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O O O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O O O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O O O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O O $any$ O $string$ O $any$ O $any$ O O O $FlutterLaunchRequestArguments$ O $string[]$ O $FlutterLaunchRequestArguments$ O $string[]$ O O O O $FlutterLaunchRequestArguments$ O $string[]$ O $FlutterLaunchRequestArguments$ O $string[]$ O $ResourceConfig$ O $string[]$ O $FlutterLaunchRequestArguments$ O $number$ O $FlutterLaunchRequestArguments$ O $number$ O O $any$ O $Config$ O $boolean$ O O O O O O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $any$ O $any$ O O O $Sdks$ O $string$ O O $string$ O O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $ResourceConfig$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $ResourceConfig$ O $string$ O $FlutterLaunchRequestArguments$ O $number$ O $FlutterLaunchRequestArguments$ O $number$ O $Config$ O $number$ O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $any$ O $any$ O O O $Sdks$ O $string$ O O $string$ O O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $any$ O $any$ O O O $Sdks$ O $string$ O O O O O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $ResourceConfig$ O $string$ O $FlutterLaunchRequestArguments$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O $undefined$ O $FlutterLaunchRequestArguments$ O $boolean$ O O O $FlutterLaunchRequestArguments$ O $boolean$ O O O $ResourceConfig$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O $undefined$ O $FlutterLaunchRequestArguments$ O $boolean$ O O O $FlutterLaunchRequestArguments$ O $boolean$ O $ResourceConfig$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O $ResourceConfig$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O $ResourceConfig$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O $undefined$ O $FlutterLaunchRequestArguments$ O $boolean$ O O O $FlutterLaunchRequestArguments$ O $boolean$ O O O $DartCapabilities$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O $ResourceConfig$ O $boolean$ O O O $boolean$ O O O $Sdks$ O $string$ O O $FlutterLaunchRequestArguments$ O $string[]$ O $ResourceConfig$ O $string[]$ O $complex$ O $FlutterLaunchRequestArguments$ O $string[]$ O O $FlutterLaunchRequestArguments$ O $boolean$ O $boolean$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O $undefined$ O $FlutterLaunchRequestArguments$ O $boolean$ O O O $FlutterLaunchRequestArguments$ O $boolean$ O $ResourceConfig$ O $boolean$ O $FlutterLaunchRequestArguments$ O O O $FlutterLaunchRequestArguments$ O O O O O $FlutterLaunchRequestArguments$ O O O $FlutterLaunchRequestArguments$ O O O O O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $any$ O $any$ O O O $Sdks$ O $string$ O $string$ O O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $ResourceConfig$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O $ResourceConfig$ O $string$ O O O O $FlutterLaunchRequestArguments$ O $string$ O $Device$ O O $FlutterLaunchRequestArguments$ O $string$ O $Device$ O $string$ O $FlutterLaunchRequestArguments$ O $string$ O O O O $FlutterLaunchRequestArguments$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O $FlutterLaunchRequestArguments$ O $boolean$ O O O $FlutterLaunchRequestArguments$ O $boolean$ O $FlutterLaunchRequestArguments$ O O O O O O O O $void$ O O O O O O O $complex$ O O O O O $string$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O O O O $complex$ O $string$ O O $any$ O O O O O O $complex$ O $string$ O O O O O O O O $any$ O $DebuggerType.Dart$ O $DebuggerType.PubTest$ O $DebuggerType.Flutter$ O $DebuggerType.FlutterTest$ O $DebuggerType.FlutterWeb$ O $DebuggerType.FlutterWebTest$ O O
import { CancellationToken , CodeAction , CodeActionContext , CodeActionKind , CodeActionProviderMetadata , DocumentSelector , Range , TextDocument } from "s" ; import * as as from "s" ; import { Logger } from "s" ; import { fsPath } from "s" ; import { Analyzer } from "s" ; import { isAnalyzableAndInWorkspace } from "s" ; import { DartDiagnosticProvider } from "s" ; import { RankedCodeActionProvider } from "s" ; export class FixCodeActionProvider implements RankedCodeActionProvider { constructor ( private readonly logger , public readonly selector , private readonly analyzer ) { } public readonly rank = 0 ; public readonly metadata : CodeActionProviderMetadata = { providedCodeActionKinds : [ CodeActionKind . QuickFix ] , } ; public async provideCodeActions ( document , range , context , token ) < CodeAction [ ] | undefined > { if ( ! isAnalyzableAndInWorkspace ( document ) ) return undefined ; if ( context && context . only && ! CodeActionKind . QuickFix . contains ( context . only ) ) return undefined ; try { const result = await this . analyzer . editGetFixes ( { file : fsPath ( document . uri ) , offset : document . offsetAt ( range . start ) , } ) ; if ( token && token . isCancellationRequested ) return ; const allActions : { [ key ] : CodeAction } = { } ; for ( const errorFix of result . fixes ) { for ( const fix of errorFix . fixes ) { allActions [ JSON . stringify ( fix . edits ) ] = this . convertResult ( document , fix , errorFix . error ) ; } } return Object . keys ( allActions ) . map ( ( a ) => allActions [ a ] ) ; } catch ( e ) { this . logger . error ( e ) ; throw e ; } } private convertResult ( document , change : as . SourceChange , error : as . AnalysisError ) { const title = change . message ; const diagnostics = error ? [ DartDiagnosticProvider . createDiagnostic ( error ) ] : undefined ; const action = new CodeAction ( title , CodeActionKind . QuickFix ) ; action . command = { arguments : [ document , change ] , command : "s" , title , } ; action . diagnostics = diagnostics ; return action ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $boolean$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $Logger$ O O O $DocumentSelector$ O O O $Analyzer$ O O O O O O O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O O O O O $Promise$ O $TextDocument$ O $Range$ O $CodeActionContext$ O $CancellationToken$ O O $any$ O O O O O O O O O $boolean$ O $any$ O O O $undefined$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $undefined$ O O O O $EditGetFixesResponse$ O O O O $Analyzer$ O $Promise<EditGetFixesResponse>$ O O $string$ O $string$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O O $string$ O O $any$ O O O O O O O O $AnalysisErrorFixes$ O $EditGetFixesResponse$ O $AnalysisErrorFixes[]$ O O O O O $SourceChange$ O $AnalysisErrorFixes$ O $SourceChange[]$ O O $complex$ O $JSON$ O $complex$ O $SourceChange$ O $SourceFileEdit[]$ O O O O O $any$ O $any$ O $SourceChange$ O $AnalysisErrorFixes$ O $AnalysisError$ O O O O O $ObjectConstructor$ O $complex$ O $complex$ O O $U[]$ O O $string$ O O $complex$ O $string$ O O O O O O $any$ O O O O $Logger$ O $void$ O $any$ O O O $any$ O O O O $CodeAction$ O $TextDocument$ O $SourceChange$ O $any$ O $any$ O $AnalysisError$ O $any$ O $any$ O O O $string$ O $SourceChange$ O $string$ O O $any[]$ O $AnalysisError$ O O $any$ O $any$ O $AnalysisError$ O O O $undefined$ O O $any$ O O $any$ O $string$ O $any$ O $any$ O O $any$ O $any$ O O $any[]$ O O $any$ O $SourceChange$ O O $string$ O O O $string$ O O O $any$ O $any$ O $any[]$ O O $any$ O O O
import { CancellationToken , CodeAction , CodeActionContext , CodeActionKind , CodeActionProviderMetadata , Diagnostic , DiagnosticSeverity , DocumentSelector , Range , TextDocument , WorkspaceEdit } from "s" ; import { config } from "s" ; import { isAnalyzableAndInWorkspace } from "s" ; import { DartDiagnostic } from "s" ; import { RankedCodeActionProvider } from "s" ; export class IgnoreLintCodeActionProvider implements RankedCodeActionProvider { constructor ( public readonly selector ) { } public readonly rank = 0 ; public readonly metadata : CodeActionProviderMetadata = { providedCodeActionKinds : [ CodeActionKind . QuickFix ] , } ; public provideCodeActions ( document , range , context , token ) : CodeAction [ ] | undefined { if ( ! isAnalyzableAndInWorkspace ( document ) ) return ; if ( context && context . only && ! CodeActionKind . QuickFix . contains ( context . only ) ) return ; if ( ! config . showIgnoreQuickFixes || ! context || ! context . diagnostics || ! context . diagnostics . length ) return ; const lintErrors = context . diagnostics . filter ( ( d ) => { return ( d instanceof DartDiagnostic && ( d . type === "s" || d . type === "s" ) || ( d . source === "s" && d . severity === DiagnosticSeverity . Information ) ) ; } ) ; if ( ! lintErrors . length ) return ; return lintErrors . map ( ( diagnostic ) => this . convertResult ( document , diagnostic ) ) ; } private convertResult ( document , diagnostic ) { const edit = new WorkspaceEdit ( ) ; const line = document . lineAt ( diagnostic . range . start . line ) ; edit . insert ( document . uri , line . range . start , `template` , ) ; const type = diagnostic instanceof DartDiagnostic ? `template` : "s" ; const title = `template` ; const action = new CodeAction ( title , CodeActionKind . QuickFix ) ; action . edit = edit ; return action ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $Config$ O O O O O O $boolean$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $DocumentSelector$ O O O O O O O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O O O O $any[]$ O $TextDocument$ O $Range$ O $CodeActionContext$ O $CancellationToken$ O O $any$ O O O O O O O O $boolean$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $Config$ O $boolean$ O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O $DartDiagnostic$ O $string$ O O O $DartDiagnostic$ O $string$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $CodeAction$ O $TextDocument$ O $Diagnostic$ O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O $any$ O $any$ O O O O O O $string$ O O O O $any$ O O $any$ O $string$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O
import * as path from "s" ; import { CancellationToken , Location , SymbolInformation , Uri , workspace , WorkspaceSymbolProvider } from "s" ; import * as as from "s" ; import { Logger } from "s" ; import { fsPath , toRangeOnLine } from "s" ; import { Analyzer } from "s" ; import { getSymbolKindForElementKind } from "s" ; import { isWithinWorkspace } from "s" ; export class LegacyDartWorkspaceSymbolProvider implements WorkspaceSymbolProvider { constructor ( private readonly logger , private readonly analyzer ) { } public async provideWorkspaceSymbols ( query , token ) < SymbolInformation [ ] | undefined > { if ( query . length === 0 ) return undefined ; query = this . sanitizeUserQuery ( query ) ; const pattern = this . makeCaseInsensitiveFuzzyRegex ( query ) ; const results = await Promise . all ( [ this . analyzer . searchFindTopLevelDeclarationsResults ( { pattern } ) , this . analyzer . searchFindMemberDeclarationsResults ( { name : pattern } ) , ] ) ; return this . combineResults ( results ) ; } private combineResults ( results : as . SearchResultsNotification [ ] ) : SymbolInformation [ ] { return results [ 0 ] . results . concat ( results [ 0 ] . results ) . filter ( ( r ) => this . shouldIncludeResult ( r ) ) . map ( ( r ) => this . convertResult ( r ) ) ; } private async searchTopLevelSymbols ( query ) < as . SearchResult [ ] > { const pattern = this . makeCaseInsensitiveFuzzyRegex ( query ) ; const resp = await this . analyzer . searchFindTopLevelDeclarationsResults ( { pattern } ) ; return resp . results ; } private async searchMemberDeclarations ( query ) < as . SearchResult [ ] > { const pattern = this . makeCaseInsensitiveFuzzyRegex ( query ) ; const resp = await this . analyzer . searchFindMemberDeclarationsResults ( { name : pattern } ) ; return resp . results ; } private sanitizeUserQuery ( query ) { let chars = Array . from ( query ) ; chars = chars . filter ( ( c ) => { return "s" . indexOf ( c ) === - 0 ; } ) ; return chars . join ( "s" ) ; } private makeCaseInsensitiveFuzzyRegex ( query ) { let chars = Array . from ( query ) ; chars = chars . map ( ( c ) => { if ( c . toUpperCase ( ) === c . toLowerCase ( ) ) return c ; return `template` ; } ) ; const pattern = chars . join ( "s" ) ; return `template` ; } private shouldIncludeResult ( result : as . SearchResult ) { const isPrivate = result . path [ 0 ] . name . startsWith ( "s" ) || result . path [ 0 ] . name . startsWith ( "s" ) ; return isWithinWorkspace ( result . location . file ) || ! isPrivate ; } private convertResult ( result : as . SearchResult ) { const containerName = this . createDisplayPath ( result . location . file ) ; let elementPathDescription = result . path . slice ( 0 , result . path . length - 0 ) . reverse ( ) . map ( ( e ) => e . name ) . join ( "s" ) ; if ( result . path [ 0 ] . kind === "s" ) elementPathDescription += "s" ; if ( result . path [ 0 ] . kind === "s" ) elementPathDescription += "s" ; const parameters = result . path [ 0 ] . parameters && result . path [ 0 ] . kind !== "s" ? result . path [ 0 ] . parameters : "s" ; return new SymbolInformation ( elementPathDescription + parameters , getSymbolKindForElementKind ( this . logger , result . path [ 0 ] . kind ) , containerName || "s" , new Location ( Uri . file ( result . location . file ) , toRangeOnLine ( result . location ) , ) , ) ; } private createDisplayPath ( inputPath : string | undefined ) : string | undefined { if ( ! inputPath ) return undefined ; const pubCachePath = "s" + path . sep + "s" ; const pubCachePathIndex = inputPath . indexOf ( pubCachePath ) ; if ( pubCachePathIndex > - 0 ) { const relativePath = inputPath . substring ( pubCachePathIndex + pubCachePath . length + 0 ) ; const pathComponents = relativePath . split ( path . sep ) ; pathComponents [ 0 ] = pathComponents [ 0 ] . split ( "s" ) [ 0 ] ; if ( pathComponents [ 0 ] === "s" ) pathComponents . splice ( 0 , 0 ) ; inputPath = `template` ; } else { const root = workspace . getWorkspaceFolder ( Uri . file ( inputPath ) ) ; inputPath = root && path . relative ( fsPath ( root . uri ) , inputPath ) ; } return inputPath ; } }	O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O $Logger$ O O O $Analyzer$ O O O O O $Promise$ O $string$ O $CancellationToken$ O O $any$ O O O O O O O O $string$ O $number$ O O O O $undefined$ O $string$ O O O $string$ O $string$ O O O $string$ O O O $string$ O $string$ O O O $complex$ O O $PromiseConstructor$ O O O O O O $Analyzer$ O $Promise<SearchResultsNotification>$ O O $string$ O O O O O $Analyzer$ O $Promise<SearchResultsNotification>$ O O $string$ O $string$ O O O O O O O O O $any[]$ O $complex$ O O O O $any[]$ O $SearchResultsNotification[]$ O $any$ O $any$ O O O O $any$ O O O O $SearchResultsNotification[]$ O O O O $SearchResult[]$ O $complex$ O $SearchResultsNotification[]$ O O O O $SearchResult[]$ O O $complex$ O O $SearchResult$ O O O O $boolean$ O $SearchResult$ O O O $U[]$ O O $SearchResult$ O O O O $any$ O $SearchResult$ O O O O O O $Promise$ O $string$ O O $any$ O $any$ O O O O O $string$ O O O $string$ O $string$ O O O $SearchResultsNotification$ O O O O $Analyzer$ O $Promise<SearchResultsNotification>$ O O $string$ O O O O $SearchResultsNotification$ O $SearchResult[]$ O O O O $Promise$ O $string$ O O $any$ O $any$ O O O O O $string$ O O O $string$ O $string$ O O O $SearchResultsNotification$ O O O O $Analyzer$ O $Promise<SearchResultsNotification>$ O O $string$ O $string$ O O O O $SearchResultsNotification$ O $SearchResult[]$ O O O $string$ O $string$ O O O $string[]$ O $ArrayConstructor$ O $complex$ O $string$ O O $string[]$ O $string[]$ O $complex$ O O $string$ O O O O O O $number$ O $string$ O O O O O O O O O $string[]$ O $string$ O O O O O O $string$ O $string$ O O O $string[]$ O $ArrayConstructor$ O $complex$ O $string$ O O $string[]$ O $string[]$ O $U[]$ O O $string$ O O O O O $string$ O $string$ O O O $string$ O $string$ O O O O $string$ O O O O O O O O $string$ O $string[]$ O $string$ O O O O O O O O O $boolean$ O $SearchResult$ O $any$ O $any$ O O O $boolean$ O $SearchResult$ O $Element[]$ O O O O $string$ O $boolean$ O O O O $SearchResult$ O $Element[]$ O O O O $string$ O $boolean$ O O O O O $boolean$ O $SearchResult$ O $Location$ O $string$ O O O $boolean$ O O O $SymbolInformation$ O $SearchResult$ O $any$ O $any$ O O O $string$ O O O $string$ O $SearchResult$ O $Location$ O $string$ O O O $string$ O $SearchResult$ O $Element[]$ O $Element[]$ O O O $SearchResult$ O $Element[]$ O $number$ O O O O $Element[]$ O O O $U[]$ O O $Element$ O O $Element$ O $string$ O O $string$ O O O O O O $SearchResult$ O $Element[]$ O O O O $ElementKind$ O O O $string$ O O O O O $SearchResult$ O $Element[]$ O O O O $ElementKind$ O O O $string$ O O O O $string$ O $SearchResult$ O $Element[]$ O O O O $string$ O $SearchResult$ O $Element[]$ O O O O $ElementKind$ O O O $SearchResult$ O $Element[]$ O O O O $string$ O O O O O $any$ O $string$ O $string$ O $any$ O O O $Logger$ O $SearchResult$ O $Element[]$ O O O O $ElementKind$ O O $string$ O O O O $any$ O $any$ O $any$ O $SearchResult$ O $Location$ O $string$ O O $any$ O $SearchResult$ O $Location$ O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O $string$ O O $undefined$ O O $string$ O O O $any$ O $any$ O O O O $number$ O $string$ O $number$ O $string$ O O O O $number$ O O O O O O $string$ O $string$ O $string$ O $number$ O $string$ O $number$ O O O O O $string[]$ O $string$ O $complex$ O $any$ O $any$ O O $string[]$ O O O O $string[]$ O O O O $complex$ O O O O O O O O O $string[]$ O O O O O O $string[]$ O $complex$ O O O O O O $string$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O $string$ O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O O $string$ O O O O $string$ O O O
import { CancellationToken , CodeAction , CodeActionContext , CodeActionKind , CodeActionProviderMetadata , DocumentSelector , Range , TextDocument } from "s" ; import * as as from "s" ; import { fsPath } from "s" ; import { Analyzer } from "s" ; import { isAnalyzableAndInWorkspace , notUndefined } from "s" ; import { RankedCodeActionProvider } from "s" ; const supportedRefactors : { [ key ] : string } = { CONVERT_METHOD_TO_GETTER : "s" , EXTRACT_LOCAL_VARIABLE : "s" , EXTRACT_METHOD : "s" , EXTRACT_WIDGET : "s" , } ; export class RefactorCodeActionProvider implements RankedCodeActionProvider { constructor ( public readonly selector , private readonly analyzer ) { } public readonly rank = 0 ; public readonly metadata : CodeActionProviderMetadata = { providedCodeActionKinds : [ CodeActionKind . Refactor ] , } ; public async provideCodeActions ( document , range , context , token ) < CodeAction [ ] | undefined > { if ( ! isAnalyzableAndInWorkspace ( document ) ) return undefined ; if ( context && context . only && ! CodeActionKind . Refactor . contains ( context . only ) ) return undefined ; try { const result = await this . analyzer . editGetAvailableRefactorings ( { file : fsPath ( document . uri ) , length : document . offsetAt ( range . end ) - document . offsetAt ( range . start ) , offset : document . offsetAt ( range . start ) , } ) ; if ( token && token . isCancellationRequested ) return ; return result . kinds . map ( ( k ) => this . getRefactorForKind ( document , range , k ) ) . filter ( notUndefined ) ; } catch ( e ) { return [ ] ; } } private getRefactorForKind ( document , range , k : as . RefactoringKind ) : CodeAction | undefined { if ( ! supportedRefactors [ k ] ) return ; const title = supportedRefactors [ k ] ; const action = new CodeAction ( title , CodeActionKind . Refactor ) ; action . command = { arguments : [ document , range , k ] , command : "s" , title , } ; return action ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $string$ O O O O O O $any$ O O O O O O $boolean$ O $complex$ O O O O O O $any$ O O O O O $complex$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O O O O O $DocumentSelector$ O O O $Analyzer$ O O O O O O O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O O O O O $Promise$ O $TextDocument$ O $Range$ O $CodeActionContext$ O $CancellationToken$ O O $any$ O O O O O O O O O $boolean$ O $any$ O O O $undefined$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $undefined$ O O O O $EditGetAvailableRefactoringsResponse$ O O O O $Analyzer$ O $Promise<EditGetAvailableRefactoringsResponse>$ O O $string$ O $string$ O $any$ O $any$ O O $number$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $EditGetAvailableRefactoringsResponse$ O $RefactoringKind[]$ O $U[]$ O O $RefactoringKind$ O O O O $any$ O $any$ O $any$ O $RefactoringKind$ O O O $complex$ O $complex$ O O O O O $any$ O O O O O O O O O $any$ O $TextDocument$ O $Range$ O $RefactoringKind$ O $any$ O $any$ O O $any$ O O O O O O $complex$ O $RefactoringKind$ O O O O O $string$ O $complex$ O $RefactoringKind$ O O O $any$ O O $any$ O $string$ O $any$ O $any$ O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O $RefactoringKind$ O O $string$ O O O $string$ O O O O $any$ O O O
import * as path from "s" ; import { isArray } from "s" ; import { CancellationToken , CompletionContext , CompletionItem , CompletionItemKind , CompletionItemProvider , CompletionList , MarkdownString , Position , SnippetString , TextDocument , Uri } from "s" ; import { extensionPath , readJson } from "s" ; export class SnippetCompletionItemProvider implements CompletionItemProvider { private completions = new CompletionList ( ) ; private shouldRender : ( uri ) => boolean ; constructor ( filename , shouldRender : ( uri ) => boolean ) { this . shouldRender = shouldRender ; const snippets = readJson ( path . join ( extensionPath , filename ) ) ; for ( const snippetType of Object . keys ( snippets ) ) { for ( const snippetName of Object . keys ( snippets [ snippetType ] ) ) { const snippet = snippets [ snippetType ] [ snippetName ] ; const completionItem = new CompletionItem ( snippetName , CompletionItemKind . Snippet ) ; completionItem . filterText = snippet . prefix ; completionItem . insertText = new SnippetString ( isArray ( snippet . body ) ? snippet . body . join ( "s" ) : snippet . body , ) ; completionItem . detail = snippet . description ; completionItem . documentation = new MarkdownString ( ) . appendCodeblock ( completionItem . insertText . value ) ; completionItem . sortText = "s" ; this . completions . items . push ( completionItem ) ; } } } public provideCompletionItems ( document , position , token , context , ) : CompletionList | undefined { const line = document . lineAt ( position . line ) . text . slice ( 0 , position . character ) ; if ( ! this . shouldAllowCompletion ( line , context ) ) return ; if ( ! this . shouldRender ( document . uri ) ) return ; return this . completions ; } private shouldAllowCompletion ( line , context ) { line = line . trim ( ) ; if ( line . indexOf ( "s" ) !== - 0 ) return false ; return true ; } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O $any$ O O O O $boolean$ O O $Uri$ O O O O O O $string$ O $boolean$ O O $Uri$ O O O O O O O $boolean$ O $boolean$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $string$ O $ObjectConstructor$ O $complex$ O $any$ O O O O O O $string$ O $ObjectConstructor$ O $complex$ O $any$ O $string$ O O O O O $any$ O $any$ O $string$ O O $string$ O O O $any$ O O $any$ O $string$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $TextDocument$ O $Position$ O $CancellationToken$ O $CompletionContext$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $boolean$ O $any$ O $any$ O O O O O O O O O $boolean$ O $any$ O $any$ O O O O O O O $any$ O O O $boolean$ O $string$ O $CompletionContext$ O O $string$ O $string$ O $string$ O O O O O $string$ O $number$ O O O O O O O O O O O O O O O
import { CancellationToken , CodeAction , CodeActionContext , CodeActionKind , CodeActionProvider , CodeActionProviderMetadata , Range , TextDocument } from "s" ; import { isAnalyzableAndInWorkspace } from "s" ; const SourceSortMembers = CodeActionKind . Source . append ( "s" ) ; export class SourceCodeActionProvider implements CodeActionProvider { public readonly metadata : CodeActionProviderMetadata = { providedCodeActionKinds : [ CodeActionKind . Source , CodeActionKind . SourceOrganizeImports , SourceSortMembers ] , } ; public provideCodeActions ( document , range , context , token ) : CodeAction [ ] | undefined { if ( ! isAnalyzableAndInWorkspace ( document ) ) return undefined ; const actions = [ ] ; if ( ! context || ! context . only || context . only . contains ( CodeActionKind . Source ) || context . only . contains ( CodeActionKind . SourceOrganizeImports ) ) { actions . push ( { command : { arguments : [ document ] , command : "s" , title : "s" , } , kind : CodeActionKind . SourceOrganizeImports , title : "s" , } ) ; } if ( ! context || ! context . only || context . only . contains ( CodeActionKind . Source ) || context . only . contains ( SourceSortMembers ) ) { actions . push ( { command : { arguments : [ document ] , command : "s" , title : "s" , } , kind : SourceSortMembers , title : "s" , } ) ; } return actions ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any[]$ O $TextDocument$ O $Range$ O $CodeActionContext$ O $CancellationToken$ O O $any$ O O O O O O O O $boolean$ O $any$ O O O $undefined$ O O $any[]$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any[]$ O $number$ O O $complex$ O O $any[]$ O O $any$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any[]$ O $number$ O O $complex$ O O $any[]$ O O $any$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O $string$ O O O O O O O O $any[]$ O O O
import * as path from "s" ; import * as vs from "s" ; import { flutterPath , pubPath } from "s" ; import { Sdks } from "s" ; import { fsPath , getDartWorkspaceFolders } from "s" ; import { config } from "s" ; import { referencesBuildRunner } from "s" ; import * as util from "s" ; import { toolEnv } from "s" ; export class PubBuildRunnerTaskProvider implements vs . TaskProvider { constructor ( private sdks ) { } public provideTasks ( token ? : vs . CancellationToken ) : vs . ProviderResult < vs . Task [ ] > { const dartProjects = getDartWorkspaceFolders ( ) ; const tasks : vs . Task [ ] = [ ] ; dartProjects . forEach ( ( folder ) => { if ( referencesBuildRunner ( fsPath ( folder . uri ) ) ) { tasks . push ( this . createBuildRunnerCommandBackgroundTask ( folder , "s" , vs . TaskGroup . Build ) ) ; tasks . push ( this . createBuildRunnerCommandBackgroundTask ( folder , "s" , vs . TaskGroup . Build ) ) ; tasks . push ( this . createBuildRunnerCommandBackgroundTask ( folder , "s" , vs . TaskGroup . Build ) ) ; tasks . push ( this . createBuildRunnerCommandBackgroundTask ( folder , "s" , vs . TaskGroup . Test ) ) ; } } ) ; return tasks ; } private createBuildRunnerCommandBackgroundTask ( folder : vs . WorkspaceFolder , subCommand , group : vs . TaskGroup ) { const isFlutter = util . isFlutterWorkspaceFolder ( folder ) && this . sdks . flutter ; const type = isFlutter ? "s" : "s" ; const program = isFlutter ? path . join ( this . sdks . flutter ! , flutterPath ) : path . join ( this . sdks . dart ! , pubPath ) ; const args = isFlutter ? [ "s" , "s" , "s" , "s" , subCommand ] : [ "s" , "s" , subCommand ] ; if ( config . buildRunnerAdditionalArgs ) { args . push ( ... config . buildRunnerAdditionalArgs ) ; } const task = new vs . Task ( { command : subCommand , type , } , folder , `template` , type , new vs . ProcessExecution ( program , args , { cwd : fsPath ( folder . uri ) , env : toolEnv } , ) , "s" ) ; task . group = group ; task . isBackground = true ; task . name = `template` ; return task ; } public resolveTask ( task : vs . Task , token ? : vs . CancellationToken ) { return undefined ; } }	O O O $any$ O O O O O O $any$ O O O O O $string$ O $string$ O O O O O O $any$ O O O O O O $string$ O $any[]$ O O O O O O $Config$ O O O O O O $boolean$ O O O O O O O $any$ O O O O O $complex$ O O O O O O $any$ O $any$ O $any$ O O O O $Sdks$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any[]$ O $any[]$ O O O O $any[]$ O $any$ O $any$ O O O O O O $any[]$ O $void$ O O $any$ O O O O O $boolean$ O $string$ O $any$ O $any$ O O O O $any[]$ O $number$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any[]$ O $number$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any[]$ O $number$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any[]$ O $number$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any[]$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O $string$ O $any$ O $boolean$ O $any$ O O O O $Sdks$ O $string$ O O O O $string$ O O O O O O $any$ O $string$ O $any$ O $any$ O O O $Sdks$ O $string$ O O $string$ O O $any$ O $any$ O O O $Sdks$ O $string$ O O $string$ O O O $string[]$ O $string$ O O O O O O O O O O $string$ O O O O O O O $string$ O O O O $Config$ O $string[]$ O O $string[]$ O $number$ O O $Config$ O $string[]$ O O O O $any$ O O $any$ O $any$ O O $string$ O $string$ O $string$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $string[]$ O O $string$ O $string$ O $any$ O $any$ O O $complex$ O $complex$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O $undefined$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $undefined$ O O O
import * as vs from "s" ; import { WorkspaceContext } from "s" ; import { config } from "s" ; import { isAnalyzable } from "s" ; export class StatusBarVersionTracker implements vs . Disposable { private subscriptions : vs . Disposable [ ] = [ ] ; constructor ( workspaceContext ) { const dartIsFromFlutter = workspaceContext . sdks . dartSdkIsFromFlutter ; const switchSdkCommand = workspaceContext . hasAnyFlutterProjects ? ( config . flutterSdkPaths && config . flutterSdkPaths . length > 0 ? "s" : undefined ) : ( config . sdkPaths && config . sdkPaths . length > 0 ? "s" : undefined ) ; const label = workspaceContext . hasAnyFlutterProjects ? "s" : ( dartIsFromFlutter ? "s" : "s" ) ; const versionLabel = ( workspaceContext . hasAnyFlutterProjects || dartIsFromFlutter ) ? workspaceContext . sdks . flutterVersion : workspaceContext . sdks . dartVersion ; if ( versionLabel ) { this . addStatusBarItem ( `template` + ( versionLabel . length > 0 ? versionLabel . substr ( 0 , 0 ) + "s" : versionLabel ) , `template` , switchSdkCommand , ) ; } } private addStatusBarItem ( text , tooltip , command : string | undefined ) { const statusBarItem = vs . window . createStatusBarItem ( vs . StatusBarAlignment . Right , 0 ) ; statusBarItem . text = text ; statusBarItem . tooltip = tooltip ; statusBarItem . command = command ; this . subscriptions . push ( statusBarItem ) ; this . subscriptions . push ( vs . window . onDidChangeActiveTextEditor ( ( e ) => { if ( e && e . document && isAnalyzable ( e . document ) ) statusBarItem . show ( ) ; else statusBarItem . hide ( ) ; } ) ) ; if ( vs . window . activeTextEditor && vs . window . activeTextEditor . document && isAnalyzable ( vs . window . activeTextEditor . document ) ) statusBarItem . show ( ) ; } public dispose ( ) { this . subscriptions . forEach ( ( s ) => s . dispose ( ) ) ; } }	O O O $any$ O O O O O $any$ O O O O O O $Config$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O $any$ O O O O O O O O $WorkspaceContext$ O O O $boolean$ O $WorkspaceContext$ O $Sdks$ O $boolean$ O O O O $WorkspaceContext$ O $boolean$ O O $Config$ O $string[]$ O $Config$ O $string[]$ O $number$ O O O O O $undefined$ O O O $Config$ O $string[]$ O $Config$ O $string[]$ O $number$ O O O O O $undefined$ O O O O O $WorkspaceContext$ O $boolean$ O O O O $boolean$ O O O O O O O $string$ O O $WorkspaceContext$ O $boolean$ O $boolean$ O O $WorkspaceContext$ O $Sdks$ O $string$ O $WorkspaceContext$ O $Sdks$ O $string$ O O O $string$ O O O O $void$ O O O O $string$ O $number$ O O O $string$ O $string$ O O O O O O O O $string$ O O O O O O O O O O O $void$ O $string$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O $any$ O $string$ O $any$ O $any$ O $string$ O O O $any[]$ O $number$ O $any$ O O O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $boolean$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $void$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O
import { window } from "s" ; import { DART_DOWNLOAD_URL } from "s" ; import { Logger } from "s" ; import { versionIsAtLeast } from "s" ; import { WorkspaceContext } from "s" ; import { config } from "s" ; import { getLatestSdkVersion } from "s" ; import { envUtils } from "s" ; export async function checkForStandardDartSdkUpdates ( logger , workspaceContext ) < void > { if ( ! config . checkForSdkUpdates || ! workspaceContext . hasOnlyDartProjects ) return ; if ( workspaceContext . sdks . dartSdkIsFromFlutter ) return ; const dartSdkVersion = workspaceContext . sdks . dartVersion ; try { const version = await getLatestSdkVersion ( ) ; if ( ! dartSdkVersion || versionIsAtLeast ( dartSdkVersion , version ) ) return ; const goToDownloadsAction = "s" ; const dontShowAgainAction = "s" ; const message = `template` ; const action = await window . showWarningMessage ( message , goToDownloadsAction , dontShowAgainAction ) ; if ( action === goToDownloadsAction ) await envUtils . openInBrowser ( DART_DOWNLOAD_URL ) ; else if ( action === dontShowAgainAction ) config . setCheckForSdkUpdates ( false ) ; } catch ( e ) { logger . error ( e ) ; } }	O O $any$ O O O O O O O O O O O O O $any$ O O O O O O $boolean$ O O O O O O $any$ O O O O O O $Config$ O O O O O O $PromiseLike<string>$ O O O O O O $EnvUtils$ O O O O O O O $Promise$ O $Logger$ O $WorkspaceContext$ O O O O O O O O $Config$ O $boolean$ O O $WorkspaceContext$ O $boolean$ O O O O O $WorkspaceContext$ O $Sdks$ O $boolean$ O O O O $string$ O $WorkspaceContext$ O $Sdks$ O $string$ O O O O $string$ O O $PromiseLike<string>$ O O O O O O $string$ O $boolean$ O $string$ O $string$ O O O O O O O O O O O O O O O $string$ O O O O $any$ O O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O O $EnvUtils$ O $Promise<boolean>$ O O O O O O O $any$ O O O $Config$ O $any$ O O O O O O O $any$ O O $Logger$ O $void$ O $any$ O O O O
import * as fs from "s" ; import * as path from "s" ; import * as vs from "s" ; import { DART_STAGEHAND_PROJECT_TRIGGER_FILE , flutterExtensionIdentifier , FLUTTER_CREATE_PROJECT_TRIGGER_FILE , installFlutterExtensionPromptKey , noAction , recommendedSettingsUrl , showRecommendedSettingsAction , userPromptContextPrefix , yesAction } from "s" ; import { LogCategory } from "s" ; import { Logger , StagehandTemplate } from "s" ; import { checkHasFlutterExtension , extensionVersion , hasFlutterExtension , isDevExtension } from "s" ; import { showFlutterSurveyNotificationIfAppropriate } from "s" ; import { fsPath , getDartWorkspaceFolders } from "s" ; import { Context } from "s" ; import { WorkspaceContext } from "s" ; import { markProjectCreationEnded , markProjectCreationStarted } from "s" ; import { reloadExtension } from "s" ; import { envUtils } from "s" ; export async function showUserPrompts ( logger , context , workspaceContext ) < void > { handleNewProjects ( logger , context ) ; function shouldSuppress ( key ) { const stateKey = `template` ; return context . get ( stateKey ) === true ; } function showPrompt ( key , prompt : ( ) => Thenable < boolean > ) { const stateKey = `template` ; prompt ( ) . then ( ( res ) => context . update ( stateKey , res ) , error ) ; } if ( workspaceContext . hasAnyFlutterProjects && ! hasFlutterExtension && ! shouldSuppress ( installFlutterExtensionPromptKey ) ) { await new Promise ( ( resolve ) => setTimeout ( resolve , 0 ) ) ; if ( ! checkHasFlutterExtension ( ) ) return showPrompt ( installFlutterExtensionPromptKey , promptToInstallFlutterExtension ) ; } const lastSeenVersionNotification = context . lastSeenVersion ; if ( ! lastSeenVersionNotification ) { context . lastSeenVersion = extensionVersion ; } else if ( ! isDevExtension && lastSeenVersionNotification !== extensionVersion ) { const versionLink = extensionVersion . split ( "s" ) . slice ( 0 , 0 ) . join ( "s" ) . replace ( "s" , "s" ) ; promptToShowReleaseNotes ( extensionVersion , versionLink ) . then ( ( ) => context . lastSeenVersion = extensionVersion , ) ; return ; } if ( workspaceContext . hasAnyFlutterProjects ) { if ( showFlutterSurveyNotificationIfAppropriate ( context , envUtils . openInBrowser , Date . now ( ) , logger ) ) return ; } } async function promptToUseRecommendedSettings ( ) < boolean > { const action = await vs . window . showInformationMessage ( "s" , yesAction , noAction , showRecommendedSettingsAction , ) ; if ( action === yesAction ) { await vs . commands . executeCommand ( "s" ) ; } else if ( action === showRecommendedSettingsAction ) { envUtils . openInBrowser ( recommendedSettingsUrl ) ; } return true ; } async function promptToInstallFlutterExtension ( ) < boolean > { const installExtension = "s" ; const res = await vs . window . showInformationMessage ( "s" , installExtension , ) ; if ( res === installExtension ) { await vs . window . withProgress ( { location : vs . ProgressLocation . Notification } , ( progress ) => { progress . report ( { message : "s" } ) ; return new Promise ( ( resolve ) => { vs . extensions . onDidChange ( ( e ) => resolve ( ) ) ; vs . commands . executeCommand ( "s" , flutterExtensionIdentifier ) ; } ) ; } , ) ; reloadExtension ( ) ; } return false ; } async function promptToShowReleaseNotes ( versionDisplay , versionLink ) < boolean > { const res = await vs . window . showInformationMessage ( `template` , `template` , ) ; if ( res ) { envUtils . openInBrowser ( `template` ) ; } return true ; } function error ( err ) { vs . window . showErrorMessage ( err . message ) ; } async function handleNewProjects ( logger , context ) < void > { if ( process . env . DART_CODE_IS_TEST_RUN ) await new Promise ( ( resolve ) => setTimeout ( resolve , 0 ) ) ; getDartWorkspaceFolders ( ) . forEach ( ( wf ) => { handleStagehandTrigger ( logger , wf , DART_STAGEHAND_PROJECT_TRIGGER_FILE ) ; handleFlutterCreateTrigger ( wf ) ; } ) ; } async function handleStagehandTrigger ( logger , wf : vs . WorkspaceFolder , triggerFilename ) < void > { const triggerFile = path . join ( fsPath ( wf . uri ) , triggerFilename ) ; if ( fs . existsSync ( triggerFile ) ) { const templateJson = fs . readFileSync ( triggerFile ) . toString ( ) . trim ( ) ; let template ; try { template = JSON . parse ( templateJson ) ; } catch ( e ) { vs . window . showErrorMessage ( "s" ) ; return ; } fs . unlinkSync ( triggerFile ) ; logger . info ( `template` , LogCategory . CommandProcesses ) ; try { markProjectCreationStarted ( ) ; const success = await createDartProject ( fsPath ( wf . uri ) , template . name ) ; if ( success ) { logger . info ( `template` , LogCategory . CommandProcesses ) ; await vs . commands . executeCommand ( "s" , wf . uri ) ; handleDartWelcome ( wf , template ) ; logger . info ( `template` , LogCategory . CommandProcesses ) ; } else { logger . info ( `template` , LogCategory . CommandProcesses ) ; } } finally { markProjectCreationEnded ( ) ; } } } async function handleFlutterCreateTrigger ( wf : vs . WorkspaceFolder ) < void > { const flutterTriggerFile = path . join ( fsPath ( wf . uri ) , FLUTTER_CREATE_PROJECT_TRIGGER_FILE ) ; if ( fs . existsSync ( flutterTriggerFile ) ) { let sampleID : string | undefined = fs . readFileSync ( flutterTriggerFile ) . toString ( ) . trim ( ) ; sampleID = sampleID ? sampleID : undefined ; fs . unlinkSync ( flutterTriggerFile ) ; try { markProjectCreationStarted ( ) ; const success = await createFlutterProject ( fsPath ( wf . uri ) , sampleID ) ; if ( success ) handleFlutterWelcome ( wf , sampleID ) ; } finally { markProjectCreationEnded ( ) ; } } } async function createDartProject ( projectPath , templateName ) < boolean > { const code = await vs . commands . executeCommand ( "s" , projectPath , templateName ) as number ; return code === 0 ; } async function createFlutterProject ( projectPath , sampleID : string | undefined ) < boolean > { const projectName = sampleID ? "s" : undefined ; const code = await vs . commands . executeCommand ( "s" , projectPath , projectName , sampleID ) as number ; return code === 0 ; } function handleFlutterWelcome ( workspaceFolder : vs . WorkspaceFolder , sampleID : string | undefined ) { const entryFile = path . join ( fsPath ( workspaceFolder . uri ) , "s" ) ; openFile ( entryFile ) ; if ( sampleID ) vs . window . showInformationMessage ( `template` ) ; else vs . window . showInformationMessage ( "s" ) ; } function handleDartWelcome ( workspaceFolder : vs . WorkspaceFolder , template ) { const workspacePath = fsPath ( workspaceFolder . uri ) ; const projectName = path . basename ( workspacePath ) ; const entryFile = path . join ( workspacePath , template . entrypoint . replace ( "s" , projectName ) ) ; openFile ( entryFile ) ; vs . window . showInformationMessage ( `template` ) ; } function openFile ( entryFile ) { if ( ! fs . existsSync ( entryFile ) ) return ; setTimeout ( ( ) => { vs . commands . executeCommand ( "s" , vs . Uri . file ( entryFile ) ) ; } , 0 ) ; }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $boolean$ O $string$ O $boolean$ O $boolean$ O O O O O O $boolean$ O O O O O O $string$ O $any[]$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O $void$ O O O O O O $Promise<void>$ O O O O O O $EnvUtils$ O O O O O O O $Promise$ O $Logger$ O $Context$ O $WorkspaceContext$ O O O O O $Promise<void>$ O $Logger$ O $Context$ O O O $boolean$ O $string$ O O O $string$ O O O O $Context$ O $any$ O $string$ O O O O O O $void$ O $string$ O $any$ O O O O $any$ O O O O O O $string$ O O O $any$ O O O $any$ O O $any$ O O $Context$ O $any$ O $string$ O $any$ O O $void$ O O O O O $WorkspaceContext$ O $boolean$ O O $boolean$ O O $boolean$ O O O O O O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O O O O O O O O $boolean$ O O O O $void$ O O O $Promise<boolean>$ O O O O $string$ O $Context$ O $string$ O O O O $string$ O O $Context$ O $string$ O $string$ O O O O O O $boolean$ O $string$ O $string$ O O O $string$ O $string$ O $complex$ O O O O $string[]$ O O O O O O $string$ O O O O $complex$ O O O O O O $Promise<boolean>$ O $string$ O $string$ O O O O O O O $Context$ O $string$ O $string$ O O O O O O O O $WorkspaceContext$ O $boolean$ O O O O $boolean$ O $Context$ O $EnvUtils$ O $Promise<boolean>$ O $DateConstructor$ O $number$ O O O $Logger$ O O O O O O O O $Promise$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O $EnvUtils$ O $Promise<boolean>$ O O O O O O O O O O O $Promise$ O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O $string$ O O O O O O O $PromiseConstructor$ O O $void$ O O O $any$ O $any$ O $any$ O O $any$ O O $void$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $Promise<void>$ O O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O $EnvUtils$ O $Promise<boolean>$ O O O O O O O O O O $void$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Promise$ O $Logger$ O $Context$ O O O O O O O $any$ O $any$ O $any$ O O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O O O O O $any[]$ O O O $void$ O O $any$ O O O $Promise<void>$ O $Logger$ O $any$ O O O O $Promise<void>$ O $any$ O O O O O O O O $Promise$ O $Logger$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O O $string$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O $StagehandTemplate$ O O O $StagehandTemplate$ O $JSON$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O $Logger$ O $void$ O O O $any$ O $LogCategory.CommandProcesses$ O O O O $void$ O O O O $boolean$ O O $Promise<boolean>$ O $string$ O $any$ O $any$ O O $StagehandTemplate$ O $string$ O O O O $boolean$ O O $Logger$ O $void$ O O O $any$ O $LogCategory.CommandProcesses$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $void$ O $any$ O $StagehandTemplate$ O O $Logger$ O $void$ O O O $any$ O $LogCategory.CommandProcesses$ O O O O O $Logger$ O $void$ O O O $any$ O $LogCategory.CommandProcesses$ O O O O O O $void$ O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O $string$ O $string$ O $string$ O $undefined$ O $any$ O $any$ O $any$ O O O O $void$ O O O O $boolean$ O O $Promise<boolean>$ O $string$ O $any$ O $any$ O O $string$ O O O O $boolean$ O $void$ O $any$ O $string$ O O O O O $void$ O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O $number$ O O $any$ O $any$ O $any$ O O O $string$ O $string$ O O O O O $number$ O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O O O O O $string$ O O O $undefined$ O O $number$ O O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O O O O O $number$ O O O O O $void$ O $any$ O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O O O O O $void$ O $any$ O O O O $string$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O $StagehandTemplate$ O O O $string$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O $StagehandTemplate$ O $string$ O $complex$ O O O $any$ O O O $void$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $void$ O $string$ O O O O O $any$ O $any$ O $string$ O O O O $number$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O O O O O O
import * as fs from "s" ; import * as path from "s" ; import * as vs from "s" ; import { DART_DEP_FILE_NODE_CONTEXT , DART_DEP_FOLDER_NODE_CONTEXT , DART_DEP_PACKAGE_NODE_CONTEXT , DART_DEP_PROJECT_NODE_CONTEXT } from "s" ; import { Logger } from "s" ; import { PackageMap } from "s" ; import { sortBy } from "s" ; import { findProjectFolders } from "s" ; import { fsPath , getDartWorkspaceFolders } from "s" ; export class DartPackagesProvider implements vs . Disposable , vs . TreeDataProvider < PackageDep > { private readonly watcher : vs . FileSystemWatcher ; private onDidChangeTreeDataEmitter : vs . EventEmitter < PackageDep | undefined > = new vs . EventEmitter < PackageDep | undefined > ( ) ; public readonly onDidChangeTreeData : vs . Event < PackageDep | undefined > = this . onDidChangeTreeDataEmitter . event ; constructor ( private readonly logger ) { this . watcher = vs . workspace . createFileSystemWatcher ( "s" ) ; this . watcher . onDidChange ( this . refresh , this ) ; this . watcher . onDidCreate ( this . refresh , this ) ; this . watcher . onDidDelete ( this . refresh , this ) ; } public refresh ( ) { this . onDidChangeTreeDataEmitter . fire ( ) ; } public getTreeItem ( element ) : vs . TreeItem { return element ; } public async getChildren ( element ? ) < PackageDep [ ] > { if ( ! element ) { const topLevelFolders = getDartWorkspaceFolders ( ) . map ( ( w ) => fsPath ( w . uri ) ) ; const allProjects = await findProjectFolders ( topLevelFolders , { requirePubspec : true } ) ; const nodes = allProjects . map ( ( folder ) => new PackageDepProject ( vs . Uri . file ( folder ) ) ) ; return nodes . length === 0 ? this . getChildren ( nodes [ 0 ] ) : nodes ; } else if ( element instanceof PackageDepProject ) { return this . getPackages ( element ) ; } else if ( element instanceof PackageDepPackage ) { return this . getFilesAndFolders ( element ) ; } else if ( element instanceof PackageDepFolder ) { return this . getFilesAndFolders ( element ) ; } else if ( element instanceof PackageDepFile ) { return [ ] ; } else { this . logger . warn ( `template` ) ; return [ ] ; } } private getPackages ( project ) : PackageDep [ ] { const map = new PackageMap ( path . join ( fsPath ( project . resourceUri ! ) , "s" ) ) ; const packages = map . packages ; const packageNames = sortBy ( Object . keys ( packages ) , ( s ) => s . toLowerCase ( ) ) ; return packageNames . filter ( ( name ) => name !== map . localPackageName ) . map ( ( name ) => { const path = packages [ name ] ; return new PackageDepPackage ( `template` , vs . Uri . file ( path ) ) ; } ) ; } private getFilesAndFolders ( folder ) : PackageDep [ ] { const children = sortBy ( fs . readdirSync ( fsPath ( folder . resourceUri ! ) , { withFileTypes : true } ) , ( s ) => s . name . toLowerCase ( ) ) ; const folders : PackageDepFolder [ ] = [ ] ; const files : PackageDepFile [ ] = [ ] ; if ( ! folder . resourceUri ) return [ ] ; const folderPath = fsPath ( folder . resourceUri ) ; children . forEach ( ( child ) => { const filePath = path . join ( folderPath , child . name ) ; if ( child . isFile ( ) ) { files . push ( new PackageDepFile ( vs . Uri . file ( filePath ) ) ) ; } else if ( child . isDirectory ( ) ) { folders . push ( new PackageDepFolder ( vs . Uri . file ( filePath ) ) ) ; } } ) ; return [ ... folders , ... files ] ; } public dispose ( ) { this . watcher . dispose ( ) ; } } export abstract class PackageDep extends vs . TreeItem { constructor ( label : string | undefined , resourceUri : vs . Uri , collapsibleState : vs . TreeItemCollapsibleState | undefined , ) { if ( label ) { super ( label , collapsibleState ) ; this . resourceUri = resourceUri ; } else { super ( resourceUri , collapsibleState ) ; } } } export class PackageDepFile extends PackageDep { constructor ( resourceUri : vs . Uri , ) { super ( undefined , resourceUri , vs . TreeItemCollapsibleState . None ) ; this . contextValue = DART_DEP_FILE_NODE_CONTEXT ; this . command = { arguments : [ resourceUri ] , command : "s" , title : "s" , } ; } } export class PackageDepFolder extends PackageDep { constructor ( resourceUri : vs . Uri , ) { super ( undefined , resourceUri , vs . TreeItemCollapsibleState . Collapsed ) ; this . contextValue = DART_DEP_FOLDER_NODE_CONTEXT ; } } export class PackageDepProject extends PackageDep { constructor ( resourceUri : vs . Uri , ) { const projectFolder = fsPath ( resourceUri ) ; super ( path . basename ( projectFolder ) , resourceUri , vs . TreeItemCollapsibleState . Collapsed ) ; this . contextValue = DART_DEP_PROJECT_NODE_CONTEXT ; const wf = vs . workspace . getWorkspaceFolder ( resourceUri ) ; if ( wf ) { const workspaceFolder = fsPath ( wf . uri ) ; this . description = path . relative ( path . dirname ( workspaceFolder ) , path . dirname ( projectFolder ) ) ; } } } export class PackageDepPackage extends PackageDep { constructor ( label , resourceUri : vs . Uri , ) { super ( label , resourceUri , vs . TreeItemCollapsibleState . Collapsed ) ; this . contextValue = DART_DEP_PACKAGE_NODE_CONTEXT ; } }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $T[]$ O O O O O O $Promise<string[]>$ O O O O O O $string$ O $any[]$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $Logger$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $void$ O O O O O O $any$ O $any$ O O O $void$ O O O O O O $any$ O $any$ O O O $void$ O O O O O O $void$ O O O O O $any$ O $any$ O O O O O $any$ O $PackageDep$ O O $any$ O $any$ O O $PackageDep$ O O O O $Promise$ O $PackageDep$ $PackageDep$ O O $any$ O O O O O O O $PackageDep$ O O O $string[]$ O $any[]$ O O O $U[]$ O O $any$ O O $string$ O $any$ O $any$ O O O O $string[]$ O O $Promise<string[]>$ O $string[]$ O O $true$ O O O O O O $PackageDepProject[]$ O $string[]$ O $U[]$ O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $PackageDepProject[]$ O $number$ O O O O O $Promise<PackageDep[]>$ O $PackageDepProject[]$ O O O O O $PackageDepProject[]$ O O O O O $PackageDep$ O $any$ O O O O O $PackageDep[]$ O $PackageDepProject$ O O O O O O $PackageDep$ O $any$ O O O O O $PackageDep[]$ O $PackageDepPackage$ O O O O O O $PackageDep$ O $any$ O O O O O $PackageDep[]$ O $PackageDepFolder$ O O O O O O $PackageDep$ O $any$ O O O O O O O O O O O $Logger$ O $void$ O O O O O O O O O O O $PackageDep[]$ O $PackageDepProject$ O O $any$ O O O O $PackageMap$ O O $any$ O $any$ O $any$ O $string$ O $PackageDepProject$ O $any$ O O O O O O O O $complex$ O $PackageMap$ O $complex$ O O $string[]$ O $T[]$ O $ObjectConstructor$ O $complex$ O $complex$ O O O $string$ O O $string$ O $string$ O O O O O $string[]$ O $complex$ O O $string$ O O $string$ O $PackageMap$ O $string$ O O $U[]$ O O $string$ O O O O $string$ O $complex$ O $string$ O O O O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O O O O O $PackageDep[]$ O $PackageDepFolder$ O O $any$ O O O O $unknown[]$ O $T[]$ O $any$ O $any$ O $string$ O $PackageDepFolder$ O $any$ O O O O $boolean$ O O O O O O $unknown$ O O $unknown$ O $any$ O $any$ O O O O O $PackageDepFolder[]$ O $any$ O O O O O O O $PackageDepFile[]$ O $any$ O O O O O O O O O $PackageDepFolder$ O $any$ O O O O O O $string$ O $string$ O $PackageDepFolder$ O $any$ O O $unknown[]$ O $void$ O O $unknown$ O O O O $any$ O $any$ O $any$ O $string$ O $unknown$ O $any$ O O O O $unknown$ O $any$ O O O O $PackageDepFile[]$ O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $unknown$ O $any$ O O O O $PackageDepFolder[]$ O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $PackageDepFolder[]$ O O $PackageDepFile[]$ O O O O $void$ O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $string$ O O O O $string$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $undefined$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O $any[]$ O O $any$ O O $string$ O O O $string$ O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $undefined$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $string$ O $string$ O $any$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O O O O O O O $any$ O $any$ O O O $string$ O $any$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O
import * as fs from "s" ; import * as path from "s" ; import { isArray } from "s" ; import * as vs from "s" ; import { DaemonCapabilities , FlutterCapabilities } from "s" ; import { analyzerSnapshotPath , dartPlatformName , dartVMPath , flutterExtensionIdentifier , flutterPath , HAS_LAST_DEBUG_CONFIG , isWin , IS_RUNNING_LOCALLY_CONTEXT , platformDisplayName } from "s" ; import { LogCategory } from "s" ; import { DartWorkspaceContext , IFlutterDaemon , Sdks } from "s" ; import { captureLogs , EmittingLogger , logToConsole } from "s" ; import { internalApiSymbol } from "s" ; import { forceWindowsDriveLetterToUppercase , isWithinPath } from "s" ; import { FlutterDeviceManager } from "s" ; import { extensionVersion , isDevExtension } from "s" ; import { InternalExtensionApi } from "s" ; import { DartUriHandler } from "s" ; import { fsPath , getDartWorkspaceFolders , isRunningLocally } from "s" ; import { Context } from "s" ; import { WorkspaceContext } from "s" ; import { Analyzer } from "s" ; import { AnalyzerStatusReporter } from "s" ; import { FileChangeHandler } from "s" ; import { openFileTracker } from "s" ; import { Analytics } from "s" ; import { DartExtensionApi } from "s" ; import { TestCodeLensProvider } from "s" ; import { AnalyzerCommands } from "s" ; import { DebugCommands } from "s" ; import { EditCommands } from "s" ; import { DasEditCommands } from "s" ; import { FlutterOutlineCommands } from "s" ; import { GoToSuperCommand } from "s" ; import { LoggingCommands } from "s" ; import { OpenInOtherEditorCommands } from "s" ; import { RefactorCommands } from "s" ; import { SdkCommands } from "s" ; import { cursorIsInTest , TestCommands } from "s" ; import { TypeHierarchyCommand } from "s" ; import { config } from "s" ; import { ClosingLabelsDecorations } from "s" ; import { FlutterColorDecorations } from "s" ; import { FlutterIconDecorations } from "s" ; import { FlutterUiGuideDecorations } from "s" ; import { HotReloadCoverageDecorations } from "s" ; import { setUpDaemonMessageHandler } from "s" ; import { FlutterDaemon } from "s" ; import { FlutterOutlineProvider } from "s" ; import { setUpHotReloadOnSave } from "s" ; import { AssistCodeActionProvider } from "s" ; import { DartCompletionItemProvider } from "s" ; import { DartDiagnosticProvider } from "s" ; import { DartDocumentSymbolProvider } from "s" ; import { DartFoldingProvider } from "s" ; import { DartFormattingEditProvider } from "s" ; import { DartDocumentHighlightProvider } from "s" ; import { DartHoverProvider } from "s" ; import { DartImplementationProvider } from "s" ; import { DartLanguageConfiguration } from "s" ; import { DartReferenceProvider } from "s" ; import { DartRenameProvider } from "s" ; import { DartSignatureHelpProvider } from "s" ; import { DartWorkspaceSymbolProvider } from "s" ; import { DebugConfigProvider } from "s" ; import { FixCodeActionProvider } from "s" ; import { IgnoreLintCodeActionProvider } from "s" ; import { LegacyDartWorkspaceSymbolProvider } from "s" ; import { RankingCodeActionProvider } from "s" ; import { RefactorCodeActionProvider } from "s" ; import { SnippetCompletionItemProvider } from "s" ; import { SourceCodeActionProvider } from "s" ; import { PubBuildRunnerTaskProvider } from "s" ; import { PubGlobal } from "s" ; import { DartCapabilities } from "s" ; import { StatusBarVersionTracker } from "s" ; import { checkForStandardDartSdkUpdates } from "s" ; import { SdkUtils } from "s" ; import { showUserPrompts } from "s" ; import * as util from "s" ; import { addToLogHeader , clearLogHeader , getExtensionLogPath , getLogHeader } from "s" ; import { safeSpawn } from "s" ; import { envUtils } from "s" ; import { DartPackagesProvider } from "s" ; import { TestItemTreeItem , TestResultsProvider } from "s" ; const DART_MODE = { language : "s" , scheme : "s" } ; const HTML_MODE = { language : "s" , scheme : "s" } ; const additionalModes = config . additionalAnalyzerFileExtensions . map ( ( ext ) => { return { scheme : "s" , pattern : `template` } ; } ) ; const DART_PROJECT_LOADED = "s" ; const FLUTTER_PROJECT_LOADED = "s" ; const FLUTTER_MOBILE_PROJECT_LOADED = "s" ; const FLUTTER_WEB_PROJECT_LOADED = "s" ; export const FLUTTER_SUPPORTS_ATTACH = "s" ; const DART_PLATFORM_NAME = "s" ; export const SERVICE_EXTENSION_CONTEXT_PREFIX = "s" ; export const SERVICE_CONTEXT_PREFIX = "s" ; let analyzer ; let flutterDaemon ; let deviceManager ; const dartCapabilities = DartCapabilities . empty ; const flutterCapabilities = FlutterCapabilities . empty ; let analysisRoots : string [ ] = [ ] ; let analytics ; let showTodos : boolean | undefined ; let previousSettings ; const loggers < { dispose : ( ) => Promise < void > | void } > = [ ] ; const logger = new EmittingLogger ( ) ; export async function activate ( context : vs . ExtensionContext , isRestart = false ) { if ( isDevExtension ) logToConsole ( logger ) ; vs . commands . executeCommand ( "s" , IS_RUNNING_LOCALLY_CONTEXT , isRunningLocally ) ; buildLogHeaders ( ) ; setupLog ( getExtensionLogPath ( ) , LogCategory . General ) ; const extContext = Context . for ( context ) ; util . logTime ( "s" ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( _ ) => { logger . info ( "s" ) ; await deactivate ( true ) ; const toDispose = context . subscriptions . slice ( ) ; context . subscriptions . length = 0 ; for ( const sub of toDispose ) { try { sub . dispose ( ) ; } catch ( e ) { logger . error ( e ) ; } } activate ( context , true ) ; logger . info ( "s" ) ; } ) ) ; showTodos = config . showTodos ; previousSettings = getSettingsThatRequireRestart ( ) ; const extensionStartTime = new Date ( ) ; util . logTime ( ) ; const sdkUtils = new SdkUtils ( logger ) ; const workspaceContextUnverified = await sdkUtils . scanWorkspace ( ) ; util . logTime ( "s" ) ; buildLogHeaders ( workspaceContextUnverified ) ; setupLog ( config . analyzerLogFile , LogCategory . Analyzer ) ; setupLog ( config . flutterDaemonLogFile , LogCategory . FlutterDaemon ) ; setupLog ( config . devToolsLogFile , LogCategory . DevTools ) ; analytics = new Analytics ( logger , workspaceContextUnverified ) ; if ( ! workspaceContextUnverified . sdks . dart || ( workspaceContextUnverified . hasAnyFlutterProjects && ! workspaceContextUnverified . sdks . flutter ) ) { return sdkUtils . handleMissingSdks ( context , analytics , workspaceContextUnverified ) ; } const workspaceContext = workspaceContextUnverified as DartWorkspaceContext ; const sdks = workspaceContext . sdks ; if ( sdks . flutterVersion ) { flutterCapabilities . version = sdks . flutterVersion ; analytics . flutterSdkVersion = sdks . flutterVersion ; } if ( sdks . dartVersion ) { dartCapabilities . version = sdks . dartVersion ; analytics . sdkVersion = sdks . dartVersion ; checkForStandardDartSdkUpdates ( logger , workspaceContext ) ; context . subscriptions . push ( new StatusBarVersionTracker ( workspaceContext ) ) ; } const analyzerStartTime = new Date ( ) ; const analyzerPath = config . analyzerPath || path . join ( sdks . dart , analyzerSnapshotPath ) ; if ( ! config . analyzerSshHost && ! fs . existsSync ( analyzerPath ) ) { vs . window . showErrorMessage ( "s" + analyzerPath ) ; return ; } analyzer = new Analyzer ( logger , path . join ( sdks . dart , dartVMPath ) , analyzerPath ) ; context . subscriptions . push ( analyzer ) ; const connectedEvents = analyzer . registerForServerConnected ( ( sc ) => { analytics . analysisServerVersion = sc . version ; const analyzerEndTime = new Date ( ) ; analytics . logAnalyzerStartupTime ( analyzerEndTime . getTime ( ) - analyzerStartTime . getTime ( ) ) ; connectedEvents . dispose ( ) ; } ) ; const nextAnalysis = ( ) => new Promise < void > ( ( resolve , reject ) => { const disposable = analyzer . registerForServerStatus ( ( ss ) => { if ( ss . analysis && ! ss . analysis . isAnalyzing ) { resolve ( ) ; disposable . dispose ( ) ; } } ) ; } ) ; let analysisStartTime ; const initialAnalysis = nextAnalysis ( ) ; const analysisCompleteEvents = analyzer . registerForServerStatus ( ( ss ) => { if ( ss . analysis && ss . analysis . isAnalyzing && ! analysisStartTime ) analysisStartTime = new Date ( ) ; if ( ss . analysis && ! ss . analysis . isAnalyzing && analysisStartTime ) { const analysisEndTime = new Date ( ) ; analytics . logAnalyzerFirstAnalysisTime ( analysisEndTime . getTime ( ) - analysisStartTime . getTime ( ) ) ; analysisCompleteEvents . dispose ( ) ; } } ) ; const hoverProvider = new DartHoverProvider ( logger , analyzer ) ; const formattingEditProvider = new DartFormattingEditProvider ( logger , analyzer , extContext ) ; context . subscriptions . push ( formattingEditProvider ) ; const completionItemProvider = new DartCompletionItemProvider ( logger , analyzer ) ; const referenceProvider = new DartReferenceProvider ( analyzer ) ; const documentHighlightProvider = new DartDocumentHighlightProvider ( ) ; const sourceCodeActionProvider = new SourceCodeActionProvider ( ) ; const renameProvider = new DartRenameProvider ( analyzer ) ; const implementationProvider = new DartImplementationProvider ( analyzer ) ; const activeFileFilters : vs . DocumentSelector = [ DART_MODE ] ; if ( config . analyzeAngularTemplates ) { activeFileFilters . push ( HTML_MODE ) ; activeFileFilters . push ( ... additionalModes ) ; } const rankingCodeActionProvider = new RankingCodeActionProvider ( ) ; const triggerCharacters = "s" . split ( "s" ) ; context . subscriptions . push ( vs . languages . registerHoverProvider ( activeFileFilters , hoverProvider ) ) ; formattingEditProvider . registerDocumentFormatter ( activeFileFilters ) ; context . subscriptions . push ( vs . languages . registerCompletionItemProvider ( activeFileFilters , completionItemProvider , ... triggerCharacters ) ) ; context . subscriptions . push ( vs . languages . registerDefinitionProvider ( activeFileFilters , referenceProvider ) ) ; context . subscriptions . push ( vs . languages . registerReferenceProvider ( activeFileFilters , referenceProvider ) ) ; context . subscriptions . push ( vs . languages . registerDocumentHighlightProvider ( activeFileFilters , documentHighlightProvider ) ) ; rankingCodeActionProvider . registerProvider ( new AssistCodeActionProvider ( logger , activeFileFilters , analyzer ) ) ; rankingCodeActionProvider . registerProvider ( new FixCodeActionProvider ( logger , activeFileFilters , analyzer ) ) ; rankingCodeActionProvider . registerProvider ( new RefactorCodeActionProvider ( activeFileFilters , analyzer ) ) ; context . subscriptions . push ( vs . languages . registerRenameProvider ( activeFileFilters , renameProvider ) ) ; formattingEditProvider . registerTypingFormatter ( DART_MODE , "s" , "s" ) ; context . subscriptions . push ( vs . languages . registerCodeActionsProvider ( DART_MODE , sourceCodeActionProvider , sourceCodeActionProvider . metadata ) ) ; rankingCodeActionProvider . registerProvider ( new IgnoreLintCodeActionProvider ( activeFileFilters ) ) ; context . subscriptions . push ( vs . languages . registerImplementationProvider ( DART_MODE , implementationProvider ) ) ; if ( config . showTestCodeLens ) { const codeLensProvider = new TestCodeLensProvider ( logger , analyzer ) ; context . subscriptions . push ( codeLensProvider ) ; context . subscriptions . push ( vs . languages . registerCodeLensProvider ( DART_MODE , codeLensProvider ) ) ; } context . subscriptions . push ( vs . languages . registerCodeActionsProvider ( activeFileFilters , rankingCodeActionProvider , rankingCodeActionProvider . metadata ) ) ; if ( config . previewBuildRunnerTasks ) { context . subscriptions . push ( vs . tasks . registerTaskProvider ( "s" , new PubBuildRunnerTaskProvider ( sdks ) ) ) ; } context . subscriptions . push ( vs . languages . registerCompletionItemProvider ( DART_MODE , new SnippetCompletionItemProvider ( "s" , ( _ ) => true ) ) ) ; context . subscriptions . push ( vs . languages . registerCompletionItemProvider ( DART_MODE , new SnippetCompletionItemProvider ( "s" , ( uri ) => util . isInsideFlutterProject ( uri ) || util . isInsideFlutterWebProject ( uri ) ) ) ) ; context . subscriptions . push ( vs . languages . setLanguageConfiguration ( DART_MODE . language , new DartLanguageConfiguration ( ) ) ) ; const statusReporter = new AnalyzerStatusReporter ( logger , analyzer , workspaceContext , analytics ) ; const diagnostics = vs . languages . createDiagnosticCollection ( "s" ) ; context . subscriptions . push ( diagnostics ) ; const diagnosticsProvider = new DartDiagnosticProvider ( analyzer , diagnostics ) ; const serverConnected = analyzer . registerForServerConnected ( ( sc ) => { serverConnected . dispose ( ) ; recalculateAnalysisRoots ( ) ; let hasWarnedAboutLooseDartFiles = false ; const handleOpenFile = ( d : vs . TextDocument ) => { if ( d . languageId === "s" && analysisRoots . length === 0 && ! hasWarnedAboutLooseDartFiles ) { hasWarnedAboutLooseDartFiles = true ; vs . window . showWarningMessage ( "s" ) ; } } ; context . subscriptions . push ( vs . workspace . onDidOpenTextDocument ( ( d ) => handleOpenFile ( d ) ) ) ; vs . window . visibleTextEditors . forEach ( ( e ) => handleOpenFile ( e . document ) ) ; } ) ; context . subscriptions . push ( new FileChangeHandler ( analyzer ) ) ; if ( workspaceContext . hasAnyFlutterMobileProjects && sdks . flutter ) { flutterDaemon = new FlutterDaemon ( logger , path . join ( sdks . flutter , flutterPath ) , sdks . flutter ) ; deviceManager = new FlutterDeviceManager ( logger , flutterDaemon , config . flutterSelectDeviceWhenConnected ) ; context . subscriptions . push ( deviceManager ) ; context . subscriptions . push ( flutterDaemon ) ; setUpDaemonMessageHandler ( logger , context , flutterDaemon ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , deviceManager . showDevicePicker , deviceManager ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , deviceManager . promptForAndLaunchEmulator , deviceManager ) ) ; } util . logTime ( "s" ) ; const pubGlobal = new PubGlobal ( logger , extContext , sdks ) ; const debugProvider = new DebugConfigProvider ( logger , sdks , analytics , pubGlobal , flutterDaemon , deviceManager , dartCapabilities , flutterCapabilities ) ; context . subscriptions . push ( vs . debug . registerDebugConfigurationProvider ( "s" , debugProvider ) ) ; context . subscriptions . push ( debugProvider ) ; if ( config . previewFlutterUiGuides ) context . subscriptions . push ( new FlutterUiGuideDecorations ( analyzer ) ) ; if ( config . previewFlutterGutterIcons ) { context . subscriptions . push ( new FlutterIconDecorations ( logger , analyzer ) ) ; context . subscriptions . push ( new FlutterColorDecorations ( logger , path . join ( context . globalStoragePath , "s" ) ) ) ; } const connectedSetup = analyzer . registerForServerConnected ( ( sc ) => { connectedSetup . dispose ( ) ; if ( analyzer . capabilities . supportsClosingLabels && config . closingLabels ) { context . subscriptions . push ( new ClosingLabelsDecorations ( analyzer ) ) ; } if ( analyzer . capabilities . supportsGetDeclerations ) { context . subscriptions . push ( vs . languages . registerWorkspaceSymbolProvider ( new DartWorkspaceSymbolProvider ( logger , analyzer ) ) ) ; } else { context . subscriptions . push ( vs . languages . registerWorkspaceSymbolProvider ( new LegacyDartWorkspaceSymbolProvider ( logger , analyzer ) ) ) ; } if ( analyzer . capabilities . supportsCustomFolding && config . analysisServerFolding ) context . subscriptions . push ( vs . languages . registerFoldingRangeProvider ( activeFileFilters , new DartFoldingProvider ( analyzer ) ) ) ; if ( analyzer . capabilities . supportsGetSignature ) context . subscriptions . push ( vs . languages . registerSignatureHelpProvider ( DART_MODE , new DartSignatureHelpProvider ( analyzer ) , ... ( config . triggerSignatureHelpAutomatically ? [ "s" , "s" ] : [ ] ) , ) ) ; const documentSymbolProvider = new DartDocumentSymbolProvider ( logger ) ; activeFileFilters . forEach ( ( filter ) => { context . subscriptions . push ( vs . languages . registerDocumentSymbolProvider ( filter , documentSymbolProvider ) ) ; } ) ; context . subscriptions . push ( openFileTracker . create ( logger , analyzer , workspaceContext ) ) ; if ( analyzer . capabilities . supportsAvailableSuggestions && config . autoImportCompletions ) { analyzer . completionSetSubscriptions ( { subscriptions : [ "s" ] , } ) ; } } ) ; context . subscriptions . push ( vs . workspace . onDidChangeConfiguration ( ( ) => handleConfigurationChange ( sdks ) ) ) ; const analyzerCommands = new AnalyzerCommands ( context , analyzer ) ; const sdkCommands = new SdkCommands ( logger , context , workspaceContext , sdkUtils , pubGlobal , flutterCapabilities , deviceManager ) ; const debugCommands = new DebugCommands ( logger , extContext , workspaceContext , analytics , pubGlobal ) ; if ( workspaceContext . hasAnyFlutterProjects ) { setUpHotReloadOnSave ( context , debugCommands ) ; } context . subscriptions . push ( vs . window . registerUriHandler ( new DartUriHandler ( flutterCapabilities ) ) ) ; context . subscriptions . push ( new EditCommands ( ) ) ; context . subscriptions . push ( new DasEditCommands ( logger , context , analyzer ) ) ; context . subscriptions . push ( new RefactorCommands ( logger , context , analyzer ) ) ; context . subscriptions . push ( new TypeHierarchyCommand ( logger , analyzer ) ) ; context . subscriptions . push ( new GoToSuperCommand ( analyzer ) ) ; context . subscriptions . push ( new LoggingCommands ( logger , context . logPath ) ) ; context . subscriptions . push ( new OpenInOtherEditorCommands ( logger , sdks ) ) ; context . subscriptions . push ( new TestCommands ( logger ) ) ; const dartPackagesProvider = new DartPackagesProvider ( logger ) ; const packagesTreeView = vs . window . createTreeView ( "s" , { treeDataProvider : dartPackagesProvider } ) ; context . subscriptions . push ( dartPackagesProvider , packagesTreeView , ) ; const testTreeProvider = new TestResultsProvider ( ) ; const testTreeView = vs . window . createTreeView ( "s" , { treeDataProvider : testTreeProvider } ) ; context . subscriptions . push ( testTreeProvider , testTreeView , testTreeProvider . onDidStartTests ( ( node ) => { if ( config . openTestViewOnStart ) testTreeView . reveal ( node ) ; } ) , testTreeProvider . onFirstFailure ( ( node ) => { if ( config . openTestViewOnFailure ) testTreeView . reveal ( node ) ; } ) , testTreeView . onDidChangeSelection ( ( e ) => { testTreeProvider . setSelectedNodes ( e . selection && e . selection . length === 0 ? e . selection [ 0 ] as TestItemTreeItem : undefined ) ; } ) , ) ; let flutterOutlineTreeProvider : FlutterOutlineProvider | undefined ; if ( config . flutterOutline ) { flutterOutlineTreeProvider = new FlutterOutlineProvider ( analyzer ) ; const tree = vs . window . createTreeView ( "s" , { treeDataProvider : flutterOutlineTreeProvider , showCollapseAll : true } ) ; tree . onDidChangeSelection ( ( e ) => { flutterOutlineTreeProvider ! . setContexts ( e . selection ) ; } ) ; context . subscriptions . push ( vs . window . onDidChangeTextEditorSelection ( ( e ) => { if ( e . selections && e . selections . length ) { const node = flutterOutlineTreeProvider ! . getNodeAt ( e . textEditor . document . uri , e . selections [ 0 ] . start ) ; if ( node && tree . visible ) tree . reveal ( node , { select : true , focus : false , expand : true } ) ; } } ) ) ; context . subscriptions . push ( tree ) ; context . subscriptions . push ( flutterOutlineTreeProvider ) ; const flutterOutlineCommands = new FlutterOutlineCommands ( tree , context ) ; } if ( workspaceContext . hasAnyFlutterProjects && config . previewHotReloadCoverageMarkers ) { context . subscriptions . push ( new HotReloadCoverageDecorations ( logger , debugCommands ) ) ; } context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( filePath ) => { if ( ! filePath ) return ; vs . workspace . openTextDocument ( filePath ) . then ( ( document ) => { vs . window . showTextDocument ( document , { preview : true } ) ; } , ( error ) => logger . error ( error ) ) ; } ) ) ; if ( vs . workspace . workspaceFolders && vs . workspace . workspaceFolders . length ) { for ( const wf of vs . workspace . workspaceFolders ) { const userPath = forceWindowsDriveLetterToUppercase ( fsPath ( wf . uri ) ) ; const realPath = forceWindowsDriveLetterToUppercase ( fs . realpathSync . native ( userPath ) ) ; if ( userPath && realPath && userPath . toLowerCase ( ) === realPath . toLowerCase ( ) && userPath !== realPath ) { vs . window . showWarningMessage ( `template` + `template` , ) ; break ; } } } if ( ! isRestart ) showUserPrompts ( logger , extContext , workspaceContext ) ; setCommandVisiblity ( true , workspaceContext ) ; vs . commands . executeCommand ( "s" , DART_PLATFORM_NAME , dartPlatformName ) ; function checkForPackages ( ) { if ( workspaceContext . shouldAvoidFetchingPackages ) return ; sdkCommands . fetchPackagesOrPrompt ( undefined , { alwaysPrompt : true } ) ; } if ( ! isRestart ) checkForPackages ( ) ; if ( workspaceContext . shouldLoadFlutterExtension ) { const flutterExtension = vs . extensions . getExtension ( flutterExtensionIdentifier ) ; if ( flutterExtension ) { logger . info ( `template` ) ; flutterExtension . activate ( ) ; } } const extensionEndTime = new Date ( ) ; if ( isRestart ) { analytics . logExtensionRestart ( extensionEndTime . getTime ( ) - extensionStartTime . getTime ( ) ) ; } else { analytics . logExtensionStartup ( extensionEndTime . getTime ( ) - extensionStartTime . getTime ( ) ) ; } context . subscriptions . push ( vs . workspace . onDidChangeWorkspaceFolders ( async ( f ) => { const newWorkspaceContext = await sdkUtils . scanWorkspace ( ) ; if ( newWorkspaceContext . hasOnlyDartProjects !== workspaceContext . hasOnlyDartProjects || newWorkspaceContext . hasAnyFlutterProjects !== workspaceContext . hasAnyFlutterProjects || newWorkspaceContext . hasProjectsInFuchsiaTree !== workspaceContext . hasProjectsInFuchsiaTree || newWorkspaceContext . isDartSdkRepo !== workspaceContext . isDartSdkRepo ) { util . reloadExtension ( ) ; return ; } dartPackagesProvider . refresh ( ) ; recalculateAnalysisRoots ( ) ; checkForPackages ( ) ; } ) ) ; return { ... new DartExtensionApi ( ) , [ internalApiSymbol ] : { analyzerCapabilities : analyzer . capabilities , cancelAllAnalysisRequests : ( ) => analyzer . cancelAllRequests ( ) , completionItemProvider , context : extContext , currentAnalysis : ( ) => analyzer . currentAnalysis , get cursorIsInTest ( ) { return cursorIsInTest ; } , daemonCapabilities : flutterDaemon ? flutterDaemon . capabilities : DaemonCapabilities . empty , dartCapabilities , debugCommands , debugProvider , envUtils , fileTracker : openFileTracker , flutterCapabilities , flutterOutlineTreeProvider , getLogHeader , initialAnalysis , logger , nextAnalysis , packagesTreeProvider : dartPackagesProvider , pubGlobal , renameProvider , safeSpawn , testTreeProvider , workspaceContext , } as InternalExtensionApi , } ; } function setupLog ( logFile : string | undefined , category ) { if ( logFile ) loggers . push ( captureLogs ( logger , logFile , getLogHeader ( ) , config . maxLogLineLength , [ category ] ) ) ; } function buildLogHeaders ( workspaceContext ? ) { clearLogHeader ( ) ; addToLogHeader ( ( ) => `template` ) ; addToLogHeader ( ( ) => `template` ) ; addToLogHeader ( ( ) => `template` ) ; addToLogHeader ( ( ) => { const ext = vs . extensions . getExtension ( flutterExtensionIdentifier ) ! ; return `template` ; } ) ; addToLogHeader ( ( ) => `template` ) ; addToLogHeader ( ( ) => `template` ) ; if ( workspaceContext ) { addToLogHeader ( ( ) => `template` ) ; addToLogHeader ( ( ) => `template` ) ; const sdks = workspaceContext . sdks ; addToLogHeader ( ( ) => `template` ) ; addToLogHeader ( ( ) => `template` ) ; } addToLogHeader ( ( ) => `template` ) ; addToLogHeader ( ( ) => `template` ) ; } function recalculateAnalysisRoots ( ) { analysisRoots = getDartWorkspaceFolders ( ) . map ( ( w ) => fsPath ( w . uri ) ) ; const excludeFolders : string [ ] = [ ] ; if ( isWin ) { const addExcludeIfRequired = ( folder : string | undefined ) => { if ( ! folder || ! path . isAbsolute ( folder ) ) return ; const containingRoot = analysisRoots . find ( ( root ) => isWithinPath ( folder , root ) ) ; if ( containingRoot ) { logger . info ( `template` ) ; excludeFolders . push ( folder ) ; } } ; addExcludeIfRequired ( process . env . PUB_CACHE ) ; addExcludeIfRequired ( process . env . APPDATA ) ; addExcludeIfRequired ( process . env . LOCALAPPDATA ) ; } getDartWorkspaceFolders ( ) . forEach ( ( f ) => { const excludedForWorkspace = config . for ( f . uri ) . analysisExcludedFolders ; const workspacePath = fsPath ( f . uri ) ; if ( excludedForWorkspace && isArray ( excludedForWorkspace ) ) { excludedForWorkspace . forEach ( ( folder ) => { if ( ! path . isAbsolute ( folder ) ) folder = path . join ( workspacePath , folder ) ; excludeFolders . push ( folder ) ; } ) ; } } ) ; analyzer . analysisSetAnalysisRoots ( { excluded : excludeFolders , included : analysisRoots , } ) ; } function handleConfigurationChange ( sdks ) { const newShowTodoSetting = config . showTodos ; const todoSettingChanged = showTodos !== newShowTodoSetting ; showTodos = newShowTodoSetting ; const newSettings = getSettingsThatRequireRestart ( ) ; const settingsChanged = previousSettings !== newSettings ; previousSettings = newSettings ; if ( todoSettingChanged ) { analyzer . analysisReanalyze ( ) ; } if ( settingsChanged ) { util . reloadExtension ( ) ; } } function getSettingsThatRequireRestart ( ) { return "s" + config . sdkPath + config . analyzerPath + config . analyzerDiagnosticsPort + config . analyzerObservatoryPort + config . analyzerInstrumentationLogFile + config . extensionLogFile + config . analyzerAdditionalArgs + config . flutterSdkPath + config . flutterSelectDeviceWhenConnected + config . closingLabels + config . analyzeAngularTemplates + config . analysisServerFolding + config . showTestCodeLens + config . previewHotReloadCoverageMarkers + config . previewBuildRunnerTasks + config . flutterOutline + config . triggerSignatureHelpAutomatically + config . flutterAdbConnectOnChromeOs ; } export async function deactivate ( isRestart = false ) < void > { setCommandVisiblity ( false ) ; vs . commands . executeCommand ( "s" , FLUTTER_SUPPORTS_ATTACH , false ) ; if ( ! isRestart ) { vs . commands . executeCommand ( "s" , HAS_LAST_DEBUG_CONFIG , false ) ; await analytics . logExtensionShutdown ( ) ; if ( loggers ) { await Promise . all ( loggers . map ( ( logger ) => logger . dispose ( ) ) ) ; loggers . length = 0 ; } } } function setCommandVisiblity ( enable , workspaceContext ? ) { vs . commands . executeCommand ( "s" , DART_PROJECT_LOADED , enable ) ; vs . commands . executeCommand ( "s" , FLUTTER_PROJECT_LOADED , enable && workspaceContext && workspaceContext . hasAnyFlutterProjects ) ; vs . commands . executeCommand ( "s" , FLUTTER_MOBILE_PROJECT_LOADED , enable && workspaceContext && workspaceContext . hasAnyFlutterMobileProjects ) ; vs . commands . executeCommand ( "s" , FLUTTER_WEB_PROJECT_LOADED , enable && workspaceContext && workspaceContext . hasAnyFlutterWebProjects ) ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O O $string$ O O O $string$ O O O $boolean$ O O O O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $complex$ O $any$ O $void$ O O O O O O O O O O O O O $string$ O $boolean$ O O O O O O $any$ O O O O O O $string$ O $boolean$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O $any[]$ O $boolean$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $boolean$ O $any$ O O O O O O $any$ O O O O O O $Config$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O O O $any$ O O O O O $void$ O $void$ O $string$ O $string$ O O O O O O $any$ O O O O O O $EnvUtils$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O $Config$ O $string[]$ O $U[]$ O O $string$ O O O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Analyzer$ O O $IFlutterDaemon$ O O $FlutterDeviceManager$ O O $DartCapabilities$ O $any$ O $DartCapabilities$ O O $FlutterCapabilities$ O $any$ O $FlutterCapabilities$ O O $string[]$ O O O O O O O O O $Analytics$ O O $boolean$ O O O O O O $string$ O O $Array$ O O $complex$ O O O O $PromiseConstructor$ O O O O O O O O O O O O $EmittingLogger$ O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $boolean$ O O O O O O $boolean$ O $void$ O $EmittingLogger$ O O $any$ O $any$ O $any$ O O O O O $boolean$ O O $void$ O O O $void$ O $string$ O O O $any$ O $LogCategory.General$ O O O $Context$ O $any$ O $Context$ O $any$ O O $any$ O $void$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $EmittingLogger$ O $void$ O O O O O $Promise<void>$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O $EmittingLogger$ O $void$ O $any$ O O O O O O $any$ O O O O $EmittingLogger$ O $void$ O O O O O O O O $boolean$ O $Config$ O $boolean$ O $string$ O $string$ O O O O $Date$ O O $DateConstructor$ O O O $any$ O $void$ O O O O $SdkUtils$ O O $any$ O $EmittingLogger$ O O O $WorkspaceContext$ O O $SdkUtils$ O $Promise<WorkspaceContext>$ O O O $any$ O $void$ O O O O $void$ O $WorkspaceContext$ O O $void$ O $Config$ O $string$ O $any$ O $LogCategory.Analyzer$ O O $void$ O $Config$ O $string$ O $any$ O $LogCategory.FlutterDaemon$ O O $void$ O $Config$ O $string$ O $any$ O $LogCategory.DevTools$ O O $Analytics$ O O $any$ O $EmittingLogger$ O $WorkspaceContext$ O O O O O $WorkspaceContext$ O $Sdks$ O $string$ O O $WorkspaceContext$ O $boolean$ O O $WorkspaceContext$ O $Sdks$ O $string$ O O O O $SdkUtils$ O $void$ O $any$ O $Analytics$ O $WorkspaceContext$ O O O O $DartWorkspaceContext$ O $WorkspaceContext$ O $any$ O O $DartSdks$ O $DartWorkspaceContext$ O $DartSdks$ O O O $DartSdks$ O $string$ O O $FlutterCapabilities$ O $string$ O $DartSdks$ O $string$ O $Analytics$ O $string$ O $DartSdks$ O $string$ O O O O $DartSdks$ O $string$ O O $DartCapabilities$ O $string$ O $DartSdks$ O $string$ O $Analytics$ O $string$ O $DartSdks$ O $string$ O $Promise<void>$ O $EmittingLogger$ O $DartWorkspaceContext$ O O $any$ O $any$ O $any$ O O $any$ O $DartWorkspaceContext$ O O O O O $Date$ O O $DateConstructor$ O O O O $any$ O $Config$ O $string$ O $any$ O $any$ O $DartSdks$ O $string$ O O O O O O O $Config$ O $string$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $Analyzer$ O O $any$ O $EmittingLogger$ O $any$ O $any$ O $DartSdks$ O $string$ O $string$ O O $any$ O O $any$ O $any$ O $any$ O $Analyzer$ O O O $any$ O $Analyzer$ O $any$ O O $ServerConnectedNotification$ O O O $Analytics$ O $string$ O $ServerConnectedNotification$ O $string$ O O $Date$ O O $DateConstructor$ O O O $Analytics$ O $void$ O $Date$ O $number$ O O O $Date$ O $number$ O O O O $any$ O $any$ O O O O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O $any$ O $Analyzer$ O $any$ O O $ServerStatusNotification$ O O O O O $ServerStatusNotification$ O $AnalysisStatus$ O O $ServerStatusNotification$ O $AnalysisStatus$ O $boolean$ O O $void$ O O O $any$ O $any$ O O O O O O O O O O O $Date$ O O $Promise<void>$ O $Promise<void>$ O O O O $any$ O $Analyzer$ O $any$ O O $ServerStatusNotification$ O O O O O $ServerStatusNotification$ O $AnalysisStatus$ O $ServerStatusNotification$ O $AnalysisStatus$ O $boolean$ O O $Date$ O $Date$ O O $DateConstructor$ O O O O O $ServerStatusNotification$ O $AnalysisStatus$ O O $ServerStatusNotification$ O $AnalysisStatus$ O $boolean$ O $Date$ O O O $Date$ O O $DateConstructor$ O O O $Analytics$ O $void$ O $Date$ O $number$ O O O $Date$ O $number$ O O O O $any$ O $any$ O O O O O O O O $DartHoverProvider$ O O $any$ O $EmittingLogger$ O $Analyzer$ O O O $DartFormattingEditProvider$ O O $any$ O $EmittingLogger$ O $Analyzer$ O $Context$ O O $any$ O $any$ O $any$ O $DartFormattingEditProvider$ O O O $DartCompletionItemProvider$ O O $any$ O $EmittingLogger$ O $Analyzer$ O O O $DartReferenceProvider$ O O $any$ O $Analyzer$ O O O $DartDocumentHighlightProvider$ O O $any$ O O O O $SourceCodeActionProvider$ O O $any$ O O O O $DartRenameProvider$ O O $any$ O $Analyzer$ O O O $DartImplementationProvider$ O O $any$ O $Analyzer$ O O O $any$ O $any$ O $any$ O O $complex$ O O O O $Config$ O $boolean$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O $complex$ O O O O $RankingCodeActionProvider$ O O $any$ O O O O $string[]$ O O O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $DartHoverProvider$ O O O $DartFormattingEditProvider$ O $void$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $DartCompletionItemProvider$ O O $string[]$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $DartReferenceProvider$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $DartReferenceProvider$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $DartDocumentHighlightProvider$ O O O $RankingCodeActionProvider$ O $void$ O O $any$ O $EmittingLogger$ O $any$ O $Analyzer$ O O O $RankingCodeActionProvider$ O $void$ O O $any$ O $EmittingLogger$ O $any$ O $Analyzer$ O O O $RankingCodeActionProvider$ O $void$ O O $any$ O $any$ O $Analyzer$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $DartRenameProvider$ O O O $DartFormattingEditProvider$ O $void$ O $complex$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $SourceCodeActionProvider$ O $SourceCodeActionProvider$ O $any$ O O O $RankingCodeActionProvider$ O $void$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $DartImplementationProvider$ O O O O O $Config$ O $boolean$ O O O $TestCodeLensProvider$ O O $any$ O $EmittingLogger$ O $Analyzer$ O O $any$ O $any$ O $any$ O $TestCodeLensProvider$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $TestCodeLensProvider$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $RankingCodeActionProvider$ O $RankingCodeActionProvider$ O $any$ O O O O O $Config$ O $boolean$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $DartSdks$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O $any$ O O O O $any$ O O $any$ O $boolean$ O $any$ O O $any$ O $boolean$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $string$ O O $any$ O O O O O O $AnalyzerStatusReporter$ O O $any$ O $EmittingLogger$ O $Analyzer$ O $DartWorkspaceContext$ O $Analytics$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $DartDiagnosticProvider$ O O $any$ O $Analyzer$ O $any$ O O O $any$ O $Analyzer$ O $any$ O O $ServerConnectedNotification$ O O O $any$ O $any$ O O O $void$ O O O O $boolean$ O O O O $void$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $string[]$ O $number$ O O O O $boolean$ O O $boolean$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $void$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $Analyzer$ O O O O O $DartWorkspaceContext$ O $boolean$ O $DartSdks$ O $string$ O O $IFlutterDaemon$ O O $any$ O $EmittingLogger$ O $any$ O $any$ O $DartSdks$ O $string$ O $string$ O O $DartSdks$ O $string$ O O $FlutterDeviceManager$ O O $any$ O $EmittingLogger$ O $IFlutterDaemon$ O $Config$ O $boolean$ O O $any$ O $any$ O $any$ O $FlutterDeviceManager$ O O $any$ O $any$ O $any$ O $IFlutterDaemon$ O O $void$ O $EmittingLogger$ O $any$ O $IFlutterDaemon$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $FlutterDeviceManager$ O $Promise<Device>$ O $FlutterDeviceManager$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $FlutterDeviceManager$ O $Promise<boolean>$ O $FlutterDeviceManager$ O O O O $any$ O $void$ O O O O O $PubGlobal$ O O $any$ O $EmittingLogger$ O $Context$ O $DartSdks$ O O O $DebugConfigProvider$ O O $any$ O $EmittingLogger$ O $DartSdks$ O $Analytics$ O $PubGlobal$ O $IFlutterDaemon$ O $FlutterDeviceManager$ O $DartCapabilities$ O $FlutterCapabilities$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $DebugConfigProvider$ O O O $any$ O $any$ O $any$ O $DebugConfigProvider$ O O O O $Config$ O $boolean$ O $any$ O $any$ O $any$ O O $any$ O $Analyzer$ O O O O O $Config$ O $boolean$ O O $any$ O $any$ O $any$ O O $any$ O $EmittingLogger$ O $Analyzer$ O O O $any$ O $any$ O $any$ O O $any$ O $EmittingLogger$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $Analyzer$ O $any$ O O $ServerConnectedNotification$ O O O $any$ O $any$ O O O O O $Analyzer$ O $AnalyzerCapabilities$ O $boolean$ O $Config$ O $boolean$ O O $any$ O $any$ O $any$ O O $any$ O $Analyzer$ O O O O O O $Analyzer$ O $AnalyzerCapabilities$ O $boolean$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $EmittingLogger$ O $Analyzer$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $EmittingLogger$ O $Analyzer$ O O O O O O O $Analyzer$ O $AnalyzerCapabilities$ O $boolean$ O $Config$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $Analyzer$ O O O O O O $Analyzer$ O $AnalyzerCapabilities$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O $any$ O $Analyzer$ O O O O $Config$ O $boolean$ O O O O O O O O O O O O O O O $DartDocumentSymbolProvider$ O O $any$ O $EmittingLogger$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $DartDocumentSymbolProvider$ O O O O O O $any$ O $any$ O $any$ O O O $IAmDisposable$ O $EmittingLogger$ O $Analyzer$ O $DartWorkspaceContext$ O O O O O $Analyzer$ O $AnalyzerCapabilities$ O $boolean$ O $Config$ O $boolean$ O O $Analyzer$ O $Promise<UnknownResponse>$ O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $void$ O $DartSdks$ O O O O O $AnalyzerCommands$ O O $any$ O $any$ O $Analyzer$ O O O $SdkCommands$ O O $any$ O $EmittingLogger$ O $any$ O $DartWorkspaceContext$ O $SdkUtils$ O $PubGlobal$ O $FlutterCapabilities$ O $FlutterDeviceManager$ O O O $DebugCommands$ O O $any$ O $EmittingLogger$ O $Context$ O $DartWorkspaceContext$ O $Analytics$ O $PubGlobal$ O O O O $DartWorkspaceContext$ O $boolean$ O O $void$ O $any$ O $DebugCommands$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $FlutterCapabilities$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $EmittingLogger$ O $any$ O $Analyzer$ O O O $any$ O $any$ O $any$ O O $any$ O $EmittingLogger$ O $any$ O $Analyzer$ O O O $any$ O $any$ O $any$ O O $any$ O $EmittingLogger$ O $Analyzer$ O O O $any$ O $any$ O $any$ O O $any$ O $Analyzer$ O O O $any$ O $any$ O $any$ O O $any$ O $EmittingLogger$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $EmittingLogger$ O $DartSdks$ O O O $any$ O $any$ O $any$ O O $any$ O $EmittingLogger$ O O O O $DartPackagesProvider$ O O $any$ O $EmittingLogger$ O O O $any$ O $any$ O $any$ O $any$ O O O O $DartPackagesProvider$ O $DartPackagesProvider$ O O O $any$ O $any$ O $any$ O $DartPackagesProvider$ O $any$ O O O O $TestResultsProvider$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $TestResultsProvider$ O $TestResultsProvider$ O O O $any$ O $any$ O $any$ O $TestResultsProvider$ O $any$ O $TestResultsProvider$ O $any$ O O $any$ O O O O O $Config$ O $boolean$ O $any$ O $any$ O $any$ O O O O O $TestResultsProvider$ O $any$ O O $any$ O O O O O $Config$ O $boolean$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O $TestResultsProvider$ O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $undefined$ O O O O O O O O $FlutterOutlineProvider$ O $any$ O O O O O $Config$ O $boolean$ O O $FlutterOutlineProvider$ O O $any$ O $Analyzer$ O O O $any$ O $any$ O $any$ O $any$ O O O O $FlutterOutlineProvider$ O $FlutterOutlineProvider$ O $boolean$ O O O O O $any$ O $any$ O O $any$ O O O $FlutterOutlineProvider$ O O $Promise<void>$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $FlutterWidgetItem$ O $FlutterOutlineProvider$ O O $FlutterWidgetItem$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $FlutterWidgetItem$ O $any$ O $any$ O $any$ O $any$ O $FlutterWidgetItem$ O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $FlutterOutlineProvider$ O O O $FlutterOutlineCommands$ O O $any$ O $any$ O $any$ O O O O O $DartWorkspaceContext$ O $boolean$ O $Config$ O $boolean$ O O $any$ O $any$ O $any$ O O $any$ O $EmittingLogger$ O $DebugCommands$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O O O O O $any$ O O $EmittingLogger$ O $void$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O $string$ O $string$ O $any$ O $any$ O O O O $string$ O $string$ O $any$ O $any$ O $any$ O $string$ O O O O O $string$ O $string$ O $string$ O $string$ O O O $string$ O $string$ O O O $string$ O $string$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $boolean$ O $Promise<void>$ O $EmittingLogger$ O $Context$ O $DartWorkspaceContext$ O O $void$ O O O $DartWorkspaceContext$ O O $any$ O $any$ O $any$ O O O O O O O O O $void$ O O O O O $DartWorkspaceContext$ O $boolean$ O O O $SdkCommands$ O $Promise<void>$ O $undefined$ O O $true$ O O O O O O O O O $boolean$ O $void$ O O O O O $DartWorkspaceContext$ O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $EmittingLogger$ O $void$ O O O O $any$ O $any$ O O O O O O $Date$ O O $DateConstructor$ O O O O O $boolean$ O O $Analytics$ O $void$ O $Date$ O $number$ O O O $Date$ O $number$ O O O O O O O $Analytics$ O $void$ O $Date$ O $number$ O O O $Date$ O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $WorkspaceContext$ O O $SdkUtils$ O $Promise<WorkspaceContext>$ O O O O O $WorkspaceContext$ O $boolean$ O $DartWorkspaceContext$ O $boolean$ O $WorkspaceContext$ O $boolean$ O $DartWorkspaceContext$ O $boolean$ O $WorkspaceContext$ O $boolean$ O $DartWorkspaceContext$ O $boolean$ O $WorkspaceContext$ O $boolean$ O $DartWorkspaceContext$ O $boolean$ O O $any$ O $Promise<void>$ O O O O O O $DartPackagesProvider$ O $void$ O O O $void$ O O O $void$ O O O O O O O O O O O $any$ O O O O O O O O $AnalyzerCapabilities$ O $Analyzer$ O $AnalyzerCapabilities$ O $void$ O O O O $Analyzer$ O $void$ O O O $DartCompletionItemProvider$ O $Context$ O $Context$ O $Promise<void>$ O O O O $Analyzer$ O $Promise<void>$ O O $boolean$ O O O O $boolean$ O O O $DaemonCapabilities$ O $IFlutterDaemon$ O $IFlutterDaemon$ O $DaemonCapabilities$ O $any$ O $DaemonCapabilities$ O $DartCapabilities$ O $DebugCommands$ O $DebugConfigProvider$ O $EnvUtils$ O O O O O $FlutterCapabilities$ O $FlutterOutlineProvider$ O $string$ O $Promise<void>$ O $EmittingLogger$ O $Promise<void>$ O $DartPackagesProvider$ O $DartPackagesProvider$ O $PubGlobal$ O $DartRenameProvider$ O $any$ O $TestResultsProvider$ O $DartWorkspaceContext$ O O O $any$ O O O O O $void$ O $string$ O O O O O $LogCategory$ O O O O $string$ O $complex$ O $number$ O $complex$ O $EmittingLogger$ O $string$ O $string$ O O O $Config$ O $number$ O O $LogCategory$ O O O O O O $void$ O $WorkspaceContext$ $WorkspaceContext$ O O $void$ O O O $void$ O O O O O O O $void$ O O O O O O O $void$ O O O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $void$ O O O O O O O $void$ O O O O O O O O O $WorkspaceContext$ O O $void$ O O O O O O O $void$ O O O O O O O O $Sdks$ O $WorkspaceContext$ O $Sdks$ O $void$ O O O O O O O $void$ O O O O O O O O $void$ O O O O O O O $void$ O O O O O O O O O $void$ O O O $string[]$ O $any[]$ O O O $U[]$ O O $any$ O O $string$ O $any$ O $any$ O O O O $string[]$ O O O O O O O O O O $boolean$ O O O $void$ O O $string$ O O O O O O O O O O $string$ O O $any$ O $any$ O $string$ O O O O O $string$ O $string[]$ O $complex$ O O $string$ O O $boolean$ O $string$ O $string$ O O O O O $string$ O O $EmittingLogger$ O $void$ O O O O $string[]$ O $number$ O $string$ O O O O O $void$ O $any$ O $any$ O $any$ O O $void$ O $any$ O $any$ O $any$ O O $void$ O $any$ O $any$ O $any$ O O O $any[]$ O O O $void$ O O $any$ O O O O $string[]$ O $Config$ O $ResourceConfig$ O $any$ O $any$ O O $string[]$ O O $string$ O $string$ O $any$ O $any$ O O O O $string[]$ O $any$ O $string[]$ O O O $string[]$ O $void$ O O $string$ O O O O O O $any$ O $any$ O $string$ O O $string$ O $any$ O $any$ O $string$ O $string$ O O $string[]$ O $number$ O $string$ O O O O O O O O O $Analyzer$ O $Promise<UnknownResponse>$ O O $string[]$ O $string[]$ O $string[]$ O $string[]$ O O O O O O $void$ O $Sdks$ O O O $boolean$ O $Config$ O $boolean$ O O $boolean$ O $boolean$ O $boolean$ O $boolean$ O $boolean$ O O $string$ O $string$ O O O O $boolean$ O $string$ O $string$ O $string$ O $string$ O O O $boolean$ O O $Analyzer$ O $Promise<UnknownResponse>$ O O O O O O $boolean$ O O $any$ O $Promise<void>$ O O O O O O $string$ O O O O O O $Config$ O $string$ O $Config$ O $string$ O $Config$ O $number$ O $Config$ O $number$ O $Config$ O $string$ O $Config$ O $string$ O $Config$ O $string[]$ O $Config$ O $string$ O $Config$ O $boolean$ O $Config$ O $boolean$ O $Config$ O $boolean$ O $Config$ O $boolean$ O $Config$ O $boolean$ O $Config$ O $boolean$ O $Config$ O $boolean$ O $Config$ O $boolean$ O $Config$ O $boolean$ O $Config$ O $boolean$ O O O O O $Promise$ O $boolean$ O O O O O O O $void$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $boolean$ O O $any$ O $any$ O $any$ O O O O O O O O O $Analytics$ O $PromiseLike<void>$ O O O O O $complex$ O O O $PromiseConstructor$ O O O $complex$ O $U[]$ O O $complex$ O O $complex$ O $complex$ O O O O O $complex$ O $number$ O O O O O O O $void$ O $boolean$ O $WorkspaceContext$ $WorkspaceContext$ O O $any$ O $any$ O $any$ O O O O O $boolean$ O O $any$ O $any$ O $any$ O O O O O $boolean$ O $WorkspaceContext$ O $WorkspaceContext$ O $boolean$ O O $any$ O $any$ O $any$ O O O O O $boolean$ O $WorkspaceContext$ O $WorkspaceContext$ O $boolean$ O O $any$ O $any$ O $any$ O O O O O $boolean$ O $WorkspaceContext$ O $WorkspaceContext$ O $boolean$ O O O
import * as vs from "s" ; import { isWin , TRACK_WIDGET_CREATION_ENABLED } from "s" ; import { FlutterService , FlutterServiceExtension } from "s" ; import { SERVICE_CONTEXT_PREFIX , SERVICE_EXTENSION_CONTEXT_PREFIX } from "s" ; import { DebuggerType } from "s" ; export const IS_INSPECTING_WIDGET_CONTEXT = "s" ; const keyTimeDilation = "s" ; const keyEnabled = "s" ; const keyValue = "s" ; const toggleExtensionStateKeys : { [ key ] : string } = { [ FlutterServiceExtension . PlatformOverride ] : keyValue , [ FlutterServiceExtension . DebugBanner ] : keyEnabled , [ FlutterServiceExtension . CheckElevations ] : keyEnabled , [ FlutterServiceExtension . DebugPaint ] : keyEnabled , [ FlutterServiceExtension . PaintBaselines ] : keyEnabled , [ FlutterServiceExtension . InspectorSelectMode ] : keyEnabled , [ FlutterServiceExtension . RepaintRainbow ] : keyEnabled , [ FlutterServiceExtension . PerformanceOverlay ] : keyEnabled , [ FlutterServiceExtension . SlowAnimations ] : keyTimeDilation , } ; export const timeDilationNormal = 0 ; export const timeDilationSlow = 0 ; const defaultToggleExtensionState : { [ key ] : any } = { [ FlutterServiceExtension . PlatformOverride ] : null , [ FlutterServiceExtension . DebugBanner ] : true , [ FlutterServiceExtension . CheckElevations ] : false , [ FlutterServiceExtension . DebugPaint ] : false , [ FlutterServiceExtension . PaintBaselines ] : false , [ FlutterServiceExtension . InspectorSelectMode ] : false , [ FlutterServiceExtension . RepaintRainbow ] : false , [ FlutterServiceExtension . PerformanceOverlay ] : false , [ FlutterServiceExtension . SlowAnimations ] : timeDilationNormal , } ; export interface FlutterServiceExtensionArgs { type : FlutterServiceExtension ; params : any ; } export class FlutterVmServiceExtensions { private registeredServices : { [ x in FlutterService ] ? : string } = { } ; private loadedServiceExtensions : FlutterServiceExtension [ ] = [ ] ; private currentExtensionState = Object . assign ( { } , defaultToggleExtensionState ) ; private sendValueToVM : ( extension ) => void ; constructor ( sendRequest : ( extension , args ) => void ) { this . sendValueToVM = ( extension ) => { if ( this . loadedServiceExtensions . indexOf ( extension ) !== - 0 && toggleExtensionStateKeys [ extension ] !== undefined ) { const params = { [ toggleExtensionStateKeys [ extension ] ] : this . currentExtensionState [ extension ] } ; const args = { type : extension , params } ; sendRequest ( extension , args ) ; this . syncInspectingWidgetContext ( extension ) ; } } ; } public handleDebugEvent ( e : vs . DebugSessionCustomEvent ) { if ( e . event === "s" ) { this . handleServiceExtensionLoaded ( e . body . id ) ; if ( e . body . id === "s" ) { e . session . customRequest ( "s" ) ; } else if ( e . body . id === FlutterServiceExtension . PlatformOverride ) { e . session . customRequest ( "s" ) ; } else if ( e . body . id === FlutterServiceExtension . InspectorSetPubRootDirectories ) { const debuggerType = e . session . configuration . debuggerType ; if ( debuggerType !== DebuggerType . FlutterWeb ) { e . session . customRequest ( "s" , { params : { 0 : this . formatPathForPubRootDirectories ( e . session . configuration . cwd ) , 0 : e . session . configuration . cwd , isolateId : e . body . isolateId , } , type : "s" , } , ) ; } } } else if ( e . event === "s" ) { this . handleServiceRegistered ( e . body . service , e . body . method ) ; } else if ( e . event === "s" ) { for ( const extension in FlutterServiceExtension ) this . sendValueToVM ( extension as FlutterServiceExtension ) ; } else if ( e . event === "s" ) { vs . commands . executeCommand ( "s" , TRACK_WIDGET_CREATION_ENABLED , e . body . isWidgetCreationTracked ) ; } else if ( e . event === "s" ) { this . currentExtensionState [ FlutterServiceExtension . PlatformOverride ] = e . body . platform ; } else if ( e . event === "s" ) { this . handleRemoteValueUpdate ( e . body . extension , e . body . value ) ; } } private formatPathForPubRootDirectories ( path : string | undefined ) : string | undefined { return isWin ? path && `template` : path ; } public toggle ( id , 0 = true , 0 = false ) { this . currentExtensionState [ id ] = this . currentExtensionState [ id ] !== 0 ? 0 : 0 ; this . sendValueToVM ( id ) ; } private syncInspectingWidgetContext ( id ) { vs . commands . executeCommand ( "s" , IS_INSPECTING_WIDGET_CONTEXT , this . currentExtensionState [ FlutterServiceExtension . InspectorSelectMode ] ) ; } private handleRemoteValueUpdate ( id , value ) { if ( this . currentExtensionState [ id ] === undefined ) { return ; } if ( typeof value === "s" ) { try { value = JSON . parse ( value ) ; } catch { } } this . currentExtensionState [ id ] = value ; this . syncInspectingWidgetContext ( id ) ; } public resetToDefaults ( ) { this . currentExtensionState = Object . assign ( { } , defaultToggleExtensionState ) ; } private handleServiceRegistered ( service , method ) { this . registeredServices [ service ] = method ; vs . commands . executeCommand ( "s" , `template` , true ) ; } private handleServiceExtensionLoaded ( id ) { this . loadedServiceExtensions . push ( id ) ; vs . commands . executeCommand ( "s" , `template` , true ) ; } public markAllServicesUnloaded ( ) { for ( const id of Object . keys ( this . registeredServices ) ) { vs . commands . executeCommand ( "s" , `template` , undefined ) ; } this . registeredServices = { } ; for ( const id of this . loadedServiceExtensions ) { vs . commands . executeCommand ( "s" , `template` , undefined ) ; } this . loadedServiceExtensions . length = 0 ; vs . commands . executeCommand ( "s" , TRACK_WIDGET_CREATION_ENABLED , false ) ; } public serviceIsRegistered ( service ) { return ! ! this . registeredServices [ service ] ; } public getServiceMethodName ( service ) : string | undefined { return this . registeredServices [ service ] ; } public serviceExtensionIsLoaded ( id ) { return ! ! this . loadedServiceExtensions . find ( ( loadedID ) => loadedID === id ) ; } }	O O O $any$ O O O O O $boolean$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O $complex$ O O O $string$ O O O O O O O $any$ O $FlutterServiceExtension.PlatformOverride$ O O O O O $any$ O $FlutterServiceExtension.DebugBanner$ O O O O O $any$ O $FlutterServiceExtension.CheckElevations$ O O O O O $any$ O $FlutterServiceExtension.DebugPaint$ O O O O O $any$ O $FlutterServiceExtension.PaintBaselines$ O O O O O $any$ O $FlutterServiceExtension.InspectorSelectMode$ O O O O O $any$ O $FlutterServiceExtension.RepaintRainbow$ O O O O O $any$ O $FlutterServiceExtension.PerformanceOverlay$ O O O O O $any$ O $FlutterServiceExtension.SlowAnimations$ O O O O O O O O O O O O O O O O O O O $complex$ O O O $string$ O O O O O O O $any$ O $FlutterServiceExtension.PlatformOverride$ O O O O O $any$ O $FlutterServiceExtension.DebugBanner$ O O O O O $any$ O $FlutterServiceExtension.CheckElevations$ O O O O O $any$ O $FlutterServiceExtension.DebugPaint$ O O O O O $any$ O $FlutterServiceExtension.PaintBaselines$ O O O O O $any$ O $FlutterServiceExtension.InspectorSelectMode$ O O O O O $any$ O $FlutterServiceExtension.RepaintRainbow$ O O O O O $any$ O $FlutterServiceExtension.PerformanceOverlay$ O O O O O $any$ O $FlutterServiceExtension.SlowAnimations$ O O O O O O O O $any$ O $FlutterServiceExtension$ O $any$ O $any$ O O O O O O $any$ O O $complex$ O O O $any$ O $any$ O O O O O O O O O O $FlutterServiceExtension[]$ O $any$ O O O O O O O $complex$ O $ObjectConstructor$ O O O O O O $complex$ O O O $void$ O O $FlutterServiceExtension$ O O O O O O $void$ O O $FlutterServiceExtension$ O $FlutterServiceExtensionArgs$ O O O O O O O $void$ O O $FlutterServiceExtension$ O O O O O O O $FlutterServiceExtension[]$ O $number$ O $FlutterServiceExtension$ O O O O O $complex$ O $FlutterServiceExtension$ O O $undefined$ O O O $complex$ O O O $complex$ O $FlutterServiceExtension$ O O O O O $complex$ O $FlutterServiceExtension$ O O O O $complex$ O O $FlutterServiceExtension$ O $FlutterServiceExtension$ O $complex$ O O $void$ O $FlutterServiceExtension$ O $complex$ O O O O $void$ O $FlutterServiceExtension$ O O O O O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $FlutterServiceExtension.PlatformOverride$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $FlutterServiceExtension.InspectorSetPubRootDirectories$ O O O $DebuggerType$ O $any$ O $any$ O $any$ O $any$ O O O $DebuggerType$ O $any$ O $DebuggerType.FlutterWeb$ O O $any$ O $any$ O $any$ O O O O O O O $string$ O O O $string$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $string$ O $any$ O O O $void$ O $string$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $complex$ O $any$ O $FlutterServiceExtension.PlatformOverride$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O $string$ O O O O O O O O O O O $boolean$ O $string$ O O O $string$ O O O O O $FlutterServiceExtension$ O $any$ O O O $any$ O O O O O O $complex$ O $FlutterServiceExtension$ O O O O $complex$ O $FlutterServiceExtension$ O O $any$ O $any$ O $any$ O O O $void$ O $FlutterServiceExtension$ O O O O $void$ O $string$ O O $any$ O $any$ O $any$ O O O O O O O $complex$ O $any$ O $FlutterServiceExtension.InspectorSelectMode$ O O O O O $void$ O $string$ O $any$ O O O O O O $complex$ O $string$ O O $undefined$ O O O O O O O O $any$ O O O O O O $any$ O $JSON$ O $any$ O $string$ O O O O O O O O O $complex$ O $string$ O O $any$ O O O $void$ O $string$ O O O O $void$ O O O O O $complex$ O $ObjectConstructor$ O O O O O O $complex$ O O O O $void$ O $FlutterService$ O $string$ O O O O $complex$ O $FlutterService$ O O $string$ O $any$ O $any$ O $any$ O O O O O O O O O O $void$ O $FlutterServiceExtension$ O O O O $FlutterServiceExtension[]$ O $number$ O $FlutterServiceExtension$ O O $any$ O $any$ O $any$ O O O O O O O O O O $void$ O O O O O O $string$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O O $any$ O $any$ O $any$ O O O O O $undefined$ O O O O O $complex$ O O O O O O O $FlutterServiceExtension$ O O O $FlutterServiceExtension[]$ O O $any$ O $any$ O $any$ O O O O O $undefined$ O O O O O $FlutterServiceExtension[]$ O $number$ O O O $any$ O $any$ O $any$ O O O O O O O O O O $boolean$ O $FlutterService$ O O O O O O O $complex$ O $FlutterService$ O O O O $string$ O $FlutterService$ O O O O O O O O O $complex$ O $FlutterService$ O O O O $boolean$ O $FlutterServiceExtension$ O O O O O O O $FlutterServiceExtension[]$ O $complex$ O O $FlutterServiceExtension$ O O $FlutterServiceExtension$ O $FlutterServiceExtension$ O O O O
import * as vs from "s" ; import { PromiseCompleter } from "s" ; export class DartDebugSessionInformation { public observatoryUri ? : string ; public vmServiceUri ? : string ; public readonly launchProgressPromise = new PromiseCompleter < void > ( ) ; public launchProgressReporter ? : vs . Progress < { message ? : string ; increment ? : number ; } > ; public progressPromise ? : PromiseCompleter < void > ; public progressReporter ? : vs . Progress < { message ? : string ; increment ? : number ; } > ; public progressID ? : string ; public readonly sessionStart : Date = new Date ( ) ; constructor ( public readonly session : vs . DebugSession , public readonly debuggerType ) { } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O O $string$ O O O O O $string$ O O O O O O $PromiseCompleter<void>$ O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $string$ O O O O $number$ O O O O O O O O $PromiseCompleter<void>$ O O $any$ O O O O O $any$ O O $any$ O $any$ O O $string$ O O O O $number$ O O O O O O O O $string$ O O O O O O $Date$ O $DateConstructor$ O O $DateConstructor$ O O O O O O O $any$ O $any$ O $any$ O O O $string$ O O O O
import * as fs from "s" ; import * as os from "s" ; import * as path from "s" ; import * as vs from "s" ; import { window , workspace } from "s" ; import { CHROME_OS_DEVTOOLS_PORT , isChromeOS , pubPath } from "s" ; import { FlutterService , LogCategory } from "s" ; import { Logger , Sdks } from "s" ; import { CategoryLogger } from "s" ; import { UnknownNotification } from "s" ; import { getRandomInt } from "s" ; import { waitFor } from "s" ; import { isRunningLocally } from "s" ; import { Analytics } from "s" ; import { DebugCommands , debugSessions } from "s" ; import { config } from "s" ; import { PubGlobal } from "s" ; import { StdIOService } from "s" ; import { DartDebugSessionInformation } from "s" ; import { envUtils } from "s" ; const devtools = "s" ; const devtoolsPackageName = "s" ; let portToBind : number | undefined ; export class DevToolsManager implements vs . Disposable { private readonly disposables : vs . Disposable [ ] = [ ] ; private readonly devToolsStatusBarItem = vs . window . createStatusBarItem ( vs . StatusBarAlignment . Right , 0 ) ; private devtoolsUrl : Thenable < string > | undefined ; constructor ( private logger , private sdks , private debugCommands , private analytics , private pubGlobal ) { this . disposables . push ( this . devToolsStatusBarItem ) ; } public async spawnForSession ( session : DartDebugSessionInformation & { vmServiceUri : string } ) < { url : string , dispose : ( ) => void } | undefined > { this . analytics . logDebuggerOpenDevTools ( ) ; const isAvailable = await this . pubGlobal . promptToInstallIfRequired ( devtoolsPackageName , devtools , undefined , "s" , true ) ; if ( ! isAvailable ) { return undefined ; } if ( ! this . devtoolsUrl ) { this . devtoolsUrl = vs . window . withProgress ( { location : vs . ProgressLocation . Notification , title : "s" , } , async ( _ ) => this . startServer ( ) ) ; } try { const url = await this . devtoolsUrl ; await vs . window . withProgress ( { location : vs . ProgressLocation . Notification , title : "s" , } , async ( _ ) => { const queryParams : { [ key ] : string | undefined } = { hide : "s" , ide : "s" , theme : config . useDevToolsDarkTheme ? "s" : undefined , } ; const canLaunchDevToolsThroughService = isRunningLocally && ! process . env . DART_CODE_IS_TEST_RUN && await waitFor ( ( ) => this . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . LaunchDevTools ) , 0 ) ; if ( canLaunchDevToolsThroughService ) { try { await session . session . customRequest ( "s" , { params : { queryParams } , type : this . debugCommands . flutterExtensions . getServiceMethodName ( FlutterService . LaunchDevTools ) , } , ) ; return true ; } catch ( e ) { this . logger . error ( `template` ) ; vs . window . showWarningMessage ( `template` , "s" ) . then ( ( res ) => { if ( res ) { const fileName = `template` ; const tempPath = path . join ( os . tmpdir ( ) , fileName ) ; fs . writeFileSync ( tempPath , e . message || e ) ; workspace . openTextDocument ( tempPath ) . then ( ( document ) => { window . showTextDocument ( document ) ; } ) ; } } ) ; } } const paramsString = Object . keys ( queryParams ) . filter ( ( key ) => queryParams [ key ] !== undefined ) . map ( ( key ) => `template` ) . join ( "s" ) ; const fullUrl = `template` ; await envUtils . openInBrowser ( fullUrl ) ; } ) ; this . devToolsStatusBarItem . text = "s" ; this . devToolsStatusBarItem . tooltip = `template` ; this . devToolsStatusBarItem . command = "s" ; this . devToolsStatusBarItem . show ( ) ; return { url , dispose : ( ) => this . dispose ( ) } ; } catch ( e ) { this . devToolsStatusBarItem . hide ( ) ; this . logger . error ( e ) ; vs . window . showErrorMessage ( `template` ) ; } } private startServer ( ) < string > { return new Promise < string > ( ( resolve , reject ) => { const service = new DevToolsService ( this . logger , this . sdks ) ; this . disposables . push ( service ) ; service . registerForServerStarted ( ( n ) => { this . disposables . push ( this . debugCommands . onDebugSessionVmServiceAvailable ( ( session ) => service . vmRegister ( { uri : session . vmServiceUri ! } ) , ) ) ; for ( const session of debugSessions ) { if ( session . vmServiceUri ) service . vmRegister ( { uri : session . vmServiceUri } ) ; } portToBind = n . port ; resolve ( `template` ) ; } ) ; service . process ! . on ( "s" , ( code ) => { this . devtoolsUrl = undefined ; this . devToolsStatusBarItem . hide ( ) ; if ( code && code !== 0 ) { portToBind = 0 ; const errorMessage = `template` ; this . logger . error ( errorMessage ) ; reject ( errorMessage ) ; } } ) ; } ) ; } public dispose ( ) { this . disposables . forEach ( ( d ) => d . dispose ( ) ) ; } } class DevToolsService extends StdIOService < UnknownNotification > { constructor ( logger , sdks ) { super ( new CategoryLogger ( logger , LogCategory . DevTools ) , config . maxLogLineLength ) ; const pubBinPath = path . join ( sdks . dart ! , pubPath ) ; portToBind = config . devToolsPort || portToBind || ( isChromeOS && config . useKnownChromeOSPorts ? CHROME_OS_DEVTOOLS_PORT : 0 ) ; const args = [ "s" , "s" , "s" , "s" , "s" , portToBind . toString ( ) ] ; this . registerForServerStarted ( ( n ) => this . additionalPidsToTerminate . push ( n . pid ) ) ; this . createProcess ( undefined , pubBinPath , args ) ; } protected shouldHandleMessage ( message ) { return message . startsWith ( "s" ) && message . endsWith ( "s" ) ; } protected isNotification ( msg ) { return msg . event || msg . method === "s" ; } protected handleNotification ( evt ) { switch ( ( evt as any ) . method || evt . event ) { case "s" : this . notify ( this . serverStartedSubscriptions , evt . params as ServerStartedNotification ) ; break ; } } private serverStartedSubscriptions : Array < ( notification ) => void > = [ ] ; public registerForServerStarted ( subscriber : ( notification ) => void ) : vs . Disposable { return this . subscribe ( this . serverStartedSubscriptions , subscriber ) ; } public vmRegister ( request : { uri : string } ) < any > { return this . sendRequest ( "s" , request ) ; } } export interface ServerStartedNotification { host : string ; port : number ; pid : number ; }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O $any$ O $string$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $number$ O O O O O O $Promise<T>$ O O O O O O $boolean$ O O O O O O $any$ O O O O O O $any$ O $DartDebugSessionInformation[]$ O O O O O O $Config$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $EnvUtils$ O O O O O O O O O O O O O O O $number$ O O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $Logger$ O O $Sdks$ O O $DebugCommands$ O O $Analytics$ O O $PubGlobal$ O O O O $any[]$ O $number$ O O O $any$ O O O O O $Promise$ O $complex$ O $any$ O O $string$ O O O O O O $string$ O O O $void$ O O O O O O O O O O O O $Analytics$ O $void$ O O O O $boolean$ O O O O $PubGlobal$ O $Promise<boolean>$ O O O O O $undefined$ O O O O O O O O O $boolean$ O O O $undefined$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O $any$ O O O O $Promise<string>$ O O O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O $any$ O O O O $complex$ O O O $string$ O O O O O O O O $string$ O O O $string$ O O O $string$ O $Config$ O $boolean$ O O O $undefined$ O O O O $boolean$ O $boolean$ O O $any$ O $any$ O $any$ O O $Promise<T>$ O O O O O O $DebugCommands$ O $FlutterVmServiceExtensions$ O $boolean$ O $any$ O $FlutterService.LaunchDevTools$ O O O O O O O $boolean$ O O O O O $complex$ O $any$ O $any$ O O O O $complex$ O O $complex$ O O $string$ O O O $DebugCommands$ O $FlutterVmServiceExtensions$ O $string$ O $any$ O $FlutterService.LaunchDevTools$ O O O O O O O O O O O O $any$ O O O O $Logger$ O $void$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O O $any$ O O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $string$ O $ObjectConstructor$ O $complex$ O $complex$ O O $complex$ O O $string$ O O $complex$ O $string$ O O $undefined$ O O $U[]$ O O $string$ O O O O O $string$ O O O O O $string$ O O O O $EnvUtils$ O $Promise<boolean>$ O $string$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O O $Logger$ O $void$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $Promise$ O O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O $DevToolsService$ O O $any$ O O O $Logger$ O O O $Sdks$ O O O O $any[]$ O $number$ O $DevToolsService$ O O $DevToolsService$ O $any$ O O $ServerStartedNotification$ O O O O O $any[]$ O $number$ O O O $DebugCommands$ O $any$ O O $any$ O O $DevToolsService$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O $DartDebugSessionInformation$ O $DartDebugSessionInformation[]$ O O O O $DartDebugSessionInformation$ O $string$ O $DevToolsService$ O $any$ O O $string$ O $DartDebugSessionInformation$ O $string$ O O O O $number$ O $ServerStartedNotification$ O $number$ O $void$ O O O O O O O $DevToolsService$ O $any$ O O $any$ O O O O $any$ O O O O O $any$ O $undefined$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $number$ O O O O $string$ O O O O O $Logger$ O $void$ O $string$ O O $void$ O $string$ O O O O O O O O O O O $any$ O O O O O $any[]$ O $void$ O O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $Logger$ O $Sdks$ O O O O O $any$ O $Logger$ O $any$ O $LogCategory.DevTools$ O O $Config$ O $number$ O O O $any$ O $any$ O $any$ O $Sdks$ O $string$ O O $string$ O O $number$ O $Config$ O $number$ O $number$ O O $any$ O $Config$ O $boolean$ O O O O O O O $string[]$ O O O O O O O O O O O O $number$ O $string$ O O O O O O $any$ O O $ServerStartedNotification$ O O O O $number[]$ O $number$ O $ServerStartedNotification$ O $number$ O O O O O $void$ O $undefined$ O $any$ O $string[]$ O O O O $boolean$ O $string$ O O O $string$ O $boolean$ O O O O $string$ O $boolean$ O O O O O O $boolean$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $void$ O $UnknownNotification$ O O O O O $UnknownNotification$ O O O O $any$ O $UnknownNotification$ O $string$ O O O O O O O $Promise<void>$ O O O $void)[]$ O $UnknownNotification$ O $any$ O $any$ O O O O O O O $void)[]$ O $ArrayConstructor$ O O $ServerStartedNotification$ O O O O O O O O O $any$ O $void$ O O $ServerStartedNotification$ O O O O O $any$ O $any$ O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $Thenable$ O $complex$ O O $string$ O O O O O O O O O O O $Promise<TResp>$ O O O $complex$ O O O O O O $any$ O $string$ O O O $number$ O O O $number$ O O O O
import * as fs from "s" ; import * as path from "s" ; import * as vs from "s" ; import { CoverageData } from "s" ; import { isInDebugSessionThatProbablySupportsHotReloadContext } from "s" ; import { FlutterServiceExtension , LogSeverity } from "s" ; import { Logger , LogMessage } from "s" ; import { PromiseCompleter } from "s" ; import { findProjectFolders } from "s" ; import { showDevToolsNotificationIfAppropriate } from "s" ; import { fsPath , getDartWorkspaceFolders } from "s" ; import { Context } from "s" ; import { WorkspaceContext } from "s" ; import { Analytics } from "s" ; import { FlutterServiceExtensionArgs , FlutterVmServiceExtensions , timeDilationNormal , timeDilationSlow } from "s" ; import { DebuggerType } from "s" ; import { PubGlobal } from "s" ; import { DevToolsManager } from "s" ; import { DartDebugSessionInformation } from "s" ; import { envUtils } from "s" ; export const debugSessions : DartDebugSessionInformation [ ] = [ ] ; let pendingCustomEvents : vs . DebugSessionCustomEvent [ ] = [ ] ; export class LastDebugSession { public static workspaceFolder ? : vs . WorkspaceFolder ; public static debugConfig ? : vs . DebugConfiguration ; } export class DebugCommands { private debugMetrics = vs . window . createStatusBarItem ( vs . StatusBarAlignment . Right , 0 ) ; private onWillHotReloadEmitter = new vs . EventEmitter < void > ( ) ; public readonly onWillHotReload = this . onWillHotReloadEmitter . event ; private onWillHotRestartEmitter = new vs . EventEmitter < void > ( ) ; public readonly onWillHotRestart = this . onWillHotRestartEmitter . event ; private onReceiveCoverageEmitter = new vs . EventEmitter < CoverageData [ ] > ( ) ; public readonly onReceiveCoverage = this . onReceiveCoverageEmitter . event ; private onFirstFrameEmitter = new vs . EventEmitter < void > ( ) ; public readonly onFirstFrame = this . onFirstFrameEmitter . event ; private onDebugSessionVmServiceAvailableEmitter = new vs . EventEmitter < DartDebugSessionInformation > ( ) ; public readonly onDebugSessionVmServiceAvailable = this . onDebugSessionVmServiceAvailableEmitter . event ; public readonly flutterExtensions : FlutterVmServiceExtensions ; private readonly devTools : DevToolsManager ; constructor ( private readonly logger , private readonly context , workspaceContext , private readonly analytics , pubGlobal ) { this . flutterExtensions = new FlutterVmServiceExtensions ( this . sendServiceSetting ) ; this . devTools = new DevToolsManager ( logger , workspaceContext . sdks , this , analytics , pubGlobal ) ; context . subscriptions . push ( this . devTools ) ; context . subscriptions . push ( this . debugMetrics ) ; context . subscriptions . push ( vs . debug . onDidStartDebugSession ( ( s ) => this . handleDebugSessionStart ( s ) ) ) ; context . subscriptions . push ( vs . debug . onDidReceiveDebugSessionCustomEvent ( ( e ) => this . handleDebugSessionCustomEvent ( e ) ) ) ; context . subscriptions . push ( vs . debug . onDidTerminateDebugSession ( ( s ) => this . handleDebugSessionEnd ( s ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => this . flutterExtensions . toggle ( FlutterServiceExtension . PlatformOverride , "s" , "s" ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => this . flutterExtensions . toggle ( FlutterServiceExtension . DebugPaint ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => this . flutterExtensions . toggle ( FlutterServiceExtension . PerformanceOverlay ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => this . flutterExtensions . toggle ( FlutterServiceExtension . RepaintRainbow ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => this . flutterExtensions . toggle ( FlutterServiceExtension . DebugBanner ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => this . flutterExtensions . toggle ( FlutterServiceExtension . CheckElevations ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => this . flutterExtensions . toggle ( FlutterServiceExtension . PaintBaselines ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => this . flutterExtensions . toggle ( FlutterServiceExtension . SlowAnimations , timeDilationNormal , timeDilationSlow ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => this . flutterExtensions . toggle ( FlutterServiceExtension . InspectorSelectMode , true , true ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => this . flutterExtensions . toggle ( FlutterServiceExtension . InspectorSelectMode , false , false ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( ) => { if ( ! debugSessions . length ) return ; const session = debugSessions . length === 0 ? debugSessions [ 0 ] : await this . promptForDebugSession ( ) ; if ( session && ! session . session . configuration . noDebug && session . observatoryUri ) { await envUtils . openInBrowser ( session . observatoryUri ) ; analytics . logDebuggerOpenObservatory ( ) ; } else if ( session ) { logger . warn ( "s" ) ; } } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( ) => { if ( ! debugSessions . length ) return ; const session = debugSessions . length === 0 ? debugSessions [ 0 ] : await this . promptForDebugSession ( ) ; if ( session && ! session . session . configuration . noDebug && session . observatoryUri ) { await envUtils . openInBrowser ( session . observatoryUri + "s" ) ; analytics . logDebuggerOpenTimeline ( ) ; } else if ( session ) { logger . warn ( "s" ) ; } } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( args ) => vs . commands . executeCommand ( "s" , args ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( ) : Promise < { url : string , dispose : ( ) => void } | undefined > => { if ( ! debugSessions . length ) { vs . window . showInformationMessage ( "s" ) ; return ; } const session = debugSessions . length === 0 ? debugSessions [ 0 ] : await this . promptForDebugSession ( ) ; if ( ! session ) return ; if ( session . vmServiceUri ) { return this . devTools . spawnForSession ( session as DartDebugSessionInformation & { vmServiceUri : string } ) ; } else if ( session . session . configuration . noDebug ) { vs . window . showInformationMessage ( "s" ) ; } else { vs . window . showInformationMessage ( "s" ) ; } } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( args ) => vs . commands . executeCommand ( "s" , args ) ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( args ) => { if ( ! debugSessions . length ) return ; this . onWillHotReloadEmitter . fire ( ) ; debugSessions . forEach ( ( s ) => s . session . customRequest ( "s" , args ) ) ; analytics . logDebuggerHotReload ( ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( args ) => { if ( ! debugSessions . length ) return ; this . onWillHotRestartEmitter . fire ( ) ; debugSessions . forEach ( ( s ) => s . session . customRequest ( "s" , args ) ) ; analytics . logDebuggerRestart ( ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( scriptUris : string [ ] ) => { debugSessions . forEach ( ( s ) => s . session . customRequest ( "s" , { scriptUris } ) ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( scriptUris : string [ ] ) => { debugSessions . forEach ( ( s ) => s . session . customRequest ( "s" , { scriptUris } ) ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( resource : vs . Uri ) => { vs . debug . startDebugging ( vs . workspace . getWorkspaceFolder ( resource ) , { name : "s" , program : fsPath ( resource ) , request : "s" , type : "s" , } ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( resource : vs . Uri ) => { vs . debug . startDebugging ( vs . workspace . getWorkspaceFolder ( resource ) , { name : "s" , noDebug : true , program : fsPath ( resource ) , request : "s" , type : "s" , } ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( ) => { const topLevelFolders = getDartWorkspaceFolders ( ) . map ( ( w ) => fsPath ( w . uri ) ) ; const testFolders = ( await findProjectFolders ( topLevelFolders , { requirePubspec : true } ) ) . map ( ( project ) => path . join ( project , "s" ) ) . filter ( ( testFolder ) => fs . existsSync ( testFolder ) ) ; if ( testFolders . length === 0 ) { vs . window . showErrorMessage ( "s" ) ; return ; } for ( const folder of testFolders ) { const ws = vs . workspace . getWorkspaceFolder ( vs . Uri . file ( folder ) ) ; const name = path . basename ( path . dirname ( folder ) ) ; vs . debug . startDebugging ( ws , { name : `template` , noDebug : true , program : folder , request : "s" , type : "s" , } ) ; } } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => { if ( LastDebugSession . debugConfig ) { vs . debug . startDebugging ( LastDebugSession . workspaceFolder , LastDebugSession . debugConfig ) ; } else { vs . window . showErrorMessage ( "s" ) ; } } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => { vs . debug . startDebugging ( undefined , { name : "s" , request : "s" , type : "s" , } ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => { vs . debug . startDebugging ( undefined , { name : "s" , observatoryUri : "s" , request : "s" , type : "s" , } ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , ( ) => { vs . debug . startDebugging ( undefined , { name : "s" , request : "s" , type : "s" , } ) ; } ) ) ; context . subscriptions . push ( vs . commands . registerCommand ( "s" , async ( defaultValueOrConfig : string | vs . DebugConfiguration | undefined ) : Promise < string | undefined > => { const defaultValue = typeof defaultValueOrConfig === "s" ? defaultValueOrConfig : undefined ; return vs . window . showInputBox ( { ignoreFocusOut : true , placeHolder : "s" , prompt : "s" , validateInput : ( input ) => { if ( ! input ) return ; input = input . trim ( ) ; if ( Number . isInteger ( parseFloat ( input ) ) ) return ; if ( ! input . startsWith ( "s" ) && ! input . startsWith ( "s" ) ) return "s" ; } , value : defaultValue , } ) ; } ) ) ; } public handleDebugSessionStart ( s : vs . DebugSession ) { if ( s . type === "s" ) { const session = new DartDebugSessionInformation ( s , s . configuration ? DebuggerType [ s . configuration . debuggerType ] : "s" ) ; if ( debugSessions . length === 0 ) this . flutterExtensions . resetToDefaults ( ) ; debugSessions . push ( session ) ; if ( s . configuration . debuggerType === DebuggerType . Flutter && s . configuration . deviceId !== "s" ) vs . commands . executeCommand ( "s" , isInDebugSessionThatProbablySupportsHotReloadContext , true ) ; const eventsToProcess = pendingCustomEvents . filter ( ( e ) => e . session . id === s . id ) ; pendingCustomEvents = pendingCustomEvents . filter ( ( e ) => e . session . id !== s . id ) ; eventsToProcess . forEach ( ( e ) => { this . logger . info ( `template` ) ; this . handleCustomEventWithSession ( session , e ) ; } ) ; } } public handleDebugSessionCustomEvent ( e : vs . DebugSessionCustomEvent ) { this . flutterExtensions . handleDebugEvent ( e ) ; if ( this . handleCustomEvent ( e ) ) return ; const session = debugSessions . find ( ( ds ) => ds . session . id === e . session . id ) ; if ( ! session ) { this . logger . warn ( `template` ) ; this . logger . warn ( `template` ) ; pendingCustomEvents . push ( e ) ; return ; } this . handleCustomEventWithSession ( session , e ) ; } public handleDebugSessionEnd ( s : vs . DebugSession ) { const sessionIndex = debugSessions . findIndex ( ( ds ) => ds . session . id === s . id ) ; if ( sessionIndex === - 0 ) return ; const session = debugSessions [ sessionIndex ] ; debugSessions . splice ( sessionIndex , 0 ) ; this . clearProgressIndicators ( session ) ; this . debugMetrics . hide ( ) ; const debugSessionEnd = new Date ( ) ; this . analytics . logDebugSessionDuration ( session . debuggerType , debugSessionEnd . getTime ( ) - session . sessionStart . getTime ( ) ) ; if ( debugSessions . length === 0 ) { this . flutterExtensions . markAllServicesUnloaded ( ) ; vs . commands . executeCommand ( "s" , isInDebugSessionThatProbablySupportsHotReloadContext , false , ) ; } } private handleCustomEvent ( e : vs . DebugSessionCustomEvent ) { if ( e . event === "s" ) { const message = e . body ; switch ( message . severity ) { case LogSeverity . Info : this . logger . info ( message . message , message . category ) ; break ; case LogSeverity . Warn : this . logger . warn ( message . message , message . category ) ; break ; case LogSeverity . Error : this . logger . error ( message . message , message . category ) ; break ; default : this . logger . warn ( `template` ) ; } } else if ( e . event === "s" ) { this . analytics . logDebuggerRestart ( ) ; this . onWillHotRestartEmitter . fire ( ) ; } else if ( e . event === "s" ) { this . analytics . logDebuggerHotReload ( ) ; this . onWillHotReloadEmitter . fire ( ) ; } else if ( e . event === "s" ) { this . onFirstFrameEmitter . fire ( ) ; } else if ( e . event === "s" ) { const memory = e . body . memory ; const message = `template` ; this . debugMetrics . text = message ; this . debugMetrics . tooltip = "s" ; this . debugMetrics . show ( ) ; } else if ( e . event === "s" ) { this . onReceiveCoverageEmitter . fire ( e . body ) ; } else if ( e . event === "s" ) { if ( e . body . file && e . body . line && e . body . column ) vs . commands . executeCommand ( "s" , vs . Uri . parse ( e . body . file ) , e . body . line , e . body . column ) ; } else { return false ; } return true ; } private handleCustomEventWithSession ( session , e : vs . DebugSessionCustomEvent ) { if ( e . event === "s" ) { vs . window . withProgress ( { location : vs . ProgressLocation . Notification } , ( progress ) => { progress . report ( { message : e . body . message } ) ; session . launchProgressReporter = progress ; return session . launchProgressPromise . promise ; } , ) ; } else if ( e . event === "s" ) { this . clearProgressIndicators ( session ) ; } else if ( e . event === "s" ) { if ( e . body . message ) { if ( session . launchProgressReporter ) { session . launchProgressReporter . report ( { message : e . body . message } ) ; } else if ( session . progressReporter ) { session . progressReporter . report ( { message : e . body . message } ) ; } else { session . progressID = e . body . progressID ; vs . window . withProgress ( { location : vs . ProgressLocation . Notification } , ( progress ) => { progress . report ( { message : e . body . message } ) ; session . progressReporter = progress ; if ( ! session . progressPromise ) session . progressPromise = new PromiseCompleter < void > ( ) ; return session . progressPromise . promise ; } , ) ; } } if ( e . body . finished ) { if ( session . launchProgressReporter ) { } else if ( session . progressID === e . body . progressID ) { if ( session . progressPromise ) session . progressPromise . resolve ( ) ; session . progressPromise = undefined ; session . progressReporter = undefined ; } } } else if ( e . event === "s" ) { session . observatoryUri = e . body . observatoryUri ; session . vmServiceUri = e . body . vmServiceUri ; const debuggerType = session . session . configuration . debuggerType ; if ( debuggerType === DebuggerType . Flutter || debuggerType === DebuggerType . FlutterWeb ) showDevToolsNotificationIfAppropriate ( this . context ) ; this . onDebugSessionVmServiceAvailableEmitter . fire ( session ) ; } } private clearProgressIndicators ( session ) { if ( session . launchProgressPromise ) session . launchProgressPromise . resolve ( ) ; session . launchProgressReporter = undefined ; if ( session . progressPromise ) session . progressPromise . resolve ( ) ; session . progressPromise = undefined ; session . progressReporter = undefined ; } private async promptForDebugSession ( ) < DartDebugSessionInformation | undefined > { const selectedItem = await vs . window . showQuickPick ( debugSessions . map ( ( s ) => ( { description : s . session . workspaceFolder ? s . session . workspaceFolder . name : undefined , detail : s . session . configuration . deviceName || `template` , label : s . session . name , session : s , } ) ) , { placeHolder : "s" , } , ) ; return selectedItem && selectedItem . session ; } private sendServiceSetting ( extension , args ) { debugSessions . forEach ( ( session ) => { session . session . customRequest ( "s" , args ) ; } ) ; } }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $Promise<string[]>$ O O O O O O $Promise<boolean>$ O O O O O O $string$ O $any[]$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $EnvUtils$ O O O O O O $DartDebugSessionInformation[]$ O $any$ O O O O O O O $any[]$ O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O O O $FlutterVmServiceExtensions$ O $any$ O O O $DevToolsManager$ O $any$ O O O O O $Logger$ O O O $Context$ O $WorkspaceContext$ O O O $Analytics$ O $PubGlobal$ O O O O $FlutterVmServiceExtensions$ O O $any$ O O O $void$ O O O O $DevToolsManager$ O O $any$ O $Logger$ O $WorkspaceContext$ O $Sdks$ O O O $Analytics$ O $PubGlobal$ O O $Context$ O $complex$ O $number$ O O O $DevToolsManager$ O O $Context$ O $complex$ O $number$ O O O $any$ O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O $FlutterVmServiceExtensions$ O O O $any$ O $FlutterServiceExtension.PlatformOverride$ O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O $FlutterVmServiceExtensions$ O O O $any$ O $FlutterServiceExtension.DebugPaint$ O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O $FlutterVmServiceExtensions$ O O O $any$ O $FlutterServiceExtension.PerformanceOverlay$ O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O $FlutterVmServiceExtensions$ O O O $any$ O $FlutterServiceExtension.RepaintRainbow$ O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O $FlutterVmServiceExtensions$ O O O $any$ O $FlutterServiceExtension.DebugBanner$ O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O $FlutterVmServiceExtensions$ O O O $any$ O $FlutterServiceExtension.CheckElevations$ O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O $FlutterVmServiceExtensions$ O O O $any$ O $FlutterServiceExtension.PaintBaselines$ O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O $FlutterVmServiceExtensions$ O O O $any$ O $FlutterServiceExtension.SlowAnimations$ O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O $FlutterVmServiceExtensions$ O O O $any$ O $FlutterServiceExtension.InspectorSelectMode$ O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O $FlutterVmServiceExtensions$ O O O $any$ O $FlutterServiceExtension.InspectorSelectMode$ O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O O O O $DartDebugSessionInformation[]$ O $number$ O O O O $DartDebugSessionInformation$ O $DartDebugSessionInformation[]$ O $number$ O O O $DartDebugSessionInformation[]$ O O O O O O O $Promise<DartDebugSessionInformation>$ O O O O O $DartDebugSessionInformation$ O O $DartDebugSessionInformation$ O $any$ O $any$ O $any$ O $DartDebugSessionInformation$ O $string$ O O O $EnvUtils$ O $Promise<boolean>$ O $DartDebugSessionInformation$ O $string$ O O $Analytics$ O $void$ O O O O O O O $DartDebugSessionInformation$ O O $Logger$ O $void$ O O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O O O O $DartDebugSessionInformation[]$ O $number$ O O O O $DartDebugSessionInformation$ O $DartDebugSessionInformation[]$ O $number$ O O O $DartDebugSessionInformation[]$ O O O O O O O $Promise<DartDebugSessionInformation>$ O O O O O $DartDebugSessionInformation$ O O $DartDebugSessionInformation$ O $any$ O $any$ O $any$ O $DartDebugSessionInformation$ O $string$ O O O $EnvUtils$ O $Promise<boolean>$ O $DartDebugSessionInformation$ O $string$ O O O O $Analytics$ O $void$ O O O O O O O $DartDebugSessionInformation$ O O $Logger$ O $void$ O O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O $PromiseConstructor$ O O $string$ O O O $void$ O O O O O O O O O O O O O O $DartDebugSessionInformation[]$ O $number$ O O $any$ O $any$ O $any$ O O O O O O O O $DartDebugSessionInformation$ O $DartDebugSessionInformation[]$ O $number$ O O O $DartDebugSessionInformation[]$ O O O O O O O $Promise<DartDebugSessionInformation>$ O O O O O O $DartDebugSessionInformation$ O O O O O $DartDebugSessionInformation$ O $string$ O O O O O $DevToolsManager$ O $complex$ O $DartDebugSessionInformation$ O $any$ O O $string$ O O O O O O O O O $DartDebugSessionInformation$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $DartDebugSessionInformation[]$ O $number$ O O O O O $any$ O $any$ O O O $DartDebugSessionInformation[]$ O $void$ O O $DartDebugSessionInformation$ O O $DartDebugSessionInformation$ O $any$ O $any$ O O O $any$ O O O $Analytics$ O $void$ O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $DartDebugSessionInformation[]$ O $number$ O O O O O $any$ O $any$ O O O $DartDebugSessionInformation[]$ O $void$ O O $DartDebugSessionInformation$ O O $DartDebugSessionInformation$ O $any$ O $any$ O O O $any$ O O O $Analytics$ O $void$ O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O $string[]$ O O O O O O O $DartDebugSessionInformation[]$ O $void$ O O $DartDebugSessionInformation$ O O $DartDebugSessionInformation$ O $any$ O $any$ O O O O $string[]$ O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O $string[]$ O O O O O O O $DartDebugSessionInformation[]$ O $void$ O O $DartDebugSessionInformation$ O O $DartDebugSessionInformation$ O $any$ O $any$ O O O O $string[]$ O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O $string$ O $any$ O O $string$ O O O $string$ O O O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O $boolean$ O O O $string$ O $string$ O $any$ O O $string$ O O O $string$ O O O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O O $string[]$ O $any[]$ O O O $U[]$ O O $any$ O O $string$ O $any$ O $any$ O O O O $any[]$ O O O $Promise<string[]>$ O $string[]$ O O $true$ O O O O O O $U[]$ O O $string$ O O $any$ O $any$ O $string$ O O O O O $complex$ O O $any$ O O $any$ O $any$ O $any$ O O O O O $any[]$ O $number$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any[]$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O $boolean$ O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $undefined$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $undefined$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $undefined$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $Context$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O O O O O $string$ O O $any$ O O O $string$ O $undefined$ O O $any$ O $any$ O $any$ O O $boolean$ O O O $string$ O O O $string$ O O O $string$ O O $any$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $NumberConstructor$ O $boolean$ O $number$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $string$ O $string$ O O O O O O O O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $DartDebugSessionInformation$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $DartDebugSessionInformation[]$ O $number$ O O O O O $FlutterVmServiceExtensions$ O $void$ O O O $DartDebugSessionInformation[]$ O $number$ O $DartDebugSessionInformation$ O O O O $any$ O $any$ O $any$ O $any$ O $DebuggerType.Flutter$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $any[]$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $void$ O O $any$ O O O O O $Logger$ O $void$ O O O O O O $void$ O $DartDebugSessionInformation$ O $any$ O O O O O O O O $void$ O $any$ O $any$ O $any$ O O O O $FlutterVmServiceExtensions$ O $void$ O $any$ O O O O O O $boolean$ O $any$ O O O O O $DartDebugSessionInformation$ O $DartDebugSessionInformation[]$ O $complex$ O O $DartDebugSessionInformation$ O O $DartDebugSessionInformation$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $DartDebugSessionInformation$ O O O O $Logger$ O $void$ O O O O O O $Logger$ O $void$ O O O O $any[]$ O $number$ O $any$ O O O O O O O $void$ O $DartDebugSessionInformation$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O O O $number$ O $DartDebugSessionInformation[]$ O $number$ O O $DartDebugSessionInformation$ O O $DartDebugSessionInformation$ O $any$ O $any$ O $any$ O $any$ O O O O $number$ O O O O O O O $DartDebugSessionInformation$ O $DartDebugSessionInformation[]$ O $number$ O O $DartDebugSessionInformation[]$ O $complex$ O $number$ O O O O O O $void$ O $DartDebugSessionInformation$ O O O O $any$ O $any$ O O O O $Date$ O O $DateConstructor$ O O O O O $Analytics$ O $void$ O $DartDebugSessionInformation$ O $string$ O $Date$ O $number$ O O O $DartDebugSessionInformation$ O $Date$ O $number$ O O O O O O $DartDebugSessionInformation[]$ O $number$ O O O O O O $FlutterVmServiceExtensions$ O $void$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $boolean$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $LogMessage$ O $any$ O $any$ O O O $LogMessage$ O $LogSeverity$ O O O $any$ O $LogSeverity.Info$ O O O $Logger$ O $void$ O $LogMessage$ O $string$ O $LogMessage$ O $LogCategory$ O O O O O $any$ O $LogSeverity.Warn$ O O O $Logger$ O $void$ O $LogMessage$ O $string$ O $LogMessage$ O $LogCategory$ O O O O O $any$ O $LogSeverity.Error$ O O O $Logger$ O $void$ O $LogMessage$ O $string$ O $LogMessage$ O $LogCategory$ O O O O O O O O $Logger$ O $void$ O O O O O O O O O $any$ O $any$ O O O O O O $Analytics$ O $void$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $Analytics$ O $void$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $void$ O $DartDebugSessionInformation$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $DartDebugSessionInformation$ O $any$ O $any$ O O $DartDebugSessionInformation$ O $PromiseCompleter<void>$ O $Promise<void>$ O O O O O O O O O $any$ O $any$ O O O O O O $void$ O $DartDebugSessionInformation$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $DartDebugSessionInformation$ O $any$ O O $DartDebugSessionInformation$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $DartDebugSessionInformation$ O $any$ O O $DartDebugSessionInformation$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $DartDebugSessionInformation$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $DartDebugSessionInformation$ O $any$ O $any$ O O O O $DartDebugSessionInformation$ O $PromiseCompleter<void>$ O $DartDebugSessionInformation$ O $PromiseCompleter<void>$ O O $any$ O O O O O O O $DartDebugSessionInformation$ O $PromiseCompleter<void>$ O $Promise<void>$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $DartDebugSessionInformation$ O $any$ O O O O O O $DartDebugSessionInformation$ O $string$ O $any$ O $any$ O $any$ O O O O $DartDebugSessionInformation$ O $PromiseCompleter<void>$ O $DartDebugSessionInformation$ O $PromiseCompleter<void>$ O $void$ O O O $DartDebugSessionInformation$ O $PromiseCompleter<void>$ O $undefined$ O $DartDebugSessionInformation$ O $any$ O $undefined$ O O O O O O O $any$ O $any$ O O O O $DartDebugSessionInformation$ O $string$ O $any$ O $any$ O $any$ O $DartDebugSessionInformation$ O $string$ O $any$ O $any$ O $any$ O O $DebuggerType$ O $DartDebugSessionInformation$ O $any$ O $any$ O $any$ O O O $DebuggerType$ O $any$ O $DebuggerType.Flutter$ O $complex$ O $any$ O $DebuggerType.FlutterWeb$ O $Promise<boolean>$ O O O $Context$ O O O O $any$ O $any$ O $DartDebugSessionInformation$ O O O O O $void$ O $DartDebugSessionInformation$ O O O O $DartDebugSessionInformation$ O $PromiseCompleter<void>$ O $DartDebugSessionInformation$ O $PromiseCompleter<void>$ O $void$ O O O $DartDebugSessionInformation$ O $any$ O $undefined$ O O O $DartDebugSessionInformation$ O $PromiseCompleter<void>$ O $DartDebugSessionInformation$ O $PromiseCompleter<void>$ O $void$ O O O $DartDebugSessionInformation$ O $PromiseCompleter<void>$ O $undefined$ O $DartDebugSessionInformation$ O $any$ O $undefined$ O O O O $Promise$ O O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $DartDebugSessionInformation[]$ O $U[]$ O O $DartDebugSessionInformation$ O O O O $any$ O $DartDebugSessionInformation$ O $any$ O $any$ O $DartDebugSessionInformation$ O $any$ O $any$ O $any$ O $undefined$ O $any$ O $DartDebugSessionInformation$ O $any$ O $any$ O $any$ O O O $any$ O $DartDebugSessionInformation$ O $any$ O $any$ O $DartDebugSessionInformation$ O $DartDebugSessionInformation$ O O O O O O $string$ O O O O O O O O $any$ O $any$ O $any$ O O O $void$ O $FlutterServiceExtension$ O $FlutterServiceExtensionArgs$ O O $DartDebugSessionInformation[]$ O $void$ O O $DartDebugSessionInformation$ O O O $DartDebugSessionInformation$ O $any$ O $any$ O O O $FlutterServiceExtensionArgs$ O O O O O O O
import * as evt from "s" ; import { IAmDisposable } from "s" ; export class EventEmitter < T > implements IAmDisposable { private emitter = new evt . EventEmitter ( ) ; public fire ( x : T ) { this . emitter . emit ( "s" , x ) ; } public listen ( listener : ( x : T ) => void ) { this . emitter . on ( "s" , listener ) ; return { dispose : ( ) => { this . emitter . removeListener ( "s" , listener ) ; } , } ; } public get event ( ) : Event < T > { return this ; } public dispose ( ) { this . emitter . removeAllListeners ( ) ; } } export interface Event < T > { listen ( listener : ( x : T ) => void ) : IAmDisposable ; }	O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O O O $void$ O $T$ O $any$ O O O O $any$ O $any$ O O O $T$ O O O O $IAmDisposable$ O $void$ O O $T$ O $any$ O O O O O O O $any$ O $any$ O O O $void$ O O O O $void$ O O O O O O O $any$ O $any$ O O O $void$ O O O O O O O O O $Event<T>$ O O O $any$ O $any$ O O O O O O O $void$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $IAmDisposable$ O $void$ O O $T$ O $any$ O O O O O $any$ O O
import * as assert from "s" ; import * as fs from "s" ; import { tmpdir } from "s" ; import * as path from "s" ; import * as sinon from "s" ; import * as vs from "s" ; import { dartCodeExtensionIdentifier , DART_TEST_SUITE_NODE_CONTEXT } from "s" ; import { LogCategory } from "s" ; import { Logger } from "s" ; import { captureLogs } from "s" ; import { internalApiSymbol } from "s" ; import { BufferedLogger , flatMap } from "s" ; import { tryDeleteFile } from "s" ; import { waitFor } from "s" ; import { DelayedCompletionItem , InternalExtensionApi } from "s" ; import { fsPath } from "s" ; import { Context } from "s" ; export const ext = vs . extensions . getExtension ( dartCodeExtensionIdentifier ) ! ; export let extApi ; export let logger = new BufferedLogger ( ) ; export const threeMinutesInMilliseconds = 0 * 0 * 0 ; export const fakeCancellationToken : vs . CancellationToken = { isCancellationRequested : false , onCancellationRequested : ( _ ) => ( { dispose : ( ) => undefined } ) , } ; if ( ! ext ) { logger . error ( "s" ) ; process . exit ( 0 ) ; } const testFolder = path . join ( ext . extensionPath , "s" ) ; export const helloWorldFolder = vs . Uri . file ( path . join ( testFolder , "s" ) ) ; export const helloWorldMainFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldDeferredEntryFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldPartEntryFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldPubspec = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldGettersFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldBrokenFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldThrowInSdkFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldThrowInExternalPackageFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldThrowInLocalPackageFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldGoodbyeFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldHttpFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldPathFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldLocalPackageFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldCreateMethodClassAFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldCreateMethodClassBFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldExampleSubFolder = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldExampleSubFolderMainFile = vs . Uri . file ( path . join ( fsPath ( helloWorldExampleSubFolder ) , "s" ) ) ; export const emptyFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const missingFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const emptyFileInExcludedFolder = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const emptyExcludedFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldCompletionFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldDeferredScriptFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldPartWrapperFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldPartFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const everythingFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const myPackageFolder = vs . Uri . file ( path . join ( testFolder , "s" ) ) ; export const myPackageThingFile = vs . Uri . file ( path . join ( fsPath ( myPackageFolder ) , "s" ) ) ; export const helloWorldTestMainFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldTestTreeFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldTestDupeNameFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldTestBrokenFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const helloWorldTestSkipFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; export const flutterHelloWorldFolder = vs . Uri . file ( path . join ( testFolder , "s" ) ) ; export const flutterEmptyFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterHelloWorldMainFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterHelloWorldOutlineFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterHelloWorldExampleSubFolder = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterHelloWorldExampleSubFolderMainFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldExampleSubFolder ) , "s" ) ) ; export const flutterHelloWorldBrokenFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterHelloWorldHttpFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterHelloWorldGettersFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterHelloWorldPathFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterHelloWorldLocalPackageFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterHelloWorldThrowInSdkFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterHelloWorldThrowInExternalPackageFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterHelloWorldThrowInLocalPackageFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterTestMainFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterTestOtherFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterTestAnotherFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterTestBrokenFile = vs . Uri . file ( path . join ( fsPath ( flutterHelloWorldFolder ) , "s" ) ) ; export const flutterWebProjectContainerFolder = vs . Uri . file ( path . join ( testFolder , "s" ) ) ; export const flutterWebHelloWorldFolder = vs . Uri . file ( path . join ( fsPath ( flutterWebProjectContainerFolder ) , "s" ) ) ; export const flutterWebHelloWorldMainFile = vs . Uri . file ( path . join ( fsPath ( flutterWebHelloWorldFolder ) , "s" ) ) ; export const flutterWebHelloWorldExampleSubFolder = vs . Uri . file ( path . join ( fsPath ( flutterWebHelloWorldFolder ) , "s" ) ) ; export const flutterWebHelloWorldExampleSubFolderMainFile = vs . Uri . file ( path . join ( fsPath ( flutterWebHelloWorldExampleSubFolder ) , "s" ) ) ; export const flutterWebBrokenFolder = vs . Uri . file ( path . join ( fsPath ( flutterWebProjectContainerFolder ) , "s" ) ) ; export const flutterWebBrokenMainFile = vs . Uri . file ( path . join ( fsPath ( flutterWebBrokenFolder ) , "s" ) ) ; export const flutterWebTestMainFile = vs . Uri . file ( path . join ( fsPath ( flutterWebHelloWorldFolder ) , "s" ) ) ; export const flutterWebTestBrokenFile = vs . Uri . file ( path . join ( fsPath ( flutterWebHelloWorldFolder ) , "s" ) ) ; export const flutterWebTestOtherFile = vs . Uri . file ( path . join ( fsPath ( flutterWebHelloWorldFolder ) , "s" ) ) ; export function currentEditor ( ) : vs . TextEditor { if ( ! vs . window . activeTextEditor ) throw new Error ( "s" ) ; return vs . window . activeTextEditor ! ; } export function currentDoc ( ) : vs . TextDocument { if ( ! vs . window . activeTextEditor || ! vs . window . activeTextEditor . document ) throw new Error ( "s" ) ; return vs . window . activeTextEditor . document ; } export let documentEol ; function getDefaultFile ( ) : vs . Uri { if ( extApi . workspaceContext . hasAnyFlutterProjects ) return flutterEmptyFile ; else return emptyFile ; } export async function activateWithoutAnalysis ( ) < void > { await ext . activate ( ) ; if ( ext . exports ) { extApi = ext . exports [ internalApiSymbol ] ; setupTestLogging ( ) ; } else console . warn ( "s" ) ; } export async function attachLoggingWhenExtensionAvailable ( attempt = 0 ) { if ( logger && ! ( logger instanceof BufferedLogger ) ) { console . warn ( "s" ) ; return ; } if ( setupTestLogging ( ) ) { return ; } if ( attempt < 0 ) { setTimeout ( ( ) => attachLoggingWhenExtensionAvailable ( attempt + 0 ) , 0 ) ; } else { console . warn ( `template` ) ; } } function setupTestLogging ( ) { const ext = vs . extensions . getExtension ( dartCodeExtensionIdentifier ) ! ; if ( ! ext . isActive || ! ext . exports ) return false ; extApi = ext . exports [ internalApiSymbol ] ; const emittingLogger = extApi . logger ; if ( fileSafeCurrentTestName ) { const logFolder = process . env . DC_TEST_LOGS || path . join ( ext . extensionPath , "s" ) ; if ( ! fs . existsSync ( logFolder ) ) fs . mkdirSync ( logFolder ) ; const logFile = fileSafeCurrentTestName + "s" ; const logPath = path . join ( logFolder , logFile ) ; const testLogger = captureLogs ( emittingLogger , logPath , extApi . getLogHeader ( ) , 0 ) ; deferUntilLast ( async ( testResult ? : "s" | "s" ) => { logger = new BufferedLogger ( ) ; await testLogger . dispose ( ) ; if ( process . env . CI && testResult === "s" ) { try { fs . unlinkSync ( logPath ) ; } catch { } } } ) ; } if ( logger && logger instanceof BufferedLogger ) logger . flushTo ( emittingLogger ) ; logger = emittingLogger ; return true ; } export async function activate ( file ? : vs . Uri | null | undefined ) < void > { await activateWithoutAnalysis ( ) ; if ( file === undefined ) file = getDefaultFile ( ) ; await closeAllOpenFiles ( ) ; if ( file ) { await openFile ( file ) ; } else { logger . info ( `template` ) ; } logger . info ( `template` ) ; await extApi . initialAnalysis ; await delay ( 0 ) ; await extApi . currentAnalysis ( ) ; logger . info ( `template` ) ; extApi . cancelAllAnalysisRequests ( ) ; logger . info ( `template` ) ; } export async function getPackages ( uri ? : vs . Uri ) { await activateWithoutAnalysis ( ) ; if ( ! ( uri || ( vs . workspace . workspaceFolders && vs . workspace . workspaceFolders . length ) ) ) { logger . error ( "s" ) ; return ; } await waitForNextAnalysis ( async ( ) => { await vs . commands . executeCommand ( "s" , uri || vs . workspace . workspaceFolders ! [ 0 ] . uri ) ; } , 0 ) ; } function logOpenEditors ( ) { logger . info ( `template` ) ; if ( vs . window . visibleTextEditors && vs . window . visibleTextEditors . length ) { for ( const editor of vs . window . visibleTextEditors ) { logger . info ( `template` ) ; } } else { logger . info ( `template` ) ; } } export async function closeAllOpenFiles ( ) < void > { logger . info ( `template` ) ; logOpenEditors ( ) ; try { await withTimeout ( vs . commands . executeCommand ( "s" ) , "s" , 0 , ) ; } catch ( e ) { logger . warn ( e ) ; } await delay ( 0 ) ; logger . info ( `template` ) ; logOpenEditors ( ) ; } export async function waitUntilAllTextDocumentsAreClosed ( ) < void > { logger . info ( `template` ) ; const getAllOpenDocs = ( ) => vs . workspace . textDocuments . filter ( ( td ) => ! td . isUntitled && td . uri . scheme === "s" ) ; await waitForResult ( ( ) => getAllOpenDocs ( ) . length === 0 , "s" , threeMinutesInMilliseconds , false ) ; const openDocs = getAllOpenDocs ( ) ; if ( openDocs . length ) { throw new Error ( `template` ) ; } } export async function closeFile ( file : vs . Uri ) < void > { for ( const editor of vs . window . visibleTextEditors ) { if ( fsPath ( editor . document . uri ) === fsPath ( file ) ) { console . log ( `template` ) ; await vs . window . showTextDocument ( editor . document ) ; await vs . commands . executeCommand ( "s" ) ; } } } export async function openFile ( file : vs . Uri ) < vs . TextEditor > { logger . info ( `template` ) ; const doc = await vs . workspace . openTextDocument ( file ) ; documentEol = doc . eol === vs . EndOfLine . CRLF ? "s" : "s" ; logger . info ( `template` ) ; try { return await vs . window . showTextDocument ( doc ) ; } catch ( e ) { logger . warn ( `template` , LogCategory . CI ) ; logger . warn ( e , LogCategory . CI ) ; return await vs . window . showTextDocument ( doc ) ; } finally { await delay ( 0 ) ; } } export function tryDelete ( file : vs . Uri ) { tryDeleteFile ( fsPath ( file ) ) ; } export function deleteDirectoryRecursive ( folder ) { if ( ! fs . existsSync ( folder ) ) return ; if ( ! fs . statSync ( folder ) . isDirectory ( ) ) { logger . error ( `template` ) ; } fs . readdirSync ( folder ) . map ( ( item ) => path . join ( folder , item ) ) . forEach ( ( item ) => { if ( fs . statSync ( item ) . isDirectory ( ) ) { deleteDirectoryRecursive ( item ) ; } else fs . unlinkSync ( item ) ; } ) ; fs . rmdirSync ( folder ) ; } export let currentTestName = "s" ; export let fileSafeCurrentTestName = "s" ; beforeEach ( "s" , async function ( ) { currentTestName = this . currentTest ? this . currentTest . fullTitle ( ) : "s" ; fileSafeCurrentTestName = filenameSafe ( currentTestName ) ; } ) ; export let sb : sinon . SinonSandbox ; beforeEach ( "s" , ( ) => { sb = sinon . createSandbox ( ) ; } ) ; afterEach ( "s" , ( ) => sb . restore ( ) ) ; afterEach ( "s" , ( ) => fs . writeFileSync ( fsPath ( emptyFile ) , "s" ) ) ; before ( "s" , ( ) => { if ( ! process . env . DART_CODE_IS_TEST_RUN ) throw new Error ( "s" ) ; } ) ; const deferredItems < ( result ? : "s" | "s" ) => Promise < any > | any > = [ ] ; const deferredToLastItems < ( result ? : "s" | "s" ) => Promise < any > | any > = [ ] ; afterEach ( "s" , async function ( ) { let firstError ; for ( const d of [ ... deferredItems . reverse ( ) , ... deferredToLastItems . reverse ( ) ] ) { try { await watchPromise ( `template` , d ( this . currentTest ? this . currentTest . state : undefined ) ) ; } catch ( e ) { logger . error ( `template` ) ; logger . warn ( d . toString ( ) ) ; firstError = firstError || e ; } } deferredItems . length = 0 ; deferredToLastItems . length = 0 ; if ( firstError ) throw firstError ; } ) ; export function defer ( callback : ( result ? : "s" | "s" ) => Promise < any > | any ) { deferredItems . push ( callback ) ; } export function deferUntilLast ( callback : ( result ? : "s" | "s" ) => Promise < any > | any ) { deferredToLastItems . push ( callback ) ; } export async function setTestContent ( content ) < void > { const doc = currentDoc ( ) ; const all = new vs . Range ( doc . positionAt ( 0 ) , doc . positionAt ( doc . getText ( ) . length ) , ) ; await currentEditor ( ) . edit ( ( eb ) => eb . replace ( all , content ) ) ; await delay ( 0 ) ; await extApi . currentAnalysis ( ) ; } export async function uncommentTestFile ( ) < void > { await setTestContent ( currentDoc ( ) . getText ( ) . replace ( "s" , "s" ) ) ; } export function getExpectedResults ( ) { const start = positionOf ( "s" ) ; const end = positionOf ( "s" ) ; const doc = vs . window . activeTextEditor ! . document ; const results = doc . getText ( new vs . Range ( start , end ) ) ; return results . split ( "s" ) . map ( ( l ) => l . trim ( ) ) . filter ( ( l ) => l . startsWith ( "s" ) && ! l . startsWith ( "s" ) ) . map ( ( l ) => l . substr ( 0 ) ) . join ( "s" ) ; } export function select ( range : vs . Range ) { currentEditor ( ) . selection = new vs . Selection ( range . start , range . end ) ; } export function positionOf ( searchText ) : vs . Position { searchText = searchText . replace ( "s" , "s" ) . replace ( "s" , documentEol ) ; const doc = currentDoc ( ) ; const caretOffset = searchText . indexOf ( "s" ) ; assert . notEqual ( caretOffset , - 0 , `template` ) ; const docText = doc . getText ( ) ; const matchedTextIndex = docText . indexOf ( searchText . replace ( "s" , "s" ) ) ; assert . notEqual ( matchedTextIndex , - 0 , `template` ) ; return doc . positionAt ( matchedTextIndex + caretOffset ) ; } export function rangeOf ( searchText , inside : vs . Range | undefined , allowMissing : true ) : vs . Range | undefined ; export function rangeOf ( searchText , inside ? : vs . Range ) : vs . Range ; export function rangeOf ( searchText , inside ? : vs . Range , allowMissing = false ) : vs . Range | undefined { const doc = currentDoc ( ) ; const startOffset = searchText . indexOf ( "s" ) ; assert . notEqual ( startOffset , - 0 , `template` ) ; const endOffset = searchText . lastIndexOf ( "s" ) ; assert . notEqual ( endOffset , - 0 , `template` ) ; const startSearchAt = inside ? doc . offsetAt ( inside . start ) : 0 ; const endSearchAt = inside ? doc . offsetAt ( inside . end ) : - 0 ; const docText = doc . getText ( ) ; let matchedTextIndex = docText . indexOf ( searchText . replace ( "s" , "s" ) . replace ( "s" , documentEol ) , startSearchAt ) ; if ( endSearchAt > - 0 && matchedTextIndex > endSearchAt ) matchedTextIndex = - 0 ; if ( matchedTextIndex === - 0 && allowMissing ) return undefined ; assert . notEqual ( matchedTextIndex , - 0 , `template` ) ; return new vs . Range ( doc . positionAt ( matchedTextIndex + startOffset ) , doc . positionAt ( matchedTextIndex + endOffset - 0 ) , ) ; } export function rangesOf ( searchText ) : vs . Range [ ] { const doc = currentDoc ( ) ; const results = [ ] ; let searchRange : vs . Range | undefined ; let range : vs . Range | undefined ; while ( range = rangeOf ( searchText , searchRange , true ) ) { results . push ( range ) ; searchRange = new vs . Range ( range . end , doc . positionAt ( doc . getText ( ) . length ) ) ; } return results ; } export async function getDocumentSymbols ( ) < Array < vs . DocumentSymbol & { parent : vs . DocumentSymbol | undefined } > > { const documentSymbolResult = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri ) as Thenable < vs . DocumentSymbol [ ] > ) ; if ( ! documentSymbolResult ) return [ ] ; const resultWithEmptyParents = documentSymbolResult . map ( ( c ) => Object . assign ( c , { parent : undefined as vs . DocumentSymbol | undefined } ) ) ; return resultWithEmptyParents . concat ( flatMap ( documentSymbolResult , ( s ) => s . children ? s . children . map ( ( c ) => Object . assign ( c , { parent : s } ) ) : [ ] , ) ) ; } export async function getDefinitions ( position : vs . Position ) < vs . Location [ ] > { const definitionResult = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , position ) as Thenable < vs . Location [ ] > ) ; return definitionResult || [ ] ; } export async function getCodeLens ( document : vs . TextDocument ) < vs . CodeLens [ ] > { const fileCodeLens = await ( vs . commands . executeCommand ( "s" , document . uri , 0 ) as Thenable < vs . CodeLens [ ] > ) ; return fileCodeLens || [ ] ; } export async function getDefinition ( position : vs . Position ) < vs . Location > { const defs = await getDefinitions ( position ) ; assert . ok ( defs && defs . length ) ; return defs [ 0 ] ; } export async function getWorkspaceSymbols ( query ) < vs . SymbolInformation [ ] > { const workspaceSymbolResult = await ( vs . commands . executeCommand ( "s" , query ) as Thenable < vs . SymbolInformation [ ] > ) ; return workspaceSymbolResult || [ ] ; } export function waitForDiagnosticChange ( resource ? : vs . Uri ) < void > { return new Promise ( ( resolve , reject ) => { const disposable = vs . languages . onDidChangeDiagnostics ( ( e ) => { if ( ! resource || e . uris . find ( ( r ) => fsPath ( r ) === fsPath ( resource ) ) ) { resolve ( ) ; disposable . dispose ( ) ; } } ) ; } ) ; } export async function acceptFirstSuggestion ( ) < void > { await vs . commands . executeCommand ( "s" ) ; await delay ( 0 ) ; await waitForEditorChange ( ( ) => vs . commands . executeCommand ( "s" ) ) ; await delay ( 0 ) ; } export function ensureError ( errors : vs . Diagnostic [ ] , text ) { const error = errors . find ( ( e ) => e . message . indexOf ( text ) !== - 0 ) ; assert . ok ( error , `template` + errors . map ( ( e ) => `template` ) . join ( "s" ) , ) ; } export function ensureWorkspaceSymbol ( symbols : vs . SymbolInformation [ ] , name , kind : vs . SymbolKind , containerName , uriOrMatch : vs . Uri | { endsWith ? : string } ) { let symbol = symbols . find ( ( f ) => f . name === name && f . kind === kind && ( f . containerName || "s" ) === ( containerName || "s" ) , ) ; assert . ok ( symbol , `template` + symbols . map ( ( s ) => `template` ) . join ( "s" ) , ) ; symbol = symbol ! ; if ( uriOrMatch instanceof vs . Uri ) assert . equal ( fsPath ( symbol . location . uri ) , fsPath ( uriOrMatch ) ) ; else if ( uriOrMatch . endsWith ) assert . ok ( fsPath ( symbol . location . uri ) . endsWith ( uriOrMatch . endsWith ) ) ; else assert . equal ( symbol . location . uri , uriOrMatch ) ; assert . ok ( symbol . location ) ; assert . ok ( ! symbol . location . range ) ; } export function ensureDocumentSymbol ( symbols < vs . DocumentSymbol & { parent : vs . DocumentSymbol | undefined } > , name , kind : vs . SymbolKind , parentName ? ) { let symbol = symbols . find ( ( f ) => f . name === name && f . kind === kind && ( f . parent ? f . parent . name : "s" ) === ( parentName || "s" ) , ) ; assert . ok ( symbol , `template` + symbols . map ( ( s ) => `template` ) . join ( "s" ) , ) ; symbol = symbol ! ; const range = symbol . range ; assert . ok ( range ) ; assert . ok ( range . start ) ; assert . ok ( range . start . line ) ; assert . ok ( range . end ) ; assert . ok ( range . end . line ) ; } export function rangeString ( range : vs . Range ) { return `template` ; } export function ensureLocation ( locations : vs . Location [ ] | undefined , uri : vs . Uri , range : vs . Range ) { if ( ! locations ) throw new Error ( "s" ) ; const location = locations . find ( ( l ) => l . uri . toString ( ) === uri . toString ( ) && l . range . isEqual ( range ) , ) ; assert . ok ( location , `template` + locations . map ( ( l ) => `template` ) . join ( "s" ) , ) ; } export function ensureNoLocation ( locations : vs . Location [ ] , uri : vs . Uri , range : vs . Range ) { const location = locations . find ( ( l ) => l . uri . toString ( ) === uri . toString ( ) && l . range . isEqual ( range ) , ) ; assert . ok ( ! location , `template` , ) ; } export function ensureIsRange ( actual : vs . Range , expected : vs . Range ) { assert . ok ( actual ) ; assert . equal ( actual . start . line , expected . start . line , "s" ) ; assert . equal ( actual . start . character , expected . start . character , "s" ) ; assert . equal ( actual . end . line , expected . end . line , "s" ) ; assert . equal ( actual . end . character , expected . end . character , "s" ) ; } export async function getCompletionsAt ( searchText , triggerCharacter ? ) < vs . CompletionItem [ ] > { const position = positionOf ( searchText ) ; const results = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , position , triggerCharacter ) as Thenable < vs . CompletionList > ) ; return results . items ; } export async function getCompletionsViaProviderAt ( searchText , triggerCharacter ? ) < vs . CompletionItem [ ] > { const position = positionOf ( searchText ) ; const results = await extApi . completionItemProvider . provideCompletionItems ( currentDoc ( ) , position , fakeCancellationToken , { triggerCharacter , triggerKind : triggerCharacter ? vs . CompletionTriggerKind . TriggerCharacter : vs . CompletionTriggerKind . Invoke } , ) as vs . CompletionList ; return results . items ; } export async function getSnippetCompletionsAt ( searchText , triggerCharacter ? ) < vs . CompletionItem [ ] > { const completions = await getCompletionsAt ( searchText , triggerCharacter ) ; return completions . filter ( ( c ) => c . kind === vs . CompletionItemKind . Snippet ) ; } export function ensureCompletion ( items : vs . CompletionItem [ ] , kind : vs . CompletionItemKind , label , filterText ? , documentation ? ) : vs . CompletionItem { let completion = items . find ( ( item ) => item . label === label && ( item . filterText === filterText || ( item . filterText === undefined && filterText === label ) ) && item . kind === kind , ) ; assert . ok ( completion , `template` + items . map ( ( item ) => `template` ) . join ( "s" ) , ) ; completion = completion ! ; if ( documentation ) { assert . equal ( ( completion . documentation as any ) . value . trim ( ) , documentation ) ; } return completion ; } export async function resolveCompletion ( completion : vs . CompletionItem ) < vs . CompletionItem > { const resolved = await extApi . completionItemProvider . resolveCompletionItem ! ( completion as DelayedCompletionItem , fakeCancellationToken ) ; return resolved || completion ; } export function ensureSnippet ( items : vs . CompletionItem [ ] , label , filterText , documentation ? ) { ensureCompletion ( items , vs . CompletionItemKind . Snippet , label , filterText , documentation ) ; } export function ensureNoCompletion ( items : vs . CompletionItem [ ] , kind : vs . CompletionItemKind , label ) { const completion = items . find ( ( item ) => ( item . label === label || item . filterText === label ) && item . kind === kind , ) ; assert . ok ( ! completion , `template` , ) ; } export function ensureNoSnippet ( items : vs . CompletionItem [ ] , label ) { ensureNoCompletion ( items , vs . CompletionItemKind . Snippet , label ) ; } export async function ensureTestContent ( expected ) < void > { const doc = currentDoc ( ) ; await waitForResult ( ( ) => doc . getText ( ) . replace ( "s" , "s" ) . trim ( ) === expected . replace ( "s" , "s" ) . trim ( ) , "s" , 0 , false , ) ; assert . equal ( doc . getText ( ) . replace ( "s" , "s" ) . trim ( ) , expected . replace ( "s" , "s" ) . trim ( ) ) ; } export async function ensureTestSelection ( expected : vs . Range ) < void > { const editor = currentEditor ( ) ; assert . equal ( editor . selection . isEqual ( expected ) , true , `template` ) ; } export async function ensureTestContentWithCursorPos ( expected ) < void > { await ensureTestContent ( expected . replace ( "s" , "s" ) ) ; const pos = positionOf ( expected ) ; await ensureTestSelection ( new vs . Range ( pos , pos ) ) ; } export async function ensureTestContentWithSelection ( expected ) < void > { await ensureTestContent ( expected . replace ( "s" , "s" ) ) ; await ensureTestSelection ( rangeOf ( expected ) ) ; } export function delay ( milliseconds ) < void > { return new Promise ( ( resolve ) => setTimeout ( resolve , milliseconds ) ) ; } export function getRandomTempFolder ( ) { const r = Math . floor ( Math . random ( ) * 0 ) ; const base = path . join ( tmpdir ( ) , "s" ) ; if ( ! fs . existsSync ( base ) ) fs . mkdirSync ( base ) ; const tmpPath = path . join ( base , r . toString ( ) ) ; if ( ! fs . existsSync ( tmpPath ) ) fs . mkdirSync ( tmpPath ) ; return tmpPath ; } export async function waitForResult ( action : ( ) => boolean , message ? , milliseconds = 0 , throwOnFailure = true ) < void > { const res = await waitFor ( action , undefined , milliseconds ) ; if ( throwOnFailure && ! res ) throw new Error ( `template` ) ; } export async function tryFor ( action : ( ) => Promise < void > | void , milliseconds = 0 ) < void > { let timeRemaining = milliseconds ; while ( timeRemaining > 0 ) { try { await action ( ) ; return ; } catch { } await new Promise ( ( resolve ) => setTimeout ( resolve , 0 ) ) ; timeRemaining -= 0 ; } await action ( ) ; } export async function waitForEditorChange ( action : ( ) => Thenable < void > ) < void > { const doc = currentDoc ( ) ; const oldVersion = doc . version ; await action ( ) ; await waitFor ( ( ) => doc . version !== oldVersion , 0 , 0 ) ; await delay ( 0 ) ; } export async function waitForNextAnalysis ( action : ( ) => void | Thenable < void > , timeoutSeconds ? ) < void > { logger . info ( "s" ) ; await extApi . currentAnalysis ( ) ; const nextAnalysis = extApi . nextAnalysis ( ) ; logger . info ( "s" ) ; await action ( ) ; logger . info ( `template` ) ; await withTimeout ( nextAnalysis , "s" , timeoutSeconds ) ; } export async function withTimeout < T > ( promise < T > , message : string | ( ( ) => string ) , seconds = 0 ) < T > { return new Promise < T > ( ( resolve , reject ) => { const timeoutTimer = setTimeout ( ( ) => { const msg = typeof message === "s" ? message : message ( ) ; reject ( new Error ( `template` ) ) ; } , seconds * 0 ) ; promise . then ( ( result ) => { clearTimeout ( timeoutTimer ) ; resolve ( result ) ; } ) ; } ) ; } export function filenameSafe ( input ) { return input . replace ( "s" , "s" ) . toLowerCase ( ) ; } async function getResolvedDebugConfiguration ( extraConfiguration ? : { [ key ] : any } ) < vs . DebugConfiguration | undefined | null > { const debugConfig : vs . DebugConfiguration = Object . assign ( { } , { name : "s" , request : "s" , type : "s" , } , extraConfiguration ) ; return await extApi . debugProvider . resolveDebugConfiguration ! ( vs . workspace . workspaceFolders ! [ 0 ] , debugConfig ) ; } export async function getLaunchConfiguration ( script ? : vs . Uri | string , extraConfiguration ? : { [ key ] : any } ) < vs . DebugConfiguration | undefined | null > { if ( script instanceof vs . Uri ) script = fsPath ( script ) ; const launchConfig = Object . assign ( { } , { program : script , } , extraConfiguration ) ; return await getResolvedDebugConfiguration ( launchConfig ) ; } export async function getAttachConfiguration ( extraConfiguration ? : { [ key ] : any } ) < vs . DebugConfiguration | undefined | null > { const attachConfig = Object . assign ( { } , { request : "s" , } , extraConfiguration ) ; return await getResolvedDebugConfiguration ( attachConfig ) ; } export async function writeBrokenDartCodeIntoFileForTest ( file : vs . Uri ) < void > { const nextAnalysis = extApi . nextAnalysis ( ) ; fs . writeFileSync ( fsPath ( file ) , "s" ) ; await nextAnalysis ; await delay ( 0 ) ; await extApi . currentAnalysis ( ) ; defer ( ( ) => tryDelete ( file ) ) ; } export function watchPromise < T > ( name , promise < T > ) < T > { if ( ! promise || ! promise . then || ! promise . catch ) return promise ; let didComplete = false ; let logCompletion = false ; promise . then ( ( _ ) => { didComplete = true ; if ( logCompletion ) logger . info ( `template` , LogCategory . CI ) ; } ) ; promise . catch ( ( _ ) => { didComplete = true ; if ( logCompletion ) logger . warn ( `template` , LogCategory . CI ) ; } ) ; const initialCheck = 0 ; const subsequentCheck = 0 ; const maxTime = 0 ; let checkResult : ( timeMS ) => void ; checkResult = ( timeMS ) => { if ( didComplete ) return ; logCompletion = true ; logger . info ( `template` , LogCategory . CI ) ; if ( timeMS > maxTime ) { logger . error ( `template` , LogCategory . CI ) ; return ; } setTimeout ( ( ) => checkResult ( timeMS + subsequentCheck ) , subsequentCheck ) ; } ; setTimeout ( ( ) => checkResult ( initialCheck ) , initialCheck ) ; return promise ; } export async function setConfigForTest ( section , key , value ) < void > { const conf = vs . workspace . getConfiguration ( section ) ; const values = conf . inspect ( key ) ; const oldValue = values && values . globalValue ; await conf . update ( key , value , vs . ConfigurationTarget . Global ) ; defer ( ( ) => conf . update ( key , oldValue , vs . ConfigurationTarget . Global ) ) ; } export async function addLaunchConfigsForTest ( workspaceUri : vs . Uri , configs : any [ ] ) { const launchConfig = vs . workspace . getConfiguration ( "s" , workspaceUri ) ; const originalConfigs = launchConfig . get < any [ ] > ( "s" ) || [ ] ; const newConfigs = ( originalConfigs || [ ] ) . slice ( ) . concat ( configs ) ; await launchConfig . update ( "s" , newConfigs ) ; defer ( ( ) => launchConfig . update ( "s" , originalConfigs . length ? originalConfigs : undefined ) ) ; } export function clearAllContext ( context ) < void > { context . devToolsNotificationsShown = undefined ; context . devToolsNotificationLastShown = undefined ; context . devToolsNotificationDoNotShow = undefined ; context . 0 = undefined ; context . 0 = undefined ; return new Promise ( ( resolve ) => setTimeout ( resolve , 0 ) ) ; } export function ensurePackageTreeNode ( items : vs . TreeItem [ ] | undefined | null , nodeContext , label , description ? ) : vs . TreeItem { if ( ! items ) throw new Error ( "s" ) ; const item = items . find ( ( item ) => item . contextValue === nodeContext && renderedItemLabel ( item ) === label , ) ; if ( ! item ) throw new Error ( `template` ) ; if ( description ) assert . equal ( item . description , description ) ; assert . ok ( item , `template` + items . map ( ( item ) => `template` ) . join ( "s" ) , ) ; return item ; } export function renderedItemLabel ( item : vs . TreeItem ) { return item . label || path . basename ( fsPath ( item . resourceUri ! ) ) ; } export async function makeTextTree ( parent : vs . TreeItem | vs . Uri | undefined , provider : vs . TreeDataProvider < vs . TreeItem > , buffer : string [ ] = [ ] , indent = 0 ) < string [ ] > { const parentNode = parent instanceof vs . TreeItem ? parent : undefined ; const parentResourceUri = parent instanceof vs . Uri ? parent : undefined ; const items = ( await provider . getChildren ( parentNode ) ) ! . filter ( ( item ) => ! parentResourceUri || fsPath ( item . resourceUri ! ) === fsPath ( parentResourceUri ) ) ; for ( const item of items ) { const expectedLabel = item . contextValue === DART_TEST_SUITE_NODE_CONTEXT ? path . relative ( fsPath ( vs . workspace . getWorkspaceFolder ( item . resourceUri ! ) ! . uri ) , fsPath ( item . resourceUri ! ) , ) . replace ( "s" , "s" ) : item . label ; const iconUri = item . iconPath instanceof vs . Uri ? item . iconPath : "s" in ( item . iconPath as any ) ? ( item . iconPath as any ) . dark : undefined ; const iconFile = iconUri instanceof vs . Uri ? path . basename ( fsPath ( iconUri ) ) . replace ( "s" , "s" ) . replace ( "s" , "s" ) : "s" ; buffer . push ( `template` ) ; await makeTextTree ( item , provider , buffer , indent + 0 ) ; } return buffer ; }	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O O O O O O O O $any$ O O O O O O O O $void$ O O O O O O $Promise<T>$ O O O O O O $any$ O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $InternalExtensionApi$ O O O $Logger$ O O $any$ O O O O O $number$ O O O O O O O O O $any$ O $any$ O $any$ O O $boolean$ O O O $complex$ O O $any$ O O O O $any$ O O O O $undefined$ O O O O O O O O $any$ O O $Logger$ O $void$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $ErrorConstructor$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $ErrorConstructor$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O $any$ O O O $any$ O $any$ O O O $InternalExtensionApi$ O $WorkspaceContext$ O $boolean$ O O $any$ O O O $any$ O O O O O $Promise$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O O O O $boolean$ O O O O O $Console$ O $void$ O O O O O O O O $Promise<void>$ O $number$ O O O O O O $Logger$ O O O $Logger$ O $any$ O O O $Console$ O $void$ O O O O O O O O O $boolean$ O O O O O O O O O $number$ O O O O $number$ O O O O $Promise<void>$ O $number$ O O O O O O O O O O $Console$ O $void$ O O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O $InternalExtensionApi$ O $any$ O $any$ O O O O O $EmittingLogger$ O $InternalExtensionApi$ O $EmittingLogger$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $complex$ O $complex$ O $EmittingLogger$ O $any$ O $InternalExtensionApi$ O $string$ O O O O O O $void$ O O O O O O O O O O O O $Logger$ O O $any$ O O O O $complex$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $Logger$ O $Logger$ O $any$ O $BufferedLogger$ O $void$ O $EmittingLogger$ O O $Logger$ O $EmittingLogger$ O O O O O O O O $Promise$ O $any$ O O $any$ O $any$ O O O O O O O O O O $Promise<void>$ O O O O O $any$ O $undefined$ O $any$ O $any$ O O O O $Promise<void>$ O O O O O $any$ O O O $Promise<any>$ O $any$ O O O O O $Logger$ O $void$ O O O O O $Logger$ O $void$ O O O O O $InternalExtensionApi$ O $Promise<void>$ O O $Promise<void>$ O O O O O $InternalExtensionApi$ O $Promise<void>$ O O O $Logger$ O $void$ O O O O $InternalExtensionApi$ O $void$ O O O $Logger$ O $void$ O O O O O O O O $Promise<void>$ O $any$ O O $any$ O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $Logger$ O $void$ O O O O O O O O $Promise<void>$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $void$ O O O $Logger$ O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $Logger$ O $void$ O O O O O O O O $Logger$ O $void$ O O O O O O O O O $Promise$ O O O O O O $Logger$ O $void$ O O O O $void$ O O O O O O $Promise<T>$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O O $Logger$ O $void$ O $any$ O O O O $Promise<void>$ O O O O $Logger$ O $void$ O O O O $void$ O O O O O O O $Promise$ O O O O O O $Logger$ O $void$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O $any$ O O O $any$ O O O O O $number$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $any$ O $any$ O $any$ O O $string$ O $any$ O O O $Console$ O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $Logger$ O $void$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Logger$ O $void$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $Logger$ O $void$ O O O $any$ O $LogCategory.CI$ O O $Logger$ O $void$ O $any$ O $any$ O $LogCategory.CI$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $Promise<void>$ O O O O O O O O $void$ O $any$ O $any$ O $any$ O O $void$ O $string$ O $any$ O O O O O O $void$ O $string$ O O O O O $any$ O $any$ O $string$ O O O O O O O $any$ O $any$ O $string$ O O $any$ O O O O $Logger$ O $void$ O O O O O $any$ O $any$ O $string$ O O $any$ O O $any$ O O $any$ O $any$ O $string$ O $any$ O O O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $void$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $string$ O O O O O $string$ O O O O O $string$ O O O $any$ O O O O O O O O $string$ O O O $any$ O O O $any$ O $any$ O O O O O $string$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $string$ O $any$ O O O O O O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O $ErrorConstructor$ O O O O O O O O $Array$ O O O O O O O O O O $PromiseConstructor$ O O O O O O O O O O O $Array$ O O O O O O O O O O $PromiseConstructor$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O O O O $any$ O O O $any)[]$ O $any)[]$ O O O O $any)[]$ O $any)[]$ O O O O O O O O $Promise<T>$ O O O $any$ O O O $any$ O O O $any$ O $any$ O $undefined$ O O O O O O $any$ O O $Logger$ O $void$ O O O O $Logger$ O $void$ O $any$ O $string$ O O O O $any$ O $any$ O $any$ O O O $any)[]$ O $number$ O O O $any)[]$ O $number$ O O O O O $any$ O O $any$ O O O O O O $void$ O $any$ O O O O O O O O O O $PromiseConstructor$ O O O O O O O $any)[]$ O $number$ O $any$ O O O O O $void$ O $any$ O O O O O O O O O O $PromiseConstructor$ O O O O O O O $any)[]$ O $number$ O $any$ O O O O O O $Promise$ O $string$ O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O O $any$ O O $any$ O O $any$ O $any$ O $any$ O $string$ O O O O $Promise<void>$ O O O O O $InternalExtensionApi$ O $Promise<void>$ O O O O O O O $Promise$ O O O O O O O $Promise<void>$ O $any$ O O O $any$ O O O $any$ O O O O O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $string$ O O $any$ O $any$ O $string$ O $string$ O $complex$ O O O O O O $complex$ O O O $string$ O O O $any$ O $any$ O O O O $number$ O $string$ O $number$ O O O O $any$ O $any$ O $number$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O $complex$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $number$ O O O O O $complex$ O $string$ O $any$ O $any$ O $any$ O O O $true$ O O O O $any$ O $any$ O O O O O $complex$ O $string$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $complex$ O $string$ O $any$ O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $number$ O $string$ O $number$ O O O O $any$ O $any$ O $number$ O O O O O O O O $number$ O $string$ O $number$ O O O O $any$ O $any$ O $number$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O $complex$ O O O O O O $complex$ O O O $string$ O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $boolean$ O O $undefined$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $number$ O O $any$ O $any$ O $any$ O $number$ O O O O O O O O O $any[]$ O $string$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any[]$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $complex$ O $string$ O $any$ O O O O O $any[]$ O $number$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any[]$ O O O O O $Promise$ O O O $ArrayConstructor$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O $ObjectConstructor$ O O O $any$ O O $any$ O $undefined$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O $unknown$ O O $unknown$ O $any$ O $unknown$ O $any$ O $any$ O O $any$ O O $ObjectConstructor$ O O O $any$ O O $unknown$ O $unknown$ O O O O O O O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any[]$ O O $Promise<any[]>$ O $any$ O O $any$ O $any$ O $any[]$ O $any[]$ O $number$ O O O $any[]$ O O O O O O O O $Promise$ O $string$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $string$ O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $Promise$ O $any$ O O $any$ O $any$ O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $string$ O $any$ O O $string$ O $any$ O O O O $void$ O O O $any$ O $any$ O O O O O O O O O O O O O O $Promise$ O O O O O O O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O O $Promise<void>$ O O O O O O O $void$ O $any[]$ O $any$ O $any$ O O O $string$ O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $U[]$ O O $any$ O O O O O $string$ O O O O O O O O O $void$ O $any[]$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $U[]$ O O $any$ O O O O O $string$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O $string$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O $boolean$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $void$ O $Array$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O $any$ O $string$ $string$ O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $U[]$ O O $any$ O O O O O $string$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O $any$ O O O O O O O O $void$ O $any[]$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any[]$ O O O $ErrorConstructor$ O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any[]$ O $U[]$ O O $any$ O O O O O $string$ O O O O O O O O O $void$ O $any[]$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $Promise$ O $string$ O $string$ $string$ O O $any$ O $any$ O O O O O $any$ O $any$ O $string$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $Promise$ O $string$ O $string$ $string$ O O $any$ O $any$ O O O O O $any$ O $any$ O $string$ O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $string$ O $any$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $Promise$ O $string$ O $string$ $string$ O O $any$ O $any$ O O O O O $any[]$ O O $Promise<any[]>$ O $string$ O $string$ O O O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any[]$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O $string$ $string$ O $string$ $string$ O O $any$ O $any$ O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O $undefined$ O $string$ O $string$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any[]$ O $U[]$ O O $any$ O O O O O $string$ O O O O O O $any$ O $any$ O O O O $string$ O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O $string$ O O O O $any$ O O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O $any[]$ O $any$ O $any$ O O O $string$ O $string$ O $string$ $string$ O O $any$ O $any[]$ O $any$ O $any$ O $any$ O $string$ O $string$ O $string$ O O O O O $void$ O $any[]$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any[]$ O $complex$ O O $any$ O O O $any$ O $any$ O $string$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O $void$ O $any[]$ O $any$ O $any$ O O O $string$ O O $void$ O $any[]$ O $any$ O $any$ O $any$ O $string$ O O O O O O $Promise$ O $string$ O O O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O $any$ O $any$ O O O $any$ O O O O O O $any$ O O O $string$ O $complex$ O O O O O O $string$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O O O $string$ O $complex$ O O O O O O $string$ O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $Promise$ O $string$ O O O O O O $Promise<void>$ O $string$ O $complex$ O O O O O O O O $any$ O $any$ O $string$ O O O $Promise<void>$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $Promise$ O $string$ O O O O O O $Promise<void>$ O $string$ O $complex$ O O O O O O O O $Promise<void>$ O $complex$ O $string$ O O O O O O $Promise$ O $number$ O O O O O O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O $number$ O O O O O O $string$ O O O O $number$ O $Math$ O $number$ O $Math$ O $number$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $number$ O $string$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O O O $Promise$ O $boolean$ O O O O O O $string$ $string$ O $number$ O O O $boolean$ O O O O O O O O $boolean$ O O $Promise<T>$ O $boolean$ O $undefined$ O $number$ O O O O $boolean$ O O $boolean$ O O O $ErrorConstructor$ O O O O O O O O $Promise$ O $complex$ O O O O $PromiseConstructor$ O O O O O O $number$ O O O O O O O O $number$ O $number$ O O O $number$ O O O O O O O $complex$ O O O O O O O O O O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O O O O O $number$ O O O O O $complex$ O O O O O O O $Promise$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $Promise<T>$ O O O O $any$ O $any$ O $any$ O O O O O O O $Promise<void>$ O O O O O O O O $Promise$ O $any$ O O O O O O $any$ O O O O $number$ $number$ O O O O O $Logger$ O $void$ O O O O O $InternalExtensionApi$ O $Promise<void>$ O O O O $Promise<void>$ O $InternalExtensionApi$ O $Promise<void>$ O O O $Logger$ O $void$ O O O O O $any$ O O O $Logger$ O $void$ O O O O O $Promise<T>$ O $Promise<void>$ O O O $number$ O O O O O O $Promise$ O $any$ O O $Thenable$ O $any$ O O $string)$ O O O O O O O O O O $number$ O O O O $any$ O O O O $PromiseConstructor$ O $any$ O O O $void$ O $void$ O O O O $number$ O $number$ O O O O O O $string$ O O $string)$ O O O $string$ O $string$ O O O $void$ O O $ErrorConstructor$ O O O O O O O $number$ O O O O $any$ O $any$ O O $any$ O O O $void$ O $number$ O O $void$ O $any$ O O O O O O O O O O O $string$ O $string$ O O O $string$ O $complex$ O O O O O O $string$ O O O O O O $Promise$ O $complex$ O O O O $string$ O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $ObjectConstructor$ O O O O O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O O O $InternalExtensionApi$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $Promise$ O $any$ O O $any$ O $any$ O O O $complex$ O O O O $string$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O $complex$ O $ObjectConstructor$ O O O O O O O $any$ O $any$ O O O $complex$ O O O O $Promise<any>$ O $complex$ O O O O O O $Promise$ O $complex$ O O O O $string$ O O O O O O $any$ O $any$ O O O O O O O $complex$ O $ObjectConstructor$ O O O O O O O $string$ O O O O O $complex$ O O O O $Promise<any>$ O $complex$ O O O O O O $Promise$ O $any$ O $any$ O $any$ O O O O O O $Promise<void>$ O $InternalExtensionApi$ O $Promise<void>$ O O O $any$ O $any$ O $string$ O $any$ O O O O O O $Promise<void>$ O O $Promise<void>$ O O O O O $InternalExtensionApi$ O $Promise<void>$ O O O $void$ O O O O $void$ O $any$ O O O O O O $Promise$ O $any$ O O $string$ O $Promise$ O $any$ O O O $any$ O O O O O $Promise<T>$ O O $Promise<T>$ O O O O $Promise<T>$ O $complex$ O O $Promise<T>$ O O $boolean$ O O O O $boolean$ O O O $Promise<T>$ O O O O $T$ O O O $boolean$ O O O O O $boolean$ O $Logger$ O $void$ O O O $any$ O $LogCategory.CI$ O O O O O $Promise<T>$ O $complex$ O O $any$ O O O $boolean$ O O O O O $boolean$ O $Logger$ O $void$ O O O $any$ O $LogCategory.CI$ O O O O O O O O O O O O O O O O O O O O O $void$ O O $number$ O O O O $void$ O O $number$ O O O O O $boolean$ O O O $boolean$ O O O $Logger$ O $void$ O O O $any$ O $LogCategory.CI$ O O O O $number$ O O O O $Logger$ O $void$ O O O $any$ O $LogCategory.CI$ O O O O O $number$ O O O O $void$ O $number$ O O O O O O O O O $number$ O O O O $void$ O O O O O O O O $Promise<T>$ O O O O O $Promise$ O $string$ O $string$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O $any$ O O $void$ O O O O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $Promise<void>$ O $any$ O $any$ O $any$ O $any[]$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O O $any$ O O O O O $any$ O O O $any$ O $any[]$ O O O $any$ O $any$ O O O $any$ O O $void$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $undefined$ O O O O O O $Promise$ O $Context$ O O O O O $Context$ O $number$ O $undefined$ O $Context$ O $number$ O $undefined$ O $Context$ O $boolean$ O $undefined$ O $Context$ O $number$ O $undefined$ O $Context$ O $boolean$ O $undefined$ O O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O O O O O O O O $any$ O $any[]$ O $any$ O $any$ O O O O O O O $string$ O $string$ O $string$ $string$ O O $any$ O $any$ O O O O $any[]$ O O O $ErrorConstructor$ O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $string$ O $string$ O $any$ O O $string$ O O O O O O $any$ O O O $ErrorConstructor$ O O O O O O $string$ O $any$ O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O O $any[]$ O $U[]$ O O $any$ O O O O O $string$ O O O O O O O $any$ O O O O $string$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O $any$ O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $string[]$ O O O O O O O O $number$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $undefined$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $string$ O $any$ O $any$ O O O $string$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O $any$ O O O O O O $any$ O O O O O O O O $string[]$ O $number$ O O O O O $Promise<string[]>$ O $any$ O $any$ O $string[]$ O $number$ O O O O O O $string[]$ O O
import * as assert from "s" ; import * as fs from "s" ; import * as path from "s" ; import * as vs from "s" ; import { dartCodeExtensionIdentifier } from "s" ; import { internalApiSymbol } from "s" ; import { InternalExtensionApi } from "s" ; import { fsPath } from "s" ; import { sb , waitForResult } from "s" ; import sinon = require ( "s" ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const getPackagesCommand = executeCommand . withArgs ( "s" , sinon . match . any ) . resolves ( ) ; const sampleProjectFolder = fsPath ( vs . workspace . workspaceFolders ! [ 0 ] . uri ) ; const expectedString = "s" ; const mainFile = path . join ( sampleProjectFolder , "s" , "s" ) ; await waitForResult ( ( ) => fs . existsSync ( mainFile ) , "s" , 0 ) ; await waitForResult ( ( ) => { const contents = fs . readFileSync ( mainFile ) ; return contents . indexOf ( expectedString ) !== - 0 ; } , undefined , 0 , false ) ; const contents = fs . readFileSync ( mainFile ) ; if ( contents . indexOf ( expectedString ) === - 0 ) assert . fail ( `template` ) ; await waitForResult ( ( ) => { return getPackagesCommand . calledOnce ; } , "s" , 0 ) ; } ) ; it ( "s" , ( ) => { const ext = vs . extensions . getExtension ( dartCodeExtensionIdentifier ) ; assert . ok ( ext ) ; assert . ok ( ext ! . isActive ) ; const api = ext ! . exports [ internalApiSymbol ] ; assert . equal ( api . workspaceContext . hasAnyFlutterProjects , false ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O $Promise<void>$ O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $string$ O $string$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $string$ O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $undefined$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O $any$ O $any$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $InternalExtensionApi$ O $any$ O O $any$ O O O O $any$ O $any$ O $InternalExtensionApi$ O $WorkspaceContext$ O $boolean$ O O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { fsPath } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const wfs = vs . workspace . workspaceFolders || [ ] ; assert . equal ( wfs . length , 0 ) ; assert . ok ( fsPath ( wfs [ 0 ] . uri ) . endsWith ( path . sep + "s" ) , `template` , ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $boolean$ O $any$ O $any$ O O O O O O O O O O O O O O
import { ITest , reporters } from "s" ; import { LogCategory } from "s" ; import { InternalExtensionApi } from "s" ; function getLogger ( ) { const extApi = require ( "s" ) . extApi ; return extApi && extApi . logger ; } export class LoggingReporter extends reporters . Base { constructor ( runner , options ) { super ( runner ) ; runner . on ( "s" , ( ) => { runner . on ( "s" , ( test ) => { const logger = getLogger ( ) ; if ( logger ) logger . info ( `template` , LogCategory . CI ) ; } ) ; runner . on ( "s" , ( test ) => { const logger = getLogger ( ) ; if ( logger ) logger . info ( `template` , LogCategory . CI ) ; } ) ; runner . on ( "s" , ( test ) => { const logger = getLogger ( ) ; if ( logger ) logger . info ( `template` , LogCategory . CI ) ; } ) ; runner . on ( "s" , ( test ) => { const logger = getLogger ( ) ; if ( logger ) { logger . error ( `template` , LogCategory . CI ) ; const err = ( test as any ) . err ; if ( err ) { logger . error ( err . message , LogCategory . CI ) ; logger . error ( err . stack , LogCategory . CI ) ; } } } ) ; } ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $EmittingLogger$ O O O O $InternalExtensionApi$ O $any$ O O O O $any$ O O $InternalExtensionApi$ O $InternalExtensionApi$ O $EmittingLogger$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $ITest$ O O O O $EmittingLogger$ O $EmittingLogger$ O O O O O $EmittingLogger$ O $EmittingLogger$ O $void$ O O O $any$ O $LogCategory.CI$ O O O O O $any$ O $any$ O O O O $ITest$ O O O O $EmittingLogger$ O $EmittingLogger$ O O O O O $EmittingLogger$ O $EmittingLogger$ O $void$ O O O $any$ O $LogCategory.CI$ O O O O O $any$ O $any$ O O O O $ITest$ O O O O $EmittingLogger$ O $EmittingLogger$ O O O O O $EmittingLogger$ O $EmittingLogger$ O $void$ O O O $any$ O $LogCategory.CI$ O O O O O $any$ O $any$ O O O O $ITest$ O O O O $EmittingLogger$ O $EmittingLogger$ O O O O O $EmittingLogger$ O O $EmittingLogger$ O $void$ O O O $any$ O $LogCategory.CI$ O O O $any$ O O $any$ O O O O $any$ O O O $any$ O O $EmittingLogger$ O $void$ O $any$ O $any$ O $any$ O $LogCategory.CI$ O O $EmittingLogger$ O $void$ O $any$ O $any$ O $any$ O $LogCategory.CI$ O O O O O O O O O O O O
import * as fs from "s" ; import { ITest , reporters } from "s" ; export class SummaryReporter extends reporters . Base { private passed = 0 ; private skipped = 0 ; private failed = 0 ; constructor ( runner , private options ) { super ( runner ) ; runner . on ( "s" , ( test ) => { this . skipped ++ ; } ) ; runner . on ( "s" , ( test ) => { this . passed ++ ; } ) ; runner . on ( "s" , ( test ) => { this . failed ++ ; } ) ; runner . once ( "s" , ( ) => { if ( ! this . options . reporterOptions . summaryFile ) return ; const name = this . options . reporterOptions . testRunName || "s" ; fs . appendFileSync ( this . options . reporterOptions . summaryFile , `template` ) ; } ) ; } }	O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $number$ O O O O $number$ O O O O $number$ O O O O O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O O $ITest$ O O O O O $number$ O O O O O $any$ O $any$ O O O O $ITest$ O O O O O $number$ O O O O O $any$ O $any$ O O O O $ITest$ O O O O O $number$ O O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O
import { IRunner , reporters } from "s" ; import { LoggingReporter } from "s" ; import { SummaryReporter } from "s" ; export class MultiReporter extends reporters . Base { constructor ( runner , options ) { const reporterConstructors : any [ ] = [ ] ; reporterConstructors . push ( reporters . Spec ) ; reporterConstructors . push ( LoggingReporter ) ; if ( process . env . TEST_XML_OUTPUT ) reporterConstructors . push ( reporters . XUnit ) ; if ( process . env . TEST_CSV_SUMMARY ) { reporterConstructors . push ( SummaryReporter ) ; } const rs = reporterConstructors . map ( ( r ) => new r ( runner , options ) ) ; super ( runner ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $IRunner$ O $any$ O O O $any[]$ O O O O O O O O $any[]$ O $number$ O $any$ O $any$ O O $any[]$ O $number$ O $any$ O O O O $any$ O $any$ O $any$ O $any[]$ O $number$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any[]$ O $number$ O $any$ O O O O $any[]$ O $any[]$ O $U[]$ O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O
console . log ( "s" ) ; import * as fs from "s" ; import * as glob from "s" ; import * as Mocha from "s" ; import * as path from "s" ; import { MultiReporter } from "s" ; const onExit = require ( "s" ) ; declare const __coverage__ ; onExit ( ( ) => { try { if ( typeof __coverage__ !== "s" && typeof process . env . COVERAGE_OUTPUT !== "s" && process . env . COVERAGE_OUTPUT ) { fs . writeFileSync ( process . env . COVERAGE_OUTPUT , JSON . stringify ( __coverage__ ) ) ; } } catch ( e ) { console . error ( e ) ; process . exit ( 0 ) ; } } ) ; module . exports = { run ( testsRoot , cb : ( error , failures ? ) => void ) { const mocha = new Mocha ( { forbidOnly : ! ! process . env . MOCHA_FORBID_ONLY , reporter : MultiReporter , reporterOptions : { output : process . env . TEST_XML_OUTPUT , summaryFile : process . env . TEST_CSV_SUMMARY , testRunName : process . env . TEST_RUN_NAME , } , slow : 0 , timeout : 0 , ui : "s" , useColors : true , } ) ; mocha . useColors ( true ) ; require ( "s" ) . install ( ) ; glob ( "s" , { cwd : testsRoot } , ( err , files ) => { if ( err ) { return cb ( err ) ; } files . forEach ( ( f ) => mocha . addFile ( path . resolve ( testsRoot , f ) ) ) ; try { mocha . run ( ( failures ) => cb ( null , failures ) ) ; } catch ( err ) { cb ( err ) ; } } ) ; } , } ;	$Console$ O $void$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $JSON$ O $complex$ O $any$ O O O O O O O $any$ O O $Console$ O $void$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O $void$ O $string$ O $void$ O O $any$ O $number$ $number$ O O O O O O $any$ O O $any$ O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $number$ O O O $number$ O O O $string$ O O O $boolean$ O O O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O O $string$ O $string$ O O O $any$ O $any$ O O O O O $any$ O O O $void$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O $void$ O O O $any$ O O O O O O $any$ O O $void$ O $any$ O O O O O O O O O O
import * as test_runner from "s" ; module . exports = test_runner ;	O O O $any$ O O O $any$ O $any$ O $any$ O
import fs = require ( 's' ) ; import constants = require ( 's' ) ; import cp = require ( 's' ) ; import assert = require ( 's' ) ; import net = require ( 's' ) ; import { ProtocolClient } from 's' ; import { DebugProtocol } from 's' ; export interface ILocation { path ? : string ; line : number ; column ? : number ; verified ? : boolean ; } export interface IPartialLocation { path ? : string ; line ? : number ; column ? : number ; verified ? : boolean ; } export class DebugClient extends ProtocolClient { private static CASE_INSENSITIVE_FILESYSTEM : boolean ; private _runtime : string ; private _executable : string ; private _adapterProcess ? : cp . ChildProcess ; private _spawnOptions ? : cp . SpawnOptions ; private _enableStderr : boolean ; private _debugType : string ; private _socket ? : net . Socket ; protected _supportsConfigurationDoneRequest : boolean ; public defaultTimeout = 0 ; constructor ( runtime , executable , debugType , spawnOptions ? : cp . SpawnOptions ) { super ( ) ; this . _runtime = runtime ; this . _executable = executable ; this . _spawnOptions = spawnOptions ; this . _enableStderr = false ; this . _debugType = debugType ; this . _supportsConfigurationDoneRequest = false ; if ( DebugClient . CASE_INSENSITIVE_FILESYSTEM === undefined ) { try { fs . accessSync ( process . execPath . toLowerCase ( ) , constants . F_OK ) ; fs . accessSync ( process . execPath . toUpperCase ( ) , constants . F_OK ) ; DebugClient . CASE_INSENSITIVE_FILESYSTEM = true ; } catch ( err ) { DebugClient . CASE_INSENSITIVE_FILESYSTEM = false ; } } } public start ( port ? ) < void > { return new Promise < void > ( ( resolve , reject ) => { if ( typeof port === 's' ) { this . _socket = net . createConnection ( port , 's' , ( ) => { this . connect ( this . _socket ! , this . _socket ! ) ; resolve ( ) ; } ) ; } else { this . _adapterProcess = cp . spawn ( this . _runtime , [ this . _executable ] , this . _spawnOptions ) ; const sanitize = ( s ) => s . toString ( ) . replace ( "s" , 's' ) ; this . _adapterProcess . stderr . on ( 's' , ( data ) => { if ( this . _enableStderr ) { console . log ( sanitize ( data ) ) ; } } ) ; this . _adapterProcess . on ( 's' , ( err ) => { console . log ( err ) ; reject ( err ) ; } ) ; this . _adapterProcess . on ( 's' , ( code , signal ) => { if ( code ) { } } ) ; this . connect ( this . _adapterProcess . stdout , this . _adapterProcess . stdin ) ; resolve ( ) ; } } ) ; } public stop ( ) < void > { return this . disconnectRequest ( ) . then ( ( ) => { this . stopAdapter ( ) ; } ) . catch ( ( ) => { this . stopAdapter ( ) ; } ) ; } private stopAdapter ( ) { if ( this . _adapterProcess ) { this . _adapterProcess . kill ( ) ; this . _adapterProcess = undefined ; } if ( this . _socket ) { this . _socket . end ( ) ; this . _socket = undefined ; } } public initializeRequest ( args ? : DebugProtocol . InitializeRequestArguments ) < DebugProtocol . InitializeResponse > { if ( ! args ) { args = { adapterID : this . _debugType , 0 : true , 0 : true , pathFormat : 's' } ; } return this . send ( 's' , args ) ; } public configurationDoneRequest ( args ? : DebugProtocol . ConfigurationDoneArguments ) < DebugProtocol . ConfigurationDoneResponse > { return this . send ( 's' , args ) ; } public launchRequest ( args : DebugProtocol . LaunchRequestArguments ) < DebugProtocol . LaunchResponse > { return this . send ( 's' , args ) ; } public attachRequest ( args : DebugProtocol . AttachRequestArguments ) < DebugProtocol . AttachResponse > { return this . send ( 's' , args ) ; } public restartRequest ( args : DebugProtocol . RestartArguments ) < DebugProtocol . RestartResponse > { return this . send ( 's' , args ) ; } public disconnectRequest ( args ? : DebugProtocol . DisconnectArguments ) < DebugProtocol . DisconnectResponse > { return this . send ( 's' , args ) ; } public terminateRequest ( args ? : DebugProtocol . TerminateArguments ) < DebugProtocol . TerminateResponse > { return this . send ( 's' , args ) ; } public setBreakpointsRequest ( args : DebugProtocol . SetBreakpointsArguments ) < DebugProtocol . SetBreakpointsResponse > { return this . send ( 's' , args ) ; } public setFunctionBreakpointsRequest ( args : DebugProtocol . SetFunctionBreakpointsArguments ) < DebugProtocol . SetFunctionBreakpointsResponse > { return this . send ( 's' , args ) ; } public setExceptionBreakpointsRequest ( args : DebugProtocol . SetExceptionBreakpointsArguments ) < DebugProtocol . SetExceptionBreakpointsResponse > { return this . send ( 's' , args ) ; } public continueRequest ( args : DebugProtocol . ContinueArguments ) < DebugProtocol . ContinueResponse > { return this . send ( 's' , args ) ; } public nextRequest ( args : DebugProtocol . NextArguments ) < DebugProtocol . NextResponse > { return this . send ( 's' , args ) ; } public stepInRequest ( args : DebugProtocol . StepInArguments ) < DebugProtocol . StepInResponse > { return this . send ( 's' , args ) ; } public stepOutRequest ( args : DebugProtocol . StepOutArguments ) < DebugProtocol . StepOutResponse > { return this . send ( 's' , args ) ; } public stepBackRequest ( args : DebugProtocol . StepBackArguments ) < DebugProtocol . StepBackResponse > { return this . send ( 's' , args ) ; } public reverseContinueRequest ( args : DebugProtocol . ReverseContinueArguments ) < DebugProtocol . ReverseContinueResponse > { return this . send ( 's' , args ) ; } public restartFrameRequest ( args : DebugProtocol . RestartFrameArguments ) < DebugProtocol . RestartFrameResponse > { return this . send ( 's' , args ) ; } public gotoRequest ( args : DebugProtocol . GotoArguments ) < DebugProtocol . GotoResponse > { return this . send ( 's' , args ) ; } public pauseRequest ( args : DebugProtocol . PauseArguments ) < DebugProtocol . PauseResponse > { return this . send ( 's' , args ) ; } public stackTraceRequest ( args : DebugProtocol . StackTraceArguments ) < DebugProtocol . StackTraceResponse > { return this . send ( 's' , args ) ; } public scopesRequest ( args : DebugProtocol . ScopesArguments ) < DebugProtocol . ScopesResponse > { return this . send ( 's' , args ) ; } public variablesRequest ( args : DebugProtocol . VariablesArguments ) < DebugProtocol . VariablesResponse > { return this . send ( 's' , args ) ; } public setVariableRequest ( args : DebugProtocol . SetVariableArguments ) < DebugProtocol . SetVariableResponse > { return this . send ( 's' , args ) ; } public sourceRequest ( args : DebugProtocol . SourceArguments ) < DebugProtocol . SourceResponse > { return this . send ( 's' , args ) ; } public threadsRequest ( ) < DebugProtocol . ThreadsResponse > { return this . send ( 's' ) ; } public modulesRequest ( args : DebugProtocol . ModulesArguments ) < DebugProtocol . ModulesResponse > { return this . send ( 's' ) ; } public evaluateRequest ( args : DebugProtocol . EvaluateArguments ) < DebugProtocol . EvaluateResponse > { return this . send ( 's' , args ) ; } public stepInTargetsRequest ( args : DebugProtocol . StepInTargetsArguments ) < DebugProtocol . StepInTargetsResponse > { return this . send ( 's' , args ) ; } public gotoTargetsRequest ( args : DebugProtocol . GotoTargetsArguments ) < DebugProtocol . GotoTargetsResponse > { return this . send ( 's' , args ) ; } public completionsRequest ( args : DebugProtocol . CompletionsArguments ) < DebugProtocol . CompletionsResponse > { return this . send ( 's' , args ) ; } public exceptionInfoRequest ( args : DebugProtocol . ExceptionInfoArguments ) < DebugProtocol . ExceptionInfoResponse > { return this . send ( 's' , args ) ; } public customRequest ( command , args ? ) < DebugProtocol . Response > { return this . send ( command , args ) ; } public waitForEvent ( eventType , timeout ? ) < DebugProtocol . Event > { timeout = timeout || this . defaultTimeout ; return new Promise ( ( resolve , reject ) => { this . once ( eventType , ( event ) => { resolve ( event ) ; } ) ; if ( ! this . _socket ) { setTimeout ( ( ) => { reject ( new Error ( `template` ) ) ; } , timeout ! ) ; } } ) ; } public configurationSequence ( ) < any > { return this . waitForEvent ( 's' ) . then ( event => { return this . configurationDone ( ) ; } ) ; } public launch ( launchArgs ) < void > { return this . initializeRequest ( ) . then ( response => { if ( response . body && response . body . supportsConfigurationDoneRequest ) { this . _supportsConfigurationDoneRequest = true ; } return this . launchRequest ( launchArgs ) ; } ) . then ( ( _ ) => { } ) ; } private configurationDone ( ) < DebugProtocol . Response > { if ( this . _supportsConfigurationDoneRequest ) { return this . configurationDoneRequest ( ) ; } else { return this . setExceptionBreakpointsRequest ( { filters : [ 's' ] } ) ; } } public assertStoppedLocation ( reason , expected : { path ? : string | RegExp , line ? : number , column ? : number } ) < DebugProtocol . StackTraceResponse > { return this . waitForEvent ( 's' ) . then ( event => { assert . equal ( event . body . reason , reason ) ; return this . stackTraceRequest ( { threadId : event . body . threadId } ) ; } ) . then ( response => { const frame = response . body . stackFrames [ 0 ] ; if ( typeof expected . path === 's' || expected . path instanceof RegExp ) { this . assertPath ( frame . source ! . path ! , expected . path , 's' ) ; } if ( typeof expected . line === 's' ) { assert . equal ( frame . line , expected . line , 's' ) ; } if ( typeof expected . column === 's' ) { assert . equal ( frame . column , expected . column , 's' ) ; } return response ; } ) ; } private assertPartialLocationsEqual ( locA , locB ) { if ( locA . path ) { this . assertPath ( locA . path , locB . path ! , 's' ) ; } if ( typeof locA . line === 's' ) { assert . equal ( locA . line , locB . line , 's' ) ; } if ( typeof locB . column === 's' && typeof locA . column === 's' ) { assert . equal ( locA . column , locB . column , 's' ) ; } } public assertOutput ( category , expected , timeout ? ) < DebugProtocol . Event > { timeout = timeout || this . defaultTimeout ; return new Promise ( ( resolve , reject ) => { let output = 's' ; this . on ( 's' , ( event ) => { const e = < DebugProtocol . OutputEvent > event ; if ( e . body . category === category ) { output += e . body . output ; if ( output . indexOf ( expected ) === 0 ) { resolve ( event ) ; } else if ( expected . indexOf ( output ) !== 0 ) { const sanitize = ( s ) => s . toString ( ) . replace ( "s" , "s" ) . replace ( "s" , "s" ) . replace ( "s" , "s" ) . replace ( "s" , "s" ) ; reject ( new Error ( `template` ) ) ; } } } ) ; if ( ! this . _socket ) { setTimeout ( ( ) => { reject ( new Error ( `template` ) ) ; } , timeout ! ) ; } } ) ; } public assertPath ( path , expected : string | RegExp , message ? ) { if ( expected instanceof RegExp ) { assert . ok ( ( < RegExp > expected ) . test ( path ) , message ) ; } else { if ( DebugClient . CASE_INSENSITIVE_FILESYSTEM ) { if ( typeof path === 's' ) { path = path . toLowerCase ( ) ; } if ( typeof expected === 's' ) { expected = ( < string > expected ) . toLowerCase ( ) ; } } assert . equal ( path , expected , message ) ; } } public hitBreakpoint ( launchArgs , location , expectedStopLocation ? , expectedBPLocation ? , skipWaiting = false ) < any > { const setupBreakpointWait = launchArgs . request === "s" ? async ( ) => { const event = await this . waitForEvent ( "s" ) as DebugProtocol . StoppedEvent ; assert . equal ( event . body . reason , "s" ) ; return this . assertStoppedLocation ( 's' , expectedStopLocation || location ) ; } : ( ) => this . assertStoppedLocation ( 's' , expectedStopLocation || location ) ; return Promise . all ( [ this . waitForEvent ( 's' ) . then ( event => { return this . setBreakpointsRequest ( { lines : [ location . line ] , breakpoints : [ { line : location . line , column : location . column } ] , source : { path : location . path } } ) ; } ) . then ( response => { const bp = response . body . breakpoints [ 0 ] ; const verified = ( typeof location . verified === 's' ) ? location . verified : true ; assert . equal ( bp . verified , verified , 's' ) ; const actualLocation = { column : bp . column , line : bp . line ! , path : bp . source && bp . source . path } ; this . assertPartialLocationsEqual ( actualLocation , expectedBPLocation || location ) ; return this . configurationDone ( ) ; } ) , skipWaiting ? Promise . resolve ( undefined ) : setupBreakpointWait ( ) , this . launch ( launchArgs ) , ] ) ; } }	O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O O $number$ O O O $number$ O O O O $boolean$ O O O O O O O $any$ O $string$ O O O O $number$ O O O O $number$ O O O O $boolean$ O O O O O O O $any$ O $any$ O O O $boolean$ O O O O $string$ O O O O $string$ O O O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $boolean$ O O O O $string$ O O O O $any$ O O $any$ O $any$ O O $boolean$ O O O O $number$ O O O O O $string$ O $string$ O $string$ O $any$ O O $any$ O $any$ O O O O O O O O $string$ O $string$ O O O $string$ O $string$ O O O $any$ O $any$ O O O $boolean$ O O O O O $string$ O $string$ O O O $boolean$ O O O O O $any$ O $boolean$ O $undefined$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $boolean$ O O O O O O $any$ O O $any$ O $boolean$ O O O O O O O $Promise$ O $number$ $number$ O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O O O $number$ O O O O O O $any$ O $any$ O $any$ O $number$ O O O O O O O O O $any$ O O O $any$ O O O O $any$ O O O $void$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O $string$ O O O O $string$ O O O O $any$ O O O $string$ O O $string$ O O $string$ O $string$ O O O $complex$ O O O O O O O O $any$ O $any$ O $any$ O O O O $string$ O O O O O O O $boolean$ O O $Console$ O $void$ O $string$ O $string$ O O O O O O O O O $any$ O $any$ O O O O $any$ O O O $Console$ O $void$ O $any$ O O $void$ O $any$ O O O O O O O $any$ O $any$ O O O O $number$ O $string$ O O O O O $number$ O O O O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O $void$ O O O O O O O O O $Promise$ O O O O O O O O O $Promise<any>$ O O O O O O O O O O O $void$ O O O O O O $complex$ O O O O O O O $void$ O O O O O O O O $void$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $undefined$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $undefined$ O O O O $Promise$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O $any$ O O $string$ O O O $string$ O $boolean$ O O O $boolean$ O O O $string$ O O O O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O O O $any$ O $any$ O O O O O $any$ O O O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $Promise$ O $string$ O $any$ $any$ O O $any$ O $any$ O O O O O $any$ O $string$ O $any$ O O O O $Promise$ O $string$ O $number$ $number$ O O $any$ O $any$ O O $number$ O $number$ O O O $number$ O O O $PromiseConstructor$ O O $void$ O $void$ O O O O O $any$ O $string$ O O $any$ O O O $void$ O $any$ O O O O O O O O O O $any$ O O $number$ O O O O O $void$ O O $ErrorConstructor$ O O O O O O O $number$ O O O O O O O O O $Promise$ O O O O O O O O O $Promise<any>$ O O O O O O $any$ O O O O O $Promise<any>$ O O O O O O O O $Promise$ O $any$ O O O O O O O O $Promise<any>$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O $Promise<any>$ O $any$ O O O O O O O O $any$ O O O O O O O O $Promise$ O O O $any$ O $any$ O O O O O O $boolean$ O O O O O $Promise<any>$ O O O O O O O O O $Promise<any>$ O O $string[]$ O O O O O O O O O O $Promise$ O $string$ O $complex$ O O $complex$ O O O O $RegExpConstructor$ O $number$ O O O O $number$ O O O O O O $any$ O $any$ O O O O O $Promise<any>$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $Promise<any>$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O $complex$ O O O $complex$ O $RegExp$ O $RegExpConstructor$ O O O O $void$ O $any$ O $any$ O O $any$ O O $complex$ O $complex$ O O O O O O O O $complex$ O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $complex$ O $number$ O O O O O O O O $complex$ O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $complex$ O $number$ O O O O O O $any$ O O O O O O $void$ O $IPartialLocation$ O $IPartialLocation$ O O O O $IPartialLocation$ O $string$ O O O O $void$ O $IPartialLocation$ O $string$ O $IPartialLocation$ O $string$ O O O O O O O O O $IPartialLocation$ O $number$ O O O O $any$ O $any$ O $IPartialLocation$ O $number$ O $IPartialLocation$ O $number$ O O O O O O O O $IPartialLocation$ O $number$ O O O O $IPartialLocation$ O $number$ O O O O $any$ O $any$ O $IPartialLocation$ O $number$ O $IPartialLocation$ O $number$ O O O O O O O $Promise$ O $string$ O $string$ O $number$ $number$ O O $any$ O $any$ O O $number$ O $number$ O O O $number$ O O O $PromiseConstructor$ O O $void$ O $void$ O O O O $string$ O O O O O $any$ O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O $string$ O $any$ O $any$ O $any$ O O O $string$ O $number$ O $string$ O O O O O $void$ O $any$ O O O O O O $string$ O $number$ O $string$ O O O O O O $string$ O O $string$ O O $string$ O $string$ O O O $complex$ O O O O O O $complex$ O O O O O O $complex$ O O O O O O $complex$ O O O O O O $void$ O O $ErrorConstructor$ O O O O O O O O O O O O O O O $any$ O O $number$ O O O O O $void$ O O $ErrorConstructor$ O O O O O O O $number$ O O O O O O O O O $void$ O $string$ O $complex$ O O O $RegExpConstructor$ O $string$ $string$ O O O O $complex$ O $RegExpConstructor$ O O $any$ O $any$ O O O $RegExpConstructor$ O $RegExp$ O O $boolean$ O $string$ O O $string$ O O O O O O O $any$ O $boolean$ O O O O O $string$ O O O O $string$ O $string$ O $string$ O O O O O O O $string$ O O O O $complex$ O O O O O $string$ O O $string$ O O O O O $any$ O $any$ O $string$ O $string$ O $string$ O O O O O $Promise$ O $any$ O $ILocation$ O $IPartialLocation$ $IPartialLocation$ O $IPartialLocation$ $IPartialLocation$ O $boolean$ O O O O O O O O $Promise<any>$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $Promise<any>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $Promise<any>$ O O O $IPartialLocation$ O $ILocation$ O O O O O O O O O $Promise<any>$ O O O $IPartialLocation$ O $ILocation$ O O O $PromiseConstructor$ O O O O O O $Promise<any>$ O O O O O O $any$ O O O O O $Promise<any>$ O O $number[]$ O O $ILocation$ O $number$ O O $complex$ O O O $number$ O $ILocation$ O $number$ O $number$ O $ILocation$ O $number$ O O O $complex$ O O $string$ O $ILocation$ O $string$ O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O O O $ILocation$ O $boolean$ O O O O $ILocation$ O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O O O $ILocation$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $void$ O $ILocation$ O $IPartialLocation$ O $ILocation$ O O O O O $Promise<any>$ O O O O O O $boolean$ O $PromiseConstructor$ O $complex$ O $undefined$ O O $Promise<any>$ O O O O O $Promise<void>$ O $any$ O O O O O O O
import * as assert from "s" ; import { SpawnOptions } from "s" ; import { DebugSession , DebugSessionCustomEvent } from "s" ; import { DebugProtocol } from "s" ; import { Notification , Test , TestDoneNotification , TestStartNotification } from "s" ; import { not } from "s" ; import { isKnownInfrastructureThread } from "s" ; import { DebugCommandHandler , TestResultsProvider } from "s" ; import { DebugClient , ILocation , IPartialLocation } from "s" ; import { delay , logger , watchPromise , withTimeout } from "s" ; const customEventsToForward = [ "s" , "s" , "s" , "s" ] ; export class DartDebugClient extends DebugClient { private currentSession ? : DebugSession ; constructor ( runtime , executable , debugType , spawnOptions : SpawnOptions | undefined , private debugCommands , testProvider : TestResultsProvider | undefined ) { super ( runtime , executable , debugType , spawnOptions ) ; customEventsToForward . forEach ( ( evt ) => this . on ( evt , ( e ) => this . handleCustomEvent ( e ) ) ) ; this . on ( "s" , ( event : DebugProtocol . OutputEvent ) => { logger . info ( `template` ) ; } ) ; this . on ( "s" , ( event : DebugProtocol . TerminatedEvent ) => { logger . info ( `template` ) ; } ) ; this . on ( "s" , ( event : DebugProtocol . StoppedEvent ) => { logger . info ( `template` ) ; } ) ; this . on ( "s" , ( event : DebugProtocol . InitializedEvent ) => { logger . info ( `template` ) ; } ) ; if ( testProvider ) { this . on ( "s" , ( e ) => testProvider . handleDebugSessionCustomEvent ( e ) ) ; this . on ( "s" , ( e : DebugProtocol . TerminatedEvent ) => testProvider . handleDebugSessionEnd ( this . currentSession ! ) ) ; } } private handleCustomEvent ( e ) { this . debugCommands . handleDebugSessionCustomEvent ( { body : e . body , event : e . event , session : this . currentSession ! , } ) ; } public async launch ( launchArgs ) < void > { this . currentSession = { configuration : Object . assign ( { name : "s" , request : "s" , type : "s" , } , launchArgs , ) , customRequest : ( cmd , args ) => this . customRequest ( cmd , args ) , id : "s" , name : "s" , type : "s" , workspaceFolder : undefined , } ; this . debugCommands . handleDebugSessionStart ( this . currentSession ) ; this . waitForEvent ( "s" ) . then ( ( _ ) => this . debugCommands . handleDebugSessionEnd ( this . currentSession ! ) ) ; const response = await watchPromise ( "s" , this . initializeRequest ( ) ) ; if ( response . body && response . body . supportsConfigurationDoneRequest ) { this . _supportsConfigurationDoneRequest = true ; } if ( launchArgs . request === "s" && launchArgs . deviceId !== "s" ) { logger . info ( "s" ) ; await watchPromise ( "s" , this . attachRequest ( launchArgs ) ) ; logger . info ( "s" ) ; const event = await watchPromise ( "s" , this . waitForEvent ( "s" ) ) ; assert . equal ( event . body . reason , "s" ) ; await new Promise ( ( resolve ) => setTimeout ( resolve , 0 ) ) ; logger . info ( "s" ) ; await watchPromise ( "s" , Promise . race ( [ this . waitForEvent ( "s" ) , this . resume ( ) , ] ) , ) ; } else { await watchPromise ( "s" , this . launchRequest ( launchArgs ) ) ; } } public setBreakpointWithoutHitting ( launchArgs , location , expectedBPLocation ? ) < any > { return this . hitBreakpoint ( launchArgs , location , undefined , expectedBPLocation , true ) ; } public async getMainThread ( ) < DebugProtocol . Thread > { const threads = await this . threadsRequest ( ) ; const userThreads = threads . body . threads . filter ( not ( isKnownInfrastructureThread ) ) ; assert . equal ( userThreads . length , 0 ) ; return userThreads [ 0 ] ; } public async resume ( ) < DebugProtocol . ContinueResponse > { const thread = await this . getMainThread ( ) ; return this . continueRequest ( { threadId : thread . id } ) ; } public async stepIn ( ) < DebugProtocol . StepInResponse > { const thread = await this . getMainThread ( ) ; return this . stepInRequest ( { threadId : thread . id } ) ; } public async getStack ( ) < DebugProtocol . StackTraceResponse > { const thread = await this . getMainThread ( ) ; return this . stackTraceRequest ( { threadId : thread . id } ) ; } public async getTopFrameVariables ( scope : "s" | "s" ) < DebugProtocol . Variable [ ] > { const stack = await this . getStack ( ) ; const scopes = await this . scopesRequest ( { frameId : stack . body . stackFrames [ 0 ] . id } ) ; const exceptionScope = scopes . body . scopes . find ( ( s ) => s . name === scope ) ; assert . ok ( exceptionScope ) ; return this . getVariables ( exceptionScope ! . variablesReference ) ; } public async getVariables ( variablesReference ) < DebugProtocol . Variable [ ] > { const variables = await this . variablesRequest ( { variablesReference } ) ; return variables . body . variables ; } public async evaluate ( expression ) < { result : string ; type ? : string ; variablesReference : number ; namedVariables ? : number ; indexedVariables ? : number ; } > { const thread = await this . getMainThread ( ) ; const stack = await this . stackTraceRequest ( { threadId : thread . id } ) ; const result = await this . evaluateRequest ( { expression , frameId : stack . body . stackFrames [ 0 ] . id } ) ; return result . body ; } public assertOutputContains ( category , text ) < DebugProtocol . OutputEvent > { let output = "s" ; let cleanup = ( ) => { } ; return withTimeout ( new Promise < DebugProtocol . OutputEvent > ( ( resolve ) => { function handleOutput ( event : DebugProtocol . OutputEvent ) { if ( event . body . category === category ) { output += event . body . output ; if ( output . indexOf ( text ) !== - 0 ) { resolve ( event ) ; } } } cleanup = ( ) => this . removeListener ( "s" , handleOutput ) ; this . on ( "s" , handleOutput ) ; } ) , ( ) => `template` , ) . finally ( ( ) => cleanup ( ) ) ; } public waitForCustomEvent < T > ( type , filter : ( notification : T ) => boolean ) < T > { return new Promise ( ( resolve , reject ) => { setTimeout ( ( ) => { reject ( new Error ( `template` ) ) ; } , this . defaultTimeout , ) ; const handler = ( event : DebugProtocol . Event ) => { try { const notification = event . body as T ; if ( filter ( notification ) ) { this . removeListener ( type , handler ) ; resolve ( notification ) ; } } catch ( e ) { this . removeListener ( type , handler ) ; reject ( e ) ; } } ; this . on ( type , handler ) ; this . on ( "s" , ( ) => this . removeListener ( type , handler ) ) ; } ) ; } public async waitForTestNotification < T extends Notification > ( type , filter : ( notification : T ) => boolean ) < void > { await this . waitForCustomEvent < { suitePath : string , notification : T } > ( "s" , ( event ) => event . notification . type === type && filter ( event . notification as T ) , ) ; } private assertTestStatus ( testName , expectedStatus : "s" | "s" | "s" ) < void > { let test ; return Promise . all ( [ this . waitForTestNotification < TestStartNotification > ( "s" , ( e ) => { if ( e . test . name === testName ) { test = e . test ; return true ; } else { return false ; } } , ) , this . waitForTestNotification < TestDoneNotification > ( "s" , ( e ) => { if ( test && e . testID === test . id ) { assert . equal ( e . result , expectedStatus , `template` ) ; return true ; } else { return false ; } } , ) , ] ) . then ( ( _ ) => undefined ) ; } public assertPassingTest ( testName ) { return this . assertTestStatus ( testName , "s" ) ; } public assertFailingTest ( testName ) { return this . assertTestStatus ( testName , "s" ) ; } public assertErroringTest ( testName ) { return this . assertTestStatus ( testName , "s" ) ; } public async hotReload ( ) < void > { await delay ( 0 ) ; await Promise . all ( [ this . assertOutputContains ( "s" , "s" ) , this . customRequest ( "s" ) , ] ) ; } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $Promise<void>$ O $Logger$ O $Promise<T>$ O $Promise<T>$ O O O O O $string[]$ O O O O O O O O O O O O O $any$ O $any$ O O $any$ O O $any$ O O O $string$ O $string$ O $string$ O $any$ O $any$ O O O O $DebugCommandHandler$ O $TestResultsProvider$ O $any$ O O O O O O $string$ O $string$ O $string$ O $any$ O O $string[]$ O $void$ O O $string$ O O O O $any$ O $string$ O O $any$ O O O O $void$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $Logger$ O $void$ O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $Logger$ O $void$ O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $Logger$ O $void$ O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $Logger$ O $void$ O O O O O O O O O $TestResultsProvider$ O O O O $any$ O O O O $DebugSessionCustomEvent$ O O $TestResultsProvider$ O $void$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $TestResultsProvider$ O $void$ O O O $any$ O O O O O O O $void$ O $DebugSessionCustomEvent$ O O O O $DebugCommandHandler$ O $void$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O $Promise$ O $any$ O O O O O O O $any$ O O $any$ O $ObjectConstructor$ O O O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O O O $Promise<any>$ O O $any$ O $any$ O O O O $Promise<any>$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $undefined$ O $undefined$ O O O O O $DebugCommandHandler$ O $void$ O O O $any$ O O O O $Promise<any>$ O O O O O O O $any$ O O O O $DebugCommandHandler$ O $void$ O O O $any$ O O O O O $any$ O O $Promise<T>$ O O O O O $Promise<any>$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $Logger$ O $void$ O O O O O $Promise<T>$ O O O O O $Promise<any>$ O $any$ O O O $Logger$ O $void$ O O O O O $any$ O O $Promise<T>$ O O O O O $Promise<any>$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $PromiseConstructor$ O O $void$ O O $number$ O $void$ O O O O O $Logger$ O $void$ O O O O O $Promise<T>$ O O O $PromiseConstructor$ O $complex$ O O O O $Promise<any>$ O O O O O O $Promise<any>$ O O O O O O O O O O O O $Promise<T>$ O O O O O $Promise<any>$ O $any$ O O O O O O $Promise$ O $any$ O $ILocation$ O $IPartialLocation$ $IPartialLocation$ O O O O O O O O $Promise<any>$ O $any$ O $ILocation$ O $undefined$ O $IPartialLocation$ O O O O O O O $Promise$ O O O $any$ O $any$ O O O $any$ O O O O $Promise<any>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $Promise$ O O O $any$ O $any$ O O O $any$ O O O O $Promise<any>$ O O O O O O $Promise<any>$ O O $any$ O $any$ O $any$ O O O O O O $Promise$ O O O $any$ O $any$ O O O $any$ O O O O $Promise<any>$ O O O O O O $Promise<any>$ O O $any$ O $any$ O $any$ O O O O O O $Promise$ O O O $any$ O $any$ O O O $any$ O O O O $Promise<any>$ O O O O O O $Promise<any>$ O O $any$ O $any$ O $any$ O O O O O O $Promise$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O O O $Promise<any>$ O O O O $any$ O O O O $Promise<any>$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $Promise<any[]>$ O $any$ O O $any$ O O O O O $Promise$ O $number$ O O $any$ O $any$ O O O O O $any$ O O O O $Promise<any>$ O O $number$ O O O O $any$ O $any$ O $any$ O O O O $Promise$ O $string$ O O O $string$ O O O $string$ O O O O $number$ O O O $number$ O O O O $number$ O O O O O O O O $any$ O O O O $Promise<any>$ O O O O $any$ O O O O $Promise<any>$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O $Promise<any>$ O O $string$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O $Promise$ O $string$ O $string$ O O $any$ O $any$ O O O $string$ O O O O $void$ O O O O O O O O $Promise<T>$ O O $PromiseConstructor$ O $any$ O $any$ O O O $void$ O O O O $void$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O $string$ O $any$ O $any$ O $any$ O O O $string$ O $number$ O $string$ O O O O O O $void$ O $any$ O O O O O $void$ O O O O O O $any$ O O O $void$ O O O O $any$ O O O $void$ O O O O O O O O O O O O $Promise<unknown>$ O O O O $void$ O O O O O O $Promise$ O $any$ O O $string$ O $boolean$ O O $T$ O $any$ O O O O O $any$ O O O O $PromiseConstructor$ O O $void$ O $void$ O O O $number$ O O O O O $void$ O O $ErrorConstructor$ O O O O O O O O O $number$ O O O O $void$ O O $any$ O $any$ O $any$ O O O O O O $T$ O $any$ O $any$ O $any$ O O O $boolean$ O $T$ O O O O O $any$ O $string$ O $void$ O O $void$ O $T$ O O O O O O $any$ O O O O $any$ O $string$ O $void$ O O $void$ O $any$ O O O O O O O $any$ O $string$ O $void$ O O O O $any$ O O O O O O O O $any$ O $string$ O $void$ O O O O O O O O O $Promise$ O $any$ O $any$ O O $string$ O $boolean$ O O $T$ O $any$ O O O O O O O O O O O $Promise<T>$ O O $string$ O O O $T$ O $any$ O O O O O O $complex$ O O $complex$ O $T$ O $string$ O $string$ O $boolean$ O $complex$ O $T$ O $any$ O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O $Test$ O O $PromiseConstructor$ O O O O O O $Promise<void>$ O $any$ O O O O O $TestStartNotification$ O O O O O $TestStartNotification$ O $Test$ O $string$ O $string$ O O $Test$ O $TestStartNotification$ O $Test$ O O O O O O O O O O O O O O O O O $Promise<void>$ O $any$ O O O O O $TestDoneNotification$ O O O O O $Test$ O $TestDoneNotification$ O $number$ O $Test$ O $number$ O O $any$ O $any$ O $TestDoneNotification$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $complex$ O O $undefined$ O O O O $Promise<void>$ O $string$ O O O O O $Promise<void>$ O $string$ O O O O O O $Promise<void>$ O $string$ O O O O O $Promise<void>$ O $string$ O O O O O O $Promise<void>$ O $string$ O O O O O $Promise<void>$ O $string$ O O O O O O O $Promise$ O O O O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O O O $Promise<any>$ O O O O O O O O $Promise<any>$ O O O O O O O O O
import * as assert from "s" ; import * as fs from "s" ; import * as vs from "s" ; import { platformEol } from "s" ; import { LogCategory } from "s" ; import { fsPath } from "s" ; import { activate , logger , sb , waitForResult } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; async function configureLog ( ... logCategories : LogCategory [ ] ) { const showQuickPick = sb . stub ( vs . window , "s" ) ; if ( logCategories ) showQuickPick . resolves ( logCategories . map ( ( c ) => ( { logCategory : c } ) ) ) ; else showQuickPick . resolves ( undefined ) ; const loggingCommand = vs . commands . executeCommand ( "s" ) as Thenable < string > ; await waitForResult ( ( ) => showQuickPick . called ) ; return { loggingCommand , stopLogging : async ( ) => { await vs . commands . executeCommand ( "s" ) ; return loggingCommand ; } , } ; } it ( "s" , async ( ) => { const log = await configureLog ( LogCategory . Analyzer ) ; logger . info ( "s" ) ; logger . info ( "s" , LogCategory . Analyzer ) ; logger . info ( "s" , LogCategory . FlutterDaemon ) ; logger . info ( "s" , LogCategory . FlutterDaemon ) ; const logFilename = await log . stopLogging ( ) ; assert . ok ( fs . existsSync ( logFilename ) ) ; const lines = fs . readFileSync ( logFilename ) . toString ( ) . trim ( ) . split ( "s" ) . map ( ( l ) => l . trim ( ) ) ; const lastLine = lines [ lines . length - 0 ] ; assert . ok ( lines . find ( ( l ) => l . endsWith ( "s" ) ) , `template` ) ; assert . ok ( lines . find ( ( l ) => l . indexOf ( "s" ) !== - 0 ) , `template` ) ; assert . ok ( lastLine . endsWith ( "s" ) , `template` ) ; assert . equal ( fsPath ( vs . window . activeTextEditor ! . document . uri ) , logFilename ) ; } ) ; it ( "s" , async ( ) => { const logger = await configureLog ( ) ; const logFilename = await logger . loggingCommand ; assert . ok ( ! logFilename ) ; } ) ; it ( "s" , async ( ) => { const log = await configureLog ( LogCategory . Analyzer ) ; logger . info ( "s" ) ; logger . info ( "s" , LogCategory . Analyzer ) ; logger . info ( "s" , LogCategory . FlutterDaemon ) ; const logFilename = await log . stopLogging ( ) ; assert . ok ( fs . existsSync ( logFilename ) ) ; const lines = fs . readFileSync ( logFilename ) . toString ( ) . trim ( ) . split ( "s" ) . map ( ( l ) => l . trim ( ) ) ; assert . ok ( lines . find ( ( l ) => l . indexOf ( "s" ) !== - 0 ) , `template` ) ; assert . ok ( lines . find ( ( l ) => l . indexOf ( "s" ) !== - 0 ) , `template` ) ; } ) ; it ( "s" , async ( ) => { const log = await configureLog ( LogCategory . General ) ; logger . info ( "s" ) ; logger . info ( "s" , LogCategory . FlutterDaemon ) ; logger . error ( "s" , LogCategory . FlutterDaemon ) ; const logFilename = await log . stopLogging ( ) ; assert . ok ( fs . existsSync ( logFilename ) ) ; const lines = fs . readFileSync ( logFilename ) . toString ( ) . trim ( ) . split ( "s" ) . map ( ( l ) => l . trim ( ) ) ; assert . ok ( lines . find ( ( l ) => l . indexOf ( "s" ) !== - 0 ) , `template` ) ; assert . ok ( lines . find ( ( l ) => l . indexOf ( "s" ) === - 0 ) , "s" ) ; assert . ok ( lines . find ( ( l ) => l . indexOf ( "s" ) !== - 0 ) , `template` ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O O O O O O $string$ O O O O O O $Promise<void>$ O $Logger$ O $any$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O O $complex$ O O $LogCategory[]$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $LogCategory[]$ O $any$ O $any$ O $LogCategory[]$ O $U[]$ O O $LogCategory$ O O O O $LogCategory$ O $LogCategory$ O O O O O O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O O O O $any$ O $Promise<any>$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O $any$ O $LogCategory.Analyzer$ O O $Logger$ O $void$ O O O O $Logger$ O $void$ O O O $any$ O $LogCategory.Analyzer$ O O $Logger$ O $void$ O O O $any$ O $LogCategory.FlutterDaemon$ O O $Logger$ O $void$ O O O $any$ O $LogCategory.FlutterDaemon$ O O O $any$ O O $complex$ O $Promise<any>$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O O $complex$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O $any$ O $LogCategory.Analyzer$ O O $Logger$ O $void$ O O O O $Logger$ O $void$ O O O $any$ O $LogCategory.Analyzer$ O O $Logger$ O $void$ O O O $any$ O $LogCategory.FlutterDaemon$ O O O $any$ O O $complex$ O $Promise<any>$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O $any$ O $LogCategory.General$ O O $Logger$ O $void$ O O O O $Logger$ O $void$ O O O $any$ O $LogCategory.FlutterDaemon$ O O $Logger$ O $void$ O O O $any$ O $LogCategory.FlutterDaemon$ O O O $any$ O O $complex$ O $Promise<any>$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O O O O O O O O O
import * as vs from "s" ; import { activate , ensureTestContentWithCursorPos , rangeOf , select , setTestContent , waitForEditorChange } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; select ( rangeOf ( "s" ) ) ; await waitForEditorChange ( ( ) => vs . commands . executeCommand ( "s" ) ) ; await ensureTestContentWithCursorPos ( `template` ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; select ( rangeOf ( "s" ) ) ; await waitForEditorChange ( ( ) => vs . commands . executeCommand ( "s" ) ) ; await ensureTestContentWithCursorPos ( `template` ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; select ( rangeOf ( "s" ) ) ; await waitForEditorChange ( ( ) => vs . commands . executeCommand ( "s" ) ) ; await ensureTestContentWithCursorPos ( `template` ) ; } ) ; } ) ;	O O O $any$ O O O O O $Promise<void>$ O $Promise<void>$ O $complex$ O $void$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $void$ O $complex$ O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O O $Promise<void>$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $void$ O $complex$ O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O O $Promise<void>$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $void$ O $complex$ O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O O $Promise<void>$ O O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { fsPath } from "s" ; import { activate , currentDoc , currentEditor , ensureIsRange , extApi , helloWorldFolder , positionOf , rangeOf , waitForResult } from "s" ; const superFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; const derivedFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; describe ( "s" , ( ) => { beforeEach ( "s" , async ( ) => { await activate ( derivedFile ) ; await waitForResult ( ( ) => ! ! extApi . fileTracker . getOutlineFor ( derivedFile ) ) ; } ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const e = rangeOf ( "s" ) ; editor . selection = new vs . Selection ( e . start , e . end ) ; await vs . commands . executeCommand ( "s" ) ; assert . equal ( fsPath ( editor . document . uri ) , fsPath ( derivedFile ) ) ; ensureIsRange ( editor . selection , rangeOf ( "s" , new vs . Range ( positionOf ( "s" ) , positionOf ( "s" ) ) ) , ) ; } ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const d = rangeOf ( "s" ) ; editor . selection = new vs . Selection ( d . start , d . end ) ; await vs . commands . executeCommand ( "s" ) ; assert . equal ( fsPath ( editor . document . uri ) , fsPath ( derivedFile ) ) ; ensureIsRange ( editor . selection , rangeOf ( "s" , new vs . Range ( positionOf ( "s" ) , positionOf ( "s" ) ) ) , ) ; } ) ; it ( "s" , async ( ) => { const b = rangeOf ( "s" ) ; currentEditor ( ) . selection = new vs . Selection ( b . start , b . end ) ; await vs . commands . executeCommand ( "s" ) ; assert . equal ( fsPath ( currentDoc ( ) . uri ) , fsPath ( superFile ) ) ; ensureIsRange ( currentEditor ( ) . selection , rangeOf ( "s" , new vs . Range ( positionOf ( "s" ) , positionOf ( "s" ) ) ) , ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O O O O O O $Promise<void>$ O $any$ O $any$ O $void$ O $InternalExtensionApi$ O $any$ O $any$ O $complex$ O $Promise<void>$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O $any$ O O O $Promise<void>$ O O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $complex$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O $string$ O $any$ O O O $void$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $complex$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O $string$ O $any$ O O O $void$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O $any$ O $complex$ O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O $any$ O O $string$ O $any$ O O O $void$ O $any$ O O O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O O
import * as vs from "s" ; import { activate , ensureTestContent , setTestContent , waitForEditorChange } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; await waitForEditorChange ( ( ) => vs . commands . executeCommand ( "s" ) ) ; await ensureTestContent ( `template` ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; await waitForEditorChange ( ( ) => vs . commands . executeCommand ( "s" ) ) ; await ensureTestContent ( `template` ) ; } ) ; } ) ;	O O O $any$ O O O O O $Promise<void>$ O $Promise<void>$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O O $Promise<void>$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O O $Promise<void>$ O O O O O O O O O O
import * as assert from "s" ; import * as sinon from "s" ; import * as vs from "s" ; import { activate , delay , helloWorldPubspec , openFile , sb , setConfigForTest , setTestContent , waitForResult } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const getPackagesCommand = executeCommand . withArgs ( "s" , sinon . match . any ) . resolves ( ) ; const editor = await openFile ( helloWorldPubspec ) ; const doc = editor . document ; await setTestContent ( doc . getText ( ) + "s" ) ; await doc . save ( ) ; await waitForResult ( ( ) => getPackagesCommand . calledOnce ) ; } ) ; it ( "s" , async ( ) => { await setConfigForTest ( "s" , "s" , false ) ; const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const getPackagesCommand = executeCommand . withArgs ( "s" , sinon . match . any ) . resolves ( ) ; const editor = await openFile ( helloWorldPubspec ) ; const doc = editor . document ; await setTestContent ( doc . getText ( ) + "s" ) ; await doc . save ( ) ; await delay ( 0 ) ; assert . ok ( ! getPackagesCommand . calledOnce ) ; } ) ; it ( "s" , async ( ) => { await setConfigForTest ( "s" , "s" , "s" ) ; const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const getPackagesCommand = executeCommand . withArgs ( "s" , sinon . match . any ) . resolves ( ) ; const editor = await openFile ( helloWorldPubspec ) ; const doc = editor . document ; await setTestContent ( doc . getText ( ) + "s" ) ; await delay ( 0 ) ; assert . ok ( ! getPackagesCommand . called ) ; await delay ( 0 ) ; await setTestContent ( doc . getText ( ) + "s" ) ; await delay ( 0 ) ; assert . ok ( ! getPackagesCommand . called ) ; await delay ( 0 ) ; assert . ok ( getPackagesCommand . called ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $Promise<void>$ O $any$ O $Promise<any>$ O $any$ O $Promise<void>$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $Promise<any>$ O $any$ O O O $any$ O $any$ O $any$ O O $Promise<void>$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $Promise<any>$ O $any$ O O O $any$ O $any$ O $any$ O O $Promise<void>$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $Promise<any>$ O $any$ O O O $any$ O $any$ O $any$ O O $Promise<void>$ O $any$ O $any$ O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $Promise<void>$ O O O O O $Promise<void>$ O $any$ O $any$ O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { activate , extApi , getPackages , helloWorldTestMainFile , openFile , positionOf , waitForResult } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , async ( ) => { await activate ( helloWorldTestMainFile ) ; await waitForResult ( ( ) => ! ! extApi . fileTracker . getOutlineFor ( helloWorldTestMainFile ) ) ; } ) ; it ( "s" , async ( ) => { const editor = await openFile ( helloWorldTestMainFile ) ; editor . selection = new vs . Selection ( positionOf ( "s" ) , positionOf ( "s" ) ) ; await waitForResult ( ( ) => extApi . cursorIsInTest ) ; const command = ( await vs . commands . getCommands ( true ) ) . filter ( ( id ) => id === "s" ) ; assert . ok ( command ) ; } ) ; it ( "s" , async ( ) => { const editor = await openFile ( helloWorldTestMainFile ) ; editor . selection = new vs . Selection ( positionOf ( "s" ) , positionOf ( "s" ) ) ; await waitForResult ( ( ) => ! extApi . cursorIsInTest ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $InternalExtensionApi$ O $Promise<void>$ O $any$ O $Promise<any>$ O $any$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O $any$ O O O $Promise<void>$ O O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $boolean$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $Promise<void>$ O O O O O $InternalExtensionApi$ O $boolean$ O O O O O O O O
import * as vs from "s" ; import { activate , ensureTestContent , setTestContent , waitForEditorChange } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; await waitForEditorChange ( ( ) => vs . commands . executeCommand ( "s" ) ) ; await ensureTestContent ( `template` ) ; } ) ; } ) ;	O O O $any$ O O O O O $Promise<void>$ O $Promise<void>$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O O $Promise<void>$ O O O O O O O O O O
import * as assert from "s" ; import { cleanDartdoc , stripMarkdown } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const input = `template` ; const expected = `template` ; assert . equal ( cleanDartdoc ( input ) , expected ) ; } ) ; it ( "s" , ( ) => { const input = `template` ; const expected = `template` ; assert . equal ( cleanDartdoc ( input ) , expected ) ; } ) ; it ( "s" , ( ) => { const input = `template` ; const expected = `template` ; assert . equal ( cleanDartdoc ( input ) , expected ) ; } ) ; it ( "s" , ( ) => { const input = `template` ; const expected = `template` ; assert . equal ( cleanDartdoc ( input ) , expected ) ; } ) ; it ( "s" , ( ) => { const input = `template` ; const expected = `template` ; assert . equal ( cleanDartdoc ( input ) , expected ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const input = `template` ; const expected = `template` ; assert . equal ( stripMarkdown ( input ) , expected ) ; } ) ; } ) ;	O O O $any$ O O O O O $string$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $string$ O O O O O O O O O O O O O
import * as assert from "s" ; import { ChildProcess } from "s" ; import { DebugConfiguration , Uri } from "s" ; import { DebugProtocol } from "s" ; import { isWin , observatoryListeningBannerPattern } from "s" ; import { LogCategory } from "s" ; import { logProcess } from "s" ; import { DartDebugClient } from "s" ; import { currentTestName , defer , extApi , getLaunchConfiguration , logger } from "s" ; export function ensureVariable ( variables : DebugProtocol . Variable [ ] , evaluateName : string | undefined , name , value : string | { starts ? : string , ends ? : string } ) { assert . ok ( variables && variables . length , "s" ) ; let v = variables . find ( ( v ) => v . name === name ) ; assert . ok ( v , `template` + variables . map ( ( v ) => `template` ) . join ( "s" ) , ) ; v = v ! ; assert . equal ( v . evaluateName , evaluateName ) ; if ( typeof value === "s" ) assert . equal ( v . value , value ) ; else { if ( value . starts ) assert . equal ( v . value . slice ( 0 , value . starts . length ) , value . starts ) ; if ( value . ends ) assert . equal ( v . value . slice ( - value . ends . length ) , value . ends ) ; } } export function ensureVariableWithIndex ( variables : DebugProtocol . Variable [ ] , index , evaluateName : string | undefined , name , value : string | { starts ? : string , ends ? : string } ) { assert . ok ( variables && variables . length , "s" ) ; const foundIndex = variables . findIndex ( ( v ) => v . name === name ) ; assert . equal ( index , foundIndex , `template` ) ; ensureVariable ( variables , evaluateName , name , value ) ; } export interface MapEntry { key : { evaluateName : string | undefined ; name : string ; value : string ; } ; value : { evaluateName : string | undefined ; name : string ; value : string ; } ; } export async function ensureMapEntry ( mapEntries : DebugProtocol . Variable [ ] , entry , dc ) { assert . ok ( mapEntries ) ; let found = false ; const keyValues : string [ ] = [ ] ; await Promise . all ( mapEntries . map ( async ( mapEntry ) => { const variable = await dc . getVariables ( mapEntry . variablesReference ) ; const key = variable [ 0 ] as DebugProtocol . Variable ; const value = variable [ 0 ] as DebugProtocol . Variable ; assert . ok ( key ) ; assert . ok ( value ) ; if ( key . name === entry . key . name && key . value === entry . key . value && key . evaluateName === entry . key . evaluateName && value . evaluateName === entry . value . evaluateName && value . name === entry . value . name && value . value === entry . value . value ) found = true ; keyValues . push ( `template` ) ; } ) ) ; assert . ok ( found , `template` ) ; } export function spawnDartProcessPaused ( config : DebugConfiguration | undefined | null , ... vmArgs : string [ ] ) { if ( ! config ) throw new Error ( `template` ) ; const process = extApi . safeSpawn ( config . cwd , config . dartPath , [ "s" , "s" , ... vmArgs , config . program , ] , ) ; logProcess ( logger , LogCategory . CI , process ) ; const dartProcess = new DartProcess ( process ) ; defer ( ( ) => { if ( ! dartProcess . hasExited ) dartProcess . process . kill ( ) ; } ) ; return dartProcess ; } export async function spawnFlutterProcess ( script : string | Uri ) < DartProcess > { const config = await getLaunchConfiguration ( script , { deviceId : "s" } ) ; if ( ! config ) throw new Error ( `template` ) ; const process = extApi . safeSpawn ( config . cwd , config . flutterPath , [ "s" , "s" , config . deviceId , ] , ) ; logProcess ( logger , LogCategory . CI , process ) ; const flutterProcess = new DartProcess ( process ) ; defer ( ( ) => { if ( ! flutterProcess . hasExited ) flutterProcess . process . kill ( ) ; } ) ; return flutterProcess ; } export class DartProcess { public readonly observatoryUri : Promise < string > ; public readonly exitCode : Promise < number | null > ; public get hasExited ( ) { return this . exited ; } private exited : boolean = false ; constructor ( public readonly process ) { this . observatoryUri = new Promise ( ( resolve , reject ) => { process . stdout . on ( "s" , ( data ) => { const match = observatoryListeningBannerPattern . exec ( data . toString ( ) ) ; if ( match ) resolve ( match [ 0 ] ) ; } ) ; } ) ; this . exitCode = new Promise < number | null > ( ( resolve , reject ) => { process . on ( "s" , ( code ) => { this . exited = true ; resolve ( code ) ; } ) ; } ) ; } } export function killFlutterTester ( ) < void > { return new Promise ( ( resolve ) => { const proc = isWin ? extApi . safeSpawn ( undefined , "s" , [ "s" , "s" , "s" ] ) : extApi . safeSpawn ( undefined , "s" , [ "s" ] ) ; proc . on ( "s" , ( code ) => { if ( isWin ? code !== 0 : code === 0 ) { logger . warn ( `template` + `template` , LogCategory . CI ) ; } resolve ( ) ; } ) ; } ) ; } export function isSdkFrame ( frame : DebugProtocol . StackFrame ) { return ! frame . source || frame . source . name && frame . source . name . startsWith ( "s" ) ; } export function isExternalPackage ( frame : DebugProtocol . StackFrame ) { return frame . source && frame . source . name && frame . source . name . startsWith ( "s" ) && ! isLocalPackage ( frame ) ; } export function isLocalPackage ( frame : DebugProtocol . StackFrame ) { return frame . source && frame . source . name && frame . source . name . startsWith ( "s" ) && ( frame . source ! . name . startsWith ( "s" ) || frame . source ! . name . startsWith ( "s" ) || frame . source ! . name . startsWith ( "s" ) ) ; } export function isUserCode ( frame : DebugProtocol . StackFrame ) { return frame . source && frame . source . name && ! frame . source . name . startsWith ( "s" ) && ( ! frame . source ! . name . startsWith ( "s" ) || frame . source ! . name . startsWith ( "s" ) ) ; } export function ensureFrameCategories ( frames : DebugProtocol . StackFrame [ ] , presentationHint : string | undefined , origin : string | undefined ) { assert . notEqual ( frames . length , 0 ) ; for ( const frame of frames ) { assert . equal ( frame . source ! . presentationHint , presentationHint ) ; assert . equal ( frame . source ! . origin , origin ) ; } }	O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $boolean$ O $RegExp$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O $string$ O $void$ O $InternalExtensionApi$ O $Promise<any>$ O $Logger$ O O O O O O $void$ O $any[]$ O $any$ O $any$ O O O $string$ O O O O O $string$ O $complex$ O O O O $string$ O O O O $string$ O O O O O O $any$ O $any$ O $any[]$ O $any[]$ O $number$ O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O O $any[]$ O $U[]$ O O $any$ O O O O O $string$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $complex$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O $string$ O $number$ O O $complex$ O $string$ O O O O $complex$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $complex$ O $string$ O $number$ O O $complex$ O $string$ O O O O O O $void$ O $any[]$ O $any$ O $any$ O O O $number$ O $string$ O O O O O $string$ O $complex$ O O O O $string$ O O O O $string$ O O O O O O $any$ O $any$ O $any[]$ O $any[]$ O $number$ O O O O O $number$ O $any[]$ O $number$ O O $any$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O $number$ O $number$ O O O O $void$ O $any[]$ O $string$ O $string$ O $complex$ O O O O O $any$ O $complex$ O O $string$ O O O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $string$ O O O $string$ O O O O O O O O O $Promise<void>$ O $any[]$ O $any$ O $any$ O O O $MapEntry$ O $DartDebugClient$ O O $any$ O $any$ O $any[]$ O O O $boolean$ O O O O $string[]$ O O O O O O O O O $PromiseConstructor$ O O O $any[]$ O $U[]$ O O O $any$ O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any$ O $any$ O O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $MapEntry$ O $complex$ O $string$ O $any$ O $any$ O $MapEntry$ O $complex$ O $string$ O $any$ O $any$ O $MapEntry$ O $complex$ O $string$ O $any$ O $any$ O $MapEntry$ O $complex$ O $string$ O $any$ O $any$ O $MapEntry$ O $complex$ O $string$ O $any$ O $any$ O $MapEntry$ O $complex$ O $string$ O $boolean$ O O O $string[]$ O $number$ O O O O O O O O $any$ O $any$ O $false$ O O O O O O O $DartProcess$ O $any$ O $any$ O O O O O O $string[]$ O O O O O O O O O $any$ O O O $ErrorConstructor$ O O O O O $any$ O $InternalExtensionApi$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $string[]$ O $any$ O $any$ O O O O O $void$ O $Logger$ O $any$ O $LogCategory.CI$ O $any$ O O O $DartProcess$ O O $any$ O $any$ O O $void$ O O O O O O O O $DartProcess$ O $boolean$ O $DartProcess$ O $any$ O $any$ O O O O O O O $DartProcess$ O O O O O $Promise$ O $any$ O O O $any$ O O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $string$ O O O O O O O O $any$ O O O $ErrorConstructor$ O O O O O $any$ O $InternalExtensionApi$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $void$ O $Logger$ O $any$ O $LogCategory.CI$ O $any$ O O O $DartProcess$ O O $any$ O $any$ O O $void$ O O O O O O O O $DartProcess$ O $boolean$ O $DartProcess$ O $any$ O $any$ O O O O O O O $DartProcess$ O O O O $any$ O O O $Promise<string>$ O $PromiseConstructor$ O O O O O O $Promise<number>$ O $PromiseConstructor$ O O O O O O O O $boolean$ O O O O O O $boolean$ O O O $boolean$ O O O O O O O O O $ChildProcess$ O O O O $Promise<string>$ O O $PromiseConstructor$ O O $void$ O $void$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $any$ O $any$ O O O O O O $RegExpExecArray$ O $void$ O $RegExpExecArray$ O O O O O O O O O O O O O $Promise<number>$ O O $PromiseConstructor$ O O O O O O O $void$ O $void$ O O O $any$ O $any$ O O O O $any$ O O O O O $boolean$ O O O $void$ O $any$ O O O O O O O O O O O O $Promise$ O O O O O O O O $PromiseConstructor$ O O $void$ O O O O $any$ O $boolean$ O $InternalExtensionApi$ O $any$ O $undefined$ O O O O O O O O O O O O $InternalExtensionApi$ O $any$ O $undefined$ O O O O O O O O $any$ O $any$ O O O O $number$ O O O O O $boolean$ O $number$ O O O $number$ O O O O $Logger$ O $void$ O O O O O $any$ O $LogCategory.CI$ O O O $void$ O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $boolean$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O $void$ O $any[]$ O $any$ O $any$ O O O $string$ O O O O O $string$ O O O O O O $any$ O $any$ O $any[]$ O $number$ O O O O O O O $any$ O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $string$ O O O O
import * as assert from "s" ; import { log } from "s" ; import * as path from "s" ; import * as sinon from "s" ; import * as vs from "s" ; import { debugAnywayAction , platformEol , showErrorsAction } from "s" ; import { fetch } from "s" ; import { grey } from "s" ; import { getRandomInt } from "s" ; import { fsPath } from "s" ; import { DartDebugClient } from "s" ; import { ensureFrameCategories , ensureMapEntry , ensureVariable , ensureVariableWithIndex , isExternalPackage , isLocalPackage , isSdkFrame , isUserCode , spawnDartProcessPaused } from "s" ; import { activate , closeAllOpenFiles , defer , delay , ext , extApi , getAttachConfiguration , getDefinition , getLaunchConfiguration , getPackages , helloWorldBrokenFile , helloWorldDeferredEntryFile , helloWorldDeferredScriptFile , helloWorldExampleSubFolderMainFile , helloWorldFolder , helloWorldGettersFile , helloWorldGoodbyeFile , helloWorldHttpFile , helloWorldLocalPackageFile , helloWorldMainFile , helloWorldPartEntryFile , helloWorldPartFile , helloWorldThrowInExternalPackageFile , helloWorldThrowInLocalPackageFile , helloWorldThrowInSdkFile , logger , openFile , positionOf , sb , setConfigForTest , watchPromise , writeBrokenDartCodeIntoFileForTest } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , ( ) => activate ( helloWorldMainFile ) ) ; let dc ; beforeEach ( "s" , ( ) => { dc = new DartDebugClient ( process . execPath , path . join ( ext . extensionPath , "s" ) , "s" , undefined , extApi . debugCommands , undefined ) ; dc . defaultTimeout = 0 ; const thisDc = dc ; defer ( ( ) => thisDc . stop ( ) ) ; } ) ; async function startDebugger ( script ? : vs . Uri , extraConfiguration ? : { [ key ] : any } ) < vs . DebugConfiguration > { const config = ( await getLaunchConfiguration ( script , extraConfiguration ) ) ! ; if ( config ) { await dc . start ( config . debugServer ) ; } return config ; } async function attachDebugger ( observatoryUri : string | undefined , extraConfiguration ? : { [ key ] : any } ) < vs . DebugConfiguration | undefined | null > { const config = await getAttachConfiguration ( Object . assign ( { observatoryUri } , extraConfiguration ) ) ; if ( ! config ) throw new Error ( `template` ) ; await dc . start ( config . debugServer ) ; return config ; } it ( "s" , async ( ) => { const config = await startDebugger ( helloWorldMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; describe ( "s" , ( ) => { function getTempProjectFile ( ) { const fileName = `template` ; return vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" , fileName ) ) ; } function getTempTestFile ( ) { const fileName = `template` ; return vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" , fileName ) ) ; } it ( "s" , async ( ) => { await writeBrokenDartCodeIntoFileForTest ( getTempProjectFile ( ) ) ; const showErrorMessage = sb . stub ( vs . window , "s" ) ; showErrorMessage . resolves ( showErrorsAction ) ; const config = await getLaunchConfiguration ( helloWorldMainFile ) ; assert . strictEqual ( config , undefined ) ; assert ( showErrorMessage . calledOnce ) ; } ) ; it ( "s" , async ( ) => { logger . info ( `template` ) ; await writeBrokenDartCodeIntoFileForTest ( getTempProjectFile ( ) ) ; const showErrorMessage = sb . stub ( vs . window , "s" ) ; showErrorMessage . resolves ( debugAnywayAction ) ; const config = await startDebugger ( helloWorldMainFile ) ; assert ( config ) ; assert ( showErrorMessage . calledOnce ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutput ( "s" , "s" ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { log ( `template` ) ; await writeBrokenDartCodeIntoFileForTest ( getTempTestFile ( ) ) ; const showErrorMessage = sb . stub ( vs . window , "s" ) ; showErrorMessage . resolves ( debugAnywayAction ) ; const config = await startDebugger ( helloWorldMainFile ) ; assert ( config ) ; assert ( ! showErrorMessage . calledOnce ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutput ( "s" , "s" ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const tempTestScript = getTempProjectFile ( ) ; await writeBrokenDartCodeIntoFileForTest ( tempTestScript ) ; const showErrorMessage = sb . stub ( vs . window , "s" ) ; showErrorMessage . resolves ( showErrorsAction ) ; const config = await getLaunchConfiguration ( tempTestScript ) ; assert . strictEqual ( config , undefined ) ; assert ( showErrorMessage . calledOnce ) ; } ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( helloWorldMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutput ( "s" , "s" ) , dc . assertOutput ( "s" , `template` ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( helloWorldMainFile ) ; config ! . vmAdditionalArgs = [ "s" ] ; await Promise . all ( [ dc . assertOutputContains ( "s" , "s" ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( helloWorldMainFile ) ; config ! . program = path . relative ( fsPath ( helloWorldFolder ) , fsPath ( helloWorldMainFile ) ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutput ( "s" , "s" ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( helloWorldMainFile , { cwd : "s" } ) ; config . program = path . relative ( fsPath ( helloWorldFolder ) , fsPath ( helloWorldMainFile ) ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutput ( "s" , "s" ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await closeAllOpenFiles ( ) ; const config = await startDebugger ( ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutput ( "s" , "s" ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const config = await startDebugger ( helloWorldGoodbyeFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutput ( "s" , "s" ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldGoodbyeFile ) ; const config = await startDebugger ( ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutput ( "s" , "s" ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldExampleSubFolderMainFile ) ; const config = await startDebugger ( ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , "s" ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( undefined , { cwd : "s" } ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , "s" ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . dartCapabilities . supportsDevTools ) { this . skip ( ) ; return ; } const openBrowserCommand = sb . stub ( extApi . envUtils , "s" ) . withArgs ( sinon . match . any ) . resolves ( true ) ; await openFile ( helloWorldMainFile ) ; const config = await startDebugger ( helloWorldMainFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldMainFile ) , } ) ; const devTools = await vs . commands . executeCommand ( "s" ) as { url : string , dispose : ( ) => void } ; assert . ok ( openBrowserCommand . calledOnce ) ; assert . ok ( devTools ) ; defer ( devTools . dispose ) ; assert . ok ( devTools . url ) ; const serverResponse = await fetch ( devTools . url ) ; assert . notEqual ( serverResponse . indexOf ( "s" ) , - 0 ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const config = await startDebugger ( helloWorldMainFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldMainFile ) , } ) ; const stack = await dc . getStack ( ) ; const frames = stack . body . stackFrames ; assert . equal ( frames [ 0 ] . name , "s" ) ; assert . equal ( frames [ 0 ] . source ! . path , fsPath ( helloWorldMainFile ) ) ; assert . equal ( frames [ 0 ] . source ! . name , path . relative ( fsPath ( helloWorldFolder ) , fsPath ( helloWorldMainFile ) ) ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const config = await startDebugger ( helloWorldMainFile ) ; config . noDebug = true ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . setBreakpointWithoutHitting ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldMainFile ) , verified : false , } ) , ] ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . dartCapabilities . handlesBreakpointsInPartFiles ) { this . skip ( ) ; return ; } await openFile ( helloWorldPartFile ) ; const config = await startDebugger ( helloWorldPartEntryFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( helloWorldPartFile ) , } ) ; const stack = await dc . getStack ( ) ; const frames = stack . body . stackFrames ; assert . equal ( frames [ 0 ] . name , "s" ) ; assert . equal ( frames [ 0 ] . source ! . path , fsPath ( helloWorldPartFile ) ) ; assert . equal ( frames [ 0 ] . source ! . name , "s" ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldDeferredScriptFile ) ; const config = await startDebugger ( helloWorldDeferredEntryFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( helloWorldDeferredScriptFile ) , } ) ; const stack = await dc . getStack ( ) ; const frames = stack . body . stackFrames ; assert . equal ( frames [ 0 ] . name , "s" ) ; assert . equal ( frames [ 0 ] . source ! . path , fsPath ( helloWorldDeferredScriptFile ) ) ; assert . equal ( frames [ 0 ] . source ! . name , "s" ) ; } ) ; it . skip ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const def = await getDefinition ( positionOf ( "s" ) ) ; const config = await startDebugger ( helloWorldMainFile ) ; await dc . hitBreakpoint ( config , { line : def . range . start . line + 0 , path : fsPath ( def . uri ) , } ) ; const stack = await dc . getStack ( ) ; const frames = stack . body . stackFrames ; assert . equal ( frames [ 0 ] . name , "s" ) ; assert . equal ( frames [ 0 ] . source ! . path , fsPath ( def . uri ) ) ; assert . equal ( frames [ 0 ] . source ! . name , "s" ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldHttpFile ) ; const def = await getDefinition ( positionOf ( "s" ) ) ; const config = await startDebugger ( helloWorldHttpFile , { debugExternalLibraries : true } ) ; await dc . hitBreakpoint ( config , { line : def . range . start . line + 0 , path : fsPath ( def . uri ) , } ) ; const stack = await dc . getStack ( ) ; const frames = stack . body . stackFrames ; assert . equal ( frames [ 0 ] . name , "s" ) ; assert . equal ( frames [ 0 ] . source ! . path , fsPath ( def . uri ) ) ; assert . equal ( frames [ 0 ] . source ! . name , "s" ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const printCall = positionOf ( "s" ) ; const config = await startDebugger ( helloWorldMainFile , { debugSdkLibraries : true } ) ; await dc . hitBreakpoint ( config , { line : printCall . line + 0 , path : fsPath ( helloWorldMainFile ) , } ) ; await Promise . all ( [ dc . assertStoppedLocation ( "s" , { path : undefined , } ) . then ( ( response ) => { const frame = response . body . stackFrames [ 0 ] ; assert . equal ( frame . name , "s" ) ; assert . equal ( frame . source ! . path , undefined ) ; assert . equal ( frame . source ! . name , "s" ) ; } ) , dc . stepIn ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const printCall = positionOf ( "s" ) ; const config = await startDebugger ( helloWorldMainFile , { debugSdkLibraries : false } ) ; await dc . hitBreakpoint ( config , { line : printCall . line + 0 , path : fsPath ( helloWorldMainFile ) , } ) ; await Promise . all ( [ dc . assertStoppedLocation ( "s" , { path : fsPath ( helloWorldMainFile ) , } ) , dc . stepIn ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldHttpFile ) ; const httpReadCall = positionOf ( "s" ) ; const httpReadDef = await getDefinition ( httpReadCall ) ; const config = await startDebugger ( helloWorldHttpFile , { debugExternalLibraries : true } ) ; await dc . hitBreakpoint ( config , { line : httpReadCall . line + 0 , path : fsPath ( helloWorldHttpFile ) , } ) ; await Promise . all ( [ dc . assertStoppedLocation ( "s" , { path : fsPath ( httpReadDef . uri ) , } ) . then ( ( response ) => { const frame = response . body . stackFrames [ 0 ] ; assert . equal ( frame . name , "s" ) ; assert . equal ( frame . source ! . path , fsPath ( httpReadDef . uri ) ) ; assert . equal ( frame . source ! . name , "s" ) ; } ) , dc . stepIn ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldHttpFile ) ; const httpReadCall = positionOf ( "s" ) ; const config = await startDebugger ( helloWorldHttpFile , { debugExternalLibraries : false } ) ; await dc . hitBreakpoint ( config , { line : httpReadCall . line , path : fsPath ( helloWorldHttpFile ) , } ) ; await Promise . all ( [ dc . assertStoppedLocation ( "s" , { path : fsPath ( helloWorldHttpFile ) , } ) , dc . stepIn ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldLocalPackageFile ) ; const printMyThingCall = positionOf ( "s" ) ; const printMyThingDef = await getDefinition ( printMyThingCall ) ; const config = await startDebugger ( helloWorldLocalPackageFile , { debugExternalLibraries : false } ) ; await dc . hitBreakpoint ( config , { line : printMyThingCall . line + 0 , path : fsPath ( helloWorldLocalPackageFile ) , } ) ; await Promise . all ( [ dc . assertStoppedLocation ( "s" , { path : fsPath ( printMyThingDef . uri ) , } ) . then ( ( response ) => { const frame = response . body . stackFrames [ 0 ] ; assert . equal ( frame . name , "s" ) ; assert . equal ( frame . source ! . path , fsPath ( printMyThingDef . uri ) ) ; assert . equal ( frame . source ! . name , "s" ) ; } ) , dc . stepIn ( ) , ] ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . dartCapabilities . includesSourceForSdkLibs ) { this . skip ( ) ; return ; } await openFile ( helloWorldMainFile ) ; const printCall = positionOf ( "s" ) ; const config = await startDebugger ( helloWorldMainFile , { debugSdkLibraries : true } ) ; await dc . hitBreakpoint ( config , { line : printCall . line + 0 , path : fsPath ( helloWorldMainFile ) , } ) ; await Promise . all ( [ dc . assertStoppedLocation ( "s" , { path : undefined , } ) . then ( async ( response ) => { const frame = response . body . stackFrames [ 0 ] ; assert . equal ( frame . source ! . path , undefined ) ; assert . equal ( frame . source ! . name , "s" ) ; const source = await dc . sourceRequest ( { source : frame . source , sourceReference : frame . source ! . sourceReference ! } ) ; assert . ok ( source . body . content ) ; assert . notEqual ( source . body . content . indexOf ( "s" ) , - 0 ) ; assert . notEqual ( source . body . content . indexOf ( "s" ) , - 0 ) ; } ) , dc . stepIn ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldThrowInSdkFile ) ; const config = await startDebugger ( helloWorldThrowInSdkFile , { debugSdkLibraries : false } ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const stack = await dc . getStack ( ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isSdkFrame ) , "s" , "s" ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isUserCode ) , undefined , undefined ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldThrowInSdkFile ) ; const config = await startDebugger ( helloWorldThrowInSdkFile , { debugSdkLibraries : true } ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const stack = await dc . getStack ( ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isSdkFrame ) , undefined , undefined ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isUserCode ) , undefined , undefined ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldThrowInExternalPackageFile ) ; const config = await startDebugger ( helloWorldThrowInExternalPackageFile , { debugExternalLibraries : false } ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const stack = await dc . getStack ( ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isExternalPackage ) , "s" , "s" ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isUserCode ) , undefined , undefined ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldThrowInExternalPackageFile ) ; const config = await startDebugger ( helloWorldThrowInExternalPackageFile , { debugExternalLibraries : true } ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const stack = await dc . getStack ( ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isExternalPackage ) , undefined , undefined ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isUserCode ) , undefined , undefined ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldThrowInLocalPackageFile ) ; const config = await startDebugger ( helloWorldThrowInLocalPackageFile , { debugExternalLibraries : false } ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const stack = await dc . getStack ( ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isLocalPackage ) , undefined , undefined ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isUserCode ) , undefined , undefined ) ; } ) ; function testBreakpointCondition ( condition , shouldStop , expectedError ? ) { return async ( ) => { await openFile ( helloWorldMainFile ) ; const config = await startDebugger ( helloWorldMainFile ) ; const completionEvent < any > = shouldStop ? dc . assertStoppedLocation ( "s" , { } ) . then ( ( ) => dc . waitForEvent ( "s" ) ) : dc . waitForEvent ( "s" ) ; const errorOutputEvent < any > = expectedError ? dc . assertOutput ( "s" , expectedError ) : Promise . resolve ( ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) . then ( ( event ) => { return dc . setBreakpointsRequest ( { breakpoints : [ { condition , line : positionOf ( "s" ) . line + 0 , } ] , source : { path : fsPath ( helloWorldMainFile ) } , } ) ; } ) . then ( ( ) => dc . configurationDoneRequest ( ) ) . then ( ( ) => delay ( 0 ) ) . then ( ( ) => dc . terminateRequest ( ) ) , completionEvent , errorOutputEvent , dc . launch ( config ) , ] ) ; } ; } it ( "s" , testBreakpointCondition ( "s" , true ) ) ; it ( "s" , testBreakpointCondition ( "s" , true ) ) ; it ( "s" , testBreakpointCondition ( "s" , false ) ) ; it ( "s" , testBreakpointCondition ( "s" , false ) ) ; it ( "s" , testBreakpointCondition ( "s" , false ) ) ; it ( "s" , testBreakpointCondition ( "s" , false ) ) ; it ( "s" , testBreakpointCondition ( "s" , false , "s" ) ) ; it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const config = await startDebugger ( helloWorldMainFile ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) . then ( ( event ) => { return dc . setBreakpointsRequest ( { breakpoints : [ { line : positionOf ( "s" ) . line + 0 , logMessage : 's' , } ] , source : { path : fsPath ( helloWorldMainFile ) } , } ) ; } ) . then ( ( response ) => dc . configurationDoneRequest ( ) ) , dc . waitForEvent ( "s" ) , dc . assertOutputContains ( "s" , `template` ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await setConfigForTest ( "s" , "s" , true ) ; await openFile ( helloWorldMainFile ) ; const debugConfig = await startDebugger ( helloWorldMainFile ) ; await dc . hitBreakpoint ( debugConfig , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldMainFile ) , } ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; const listVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; for ( let i = 0 ; i <= 0 ; i ++ ) { ensureVariableWithIndex ( listVariables , i , `template` , `template` , `template` ) ; } const longStringListVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; ensureVariable ( longStringListVariables , "s" , "s" , { ends : "s" , starts : "s" , } ) ; const shortdateListVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; ensureVariable ( shortdateListVariables , "s" , "s" , "s" ) ; const longdateListVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; ensureVariable ( longdateListVariables , "s" , "s" , "s" ) ; const mapVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : `template` } , value : { evaluateName : `template` , name : "s" , value : "s" } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : `template` } , value : { evaluateName : `template` , name : "s" , value : "s" } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : `template` } , value : { evaluateName : `template` , name : "s" , value : `template` } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : `template` } , value : { evaluateName : undefined , name : "s" , value : `template` } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : `template` } , value : { evaluateName : undefined , name : "s" , value : `template` } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : "s" } , value : { evaluateName : `template` , name : "s" , value : "s" } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : "s" } , value : { evaluateName : `template` , name : "s" , value : `template` } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : "s" } , value : { evaluateName : `template` , name : "s" , value : `template` } , } , dc ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const debugConfig = await startDebugger ( helloWorldMainFile ) ; await dc . hitBreakpoint ( debugConfig , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldMainFile ) , } ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; assert . equal ( variables . length , 0 ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldGettersFile ) ; const config = await startDebugger ( helloWorldGettersFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldGettersFile ) , } ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; const classInstance = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; ensureVariable ( classInstance , "s" , "s" , `template` ) ; ensureVariable ( classInstance , "s" , "s" , `template` ) ; ensureVariable ( classInstance , undefined , "s" , { starts : "s" } ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const config = await startDebugger ( helloWorldMainFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldMainFile ) , } ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; for ( const variable of variables ) { const evaluateName = ( variable as any ) . evaluateName ; if ( ! evaluateName ) continue ; const evaluateResult = await dc . evaluate ( evaluateName ) ; assert . ok ( evaluateResult ) ; assert . equal ( evaluateResult . result , variable . value ) ; assert . equal ( ! ! evaluateResult . variablesReference , ! ! variable . variablesReference ) ; } } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const config = await startDebugger ( helloWorldMainFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldMainFile ) , } ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; const listVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; const listLongstringVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; const mapVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; const allVariables = listVariables . concat ( listLongstringVariables ) . concat ( mapVariables ) ; for ( const variable of allVariables ) { const evaluateName = ( variable as any ) . evaluateName ; if ( ! evaluateName ) continue ; const evaluateResult = await dc . evaluate ( evaluateName ) ; assert . ok ( evaluateResult ) ; if ( variable . value . endsWith ( "s" ) ) { const prefix = variable . value . slice ( 0 , - 0 ) ; assert . ok ( evaluateResult . result . length > prefix . length ) ; assert . equal ( evaluateResult . result . slice ( 0 , prefix . length ) , prefix ) ; } else { assert . equal ( evaluateResult . result , variable . value ) ; } assert . equal ( ! ! evaluateResult . variablesReference , ! ! variable . variablesReference ) ; } } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const config = await startDebugger ( helloWorldMainFile ) ; await Promise . all ( [ dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( helloWorldMainFile ) , } ) , ] ) ; const evaluateResult = await dc . evaluate ( `template` ) ; assert . ok ( evaluateResult ) ; assert . equal ( evaluateResult . result , `template` ) ; assert . equal ( evaluateResult . variablesReference , 0 ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const config = await startDebugger ( helloWorldMainFile ) ; await Promise . all ( [ dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( helloWorldMainFile ) , } ) , ] ) ; const evaluateResult = await dc . evaluate ( `template` ) ; assert . ok ( evaluateResult ) ; assert . equal ( evaluateResult . result , ( new Date ( ) ) . getFullYear ( ) ) ; assert . equal ( evaluateResult . variablesReference , 0 ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const config = await startDebugger ( helloWorldMainFile ) ; await Promise . all ( [ dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( helloWorldMainFile ) , } ) , ] ) ; const evaluateResult = await dc . evaluate ( `template` ) ; const thisYear = new Date ( ) . getFullYear ( ) . toString ( ) ; assert . ok ( evaluateResult ) ; assert . ok ( evaluateResult . result . startsWith ( "s" + thisYear ) , `template` ) ; assert . ok ( evaluateResult . variablesReference ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldMainFile ) ; const config = await startDebugger ( helloWorldMainFile ) ; await Promise . all ( [ dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( helloWorldMainFile ) , } ) , ] ) ; const evaluateResult = await dc . evaluate ( `template` ) ; assert . ok ( evaluateResult ) ; assert . equal ( evaluateResult . result , ( new Date ( ) ) . getFullYear ( ) ) ; assert . equal ( evaluateResult . variablesReference , 0 ) ; } ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldBrokenFile ) ; const config = await startDebugger ( helloWorldBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldBrokenFile ) , } ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldBrokenFile ) ; const config = await startDebugger ( helloWorldBrokenFile ) ; config . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldBrokenFile ) ; const config = await startDebugger ( helloWorldBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldBrokenFile ) , } ) , dc . launch ( config ) , ] ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldBrokenFile ) ; const config = await startDebugger ( helloWorldBrokenFile ) ; config ! . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutput ( "s" , "s" ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldBrokenFile ) ; const config = await startDebugger ( helloWorldBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) . then ( ( ) => dc . setExceptionBreakpointsRequest ( { filters : [ ] } ) ) , watchPromise ( "s" , dc . assertOutputContains ( "s" , "s" ) . then ( ( event ) => { assert . equal ( event . body . output . indexOf ( "s" ) , - 0 ) ; assert . equal ( event . body . source ! . name , path . join ( "s" , "s" ) ) ; assert . equal ( event . body . source ! . path , fsPath ( helloWorldBrokenFile ) ) ; assert . equal ( event . body . line , positionOf ( "s" ) . line + 0 ) ; assert . equal ( event . body . column , 0 ) ; } ) , ) , watchPromise ( "s" , dc . launch ( config ) ) , ] ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const process = spawnDartProcessPaused ( await getLaunchConfiguration ( helloWorldMainFile ) ) ; const observatoryUri = await process . observatoryUri ; const config = await attachDebugger ( observatoryUri ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const vmArgs = extApi . dartCapabilities . supportsDisableServiceTokens ? [ "s" ] : [ ] ; const process = spawnDartProcessPaused ( await getLaunchConfiguration ( helloWorldMainFile ) , ... vmArgs ) ; const observatoryUri = await process . observatoryUri ; const observatoryPort = "s" . exec ( observatoryUri ) ! [ 0 ] ; const config = await attachDebugger ( `template` ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const process = spawnDartProcessPaused ( await getLaunchConfiguration ( helloWorldMainFile ) ) ; const observatoryUri = await process . observatoryUri ; const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( observatoryUri ) ; const config = await attachDebugger ( undefined ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; assert . ok ( showInputBox . calledOnce ) ; } ) ; it ( "s" , async ( ) => { const process = spawnDartProcessPaused ( await getLaunchConfiguration ( helloWorldMainFile ) ) ; const observatoryUri = await process . observatoryUri ; const config = await attachDebugger ( observatoryUri ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldMainFile ) , } ) ; } ) ; it ( "s" , async ( ) => { const process = spawnDartProcessPaused ( await getLaunchConfiguration ( helloWorldMainFile ) ) ; const observatoryUri = await process . observatoryUri ; const config = await attachDebugger ( observatoryUri ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldMainFile ) , } ) ; log ( "s" ) ; await dc . terminateRequest ( ) ; log ( "s" ) ; log ( "s" ) ; await process . exitCode ; } ) ; it ( "s" ) ; } ) ; } ) ;	O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O $Promise<string>$ O O O O O O $string$ O O O O O O $number$ O O O O O O $string$ O O O O O O $any$ O O O O O O $void$ O $Promise<void>$ O $void$ O $void$ O $boolean$ O $any$ O $any$ O $any$ O $DartProcess$ O O O O O O $Promise<void>$ O $Promise<void>$ O $void$ O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $Promise<any>$ O $Promise<any>$ O $Promise<any>$ O $Promise<void>$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Logger$ O $Promise<any>$ O $any$ O $any$ O $Promise<void>$ O $Promise<T>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O O $DartDebugClient$ O $any$ O O O O O O O $DartDebugClient$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $undefined$ O $InternalExtensionApi$ O $DebugCommandHandler$ O $undefined$ O O $DartDebugClient$ O $number$ O O O O $DartDebugClient$ O $DartDebugClient$ O $void$ O O O O $DartDebugClient$ O $Promise<void>$ O O O O O O O O O $Promise$ O $any$ O O $any$ O $any$ O $complex$ O O O O $string$ O O O O O O $any$ O $any$ O O O $any$ O O O $Promise<any>$ O $any$ O $complex$ O O O O O O $any$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O $any$ O O O O $any$ O O O O $Promise$ O $string$ O O O O O $complex$ O O O O $string$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O $Promise<any>$ O $ObjectConstructor$ O O O O $string$ O O $complex$ O O O O O O $any$ O O O $ErrorConstructor$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O $any$ O O O $any$ O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O $string$ O O O O O $any$ O O O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O $string$ O O O O $any$ O O O O O O O O O $Promise<void>$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $Logger$ O $void$ O O O O O $Promise<void>$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O $Promise<void>$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $Promise<void>$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $string$ O $any$ O O $string$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $string$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $any$ O O $Promise<any>$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $undefined$ O O $string$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O $string$ O O O $void$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $complex$ O O $void$ O $complex$ O $void$ O O $any$ O $any$ O $complex$ O $string$ O O O $string$ O O $Promise<string>$ O $complex$ O $string$ O O $any$ O $any$ O $string$ O $number$ O O O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $string$ O $any$ O O $string$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O $false$ O O O O O O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $undefined$ O $undefined$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $string$ O $string$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $string$ O $string$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $string$ O $string$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $undefined$ O $undefined$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O O $undefined$ O $undefined$ O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O O O O O $Promise<void>$ O $string$ O $boolean$ O $string$ $string$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $Promise$ O O O O $boolean$ O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O $Promise$ O O O O $string$ O $DartDebugClient$ O $Promise<any>$ O O O $string$ O O $PromiseConstructor$ O $complex$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $any$ O O O O $DartDebugClient$ O $Promise<any>$ O O $complex$ O O O $string$ O $any$ O $any$ O O O O $any$ O O O O O O $complex$ O O $string$ O $string$ O $any$ O O O O O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $Promise<void>$ O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $Promise<any>$ O $Promise<any>$ O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $any$ O O O O $DartDebugClient$ O $Promise<any>$ O O $complex$ O O O $any$ O $any$ O O O O $any$ O O O $string$ O O O O O O $complex$ O O $string$ O $string$ O $any$ O O O O O O O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O O O O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O $number$ O O O $number$ O O O $number$ O O O $void$ O $any[]$ O $number$ O O O O O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O $any[]$ O O O O O O $string$ O O O $string$ O O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O $any[]$ O O O O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O $any[]$ O O O O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O $any$ O $any$ O $any[]$ O $number$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O $undefined$ O O O O $string$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O O O O $any$ O $any[]$ O O O $any$ O O $any$ O O O O $any$ O O O O $any$ O O O O $complex$ O O $DartDebugClient$ O $complex$ O $any$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O $any$ O $any$ O O $any$ O $any$ O O O $complex$ O $number$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any[]$ O $any[]$ O $complex$ O $any[]$ O O $complex$ O $any[]$ O O O O O $any$ O $any[]$ O O O $any$ O O $any$ O O O O $any$ O O O O $any$ O O O O $complex$ O O $DartDebugClient$ O $complex$ O $any$ O O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $complex$ O $string$ O $number$ O $any$ O $any$ O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $complex$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O O O $complex$ O $number$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O O O O $complex$ O O $DartDebugClient$ O $complex$ O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O O O O $any$ O $any$ O $complex$ O $number$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O O O O $complex$ O O $DartDebugClient$ O $complex$ O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O O O $DateConstructor$ O O O O $number$ O O O O $any$ O $any$ O $complex$ O $number$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O O O O $complex$ O O $DartDebugClient$ O $complex$ O O O O O $string$ O O $DateConstructor$ O O O $number$ O O O $string$ O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O $boolean$ O O O $string$ O O O O O $any$ O $any$ O $complex$ O $number$ O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O O O O $complex$ O O $DartDebugClient$ O $complex$ O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O O O $DateConstructor$ O O O O $number$ O O O O $any$ O $any$ O $complex$ O $number$ O O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O $undefined[]$ O O O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $DartProcess$ O $DartProcess$ O O $Promise<any>$ O $any$ O O O O $string$ O O $DartProcess$ O $Promise<string>$ O O $any$ O O $Promise<any>$ O $string$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $string[]$ O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O O O O O O $DartProcess$ O $DartProcess$ O O $Promise<any>$ O $any$ O O O $string[]$ O O O $string$ O O $DartProcess$ O $Promise<string>$ O O $string$ O O O $RegExpExecArray$ O $string$ O O O O O O O $any$ O O $Promise<any>$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $DartProcess$ O $DartProcess$ O O $Promise<any>$ O $any$ O O O O $string$ O O $DartProcess$ O $Promise<string>$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O O $any$ O O $Promise<any>$ O $undefined$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $DartProcess$ O $DartProcess$ O O $Promise<any>$ O $any$ O O O O $string$ O O $DartProcess$ O $Promise<string>$ O O $any$ O O $Promise<any>$ O $string$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O O O O $any$ O O O O O O O O O $DartProcess$ O $DartProcess$ O O $Promise<any>$ O $any$ O O O O $string$ O O $DartProcess$ O $Promise<string>$ O O $any$ O O $Promise<any>$ O $string$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O $any$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O $any$ O O O O $any$ O O O O O $DartProcess$ O $Promise<number>$ O O O O $any$ O O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { DebugProtocol } from "s" ; import { TestStatus } from "s" ; import { TestOutlineVisitor } from "s" ; import { makeRegexForTest } from "s" ; import { fsPath } from "s" ; import { DartDebugClient } from "s" ; import { activate , defer , delay , ext , extApi , getExpectedResults , getLaunchConfiguration , getPackages , helloWorldTestBrokenFile , helloWorldTestDupeNameFile , helloWorldTestMainFile , helloWorldTestSkipFile , helloWorldTestTreeFile , logger , makeTextTree , openFile , positionOf , withTimeout } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , ( ) => activate ( helloWorldTestMainFile ) ) ; let dc ; beforeEach ( "s" , ( ) => { dc = new DartDebugClient ( process . execPath , path . join ( ext . extensionPath , "s" ) , "s" , undefined , extApi . debugCommands , extApi . testTreeProvider , ) ; dc . defaultTimeout = 0 ; const thisDc = dc ; defer ( ( ) => withTimeout ( Promise . all ( [ thisDc . terminateRequest ( ) . catch ( ( e ) => logger . info ( e ) ) , delay ( 0 ) . then ( ( ) => thisDc . stop ( ) ) . catch ( ( e ) => logger . info ( e ) ) , ] ) , "s" , 0 , ) ) ; } ) ; async function startDebugger ( script : vs . Uri | string , extraConfiguration ? : { [ key ] : any } ) < vs . DebugConfiguration | undefined | null > { const config = await getLaunchConfiguration ( script , extraConfiguration ) ; if ( ! config ) throw new Error ( `template` ) ; await dc . start ( config . debugServer ) ; return config ; } it ( "s" , async ( ) => { const config = await startDebugger ( helloWorldTestMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( helloWorldTestMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutput ( "s" , `template` ) , dc . assertPassingTest ( "s" ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldTestMainFile ) ; const config = await startDebugger ( helloWorldTestMainFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldTestMainFile ) , } ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldTestBrokenFile ) ; const config = await startDebugger ( helloWorldTestBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { } ) , dc . launch ( config ) , ] ) ; } ) ; it . skip ( "s" , async ( ) => { await openFile ( helloWorldTestBrokenFile ) ; const config = await startDebugger ( helloWorldTestBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( helloWorldTestBrokenFile ) , } ) , dc . launch ( config ) , ] ) ; } ) ; it . skip ( "s" , async ( ) => { await openFile ( helloWorldTestBrokenFile ) ; const config = await startDebugger ( helloWorldTestBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { } ) , dc . launch ( config ) , ] ) ; const variables = await dc . getTopFrameVariables ( "s" ) as DebugProtocol . Variable [ ] ; assert . ok ( variables ) ; let v = variables . find ( ( v ) => v . name === "s" ) ; assert . ok ( v ) ; v = v ! ; assert . equal ( v . evaluateName , "s" ) ; const expectedStart = `template` ; assert . ok ( v . value . startsWith ( expectedStart ) , `template` + `template` + `template` + `template` , ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldTestBrokenFile ) ; const config = await startDebugger ( helloWorldTestBrokenFile ) ; config ! . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertFailingTest ( "s" ) , dc . assertOutput ( "s" , `template` ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldTestTreeFile ) ; const config = await startDebugger ( helloWorldTestTreeFile ) ; config ! . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const expectedResults = getExpectedResults ( ) ; const actualResults = ( await makeTextTree ( helloWorldTestTreeFile , extApi . testTreeProvider ) ) . join ( "s" ) ; assert . ok ( expectedResults ) ; assert . ok ( actualResults ) ; assert . equal ( actualResults , expectedResults ) ; } ) ; it ( "s" , async ( ) => { for ( const file of [ helloWorldTestSkipFile , helloWorldTestMainFile , helloWorldTestTreeFile , helloWorldTestBrokenFile ] ) { await openFile ( file ) ; const config = await startDebugger ( file ) ; config ! . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } const topLevelNodes = await extApi . testTreeProvider . getChildren ( ) ; assert . ok ( topLevelNodes ) ; assert . equal ( topLevelNodes ! . length , 0 ) ; assert . equal ( topLevelNodes ! [ 0 ] . resourceUri ! . toString ( ) , helloWorldTestBrokenFile . toString ( ) ) ; assert . equal ( topLevelNodes ! [ 0 ] . status , TestStatus . Failed ) ; assert . equal ( topLevelNodes ! [ 0 ] . resourceUri ! . toString ( ) , helloWorldTestTreeFile . toString ( ) ) ; assert . equal ( topLevelNodes ! [ 0 ] . status , TestStatus . Failed ) ; assert . equal ( topLevelNodes ! [ 0 ] . resourceUri ! . toString ( ) , helloWorldTestMainFile . toString ( ) ) ; assert . equal ( topLevelNodes ! [ 0 ] . status , TestStatus . Passed ) ; assert . equal ( topLevelNodes ! [ 0 ] . resourceUri ! . toString ( ) , helloWorldTestSkipFile . toString ( ) ) ; assert . equal ( topLevelNodes ! [ 0 ] . status , TestStatus . Skipped ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( "s" ) ; config ! . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const topLevelNodes = await extApi . testTreeProvider . getChildren ( ) ; assert . ok ( topLevelNodes ) ; assert . equal ( topLevelNodes ! . length , 0 ) ; } ) ; it ( "s" , async ( ) => { async function checkResults ( description ) < void > { logger . info ( description ) ; const expectedResults = getExpectedResults ( ) ; const actualResults = ( await makeTextTree ( helloWorldTestTreeFile , extApi . testTreeProvider ) ) . join ( "s" ) ; assert . ok ( expectedResults ) ; assert . ok ( actualResults ) ; assert . equal ( actualResults , expectedResults ) ; } await runWithoutDebugging ( helloWorldTestTreeFile ) ; let numRuns = 0 ; await checkResults ( `template` ) ; const visitor = new TestOutlineVisitor ( logger ) ; const outline = extApi . fileTracker . getOutlineFor ( helloWorldTestTreeFile ) ; if ( ! outline ) throw new Error ( `template` ) ; visitor . visit ( outline ) ; for ( const test of visitor . tests . filter ( ( t ) => ! t . isGroup ) ) { await runWithoutDebugging ( helloWorldTestTreeFile , [ "s" , makeRegexForTest ( test . fullName , test . isGroup ) ] ) ; await checkResults ( `template` ) ; } } ) . timeout ( 0 ) ; it ( "s" , async ( ) => { async function checkResults ( description ) < void > { logger . info ( description ) ; const expectedResults = getExpectedResults ( ) ; const actualResults = ( await makeTextTree ( helloWorldTestDupeNameFile , extApi . testTreeProvider ) ) . join ( "s" ) ; assert . ok ( expectedResults ) ; assert . ok ( actualResults ) ; assert . equal ( actualResults , expectedResults ) ; } await runWithoutDebugging ( helloWorldTestDupeNameFile ) ; let numRuns = 0 ; await checkResults ( `template` ) ; const visitor = new TestOutlineVisitor ( logger ) ; const outline = extApi . fileTracker . getOutlineFor ( helloWorldTestDupeNameFile ) ; if ( ! outline ) throw new Error ( `template` ) ; visitor . visit ( outline ) ; const doc = await vs . workspace . openTextDocument ( helloWorldTestDupeNameFile ) ; const editor = await vs . window . showTextDocument ( doc ) ; for ( const modifyFile of [ false , true ] ) { if ( modifyFile ) await editor . edit ( ( e ) => e . insert ( doc . positionAt ( 0 ) , "s" ) ) ; for ( const test of visitor . tests . filter ( ( t ) => ! t . isGroup ) ) { await runWithoutDebugging ( helloWorldTestDupeNameFile , [ "s" , makeRegexForTest ( test . fullName , test . isGroup ) ] ) ; await checkResults ( `template` ) ; } for ( const group of visitor . tests . filter ( ( t ) => t . isGroup ) ) { await runWithoutDebugging ( helloWorldTestDupeNameFile , [ "s" , makeRegexForTest ( group . fullName , group . isGroup ) ] ) ; await checkResults ( `template` ) ; } } } ) . timeout ( 0 ) ; it . skip ( "s" , ( ) => { } ) ; async function runWithoutDebugging ( file : vs . Uri , args ? : string [ ] ) < void > { await openFile ( file ) ; const config = await startDebugger ( file , { args , noDebug : true } ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O O $string$ O O O O O O $any$ O O O O O O $Promise<void>$ O $void$ O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $any$ O $Promise<any>$ O $Promise<void>$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Logger$ O $Promise<string[]>$ O $Promise<any>$ O $any$ O $Promise<T>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O O $DartDebugClient$ O $any$ O O O O O O O $DartDebugClient$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $undefined$ O $InternalExtensionApi$ O $DebugCommandHandler$ O $InternalExtensionApi$ O $TestResultsProvider$ O O O $DartDebugClient$ O $number$ O O O O $DartDebugClient$ O $DartDebugClient$ O $void$ O O O O $Promise<T>$ O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $Promise<any>$ O O $any$ O O $Logger$ O $void$ O $any$ O O O $Promise<void>$ O O O O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $complex$ O O $any$ O O $Logger$ O $void$ O $any$ O O O O O O O O O O O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O O O $complex$ O O O O $string$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O $Promise<any>$ O $any$ O $complex$ O O O O O $any$ O O O $ErrorConstructor$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O $any$ O O O $any$ O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any[]$ O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O $any$ O O O O $string$ O O O $Promise<string[]>$ O $any$ O $InternalExtensionApi$ O $TestResultsProvider$ O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O $any$ O O O O O $any$ O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O $any$ O O $InternalExtensionApi$ O $TestResultsProvider$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $TestStatus.Failed$ O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $TestStatus.Failed$ O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $TestStatus.Passed$ O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $TestStatus.Skipped$ O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O O O $any$ O O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O O $InternalExtensionApi$ O $TestResultsProvider$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O $Promise$ O $string$ O O O O O $Logger$ O $void$ O $string$ O O O $any$ O $any$ O O O O $string$ O O O $Promise<string[]>$ O $any$ O $InternalExtensionApi$ O $TestResultsProvider$ O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O $any$ O O O O $Promise<void>$ O $any$ O O O $number$ O O O O $Promise<void>$ O O O O O $TestOutlineVisitor$ O O $any$ O $Logger$ O O O $Outline$ O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O O $Outline$ O O O $ErrorConstructor$ O O O O $TestOutlineVisitor$ O $void$ O $Outline$ O O O O O $TestOutlineInfo$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O $complex$ O O $TestOutlineInfo$ O O O $TestOutlineInfo$ O $boolean$ O O O O $Promise<void>$ O $any$ O O O O $string$ O $TestOutlineInfo$ O $string$ O $TestOutlineInfo$ O $boolean$ O O O O O $Promise<void>$ O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O $Promise$ O $string$ O O O O O $Logger$ O $void$ O $string$ O O O $any$ O $any$ O O O O $string$ O O O $Promise<string[]>$ O $any$ O $InternalExtensionApi$ O $TestResultsProvider$ O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O $any$ O O O O $Promise<void>$ O $any$ O O O $number$ O O O O $Promise<void>$ O O O O O $TestOutlineVisitor$ O O $any$ O $Logger$ O O O $Outline$ O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O O $Outline$ O O O $ErrorConstructor$ O O O O $TestOutlineVisitor$ O $void$ O $Outline$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O O O O O O O O O O $boolean$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $TestOutlineInfo$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O $complex$ O O $TestOutlineInfo$ O O O $TestOutlineInfo$ O $boolean$ O O O O $Promise<void>$ O $any$ O O O O $string$ O $TestOutlineInfo$ O $string$ O $TestOutlineInfo$ O $boolean$ O O O O O $Promise<void>$ O O O O O O O O $TestOutlineInfo$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O $complex$ O O $TestOutlineInfo$ O O $TestOutlineInfo$ O $boolean$ O O O O $Promise<void>$ O $any$ O O O O $string$ O $TestOutlineInfo$ O $string$ O $TestOutlineInfo$ O $boolean$ O O O O O $Promise<void>$ O O O O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O $Promise$ O $any$ O $any$ O $any$ O $string[]$ O O O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $string[]$ O $boolean$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O O
import * as assert from "s" ; import { isWithinPath } from "s" ; import { fsPath } from "s" ; import { emptyFile , everythingFile , ext , flutterEmptyFile , flutterHelloWorldFolder , flutterHelloWorldMainFile , helloWorldFolder } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { assert . equal ( isWithinPath ( fsPath ( helloWorldFolder ) , ext . extensionPath ) , true ) ; assert . equal ( isWithinPath ( fsPath ( emptyFile ) , ext . extensionPath ) , true ) ; assert . equal ( isWithinPath ( fsPath ( everythingFile ) , ext . extensionPath ) , true ) ; assert . equal ( isWithinPath ( fsPath ( emptyFile ) , fsPath ( helloWorldFolder ) ) , true ) ; assert . equal ( isWithinPath ( fsPath ( everythingFile ) , fsPath ( helloWorldFolder ) ) , true ) ; assert . equal ( isWithinPath ( fsPath ( flutterHelloWorldFolder ) , ext . extensionPath ) , true ) ; assert . equal ( isWithinPath ( fsPath ( flutterEmptyFile ) , ext . extensionPath ) , true ) ; assert . equal ( isWithinPath ( fsPath ( flutterHelloWorldMainFile ) , ext . extensionPath ) , true ) ; assert . equal ( isWithinPath ( fsPath ( flutterEmptyFile ) , fsPath ( flutterHelloWorldFolder ) ) , true ) ; assert . equal ( isWithinPath ( fsPath ( flutterHelloWorldMainFile ) , fsPath ( flutterHelloWorldFolder ) ) , true ) ; } ) ; it ( "s" , ( ) => { assert . equal ( isWithinPath ( ext . extensionPath , fsPath ( helloWorldFolder ) ) , false ) ; assert . equal ( isWithinPath ( ext . extensionPath , fsPath ( emptyFile ) ) , false ) ; assert . equal ( isWithinPath ( ext . extensionPath , fsPath ( everythingFile ) ) , false ) ; assert . equal ( isWithinPath ( fsPath ( helloWorldFolder ) , fsPath ( emptyFile ) ) , false ) ; assert . equal ( isWithinPath ( fsPath ( helloWorldFolder ) , fsPath ( everythingFile ) ) , false ) ; assert . equal ( isWithinPath ( ext . extensionPath , fsPath ( flutterHelloWorldFolder ) ) , false ) ; assert . equal ( isWithinPath ( ext . extensionPath , fsPath ( flutterEmptyFile ) ) , false ) ; assert . equal ( isWithinPath ( ext . extensionPath , fsPath ( flutterHelloWorldMainFile ) ) , false ) ; assert . equal ( isWithinPath ( fsPath ( flutterHelloWorldFolder ) , fsPath ( flutterEmptyFile ) ) , false ) ; assert . equal ( isWithinPath ( fsPath ( flutterHelloWorldFolder ) , fsPath ( flutterHelloWorldMainFile ) ) , false ) ; } ) ; it ( "s" , ( ) => { assert . equal ( isWithinPath ( ext . extensionPath , ext . extensionPath ) , false ) ; assert . equal ( isWithinPath ( fsPath ( helloWorldFolder ) , fsPath ( helloWorldFolder ) ) , false ) ; assert . equal ( isWithinPath ( fsPath ( emptyFile ) , fsPath ( emptyFile ) ) , false ) ; assert . equal ( isWithinPath ( fsPath ( everythingFile ) , fsPath ( everythingFile ) ) , false ) ; assert . equal ( isWithinPath ( fsPath ( flutterHelloWorldFolder ) , fsPath ( flutterHelloWorldFolder ) ) , false ) ; assert . equal ( isWithinPath ( fsPath ( flutterEmptyFile ) , fsPath ( flutterEmptyFile ) ) , false ) ; assert . equal ( isWithinPath ( fsPath ( flutterHelloWorldMainFile ) , fsPath ( flutterHelloWorldMainFile ) ) , false ) ; } ) ; } ) ;	O O O $any$ O O O O O $boolean$ O O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O $any$ O $any$ O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $any$ O $any$ O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $any$ O $any$ O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $any$ O $any$ O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $any$ O $any$ O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $any$ O $any$ O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O $string$ O $any$ O O $string$ O $any$ O O O O O O O O O O O O
import * as assert from "s" ; import { Position , Range } from "s" ; import { DocumentOffsetTracker , DocumentPositionTracker } from "s" ; import { activate , currentDoc , currentEditor , positionOf , setTestContent } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; const tracker = new DocumentOffsetTracker ( ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const doc = currentDoc ( ) ; await setTestContent ( "s" ) ; const originalOffset = 0 ; tracker . trackDoc ( doc , [ originalOffset ] ) ; let updatedValues : Map < number , number > | undefined ; tracker . onOffsetsChanged ( ( [ _ , offsetMap ] ) => updatedValues = offsetMap ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; assert . ok ( updatedValues ) ; assert . equal ( updatedValues ! . get ( originalOffset ) , 0 ) ; } ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const doc = currentDoc ( ) ; await setTestContent ( "s" ) ; const originalOffset = 0 ; tracker . trackDoc ( doc , [ originalOffset ] ) ; let updatedValues : Map < number , number > | undefined ; tracker . onOffsetsChanged ( ( [ _ , offsetMap ] ) => updatedValues = offsetMap ) ; await editor . edit ( ( eb ) => eb . delete ( new Range ( new Position ( 0 , 0 ) , new Position ( 0 , 0 ) ) ) ) ; assert . ok ( updatedValues ) ; assert . equal ( updatedValues ! . get ( originalOffset ) , 0 ) ; } ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const doc = currentDoc ( ) ; await setTestContent ( "s" ) ; const originalOffset = 0 ; tracker . trackDoc ( doc , [ originalOffset ] ) ; let updatedValues : Map < number , number > | undefined ; tracker . onOffsetsChanged ( ( [ _ , offsetMap ] ) => updatedValues = offsetMap ) ; await editor . edit ( ( eb ) => eb . replace ( new Range ( new Position ( 0 , 0 ) , new Position ( 0 , 0 ) ) , "s" ) ) ; assert . ok ( updatedValues ) ; assert . equal ( updatedValues ! . get ( originalOffset ) , originalOffset ) ; } ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const doc = currentDoc ( ) ; await setTestContent ( "s" ) ; const originalOffset = 0 ; tracker . trackDoc ( doc , [ originalOffset ] ) ; let updatedValues : Map < number , number > | undefined ; tracker . onOffsetsChanged ( ( [ _ , offsetMap ] ) => updatedValues = offsetMap ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; assert . ok ( updatedValues ) ; assert . equal ( updatedValues ! . get ( originalOffset ) , originalOffset ) ; } ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const doc = currentDoc ( ) ; await setTestContent ( "s" ) ; const originalOffset = 0 ; tracker . trackDoc ( doc , [ originalOffset ] ) ; let updatedValues : Map < number , number > | undefined ; tracker . onOffsetsChanged ( ( [ _ , offsetMap ] ) => updatedValues = offsetMap ) ; await editor . edit ( ( eb ) => eb . replace ( new Range ( new Position ( 0 , 0 ) , new Position ( 0 , 0 ) ) , "s" ) ) ; assert . ok ( updatedValues ) ; assert . equal ( updatedValues ! . get ( originalOffset ) , undefined ) ; } ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const doc = currentDoc ( ) ; await setTestContent ( "s" ) ; const originalOffset = 0 ; tracker . trackDoc ( doc , [ originalOffset ] ) ; let updatedValues : Map < number , number > | undefined ; tracker . onOffsetsChanged ( ( [ _ , offsetMap ] ) => updatedValues = offsetMap ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; assert . ok ( updatedValues ) ; assert . equal ( updatedValues ! . get ( originalOffset ) , 0 ) ; } ) ; } ) ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; const tracker = new DocumentPositionTracker ( ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const doc = currentDoc ( ) ; await setTestContent ( "s" ) ; const originalPosition = positionOf ( "s" ) ; tracker . trackDoc ( doc , [ originalPosition ] ) ; let updatedValues : Map < Position , Position > | undefined ; tracker . onPositionsChanged ( ( [ _ , positionMap ] ) => updatedValues = positionMap ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; assert . ok ( updatedValues ) ; assert . ok ( updatedValues ! . get ( originalPosition ) ! . isEqual ( positionOf ( "s" ) ) ) ; } ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const doc = currentDoc ( ) ; await setTestContent ( "s" ) ; const originalPosition = positionOf ( "s" ) ; tracker . trackDoc ( doc , [ originalPosition ] ) ; let updatedValues : Map < Position , Position > | undefined ; tracker . onPositionsChanged ( ( [ _ , positionMap ] ) => updatedValues = positionMap ) ; await editor . edit ( ( eb ) => eb . delete ( new Range ( new Position ( 0 , 0 ) , new Position ( 0 , 0 ) ) ) ) ; assert . ok ( updatedValues ) ; assert . ok ( updatedValues ! . get ( originalPosition ) ! . isEqual ( positionOf ( "s" ) ) ) ; } ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const doc = currentDoc ( ) ; await setTestContent ( "s" ) ; const originalPosition = positionOf ( "s" ) ; tracker . trackDoc ( doc , [ originalPosition ] ) ; let updatedValues : Map < Position , Position > | undefined ; tracker . onPositionsChanged ( ( [ _ , positionMap ] ) => updatedValues = positionMap ) ; await editor . edit ( ( eb ) => eb . replace ( new Range ( new Position ( 0 , 0 ) , new Position ( 0 , 0 ) ) , "s" ) ) ; assert . ok ( updatedValues ) ; assert . ok ( updatedValues ! . get ( originalPosition ) ! . isEqual ( positionOf ( "s" ) ) ) ; } ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const doc = currentDoc ( ) ; await setTestContent ( "s" ) ; const originalPosition = positionOf ( "s" ) ; tracker . trackDoc ( doc , [ originalPosition ] ) ; let updatedValues : Map < Position , Position > | undefined ; tracker . onPositionsChanged ( ( [ _ , positionMap ] ) => updatedValues = positionMap ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; assert . ok ( updatedValues ) ; assert . ok ( updatedValues ! . get ( originalPosition ) ! . isEqual ( positionOf ( "s" ) ) ) ; } ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const doc = currentDoc ( ) ; await setTestContent ( "s" ) ; const originalPosition = positionOf ( "s" ) ; tracker . trackDoc ( doc , [ originalPosition ] ) ; let updatedValues : Map < Position , Position > | undefined ; tracker . onPositionsChanged ( ( [ _ , positionMap ] ) => updatedValues = positionMap ) ; await editor . edit ( ( eb ) => eb . replace ( new Range ( new Position ( 0 , 0 ) , new Position ( 0 , 0 ) ) , "s" ) ) ; assert . ok ( updatedValues ) ; assert . equal ( updatedValues ! . get ( originalPosition ) , undefined ) ; } ) ; it ( "s" , async ( ) => { const editor = currentEditor ( ) ; const doc = currentDoc ( ) ; await setTestContent ( "s" ) ; const originalPosition = positionOf ( "s" ) ; tracker . trackDoc ( doc , [ originalPosition ] ) ; let updatedValues : Map < Position , Position > | undefined ; tracker . onPositionsChanged ( ( [ _ , positionMap ] ) => updatedValues = positionMap ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; await editor . edit ( ( eb ) => eb . insert ( new Position ( 0 , 0 ) , "s" ) ) ; assert . ok ( updatedValues ) ; assert . ok ( updatedValues ! . get ( originalPosition ) ! . isEqual ( positionOf ( "s" ) ) ) ; } ) ; } ) ;	O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $Promise<void>$ O $any$ O $any$ O $any$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O $DocumentOffsetTracker$ O O $any$ O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O O O O O $DocumentOffsetTracker$ O $void$ O $any$ O O O O O O O $complex$ O $MapConstructor$ O O O O O O O O $DocumentOffsetTracker$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $number$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O O O O O $DocumentOffsetTracker$ O $void$ O $any$ O O O O O O O $complex$ O $MapConstructor$ O O O O O O O O $DocumentOffsetTracker$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $number$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O O O O O $DocumentOffsetTracker$ O $void$ O $any$ O O O O O O O $complex$ O $MapConstructor$ O O O O O O O O $DocumentOffsetTracker$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $number$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O O O O O $DocumentOffsetTracker$ O $void$ O $any$ O O O O O O O $complex$ O $MapConstructor$ O O O O O O O O $DocumentOffsetTracker$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $number$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O O O O O $DocumentOffsetTracker$ O $void$ O $any$ O O O O O O O $complex$ O $MapConstructor$ O O O O O O O O $DocumentOffsetTracker$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $number$ O O O O $undefined$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O O O O O $DocumentOffsetTracker$ O $void$ O $any$ O O O O O O O $complex$ O $MapConstructor$ O O O O O O O O $DocumentOffsetTracker$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $number$ O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O $DocumentPositionTracker$ O O $any$ O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O $any$ O $any$ O O O O $DocumentPositionTracker$ O $void$ O $any$ O O $any$ O O O O $complex$ O $MapConstructor$ O $any$ O $any$ O O O O $DocumentPositionTracker$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O $any$ O $any$ O O O O $DocumentPositionTracker$ O $void$ O $any$ O O $any$ O O O O $complex$ O $MapConstructor$ O $any$ O $any$ O O O O $DocumentPositionTracker$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O $any$ O $any$ O O O O $DocumentPositionTracker$ O $void$ O $any$ O O $any$ O O O O $complex$ O $MapConstructor$ O $any$ O $any$ O O O O $DocumentPositionTracker$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O $any$ O $any$ O O O O $DocumentPositionTracker$ O $void$ O $any$ O O $any$ O O O O $complex$ O $MapConstructor$ O $any$ O $any$ O O O O $DocumentPositionTracker$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O $any$ O $any$ O O O O $DocumentPositionTracker$ O $void$ O $any$ O O $any$ O O O O $complex$ O $MapConstructor$ O $any$ O $any$ O O O O $DocumentPositionTracker$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O $undefined$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O $any$ O $any$ O O O O $DocumentPositionTracker$ O $void$ O $any$ O O $any$ O O O O $complex$ O $MapConstructor$ O $any$ O $any$ O O O O $DocumentPositionTracker$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { isWin } from "s" ; import { Sdks } from "s" ; import { fsPath } from "s" ; import { activateWithoutAnalysis , ext , extApi , logger } from "s" ; const sampleFilePath = ( isWin ? "s" : "s" ) + "s" ; const sampleFileUri = vs . Uri . parse ( `template` ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const wfs = vs . workspace . workspaceFolders || [ ] ; assert . equal ( wfs . length , 0 ) ; assert . ok ( fsPath ( wfs [ 0 ] . uri ) . endsWith ( path . sep + "s" ) , `template` , ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . equal ( ext . isActive , true ) ; } ) ; it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . ok ( extApi ) ; const sdks = extApi . workspaceContext . sdks ; assert . ok ( sdks ) ; assert . ok ( sdks . dart ) ; logger . info ( "s" + JSON . stringify ( sdks , undefined , 0 ) . trim ( ) . slice ( 0 , - 0 ) . trim ( ) ) ; logger . info ( `template` ) ; } ) ; it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . ok ( extApi ) ; const sdks = extApi . workspaceContext . sdks ; assert . ok ( sdks ) ; assert . ok ( sdks . dart ) ; assert . equal ( sdks . dartSdkIsFromFlutter , false ) ; assert . equal ( sdks . dart ! . indexOf ( "s" ) , - 0 ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $boolean$ O O O O O O $any$ O O O O O O $string$ O O O O O O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $Logger$ O O O O O $string$ O O $boolean$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $boolean$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $InternalExtensionApi$ O O O $Sdks$ O $InternalExtensionApi$ O $WorkspaceContext$ O $Sdks$ O $any$ O $any$ O $Sdks$ O O $any$ O $any$ O $Sdks$ O $string$ O O $Logger$ O $void$ O O O $JSON$ O $complex$ O $Sdks$ O $undefined$ O O O O $string$ O O O $string$ O O O O O O O $string$ O O O O $Logger$ O $void$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $InternalExtensionApi$ O O O $Sdks$ O $InternalExtensionApi$ O $WorkspaceContext$ O $Sdks$ O $any$ O $any$ O $Sdks$ O O $any$ O $any$ O $Sdks$ O $string$ O O $any$ O $any$ O $Sdks$ O $boolean$ O O O O $any$ O $any$ O $Sdks$ O $string$ O O $number$ O O O O O O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { fsPath } from "s" ; import { activate , closeAllOpenFiles , closeFile , extApi , helloWorldBrokenFile , helloWorldFolder , helloWorldMainFile , openFile , threeMinutesInMilliseconds , waitForResult , waitUntilAllTextDocumentsAreClosed } from "s" ; export const outlineTrackingFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; const 0 = helloWorldBrokenFile ; const 0 = helloWorldMainFile ; const allowSlowSubscriptionTests = false ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( null ) ) ; it ( "s" , async ( ) => { await closeAllOpenFiles ( ) ; assert . deepStrictEqual ( extApi . fileTracker . getLastPriorityFiles ( ) , [ ] ) ; await openFile ( 0 ) ; assert . deepStrictEqual ( extApi . fileTracker . getLastPriorityFiles ( ) , [ fsPath ( 0 ) ] ) ; } ) ; it ( "s" , async ( ) => { await closeAllOpenFiles ( ) ; await openFile ( 0 ) ; assert . deepStrictEqual ( extApi . fileTracker . getLastPriorityFiles ( ) , [ fsPath ( 0 ) ] ) ; await openFile ( 0 ) ; assert . deepStrictEqual ( extApi . fileTracker . getLastPriorityFiles ( ) , [ fsPath ( 0 ) ] ) ; } ) ; it ( "s" , async ( ) => { await closeAllOpenFiles ( ) ; await openFile ( 0 ) ; assert . deepStrictEqual ( extApi . fileTracker . getLastPriorityFiles ( ) , [ fsPath ( 0 ) ] ) ; await closeFile ( 0 ) ; assert . deepStrictEqual ( extApi . fileTracker . getLastPriorityFiles ( ) , [ ] ) ; } ) ; describe ( "s" , function ( ) { this . timeout ( threeMinutesInMilliseconds + ( 0 * 0 ) ) ; beforeEach ( async function ( ) { if ( ! allowSlowSubscriptionTests ) { this . skip ( ) ; return ; } await closeAllOpenFiles ( ) ; await waitUntilAllTextDocumentsAreClosed ( ) ; } ) ; it ( "s" , async ( ) => { await openFile ( 0 ) ; assert . deepStrictEqual ( extApi . fileTracker . getLastSubscribedFiles ( ) , [ fsPath ( 0 ) ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( 0 ) ; assert . deepStrictEqual ( extApi . fileTracker . getLastSubscribedFiles ( ) , [ fsPath ( 0 ) ] ) ; await openFile ( 0 ) ; assert . deepStrictEqual ( extApi . fileTracker . getLastSubscribedFiles ( ) , [ fsPath ( 0 ) , fsPath ( 0 ) ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( 0 ) ; assert . deepStrictEqual ( extApi . fileTracker . getLastSubscribedFiles ( ) , [ fsPath ( 0 ) ] ) ; await closeFile ( 0 ) ; await waitForResult ( ( ) => extApi . fileTracker . getLastSubscribedFiles ( ) . length === 0 , "s" , threeMinutesInMilliseconds ) ; } ) ; it ( "s" , async ( ) => { await waitForResult ( ( ) => ! extApi . fileTracker . getOutlineFor ( outlineTrackingFile ) , "s" ) ; await openFile ( outlineTrackingFile ) ; await waitForResult ( ( ) => ! ! extApi . fileTracker . getOutlineFor ( outlineTrackingFile ) , "s" ) ; } ) ; it ( "s" , async ( ) => { await openFile ( outlineTrackingFile ) ; await waitForResult ( ( ) => ! ! extApi . fileTracker . getOutlineFor ( outlineTrackingFile ) , "s" ) ; await closeAllOpenFiles ( ) ; await waitForResult ( ( ) => ! extApi . fileTracker . getOutlineFor ( outlineTrackingFile ) , "s" , threeMinutesInMilliseconds ) ; } ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O O O O O O $Promise<void>$ O $Promise<void>$ O $Promise<void>$ O $InternalExtensionApi$ O $any$ O $any$ O $any$ O $Promise<any>$ O $number$ O $Promise<void>$ O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O $false$ O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O $string[]$ O O O O O O O O $Promise<any>$ O $any$ O O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O $string[]$ O O O O $string$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $Promise<any>$ O $any$ O O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O $string[]$ O O O O $string$ O $any$ O O O O O $Promise<any>$ O $any$ O O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O $string[]$ O O O O $string$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $Promise<any>$ O $any$ O O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O $string[]$ O O O O $string$ O $any$ O O O O O $Promise<void>$ O $any$ O O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O $string[]$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O $number$ O O O O O O O O $any$ O O O O O O O O O $false$ O O O O $any$ O O O O O O O $Promise<void>$ O O O O $Promise<void>$ O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O $string[]$ O O O O $string$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O $string[]$ O O O O $string$ O $any$ O O O O O $Promise<any>$ O $any$ O O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O $string[]$ O O O O $string$ O $any$ O O $string$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O $string[]$ O O O O $string$ O $any$ O O O O O $Promise<void>$ O $any$ O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $complex$ O $string[]$ O O O $number$ O O O O O $number$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O O O $Promise<void>$ O O O O $Promise<void>$ O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O $number$ O O O O O O O O O O O
import * as test_runner from "s" ; module . exports = test_runner ;	O O O $any$ O O O $any$ O $any$ O $any$ O
import * as assert from "s" ; import * as vs from "s" ; import { LazyCompletionItem } from "s" ; import { acceptFirstSuggestion , activate , currentDoc , emptyFile , ensureCompletion , ensureNoCompletion , ensureTestContent , ensureTestContentWithCursorPos , ensureTestContentWithSelection , everythingFile , extApi , getCompletionsAt , getCompletionsViaProviderAt , helloWorldCompletionFile , helloWorldPartFile , helloWorldPartWrapperFile , openFile , rangeOf , resolveCompletion , select , setTestContent } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( helloWorldCompletionFile ) ) ; it . skip ( "s" , async ( ) => { const doc = currentDoc ( ) ; await setTestContent ( doc . getText ( ) . replace ( "s" , "s" ) ) ; const completions = await getCompletionsAt ( "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Function , "s" ) ; } ) ; it ( "s" , async ( ) => { const doc = currentDoc ( ) ; await setTestContent ( doc . getText ( ) . replace ( "s" , "s" ) ) ; await setTestContent ( doc . getText ( ) . replace ( "s" , "s" ) ) ; const completions = await getCompletionsAt ( "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Function , "s" , "s" ) ; } ) ; it ( "s" , async ( ) => { await openFile ( everythingFile ) ; const completions = await getCompletionsAt ( `template` ) ; ensureCompletion ( completions , vs . CompletionItemKind . Class , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Field , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Property , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Property , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Constructor , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Constructor , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Method , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Method , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Method , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Method , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Variable , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Function , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Variable , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Enum , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . EnumMember , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Keyword , "s" , "s" ) ; } ) ; it ( "s" , async ( ) => { await openFile ( emptyFile ) ; await setTestContent ( `template` ) ; const completions = await getCompletionsAt ( `template` ) ; const comp = ensureCompletion ( completions , vs . CompletionItemKind . Variable , "s" , "s" ) ; if ( typeof comp . insertText === "s" ) throw new Error ( "s" ) ; else assert . equal ( comp . insertText ! . value , "s" ) ; } ) ; it ( "s" , async ( ) => { await openFile ( emptyFile ) ; await setTestContent ( `template` ) ; const completions = await getCompletionsViaProviderAt ( `template` ) ; const classComp = ensureCompletion ( completions , vs . CompletionItemKind . Class , "s" , "s" ) ; assert . equal ( classComp . documentation , undefined ) ; if ( extApi . dartCapabilities . hasDocumentationInCompletions ) assert . equal ( ( classComp . _documentation as vs . MarkdownString ) . value , "s" ) ; if ( extApi . dartCapabilities . hasDocumentationInCompletions ) assert . equal ( ( ( await resolveCompletion ( classComp ) ) . documentation as vs . MarkdownString ) . value , "s" ) ; assert . equal ( classComp . detail , undefined ) ; const constrComp = ensureCompletion ( completions , vs . CompletionItemKind . Constructor , "s" , "s" ) ; assert . equal ( constrComp . documentation , undefined ) ; assert . equal ( constrComp . _documentation , undefined ) ; assert . equal ( ( await resolveCompletion ( constrComp ) ) . documentation , undefined ) ; assert . equal ( constrComp . detail , "s" ) ; } ) ; it ( "s" , async ( ) => { await openFile ( everythingFile ) ; const completions = await getCompletionsViaProviderAt ( `template` ) ; const cl = ensureCompletion ( completions , vs . CompletionItemKind . Method , "s" , "s" ) ; assert . equal ( cl . additionalTextEdits , undefined ) ; assert . equal ( cl . command , undefined ) ; assert . equal ( cl . commitCharacters , undefined ) ; assert . equal ( cl . detail , "s" ) ; assert . equal ( cl . documentation , undefined ) ; assert . equal ( ( cl . _documentation as vs . MarkdownString ) . value , "s" ) ; assert . equal ( ( ( await resolveCompletion ( cl ) ) . documentation as vs . MarkdownString ) . value , "s" ) ; assert . equal ( cl . filterText , "s" ) ; assert . equal ( ( cl . insertText as vs . SnippetString ) . value , "s" ) ; assert . equal ( cl . keepWhitespace , true ) ; assert . equal ( cl . kind , vs . CompletionItemKind . Method ) ; assert . equal ( cl . label , "s" ) ; assert . notEqual ( cl . preselect , true ) ; assert . equal ( cl . range ! . isEqual ( rangeOf ( "s" ) ) , true ) ; assert . equal ( cl . sortText , "s" ) ; assert . equal ( cl . textEdit , undefined ) ; } ) ; it ( "s" , async ( ) => { await openFile ( everythingFile ) ; const completions = await getCompletionsViaProviderAt ( `template` ) ; let completion = ensureCompletion ( completions , vs . CompletionItemKind . Method , "s" , "s" ) ; completion = await resolveCompletion ( completion ) ; assert . equal ( completion . detail , "s" ) ; } ) ; it . skip ( "s" ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; select ( rangeOf ( "s" ) ) ; await acceptFirstSuggestion ( ) ; await ensureTestContentWithSelection ( `template` ) ; } ) ; describe ( "s" , ( ) => { beforeEach ( "s" , async function ( ) { if ( ! extApi . analyzerCapabilities . supportsAvailableSuggestions ) this . skip ( ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const completions = await getCompletionsAt ( "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Class , "s" , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const completions = await getCompletionsViaProviderAt ( "s" ) ; let completion = ensureCompletion ( completions , vs . CompletionItemKind . Class , "s" , "s" ) ; completion = await resolveCompletion ( completion ) ; assert . ok ( completion . additionalTextEdits ! . length ) ; assert . equal ( completion . command , undefined ) ; assert . equal ( completion . commitCharacters , undefined ) ; assert . equal ( completion . detail , "s" ) ; if ( extApi . dartCapabilities . hasDocumentationInCompletions ) assert . equal ( ( completion . documentation as vs . MarkdownString ) . value , "s" ) ; assert . equal ( completion . filterText , "s" ) ; assert . equal ( ( completion . insertText as vs . SnippetString ) . value , "s" ) ; assert . equal ( completion . keepWhitespace , true ) ; assert . equal ( completion . kind , vs . CompletionItemKind . Class ) ; assert . equal ( completion . label , "s" ) ; assert . notEqual ( completion . preselect , true ) ; assert . equal ( completion . range ! . isEqual ( rangeOf ( "s" ) ) , true ) ; assert . equal ( completion . sortText , "s" ) ; assert . equal ( completion . textEdit , undefined ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const completions = await getCompletionsViaProviderAt ( "s" ) ; let completion = ensureCompletion ( completions , vs . CompletionItemKind . Constructor , "s" , "s" ) ; completion = await resolveCompletion ( completion ) ; assert . ok ( completion . additionalTextEdits ! . length ) ; assert . equal ( completion . command , undefined ) ; assert . equal ( completion . commitCharacters , undefined ) ; assert . equal ( completion . detail , "s" ) ; assert . equal ( completion . documentation , undefined ) ; assert . equal ( completion . filterText , "s" ) ; assert . equal ( ( completion . insertText as vs . SnippetString ) . value , "s" ) ; assert . equal ( completion . keepWhitespace , true ) ; assert . equal ( completion . kind , vs . CompletionItemKind . Constructor ) ; assert . equal ( completion . label , "s" ) ; assert . notEqual ( completion . preselect , true ) ; assert . equal ( completion . range ! . isEqual ( rangeOf ( "s" ) ) , true ) ; assert . equal ( completion . sortText , "s" ) ; assert . equal ( completion . textEdit , undefined ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const completions = await getCompletionsViaProviderAt ( "s" ) ; let completion = ensureCompletion ( completions , vs . CompletionItemKind . Constructor , "s" , "s" ) ; completion = await resolveCompletion ( completion ) ; assert . ok ( completion . additionalTextEdits ! . length ) ; assert . equal ( completion . command , undefined ) ; assert . equal ( completion . commitCharacters , undefined ) ; assert . equal ( completion . detail , "s" ) ; if ( extApi . dartCapabilities . hasDocumentationInCompletions ) assert . equal ( ( completion . documentation as vs . MarkdownString ) . value , "s" ) ; assert . equal ( completion . filterText , "s" ) ; assert . equal ( ( completion . insertText as vs . SnippetString ) . value , "s" ) ; assert . equal ( completion . keepWhitespace , true ) ; assert . equal ( completion . kind , vs . CompletionItemKind . Constructor ) ; assert . equal ( completion . label , "s" ) ; assert . notEqual ( completion . preselect , true ) ; assert . equal ( completion . range ! . isEqual ( rangeOf ( "s" ) ) , true ) ; assert . equal ( completion . sortText , "s" ) ; assert . equal ( completion . textEdit , undefined ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const completions = await getCompletionsViaProviderAt ( "s" ) ; let completion = ensureCompletion ( completions , vs . CompletionItemKind . Class , "s" , "s" ) ; completion = await resolveCompletion ( completion ) ; assert . equal ( completion . detail ! . startsWith ( "s" ) , true ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; select ( rangeOf ( "s" ) ) ; await acceptFirstSuggestion ( ) ; await ensureTestContentWithCursorPos ( `template` ) ; } ) ; it ( "s" , async ( ) => { await openFile ( helloWorldPartFile ) ; await setTestContent ( `template` ) ; select ( rangeOf ( "s" ) ) ; await acceptFirstSuggestion ( ) ; await ensureTestContentWithCursorPos ( `template` ) ; await openFile ( helloWorldPartWrapperFile ) ; await ensureTestContent ( `template` ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const completions = await getCompletionsAt ( "s" ) ; const completion = ensureCompletion ( completions , vs . CompletionItemKind . EnumMember , "s" , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const completions = await getCompletionsAt ( "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Enum , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . EnumMember , "s" , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const completions = await getCompletionsAt ( "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Enum , "s" , "s" ) ; ensureNoCompletion ( completions , vs . CompletionItemKind . EnumMember , "s" ) ; } ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O $any$ O $void$ O $Promise<void>$ O $Promise<void>$ O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $Promise<any[]>$ O $Promise<any[]>$ O $any$ O $any$ O $any$ O $Promise<any>$ O $complex$ O $Promise<any>$ O $void$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O $Promise<void>$ O $any$ O $any$ O O O $any$ O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $Promise<void>$ O $any$ O $any$ O O O $any$ O O O O O O O O $Promise<void>$ O $any$ O $any$ O O O $any$ O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any[]$ O O $Promise<any[]>$ O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O O $any$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O $ErrorConstructor$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O O $LazyCompletionItem$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O $undefined$ O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O $any$ O $any$ O O $LazyCompletionItem$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O $any$ O $any$ O O O O $Promise<any>$ O $LazyCompletionItem$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O $undefined$ O O O $LazyCompletionItem$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O $undefined$ O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O $undefined$ O O $any$ O $any$ O O O $Promise<any>$ O $LazyCompletionItem$ O O O $any$ O $undefined$ O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any[]$ O O $Promise<any[]>$ O O O O O $LazyCompletionItem$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O $undefined$ O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O $undefined$ O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O $undefined$ O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O O O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O $undefined$ O O $any$ O $any$ O O $LazyCompletionItem$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $Promise<any>$ O $LazyCompletionItem$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O O O O $any$ O $any$ O O $LazyCompletionItem$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O O O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O O O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O O O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O O $any$ O $complex$ O O O O O O O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O O O O $any$ O $any$ O $LazyCompletionItem$ O $any$ O $undefined$ O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any[]$ O O $Promise<any[]>$ O O O O O $any$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $void$ O $complex$ O O O O O O $Promise<void>$ O O O O $Promise<void>$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O O O $boolean$ O O O $any$ O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O O $any$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $complex$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $undefined$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O O $any$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $complex$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $undefined$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O O $any$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $complex$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $undefined$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O O $any$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $void$ O $complex$ O O O O O O $Promise<void>$ O O O O $Promise<void>$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O $void$ O $complex$ O O O O O O $Promise<void>$ O O O O $Promise<void>$ O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O O $any$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $void$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { activate , delay , emptyFile , emptyFileInExcludedFolder , ensureError , openFile , setTestContent , waitForDiagnosticChange } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( emptyFile ) ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const errors = vs . languages . getDiagnostics ( emptyFile ) ; assert . equal ( 0 , errors . length ) ; } ) ; it ( "s" , async ( ) => { const diagnosticChange = waitForDiagnosticChange ( emptyFile ) ; await setTestContent ( `template` ) ; await diagnosticChange ; const errors = vs . languages . getDiagnostics ( emptyFile ) ; ensureError ( errors , "s" ) ; } ) ; it ( "s" , async ( ) => { await openFile ( emptyFileInExcludedFolder ) ; await setTestContent ( `template` ) ; await delay ( 0 ) ; const errors = vs . languages . getDiagnostics ( emptyFileInExcludedFolder ) ; assert . equal ( 0 , errors . length ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O $void$ O $Promise<any>$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O $Promise<void>$ O $any$ O O O $Promise<void>$ O O O O O $Promise<void>$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $void$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O $Promise<void>$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { activate , ensureDocumentSymbol , everythingFile , getDocumentSymbols } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( everythingFile ) ) ; it ( "s" , async ( ) => { const symbols = await getDocumentSymbols ( ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Class ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Field , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Property , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Property , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Field , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Field , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Constructor , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Constructor , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Method , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Method , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Method , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Method , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Method , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Function ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Variable ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Enum ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . EnumMember , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . EnumMember , "s" ) ; assert . equal ( symbols . length , 0 ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $void$ O $any$ O $Promise<any[]>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any[]$ O $number$ O O O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { platformEol } from "s" ; import { activate , currentDoc , currentEditor , emptyExcludedFile , emptyFileInExcludedFolder , openFile , positionOf , setConfigForTest , setTestContent } from "s" ; const formattingOptions : vs . FormattingOptions = { tabSize : 0 , insertSpaces : true } ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; const unformattedContent = `template` ; const formattedContent = `template` ; async function formatDocument ( expectResult = true ) < void > { const formatResult = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , formattingOptions ) as Thenable < vs . TextEdit [ ] > ) ; if ( expectResult ) { assert . ok ( formatResult ) ; assert . ok ( formatResult . length ) ; await currentEditor ( ) . edit ( ( b ) => formatResult . forEach ( ( f ) => b . replace ( f . range , f . newText ) ) ) ; } else { assert . ok ( ! formatResult ) ; } } async function formatOnType ( searchText , character ) < void > { const position = positionOf ( searchText ) ; const formatResult = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , position , character , formattingOptions ) as Thenable < vs . TextEdit [ ] > ) ; assert . ok ( formatResult ) ; assert . ok ( formatResult . length ) ; await currentEditor ( ) . edit ( ( b ) => formatResult . forEach ( ( f ) => b . replace ( f . range , f . newText ) ) ) ; } it ( "s" , async ( ) => { await setTestContent ( unformattedContent ) ; await formatDocument ( ) ; assert . equal ( currentDoc ( ) . getText ( ) , formattedContent ) ; } ) ; it ( "s" , async ( ) => { await setConfigForTest ( "s" , "s" , true ) ; await setTestContent ( unformattedContent ) ; await currentDoc ( ) . save ( ) ; assert . equal ( currentDoc ( ) . getText ( ) , formattedContent ) ; } ) ; it ( "s" , async ( ) => { await setConfigForTest ( "s" , "s" , true ) ; await setConfigForTest ( "s" , "s" , false ) ; await setTestContent ( unformattedContent ) ; await currentDoc ( ) . save ( ) ; assert . equal ( currentDoc ( ) . getText ( ) , unformattedContent ) ; } ) ; it ( "s" , async ( ) => { await setConfigForTest ( "s" , "s" , false ) ; await setConfigForTest ( "s" , "s" , true ) ; await setConfigForTest ( "s" , "s" , true ) ; await setTestContent ( unformattedContent ) ; await currentDoc ( ) . save ( ) ; assert . equal ( currentDoc ( ) . getText ( ) , formattedContent ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( unformattedContent ) ; await formatOnType ( "s" , "s" ) ; assert . equal ( currentDoc ( ) . getText ( ) , formattedContent ) ; } ) ; it ( "s" , async ( ) => { await openFile ( emptyExcludedFile ) ; await setTestContent ( unformattedContent ) ; await formatDocument ( false ) ; assert . equal ( currentDoc ( ) . getText ( ) , unformattedContent ) ; } ) ; it ( "s" , async ( ) => { await openFile ( emptyFileInExcludedFolder ) ; await setTestContent ( unformattedContent ) ; await formatDocument ( false ) ; assert . equal ( currentDoc ( ) . getText ( ) , unformattedContent ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O O O O O O O $Promise<void>$ O $any$ O $any$ O $any$ O $any$ O $Promise<any>$ O $any$ O $Promise<void>$ O $Promise<void>$ O O O O O $any$ O $any$ O $any$ O O $number$ O O O $boolean$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O $string$ O O O O $string$ O O O O O $Promise$ O $boolean$ O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $boolean$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O O O O O O $Promise$ O $string$ O $string$ O O O O O O $any$ O $any$ O $string$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $string$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O $string$ O O O $Promise<void>$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O O O O O $Promise<void>$ O $string$ O O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O O O O O $Promise<void>$ O O O O O O O O O $Promise<void>$ O $string$ O O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O O O O O $Promise<void>$ O O O O O O O O O $Promise<void>$ O O O O O O O O O $Promise<void>$ O $string$ O O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O $string$ O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O $string$ O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O $string$ O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { activate , currentDoc , everythingFile , extApi , getPackages , positionOf , rangeOf } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , ( ) => activate ( everythingFile ) ) ; async function getHoversAt ( searchText ) < Array < { displayText : string , documentation ? : string , range : vs . Range | undefined } > > { const position = positionOf ( searchText ) ; const hoverResult = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , position ) as Thenable < vs . Hover [ ] > ) ; if ( ! hoverResult || hoverResult . length === 0 ) return [ ] ; return hoverResult . map ( ( h ) => { const sections = h . contents . map ( ( c ) => ( ( c as any ) . value as string ) . trim ( ) ) . join ( "s" ) . replace ( "s" , "s" ) . replace ( "s" , "s" ) . split ( "s" ) ; const displayText = sections [ 0 ] ; const docs = sections . slice ( 0 ) . join ( "s" ) ; assert . equal ( displayText . substr ( 0 , 0 ) , "s" ) ; assert . equal ( displayText . substr ( - 0 ) , "s" ) ; return { displayText : displayText . substring ( 0 , displayText . length - 0 ) . trim ( ) , documentation : docs , range : h . range , } ; } ) ; } async function getHoverAt ( searchText ) < { displayText : string , documentation ? : string , range : vs . Range | undefined } > { const hovers = await getHoversAt ( searchText ) ; assert . equal ( hovers . length , 0 ) ; return hovers [ 0 ] ; } function getExpectedSignature ( method , returnType ) { return extApi . analyzerCapabilities . hasNewSignatureFormat ? `template` : `template` ; } function getExpectedDoc ( packagePath , doc ) { return ( extApi . analyzerCapabilities . hasNewHoverLibraryFormat ) && packagePath ? `template` : doc ; } it ( "s" , async ( ) => { const hovers = await getHoversAt ( "s" ) ; assert . equal ( hovers . length , 0 ) ; } ) ; it ( "s" , async ( ) => { const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , "s" ) ; assert . equal ( hover . documentation , getExpectedDoc ( "s" , "s" ) ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , "s" ) ; assert . equal ( hover . documentation , getExpectedDoc ( "s" , "s" ) ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , getExpectedSignature ( "s" , "s" ) ) ; assert . equal ( hover . documentation , getExpectedDoc ( "s" , "s" ) ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async function ( ) { if ( extApi . analyzerCapabilities . 0 ) { this . skip ( ) ; return ; } const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , getExpectedSignature ( "s" , "s" ) ) ; assert . equal ( hover . documentation , getExpectedDoc ( "s" , "s" ) ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , getExpectedSignature ( "s" , "s" ) ) ; assert . equal ( hover . documentation , getExpectedDoc ( "s" , "s" ) ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { let hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , getExpectedSignature ( "s" , "s" ) ) ; assert . equal ( hover . documentation , getExpectedDoc ( "s" , "s" ) ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , getExpectedSignature ( "s" , "s" ) ) ; assert . equal ( hover . documentation , getExpectedDoc ( "s" , "s" ) ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , getExpectedSignature ( "s" , "s" ) ) ; assert . equal ( hover . documentation , getExpectedDoc ( "s" , "s" ) ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , getExpectedSignature ( "s" , "s" ) ) ; assert . equal ( hover . documentation , getExpectedDoc ( "s" , "s" ) ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , getExpectedSignature ( "s" , "s" ) ) ; assert . equal ( hover . documentation , getExpectedDoc ( "s" , "s" ) ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , "s" ) ; assert . equal ( hover . documentation , "s" ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , getExpectedSignature ( `template` , "s" ) ) ; assert . equal ( hover . documentation , getExpectedDoc ( "s" , "s" ) ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , "s" ) ; if ( extApi . analyzerCapabilities . hasNewHoverLibraryFormat ) assert . ok ( hover . documentation ! . indexOf ( "s" ) === 0 ) ; else assert . ok ( hover . documentation ! . indexOf ( "s" ) === 0 ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , "s" ) ; if ( extApi . analyzerCapabilities . hasNewHoverLibraryFormat ) assert . ok ( hover . documentation ! . indexOf ( "s" ) === 0 ) ; else assert . ok ( hover . documentation ! . indexOf ( "s" ) === 0 ) ; assert . deepStrictEqual ( hover . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const hover = await getHoverAt ( "s" ) ; assert . equal ( hover . displayText , `template` ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $any$ O $any$ O $InternalExtensionApi$ O $Promise<void>$ O $any$ O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O O O $Promise$ O $string$ O O $ArrayConstructor$ O O $string$ O O O $string$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $string$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O $any$ O O O O $string$ O O O O $any$ O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise$ O $string$ O O O $string$ O O O $string$ O O O O $any$ O $any$ O $any$ O O O O O O $complex$ O O $complex$ O $string$ O O $any$ O $any$ O $complex$ O $number$ O O O O O $complex$ O O O O O O $string$ O $string$ O $string$ O O O $InternalExtensionApi$ O O O $boolean$ O O O O O O O $string$ O $string$ O $string$ O O O O $InternalExtensionApi$ O O O $boolean$ O O $string$ O O O $string$ O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $number$ O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O O $InternalExtensionApi$ O O O $boolean$ O O O O $any$ O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O O O O $any$ O $any$ O $complex$ O $string$ O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O O O O O O $InternalExtensionApi$ O O O $boolean$ O $any$ O $any$ O $complex$ O $string$ O O $number$ O O O O O O O O $any$ O $any$ O $complex$ O $string$ O O $number$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O O O O O O $InternalExtensionApi$ O O O $boolean$ O $any$ O $any$ O $complex$ O $string$ O O $number$ O O O O O O O O $any$ O $any$ O $complex$ O $string$ O O $number$ O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $complex$ O O $complex$ O O O O $any$ O $any$ O $complex$ O $string$ O O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { fsPath } from "s" ; import { activate , currentDoc , ensureLocation , ensureNoLocation , helloWorldFolder , positionOf , rangeOf } from "s" ; const testFile = vs . Uri . file ( path . join ( fsPath ( helloWorldFolder ) , "s" ) ) ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( testFile ) ) ; async function getImplementationsAt ( searchText ) < vs . Location [ ] > { const position = positionOf ( searchText ) ; const definitionResults = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , position ) as Thenable < vs . Location [ ] > ) ; return definitionResults || [ ] ; } it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; assert . equal ( impls . length , 0 , "s" + JSON . stringify ( impls , undefined , 0 ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureNoLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureNoLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureNoLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureNoLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const impls = await getImplementationsAt ( "s" ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; ensureLocation ( impls , testFile , rangeOf ( "s" ) ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O O O O O O $Promise<void>$ O $any$ O $void$ O $void$ O $any$ O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O O O $Promise$ O $string$ O O $any$ O $any$ O O O O O $any$ O $any$ O $string$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $any$ O $any$ O $any[]$ O $number$ O O O O O $JSON$ O $complex$ O $any[]$ O $undefined$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { activate , currentDoc , ensureLocation , everythingFile , getPackages , positionOf , rangeOf } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , ( ) => activate ( everythingFile ) ) ; async function getDefinitionFor ( searchText ) < vs . Location [ ] > { const position = positionOf ( searchText ) ; return ( await vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , position ) ) as vs . Location [ ] ; } async function getReferencesFor ( searchText ) < vs . Location [ ] | undefined > { const position = positionOf ( searchText ) ; return ( await vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , position ) ) as vs . Location [ ] ; } it ( "s" , async ( ) => { const definitions = await getDefinitionFor ( "s" ) ; assert . ok ( definitions ) ; assert . equal ( definitions . length , 0 ) ; const definition = definitions [ 0 ] ; assert . deepStrictEqual ( definition . uri . toString ( ) , currentDoc ( ) . uri . toString ( ) ) ; assert . deepStrictEqual ( definition . range , rangeOf ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const references = await getReferencesFor ( "s" ) ; assert . ok ( references ) ; assert . equal ( references ! . length , 0 ) ; const expectedUri = currentDoc ( ) . uri ; ensureLocation ( references , expectedUri , rangeOf ( `template` ) ) ; ensureLocation ( references , expectedUri , rangeOf ( `template` ) ) ; ensureLocation ( references , expectedUri , rangeOf ( "s" ) ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $any$ O $void$ O $any$ O $Promise<void>$ O $any$ O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O O O $Promise$ O $string$ O O $any$ O $any$ O O O O O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $Promise$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $any$ O $any$ O $any[]$ O O $any$ O $any$ O $any[]$ O $number$ O O O O O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $any$ O $any$ O $any[]$ O O $any$ O $any$ O $any[]$ O O $number$ O O O O O $any$ O $any$ O O O $any$ O $void$ O $any[]$ O $any$ O $complex$ O O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O $void$ O $any[]$ O $any$ O $complex$ O O O O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { activate , currentDoc , ensureTestContent , extApi , fakeCancellationToken , positionOf , setTestContent } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { const doc = currentDoc ( ) ; await setTestContent ( `template` ) ; const renameResult = await ( vs . commands . executeCommand ( "s" , doc . uri , positionOf ( "s" ) , "s" ) as Thenable < vs . WorkspaceEdit > ) ; await vs . workspace . applyEdit ( renameResult ) ; await ensureTestContent ( `template` ) ; } ) ; it ( "s" , async ( ) => { const doc = currentDoc ( ) ; await setTestContent ( `template` ) ; const renamePrep = await extApi . renameProvider . prepareRename ! ( doc , positionOf ( "s" ) , fakeCancellationToken ) as { range : vs . Range , placeholder : string } ; assert . equal ( renamePrep . placeholder , "s" ) ; const renameResult = await extApi . renameProvider . provideRenameEdits ( doc , renamePrep . range . start , "s" , fakeCancellationToken ) ; await vs . workspace . applyEdit ( renameResult ! ) ; await ensureTestContent ( `template` ) ; } ) ; it ( "s" , async ( ) => { const doc = currentDoc ( ) ; await setTestContent ( `template` ) ; const renamePrep = await extApi . renameProvider . prepareRename ! ( doc , positionOf ( "s" ) , fakeCancellationToken ) as { range : vs . Range , placeholder : string } ; assert . equal ( renamePrep . placeholder , "s" ) ; const renameResult = await extApi . renameProvider . provideRenameEdits ( doc , renamePrep . range . start , "s" , fakeCancellationToken ) ; await vs . workspace . applyEdit ( renameResult ! ) ; await ensureTestContent ( `template` ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $any$ O $Promise<void>$ O $InternalExtensionApi$ O $any$ O $any$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O $complex$ O O $InternalExtensionApi$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $complex$ O $string$ O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $Promise<void>$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $Promise<void>$ O O O O O $complex$ O O $InternalExtensionApi$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $complex$ O $string$ O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $Promise<void>$ O O O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { activate , currentDoc , extApi , positionOf , setTestContent } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; beforeEach ( "s" , function ( ) { if ( ! extApi . analyzerCapabilities . supportsGetSignature ) this . skip ( ) ; } ) ; async function getSignatureAt ( searchText ) < vs . SignatureHelp > { const position = positionOf ( searchText ) ; return ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , position ) as Thenable < vs . SignatureHelp > ) ; } it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const sig = await getSignatureAt ( "s" ) ; assert . ok ( ! sig ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const sigs = await getSignatureAt ( "s" ) ; assert . ok ( sigs ) ; assert . equal ( sigs . activeSignature , 0 ) ; assert . equal ( sigs . signatures . length , 0 ) ; const sig = sigs . signatures [ 0 ] ; assert . equal ( sig . label , "s" ) ; assert . equal ( sig . parameters . length , 0 ) ; assert . equal ( sig . parameters [ 0 ] . label , "s" ) ; assert . equal ( sig . parameters [ 0 ] . documentation , undefined ) ; assert . equal ( ( sig . documentation as vs . MarkdownString ) . value , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const sig = await getSignatureAt ( "s" ) ; assert . ok ( sig ) ; assert . equal ( sig . activeSignature , 0 ) ; assert . equal ( sig . signatures [ 0 ] . label , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const sig = await getSignatureAt ( "s" ) ; assert . ok ( sig ) ; assert . equal ( sig . activeSignature , 0 ) ; assert . equal ( sig . signatures [ 0 ] . label , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const sig = await getSignatureAt ( "s" ) ; assert . ok ( sig ) ; assert . equal ( sig . activeSignature , 0 ) ; assert . equal ( sig . signatures [ 0 ] . label , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const sig = await getSignatureAt ( "s" ) ; assert . ok ( sig ) ; assert . equal ( sig . activeSignature , 0 ) ; assert . equal ( sig . signatures [ 0 ] . label , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const sig = await getSignatureAt ( "s" ) ; assert . ok ( sig ) ; assert . equal ( sig . activeSignature , 0 ) ; assert . equal ( sig . signatures [ 0 ] . label , "s" ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $any$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O O $InternalExtensionApi$ O O O $boolean$ O O O $any$ O O O O O O O O $Promise$ O $string$ O O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any$ O O $Promise<any>$ O O O O $any$ O $any$ O O $any$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any$ O O $Promise<any>$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any$ O O $Promise<any>$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any$ O O $Promise<any>$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any$ O O $Promise<any>$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any$ O O $Promise<any>$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any$ O O $Promise<any>$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { activate , ensureWorkspaceSymbol , everythingFile , getWorkspaceSymbols } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { const symbols = await getWorkspaceSymbols ( "s" ) ; assert . equal ( symbols . length , 0 ) ; } ) ; it ( "s" , async ( ) => { const symbols = await getWorkspaceSymbols ( "s" ) ; ensureWorkspaceSymbol ( symbols , "s" , vs . SymbolKind . Class , `template` , everythingFile ) ; ensureWorkspaceSymbol ( symbols , "s" , vs . SymbolKind . Field , `template` , everythingFile ) ; ensureWorkspaceSymbol ( symbols , "s" , vs . SymbolKind . Field , `template` , everythingFile ) ; ensureWorkspaceSymbol ( symbols , "s" , vs . SymbolKind . Field , `template` , everythingFile ) ; ensureWorkspaceSymbol ( symbols , "s" , vs . SymbolKind . Property , `template` , everythingFile ) ; ensureWorkspaceSymbol ( symbols , "s" , vs . SymbolKind . Property , `template` , everythingFile ) ; ensureWorkspaceSymbol ( symbols , "s" , vs . SymbolKind . Constructor , `template` , everythingFile ) ; ensureWorkspaceSymbol ( symbols , "s" , vs . SymbolKind . Method , `template` , everythingFile ) ; ensureWorkspaceSymbol ( symbols , "s" , vs . SymbolKind . Method , `template` , everythingFile ) ; } ) ; it ( "s" , async ( ) => { const symbols = await getWorkspaceSymbols ( "s" ) ; ensureWorkspaceSymbol ( symbols , "s" , vs . SymbolKind . Class , "s" , { endsWith : `template` } ) ; } ) ; it ( "s" , async ( ) => { const symbols = await getWorkspaceSymbols ( "s" ) ; ensureWorkspaceSymbol ( symbols , "s" , vs . SymbolKind . Class , "s" , { endsWith : `template` } ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $void$ O $any$ O $Promise<any[]>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $any$ O $any$ O $any[]$ O $number$ O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $string$ O O O O O O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $string$ O O O O O O O O O O O
import * as assert from "s" ; import * as fs from "s" ; import * as vs from "s" ; import { fsPath } from "s" ; import { activate , currentDoc , defer , emptyFile , ensureTestContent , helloWorldCreateMethodClassAFile , helloWorldCreateMethodClassBFile , missingFile , openFile , rangeOf , setTestContent , tryDelete , uncommentTestFile , waitForNextAnalysis } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { await openFile ( helloWorldCreateMethodClassBFile ) ; await waitForNextAnalysis ( ( ) => uncommentTestFile ( ) ) ; const fixResults = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , rangeOf ( "s" ) ) as Thenable < vs . CodeAction [ ] > ) ; assert . ok ( fixResults ) ; assert . ok ( fixResults . length ) ; const createMethodFix = fixResults . find ( ( r ) => r . title . indexOf ( "s" ) !== - 0 ) ; assert . ok ( createMethodFix ) ; await ( vs . commands . executeCommand ( createMethodFix ! . command ! . command , ... createMethodFix ! . command ! . arguments || [ ] ) ) ; const fileA = await openFile ( helloWorldCreateMethodClassAFile ) ; const fileB = await openFile ( helloWorldCreateMethodClassBFile ) ; assert . notEqual ( fileA . document . getText ( ) . indexOf ( "s" ) , - 0 , "s" ) ; assert . equal ( fileB . document . getText ( ) . indexOf ( "s" ) , - 0 , "s" ) ; } ) ; it ( "s" , async ( ) => { defer ( ( ) => tryDelete ( missingFile ) ) ; await openFile ( emptyFile ) ; await setTestContent ( "s" ) ; const fixResults = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , rangeOf ( "s" ) ) as Thenable < vs . CodeAction [ ] > ) ; assert . ok ( fixResults ) ; assert . ok ( fixResults . length ) ; const createFileFix = fixResults . find ( ( r ) => r . title . indexOf ( "s" ) !== - 0 ) ; assert . ok ( createFileFix , "s" ) ; const debugJson = JSON . stringify ( createFileFix ) ; assert . ok ( createFileFix ! . command , `template` ) ; assert . ok ( createFileFix ! . command ! . command , `template` ) ; await ( vs . commands . executeCommand ( createFileFix ! . command ! . command , ... createFileFix ! . command ! . arguments || [ ] ) ) ; assert . ok ( fs . existsSync ( fsPath ( missingFile ) ) ) ; } ) ; it . skip ( "s" , async ( ) => { await openFile ( emptyFile ) ; await setTestContent ( `template` ) ; const fixResults = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , rangeOf ( "s" ) ) as Thenable < vs . CodeAction [ ] > ) ; assert . ok ( fixResults ) ; assert . ok ( fixResults . length ) ; const createFunctionFix = fixResults . find ( ( r ) => r . title . indexOf ( "s" ) !== - 0 ) ; assert . ok ( createFunctionFix , "s" ) ; const debugJson = JSON . stringify ( createFunctionFix ) ; assert . ok ( createFunctionFix ! . command , `template` ) ; assert . ok ( createFunctionFix ! . command ! . command , `template` ) ; await ( vs . commands . executeCommand ( createFunctionFix ! . command ! . command , ... createFunctionFix ! . command ! . arguments || [ ] ) ) ; await ensureTestContent ( `template` ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O O O O O O $Promise<void>$ O $any$ O $void$ O $any$ O $Promise<void>$ O $any$ O $any$ O $any$ O $Promise<any>$ O $complex$ O $Promise<void>$ O $void$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O $Promise<void>$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O $void$ O O O O $void$ O $any$ O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $string$ O $JSON$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $string$ O $JSON$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O O O O O O $Promise<void>$ O O O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { activate , currentDoc , emptyFile , ensureTestContent , openFile , rangeOf , setTestContent } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { await openFile ( emptyFile ) ; await setTestContent ( `template` ) ; const fixResults = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , rangeOf ( "s" ) ) as Thenable < vs . CodeAction [ ] > ) ; assert . ok ( fixResults ) ; assert . ok ( fixResults . length ) ; const ignoreLintAction = fixResults . find ( ( r ) => { return r . title . indexOf ( "s" ) !== - 0 || r . title . indexOf ( "s" ) !== - 0 ; } ) ; assert . ok ( ignoreLintAction ) ; } ) ; it ( "s" , async ( ) => { await openFile ( emptyFile ) ; await setTestContent ( `template` ) ; const fixResults = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , rangeOf ( "s" ) ) as Thenable < vs . CodeAction [ ] > ) ; assert . ok ( fixResults ) ; assert . ok ( fixResults . length ) ; const filteredResults = fixResults . filter ( ( f ) => ! vs . CodeActionKind . Source . contains ( f . kind ! ) ) ; const index = filteredResults . findIndex ( ( r ) => { return r . title . indexOf ( "s" ) !== - 0 || r . title . indexOf ( "s" ) !== - 0 ; } ) ; assert . equal ( index , filteredResults . length - 0 ) ; } ) ; it ( "s" , async ( ) => { await openFile ( emptyFile ) ; await setTestContent ( `template` ) ; const fixResults = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , rangeOf ( "s" ) ) as Thenable < vs . CodeAction [ ] > ) ; const ignoreLintAction = fixResults . find ( ( r ) => { return r . title . indexOf ( "s" ) !== - 0 || r . title . indexOf ( "s" ) !== - 0 ; } ) ; await vs . workspace . applyEdit ( ignoreLintAction ! . edit ! ) ; await ensureTestContent ( `template` ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $any$ O $any$ O $Promise<void>$ O $Promise<any>$ O $complex$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $Promise<void>$ O O O O O O O O O O
import { activate , ensureNoSnippet , ensureSnippet , getSnippetCompletionsAt , setTestContent } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { await setTestContent ( "s" ) ; const snippets = await getSnippetCompletionsAt ( "s" ) ; ensureSnippet ( snippets , "s" , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( "s" ) ; const snippets = await getSnippetCompletionsAt ( "s" ) ; ensureSnippet ( snippets , "s" , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( "s" ) ; const snippets = await getSnippetCompletionsAt ( "s" ) ; ensureNoSnippet ( snippets , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( "s" ) ; const snippets = await getSnippetCompletionsAt ( "s" ) ; ensureNoSnippet ( snippets , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( "s" ) ; const snippets = await getSnippetCompletionsAt ( "s" ) ; ensureNoSnippet ( snippets , "s" ) ; } ) ; } ) ;	O O $Promise<void>$ O $void$ O $void$ O $Promise<any[]>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { activate , addLaunchConfigsForTest , extApi , getCodeLens , getPackages , helloWorldTestMainFile , openFile , positionOf , waitForResult } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { const editor = await openFile ( helloWorldTestMainFile ) ; await waitForResult ( ( ) => ! ! extApi . fileTracker . getOutlineFor ( helloWorldTestMainFile ) ) ; const fileCodeLens = await getCodeLens ( editor . document ) ; const testPos = positionOf ( `template` ) ; const codeLensForTest = fileCodeLens . filter ( ( cl ) => cl . range . start . line === testPos . line ) ; assert . equal ( codeLensForTest . length , 0 ) ; const runAction = codeLensForTest . find ( ( cl ) => cl . command ! . title === "s" ) ! ; assert . equal ( runAction ! . command ! . command , "s" ) ; assert . equal ( runAction ! . command ! . arguments ! [ 0 ] . fullName , "s" ) ; assert . equal ( runAction ! . command ! . arguments ! [ 0 ] . isGroup , false ) ; const debugAction = codeLensForTest . find ( ( cl ) => cl . command ! . title === "s" ) ; assert . equal ( debugAction ! . command ! . command , "s" ) ; assert . equal ( debugAction ! . command ! . arguments ! [ 0 ] . fullName , "s" ) ; assert . equal ( debugAction ! . command ! . arguments ! [ 0 ] . isGroup , false ) ; } ) ; it ( "s" , async ( ) => { const editor = await openFile ( helloWorldTestMainFile ) ; await waitForResult ( ( ) => ! ! extApi . fileTracker . getOutlineFor ( helloWorldTestMainFile ) ) ; const fileCodeLens = await getCodeLens ( editor . document ) ; const groupPos = positionOf ( "s" ) ; const codeLensForGroup = fileCodeLens . filter ( ( cl ) => cl . range . contains ( groupPos ) ) ; assert . equal ( codeLensForGroup . length , 0 ) ; const runAction = codeLensForGroup . find ( ( cl ) => cl . command ! . title === "s" ) ; assert . equal ( runAction ! . command ! . command , "s" ) ; assert . equal ( runAction ! . command ! . arguments ! [ 0 ] . fullName , "s" ) ; assert . equal ( runAction ! . command ! . arguments ! [ 0 ] . isGroup , true ) ; const debugAction = codeLensForGroup . find ( ( cl ) => cl . command ! . title === "s" ) ; assert . equal ( debugAction ! . command ! . command , "s" ) ; assert . equal ( debugAction ! . command ! . arguments ! [ 0 ] . fullName , "s" ) ; assert . equal ( debugAction ! . command ! . arguments ! [ 0 ] . isGroup , true ) ; } ) ; it ( "s" , async ( ) => { await addLaunchConfigsForTest ( vs . workspace . workspaceFolders ! [ 0 ] . uri , [ { env : { MY_VAR : "s" } , name : "s" , request : "s" , template : "s" , type : "s" , } , { env : { MY_VAR : "s" } , name : "s" , request : "s" , template : "s" , type : "s" , } , ] , ) ; const editor = await openFile ( helloWorldTestMainFile ) ; await waitForResult ( ( ) => ! ! extApi . fileTracker . getOutlineFor ( helloWorldTestMainFile ) ) ; const fileCodeLens = await getCodeLens ( editor . document ) ; const testPos = positionOf ( `template` ) ; const codeLensForTest = fileCodeLens . filter ( ( cl ) => cl . range . start . line === testPos . line ) ; assert . equal ( codeLensForTest . length , 0 ) ; const runAction = codeLensForTest . find ( ( cl ) => cl . command ! . title === "s" ) ; assert . equal ( runAction ! . command ! . command , "s" ) ; assert . equal ( runAction ! . command ! . arguments ! [ 0 ] . fullName , "s" ) ; assert . equal ( runAction ! . command ! . arguments ! [ 0 ] . isGroup , false ) ; assert . deepStrictEqual ( runAction ! . command ! . arguments ! [ 0 ] . env , { MY_VAR : "s" } ) ; const debugAction = codeLensForTest . find ( ( cl ) => cl . command ! . title === "s" ) ; assert . equal ( debugAction ! . command ! . command , "s" ) ; assert . equal ( debugAction ! . command ! . arguments ! [ 0 ] . fullName , "s" ) ; assert . equal ( debugAction ! . command ! . arguments ! [ 0 ] . isGroup , false ) ; assert . deepStrictEqual ( debugAction ! . command ! . arguments ! [ 0 ] . env , { MY_VAR : "s" } ) ; } ) ; it ( "s" , async ( ) => { await addLaunchConfigsForTest ( vs . workspace . workspaceFolders ! [ 0 ] . uri , [ { env : { MY_VAR : "s" } , name : "s" , request : "s" , template : "s" , type : "s" , } , { env : { MY_VAR : "s" } , name : "s" , request : "s" , template : "s" , type : "s" , } , ] , ) ; const editor = await openFile ( helloWorldTestMainFile ) ; await waitForResult ( ( ) => ! ! extApi . fileTracker . getOutlineFor ( helloWorldTestMainFile ) ) ; const fileCodeLens = await getCodeLens ( editor . document ) ; const groupPos = positionOf ( "s" ) ; const codeLensForGroup = fileCodeLens . filter ( ( cl ) => cl . range . contains ( groupPos ) ) ; assert . equal ( codeLensForGroup . length , 0 ) ; const runAction = codeLensForGroup . find ( ( cl ) => cl . command ! . title === "s" ) ; assert . equal ( runAction ! . command ! . command , "s" ) ; assert . equal ( runAction ! . command ! . arguments ! [ 0 ] . fullName , "s" ) ; assert . equal ( runAction ! . command ! . arguments ! [ 0 ] . isGroup , true ) ; assert . deepStrictEqual ( runAction ! . command ! . arguments ! [ 0 ] . env , { MY_VAR : "s" } ) ; const debugAction = codeLensForGroup . find ( ( cl ) => cl . command ! . title === "s" ) ; assert . equal ( debugAction ! . command ! . command , "s" ) ; assert . equal ( debugAction ! . command ! . arguments ! [ 0 ] . fullName , "s" ) ; assert . equal ( debugAction ! . command ! . arguments ! [ 0 ] . isGroup , true ) ; assert . deepStrictEqual ( debugAction ! . command ! . arguments ! [ 0 ] . env , { MY_VAR : "s" } ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $Promise<void>$ O $InternalExtensionApi$ O $Promise<any[]>$ O $Promise<void>$ O $any$ O $Promise<any>$ O $any$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O $any[]$ O O $Promise<any[]>$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any[]$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any[]$ O $number$ O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O $any[]$ O O $Promise<any[]>$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any[]$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any[]$ O $number$ O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $complex$ O O $string$ O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $complex$ O O $string$ O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O $any[]$ O O $Promise<any[]>$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any[]$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any[]$ O $number$ O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $complex$ O O $string$ O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $complex$ O O $string$ O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O $any[]$ O O $Promise<any[]>$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any[]$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any[]$ O $number$ O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O $any$ O O $string$ O O O O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { twoHoursInMs } from "s" ; import { VersionStatus } from "s" ; import { activate , defer , extApi , sb } from "s" ; const alreadyInstalledPackage = "s" ; const 0 = "s" ; const 0 = "s" ; const 0 = "s" ; const 0 = "s" ; const 0 = "s" ; const 0 = "s" ; const 0 = "s" ; const 0 = "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( null ) ) ; it ( "s" , async ( ) => { const status = await extApi . pubGlobal . getInstalledStatus ( 0 , 0 ) ; assert . equal ( status , VersionStatus . NotInstalled ) ; } ) ; it ( "s" , async ( ) => { const status = await extApi . pubGlobal . getInstalledStatus ( alreadyInstalledPackage , alreadyInstalledPackage , "s" ) ; assert . equal ( status , VersionStatus . Valid ) ; } ) ; it ( "s" , async ( ) => { const status = await extApi . pubGlobal . getInstalledStatus ( alreadyInstalledPackage , alreadyInstalledPackage , "s" ) ; assert . equal ( status , VersionStatus . UpdateRequired ) ; } ) ; it ( "s" , async ( ) => { extApi . context . setPackageLastCheckedForUpdates ( 0 , Date . now ( ) - twoHoursInMs ) ; const status = await extApi . pubGlobal . getInstalledStatus ( 0 , 0 ) ; assert . equal ( status , VersionStatus . Valid ) ; } ) ; it ( "s" , async ( ) => { const twentyFiveHoursInMs = 0 * 0 * 0 * 0 ; extApi . context . setPackageLastCheckedForUpdates ( 0 , Date . now ( ) - twentyFiveHoursInMs ) ; const status = await extApi . pubGlobal . getInstalledStatus ( 0 , 0 ) ; assert . equal ( status , VersionStatus . UpdateAvailable ) ; } ) ; it ( "s" , async ( ) => { const installPrompt = sb . stub ( vs . window , "s" ) . resolves ( `template` ) ; const installed = await extApi . pubGlobal . promptToInstallIfRequired ( 0 , 0 ) ; assert . equal ( installed , true ) ; assert . equal ( installPrompt . calledOnce , true ) ; defer ( ( ) => extApi . pubGlobal . uninstall ( 0 ) ) ; const status = await extApi . pubGlobal . getInstalledStatus ( 0 , 0 ) ; assert . equal ( status , VersionStatus . Valid ) ; } ) ; it ( "s" , async ( ) => { const installPrompt = sb . stub ( vs . window , "s" ) . resolves ( `template` ) ; const installed = await extApi . pubGlobal . promptToInstallIfRequired ( 0 , 0 , "s" , 0 ) ; assert . equal ( installed , true ) ; assert . equal ( installPrompt . calledOnce , true ) ; const status = await extApi . pubGlobal . getInstalledStatus ( 0 , 0 ) ; assert . equal ( status , VersionStatus . Valid ) ; } ) ; it ( "s" , async ( ) => { extApi . context . setPackageLastCheckedForUpdates ( 0 , undefined ) ; const installPrompt = sb . stub ( vs . window , "s" ) . resolves ( `template` ) ; const installed = await extApi . pubGlobal . promptToInstallIfRequired ( 0 , 0 , "s" ) ; assert . equal ( installed , true ) ; assert . equal ( installPrompt . calledOnce , true ) ; const status = await extApi . pubGlobal . getInstalledStatus ( 0 , 0 ) ; assert . equal ( status , VersionStatus . Valid ) ; } ) ; it ( "s" , async ( ) => { extApi . context . setPackageLastCheckedForUpdates ( 0 , undefined ) ; const installPrompt = sb . stub ( vs . window , "s" ) ; const installed = await extApi . pubGlobal . promptToInstallIfRequired ( 0 , 0 , "s" , 0 , true ) ; assert . equal ( installed , true ) ; assert . equal ( installPrompt . called , false ) ; const status = await extApi . pubGlobal . getInstalledStatus ( 0 , 0 ) ; assert . equal ( status , VersionStatus . Valid ) ; } ) ; it ( "s" , async ( ) => { const installPrompt = sb . stub ( vs . window , "s" ) ; const installed = await extApi . pubGlobal . promptToInstallIfRequired ( 0 , 0 , "s" , undefined , true ) ; assert . equal ( installed , true ) ; assert . equal ( installPrompt . called , false ) ; const status = await extApi . pubGlobal . getInstalledStatus ( 0 , 0 ) ; assert . equal ( status , VersionStatus . Valid ) ; } ) ; it ( "s" , async ( ) => { const installPrompt = sb . stub ( vs . window , "s" ) ; const installed = await extApi . pubGlobal . promptToInstallIfRequired ( alreadyInstalledPackage , alreadyInstalledPackage ) ; assert . equal ( installed , true ) ; assert . equal ( installPrompt . calledOnce , false ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $number$ O O O O O O $any$ O O O O O O $Promise<void>$ O $void$ O $InternalExtensionApi$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O $any$ O O O O O O O O O $VersionStatus$ O O $InternalExtensionApi$ O $complex$ O $Promise<VersionStatus>$ O O O O O O $any$ O $any$ O $VersionStatus$ O $any$ O $VersionStatus.NotInstalled$ O O O O O $any$ O O O O O O O O O $VersionStatus$ O O $InternalExtensionApi$ O $complex$ O $Promise<VersionStatus>$ O O O O O O O O $any$ O $any$ O $VersionStatus$ O $any$ O $VersionStatus.Valid$ O O O O O $any$ O O O O O O O O O $VersionStatus$ O O $InternalExtensionApi$ O $complex$ O $Promise<VersionStatus>$ O O O O O O O O $any$ O $any$ O $VersionStatus$ O $any$ O $VersionStatus.UpdateRequired$ O O O O O $any$ O O O O O O O O $InternalExtensionApi$ O $Context$ O $void$ O O O $DateConstructor$ O $number$ O O O $number$ O O O $VersionStatus$ O O $InternalExtensionApi$ O $complex$ O $Promise<VersionStatus>$ O O O O O O $any$ O $any$ O $VersionStatus$ O $any$ O $VersionStatus.Valid$ O O O O O $any$ O O O O O O O O O $number$ O O O O O O O O O $InternalExtensionApi$ O $Context$ O $void$ O O O $DateConstructor$ O $number$ O O O $number$ O O O $VersionStatus$ O O $InternalExtensionApi$ O $complex$ O $Promise<VersionStatus>$ O O O O O O $any$ O $any$ O $VersionStatus$ O $any$ O $VersionStatus.UpdateAvailable$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $boolean$ O O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O O O $InternalExtensionApi$ O $complex$ O $Promise<void>$ O O O O O O $VersionStatus$ O O $InternalExtensionApi$ O $complex$ O $Promise<VersionStatus>$ O O O O O O $any$ O $any$ O $VersionStatus$ O $any$ O $VersionStatus.Valid$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $boolean$ O O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O O O O O O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $VersionStatus$ O O $InternalExtensionApi$ O $complex$ O $Promise<VersionStatus>$ O O O O O O $any$ O $any$ O $VersionStatus$ O $any$ O $VersionStatus.Valid$ O O O O O $any$ O O O O O O O O $InternalExtensionApi$ O $Context$ O $void$ O O O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $boolean$ O O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O O O O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $VersionStatus$ O O $InternalExtensionApi$ O $complex$ O $Promise<VersionStatus>$ O O O O O O $any$ O $any$ O $VersionStatus$ O $any$ O $VersionStatus.Valid$ O O O O O $any$ O O O O O O O O $InternalExtensionApi$ O $Context$ O $void$ O O O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O O O O O O O O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $VersionStatus$ O O $InternalExtensionApi$ O $complex$ O $Promise<VersionStatus>$ O O O O O O $any$ O $any$ O $VersionStatus$ O $any$ O $VersionStatus.Valid$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O O O O O O O $undefined$ O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $VersionStatus$ O O $InternalExtensionApi$ O $complex$ O $Promise<VersionStatus>$ O O O O O O $any$ O $any$ O $VersionStatus$ O $any$ O $VersionStatus.Valid$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O
import * as vs from "s" ; import { activate , currentDoc , ensureTestContent , rangeOf , setTestContent } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; await ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( "s" ) , "s" ) ) ; await ensureTestContent ( `template` ) ; } ) ; } ) ;	O O O $any$ O O O O O $Promise<void>$ O $any$ O $Promise<void>$ O $complex$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O O O O O O O
import * as vs from "s" ; import { activate , currentDoc , ensureTestContent , rangeOf , setTestContent } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; await ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( `template` ) , "s" ) ) ; await ensureTestContent ( `template` ) ; } ) ; } ) ;	O O O $any$ O O O O O $Promise<void>$ O $any$ O $Promise<void>$ O $complex$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O O O O O O O
import * as assert from "s" ; import * as sinon from "s" ; import * as vs from "s" ; import { REFACTOR_ANYWAY , REFACTOR_FAILED_DOC_MODIFIED } from "s" ; import { PromiseCompleter } from "s" ; import { activate , currentDoc , ensureTestContent , positionOf , rangeOf , sb , setTestContent , waitForResult } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( "s" ) ; await setTestContent ( `template` ) ; await ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( "s" ) , "s" ) ) ; await ensureTestContent ( `template` ) ; } ) ; it ( "s" , async ( ) => { const showErrorMessage = sb . stub ( vs . window , "s" ) ; await setTestContent ( `template` ) ; await ( vs . commands . executeCommand ( "s" , currentDoc ( ) , new vs . Range ( positionOf ( "s" ) , positionOf ( "s" ) ) , "s" ) ) ; await ensureTestContent ( `template` ) ; assert ( showErrorMessage . calledOnce ) ; } ) ; it ( "s" , async ( ) => { const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( "s" ) ; const showErrorMessage = sb . stub ( vs . window , "s" ) ; await setTestContent ( `template` ) ; await ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( "s" ) , "s" ) ) ; await ensureTestContent ( `template` ) ; assert ( showErrorMessage . calledOnce ) ; } ) ; it ( "s" , async ( ) => { const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( "s" ) ; const showWarningMessage = sb . stub ( vs . window , "s" ) . callThrough ( ) ; const refactorPrompt = showWarningMessage . withArgs ( sinon . match . any , REFACTOR_ANYWAY ) . resolves ( ) ; await setTestContent ( `template` ) ; await ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( "s" ) , "s" ) ) ; await ensureTestContent ( `template` ) ; assert ( refactorPrompt . calledOnce ) ; } ) ; it ( "s" , async ( ) => { const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( "s" ) ; const showWarningMessage = sb . stub ( vs . window , "s" ) . callThrough ( ) ; const refactorPrompt = showWarningMessage . withArgs ( sinon . match . any , REFACTOR_ANYWAY ) . resolves ( REFACTOR_ANYWAY ) ; await setTestContent ( `template` ) ; await ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( "s" ) , "s" ) ) ; await ensureTestContent ( `template` ) ; assert ( refactorPrompt . calledOnce ) ; } ) ; it ( "s" , async ( ) => { const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( "s" ) ; const showWarningMessage = sb . stub ( vs . window , "s" ) ; const showErrorMessage = sb . stub ( vs . window , "s" ) ; const refactorAnywayChoice = new PromiseCompleter ( ) ; const refactorPrompt = showWarningMessage . withArgs ( sinon . match . any , REFACTOR_ANYWAY ) . returns ( refactorAnywayChoice . promise ) ; const rejectMessage = showErrorMessage . withArgs ( REFACTOR_FAILED_DOC_MODIFIED ) . resolves ( ) ; await setTestContent ( `template` ) ; const refactorCommand = ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( "s" ) , "s" ) ) ; await waitForResult ( ( ) => refactorPrompt . called ) ; await setTestContent ( `template` ) ; refactorAnywayChoice . resolve ( REFACTOR_ANYWAY ) ; await refactorCommand ; await ensureTestContent ( `template` ) ; assert ( rejectMessage . calledOnce , "s" ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O $Promise<void>$ O $any$ O $complex$ O $any$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $PromiseCompleter<unknown>$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $PromiseCompleter<unknown>$ O $Promise<unknown>$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O O O $Promise<void>$ O O O O $PromiseCompleter<unknown>$ O $void$ O O O O O $any$ O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O
import * as assert from "s" ; import * as fs from "s" ; import * as os from "s" ; import * as path from "s" ; import * as sinon from "s" ; import * as vs from "s" ; import { FlutterCapabilities } from "s" ; import { dartCodeExtensionIdentifier , FLUTTER_CREATE_PROJECT_TRIGGER_FILE } from "s" ; import { getChildFolders } from "s" ; import { DartUriHandler } from "s" ; import { deleteDirectoryRecursive , sb } from "s" ; describe ( "s" , async ( ) => { const urlHandler = new DartUriHandler ( new FlutterCapabilities ( "s" ) ) ; const tempPath = path . join ( os . tmpdir ( ) , dartCodeExtensionIdentifier , "s" , "s" , "s" ) ; beforeEach ( "s" , ( ) => deleteDirectoryRecursive ( tempPath ) ) ; afterEach ( "s" , ( ) => deleteDirectoryRecursive ( tempPath ) ) ; it ( "s" , async ( ) => { const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const openFolderCommand = executeCommand . withArgs ( "s" , sinon . match . any ) . resolves ( ) ; await urlHandler . handleUri ( vs . Uri . parse ( `template` ) ) ; const childFolders = await getChildFolders ( tempPath ) ; assert . equal ( childFolders . length , 0 ) ; const projectFolder = childFolders [ 0 ] ; const triggerFile = path . join ( projectFolder , FLUTTER_CREATE_PROJECT_TRIGGER_FILE ) ; assert . ok ( fs . existsSync ( triggerFile ) ) ; assert . equal ( fs . readFileSync ( triggerFile ) . toString ( ) , "s" ) ; assert . ok ( openFolderCommand . calledOnce ) ; } ) ; it ( "s" , async ( ) => { const showErrorMessage = sb . stub ( vs . window , "s" ) ; await urlHandler . handleUri ( vs . Uri . parse ( `template` ) ) ; assert ( showErrorMessage . calledOnce ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O O O O O O O O O $Promise<string[]>$ O O O O O O $any$ O O O O O O $void$ O $any$ O O O O $any$ O O O O O O O O O $DartUriHandler$ O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O $void$ O $any$ O O O $any$ O O O O O O $void$ O $any$ O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $DartUriHandler$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O O O $string[]$ O O $Promise<string[]>$ O $any$ O O $any$ O $any$ O $string[]$ O $number$ O O O O O $string$ O $string[]$ O O O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $DartUriHandler$ O $Promise<void>$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O
import * as assert from "s" ; import * as sinon from "s" ; import * as vs from "s" ; import { doNotAskAgainAction , flutterSurveyPromptWithoutAnalytics , longRepeatPromptThreshold , noRepeatPromptThreshold , openDevToolsAction , takeSurveyAction , twoHoursInMs , wantToTryDevToolsPrompt } from "s" ; import { waitFor } from "s" ; import { showDevToolsNotificationIfAppropriate , showFlutterSurveyNotificationIfAppropriate , surveyEnd , surveyStart } from "s" ; import { activateWithoutAnalysis , clearAllContext , extApi , logger , sb } from "s" ; describe ( "s" , async ( ) => { beforeEach ( "s" , ( ) => activateWithoutAnalysis ( ) ) ; beforeEach ( "s" , ( ) => clearAllContext ( extApi . context ) ) ; afterEach ( "s" , ( ) => clearAllContext ( extApi . context ) ) ; it ( "s" , async ( ) => { const showInformationMessage = sb . stub ( vs . window , "s" ) ; const wantToTryPrompt = showInformationMessage . withArgs ( wantToTryDevToolsPrompt , sinon . match . any ) . resolves ( openDevToolsAction ) ; const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const openDevToolsCommand = executeCommand . withArgs ( "s" ) . resolves ( ) ; const res = await showDevToolsNotificationIfAppropriate ( extApi . context ) ; assert . equal ( wantToTryPrompt . calledOnce , true ) ; assert . equal ( openDevToolsCommand . calledOnce , true ) ; assert . equal ( res , true ) ; const context = extApi . context ; assert . equal ( context . devToolsNotificationDoNotShow , false ) ; assert . equal ( context . devToolsNotificationsShown , 0 ) ; assert . equal ( context . devToolsNotificationLastShown && context . devToolsNotificationLastShown > Date . now ( ) - 0 && context . devToolsNotificationLastShown <= Date . now ( ) , true ) ; } ) ; it ( "s" , async ( ) => { const context = extApi . context ; context . devToolsNotificationsShown = 0 ; context . devToolsNotificationLastShown = Date . now ( ) - ( noRepeatPromptThreshold + twoHoursInMs ) ; const showInformationMessage = sb . stub ( vs . window , "s" ) ; const wantToTryPrompt = showInformationMessage . withArgs ( wantToTryDevToolsPrompt , sinon . match . any ) . resolves ( openDevToolsAction ) ; const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const openDevToolsCommand = executeCommand . withArgs ( "s" ) . resolves ( ) ; const res = await showDevToolsNotificationIfAppropriate ( extApi . context ) ; assert . equal ( wantToTryPrompt . calledOnce , true ) ; assert . equal ( openDevToolsCommand . calledOnce , true ) ; assert . equal ( res , true ) ; assert . equal ( context . devToolsNotificationDoNotShow , false ) ; assert . equal ( context . devToolsNotificationsShown , 0 ) ; assert . equal ( context . devToolsNotificationLastShown > Date . now ( ) - 0 && context . devToolsNotificationLastShown <= Date . now ( ) , true ) ; } ) ; it ( "s" , async ( ) => { const context = extApi . context ; context . devToolsNotificationsShown = 0 ; const fiveHoursInMs = 0 * 0 * 0 * 0 ; context . devToolsNotificationLastShown = Date . now ( ) - fiveHoursInMs ; const showInformationMessage = sb . stub ( vs . window , "s" ) ; const wantToTryPrompt = showInformationMessage . withArgs ( wantToTryDevToolsPrompt , sinon . match . any ) . resolves ( openDevToolsAction ) ; const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const openDevToolsCommand = executeCommand . withArgs ( "s" ) . resolves ( ) ; const res = await showDevToolsNotificationIfAppropriate ( extApi . context ) ; assert . equal ( wantToTryPrompt . called , false ) ; assert . equal ( openDevToolsCommand . called , false ) ; assert . equal ( res , false ) ; } ) ; it ( "s" , async ( ) => { const showInformationMessage = sb . stub ( vs . window , "s" ) ; const wantToTryPrompt = showInformationMessage . withArgs ( wantToTryDevToolsPrompt , sinon . match . any ) . resolves ( doNotAskAgainAction ) ; const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const openDevToolsCommand = executeCommand . withArgs ( "s" , sinon . match . any ) . resolves ( ) ; const res = await showDevToolsNotificationIfAppropriate ( extApi . context ) ; assert . equal ( wantToTryPrompt . called , true ) ; assert . equal ( openDevToolsCommand . called , false ) ; assert . equal ( res , false ) ; assert . equal ( extApi . context . devToolsNotificationDoNotShow , true ) ; } ) ; it ( "s" , async ( ) => { extApi . context . devToolsNotificationDoNotShow = true ; const showInformationMessage = sb . stub ( vs . window , "s" ) ; const wantToTryPrompt = showInformationMessage . withArgs ( wantToTryDevToolsPrompt , sinon . match . any ) . resolves ( doNotAskAgainAction ) ; const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const openDevToolsCommand = executeCommand . withArgs ( "s" , sinon . match . any ) . resolves ( ) ; const res = await showDevToolsNotificationIfAppropriate ( extApi . context ) ; assert . equal ( wantToTryPrompt . called , false ) ; assert . equal ( openDevToolsCommand . called , false ) ; assert . equal ( res , false ) ; } ) ; } ) ; describe ( "s" , async ( ) => { beforeEach ( "s" , ( ) => activateWithoutAnalysis ( ) ) ; beforeEach ( "s" , ( ) => clearAllContext ( extApi . context ) ) ; afterEach ( "s" , ( ) => clearAllContext ( extApi . context ) ) ; const surveyIsOpenDate = Date . UTC ( 0 , 0 , 0 ) ; const immediatelyBeforeSurveyOpensDate = surveyStart - 0 ; const immediatelyAfterSurveyOpensDate = surveyStart + 0 ; const immediatelyBeforeSurveyClosesDate = surveyEnd - 0 ; const immediatelyAfterSurveyClosesDate = surveyEnd + 0 ; const matchPrompt = sinon . match ( ( v ) => v . indexOf ( flutterSurveyPromptWithoutAnalytics ) === 0 ) ; it ( "s" , async ( ) => { const showInformationMessage = sb . stub ( vs . window , "s" ) ; const openSurveyPrompt = showInformationMessage . withArgs ( matchPrompt , sinon . match . any ) . resolves ( takeSurveyAction ) ; const openBrowserCommand = sb . stub ( extApi . envUtils , "s" ) . resolves ( ) ; const res = showFlutterSurveyNotificationIfAppropriate ( extApi . context , extApi . envUtils . openInBrowser , surveyIsOpenDate , logger ) ; assert . equal ( openSurveyPrompt . calledOnce , true ) ; await waitFor ( ( ) => openBrowserCommand . called ) ; assert . equal ( openBrowserCommand . calledOnce , true ) ; assert . equal ( res , true ) ; const context = extApi . context ; assert . equal ( context . 0 , true ) ; assert . equal ( context . 0 && context . 0 > Date . now ( ) - 0 && context . 0 <= Date . now ( ) , true ) ; } ) ; it ( "s" , async ( ) => { const context = extApi . context ; context . 0 = surveyIsOpenDate - ( longRepeatPromptThreshold + twoHoursInMs ) ; const showInformationMessage = sb . stub ( vs . window , "s" ) ; const openSurveyPrompt = showInformationMessage . withArgs ( matchPrompt , sinon . match . any ) . resolves ( takeSurveyAction ) ; const openBrowserCommand = sb . stub ( extApi . envUtils , "s" ) . resolves ( ) ; const res = showFlutterSurveyNotificationIfAppropriate ( extApi . context , extApi . envUtils . openInBrowser , surveyIsOpenDate , logger ) ; assert . equal ( openSurveyPrompt . calledOnce , true ) ; await waitFor ( ( ) => openBrowserCommand . called ) ; assert . equal ( openBrowserCommand . calledOnce , true ) ; assert . equal ( res , true ) ; assert . equal ( context . 0 , true ) ; assert . equal ( context . 0 > Date . now ( ) - 0 && context . 0 <= Date . now ( ) , true ) ; } ) ; it ( "s" , async ( ) => { const context = extApi . context ; const now = surveyIsOpenDate ; const fiveHoursInMs = 0 * 0 * 0 * 0 ; context . 0 = now - fiveHoursInMs ; const showInformationMessage = sb . stub ( vs . window , "s" ) ; const openSurveyPrompt = showInformationMessage . withArgs ( matchPrompt , sinon . match . any ) . resolves ( takeSurveyAction ) ; const openBrowserCommand = sb . stub ( extApi . envUtils , "s" ) . resolves ( ) ; const res = showFlutterSurveyNotificationIfAppropriate ( extApi . context , extApi . envUtils . openInBrowser , now , logger ) ; assert . equal ( openSurveyPrompt . called , false ) ; assert . equal ( openBrowserCommand . called , false ) ; assert . equal ( res , false ) ; } ) ; it ( "s" , async ( ) => { const showInformationMessage = sb . stub ( vs . window , "s" ) ; const openSurveyPrompt = showInformationMessage . withArgs ( matchPrompt , sinon . match . any ) . resolves ( doNotAskAgainAction ) ; const openBrowserCommand = sb . stub ( extApi . envUtils , "s" ) . resolves ( ) ; const res = showFlutterSurveyNotificationIfAppropriate ( extApi . context , extApi . envUtils . openInBrowser , surveyIsOpenDate , logger ) ; assert . equal ( openSurveyPrompt . called , true ) ; assert . equal ( openBrowserCommand . called , false ) ; assert . equal ( res , true ) ; await waitFor ( ( ) => extApi . context . 0 ) ; assert . equal ( extApi . context . 0 , true ) ; } ) ; it ( "s" , async ( ) => { extApi . context . 0 = true ; const showInformationMessage = sb . stub ( vs . window , "s" ) ; const openSurveyPrompt = showInformationMessage . withArgs ( matchPrompt , sinon . match . any ) . resolves ( doNotAskAgainAction ) ; const openBrowserCommand = sb . stub ( extApi . envUtils , "s" ) . resolves ( ) ; const res = showFlutterSurveyNotificationIfAppropriate ( extApi . context , extApi . envUtils . openInBrowser , surveyIsOpenDate , logger ) ; assert . equal ( openSurveyPrompt . called , false ) ; assert . equal ( openBrowserCommand . called , false ) ; assert . equal ( res , false ) ; } ) ; it ( "s" , async ( ) => { assert . equal ( showFlutterSurveyNotificationIfAppropriate ( extApi . context , extApi . envUtils . openInBrowser , immediatelyBeforeSurveyOpensDate , logger ) , false ) ; } ) ; it ( "s" , async ( ) => { assert . equal ( showFlutterSurveyNotificationIfAppropriate ( extApi . context , extApi . envUtils . openInBrowser , immediatelyAfterSurveyOpensDate , logger ) , true ) ; } ) ; it ( "s" , async ( ) => { assert . equal ( showFlutterSurveyNotificationIfAppropriate ( extApi . context , extApi . envUtils . openInBrowser , immediatelyBeforeSurveyClosesDate , logger ) , true ) ; } ) ; it ( "s" , async ( ) => { assert . equal ( showFlutterSurveyNotificationIfAppropriate ( extApi . context , extApi . envUtils . openInBrowser , immediatelyAfterSurveyClosesDate , logger ) , false ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O $number$ O $number$ O O O O O $number$ O O O O O O O O $Promise<T>$ O O O O O O $Promise<boolean>$ O $boolean$ O $number$ O $number$ O O O O O O $Promise<void>$ O $Promise<void>$ O $InternalExtensionApi$ O $Logger$ O $any$ O O O O $any$ O O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O $Promise<void>$ O $InternalExtensionApi$ O $Context$ O O O $any$ O O O O O O $Promise<void>$ O $InternalExtensionApi$ O $Context$ O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $boolean$ O O $Promise<boolean>$ O $InternalExtensionApi$ O $Context$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O $Context$ O $InternalExtensionApi$ O $Context$ O $any$ O $any$ O $Context$ O $boolean$ O O O O $any$ O $any$ O $Context$ O $number$ O O O O $any$ O $any$ O $Context$ O $number$ O $Context$ O $number$ O $DateConstructor$ O $number$ O O O O O $Context$ O $number$ O $DateConstructor$ O $number$ O O O O O O O O O $any$ O O O O O O O O O $Context$ O $InternalExtensionApi$ O $Context$ O $Context$ O $number$ O O O $Context$ O $number$ O $DateConstructor$ O $number$ O O O O $number$ O $number$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $boolean$ O O $Promise<boolean>$ O $InternalExtensionApi$ O $Context$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $Context$ O $boolean$ O O O O $any$ O $any$ O $Context$ O $number$ O O O O $any$ O $any$ O $Context$ O $number$ O $DateConstructor$ O $number$ O O O O O $Context$ O $number$ O $DateConstructor$ O $number$ O O O O O O O O O $any$ O O O O O O O O O $Context$ O $InternalExtensionApi$ O $Context$ O $Context$ O $number$ O O O O $number$ O O O O O O O O O $Context$ O $number$ O $DateConstructor$ O $number$ O O O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $boolean$ O O $Promise<boolean>$ O $InternalExtensionApi$ O $Context$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $boolean$ O O $Promise<boolean>$ O $InternalExtensionApi$ O $Context$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $InternalExtensionApi$ O $Context$ O $boolean$ O O O O O O O $any$ O O O O O O O O $InternalExtensionApi$ O $Context$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $boolean$ O O $Promise<boolean>$ O $InternalExtensionApi$ O $Context$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O O O O O O $any$ O O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O $Promise<void>$ O $InternalExtensionApi$ O $Context$ O O O $any$ O O O O O O $Promise<void>$ O $InternalExtensionApi$ O $Context$ O O O O $number$ O $DateConstructor$ O $number$ O O O O O O O O O $number$ O $number$ O O O O $number$ O $number$ O O O O $number$ O $number$ O O O O $number$ O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O O O O $any$ O O O O $boolean$ O $boolean$ O $InternalExtensionApi$ O $Context$ O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O $number$ O $Logger$ O O $any$ O $any$ O $any$ O $any$ O O O O O $Promise<T>$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O $Context$ O $InternalExtensionApi$ O $Context$ O $any$ O $any$ O $Context$ O $boolean$ O O O O $any$ O $any$ O $Context$ O $number$ O $Context$ O $number$ O $DateConstructor$ O $number$ O O O O O $Context$ O $number$ O $DateConstructor$ O $number$ O O O O O O O O O $any$ O O O O O O O O O $Context$ O $InternalExtensionApi$ O $Context$ O $Context$ O $number$ O $number$ O O $number$ O $number$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O O O O $any$ O O O O $boolean$ O $boolean$ O $InternalExtensionApi$ O $Context$ O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O $number$ O $Logger$ O O $any$ O $any$ O $any$ O $any$ O O O O O $Promise<T>$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $Context$ O $boolean$ O O O O $any$ O $any$ O $Context$ O $number$ O $DateConstructor$ O $number$ O O O O O $Context$ O $number$ O $DateConstructor$ O $number$ O O O O O O O O O $any$ O O O O O O O O O $Context$ O $InternalExtensionApi$ O $Context$ O O $number$ O $number$ O O $number$ O O O O O O O O O $Context$ O $number$ O $number$ O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O O O O $any$ O O O O $boolean$ O $boolean$ O $InternalExtensionApi$ O $Context$ O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O $number$ O $Logger$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O O O O $any$ O O O O $boolean$ O $boolean$ O $InternalExtensionApi$ O $Context$ O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O $number$ O $Logger$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O $Promise<T>$ O O O O $InternalExtensionApi$ O $Context$ O $boolean$ O O $any$ O $any$ O $InternalExtensionApi$ O $Context$ O $boolean$ O O O O O O O $any$ O O O O O O O O $InternalExtensionApi$ O $Context$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O O O O $any$ O O O O $boolean$ O $boolean$ O $InternalExtensionApi$ O $Context$ O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O $number$ O $Logger$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $boolean$ O $InternalExtensionApi$ O $Context$ O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O $number$ O $Logger$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $boolean$ O $InternalExtensionApi$ O $Context$ O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O $number$ O $Logger$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $boolean$ O $InternalExtensionApi$ O $Context$ O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O $number$ O $Logger$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $boolean$ O $InternalExtensionApi$ O $Context$ O $InternalExtensionApi$ O $complex$ O $Promise<boolean>$ O $number$ O $Logger$ O O O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import { isDartSdkFromFlutter , isStableSdk , versionIsAtLeast } from "s" ; import { applyColor , red } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; } ) ; it ( "s" , ( ) => { assert . equal ( versionIsAtLeast ( "s" , "s" ) , false ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , false ) ; } ) ; it ( "s" , ( ) => { assert . equal ( versionIsAtLeast ( "s" , "s" ) , false ) ; } ) ; it ( "s" , ( ) => { assert . equal ( versionIsAtLeast ( "s" , "s" ) , false ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , false ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , false ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , false ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , false ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , false ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , false ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , false ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; assert . equal ( versionIsAtLeast ( "s" , "s" ) , true ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { assert . equal ( isStableSdk ( ) , false ) ; assert . equal ( isStableSdk ( undefined ) , false ) ; } ) ; it ( "s" , ( ) => { assert . equal ( isStableSdk ( "s" ) , true ) ; assert . equal ( isStableSdk ( "s" ) , true ) ; assert . equal ( isStableSdk ( "s" ) , true ) ; } ) ; it ( "s" , ( ) => { assert . equal ( isStableSdk ( "s" ) , false ) ; assert . equal ( isStableSdk ( "s" ) , false ) ; assert . equal ( isStableSdk ( "s" ) , false ) ; assert . equal ( isStableSdk ( "s" ) , false ) ; assert . equal ( isStableSdk ( "s" ) , false ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , function ( ) { if ( ! process . env . DART_PATH ) { this . skip ( ) ; return ; } assert . equal ( isDartSdkFromFlutter ( process . env . DART_PATH ) , false ) ; } ) ; it ( "s" , function ( ) { if ( ! process . env . FLUTTER_PATH ) { this . skip ( ) ; return ; } assert . equal ( isDartSdkFromFlutter ( path . join ( process . env . FLUTTER_PATH , "s" , "s" , "s" ) ) , true ) ; } ) ; } ) ; describe ( "s" , ( ) => { const redPrefix = "s" ; const reset = "s" ; it ( "s" , ( ) => { assert . equal ( applyColor ( "s" , red ) , `template` ) ; } ) ; it ( "s" , ( ) => { assert . equal ( applyColor ( "s" , red ) , `template` ) ; } ) ; it ( "s" , ( ) => { assert . equal ( applyColor ( "s" , red ) , `template` ) ; } ) ; it ( "s" , ( ) => { assert . equal ( applyColor ( "s" , red ) , `template` ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $any$ O $boolean$ O $boolean$ O O O O O O $string$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O $any$ O $any$ O $boolean$ O $undefined$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O O O O O O
import * as assert from "s" ; import { TestOutlineVisitor } from "s" ; import { activate , extApi , getPackages , helloWorldTestMainFile , logger , waitForResult } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , async ( ) => { await activate ( helloWorldTestMainFile ) ; await waitForResult ( ( ) => ! ! extApi . fileTracker . getOutlineFor ( helloWorldTestMainFile ) ) ; } ) ; it ( "s" , ( ) => { const visitor = new TestOutlineVisitor ( logger ) ; const outline = extApi . fileTracker . getOutlineFor ( helloWorldTestMainFile ) ; if ( ! outline ) throw new Error ( `template` ) ; visitor . visit ( outline ) ; assert . equal ( visitor . tests . length , 0 ) ; assert . equal ( visitor . tests [ 0 ] . isGroup , true ) ; assert . equal ( visitor . tests [ 0 ] . fullName , "s" ) ; assert . equal ( visitor . tests [ 0 ] . isGroup , false ) ; assert . equal ( visitor . tests [ 0 ] . fullName , "s" ) ; assert . equal ( visitor . tests [ 0 ] . isGroup , false ) ; assert . equal ( visitor . tests [ 0 ] . fullName , "s" ) ; assert . equal ( visitor . tests [ 0 ] . isGroup , false ) ; assert . equal ( visitor . tests [ 0 ] . fullName , "s" ) ; assert . equal ( visitor . tests [ 0 ] . isGroup , true ) ; assert . equal ( visitor . tests [ 0 ] . fullName , "s" ) ; assert . equal ( visitor . tests [ 0 ] . isGroup , false ) ; assert . equal ( visitor . tests [ 0 ] . fullName , "s" ) ; assert . equal ( visitor . tests [ 0 ] . isGroup , false ) ; assert . equal ( visitor . tests [ 0 ] . fullName , "s" ) ; } ) ; } ) ;	O O O $any$ O O O O O $any$ O O O O O O $Promise<void>$ O $InternalExtensionApi$ O $Promise<void>$ O $any$ O $Logger$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O $any$ O O O $Promise<void>$ O O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O O O $any$ O O O O O O O O $TestOutlineVisitor$ O O $any$ O $Logger$ O O O $Outline$ O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O O $Outline$ O O O $ErrorConstructor$ O O O O $TestOutlineVisitor$ O $void$ O $Outline$ O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O $number$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $boolean$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $string$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $boolean$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $string$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $boolean$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $string$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $boolean$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $string$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $boolean$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $string$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $boolean$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $string$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $boolean$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $string$ O O O O O O O O O O
import * as assert from "s" ; import { DART_DEP_FILE_NODE_CONTEXT , DART_DEP_PACKAGE_NODE_CONTEXT , DART_DEP_PROJECT_NODE_CONTEXT } from "s" ; import { fsPath } from "s" ; import { ensurePackageTreeNode , extApi , getPackages , myPackageThingFile , renderedItemLabel } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; it ( "s" , async ( ) => { const topLevel = await extApi . packagesTreeProvider . getChildren ( undefined ) ; ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" ) ; ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" , "s" ) ; } ) ; it ( "s" , async ( ) => { const topLevel = await extApi . packagesTreeProvider . getChildren ( undefined ) ; const packageNode = ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" ) ; const packageLevel = await extApi . packagesTreeProvider . getChildren ( packageNode ) ; ensurePackageTreeNode ( packageLevel , DART_DEP_PACKAGE_NODE_CONTEXT , "s" ) ; ensurePackageTreeNode ( packageLevel , DART_DEP_PACKAGE_NODE_CONTEXT , "s" ) ; ensurePackageTreeNode ( packageLevel , DART_DEP_PACKAGE_NODE_CONTEXT , "s" ) ; } ) ; it ( "s" , async ( ) => { const topLevel = await extApi . packagesTreeProvider . getChildren ( undefined ) ; const packageNode = ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" ) ; const packageLevel = await extApi . packagesTreeProvider . getChildren ( packageNode ) ; const self = packageLevel ! . find ( ( node ) => node . label === "s" ) ; assert . equal ( self , undefined ) ; } ) ; it ( "s" , async ( ) => { const topLevel = await extApi . packagesTreeProvider . getChildren ( undefined ) ; const packageNode = ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" ) ; const packageLevel = await extApi . packagesTreeProvider . getChildren ( packageNode ) ; const myPackage = ensurePackageTreeNode ( packageLevel , DART_DEP_PACKAGE_NODE_CONTEXT , "s" ) ; const myPackageLibContents = await extApi . packagesTreeProvider . getChildren ( myPackage ) ; const file = ensurePackageTreeNode ( myPackageLibContents , DART_DEP_FILE_NODE_CONTEXT , "s" ) ; assert . equal ( fsPath ( file . resourceUri ! ) , fsPath ( myPackageThingFile ) ) ; } ) ; it ( "s" , async ( ) => { const topLevel = await extApi . packagesTreeProvider . getChildren ( undefined ) ; const packageNode = ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" ) ; const packageLevel = await extApi . packagesTreeProvider . getChildren ( packageNode ) ; const myPackage = ensurePackageTreeNode ( packageLevel , DART_DEP_PACKAGE_NODE_CONTEXT , "s" ) ; const myPackageLibContents = await extApi . packagesTreeProvider . getChildren ( myPackage ) ; const names = myPackageLibContents ! . map ( ( f ) => renderedItemLabel ( f ) ) ; const expectedNamesInOrder = [ "s" , "s" , "s" , "s" , "s" , ] ; const actualNames = names . filter ( ( n ) => expectedNamesInOrder . indexOf ( n ) !== - 0 ) ; assert . equal ( actualNames . length , expectedNamesInOrder . length ) ; actualNames . forEach ( ( name , index ) => assert . equal ( name , expectedNamesInOrder [ index ] ) ) ; } ) ; } ) ;	O O O $any$ O O O O O O O O O O O O O O O O $string$ O O O O O O $any$ O $InternalExtensionApi$ O $Promise<void>$ O $any$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $undefined$ O O O O O $any$ O O O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $string$ O $any$ O $any$ O O O $string$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O O $string$ O $any$ O O O O $string[]$ O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O $string[]$ O $number$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $string[]$ O $number$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $string[]$ O $any$ O O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { fsPath } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const wfs = vs . workspace . workspaceFolders || [ ] ; assert . equal ( wfs . length , 0 ) ; assert . ok ( fsPath ( wfs [ 0 ] . uri ) . endsWith ( path . sep + "s" ) , `template` , ) ; assert . ok ( fsPath ( wfs [ 0 ] . uri ) . endsWith ( path . sep + "s" ) , `template` , ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $boolean$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $boolean$ O $any$ O $any$ O O O O O O O O O O O O O O
import * as assert from "s" ; import * as fs from "s" ; import * as path from "s" ; import * as vs from "s" ; import { dartCodeExtensionIdentifier } from "s" ; import { LogCategory } from "s" ; import { internalApiSymbol } from "s" ; import { InternalExtensionApi } from "s" ; import { fsPath } from "s" ; import { activate , extApi , logger , waitForResult } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { const basicProjectFolder = fsPath ( vs . workspace . workspaceFolders ! [ 0 ] . uri ) ; const expectedString = "s" ; const mainFile = path . join ( basicProjectFolder , "s" , "s" ) ; logger . info ( "s" , LogCategory . CI ) ; await waitForResult ( ( ) => fs . existsSync ( mainFile ) , "s" , 0 ) ; logger . info ( "s" , LogCategory . CI ) ; await waitForResult ( ( ) => { const contents = fs . readFileSync ( mainFile ) ; return contents . indexOf ( expectedString ) !== - 0 ; } , undefined , 0 , false ) ; const contents = fs . readFileSync ( mainFile ) ; if ( contents . indexOf ( expectedString ) === - 0 ) assert . fail ( `template` ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . flutterCapabilities . supportsMultipleSamplesPerElement ) { this . skip ( ) ; return ; } const sampleProjectFolder = fsPath ( vs . workspace . workspaceFolders ! [ 0 ] . uri ) ; const expectedString = "s" ; const mainFile = path . join ( sampleProjectFolder , "s" , "s" ) ; logger . info ( "s" , LogCategory . CI ) ; await waitForResult ( ( ) => fs . existsSync ( mainFile ) , "s" , 0 ) ; logger . info ( "s" , LogCategory . CI ) ; await waitForResult ( ( ) => { const contents = fs . readFileSync ( mainFile ) ; return contents . indexOf ( expectedString ) !== - 0 ; } , undefined , 0 , false ) ; const contents = fs . readFileSync ( mainFile ) ; if ( contents . indexOf ( expectedString ) === - 0 ) assert . fail ( `template` ) ; } ) ; it ( "s" , ( ) => { const ext = vs . extensions . getExtension ( dartCodeExtensionIdentifier ) ; assert . ok ( ext ) ; assert . ok ( ext ! . isActive ) ; const api = ext ! . exports [ internalApiSymbol ] ; assert . equal ( api . workspaceContext . hasAnyFlutterProjects , true ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O $string$ O O O O O O $Promise<void>$ O $InternalExtensionApi$ O $Logger$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $string$ O $string$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $string$ O O O O O O $Logger$ O $void$ O O O $any$ O $LogCategory.CI$ O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O O O $Logger$ O $void$ O O O $any$ O $LogCategory.CI$ O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $undefined$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $string$ O $string$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $string$ O O O O O O $Logger$ O $void$ O O O $any$ O $LogCategory.CI$ O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O O O $Logger$ O $void$ O O O $any$ O $LogCategory.CI$ O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $undefined$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $InternalExtensionApi$ O $any$ O O $any$ O O O O $any$ O $any$ O $InternalExtensionApi$ O $WorkspaceContext$ O $boolean$ O O O O O O O O O O
import * as test_runner from "s" ; module . exports = test_runner ;	O O O $any$ O O O $any$ O $any$ O $any$ O
import * as assert from "s" ; import * as vs from "s" ; import { activate , extApi , flutterTestOtherFile , getPackages , openFile , positionOf , waitForResult } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , async ( ) => { await activate ( flutterTestOtherFile ) ; await waitForResult ( ( ) => ! ! extApi . fileTracker . getOutlineFor ( flutterTestOtherFile ) ) ; } ) ; it ( "s" , async ( ) => { const editor = await openFile ( flutterTestOtherFile ) ; editor . selection = new vs . Selection ( positionOf ( "s" ) , positionOf ( "s" ) ) ; await waitForResult ( ( ) => extApi . cursorIsInTest ) ; const command = ( await vs . commands . getCommands ( true ) ) . filter ( ( id ) => id === "s" ) ; assert . ok ( command ) ; } ) ; it ( "s" , async ( ) => { const editor = await openFile ( flutterTestOtherFile ) ; editor . selection = new vs . Selection ( positionOf ( "s" ) , positionOf ( "s" ) ) ; await waitForResult ( ( ) => ! extApi . cursorIsInTest ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $InternalExtensionApi$ O $any$ O $Promise<void>$ O $Promise<any>$ O $any$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O $any$ O O O $Promise<void>$ O O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $boolean$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $Promise<void>$ O O O O O $InternalExtensionApi$ O $boolean$ O O O O O O O O
import * as assert from "s" ; import * as os from "s" ; import * as path from "s" ; import * as vs from "s" ; import { DebugProtocol } from "s" ; import { platformEol } from "s" ; import { FlutterService , FlutterServiceExtension } from "s" ; import { fetch } from "s" ; import { grey , 0 } from "s" ; import { fsPath } from "s" ; import { DartDebugClient } from "s" ; import { ensureFrameCategories , ensureMapEntry , ensureVariable , ensureVariableWithIndex , isExternalPackage , isLocalPackage , isSdkFrame , isUserCode , killFlutterTester } from "s" ; import { activate , defer , delay , ext , extApi , fileSafeCurrentTestName , flutterHelloWorldBrokenFile , flutterHelloWorldExampleSubFolder , flutterHelloWorldExampleSubFolderMainFile , flutterHelloWorldFolder , flutterHelloWorldGettersFile , flutterHelloWorldHttpFile , flutterHelloWorldLocalPackageFile , flutterHelloWorldMainFile , flutterHelloWorldThrowInExternalPackageFile , flutterHelloWorldThrowInLocalPackageFile , flutterHelloWorldThrowInSdkFile , getDefinition , getLaunchConfiguration , getPackages , openFile , positionOf , sb , setConfigForTest , waitForResult , watchPromise } from "s" ; [ "s" , "s" ] . forEach ( ( deviceId ) => { describe ( `template` , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , ( ) => activate ( flutterHelloWorldMainFile ) ) ; beforeEach ( "s" , function ( ) { if ( deviceId === "s" && ( ! extApi . flutterCapabilities . supportsWebProjects || process . env . ONLY_RUN_DART_VERSION !== "s" ) ) this . skip ( ) ; } ) ; before ( "s" , ( ) => vs . commands . executeCommand ( "s" , fsPath ( flutterHelloWorldFolder ) ) ) ; before ( "s" , ( ) => vs . commands . executeCommand ( "s" , fsPath ( flutterHelloWorldExampleSubFolder ) ) ) ; before ( "s" , ( ) => vs . commands . executeCommand ( "s" , fsPath ( flutterHelloWorldFolder ) ) ) ; let dc ; beforeEach ( "s" , ( ) => { dc = new DartDebugClient ( process . execPath , path . join ( ext . extensionPath , "s" ) , "s" , undefined , extApi . debugCommands , undefined ) ; dc . defaultTimeout = 0 ; const thisDc = dc ; defer ( ( ) => thisDc . stop ( ) ) ; } ) ; afterEach ( ( ) => watchPromise ( "s" , killFlutterTester ( ) ) ) ; async function startDebugger ( script ? : vs . Uri | string , extraConfiguration ? : { [ key ] : any } ) < vs . DebugConfiguration > { extraConfiguration = Object . assign ( { } , { args : extApi . flutterCapabilities . supportsPidFileForMachine ? [ "s" , path . join ( os . tmpdir ( ) , fileSafeCurrentTestName ) ] : [ ] , deviceId , } , extraConfiguration , ) ; const config = await getLaunchConfiguration ( script , extraConfiguration ) ; if ( ! config ) throw new Error ( `template` ) ; await watchPromise ( "s" , dc . start ( config . debugServer ) ) ; return config ; } it ( "s" , async ( ) => { const config = await startDebugger ( flutterHelloWorldMainFile ) ; await Promise . all ( [ dc . assertOutputContains ( "s" , `template` ) , dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await delay ( 0 ) ; await dc . threadsRequest ( ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; describe ( "s" , ( ) => { it ( "s" ) ; it ( "s" ) ; it ( "s" ) ; it ( "s" ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterHelloWorldMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotRestart ) === true ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotReload ) === ( deviceId !== "s" ) ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotRestart ) === false ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotReload ) === false ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterHelloWorldMainFile ) ; config . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotRestart ) === true ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotReload ) === ( deviceId !== "s" ) ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotRestart ) === false ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotReload ) === false ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterHelloWorldMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugPaint ) === true ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugBanner ) === true ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugPaint ) === false ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugBanner ) === false ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterHelloWorldMainFile ) ; config . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugPaint ) === true ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugBanner ) === true ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugPaint ) === false ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugBanner ) === false ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterHelloWorldMainFile ) ; Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await delay ( 0 ) ; await Promise . race ( [ Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) , new Promise ( ( resolve , reject ) => setTimeout ( ( ) => reject ( new Error ( "s" ) ) , 0 ) ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterHelloWorldMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , "s" ) , dc . assertOutputContains ( "s" , "s" ) , dc . launch ( config ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterHelloWorldMainFile ) ; config . program = path . relative ( fsPath ( flutterHelloWorldFolder ) , fsPath ( flutterHelloWorldMainFile ) ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await delay ( 0 ) ; await dc . threadsRequest ( ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) . timeout ( 0 ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterHelloWorldMainFile , { cwd : "s" } ) ; config . program = path . relative ( fsPath ( flutterHelloWorldFolder ) , fsPath ( flutterHelloWorldMainFile ) ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await delay ( 0 ) ; await dc . threadsRequest ( ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterHelloWorldMainFile ) ; await Promise . all ( [ watchPromise ( "s" , dc . configurationSequence ( ) ) , watchPromise ( "s" , dc . launch ( config ) ) , ] ) ; await watchPromise ( "s" , dc . hotReload ( ) ) ; await Promise . all ( [ watchPromise ( "s" , dc . waitForEvent ( "s" ) ) , watchPromise ( "s" , dc . terminateRequest ( ) ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterHelloWorldMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await delay ( 0 ) ; await Promise . all ( [ dc . assertOutputContains ( "s" , "s" ) , dc . customRequest ( "s" ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldExampleSubFolderMainFile ) ; const config = await startDebugger ( ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await delay ( 0 ) ; await Promise . all ( [ dc . assertOutputContains ( "s" , "s" ) , dc . customRequest ( "s" ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( undefined , { cwd : "s" } ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await delay ( 0 ) ; await Promise . all ( [ dc . assertOutputContains ( "s" , "s" ) , dc . customRequest ( "s" ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . flutterCapabilities . supportsDevTools ) { this . skip ( ) ; return ; } const openBrowserCommand = sb . stub ( extApi . envUtils , "s" ) . resolves ( ) ; const config = await startDebugger ( flutterHelloWorldMainFile ) ; await Promise . all ( [ dc . assertOutputContains ( "s" , `template` ) , dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; const devTools = await vs . commands . executeCommand ( "s" ) as { url : string , dispose : ( ) => void } ; assert . ok ( openBrowserCommand . calledOnce ) ; assert . ok ( devTools ) ; defer ( devTools . dispose ) ; assert . ok ( devTools . url ) ; const serverResponse = await fetch ( devTools . url ) ; assert . notEqual ( serverResponse . indexOf ( "s" ) , - 0 ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; [ 0 , 0 , 0 ] . forEach ( ( numReloads ) => { const reloadDescription = numReloads === 0 ? "s" : `template` ; it ( "s" + reloadDescription , async function ( ) { if ( numReloads && extApi . flutterCapabilities . hasEvictBug ) { this . skip ( ) ; return ; } await openFile ( flutterHelloWorldMainFile ) ; const config = await startDebugger ( flutterHelloWorldMainFile ) ; const expectedLocation = { line : positionOf ( "s" ) . line , path : fsPath ( flutterHelloWorldMainFile ) , } ; await watchPromise ( "s" , dc . hitBreakpoint ( config , expectedLocation ) ) ; const stack = await dc . getStack ( ) ; const frames = stack . body . stackFrames ; assert . equal ( frames [ 0 ] . name , "s" ) ; assert . equal ( frames [ 0 ] . source ! . path , expectedLocation . path ) ; assert . equal ( frames [ 0 ] . source ! . name , "s" ) ; await watchPromise ( "s" , dc . resume ( ) ) ; await dc . setBreakpointsRequest ( { breakpoints : [ { line : 0 } , expectedLocation ] , source : { path : fsPath ( flutterHelloWorldMainFile ) } , } ) ; for ( let i = 0 ; i < numReloads ; i ++ ) { await delay ( 0 ) ; await Promise . all ( [ watchPromise ( `template` , dc . assertStoppedLocation ( "s" , expectedLocation ) ) . then ( async ( _ ) => { const stack = await watchPromise ( `template` , dc . getStack ( ) ) ; const frames = stack . body . stackFrames ; assert . equal ( frames [ 0 ] . name , "s" ) ; assert . equal ( frames [ 0 ] . source ! . path , expectedLocation . path ) ; assert . equal ( frames [ 0 ] . source ! . name , "s" ) ; } ) . then ( ( _ ) => watchPromise ( `template` , dc . resume ( ) ) ) , watchPromise ( `template` , dc . hotReload ( ) ) , ] ) ; } await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const config = await startDebugger ( flutterHelloWorldMainFile ) ; config . noDebug = true ; let didStop = false ; dc . waitForEvent ( "s" ) . then ( ( ) => didStop = true ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . setBreakpointWithoutHitting ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( flutterHelloWorldMainFile ) , verified : false , } ) . then ( ( ) => delay ( 0 ) ) . then ( ( ) => dc . terminateRequest ( ) ) , ] ) ; assert . equal ( didStop , false ) ; } ) ; it ( "s" ) ; it ( "s" ) ; it . skip ( "s" ) ; it ( "s" ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const printCall = positionOf ( "s" ) ; const config = await startDebugger ( flutterHelloWorldMainFile , { debugSdkLibraries : true } ) ; await dc . hitBreakpoint ( config , { line : printCall . line + 0 , path : fsPath ( flutterHelloWorldMainFile ) , } ) ; await Promise . all ( [ dc . assertStoppedLocation ( "s" , { path : undefined , } ) . then ( ( response ) => { const frame = response . body . stackFrames [ 0 ] ; assert . equal ( frame . name , "s" ) ; assert . equal ( frame . source ! . path , undefined ) ; assert . equal ( frame . source ! . name , "s" ) ; } ) , dc . stepIn ( ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const printCall = positionOf ( "s" ) ; const config = await startDebugger ( flutterHelloWorldMainFile , { debugSdkLibraries : false } ) ; await dc . hitBreakpoint ( config , { line : printCall . line + 0 , path : fsPath ( flutterHelloWorldMainFile ) , } ) ; await Promise . all ( [ dc . assertStoppedLocation ( "s" , { path : fsPath ( flutterHelloWorldMainFile ) , } ) , dc . stepIn ( ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldHttpFile ) ; const httpReadCall = positionOf ( "s" ) ; const httpReadDef = await getDefinition ( httpReadCall ) ; const config = await startDebugger ( flutterHelloWorldHttpFile , { debugExternalLibraries : true } ) ; await dc . hitBreakpoint ( config , { line : httpReadCall . line + 0 , path : fsPath ( flutterHelloWorldHttpFile ) , } ) ; await Promise . all ( [ dc . assertStoppedLocation ( "s" , { path : fsPath ( httpReadDef . uri ) , } ) . then ( ( response ) => { const frame = response . body . stackFrames [ 0 ] ; assert . equal ( frame . name , "s" ) ; assert . equal ( frame . source ! . path , fsPath ( httpReadDef . uri ) ) ; assert . equal ( frame . source ! . name , "s" ) ; } ) , dc . stepIn ( ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldHttpFile ) ; const httpReadCall = positionOf ( "s" ) ; const config = await startDebugger ( flutterHelloWorldHttpFile , { debugExternalLibraries : false } ) ; await dc . hitBreakpoint ( config , { line : httpReadCall . line , path : fsPath ( flutterHelloWorldHttpFile ) , } ) ; await Promise . all ( [ dc . assertStoppedLocation ( "s" , { path : fsPath ( flutterHelloWorldHttpFile ) , } ) , dc . stepIn ( ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldLocalPackageFile ) ; const printMyThingCall = positionOf ( "s" ) ; const printMyThingDef = await getDefinition ( printMyThingCall ) ; const config = await startDebugger ( flutterHelloWorldLocalPackageFile , { debugExternalLibraries : false } ) ; await dc . hitBreakpoint ( config , { line : printMyThingCall . line + 0 , path : fsPath ( flutterHelloWorldLocalPackageFile ) , } ) ; await Promise . all ( [ dc . assertStoppedLocation ( "s" , { path : fsPath ( printMyThingDef . uri ) , } ) . then ( ( response ) => { const frame = response . body . stackFrames [ 0 ] ; assert . equal ( frame . name , "s" ) ; assert . equal ( frame . source ! . path , fsPath ( printMyThingDef . uri ) ) ; assert . equal ( frame . source ! . name , "s" ) ; } ) , dc . stepIn ( ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldThrowInSdkFile ) ; const config = await startDebugger ( flutterHelloWorldThrowInSdkFile , { debugSdkLibraries : false } ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) . then ( ( ) => dc . setExceptionBreakpointsRequest ( { filters : [ "s" ] } ) ) . then ( ( ) => dc . configurationDoneRequest ( ) ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const stack = await dc . getStack ( ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isSdkFrame ) , "s" , "s" ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isUserCode ) , undefined , undefined ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldThrowInSdkFile ) ; const config = await startDebugger ( flutterHelloWorldThrowInSdkFile , { debugSdkLibraries : true } ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) . then ( ( ) => dc . setExceptionBreakpointsRequest ( { filters : [ "s" ] } ) ) . then ( ( ) => dc . configurationDoneRequest ( ) ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const stack = await dc . getStack ( ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isSdkFrame ) , undefined , undefined ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isUserCode ) , undefined , undefined ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldThrowInExternalPackageFile ) ; const config = await startDebugger ( flutterHelloWorldThrowInExternalPackageFile , { debugExternalLibraries : false } ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) . then ( ( ) => dc . setExceptionBreakpointsRequest ( { filters : [ "s" ] } ) ) . then ( ( ) => dc . configurationDoneRequest ( ) ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const stack = await dc . getStack ( ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isExternalPackage ) , "s" , "s" ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isUserCode ) , undefined , undefined ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldThrowInExternalPackageFile ) ; const config = await startDebugger ( flutterHelloWorldThrowInExternalPackageFile , { debugExternalLibraries : true } ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) . then ( ( ) => dc . setExceptionBreakpointsRequest ( { filters : [ "s" ] } ) ) . then ( ( ) => dc . configurationDoneRequest ( ) ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const stack = await dc . getStack ( ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isExternalPackage ) , undefined , undefined ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isUserCode ) , undefined , undefined ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldThrowInLocalPackageFile ) ; const config = await startDebugger ( flutterHelloWorldThrowInLocalPackageFile , { debugExternalLibraries : false } ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) . then ( ( ) => dc . setExceptionBreakpointsRequest ( { filters : [ "s" ] } ) ) . then ( ( ) => dc . configurationDoneRequest ( ) ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const stack = await dc . getStack ( ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isLocalPackage ) , undefined , undefined ) ; ensureFrameCategories ( stack . body . stackFrames . filter ( isUserCode ) , undefined , undefined ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; function testBreakpointCondition ( condition , shouldStop , expectedError ? ) { return async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const config = await startDebugger ( flutterHelloWorldMainFile ) ; const completionEvent < any > = shouldStop ? dc . assertStoppedLocation ( "s" , { } ) . then ( ( ) => dc . waitForEvent ( "s" ) ) : dc . waitForEvent ( "s" ) ; const errorOutputEvent < any > = expectedError ? dc . assertOutputContains ( "s" , expectedError ) : Promise . resolve ( ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) . then ( ( _ ) => dc . setBreakpointsRequest ( { breakpoints : [ { condition , line : positionOf ( "s" ) . line , } ] , source : { path : fsPath ( flutterHelloWorldMainFile ) } , } ) ) . then ( ( ) => dc . configurationDoneRequest ( ) ) . then ( ( ) => delay ( 0 ) ) . then ( ( ) => dc . terminateRequest ( ) ) , completionEvent , errorOutputEvent , dc . launch ( config ) , ] ) ; } ; } it ( "s" , testBreakpointCondition ( "s" , true ) ) ; it ( "s" , testBreakpointCondition ( "s" , true ) ) ; it ( "s" , testBreakpointCondition ( "s" , false ) ) ; it ( "s" , testBreakpointCondition ( "s" , false ) ) ; it ( "s" , testBreakpointCondition ( "s" , false ) ) ; it ( "s" , testBreakpointCondition ( "s" , false ) ) ; it ( "s" , testBreakpointCondition ( "s" , false , "s" ) ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const config = await startDebugger ( flutterHelloWorldMainFile ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) . then ( ( _ ) => dc . setBreakpointsRequest ( { breakpoints : [ { line : positionOf ( "s" ) . line , logMessage : 's' , } ] , source : { path : fsPath ( flutterHelloWorldMainFile ) } , } ) ) . then ( ( ) => dc . configurationDoneRequest ( ) ) . then ( ( ) => delay ( 0 ) ) . then ( ( ) => dc . terminateRequest ( ) ) , dc . waitForEvent ( "s" ) , dc . assertOutputContains ( "s" , `template` ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await setConfigForTest ( "s" , "s" , true ) ; await openFile ( flutterHelloWorldMainFile ) ; const debugConfig = await startDebugger ( flutterHelloWorldMainFile ) ; await dc . hitBreakpoint ( debugConfig , { line : positionOf ( "s" ) . line , path : fsPath ( flutterHelloWorldMainFile ) , } ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; const listVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; for ( let i = 0 ; i <= 0 ; i ++ ) { ensureVariableWithIndex ( listVariables , i , `template` , `template` , `template` ) ; } const longStringListVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; ensureVariable ( longStringListVariables , "s" , "s" , { ends : "s" , starts : "s" , } ) ; const shortdateListVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; ensureVariable ( shortdateListVariables , "s" , "s" , "s" ) ; const longdateListVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; ensureVariable ( longdateListVariables , "s" , "s" , "s" ) ; const mapVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; ensureVariable ( mapVariables , undefined , "s" , `template` ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : `template` } , value : { evaluateName : `template` , name : "s" , value : "s" } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : `template` } , value : { evaluateName : `template` , name : "s" , value : "s" } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : `template` } , value : { evaluateName : `template` , name : "s" , value : `template` } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : `template` } , value : { evaluateName : undefined , name : "s" , value : `template` } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : `template` } , value : { evaluateName : undefined , name : "s" , value : `template` } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : "s" } , value : { evaluateName : `template` , name : "s" , value : "s" } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : "s" } , value : { evaluateName : `template` , name : "s" , value : `template` } , } , dc ) ; await ensureMapEntry ( mapVariables , { key : { evaluateName : undefined , name : "s" , value : "s" } , value : { evaluateName : `template` , name : "s" , value : `template` } , } , dc ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const debugConfig = await startDebugger ( flutterHelloWorldMainFile ) ; await dc . hitBreakpoint ( debugConfig , { line : positionOf ( "s" ) . line , path : fsPath ( flutterHelloWorldMainFile ) , } ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; assert . equal ( variables . length , 0 ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldGettersFile ) ; const config = await startDebugger ( flutterHelloWorldGettersFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( flutterHelloWorldGettersFile ) , } ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; const classInstance = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; ensureVariable ( classInstance , "s" , "s" , `template` ) ; ensureVariable ( classInstance , "s" , "s" , `template` ) ; ensureVariable ( classInstance , undefined , "s" , { starts : "s" } ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it . skip ( "s" , async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const config = await startDebugger ( flutterHelloWorldMainFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( flutterHelloWorldMainFile ) , } ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; for ( const variable of variables ) { const evaluateName = ( variable as any ) . evaluateName ; if ( ! evaluateName ) continue ; const evaluateResult = await dc . evaluate ( evaluateName ) ; assert . ok ( evaluateResult ) ; assert . equal ( evaluateResult . result , variable . value ) ; assert . equal ( ! ! evaluateResult . variablesReference , ! ! variable . variablesReference ) ; } await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const config = await startDebugger ( flutterHelloWorldMainFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( flutterHelloWorldMainFile ) , } ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; const listVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; const listLongstringVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; const mapVariables = await dc . getVariables ( variables . find ( ( v ) => v . name === "s" ) ! . variablesReference ) ; const allVariables = listVariables . concat ( listLongstringVariables ) . concat ( mapVariables ) ; for ( const variable of allVariables ) { const evaluateName = ( variable as any ) . evaluateName ; if ( ! evaluateName ) continue ; const evaluateResult = await dc . evaluate ( evaluateName ) ; assert . ok ( evaluateResult ) ; if ( variable . value . endsWith ( "s" ) ) { const prefix = variable . value . slice ( 0 , - 0 ) ; assert . ok ( evaluateResult . result . length > prefix . length ) ; assert . equal ( evaluateResult . result . slice ( 0 , prefix . length ) , prefix ) ; } else { assert . equal ( evaluateResult . result , variable . value ) ; } assert . equal ( ! ! evaluateResult . variablesReference , ! ! variable . variablesReference ) ; } await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const config = await startDebugger ( flutterHelloWorldMainFile ) ; await Promise . all ( [ dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( flutterHelloWorldMainFile ) , } ) , ] ) ; const evaluateResult = await dc . evaluate ( `template` ) ; assert . ok ( evaluateResult ) ; assert . equal ( evaluateResult . result , `template` ) ; assert . equal ( evaluateResult . variablesReference , 0 ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const config = await startDebugger ( flutterHelloWorldMainFile ) ; await Promise . all ( [ dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( flutterHelloWorldMainFile ) , } ) , ] ) ; const evaluateResult = await dc . evaluate ( `template` ) ; assert . ok ( evaluateResult ) ; assert . equal ( evaluateResult . result , ( new Date ( ) ) . getFullYear ( ) ) ; assert . equal ( evaluateResult . variablesReference , 0 ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const config = await startDebugger ( flutterHelloWorldMainFile ) ; await Promise . all ( [ dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( flutterHelloWorldMainFile ) , } ) , ] ) ; const evaluateResult = await dc . evaluate ( `template` ) ; const thisYear = new Date ( ) . getFullYear ( ) . toString ( ) ; assert . ok ( evaluateResult ) ; assert . ok ( evaluateResult . result . startsWith ( "s" + thisYear ) , `template` ) ; assert . ok ( evaluateResult . variablesReference ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const config = await startDebugger ( flutterHelloWorldMainFile ) ; await Promise . all ( [ dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( flutterHelloWorldMainFile ) , } ) , ] ) ; const evaluateResult = await dc . evaluate ( `template` ) ; assert . ok ( evaluateResult ) ; assert . equal ( evaluateResult . result , ( new Date ( ) ) . getFullYear ( ) ) ; assert . equal ( evaluateResult . variablesReference , 0 ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; } ) ; it . skip ( "s" , async ( ) => { await openFile ( flutterHelloWorldBrokenFile ) ; const config = await startDebugger ( flutterHelloWorldBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( flutterHelloWorldBrokenFile ) , } ) , dc . launch ( config ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldBrokenFile ) ; const config = await startDebugger ( flutterHelloWorldBrokenFile ) ; config . noDebug = true ; let didStop = false ; dc . waitForEvent ( "s" ) . then ( ( ) => didStop = true ) ; await Promise . all ( [ dc . configurationSequence ( ) . then ( ( ) => delay ( 0 ) ) . then ( ( ) => dc . terminateRequest ( ) ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; assert . equal ( didStop , false ) ; } ) ; it . skip ( "s" , async ( ) => { await openFile ( flutterHelloWorldBrokenFile ) ; const config = await startDebugger ( flutterHelloWorldBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( flutterHelloWorldBrokenFile ) , } ) , dc . launch ( config ) , ] ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldBrokenFile ) ; const config = await startDebugger ( flutterHelloWorldBrokenFile ) ; await Promise . all ( [ watchPromise ( "s" , dc . configurationSequence ( ) ) , watchPromise ( "s" , dc . assertOutputContains ( "s" , "s" ) ) , watchPromise ( "s" , dc . launch ( config ) ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldBrokenFile ) ; const config = await startDebugger ( flutterHelloWorldBrokenFile ) ; await Promise . all ( [ watchPromise ( "s" , dc . configurationSequence ( ) ) , watchPromise ( "s" , dc . assertOutputContains ( "s" , "s" ) . then ( ( event ) => { assert . equal ( event . body . output . indexOf ( "s" ) , - 0 ) ; assert . equal ( event . body . source ! . name , "s" ) ; assert . equal ( event . body . source ! . path , fsPath ( flutterHelloWorldBrokenFile ) ) ; assert . equal ( event . body . line , positionOf ( "s" ) . line + 0 ) ; assert . equal ( event . body . column , 0 ) ; } ) , ) , watchPromise ( "s" , dc . launch ( config ) ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . flutterCapabilities . hasUpdatedStructuredErrorsFormat ) { this . skip ( ) ; return ; } await openFile ( flutterHelloWorldBrokenFile ) ; const config = await startDebugger ( flutterHelloWorldBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . InspectorStructuredErrors ) === true ) ; let stderrOutput = "s" ; const handleOutput = ( event : DebugProtocol . OutputEvent ) => { if ( event . body . category === "s" ) { stderrOutput += event . body . output ; } } ; dc . on ( "s" , handleOutput ) ; try { dc . hotReload ( ) ; await waitForResult ( ( ) => stderrOutput . indexOf ( "s" ) !== - 0 && stderrOutput . indexOf ( "s" ) !== - 0 , "s" , 0 , ) ; } finally { dc . removeListener ( "s" , handleOutput ) ; } await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; let stdErrLines = stderrOutput . split ( "s" ) . map ( ( l ) => l . trim ( ) ) ; const firstErrorLine = stdErrLines . findIndex ( ( l ) => l . indexOf ( "s" ) !== - 0 ) ; stdErrLines = stdErrLines . slice ( firstErrorLine ) ; const lastErrorLine = stdErrLines . findIndex ( ( l ) => l . indexOf ( "s" ) !== - 0 ) ; stdErrLines = stdErrLines . slice ( 0 , lastErrorLine + 0 ) ; const expectedErrorLines = [ 0 ( `template` ) , grey ( `template` ) , `template` , grey ( `template` ) , 0 ( `template` ) , grey ( `template` ) , 0 ( `template` ) , grey ( `template` ) , grey ( `template` ) , grey ( `template` ) , grey ( `template` ) , grey ( `template` ) , 0 ( `template` ) , ] ; assert . deepStrictEqual ( stdErrLines , expectedErrorLines ) ; } ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O $Promise<string>$ O O O O O O $string$ O $string$ O O O O O O $string$ O O O O O O $any$ O O O O O O $void$ O $Promise<void>$ O $void$ O $void$ O $boolean$ O $any$ O $any$ O $any$ O $Promise<void>$ O O O O O O $Promise<void>$ O $void$ O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Promise<any>$ O $Promise<any>$ O $Promise<void>$ O $Promise<any>$ O $any$ O $any$ O $Promise<void>$ O $Promise<void>$ O $Promise<T>$ O O O O O O O O O O $void$ O O $string$ O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O $any$ O O O O O O O O O $string$ O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $string$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $string$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $string$ O $any$ O O O O O $DartDebugClient$ O $any$ O O O O O O O $DartDebugClient$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $undefined$ O $InternalExtensionApi$ O $DebugCommandHandler$ O $undefined$ O O $DartDebugClient$ O $number$ O O O O $DartDebugClient$ O $DartDebugClient$ O $void$ O O O O $DartDebugClient$ O $Promise<void>$ O O O O O O O $any$ O O O O $Promise<T>$ O O O $Promise<void>$ O O O O O O O $Promise$ O $any$ O O $any$ O $any$ O O O $complex$ O O O O $string$ O O O O O O $any$ O $any$ O O $complex$ O $ObjectConstructor$ O O O O O O O $any[]$ O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O $string$ O O O $complex$ O O O O $any$ O O $Promise<any>$ O $any$ O $complex$ O O O O O $any$ O O O $ErrorConstructor$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotRestart$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotReload$ O O O $string$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotRestart$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotReload$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotRestart$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotReload$ O O O $string$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotRestart$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotReload$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugPaint$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugBanner$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugPaint$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugBanner$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugPaint$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugBanner$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugPaint$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugBanner$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O $complex$ O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O $number$ O O O O $void$ O O $ErrorConstructor$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $string$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $string$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $undefined$ O O $string$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O O O O $any$ O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O $string$ O O O $void$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $complex$ O O $void$ O $complex$ O $void$ O O $any$ O $any$ O $complex$ O $string$ O O O $string$ O O $Promise<string>$ O $complex$ O $string$ O O $any$ O $any$ O $string$ O $number$ O O O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O O O O O O O O O $void$ O O $number$ O O O O $string$ O $number$ O O O O O O O $any$ O O O $string$ O O O O O O O O $number$ O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $complex$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O $complex$ O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O $DartDebugClient$ O $Promise<any>$ O O $complex$ O O O $number$ O O O O $complex$ O O $complex$ O O $string$ O $string$ O $any$ O O O O O O O O O $number$ O O O $number$ O $number$ O $number$ O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O $complex$ O O O O O O O $any$ O O O O $any$ O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O O $void$ O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O O O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $boolean$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $boolean$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O $false$ O O O O O O O O O O O $Promise<void>$ O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $undefined$ O $undefined$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $string$ O $string$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $string$ O $string$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $string$ O $string$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O $string[]$ O O O O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O $string[]$ O O O O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O $string[]$ O O O O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O $string[]$ O O O O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O O $undefined$ O $undefined$ O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $boolean$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O $string[]$ O O O O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O $void$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O $undefined$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O O $Promise<void>$ O $string$ O $boolean$ O $string$ $string$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $Promise$ O O O O $boolean$ O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O $Promise$ O O O O $string$ O $DartDebugClient$ O $Promise<any>$ O O O $string$ O O $PromiseConstructor$ O $complex$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O $complex$ O O O $string$ O $any$ O $any$ O O O O $any$ O O O O $complex$ O O $string$ O $string$ O $any$ O O O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $Promise<void>$ O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $Promise<any>$ O $Promise<any>$ O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O $Promise<void>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O $complex$ O O O $any$ O $any$ O O O O $any$ O $string$ O O O O O O $complex$ O O $string$ O $string$ O $any$ O O O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $Promise<void>$ O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O O O O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O $number$ O O O $number$ O O O $number$ O O O $void$ O $any[]$ O $number$ O O O O O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O $any[]$ O O O O O O $string$ O O O $string$ O O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O $any[]$ O O O O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O $any[]$ O O O O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O $void$ O $any[]$ O $undefined$ O O O O O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $Promise<void>$ O $any[]$ O O $complex$ O O $undefined$ O $undefined$ O $string$ O O O $string$ O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DartDebugClient$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O $any$ O $any$ O $any[]$ O $number$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O O O O O O O O $void$ O $any[]$ O $undefined$ O O O O $string$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O O O O $any$ O $any[]$ O O O $any$ O O $any$ O O O O $any$ O O O O $any$ O O O O $complex$ O O $DartDebugClient$ O $complex$ O $any$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O $any$ O $any$ O O $any$ O $any$ O O O $complex$ O $number$ O O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any[]$ O $any[]$ O $complex$ O $any[]$ O O $complex$ O $any[]$ O O O O O $any$ O $any[]$ O O O $any$ O O $any$ O O O O $any$ O O O O $any$ O O O O $complex$ O O $DartDebugClient$ O $complex$ O $any$ O O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $complex$ O $string$ O $number$ O $any$ O $any$ O O $any$ O $any$ O $complex$ O $string$ O $string$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $complex$ O $string$ O $any$ O $any$ O O O $any$ O $any$ O O O $complex$ O $number$ O O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O O O O $complex$ O O $DartDebugClient$ O $complex$ O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O O O O $any$ O $any$ O $complex$ O $number$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O O O O $complex$ O O $DartDebugClient$ O $complex$ O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O O O $DateConstructor$ O O O O $number$ O O O O $any$ O $any$ O $complex$ O $number$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O O O O $complex$ O O $DartDebugClient$ O $complex$ O O O O O $string$ O O $DateConstructor$ O O O $number$ O O O $string$ O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O $boolean$ O O O $string$ O O O O O $any$ O $any$ O $complex$ O $number$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O O O O $complex$ O O $DartDebugClient$ O $complex$ O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O O O $DateConstructor$ O O O O $number$ O O O O $any$ O $any$ O $complex$ O $number$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $boolean$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $boolean$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $Promise<void>$ O O O O O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O $any$ O $any$ O $false$ O O O O O O O $any$ O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.InspectorStructuredErrors$ O O O O O O $string$ O O O O $void$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $string$ O $any$ O $any$ O $any$ O O O O $DartDebugClient$ O $any$ O O O $void$ O O O O $DartDebugClient$ O $Promise<void>$ O O O O $Promise<void>$ O O O O $string$ O $number$ O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O $DartDebugClient$ O $any$ O O O $void$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $string[]$ O $string$ O $complex$ O O O O $U[]$ O O $string$ O O $string$ O $string$ O O O O O $number$ O $string[]$ O $number$ O O $string$ O O $string$ O $number$ O O O O O O O O $string[]$ O $string[]$ O $string[]$ O $number$ O O O $number$ O $string[]$ O $number$ O O $string$ O O $string$ O $number$ O O O O O O O O $string[]$ O $string[]$ O $string[]$ O O O $number$ O O O O O $string[]$ O O $string$ O O O O $string$ O O O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O O O $any$ O $any$ O $string[]$ O $string[]$ O O O O O O O O O O O
import * as assert from "s" ; import * as os from "s" ; import * as path from "s" ; import * as vs from "s" ; import { DebugProtocol } from "s" ; import { fsPath } from "s" ; import { DartDebugClient } from "s" ; import { killFlutterTester , spawnFlutterProcess } from "s" ; import { activate , defer , delay , ext , extApi , fileSafeCurrentTestName , flutterHelloWorldExampleSubFolder , flutterHelloWorldFolder , flutterHelloWorldMainFile , getAttachConfiguration , getPackages , logger , watchPromise } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , ( ) => activate ( flutterHelloWorldMainFile ) ) ; before ( "s" , ( ) => vs . commands . executeCommand ( "s" , fsPath ( flutterHelloWorldFolder ) ) ) ; before ( "s" , ( ) => vs . commands . executeCommand ( "s" , fsPath ( flutterHelloWorldExampleSubFolder ) ) ) ; beforeEach ( ( ) => { defer ( ( ) => watchPromise ( "s" , killFlutterTester ( ) ) ) ; } ) ; let dc ; beforeEach ( "s" , ( ) => { dc = new DartDebugClient ( process . execPath , path . join ( ext . extensionPath , "s" ) , "s" , undefined , extApi . debugCommands , undefined ) ; dc . defaultTimeout = 0 ; defer ( ( ) => dc . stop ( ) ) ; } ) ; async function attachDebugger ( observatoryUri ? ) < vs . DebugConfiguration > { const config = await getAttachConfiguration ( { args : extApi . flutterCapabilities . supportsPidFileForMachine ? [ "s" , path . join ( os . tmpdir ( ) , fileSafeCurrentTestName ) ] : [ ] , deviceId : "s" , observatoryUri , } ) ; if ( ! config ) throw new Error ( `template` ) ; await dc . start ( config . debugServer ) ; dc . on ( "s" , ( event : DebugProtocol . OutputEvent ) => { if ( event . body . category === "s" ) logger . error ( event . body . output ) ; } ) ; return config ; } it ( "s" , async ( ) => { const process = await spawnFlutterProcess ( flutterHelloWorldMainFile ) ; const observatoryUri = await process . observatoryUri ; const config = await attachDebugger ( observatoryUri ) ; await Promise . all ( [ watchPromise ( "s" , dc . configurationSequence ( ) ) , watchPromise ( "s" , dc . launch ( config ) ) , ] ) ; await delay ( 0 ) ; await watchPromise ( "s" , dc . threadsRequest ( ) ) ; await Promise . all ( [ watchPromise ( "s" , dc . waitForEvent ( "s" ) ) , watchPromise ( "s" , dc . terminateRequest ( ) ) , ] ) ; } ) ; it ( "s" , async ( ) => { const process = await spawnFlutterProcess ( flutterHelloWorldMainFile ) ; const observatoryUri = await process . observatoryUri ; const config = await attachDebugger ( observatoryUri ) ; await Promise . all ( [ watchPromise ( "s" , dc . configurationSequence ( ) ) , watchPromise ( "s" , dc . launch ( config ) ) , ] ) ; await Promise . all ( [ watchPromise ( "s" , dc . waitForEvent ( "s" ) ) , watchPromise ( "s" , dc . terminateRequest ( ) ) , ] ) ; await delay ( 0 ) ; assert . equal ( process . hasExited , false ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $Promise<void>$ O $Promise<DartProcess>$ O O O O O O $Promise<void>$ O $void$ O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $string$ O $any$ O $any$ O $any$ O $Promise<any>$ O $Promise<void>$ O $Logger$ O $Promise<T>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $string$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $string$ O $any$ O O O O $any$ O O O O O $void$ O O O O $Promise<T>$ O O O $Promise<void>$ O O O O O O O O O $DartDebugClient$ O $any$ O O O O O O O $DartDebugClient$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $undefined$ O $InternalExtensionApi$ O $DebugCommandHandler$ O $undefined$ O O $DartDebugClient$ O $number$ O O O $void$ O O O O $DartDebugClient$ O $Promise<void>$ O O O O O O O O O $Promise$ O $string$ $string$ O O $any$ O $any$ O O O $any$ O O $Promise<any>$ O O $any[]$ O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O O O $any$ O O O $ErrorConstructor$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O $any$ O O $DartDebugClient$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $Logger$ O $void$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O O O O O O $DartProcess$ O O $Promise<DartProcess>$ O $any$ O O O $string$ O O $DartProcess$ O $Promise<string>$ O O $any$ O O $Promise<any>$ O $string$ O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O $Promise<void>$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O O $any$ O O O O O O O O O $DartProcess$ O O $Promise<DartProcess>$ O $any$ O O O $string$ O O $DartProcess$ O $Promise<string>$ O O $any$ O O $Promise<any>$ O $string$ O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $DartProcess$ O $boolean$ O O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { DebugProtocol } from "s" ; import { versionIsAtLeast } from "s" ; import { fsPath } from "s" ; import { DartDebugClient } from "s" ; import { killFlutterTester } from "s" ; import { activate , defer , delay , ext , extApi , flutterHelloWorldFolder , flutterTestAnotherFile , flutterTestBrokenFile , flutterTestMainFile , flutterTestOtherFile , getExpectedResults , getLaunchConfiguration , getPackages , logger , makeTextTree , openFile , positionOf , withTimeout } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; let testPrefix = "s" ; beforeEach ( "s" , async ( ) => { await activate ( flutterTestMainFile ) ; if ( versionIsAtLeast ( extApi . analyzerCapabilities . version , "s" ) ) testPrefix = "s" ; } ) ; before ( "s" , ( ) => vs . commands . executeCommand ( "s" , fsPath ( flutterHelloWorldFolder ) ) ) ; before ( "s" , ( ) => vs . commands . executeCommand ( "s" , fsPath ( flutterHelloWorldFolder ) ) ) ; let dc ; beforeEach ( "s" , ( ) => { dc = new DartDebugClient ( process . execPath , path . join ( ext . extensionPath , "s" ) , "s" , undefined , extApi . debugCommands , extApi . testTreeProvider , ) ; dc . defaultTimeout = 0 ; const thisDc = dc ; defer ( ( ) => withTimeout ( Promise . all ( [ thisDc . terminateRequest ( ) . catch ( ( e ) => logger . error ( e ) ) , delay ( 0 ) . then ( ( ) => thisDc . stop ( ) ) . catch ( ( e ) => logger . error ( e ) ) , ] ) , "s" , 0 , ) ) ; } ) ; afterEach ( killFlutterTester ) ; async function startDebugger ( script ? : vs . Uri | string ) < vs . DebugConfiguration > { const config = await getLaunchConfiguration ( script ) ; if ( ! config ) throw new Error ( `template` ) ; await dc . start ( config . debugServer ) ; return config ; } it ( "s" , async ( ) => { const config = await startDebugger ( flutterTestMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterTestMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , `template` ) , dc . waitForEvent ( "s" ) , dc . assertPassingTest ( `template` ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const relativePath = path . relative ( fsPath ( flutterHelloWorldFolder ) , fsPath ( flutterTestMainFile ) ) ; const config = await startDebugger ( `template` ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , `template` ) , dc . assertPassingTest ( `template` ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterTestMainFile ) ; config . program = path . relative ( fsPath ( flutterHelloWorldFolder ) , fsPath ( flutterTestMainFile ) ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , `template` ) , dc . assertPassingTest ( `template` ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterTestMainFile ) ; const config = await startDebugger ( flutterTestOtherFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , `template` ) , dc . assertPassingTest ( `template` ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterTestOtherFile ) ; const config = await startDebugger ( undefined ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , `template` ) , dc . assertPassingTest ( `template` ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterTestOtherFile ) ; const config = await startDebugger ( "s" ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , `template` ) , dc . assertPassingTest ( `template` ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( "s" ) ; config . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const testFiles = [ flutterTestMainFile , flutterTestOtherFile , flutterTestAnotherFile , flutterTestBrokenFile , ] ; const topLevelNodes = await extApi . testTreeProvider . getChildren ( ) ; assert . ok ( topLevelNodes ) ; assert . equal ( topLevelNodes ! . length , testFiles . length ) ; for ( const file of testFiles ) { await openFile ( file ) ; const expectedResults = getExpectedResults ( ) ; const actualResults = ( await makeTextTree ( file , extApi . testTreeProvider ) ) . join ( "s" ) ; assert . ok ( expectedResults ) ; assert . ok ( actualResults ) ; assert . equal ( actualResults , expectedResults ) ; } } ) ; it ( "s" , async ( ) => { await openFile ( flutterTestMainFile ) ; const config = await startDebugger ( flutterTestMainFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( flutterTestMainFile ) , } ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterTestBrokenFile ) ; const config = await startDebugger ( flutterTestBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { } ) , dc . launch ( config ) , ] ) ; } ) ; it . skip ( "s" , async ( ) => { await openFile ( flutterTestBrokenFile ) ; const config = await startDebugger ( flutterTestBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( flutterTestBrokenFile ) , } ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterTestBrokenFile ) ; const config = await startDebugger ( flutterTestBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { } ) , dc . launch ( config ) , ] ) ; const variables = await dc . getTopFrameVariables ( "s" ) as DebugProtocol . Variable [ ] ; assert . ok ( variables ) ; let v = variables . find ( ( v ) => v . name === "s" ) ; assert . ok ( v ) ; v = v ! ; assert . equal ( v . evaluateName , "s" ) ; assert . ok ( v . value . startsWith ( `template` ) ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterTestBrokenFile ) ; const config = await startDebugger ( flutterTestBrokenFile ) ; config . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertErroringTest ( `template` ) , dc . assertOutput ( "s" , "s" ) , dc . assertOutputContains ( "s" , "s" ) , dc . launch ( config ) , ] ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $boolean$ O O O O O O $string$ O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O O $Promise<void>$ O $void$ O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Promise<any>$ O $Promise<void>$ O $Logger$ O $Promise<string[]>$ O $Promise<any>$ O $any$ O $Promise<T>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O $string$ O O O $any$ O O O O O O O O O $Promise<void>$ O $any$ O O O O $boolean$ O $InternalExtensionApi$ O O O $string$ O O O O $string$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $string$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $string$ O $any$ O O O O O $DartDebugClient$ O $any$ O O O O O O O $DartDebugClient$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $undefined$ O $InternalExtensionApi$ O $DebugCommandHandler$ O $InternalExtensionApi$ O $TestResultsProvider$ O O O $DartDebugClient$ O $number$ O O O O $DartDebugClient$ O $DartDebugClient$ O $void$ O O O O $Promise<T>$ O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $Promise<any>$ O O $any$ O O $Logger$ O $void$ O $any$ O O O $Promise<void>$ O O O O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $complex$ O O $any$ O O $Logger$ O $void$ O $any$ O O O O O O O O O O O O O O O O $any$ O $Promise<void>$ O O O O $Promise$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O O O $any$ O O O $ErrorConstructor$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O $any$ O O O $any$ O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $string$ O $any$ O O $string$ O $any$ O O O O $any$ O O $Promise<any>$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $string$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $undefined$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $InternalExtensionApi$ O $TestResultsProvider$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any[]$ O $number$ O O O O O $any$ O $any[]$ O O O $Promise<any>$ O $any$ O O O $any$ O $any$ O O O O $string$ O O O $Promise<string[]>$ O $any$ O $InternalExtensionApi$ O $TestResultsProvider$ O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O $any$ O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any[]$ O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O O O O
import * as assert from "s" ; import { Range } from "s" ; import { ColorRangeComputer } from "s" ; import { activate , currentDoc , rangesOf , rangeString , setTestContent , waitForNextAnalysis } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { await waitForNextAnalysis ( ( ) => setTestContent ( `template` ) ) ; const doc = currentDoc ( ) ; const computer = new ColorRangeComputer ( ) ; const results = computer . compute ( doc ) ; assert . ok ( results ) ; assert . equal ( Object . keys ( results ) . length , 0 ) ; const ensureColor = ( hex , ranges : Range [ ] ) => { assert . ok ( results [ hex ] , hex ) ; assert . deepStrictEqual ( results [ hex ] . map ( rangeString ) , ranges . map ( rangeString ) , hex ) ; } ; ensureColor ( "s" , rangesOf ( "s" ) ) ; ensureColor ( "s" , rangesOf ( "s" ) ) ; ensureColor ( "s" , rangesOf ( "s" ) ) ; ensureColor ( "s" , rangesOf ( "s" ) ) ; ensureColor ( "s" , rangesOf ( "s" ) ) ; ensureColor ( "s" , rangesOf ( "s" ) ) ; ensureColor ( "s" , rangesOf ( "s" ) ) ; } ) ; } ) ;	O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O $any[]$ O $string$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $Promise<void>$ O O O O O O $any$ O $any$ O O O O $ColorRangeComputer$ O O $any$ O O O O $complex$ O $ColorRangeComputer$ O $complex$ O $any$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $ObjectConstructor$ O $complex$ O $complex$ O O $number$ O O O O O $void$ O O $string$ O $any[]$ O $any$ O O O O O $any$ O $any$ O $complex$ O $string$ O O $string$ O O $any$ O $any$ O $complex$ O $string$ O O $U[]$ O $string$ O O $any[]$ O $U[]$ O $string$ O O $string$ O O O O $void$ O O O $any[]$ O O O O O $void$ O O O $any[]$ O O O O O $void$ O O O $any[]$ O O O O O $void$ O O O $any[]$ O O O O O $void$ O O O $any[]$ O O O O O $void$ O O O $any[]$ O O O O O $void$ O O O $any[]$ O O O O O O O O O O O
import * as assert from "s" ; import { IconRangeComputer } from "s" ; import { activate , currentDoc , extApi , rangeOf , setTestContent , waitForNextAnalysis } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { await waitForNextAnalysis ( ( ) => setTestContent ( `template` ) ) ; const doc = currentDoc ( ) ; const outline = extApi . fileTracker . getFlutterOutlineFor ( doc . uri ) ! ; const computer = new IconRangeComputer ( extApi . logger ) ; const results = computer . compute ( doc , outline ) ; assert . ok ( results ) ; assert . deepStrictEqual ( Object . keys ( results ) , [ "s" , "s" ] ) ; assert . equal ( results . add . length , 0 ) ; assert . ok ( results . add [ 0 ] . isEqual ( rangeOf ( "s" ) ) ) ; assert . equal ( results . airline_seat_legroom_reduced . length , 0 ) ; assert . ok ( results . airline_seat_legroom_reduced [ 0 ] . isEqual ( rangeOf ( "s" ) ) ) ; } ) ; } ) ;	O O O $any$ O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $complex$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $Promise<void>$ O O O O O O $any$ O $any$ O O O O $FlutterOutline$ O $InternalExtensionApi$ O $complex$ O $FlutterOutline$ O $any$ O $any$ O O O O $IconRangeComputer$ O O $any$ O $InternalExtensionApi$ O $EmittingLogger$ O O O $complex$ O $IconRangeComputer$ O $complex$ O $any$ O $FlutterOutline$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $ObjectConstructor$ O $complex$ O $complex$ O O O O O O O O O $any$ O $any$ O $complex$ O $any$ O $number$ O O O O $any$ O $any$ O $complex$ O $any$ O O O O $any$ O $complex$ O O O O O O $any$ O $any$ O $complex$ O $any$ O $number$ O O O O $any$ O $any$ O $complex$ O $any$ O O O O $any$ O $complex$ O O O O O O O O O O O O
import { IAmDisposable } from "s" ; export class FakeStdIOService implements IAmDisposable { private readonly disposables : IAmDisposable [ ] = [ ] ; protected async notify < T > ( subscriptions < ( notification : T ) => void > , notification : T ) < void > { await Promise . all ( subscriptions . slice ( ) . map ( ( sub ) => sub ( notification ) ) ) ; } protected subscribe < T > ( subscriptions < ( notification : T ) => void > , subscriber : ( notification : T ) => void ) { subscriptions . push ( subscriber ) ; const disposable = { dispose : ( ) => { let index = subscriptions . indexOf ( subscriber ) ; if ( index >= 0 ) { subscriptions . splice ( index , 0 ) ; } index = this . disposables . indexOf ( disposable ) ; if ( index >= 0 ) { this . disposables . splice ( index , 0 ) ; } } , } ; this . disposables . push ( disposable ) ; return disposable ; } public dispose ( ) { this . disposables . forEach ( ( d ) => d . dispose ( ) ) ; } }	O O $any$ O O O O O O $any$ O $any$ O O O $IAmDisposable[]$ O $any$ O O O O O O O O $Promise$ O $any$ O O $Array$ O O $T$ O $any$ O O O O O $T$ O $any$ O O O O O O $PromiseConstructor$ O O O $void)[]$ O $void)[]$ O O O $U[]$ O O $void$ O O $void$ O $T$ O O O O O O $IAmDisposable$ O $any$ O O $Array$ O O $T$ O $any$ O O O O O $void$ O O $T$ O $any$ O O O O O $void)[]$ O $number$ O $void$ O O O $complex$ O O $void$ O O O O O O $number$ O $void)[]$ O $number$ O $void$ O O O O $number$ O O O O $void)[]$ O $complex$ O $number$ O O O O O $number$ O O O $IAmDisposable[]$ O $number$ O $complex$ O O O O $number$ O O O O O O $IAmDisposable[]$ O $complex$ O $number$ O O O O O O O O O O O $IAmDisposable[]$ O $number$ O $complex$ O O O $complex$ O O O $void$ O O O O O $IAmDisposable[]$ O $void$ O O $IAmDisposable$ O O $IAmDisposable$ O $complex$ O O O O O O
import * as assert from "s" ; import { DaemonCapabilities } from "s" ; import * as f from "s" ; import { IAmDisposable , IFlutterDaemon } from "s" ; import { UnknownResponse } from "s" ; import { FlutterDeviceManager } from "s" ; import { logger } from "s" ; import { FakeStdIOService } from "s" ; describe ( "s" , ( ) => { let dm ; let daemon ; beforeEach ( ( ) => { daemon = new FakeFlutterDaemon ( ) ; dm = new FlutterDeviceManager ( logger , daemon , true ) ; } ) ; afterEach ( ( ) => { dm . dispose ( ) ; daemon . dispose ( ) ; } ) ; it ( "s" , async ( ) => { assert . equal ( dm . currentDevice , undefined ) ; await daemon . connect ( physicalAndroidMobile , true ) ; assert . deepStrictEqual ( dm . currentDevice , physicalAndroidMobile ) ; await daemon . connect ( emulatedAndroidMobile , true ) ; assert . deepStrictEqual ( dm . currentDevice , emulatedAndroidMobile ) ; } ) ; it ( "s" , async ( ) => { assert . equal ( dm . currentDevice , undefined ) ; await daemon . connect ( emulatedAndroidMobile , true ) ; assert . deepStrictEqual ( dm . currentDevice , emulatedAndroidMobile ) ; assert . deepStrictEqual ( dm . labelForDevice ( dm . currentDevice ! ) , androidEmulator . name ) ; } ) ; it ( "s" , async ( ) => { assert . equal ( dm . currentDevice , undefined ) ; await daemon . connect ( emulatediOSMobile , true ) ; assert . deepStrictEqual ( dm . currentDevice , emulatediOSMobile ) ; assert . deepStrictEqual ( dm . labelForDevice ( dm . currentDevice ! ) , emulatediOSMobile . name ) ; } ) ; it ( "s" , async ( ) => { assert . equal ( dm . currentDevice , undefined ) ; await daemon . connect ( physicalAndroidMobile , false ) ; assert . deepStrictEqual ( dm . currentDevice , physicalAndroidMobile ) ; } ) ; it ( "s" , async ( ) => { daemon . supportedPlatforms = [ "s" ] ; assert . equal ( dm . currentDevice , undefined ) ; await daemon . connect ( physicalAndroidMobile , false ) ; assert . deepStrictEqual ( dm . currentDevice , undefined ) ; } ) ; it ( "s" , async ( ) => { assert . equal ( dm . currentDevice , undefined ) ; await daemon . connect ( emulatedAndroidMobile , true ) ; await daemon . connect ( physicalAndroidMobile , true ) ; assert . deepStrictEqual ( dm . currentDevice , physicalAndroidMobile ) ; await daemon . disconnect ( physicalAndroidMobile ) ; assert . deepStrictEqual ( dm . currentDevice , emulatedAndroidMobile ) ; await daemon . disconnect ( emulatedAndroidMobile ) ; assert . deepStrictEqual ( dm . currentDevice , undefined ) ; } ) ; it ( "s" , async ( ) => { assert . deepStrictEqual ( dm . currentDevice , undefined ) ; await daemon . connect ( desktop , true ) ; assert . deepStrictEqual ( dm . currentDevice , desktop ) ; } ) ; it ( "s" , async ( ) => { daemon . supportedPlatforms = [ "s" ] ; assert . deepStrictEqual ( dm . currentDevice , undefined ) ; await daemon . connect ( desktop , false ) ; assert . deepStrictEqual ( dm . currentDevice , undefined ) ; } ) ; it ( "s" , async ( ) => { await daemon . connect ( physicalAndroidMobile , true ) ; assert . deepStrictEqual ( dm . currentDevice , physicalAndroidMobile ) ; await daemon . connect ( desktop , true ) ; assert . deepStrictEqual ( dm . currentDevice , physicalAndroidMobile ) ; } ) ; } ) ; class FakeFlutterDaemon extends FakeStdIOService implements IFlutterDaemon { public capabilities = DaemonCapabilities . empty ; public supportedPlatforms : f . PlatformType [ ] = [ ] ; public async connect ( d : f . Device , markTypeAsValid ) < void > { if ( markTypeAsValid && d . platformType ) this . supportedPlatforms . push ( d . platformType ) ; await this . notify ( this . deviceAddedSubscriptions , d ) ; } public async disconnect ( d : f . Device ) < void > { await this . notify ( this . deviceRemovedSubscriptions , d ) ; } private daemonConnectedSubscriptions : Array < ( notification : f . DaemonConnected ) => void > = [ ] ; private deviceAddedSubscriptions : Array < ( notification : f . Device ) => void > = [ ] ; private deviceRemovedSubscriptions : Array < ( notification : f . Device ) => void > = [ ] ; private daemonLogMessageSubscriptions : Array < ( notification : f . DaemonLogMessage ) => void > = [ ] ; private daemonLogSubscriptions : Array < ( notification : f . DaemonLog ) => void > = [ ] ; private daemonShowMessageSubscriptions : Array < ( notification : f . ShowMessage ) => void > = [ ] ; public deviceEnable ( ) < UnknownResponse > { throw new Error ( "s" ) ; } public async getEmulators ( ) < f . Emulator [ ] > { return [ androidEmulator ] ; } public launchEmulator ( emulatorId ) < void > { throw new Error ( "s" ) ; } public createEmulator ( name ? ) < { success : boolean ; emulatorName : string ; error : string ; } > { throw new Error ( "s" ) ; } public async getSupportedPlatforms ( projectRoot ) < f . SupportedPlatformsResponse > { if ( ! projectRoot ) throw new Error ( "s" ) ; return { platforms : this . supportedPlatforms } ; } public registerForDaemonConnected ( subscriber : ( notification : f . DaemonConnected ) => void ) { return this . subscribe ( this . daemonConnectedSubscriptions , subscriber ) ; } public registerForDeviceAdded ( subscriber : ( notification : f . Device ) => void ) { return this . subscribe ( this . deviceAddedSubscriptions , subscriber ) ; } public registerForDeviceRemoved ( subscriber : ( notification : f . Device ) => void ) { return this . subscribe ( this . deviceRemovedSubscriptions , subscriber ) ; } public registerForDaemonLogMessage ( subscriber : ( notification : f . DaemonLogMessage ) => void ) { return this . subscribe ( this . daemonLogMessageSubscriptions , subscriber ) ; } public registerForDaemonLog ( subscriber : ( notification : f . DaemonLog ) => void ) { return this . subscribe ( this . daemonLogSubscriptions , subscriber ) ; } public registerForDaemonShowMessage ( subscriber : ( notification : f . ShowMessage ) => void ) { return this . subscribe ( this . daemonShowMessageSubscriptions , subscriber ) ; } } const desktop : f . Device = { category : "s" , emulator : false , emulatorId : undefined , ephemeral : false , id : "s" , name : "s" , platform : "s" , platformType : "s" , type : "s" , } ; const physicalAndroidMobile : f . Device = { category : "s" , emulator : false , emulatorId : undefined , ephemeral : true , id : "s" , name : "s" , platform : "s" , platformType : "s" , type : "s" , } ; const emulatedAndroidMobile : f . Device = { category : "s" , emulator : true , emulatorId : "s" , ephemeral : true , id : "s" , name : "s" , platform : "s" , platformType : "s" , type : "s" , } ; const androidEmulator : f . Emulator = { category : "s" , id : "s" , name : "s" , platformType : "s" , type : "s" , } ; const physicaliOSMobile : f . Device = { category : "s" , emulator : false , emulatorId : undefined , ephemeral : true , id : "s" , name : "s" , platform : "s" , platformType : "s" , type : "s" , } ; const emulatediOSMobile : f . Device = { category : "s" , emulator : true , emulatorId : "s" , ephemeral : true , id : "s" , name : "s" , platform : "s" , platformType : "s" , type : "s" , } ; const iOSEmulator : f . Emulator = { category : "s" , id : "s" , name : "s" , platformType : "s" , type : "s" , } ;	O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Logger$ O O O O O O $any$ O O O O $any$ O O O O O O O O $FlutterDeviceManager$ O O $FakeFlutterDaemon$ O $any$ O O O O O $FakeFlutterDaemon$ O O $any$ O O O $FlutterDeviceManager$ O O $any$ O $Logger$ O $FakeFlutterDaemon$ O O O O O O O $any$ O O O O O $FlutterDeviceManager$ O $void$ O O O $FakeFlutterDaemon$ O $void$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $undefined$ O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $Device$ O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $Device$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $undefined$ O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $Device$ O O $any$ O $any$ O $FlutterDeviceManager$ O $string$ O $FlutterDeviceManager$ O $Device$ O O O $Emulator$ O $string$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $undefined$ O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $Device$ O O $any$ O $any$ O $FlutterDeviceManager$ O $string$ O $FlutterDeviceManager$ O $Device$ O O O $Device$ O $string$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $undefined$ O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $Device$ O O O O O $any$ O O O O O O O O $FakeFlutterDaemon$ O $string[]$ O O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $undefined$ O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $undefined$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $undefined$ O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $Device$ O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $Device$ O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $undefined$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $undefined$ O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $Device$ O O O O O $any$ O O O O O O O O $FakeFlutterDaemon$ O $string[]$ O O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $undefined$ O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $undefined$ O O O O O $any$ O O O O O O O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $Device$ O O O $FakeFlutterDaemon$ O $Promise<void>$ O $Device$ O O O O $any$ O $any$ O $FlutterDeviceManager$ O $Device$ O $Device$ O O O O O O O O O $any$ O $any$ O $any$ O O $DaemonCapabilities$ O $any$ O $DaemonCapabilities$ O O $string[]$ O $any$ O $any$ O O O O O O O O $Promise$ O $Device$ O $any$ O $any$ O $boolean$ O O O O O O O $boolean$ O $Device$ O $string$ O O O $string[]$ O $number$ O $Device$ O $string$ O O O O O $Promise<void>$ O O O $void)[]$ O $Device$ O O O O O $Promise$ O $Device$ O $any$ O $any$ O O O O O O O O $Promise<void>$ O O O $void)[]$ O $Device$ O O O O $void)[]$ O $ArrayConstructor$ O O $DaemonConnected$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $Device$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $Device$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $DaemonLogMessage$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $DaemonLog$ O $any$ O $any$ O O O O O O O O O $void)[]$ O $ArrayConstructor$ O O $ShowMessage$ O $any$ O $any$ O O O O O O O O O $Thenable$ O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $Promise$ O O O $any$ O $any$ O O O O O O $Emulator$ O O O O $Thenable$ O $string$ O O O O O O O $ErrorConstructor$ O O O O O O $Thenable$ O $string$ $string$ O O O $boolean$ O O O $string$ O O O $string$ O O O O O O O O $ErrorConstructor$ O O O O O O O $Promise$ O $string$ O O $any$ O $any$ O O O O O $string$ O O O $ErrorConstructor$ O O O O O O $string[]$ O O O $string[]$ O O O O $IAmDisposable$ O $void$ O O $DaemonConnected$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $Device$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $Device$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $DaemonLogMessage$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $DaemonLog$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O $IAmDisposable$ O $void$ O O $ShowMessage$ O $any$ O $any$ O O O O O O O O $IAmDisposable$ O O O $void)[]$ O $void$ O O O O O $Device$ O $any$ O $any$ O O $string$ O O O $false$ O O O $undefined$ O $undefined$ O $false$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $Device$ O $any$ O $any$ O O $string$ O O O $false$ O O O $undefined$ O $undefined$ O $true$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $Device$ O $any$ O $any$ O O $string$ O O O $true$ O O O $string$ O O O $true$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $Emulator$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $Device$ O $any$ O $any$ O O $string$ O O O $false$ O O O $undefined$ O $undefined$ O $true$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $Device$ O $any$ O $any$ O O $string$ O O O $true$ O O O $string$ O O O $true$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O $Emulator$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { Sdks } from "s" ; import { fsPath } from "s" ; import { activateWithoutAnalysis , ext , extApi , logger } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const wfs = vs . workspace . workspaceFolders || [ ] ; assert . equal ( wfs . length , 0 ) ; assert . ok ( fsPath ( wfs [ 0 ] . uri ) . endsWith ( path . sep + "s" ) , `template` , ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . equal ( ext . isActive , true ) ; } ) ; it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . ok ( extApi ) ; const sdks = extApi . workspaceContext . sdks ; assert . ok ( sdks ) ; assert . ok ( sdks . dart ) ; assert . ok ( sdks . flutter ) ; logger . info ( "s" + JSON . stringify ( sdks , undefined , 0 ) . trim ( ) . slice ( 0 , - 0 ) . trim ( ) ) ; logger . info ( `template` ) ; } ) ; it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . ok ( extApi ) ; const sdks = extApi . workspaceContext . sdks ; assert . ok ( sdks ) ; assert . ok ( sdks . dart ) ; assert . equal ( sdks . dartSdkIsFromFlutter , true ) ; assert . notEqual ( sdks . dart ! . indexOf ( "s" ) , - 0 ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O O O O O O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $Logger$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $boolean$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $InternalExtensionApi$ O O O $Sdks$ O $InternalExtensionApi$ O $WorkspaceContext$ O $Sdks$ O $any$ O $any$ O $Sdks$ O O $any$ O $any$ O $Sdks$ O $string$ O O $any$ O $any$ O $Sdks$ O $string$ O O $Logger$ O $void$ O O O $JSON$ O $complex$ O $Sdks$ O $undefined$ O O O O $string$ O O O $string$ O O O O O O O $string$ O O O O $Logger$ O $void$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $InternalExtensionApi$ O O O $Sdks$ O $InternalExtensionApi$ O $WorkspaceContext$ O $Sdks$ O $any$ O $any$ O $Sdks$ O O $any$ O $any$ O $Sdks$ O $string$ O O $any$ O $any$ O $Sdks$ O $boolean$ O O O O $any$ O $any$ O $Sdks$ O $string$ O O $number$ O O O O O O O O O O O O O O
import * as test_runner from "s" ; module . exports = test_runner ;	O O O $any$ O O O $any$ O $any$ O $any$ O
import * as assert from "s" ; import * as vs from "s" ; import { activate , ensureCompletion , extApi , flutterHelloWorldMainFile , getCompletionsAt , getPackages , openFile , setTestContent } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , ( ) => activate ( undefined ) ) ; it ( "s" , async ( ) => { await openFile ( flutterHelloWorldMainFile ) ; const completions = await getCompletionsAt ( "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Constructor , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Constructor , "s" , "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Constructor , "s" , "s" ) ; } ) ; describe ( "s" , ( ) => { beforeEach ( "s" , function ( ) { if ( ! extApi . analyzerCapabilities . supportsAvailableSuggestions ) this . skip ( ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( `template` ) ; const completions = await getCompletionsAt ( "s" ) ; const edgeInsetsCompletions = completions . filter ( ( c ) => c . label === "s" ) ; assert . equal ( edgeInsetsCompletions . length >= 0 , true ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . analyzerCapabilities . supportsIncludedImports ) { this . skip ( ) ; return ; } await setTestContent ( `template` ) ; const completions = await getCompletionsAt ( "s" ) ; const edgeInsetsCompletions = completions . filter ( ( c ) => c . label === "s" ) ; assert . equal ( edgeInsetsCompletions . length , 0 ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . analyzerCapabilities . supportsIncludedImports ) { this . skip ( ) ; return ; } await setTestContent ( `template` ) ; const completions = await getCompletionsAt ( "s" ) ; const clipCompletion = completions . filter ( ( c ) => c . label === "s" ) ; assert . equal ( clipCompletion . length , 0 ) ; } ) ; it . skip ( "s" , async ( ) => { await setTestContent ( `template` ) ; const count = 0 ; const startMemory = process . memoryUsage ( ) ; const startTime = Date . now ( ) ; for ( let i = 0 ; i < count ; i ++ ) { const startMemoryInner = process . memoryUsage ( ) ; const startTimeInner = Date . now ( ) ; const completions = await getCompletionsAt ( "s" ) ; ensureCompletion ( completions , vs . CompletionItemKind . Class , "s" , "s" ) ; const heapChangeMbs = ( process . memoryUsage ( ) . heapUsed - startMemoryInner . heapUsed ) / 0 / 0 ; console . log ( `template` ) ; } const heapChangeMbs = ( process . memoryUsage ( ) . heapUsed - startMemory . heapUsed ) / 0 / 0 ; console . log ( `template` ) ; } ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $any$ O $Promise<any[]>$ O $Promise<void>$ O $Promise<any>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O $Promise<void>$ O $undefined$ O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any[]$ O O $Promise<any[]>$ O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O $InternalExtensionApi$ O O O $boolean$ O O O $any$ O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O O $any[]$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any[]$ O $number$ O O O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O O O $boolean$ O O O O $any$ O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O O $any[]$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any[]$ O $number$ O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O O O $boolean$ O O O O $any$ O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O O $any[]$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any[]$ O $number$ O O O O O O O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O $number$ O $DateConstructor$ O $number$ O O O O O O $number$ O O O $number$ O O O $number$ O O O O $any$ O $any$ O $any$ O O O O $number$ O $DateConstructor$ O $number$ O O O O $any[]$ O O $Promise<any[]>$ O O O O $any$ O $any[]$ O $any$ O $any$ O $any$ O O O O O O O $number$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $Console$ O $void$ O O O O O O $number$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $Console$ O $void$ O O O O O O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { activate , ensureDocumentSymbol , flutterHelloWorldMainFile , getDocumentSymbols , getPackages } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , ( ) => activate ( flutterHelloWorldMainFile ) ) ; it ( "s" , async ( ) => { const symbols = await getDocumentSymbols ( ) ; assert . ok ( symbols && symbols . length , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Function ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Class ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Method , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Class ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Constructor , "s" ) ; ensureDocumentSymbol ( symbols , "s" , vs . SymbolKind . Method , "s" ) ; assert . equal ( symbols . length , 0 ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $void$ O $any$ O $Promise<any[]>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O $any$ O O O O O O O O O $any[]$ O O $Promise<any[]>$ O O O $any$ O $any$ O $any[]$ O $any[]$ O $number$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $void$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any[]$ O $number$ O O O O O O O O O O
import * as assert from "s" ; import * as vs from "s" ; import { activate , currentDoc , flutterEmptyFile , getPackages , rangeOf , setTestContent } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , async ( ) => { await activate ( flutterEmptyFile ) ; await setTestContent ( `template` ) ; } ) ; it ( "s" , async ( ) => { const fixResults = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , rangeOf ( "s" ) ) as Thenable < vs . CodeAction [ ] > ) ; assert . ok ( fixResults ) ; assert . ok ( fixResults . length ) ; assert . ok ( fixResults . find ( ( r ) => r . title . indexOf ( "s" ) !== - 0 ) ) ; } ) ; it ( "s" , async ( ) => { const fixResults = await ( vs . commands . executeCommand ( "s" , currentDoc ( ) . uri , rangeOf ( "s" ) ) as Thenable < vs . CodeAction [ ] > ) ; assert . ok ( fixResults ) ; assert . ok ( fixResults . length ) ; fixResults . forEach ( ( 0 , index ) => { fixResults . slice ( index + 0 ) . forEach ( ( 0 ) => { assert . notDeepEqual ( 0 , 0 ) ; } ) ; } ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O $any$ O $any$ O $Promise<void>$ O $complex$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O $any$ O O O $Promise<void>$ O O O O O O O $any$ O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $complex$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O
import { activate , ensureNoSnippet , ensureSnippet , flutterEmptyFile , getSnippetCompletionsAt , setTestContent } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( flutterEmptyFile ) ) ; it ( "s" , async ( ) => { await setTestContent ( "s" ) ; const snippets = await getSnippetCompletionsAt ( "s" ) ; ensureSnippet ( snippets , "s" , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( "s" ) ; const snippets = await getSnippetCompletionsAt ( "s" ) ; ensureSnippet ( snippets , "s" , "s" ) ; } ) ; it ( "s" , async ( ) => { await setTestContent ( "s" ) ; const snippets = await getSnippetCompletionsAt ( "s" ) ; ensureNoSnippet ( snippets , "s" ) ; } ) ; } ) ;	O O $Promise<void>$ O $void$ O $void$ O $any$ O $Promise<any[]>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any[]$ O O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O O O
import * as assert from "s" ; import * as sinon from "s" ; import * as vs from "s" ; import { REFACTOR_ANYWAY , REFACTOR_FAILED_DOC_MODIFIED } from "s" ; import { PromiseCompleter } from "s" ; import { activate , currentDoc , ensureTestContent , rangeOf , sb , setTestContent , waitForResult } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( "s" ) ; await setTestContent ( `template` ) ; await ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( "s" ) , "s" ) ) ; await ensureTestContent ( `template` ) ; } ) ; it ( "s" , async ( ) => { const showErrorMessage = sb . stub ( vs . window , "s" ) ; await setTestContent ( `template` ) ; await ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( "s" ) , "s" ) ) ; await ensureTestContent ( `template` ) ; assert ( showErrorMessage . calledOnce ) ; } ) ; it ( "s" , async ( ) => { const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( "s" ) ; const showErrorMessage = sb . stub ( vs . window , "s" ) ; await setTestContent ( `template` ) ; await ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( "s" ) , "s" ) ) ; await ensureTestContent ( `template` ) ; assert ( showErrorMessage . calledOnce ) ; } ) ; it ( "s" , async ( ) => { const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( "s" ) ; const showErrorMessage = sb . stub ( vs . window , "s" ) ; const refactorPrompt = showErrorMessage . withArgs ( sinon . match . any , REFACTOR_ANYWAY ) . resolves ( ) ; await setTestContent ( `template` ) ; await ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( "s" ) , "s" ) ) ; await ensureTestContent ( `template` ) ; assert ( refactorPrompt . calledOnce ) ; } ) ; it ( "s" , async ( ) => { const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( "s" ) ; const showErrorMessage = sb . stub ( vs . window , "s" ) . callThrough ( ) ; const refactorPrompt = showErrorMessage . withArgs ( sinon . match . any , REFACTOR_ANYWAY ) . resolves ( REFACTOR_ANYWAY ) ; await setTestContent ( `template` ) ; await ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( "s" ) , "s" ) ) ; await ensureTestContent ( `template` ) ; assert ( refactorPrompt . calledOnce ) ; } ) ; it ( "s" , async ( ) => { const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( "s" ) ; const showErrorMessage = sb . stub ( vs . window , "s" ) . callThrough ( ) ; const refactorAnywayChoice = new PromiseCompleter ( ) ; const refactorPrompt = showErrorMessage . withArgs ( sinon . match . any , REFACTOR_ANYWAY ) . returns ( refactorAnywayChoice . promise ) ; const rejectMessage = showErrorMessage . withArgs ( REFACTOR_FAILED_DOC_MODIFIED ) . resolves ( ) ; await setTestContent ( `template` ) ; const refactorCommand = ( vs . commands . executeCommand ( "s" , currentDoc ( ) , rangeOf ( "s" ) , "s" ) ) ; await waitForResult ( ( ) => refactorPrompt . called ) ; await setTestContent ( `template` ) ; refactorAnywayChoice . resolve ( REFACTOR_ANYWAY ) ; await refactorCommand ; await ensureTestContent ( `template` ) ; assert ( rejectMessage . calledOnce , "s" ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O $Promise<void>$ O $complex$ O $any$ O $Promise<void>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $Promise<void>$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $PromiseCompleter<unknown>$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $PromiseCompleter<unknown>$ O $Promise<unknown>$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $Promise<void>$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O O O $Promise<void>$ O O O O $PromiseCompleter<unknown>$ O $void$ O O O O O $any$ O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O
import * as assert from "s" ; import { TestOutlineVisitor } from "s" ; import { activate , extApi , flutterTestOtherFile , getPackages , logger , waitForResult } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; beforeEach ( "s" , async ( ) => { await activate ( flutterTestOtherFile ) ; await waitForResult ( ( ) => ! ! extApi . fileTracker . getOutlineFor ( flutterTestOtherFile ) ) ; } ) ; it ( "s" , function ( ) { if ( ! extApi . flutterCapabilities . hasTestGroupFix ) { this . skip ( ) ; return ; } const outline = extApi . fileTracker . getOutlineFor ( flutterTestOtherFile ) ; const visitor = new TestOutlineVisitor ( logger ) ; visitor . visit ( outline ! ) ; assert . equal ( visitor . tests . length , 0 ) ; assert . equal ( visitor . tests [ 0 ] . isGroup , true ) ; assert . equal ( visitor . tests [ 0 ] . fullName , "s" ) ; assert . equal ( visitor . tests [ 0 ] . isGroup , false ) ; assert . equal ( visitor . tests [ 0 ] . fullName , "s" ) ; } ) ; } ) ;	O O O $any$ O O O O O $any$ O O O O O O $Promise<void>$ O $InternalExtensionApi$ O $any$ O $Promise<void>$ O $Logger$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $Promise<void>$ O $any$ O O O $Promise<void>$ O O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O O O $any$ O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Outline$ O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O $TestOutlineVisitor$ O O $any$ O $Logger$ O O $TestOutlineVisitor$ O $void$ O $Outline$ O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O $number$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $boolean$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $string$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $boolean$ O O O O $any$ O $any$ O $TestOutlineVisitor$ O $TestOutlineInfo[]$ O O O O $string$ O O O O O O O O O O
import * as assert from "s" ; import { activate , delay , extApi , flutterHelloWorldOutlineFile , getExpectedResults , getPackages , makeTextTree , openFile , waitForResult } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; before ( "s" , ( ) => activate ( ) ) ; it ( "s" , async ( ) => { assert . ok ( extApi . flutterOutlineTreeProvider ) ; await openFile ( flutterHelloWorldOutlineFile ) ; await waitForResult ( ( ) => ! ! extApi . fileTracker . getOutlineFor ( flutterHelloWorldOutlineFile ) ) ; await delay ( 0 ) ; const expectedResults = getExpectedResults ( ) ; const actualResults = ( await makeTextTree ( undefined , extApi . flutterOutlineTreeProvider ! ) ) . join ( "s" ) ; assert . ok ( expectedResults ) ; assert . ok ( actualResults ) ; assert . equal ( actualResults , expectedResults ) ; } ) ; } ) ;	O O O $any$ O O O O O $Promise<void>$ O $Promise<void>$ O $InternalExtensionApi$ O $any$ O $any$ O $Promise<void>$ O $Promise<string[]>$ O $Promise<any>$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O $any$ O $any$ O $InternalExtensionApi$ O $any$ O O O $Promise<any>$ O $any$ O O O $Promise<void>$ O O O O O O $InternalExtensionApi$ O $complex$ O $Outline$ O $any$ O O O O $Promise<void>$ O O O O O $any$ O $any$ O O O O $string$ O O O $Promise<string[]>$ O $undefined$ O $InternalExtensionApi$ O $any$ O O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O $any$ O O O O O O O O
import * as assert from "s" ; import { DART_DEP_PACKAGE_NODE_CONTEXT , DART_DEP_PROJECT_NODE_CONTEXT } from "s" ; import { ensurePackageTreeNode , extApi , getPackages } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( ) ) ; it ( "s" , async ( ) => { const topLevel = await extApi . packagesTreeProvider . getChildren ( undefined ) ; ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" ) ; ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" , "s" ) ; } ) ; it ( "s" , async ( ) => { const topLevel = await extApi . packagesTreeProvider . getChildren ( undefined ) ; const myPackage = ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" ) ; const packages = await extApi . packagesTreeProvider . getChildren ( myPackage ) ; ensurePackageTreeNode ( packages , DART_DEP_PACKAGE_NODE_CONTEXT , "s" ) ; ensurePackageTreeNode ( packages , DART_DEP_PACKAGE_NODE_CONTEXT , "s" ) ; ensurePackageTreeNode ( packages , DART_DEP_PACKAGE_NODE_CONTEXT , "s" ) ; } ) ; it ( "s" , async ( ) => { const topLevel = await extApi . packagesTreeProvider . getChildren ( undefined ) ; const myPackage = ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" ) ; const packages = await extApi . packagesTreeProvider . getChildren ( myPackage ) ; const self = packages ! . find ( ( node ) => node . label === "s" ) ; assert . equal ( self , undefined ) ; } ) ; } ) ;	O O O $any$ O O O O O O O O O O O O O O $any$ O $InternalExtensionApi$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $undefined$ O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { tenMinutesInMs } from "s" ; import { fsPath } from "s" ; import { activate , activateWithoutAnalysis , ext } from "s" ; beforeEach ( "s" , function ( ) { this . timeout ( tenMinutesInMs ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const wfs = vs . workspace . workspaceFolders || [ ] ; assert . equal ( wfs . length , 0 ) ; assert . ok ( fsPath ( wfs [ 0 ] . uri ) . endsWith ( path . sep + "s" ) , `template` , ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . equal ( ext . isActive , true ) ; } ) ; it ( "s" , async ( ) => { await activate ( ) ; function warningOrError ( d : vs . Diagnostic ) { return d . severity <= vs . DiagnosticSeverity . Warning ; } const filesWithErrors = vs . languages . getDiagnostics ( ) . filter ( ( file ) => file [ 0 ] . find ( warningOrError ) ) ; if ( filesWithErrors . length !== 0 ) { assert . equal ( filesWithErrors . length , 0 , `template` + filesWithErrors . slice ( 0 , Math . min ( 0 , filesWithErrors . length ) ) . map ( ( file ) => { return "s" + path . basename ( fsPath ( file [ 0 ] ) ) + "s" + file [ 0 ] . find ( warningOrError ) ! . message ; } ) . join ( "s" ) , ) ; } } ) . timeout ( tenMinutesInMs ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $number$ O O O O O O $string$ O O O O O O $Promise<void>$ O $Promise<void>$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $number$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $boolean$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $boolean$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O $any$ O O O O $any$ O $boolean$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $Math$ O $number$ O O O $any$ O $any$ O O O $any$ O O $any$ O O O O O O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O O O O $any$ O $boolean$ O O O $any$ O O O O $any$ O O O O O O O O O O $any$ O $number$ O O O O O
import * as test_runner from "s" ; module . exports = test_runner ;	O O O $any$ O O O $any$ O $any$ O $any$ O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { isWin } from "s" ; import { FlutterService , FlutterServiceExtension } from "s" ; import { fetch } from "s" ; import { fsPath } from "s" ; import { DartDebugClient } from "s" ; import { ensureVariable , killFlutterTester } from "s" ; import { activate , defer , delay , ext , extApi , flutterWebBrokenMainFile , flutterWebHelloWorldExampleSubFolderMainFile , flutterWebHelloWorldFolder , flutterWebHelloWorldMainFile , getLaunchConfiguration , getPackages , logger , openFile , positionOf , sb , waitForResult , watchPromise } from "s" ; describe ( "s" , ( ) => { beforeEach ( "s" , function ( ) { if ( isWin ) this . skip ( ) ; } ) ; beforeEach ( "s" , ( ) => activate ( flutterWebHelloWorldMainFile ) ) ; before ( "s" , ( ) => getPackages ( flutterWebHelloWorldMainFile ) ) ; before ( "s" , ( ) => getPackages ( flutterWebBrokenMainFile ) ) ; let dc ; beforeEach ( "s" , ( ) => { dc = new DartDebugClient ( process . execPath , path . join ( ext . extensionPath , "s" ) , "s" , undefined , extApi . debugCommands , undefined ) ; dc . defaultTimeout = 0 ; const thisDc = dc ; defer ( ( ) => thisDc . stop ( ) ) ; } ) ; afterEach ( ( ) => watchPromise ( "s" , killFlutterTester ( ) ) ) ; async function startDebugger ( script ? : vs . Uri | string , cwd ? ) < vs . DebugConfiguration > { const config = await getLaunchConfiguration ( script , { cwd , deviceId : "s" , } ) ; if ( ! config ) throw new Error ( `template` ) ; await watchPromise ( "s" , dc . start ( config . debugServer ) ) ; return config ; } it ( "s" , async ( ) => { const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; await Promise . all ( [ dc . assertOutputContains ( "s" , "s" ) , dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await delay ( 0 ) ; await dc . threadsRequest ( ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotReload ) === false ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotRestart ) === true ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotReload ) === false ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotRestart ) === false ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; config . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotReload ) === false ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotRestart ) === true ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotReload ) === false ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceIsRegistered ( FlutterService . HotRestart ) === false ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugPaint ) === true ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugBanner ) === true ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugPaint ) === false ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugBanner ) === false ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; config . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugPaint ) === true ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugBanner ) === true ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugPaint ) === false ) ; await waitForResult ( ( ) => extApi . debugCommands . flutterExtensions . serviceExtensionIsLoaded ( FlutterServiceExtension . DebugBanner ) === false ) ; } ) ; it . skip ( "s" , async ( ) => { const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await delay ( 0 ) ; await Promise . race ( [ Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) , new Promise ( ( resolve , reject ) => setTimeout ( ( ) => reject ( new Error ( "s" ) ) , 0 ) ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; config . program = path . relative ( fsPath ( flutterWebHelloWorldFolder ) , fsPath ( flutterWebHelloWorldMainFile ) ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await delay ( 0 ) ; await dc . threadsRequest ( ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) . timeout ( 0 ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterWebHelloWorldMainFile , "s" ) ; config . program = path . relative ( fsPath ( flutterWebHelloWorldFolder ) , fsPath ( flutterWebHelloWorldMainFile ) ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , ] ) ; await delay ( 0 ) ; await dc . threadsRequest ( ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it . skip ( "s" , async ( ) => { const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; await Promise . all ( [ watchPromise ( "s" , dc . configurationSequence ( ) ) , watchPromise ( "s" , dc . launch ( config ) ) , dc . waitForEvent ( "s" ) , ] ) ; await watchPromise ( "s" , dc . hotReload ( ) ) ; await Promise . all ( [ watchPromise ( "s" , dc . waitForEvent ( "s" ) ) , watchPromise ( "s" , dc . terminateRequest ( ) ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , dc . waitForEvent ( "s" ) , ] ) ; await delay ( 0 ) ; await Promise . all ( [ dc . assertOutputContains ( "s" , "s" ) , dc . customRequest ( "s" ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it . skip ( "s" , async ( ) => { await openFile ( flutterWebHelloWorldExampleSubFolderMainFile ) ; const config = await startDebugger ( ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , dc . waitForEvent ( "s" ) , ] ) ; await delay ( 0 ) ; await Promise . all ( [ dc . assertOutputContains ( "s" , "s" ) , dc . customRequest ( "s" ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it . skip ( "s" , async ( ) => { const config = await startDebugger ( undefined , "s" ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . launch ( config ) , dc . waitForEvent ( "s" ) , ] ) ; await delay ( 0 ) ; await Promise . all ( [ dc . assertOutputContains ( "s" , "s" ) , dc . customRequest ( "s" ) , ] ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . flutterCapabilities . supportsDevTools ) { this . skip ( ) ; return ; } const openBrowserCommand = sb . stub ( extApi . envUtils , "s" ) . resolves ( ) ; const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; await Promise . all ( [ watchPromise ( "s" , dc . configurationSequence ( ) ) , watchPromise ( "s" , dc . launch ( config ) ) , ] ) ; logger . info ( "s" ) ; const devTools = await vs . commands . executeCommand ( "s" ) as { url : string , dispose : ( ) => void } ; assert . ok ( openBrowserCommand . calledOnce ) ; assert . ok ( devTools ) ; assert . ok ( devTools . url ) ; defer ( devTools . dispose ) ; const serverResponse = await fetch ( devTools . url ) ; assert . notEqual ( serverResponse . indexOf ( "s" ) , - 0 ) ; await Promise . all ( [ dc . waitForEvent ( "s" ) , dc . terminateRequest ( ) , ] ) ; } ) ; [ 0 , 0 , 0 ] . forEach ( ( numReloads ) => { const reloadDescription = numReloads === 0 ? "s" : `template` ; it ( "s" + reloadDescription , async function ( ) { if ( ! extApi . flutterCapabilities . webSupportsDebugging ) { this . skip ( ) ; return ; } await openFile ( flutterWebHelloWorldMainFile ) ; const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; const expectedLocation = { line : positionOf ( "s" ) . line , path : fsPath ( flutterWebHelloWorldMainFile ) , } ; await watchPromise ( "s" , dc . hitBreakpoint ( config , expectedLocation ) ) ; const stack = await dc . getStack ( ) ; const frames = stack . body . stackFrames ; assert . equal ( frames [ 0 ] . name , "s" ) ; assert . equal ( frames [ 0 ] . source ! . path , expectedLocation . path ) ; assert . equal ( frames [ 0 ] . source ! . name , "s" ) ; await watchPromise ( "s" , dc . resume ( ) ) ; await dc . setBreakpointsRequest ( { breakpoints : [ { line : 0 } , expectedLocation ] , source : { path : fsPath ( flutterWebHelloWorldMainFile ) } , } ) ; for ( let i = 0 ; i < numReloads ; i ++ ) { await delay ( 0 ) ; await Promise . all ( [ watchPromise ( `template` , dc . assertStoppedLocation ( "s" , expectedLocation ) ) . then ( async ( _ ) => { const stack = await watchPromise ( `template` , dc . getStack ( ) ) ; const frames = stack . body . stackFrames ; assert . equal ( frames [ 0 ] . name , "s" ) ; assert . equal ( frames [ 0 ] . source ! . path , expectedLocation . path ) ; assert . equal ( frames [ 0 ] . source ! . name , "s" ) ; } ) . then ( ( _ ) => watchPromise ( `template` , dc . resume ( ) ) ) , watchPromise ( `template` , dc . hotReload ( ) ) , ] ) ; } } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async function ( ) { if ( ! extApi . flutterCapabilities . webSupportsDebugging ) { this . skip ( ) ; return ; } await openFile ( flutterWebHelloWorldMainFile ) ; const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; await Promise . all ( [ dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( flutterWebHelloWorldMainFile ) , } ) , ] ) ; const evaluateResult = await dc . evaluate ( `template` ) ; assert . ok ( evaluateResult ) ; assert . equal ( evaluateResult . result , `template` ) ; assert . equal ( evaluateResult . variablesReference , 0 ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . flutterCapabilities . webSupportsDebugging ) { this . skip ( ) ; return ; } await openFile ( flutterWebHelloWorldMainFile ) ; const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; await Promise . all ( [ dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( flutterWebHelloWorldMainFile ) , } ) , ] ) ; const evaluateResult = await dc . evaluate ( `template` ) ; assert . ok ( evaluateResult ) ; assert . equal ( evaluateResult . result , ( new Date ( ) ) . getFullYear ( ) ) ; assert . equal ( evaluateResult . variablesReference , 0 ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . flutterCapabilities . webSupportsDebugging ) { this . skip ( ) ; return ; } await openFile ( flutterWebHelloWorldMainFile ) ; const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; await Promise . all ( [ dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( flutterWebHelloWorldMainFile ) , } ) , ] ) ; const evaluateResult = await dc . evaluate ( `template` ) ; const thisYear = new Date ( ) . getFullYear ( ) . toString ( ) ; assert . ok ( evaluateResult ) ; assert . ok ( evaluateResult . result . startsWith ( "s" + thisYear ) , `template` ) ; assert . ok ( evaluateResult . variablesReference ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . flutterCapabilities . webSupportsDebugging ) { this . skip ( ) ; return ; } await openFile ( flutterWebHelloWorldMainFile ) ; const config = await startDebugger ( flutterWebHelloWorldMainFile ) ; await Promise . all ( [ dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line , path : fsPath ( flutterWebHelloWorldMainFile ) , } ) , ] ) ; const evaluateResult = await dc . evaluate ( `template` ) ; assert . ok ( evaluateResult ) ; assert . equal ( evaluateResult . result , ( new Date ( ) ) . getFullYear ( ) ) ; assert . equal ( evaluateResult . variablesReference , 0 ) ; } ) ; } ) ; it . skip ( "s" , async function ( ) { if ( ! extApi . flutterCapabilities . webSupportsDebugging ) { this . skip ( ) ; return ; } await openFile ( flutterWebBrokenMainFile ) ; const config = await startDebugger ( flutterWebBrokenMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( flutterWebBrokenMainFile ) , } ) , dc . launch ( config ) , ] ) ; } ) ; it . skip ( "s" , async function ( ) { if ( ! extApi . flutterCapabilities . webSupportsDebugging ) { this . skip ( ) ; return ; } await openFile ( flutterWebBrokenMainFile ) ; const config = await startDebugger ( flutterWebBrokenMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( flutterWebBrokenMainFile ) , } ) , dc . launch ( config ) , ] ) ; const variables = await dc . getTopFrameVariables ( "s" ) ; ensureVariable ( variables , "s" , "s" , `template` ) ; } ) ; it ( "s" , async function ( ) { if ( ! extApi . flutterCapabilities . webSupportsDebugging ) { this . skip ( ) ; return ; } await openFile ( flutterWebHelloWorldMainFile ) ; const config = await watchPromise ( "s" , startDebugger ( flutterWebHelloWorldMainFile ) ) ; await Promise . all ( [ watchPromise ( "s" , dc . waitForEvent ( "s" ) ) . then ( ( event ) => { return watchPromise ( "s" , dc . setBreakpointsRequest ( { breakpoints : [ { line : positionOf ( "s" ) . line , logMessage : "s" , } ] , source : { path : fsPath ( flutterWebHelloWorldMainFile ) } , } ) ) ; } ) . then ( ( response ) => watchPromise ( "s" , dc . configurationDoneRequest ( ) ) ) , watchPromise ( "s" , dc . assertOutputContains ( "s" , `template` ) ) , watchPromise ( "s" , dc . launch ( config ) ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterWebBrokenMainFile ) ; const config = await startDebugger ( flutterWebBrokenMainFile ) ; await Promise . all ( [ watchPromise ( "s" , dc . configurationSequence ( ) ) , watchPromise ( "s" , dc . assertOutputContains ( "s" , "s" ) ) , watchPromise ( "s" , dc . launch ( config ) ) , ] ) ; } ) ; it . skip ( "s" , async ( ) => { await openFile ( flutterWebBrokenMainFile ) ; const config = await startDebugger ( flutterWebBrokenMainFile ) ; await Promise . all ( [ watchPromise ( "s" , dc . configurationSequence ( ) ) , watchPromise ( "s" , dc . assertOutputContains ( "s" , "s" ) . then ( ( event ) => { assert . equal ( event . body . output . indexOf ( "s" ) , - 0 ) ; assert . equal ( event . body . source ! . name , "s" ) ; assert . equal ( event . body . source ! . path , fsPath ( flutterWebBrokenMainFile ) ) ; assert . equal ( event . body . line , positionOf ( "s" ) . line + 0 ) ; assert . equal ( event . body . column , 0 ) ; } ) , ) , watchPromise ( "s" , dc . launch ( config ) ) , ] ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O O $Promise<string>$ O O O O O O $string$ O O O O O O $any$ O O O O O O $void$ O $Promise<void>$ O O O O O O $Promise<void>$ O $void$ O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $any$ O $any$ O $any$ O $any$ O $Promise<any>$ O $Promise<void>$ O $Logger$ O $Promise<any>$ O $any$ O $any$ O $Promise<void>$ O $Promise<T>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $boolean$ O O O $any$ O O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O O $DartDebugClient$ O $any$ O O O O O O O $DartDebugClient$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $undefined$ O $InternalExtensionApi$ O $DebugCommandHandler$ O $undefined$ O O $DartDebugClient$ O $number$ O O O O $DartDebugClient$ O $DartDebugClient$ O $void$ O O O O $DartDebugClient$ O $Promise<void>$ O O O O O O O $any$ O O O O $Promise<T>$ O O O $Promise<void>$ O O O O O O O $Promise$ O $any$ O O $any$ O $any$ O O O $string$ $string$ O O $any$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $string$ O $string$ O O O O O O O O O $any$ O O O $ErrorConstructor$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotReload$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotRestart$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotReload$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotRestart$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotReload$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotRestart$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotReload$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterService.HotRestart$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugPaint$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugBanner$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugPaint$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugBanner$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugPaint$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugBanner$ O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugPaint$ O O O O O O $Promise<void>$ O O O O $InternalExtensionApi$ O $DebugCommandHandler$ O $complex$ O $boolean$ O $any$ O $FlutterServiceExtension.DebugBanner$ O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O $complex$ O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $PromiseConstructor$ O O $void$ O $void$ O O $number$ O O O O $void$ O O $ErrorConstructor$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $string$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $string$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Promise<void>$ O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $undefined$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $InternalExtensionApi$ O $complex$ O O O O $any$ O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $Logger$ O $void$ O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O $string$ O O O $void$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O O $void$ O $complex$ O $void$ O O O $string$ O O $Promise<string>$ O $complex$ O $string$ O O $any$ O $any$ O $string$ O $number$ O O O O O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O O O O O O O O O $void$ O O $number$ O O O O $string$ O $number$ O O O O O O O $any$ O O O $string$ O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $complex$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O $complex$ O O O O $any$ O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O $DartDebugClient$ O $Promise<any>$ O O $complex$ O O O $number$ O O O O $complex$ O O $complex$ O O $string$ O $string$ O $any$ O O O O O O O O O $number$ O O O $number$ O $number$ O $number$ O O O O $Promise<void>$ O O O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O $complex$ O O O O O O O $any$ O O O O $any$ O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O O $void$ O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O O O O $complex$ O O $DartDebugClient$ O $complex$ O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O O O O $any$ O $any$ O $complex$ O $number$ O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O O O O $complex$ O O $DartDebugClient$ O $complex$ O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O O O $DateConstructor$ O O O O $number$ O O O O $any$ O $any$ O $complex$ O $number$ O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O O O O $complex$ O O $DartDebugClient$ O $complex$ O O O O O $string$ O O $DateConstructor$ O O O $number$ O O O $string$ O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O $boolean$ O O O $string$ O O O O O $any$ O $any$ O $complex$ O $number$ O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O $string$ O $any$ O O O O O O O O O $complex$ O O $DartDebugClient$ O $complex$ O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $complex$ O $string$ O O O $DateConstructor$ O O O O $number$ O O O O $any$ O $any$ O $complex$ O $number$ O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O $void$ O $any[]$ O O O O O O O O O O O $any$ O O O O O O O O O O O $InternalExtensionApi$ O $complex$ O $boolean$ O O O O $any$ O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<T>$ O O O $Promise<any>$ O $any$ O O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O $any$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O $complex$ O O O $any$ O $any$ O O O O $any$ O $string$ O O O O O O $complex$ O O $string$ O $string$ O $any$ O O O O O O O O O O O O O $any$ O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $string$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $Promise<T>$ O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { DebugProtocol } from "s" ; import { fsPath } from "s" ; import { DartDebugClient } from "s" ; import { killFlutterTester } from "s" ; import { activate , defer , delay , ext , extApi , flutterWebHelloWorldFolder , flutterWebTestBrokenFile , flutterWebTestMainFile , flutterWebTestOtherFile , getLaunchConfiguration , logger , openFile , positionOf , withTimeout } from "s" ; describe . skip ( "s" , ( ) => { beforeEach ( "s" , async ( ) => { await activate ( flutterWebTestMainFile ) ; } ) ; let dc ; beforeEach ( "s" , ( ) => { dc = new DartDebugClient ( process . execPath , path . join ( ext . extensionPath , "s" ) , "s" , undefined , extApi . debugCommands , extApi . testTreeProvider , ) ; dc . defaultTimeout = 0 ; const thisDc = dc ; defer ( ( ) => withTimeout ( Promise . all ( [ thisDc . terminateRequest ( ) . catch ( ( e ) => logger . error ( e ) ) , delay ( 0 ) . then ( ( ) => thisDc . stop ( ) ) . catch ( ( e ) => logger . error ( e ) ) , ] ) , "s" , 0 , ) ) ; } ) ; afterEach ( killFlutterTester ) ; async function startDebugger ( script ? : vs . Uri | string ) < vs . DebugConfiguration > { const config = ( await getLaunchConfiguration ( script ) ) ! ; await dc . start ( config . debugServer ) ; return config ; } it ( "s" , async ( ) => { const config = await startDebugger ( flutterWebTestMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterWebTestMainFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , `template` ) , dc . waitForEvent ( "s" ) , dc . assertPassingTest ( `template` ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const relativePath = path . relative ( fsPath ( flutterWebHelloWorldFolder ) , fsPath ( flutterWebTestMainFile ) ) ; const config = await startDebugger ( `template` ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , `template` ) , dc . assertPassingTest ( `template` ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( flutterWebTestMainFile ) ; config . program = path . relative ( fsPath ( flutterWebHelloWorldFolder ) , fsPath ( flutterWebTestMainFile ) ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , `template` ) , dc . assertPassingTest ( `template` ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterWebTestMainFile ) ; const config = await startDebugger ( flutterWebTestOtherFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , `template` ) , dc . assertPassingTest ( `template` ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterWebTestOtherFile ) ; const config = await startDebugger ( undefined ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , `template` ) , dc . assertPassingTest ( `template` ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterWebTestOtherFile ) ; const config = await startDebugger ( "s" ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertOutputContains ( "s" , `template` ) , dc . assertPassingTest ( `template` ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { const config = await startDebugger ( "s" ) ; config . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . waitForEvent ( "s" ) , dc . launch ( config ) , ] ) ; const topLevelNodes = await extApi . testTreeProvider . getChildren ( ) ; assert . ok ( topLevelNodes ) ; assert . equal ( topLevelNodes ! . length , 0 ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterWebTestMainFile ) ; const config = await startDebugger ( flutterWebTestMainFile ) ; await dc . hitBreakpoint ( config , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( flutterWebTestMainFile ) , } ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterWebTestBrokenFile ) ; const config = await startDebugger ( flutterWebTestBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { } ) , dc . launch ( config ) , ] ) ; } ) ; it . skip ( "s" , async ( ) => { await openFile ( flutterWebTestBrokenFile ) ; const config = await startDebugger ( flutterWebTestBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { line : positionOf ( "s" ) . line + 0 , path : fsPath ( flutterWebTestBrokenFile ) , } ) , dc . launch ( config ) , ] ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterWebTestBrokenFile ) ; const config = await startDebugger ( flutterWebTestBrokenFile ) ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertStoppedLocation ( "s" , { } ) , dc . launch ( config ) , ] ) ; const variables = await dc . getTopFrameVariables ( "s" ) as DebugProtocol . Variable [ ] ; assert . ok ( variables ) ; let v = variables . find ( ( v ) => v . name === "s" ) ; assert . ok ( v ) ; v = v ! ; assert . equal ( v . evaluateName , "s" ) ; assert . ok ( v . value . startsWith ( `template` ) ) ; } ) ; it ( "s" , async ( ) => { await openFile ( flutterWebTestBrokenFile ) ; const config = await startDebugger ( flutterWebTestBrokenFile ) ; config . noDebug = true ; await Promise . all ( [ dc . configurationSequence ( ) , dc . assertErroringTest ( `template` ) , dc . assertOutput ( "s" , "s" ) , dc . assertOutputContains ( "s" , "s" ) , dc . launch ( config ) , ] ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O O $Promise<void>$ O $void$ O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $any$ O $any$ O $any$ O $any$ O $Promise<any>$ O $Logger$ O $Promise<any>$ O $any$ O $Promise<T>$ O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O $any$ O O O O O O $DartDebugClient$ O $any$ O O O O O O O $DartDebugClient$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $undefined$ O $InternalExtensionApi$ O $DebugCommandHandler$ O $InternalExtensionApi$ O $TestResultsProvider$ O O O $DartDebugClient$ O $number$ O O O O $DartDebugClient$ O $DartDebugClient$ O $void$ O O O O $Promise<T>$ O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $Promise<any>$ O O $any$ O O $Logger$ O $void$ O $any$ O O O $Promise<void>$ O O O O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $complex$ O O $any$ O O $Logger$ O $void$ O $any$ O O O O O O O O O O O O O O O O $any$ O $Promise<void>$ O O O O $Promise$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O O O $Promise<any>$ O $any$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O $any$ O O O $any$ O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $string$ O $any$ O O $string$ O $any$ O O O O $any$ O O $Promise<any>$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $string$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $undefined$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any$ O O $InternalExtensionApi$ O $TestResultsProvider$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $DartDebugClient$ O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O $any$ O $any$ O O O O $any$ O O O $string$ O $string$ O $any$ O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<any>$ O O O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O $any[]$ O O $DartDebugClient$ O $Promise<any[]>$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any[]$ O O O $any$ O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<any>$ O $any$ O O O $any$ O O $Promise<any>$ O $any$ O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $DartDebugClient$ O $Promise<any>$ O O O $DartDebugClient$ O $Promise<void>$ O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<any>$ O O O O O O $DartDebugClient$ O $Promise<void>$ O $any$ O O O O O O O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { Sdks } from "s" ; import { fsPath } from "s" ; import { activateWithoutAnalysis , ext , extApi , logger } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const wfs = vs . workspace . workspaceFolders || [ ] ; assert . equal ( wfs . length , 0 ) ; assert . ok ( fsPath ( wfs [ 0 ] . uri ) . endsWith ( `template` ) , `template` , ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . equal ( ext . isActive , true ) ; } ) ; it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . ok ( extApi ) ; const sdks = extApi . workspaceContext . sdks ; assert . ok ( sdks ) ; assert . ok ( sdks . dart ) ; assert . ok ( sdks . flutter ) ; logger . info ( "s" + JSON . stringify ( sdks , undefined , 0 ) . trim ( ) . slice ( 0 , - 0 ) . trim ( ) ) ; logger . info ( `template` ) ; } ) ; it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . ok ( extApi ) ; const sdks = extApi . workspaceContext . sdks ; assert . ok ( sdks ) ; assert . ok ( sdks . dart ) ; assert . equal ( sdks . dartSdkIsFromFlutter , true ) ; assert . notEqual ( sdks . dart ! . indexOf ( "s" ) , - 0 ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O O O O O O $Promise<void>$ O $any$ O $InternalExtensionApi$ O $Logger$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $boolean$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $InternalExtensionApi$ O O O $Sdks$ O $InternalExtensionApi$ O $WorkspaceContext$ O $Sdks$ O $any$ O $any$ O $Sdks$ O O $any$ O $any$ O $Sdks$ O $string$ O O $any$ O $any$ O $Sdks$ O $string$ O O $Logger$ O $void$ O O O $JSON$ O $complex$ O $Sdks$ O $undefined$ O O O O $string$ O O O $string$ O O O O O O O $string$ O O O O $Logger$ O $void$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $InternalExtensionApi$ O O O $Sdks$ O $InternalExtensionApi$ O $WorkspaceContext$ O $Sdks$ O $any$ O $any$ O $Sdks$ O O $any$ O $any$ O $Sdks$ O $string$ O O $any$ O $any$ O $Sdks$ O $boolean$ O O O O $any$ O $any$ O $Sdks$ O $string$ O O $number$ O O O O O O O O O O O O O O
import * as test_runner from "s" ; module . exports = test_runner ;	O O O $any$ O O O $any$ O $any$ O $any$ O
import * as assert from "s" ; import * as vs from "s" ; import { fiveMinutesInMs } from "s" ; import { activate , flutterHelloWorldMainFile , helloWorldMainFile } from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await activate ( ) ; const res = await vs . commands . executeCommand ( "s" , helloWorldMainFile ) ; assert . equal ( res , 0 ) ; } ) . timeout ( 0 * 0 * 0 ) ; it ( "s" , async ( ) => { await activate ( ) ; const res = await vs . commands . executeCommand ( "s" , flutterHelloWorldMainFile ) ; assert . equal ( res , 0 ) ; } ) . timeout ( fiveMinutesInMs ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O $number$ O O O O O O $Promise<void>$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $number$ O O O O O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { fsPath } from "s" ; import { activate , extApi , helloWorldFolder , helloWorldMainFile , setConfigForTest } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const wfs = vs . workspace . workspaceFolders || [ ] ; assert . equal ( wfs . length , 0 ) ; assert . ok ( fsPath ( wfs [ 0 ] . uri ) . endsWith ( path . sep + "s" ) , `template` , ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await activate ( ) ; await setConfigForTest ( "s" , "s" , false ) ; const resolvedConfig = await extApi . debugProvider . resolveDebugConfiguration ! ( vs . workspace . workspaceFolders ! [ 0 ] , { name : "s" , program : fsPath ( helloWorldMainFile ) , request : "s" , type : "s" , } , ) ; assert . ok ( resolvedConfig ) ; assert . equal ( resolvedConfig ! . cwd , fsPath ( helloWorldFolder ) ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O O O O O O $Promise<void>$ O $InternalExtensionApi$ O $any$ O $any$ O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $boolean$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O O $Promise<void>$ O O O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $string$ O $string$ O $any$ O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $string$ O $any$ O O O O O O O O O
import * as test_runner from "s" ; module . exports = test_runner ;	O O O $any$ O O O $any$ O $any$ O $any$ O
import * as assert from "s" ; import * as path from "s" ; import * as vs from "s" ; import { Sdks } from "s" ; import { fsPath } from "s" ; import { activateWithoutAnalysis , ext , extApi } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const wfs = vs . workspace . workspaceFolders || [ ] ; assert . equal ( wfs . length , 0 ) ; assert . ok ( fsPath ( wfs [ 0 ] . uri ) . endsWith ( path . sep + "s" ) , `template` , ) ; assert . ok ( fsPath ( wfs [ 0 ] . uri ) . endsWith ( path . sep + "s" ) , `template` , ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . equal ( ext . isActive , true ) ; } ) ; it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . ok ( extApi ) ; const sdks = extApi . workspaceContext . sdks ; assert . ok ( sdks ) ; assert . ok ( sdks . dart ) ; assert . ok ( sdks . flutter ) ; } ) ; it ( "s" , async ( ) => { await activateWithoutAnalysis ( ) ; assert . ok ( extApi ) ; const sdks = extApi . workspaceContext . sdks ; assert . ok ( sdks ) ; assert . ok ( sdks . dart ) ; assert . notEqual ( sdks . dart ! . indexOf ( "s" ) , - 0 ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $string$ O O O O O O $Promise<void>$ O $any$ O $InternalExtensionApi$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $boolean$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $boolean$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $InternalExtensionApi$ O O O $Sdks$ O $InternalExtensionApi$ O $WorkspaceContext$ O $Sdks$ O $any$ O $any$ O $Sdks$ O O $any$ O $any$ O $Sdks$ O $string$ O O $any$ O $any$ O $Sdks$ O $string$ O O O O O $any$ O O O O O O O O O $Promise<void>$ O O O $any$ O $any$ O $InternalExtensionApi$ O O O $Sdks$ O $InternalExtensionApi$ O $WorkspaceContext$ O $Sdks$ O $any$ O $any$ O $Sdks$ O O $any$ O $any$ O $Sdks$ O $string$ O O $any$ O $any$ O $Sdks$ O $string$ O O $number$ O O O O O O O O O O O O O O
import * as test_runner from "s" ; module . exports = test_runner ;	O O O $any$ O O O $any$ O $any$ O $any$ O
import * as assert from "s" ; import { DART_DEP_FILE_NODE_CONTEXT , DART_DEP_PACKAGE_NODE_CONTEXT , DART_DEP_PROJECT_NODE_CONTEXT } from "s" ; import { fsPath } from "s" ; import { ensurePackageTreeNode , extApi , flutterHelloWorldMainFile , getPackages , helloWorldMainFile , myPackageThingFile } from "s" ; describe ( "s" , ( ) => { before ( "s" , ( ) => getPackages ( helloWorldMainFile ) ) ; before ( "s" , ( ) => getPackages ( flutterHelloWorldMainFile ) ) ; it ( "s" , async ( ) => { const topLevel = await extApi . packagesTreeProvider . getChildren ( undefined ) ; ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" ) ; ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" ) ; } ) ; it ( "s" , async ( ) => { const topLevel = await extApi . packagesTreeProvider . getChildren ( undefined ) ; const helloWorld = ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" ) ; const packages = await extApi . packagesTreeProvider . getChildren ( helloWorld ) ; const self = packages ! . find ( ( node ) => node . label === "s" ) ; assert . equal ( self , undefined ) ; } ) ; it ( "s" , async ( ) => { const topLevel = await extApi . packagesTreeProvider . getChildren ( undefined ) ; const helloWorld = ensurePackageTreeNode ( topLevel , DART_DEP_PROJECT_NODE_CONTEXT , "s" ) ; const packages = await extApi . packagesTreeProvider . getChildren ( helloWorld ) ; const myPackage = ensurePackageTreeNode ( packages , DART_DEP_PACKAGE_NODE_CONTEXT , "s" ) ; const myPackageLibContents = await extApi . packagesTreeProvider . getChildren ( myPackage ) ; const file = ensurePackageTreeNode ( myPackageLibContents , DART_DEP_FILE_NODE_CONTEXT , "s" ) ; assert . equal ( fsPath ( file . resourceUri ! ) , fsPath ( myPackageThingFile ) ) ; } ) ; } ) ;	O O O $any$ O O O O O O O O O O O O O O O O $string$ O O O O O O $any$ O $InternalExtensionApi$ O $any$ O $Promise<void>$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O $any$ O O O O O O $Promise<void>$ O $any$ O O O $any$ O O O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $undefined$ O O O O O $any$ O O O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $InternalExtensionApi$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $string$ O $any$ O $any$ O O O $string$ O $any$ O O O O O O O O O
import * as assert from "s" ; import * as fs from "s" ; import * as path from "s" ; import * as sinon from "s" ; import * as vs from "s" ; import { DART_STAGEHAND_PROJECT_TRIGGER_FILE } from "s" ; import { StagehandTemplate } from "s" ; import { fsPath } from "s" ; import { attachLoggingWhenExtensionAvailable , ext , getRandomTempFolder , sb } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const wfs = vs . workspace . workspaceFolders || [ ] ; assert . equal ( wfs . length , 0 ) ; assert . ok ( fsPath ( wfs [ 0 ] . uri ) . endsWith ( path . sep + "s" ) , `template` , ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { assert . equal ( ext . isActive , false ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { attachLoggingWhenExtensionAvailable ( ) ; const projectName = "s" ; const templateName = "s" ; const templateEntrypoint = "s" ; const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( projectName ) ; const showOpenDialog = sb . stub ( vs . window , "s" ) ; const tempFolder = getRandomTempFolder ( ) ; showOpenDialog . resolves ( [ vs . Uri . file ( tempFolder ) ] ) ; const showQuickPick = sb . stub ( vs . window , "s" ) ; type SnippetOption = vs . QuickPickItem & { template : StagehandTemplate } ; showQuickPick . callsFake ( ( items : SnippetOption [ ] ) => items . find ( ( t ) => t . template . name === templateName ) ) ; const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const openFolder = executeCommand . withArgs ( "s" , sinon . match . any ) . resolves ( ) ; await vs . commands . executeCommand ( "s" ) ; assert . ok ( showQuickPick . calledOnce ) ; assert . ok ( openFolder . calledOnce ) ; const triggerFile = path . join ( tempFolder , projectName , DART_STAGEHAND_PROJECT_TRIGGER_FILE ) ; assert . ok ( fs . existsSync ( triggerFile ) ) ; const recordedTemplateJson = fs . readFileSync ( triggerFile ) . toString ( ) . trim ( ) ; const recordedTemplate = JSON . parse ( recordedTemplateJson ) as StagehandTemplate ; assert . equal ( recordedTemplate . name , templateName ) ; assert . equal ( recordedTemplate . entrypoint , templateEntrypoint ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O O O O O O $string$ O O O O O O $Promise<void>$ O $any$ O $string$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $boolean$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Promise<void>$ O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O $string$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $StagehandTemplate$ O $any$ O O $any$ O $any$ O O $any[]$ O $any$ O O O O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O $StagehandTemplate$ O $JSON$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $StagehandTemplate$ O $string$ O O O O $any$ O $any$ O $StagehandTemplate$ O $string$ O O O O O O O O O O
import * as test_runner from "s" ; module . exports = test_runner ;	O O O $any$ O O O $any$ O $any$ O $any$ O
import * as assert from "s" ; import * as fs from "s" ; import * as path from "s" ; import * as sinon from "s" ; import * as vs from "s" ; import { FLUTTER_CREATE_PROJECT_TRIGGER_FILE } from "s" ; import { FlutterSampleSnippet } from "s" ; import { fsPath } from "s" ; import { attachLoggingWhenExtensionAvailable , ext , getRandomTempFolder , sb } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const wfs = vs . workspace . workspaceFolders || [ ] ; assert . equal ( wfs . length , 0 ) ; assert . ok ( fsPath ( wfs [ 0 ] . uri ) . endsWith ( path . sep + "s" ) , `template` , ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { assert . equal ( ext . isActive , false ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { attachLoggingWhenExtensionAvailable ( ) ; const showInputBox = sb . stub ( vs . window , "s" ) ; showInputBox . resolves ( "s" ) ; const showOpenDialog = sb . stub ( vs . window , "s" ) ; const tempFolder = getRandomTempFolder ( ) ; showOpenDialog . resolves ( [ vs . Uri . file ( tempFolder ) ] ) ; const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const openFolder = executeCommand . withArgs ( "s" , sinon . match . any ) . resolves ( ) ; await vs . commands . executeCommand ( "s" ) ; assert . ok ( showInputBox . calledOnce ) ; assert . ok ( showOpenDialog . calledOnce ) ; assert . ok ( openFolder . calledOnce ) ; assert . ok ( fs . existsSync ( path . join ( tempFolder , "s" , FLUTTER_CREATE_PROJECT_TRIGGER_FILE ) ) ) ; } ) ; it ( "s" , async ( ) => { const showQuickPick = sb . stub ( vs . window , "s" ) ; type SnippetOption = vs . QuickPickItem & { snippet : FlutterSampleSnippet } ; showQuickPick . callsFake ( ( items : SnippetOption [ ] ) => items . find ( ( s ) => s . snippet . id === "s" || s . snippet . id === "s" ) ) ; const executeCommand = sb . stub ( vs . commands , "s" ) . callThrough ( ) ; const openFolder = executeCommand . withArgs ( "s" , sinon . match . any ) . resolves ( ) ; const sampleFolderUri : string | undefined = await vs . commands . executeCommand ( "s" ) ; assert . ok ( sampleFolderUri ) ; assert . ok ( showQuickPick . calledOnce ) ; assert . ok ( openFolder . calledOnce ) ; const triggerFile = path . join ( fsPath ( sampleFolderUri ! ) , FLUTTER_CREATE_PROJECT_TRIGGER_FILE ) ; assert . ok ( fs . existsSync ( triggerFile ) ) ; const recordedSampleId = fs . readFileSync ( triggerFile ) . toString ( ) . trim ( ) ; assert . equal ( recordedSampleId === "s" || recordedSampleId === "s" , true ) ; } ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O O O O O O $string$ O O O O O O $Promise<void>$ O $any$ O $string$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O O $boolean$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O $string$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $FlutterSampleSnippet$ O $any$ O O $any$ O $any$ O O $any[]$ O $any$ O O O O $any[]$ O $complex$ O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O O O O
import * as test_runner from "s" ; module . exports = test_runner ;	O O O $any$ O O O $any$ O $any$ O $any$ O
import * as fs from "s" ; import * as path from "s" ; const loadCoverage = require ( "s" ) ; const remap = require ( "s" ) ; const writeReport = require ( "s" ) ; const files = fs . readdirSync ( "s" ) . filter ( ( item ) => item . endsWith ( "s" ) ) ; for ( const filename of files ) { const fullPath = `template` ; const coverage = loadCoverage ( fullPath ) ; const collector = remap ( coverage , { mapFileName : path . resolve , } ) ; writeReport ( collector , "s" , { } , fullPath ) ; }	O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $string$ O O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $string$ O O O
import * as fs from "s" ; import * as path from "s" ; import * as vstest from "s" ; let exitCode = 0 ; const cwd = process . cwd ( ) ; const testEnv = Object . create ( process . env ) ; function yellow ( message ) { return color ( 0 , message ) ; } function color ( col , message ) { return "s" + col + "s" + message + "s" ; } async function runTests ( testFolder , workspaceFolder , sdkPaths , codeVersion : string | undefined ) < void > { console . log ( "s" ) ; console . log ( yellow ( "s" ) ) ; console . log ( yellow ( "s" ) + `template` + `template` + `template` ) ; console . log ( `template` ) ; sdkPaths . split ( path . delimiter ) . filter ( ( p ) => p && p . toLowerCase ( ) . indexOf ( "s" ) !== - 0 || p . toLowerCase ( ) . indexOf ( "s" ) !== - 0 ) . forEach ( ( p ) => console . log ( `template` ) ) ; console . log ( yellow ( "s" ) ) ; testEnv . DART_PATH_OVERRIDE = sdkPaths ; testEnv . CODE_VERSION = codeVersion ; const dartFriendlyName = ( process . env . ONLY_RUN_DART_VERSION || "s" ) . toLowerCase ( ) ; const codeFriendlyName = codeVersion || "s" ; const testRunName = testFolder . replace ( "s" , "s" ) ; testEnv . TEST_RUN_NAME = testRunName ; testEnv . DC_TEST_LOGS = path . join ( cwd , "s" , `template` ) ; testEnv . COVERAGE_OUTPUT = path . join ( cwd , "s" , `template` ) ; testEnv . TEST_XML_OUTPUT = path . join ( cwd , "s" , `template` ) ; testEnv . TEST_CSV_SUMMARY = path . join ( cwd , "s" , `template` ) ; if ( ! fs . existsSync ( testEnv . DC_TEST_LOGS ) ) fs . mkdirSync ( testEnv . DC_TEST_LOGS ) ; try { const res = await vstest . runTests ( { extensionDevelopmentPath : cwd , extensionTestsEnv : testEnv , extensionTestsPath : path . join ( cwd , "s" , "s" , "s" , testFolder ) , launchArgs : [ path . isAbsolute ( workspaceFolder ) ? workspaceFolder : path . join ( cwd , "s" , "s" , "s" , workspaceFolder ) , "s" , path . join ( cwd , "s" ) , ] , version : codeVersion , } ) ; exitCode = exitCode || res ; } catch ( e ) { console . error ( e ) ; exitCode = exitCode || 0 ; } console . log ( yellow ( "s" ) ) ; console . log ( "s" ) ; } async function runAllTests ( ) < void > { if ( process . env . CI ) { const branchName = process . env . APPVEYOR_REPO_BRANCH || process . env . TRAVIS_BRANCH || process . env . GITHUB_REF ; const commit = process . env . APPVEYOR_REPO_COMMIT || process . env . TRAVIS_COMMIT || process . env . GITHUB_SHA ; console . log ( "s" ) ; console . log ( yellow ( "s" ) ) ; console . log ( yellow ( `template` ) ) ; console . log ( "s" ) ; } const codeVersion = process . env . ONLY_RUN_CODE_VERSION === "s" ? "s" : undefined ; const dartSdkPath = process . env . DART_PATH_SYMLINK || process . env . DART_PATH || process . env . PATH ; const flutterSdkPath = process . env . FLUTTER_PATH_SYMLINK || process . env . FLUTTER_PATH || process . env . PATH ; if ( ! dartSdkPath ) throw new Error ( "s" ) ; if ( ! flutterSdkPath ) throw new Error ( "s" ) ; testEnv . DART_CODE_IS_TEST_RUN = true ; testEnv . MOCHA_FORBID_ONLY = true ; if ( ! fs . existsSync ( "s" ) ) fs . mkdirSync ( "s" ) ; if ( ! fs . existsSync ( "s" ) ) fs . mkdirSync ( "s" ) ; const flutterRoot = process . env . FLUTTER_ROOT || process . env . FLUTTER_PATH ; const runDartTests = ! process . env . RUN_TESTS || process . env . RUN_TESTS === "s" ; const runFlutterTests = ! process . env . RUN_TESTS || process . env . RUN_TESTS === "s" ; try { if ( runDartTests ) { await runTests ( "s" , "s" , dartSdkPath , codeVersion ) ; await runTests ( "s" , "s" , dartSdkPath , codeVersion ) ; await runTests ( "s" , "s" , dartSdkPath , codeVersion ) ; } if ( runFlutterTests ) { await runTests ( "s" , "s" , flutterSdkPath , codeVersion ) ; await runTests ( "s" , "s" , flutterSdkPath , codeVersion ) ; await runTests ( "s" , "s" , flutterSdkPath , codeVersion ) ; await runTests ( "s" , "s" , flutterSdkPath , codeVersion ) ; await runTests ( "s" , "s" , flutterSdkPath , codeVersion ) ; await runTests ( "s" , "s" , flutterSdkPath , codeVersion ) ; if ( flutterRoot ) { await runTests ( "s" , flutterRoot , flutterSdkPath , codeVersion ) ; } else { console . error ( "s" ) ; exitCode = 0 ; } } } catch ( e ) { exitCode = 0 ; console . error ( e ) ; } } runAllTests ( ) . then ( ( ) => process . exit ( exitCode ) ) ;	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O O O $string$ O $string$ O O O $string$ O O O $string$ O O O O $string$ O $number$ O $string$ O O O O O $number$ O O O $string$ O O O O O O $Promise$ O $string$ O $string$ O $string$ O $string$ O O O O O O O O O $Console$ O $void$ O O O O $Console$ O $void$ O $string$ O O O O O $Console$ O $void$ O $string$ O O O O O O O O O O O $Console$ O $void$ O O O O $string$ O $complex$ O $any$ O $any$ O O $complex$ O O $string$ O O $string$ O $string$ O $string$ O O O $number$ O O O O O O O $string$ O $string$ O O O $number$ O O O O O O O O $void$ O O $string$ O O $Console$ O $void$ O O O O O $Console$ O $void$ O $string$ O O O O O $any$ O $any$ O $string$ O $any$ O $any$ O $string$ O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O $string$ O $string$ O O O O $string$ O $string$ O $complex$ O O O O O O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $string$ O O $any[]$ O O $any$ O $any$ O $string$ O O $string$ O $any$ O $any$ O $any$ O O O O O O O $string$ O O O O $any$ O $any$ O $any$ O O O O O O $string$ O $string$ O O O O $number$ O $number$ O $any$ O O O O $any$ O O $Console$ O $void$ O $any$ O O $number$ O $number$ O O O O $Console$ O $void$ O $string$ O O O O O $Console$ O $void$ O O O O O O O $Promise$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Console$ O $void$ O O O O $Console$ O $void$ O $string$ O O O O O $Console$ O $void$ O $string$ O O O O O $Console$ O $void$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $undefined$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $ErrorConstructor$ O O O O O O O $any$ O O O $ErrorConstructor$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $boolean$ O O O $Promise<void>$ O O O O O $any$ O O O O O $Promise<void>$ O O O O O $any$ O O O O O $Promise<void>$ O O O O O $any$ O O O O O O O $boolean$ O O O $Promise<void>$ O O O O O $any$ O O O O O $Promise<void>$ O O O O O $any$ O O O O O $Promise<void>$ O O O O O $any$ O O O O O $Promise<void>$ O O O O O $any$ O O O O O $Promise<void>$ O O O O O $any$ O O O O O $Promise<void>$ O O O O O $any$ O O O O O O $any$ O O O $Promise<void>$ O O O $any$ O $any$ O O O O O O O $Console$ O $void$ O O O O $number$ O O O O O O O O $any$ O O $number$ O O O $Console$ O $void$ O $any$ O O O O $Promise<void>$ O O O O O O O O $any$ O $any$ O $number$ O O O
'js' "s" ; const path = require ( "s" ) ; module . exports = env => { const config = { devtool : "s" , entry : "s" , externals : { vscode : "s" , } , module : { rules : [ { exclude : "s" , test : "s" , loader : "s" , } ] , } , output : { devtoolModuleFilenameTemplate : "s" , filename : "s" , libraryTarget : "s" , path : path . resolve ( __dirname , "s" ) , } , resolve : { extensions : [ "s" , "s" ] , } , target : "s" , } ; if ( env && env . instrumentation ) { config . module . rules . push ( { enforce : "s" , exclude : "s" , test : "s" , loader : "s" , } ) ; } return config ; } ;	O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $complex$ O O O $RegExp$ O O O $RegExp$ O O O $string$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O $complex$ O O $string[]$ O O O O O O O O O $string$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O $RegExp$ O O O $RegExp$ O O O $string$ O O O O O O O O $any$ O O O