'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
import { Types as RXTypes } from 's' ; import * as React from 's' ; export interface ImageSvgStyle extends RXTypes . ViewStyle { } export declare type ImageSvgStyleRuleSet = RXTypes . StyleRuleSet < ImageSvgStyle > ; export interface SvgCommonProps { key ? : string | number ; strokeColor ? : string ; strokeWidth ? : number ; strokeOpacity ? : number ; fillColor ? : string ; fillOpacity ? : number ; } export interface ImageSvgProps extends SvgCommonProps , RXTypes . CommonStyledProps < ImageSvgStyleRuleSet , ImageSvg > { children ? : RXTypes . ReactNode ; height : number ; width : number ; accessibilityLabel ? : string ; title ? : string ; viewBox ? : string ; preserveAspectRatio ? : string ; webShadow ? : string ; } export interface SvgPathProps extends SvgCommonProps { d ? : string ; } export interface SvgRectProps extends SvgCommonProps { width : number ; height : number ; x : number ; y : number ; } export class ImageSvg extends React . Component < ImageSvgProps , RXTypes . Stateless > { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import * as Types from 's' ; export abstract class ImageSvg extends React . Component < Types . ImageSvgProps , any > { } export abstract class SvgPath extends React . Component < Types . SvgPathProps , any > { } export abstract class SvgRect extends React . Component < Types . SvgRectProps , any > { } export interface PluginInterface { Types : typeof Types ; default : typeof ImageSvg ; SvgPath : typeof SvgPath ; SvgRect : typeof SvgRect ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Types from 's' ; import ImageSvg from 's' ; import SvgPath from 's' ; import SvgRect from 's' ; export { ImageSvg as default , SvgPath , SvgRect , Types } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Types from 's' ; import ImageSvg from 's' ; import SvgPath from 's' ; import SvgRect from 's' ; export { ImageSvg as default , SvgPath , SvgRect , Types } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Interfaces from 's' ; import * as AndroidPlugin from 's' ; import * as iOSPlugin from 's' ; import * as macOSPlugin from 's' ; import * as WebPlugin from 's' ; import * as WindowsPlugin from 's' ; const _typeCheckerAndroid : Interfaces . PluginInterface = AndroidPlugin ; const _typeCheckeriOS : Interfaces . PluginInterface = iOSPlugin ; const _typeCheckermacOS : Interfaces . PluginInterface = macOSPlugin ; const _typeCheckerWeb : Interfaces . PluginInterface = WebPlugin ; const _typeCheckerWindows : Interfaces . PluginInterface = WindowsPlugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const assert = ( cond , message ? : string | undefined ) => { if ( ! cond ) { throw new Error ( message || 's' ) ; } } ; export default assert ;	O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
import * as React from 's' ; import * as RX from 's' ; export type ReactNode = React . ReactNode ; export enum NavigatorSceneConfigType { FloatFromRight , FloatFromLeft , FloatFromBottom , Fade , FadeWithSlide } export interface NavigatorRoute { routeId : number ; sceneConfigType : NavigatorSceneConfigType ; gestureResponseDistance ? : number ; customSceneConfig ? : CustomNavigatorSceneConfig ; } export type NavigationTransitionSpec = { duration ? : number ; easing ? : RX . Types . Animated . EasingFunction ; } ; export type NavigationTransitionStyleConfig = { inputRange ? : number [ ] ; opacityOutput : number | number [ ] ; scaleOutput : number | number [ ] ; translateXOutput : number | number [ ] ; translateYOutput : number | number [ ] ; } ; export type CustomNavigatorSceneConfig = { transitionStyle : ( sceneIndex , sceneDimensions : RX . Types . Dimensions ) => NavigationTransitionStyleConfig ; transitionSpec ? : NavigationTransitionSpec ; cardStyle ? : RX . Types . ViewStyleRuleSet ; hideShadow ? : boolean ; presentBelowPrevious ? : boolean ; } ; export interface NavigatorProps extends RX . CommonProps { renderScene : ( route ) => JSX . Element | null ; navigateBackCompleted ? : ( ) => void ; transitionStarted ? : ( progress ? : RX . Types . AnimatedValue , toRouteId ? , fromRouteId ? , toIndex ? , fromIndex ? ) => void ; transitionCompleted ? : ( ) => void ; cardStyle ? : RX . Types . ViewStyleRuleSet ; children ? : ReactNode ; delegateSelector ? : NavigatorDelegateSelector ; } export enum CommandType { Push , Pop , Replace } export interface CommandParam { route ? : NavigatorRoute ; value ? : number ; } export interface NavigationCommand { type : CommandType ; param : CommandParam ; } export interface NavigatorState { } export abstract class Navigator < S > extends React . Component < NavigatorProps , S > { abstract push ( route ) ; abstract pop ( ) ; abstract replace ( route ) ; abstract replacePrevious ( route ) ; abstract replaceAtIndex ( route , index ) ; abstract immediatelyResetRouteStack ( nextRouteStack : NavigatorRoute [ ] ) ; abstract popToRoute ( route ) ; abstract popToTop ( ) ; abstract getCurrentRoutes ( ) : NavigatorRoute [ ] ; } export interface NavigatorDelegateSelector { getNavigatorDelegate ( navigator < NavigatorState > ) : NavigatorDelegate ; } export abstract class NavigatorDelegate { protected _owner : Navigator < NavigatorState > ; constructor ( navigator < NavigatorState > ) { this . _owner = navigator ; } onBackPress = ( ) : boolean => { const routes = this . getRoutes ( ) ; if ( routes . length > 0 ) { this . handleBackPress ( ) ; if ( this . _owner . props . navigateBackCompleted ) { this . _owner . props . navigateBackCompleted ( ) ; } return true ; } return false ; } abstract getRoutes ( ) : NavigatorRoute [ ] ; abstract immediatelyResetRouteStack ( nextRouteStack : NavigatorRoute [ ] ) ; abstract render ( ) : JSX . Element | null ; abstract processCommand ( commandQueue : NavigationCommand [ ] ) ; abstract handleBackPress ( ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NavigatorRoute$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $NavigatorRoute$ O O O $void$ O O O O $void$ O $NavigatorRoute$ O O O $void$ O $NavigatorRoute$ O O O $void$ O $NavigatorRoute$ O $number$ O O O $void$ O O O O O O O O O $void$ O $NavigatorRoute$ O O O $void$ O O O O O O O O O O O O O O O O O O O $Navigator$ O O O O O O O O O O O O O O O O O O O O O O O $Navigator$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O $void$ O O O O
const assert = ( cond , message ? : string | undefined ) => { if ( ! cond ) { throw new Error ( message || 's' ) ; } } ; export default assert ;	O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import assign = require ( 's' ) ; import clone = require ( 's' ) ; import cloneDeep = require ( 's' ) ; import flatten = require ( 's' ) ; import get = require ( 's' ) ; import isEmpty = require ( 's' ) ; import isEqual = require ( 's' ) ; import isNumber = require ( 's' ) ; import map = require ( 's' ) ; import mapValues = require ( 's' ) ; export interface Dictionary < T > { [ index ] : T ; } export { assign , clone , cloneDeep , flatten , get , isEmpty , isEqual , isNumber , map , mapValues , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
export enum DeviceNetworkType { Unknown , None , Wifi , 0 , 0 , 0 }	O O O O O O O O O O O O O O O O
import SubscribableEvent from 's' ; import * as Types from 's' ; export abstract class NetInfo { abstract isConnected ( ) < boolean > ; abstract getType ( ) < Types . DeviceNetworkType > ; connectivityChangedEvent = new SubscribableEvent < ( isConnected ) => void > ( ) ; } export interface PluginInterface { Types : typeof Types ; default : NetInfo ; }	O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O $Promise$ O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O
import * as Types from 's' ; import NetInfo from 's' ; export { NetInfo as default , Types } ;	O O O O O O O O O O O O O O O O O O O O O
import * as Types from 's' ; import NetInfo from 's' ; export { NetInfo as default , Types } ;	O O O O O O O O O O O O O O O O O O O O O
import * as Interfaces from 's' ; import * as AndroidPlugin from 's' ; import * as iOSPlugin from 's' ; import * as macOSPlugin from 's' ; import * as WebPlugin from 's' ; import * as WindowsPlugin from 's' ; const _typeCheckerAndroid : Interfaces . PluginInterface = AndroidPlugin ; const _typeCheckeriOS : Interfaces . PluginInterface = iOSPlugin ; const _typeCheckermacOS : Interfaces . PluginInterface = macOSPlugin ; const _typeCheckerWeb : Interfaces . PluginInterface = WebPlugin ; const _typeCheckerWindows : Interfaces . PluginInterface = WindowsPlugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
import * as React from 's' ; import { Types as RXTypes } from 's' ; export interface VideoProgress { currentTime : number ; playableDuration : number ; atValue ? : number ; target ? : number ; atTimeScale ? : number ; } export interface VideoInfo { duration ? : number ; naturalSize ? : { width : number ; height : number ; } ; } export interface VideoProps extends RXTypes . CommonStyledProps < RXTypes . ViewStyleRuleSet , Video > { source : string | number ; accessibilityLabel ? : string ; showControls ? : boolean ; preload ? : 's' | 's' | 's' ; resizeMode ? : 's' | 's' | 's' ; loop ? : boolean ; authToken ? : string ; shouldRedirectForAndroidHLS ? : boolean ; onBuffer ? : ( ) => void ; onCanPlay ? : ( ) => void ; onCanPlayThrough ? : ( ) => void ; onEnded ? : ( ) => void ; onError ? : ( ) => void ; onLoadStart ? : ( ) => void ; onLoadedData ? : ( info ) => void ; onProgress ? : ( progress ) => void ; } export abstract class Video extends React . Component < VideoProps , RXTypes . Stateless > { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $VideoInfo$ O O O O O O O O $VideoProgress$ O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; import * as Types from 's' ; export abstract class Video extends RX . Component < Types . VideoProps , RX . Stateless > { abstract seek ( position ) ; abstract play ( ) ; abstract pause ( ) ; abstract mute ( muted ) ; } export interface PluginInterface { Types : typeof Types ; default : typeof Video ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O O O $void$ O O O O $void$ O O O O $void$ O $boolean$ O O O O O O O O O O O O O O O O O O
import * as Types from 's' ; import Video from 's' ; export { Video as default , Types } ;	O O O O O O O O O O O O O O O O O O O O O
import * as Types from 's' ; import Video from 's' ; export { Video as default , Types } ;	O O O O O O O O O O O O O O O O O O O O O
import * as Interfaces from 's' ; import * as AndroidPlugin from 's' ; import * as iOSPlugin from 's' ; import * as macOSPlugin from 's' ; import * as WebPlugin from 's' ; import * as WindowsPlugin from 's' ; const _typeCheckerAndroid : Interfaces . PluginInterface = AndroidPlugin ; const _typeCheckeriOS : Interfaces . PluginInterface = iOSPlugin ; const _typeCheckermacOS : Interfaces . PluginInterface = macOSPlugin ; const _typeCheckerWeb : Interfaces . PluginInterface = WebPlugin ; const _typeCheckerWindows : Interfaces . PluginInterface = WindowsPlugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
const assert = ( cond , message ? : string | undefined ) => { if ( ! cond ) { throw new Error ( message || 's' ) ; } } ; export default assert ;	O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
import { Component as ReactComponent } from 's' ; import { Types as RXTypes } from 's' ; export interface WebViewNavigationState { canGoBack : boolean ; canGoForward : boolean ; loading : boolean ; url : string ; title : string ; readonly navigationType : | 's' | 's' | 's' | 's' | 's' | 's' ; } export interface WebViewErrorState extends WebViewNavigationState { description : string ; domain : string ; code : string ; } export enum WebViewSandboxMode { None = 0 , AllowForms = 0 << 0 , AllowModals = 0 << 0 , AllowOrientationLock = 0 << 0 , AllowPointerLock = 0 << 0 , AllowPopups = 0 << 0 , AllowPopupsToEscapeSandbox = 0 << 0 , AllowPresentation = 0 << 0 , AllowSameOrigin = 0 << 0 , AllowScripts = 0 << 0 , AllowTopNavigation = 0 << 0 , AllowMixedContentAlways = 0 << 0 , AllowMixedContentCompatibilityMode = 0 << 0 } export interface WebViewSource { html : string ; baseUrl ? : string ; } export interface WebViewShouldStartLoadEvent { url : string ; } export interface WebViewNavigationEvent extends RXTypes . SyntheticEvent { nativeEvent : WebViewNavigationState ; } export interface WebViewErrorEvent extends RXTypes . SyntheticEvent { nativeEvent : WebViewErrorState ; } export interface WebViewMessageEvent extends RXTypes . SyntheticEvent { data : string ; origin : string ; } export interface WebViewProps extends RXTypes . CommonStyledProps < RXTypes . ViewStyleRuleSet , WebView > { url ? : string ; source ? : WebViewSource ; headers ? : Headers ; onLoad ? : ( e : RXTypes . SyntheticEvent ) => void ; onNavigationStateChange ? : ( navigationState ) => void ; scalesPageToFit ? : boolean ; injectedJavaScript ? : string ; javaScriptEnabled ? : boolean ; mediaPlaybackRequiresUserAction ? : boolean ; allowsInlineMediaPlayback ? : boolean ; startInLoadingState ? : boolean ; domStorageEnabled ? : boolean ; onShouldStartLoadWithRequest ? : ( shouldStartLoadEvent ) => boolean ; onLoadStart ? : ( e : RXTypes . SyntheticEvent ) => void ; onError ? : ( e : RXTypes . SyntheticEvent ) => void ; onMessage ? : ( e ) => void ; sandbox ? : WebViewSandboxMode ; } export abstract class WebView extends ReactComponent < WebViewProps , RXTypes . Stateless > { abstract postMessage ( message , targetOrigin ? ) ; abstract reload ( ) ; abstract goBack ( ) ; abstract goForward ( ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $WebViewNavigationState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $WebViewShouldStartLoadEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $WebViewMessageEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O $string$ O O O $void$ O O O O $void$ O O O O $void$ O O O O
import { Component as RXComponent , Types as RXTypes } from 's' ; import * as Types from 's' ; export interface PluginInterface { Types : typeof Types ; default : typeof Types . WebView ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Types from 's' ; import WebView from 's' ; export { WebView as default , Types } ;	O O O O O O O O O O O O O O O O O O O O O
import * as Types from 's' ; import WebView from 's' ; export { WebView as default , Types } ;	O O O O O O O O O O O O O O O O O O O O O
import * as Interfaces from 's' ; import * as AndroidPlugin from 's' ; import * as iOSPlugin from 's' ; import * as macOSPlugin from 's' ; import * as WebPlugin from 's' ; import * as WindowsPlugin from 's' ; const _typeCheckerAndroid : Interfaces . PluginInterface = AndroidPlugin ; const _typeCheckeriOS : Interfaces . PluginInterface = iOSPlugin ; const _typeCheckermacOS : Interfaces . PluginInterface = macOSPlugin ; const _typeCheckerWeb : Interfaces . PluginInterface = WebPlugin ; const _typeCheckerWindows : Interfaces . PluginInterface = WindowsPlugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' 's' ; module . exports = require ( 's' ) ;	O O O O O O O O O O O O
'js' module . exports = function ( api ) { api . cache . forever ( ) ; const presets = [ [ 's' ] , ] ; const plugins = [ [ 's' , { legacy : true } ] , ] ; if ( process . env . platform === 's' ) { return { presets : [ 's' , ... presets ] , plugins , } } return { presets , plugins } ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' import 's' ;	O O O O
'js' import Enzyme from 's' ; import Adapter from 's' ; Enzyme . configure ( { adapter : new Adapter ( ) } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { rootDir : 's' , roots : [ 's' ] , moduleFileExtensions : [ 's' , 's' , 's' , 's' , 's' , ] , moduleDirectories : [ 's' ] , snapshotSerializers : [ 's' , ] , setupFiles : [ 's' , ] , testRegex : 's' , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { transformer : { getTransformOptions : async ( ) => ( { transform : { experimentalImportSupport : false , inlineRequires : false } , } ) , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' require ( 's' ) . run ( ) ;	O O O O O O O O O O
declare const __DEV__ ; export const DEBUG = __DEV__ ; export const DEV = __DEV__ ;	O O $boolean$ O O O O O O O O O O O O O
import * as SyncTasks from 's' ; import { GenericRestClient } from 's' ; interface GiphyImageDescriptor { height : string ; width : string ; url : string ; } interface GiphyImages { fixed_height_downsampled : GiphyImageDescriptor ; fixed_height_still : GiphyImageDescriptor ; fixed_height : GiphyImageDescriptor ; fixed_width_still : GiphyImageDescriptor ; fixed_width : GiphyImageDescriptor ; original : GiphyImageDescriptor ; } interface GiphyDataImage { images : GiphyImages ; } interface GiphySearchResponse { data : GiphyDataImage [ ] ; } export interface GiphySearchResult { originalUrl : string ; smallUrl : string ; } const GIPHY_API_URL = 's' ; const GIPHY_API_KEY = 's' ; export class GiphyClient extends GenericRestClient { searchImages ( query , limit = 0 , offset = 0 , rating = 's' ) : SyncTasks . Promise < GiphySearchResult [ ] > { const url = this . _buildUrl ( query , limit , offset , rating ) ; return this . _performApiCall < GiphySearchResponse > ( url , 's' , undefined , undefined ) . then ( response => { if ( ! response . body || ! response . body . data ) { return [ ] ; } return response . body . data . map ( this . _normilizeResponse ) ; } ) ; } private _buildUrl = ( query , limit , offset , rating ) : string => ( `template` ) private _normilizeResponse = ( { images } ) : GiphySearchResult => ( { originalUrl : images . original . url , smallUrl : images . fixed_height . url } ) } export default new GiphyClient ( GIPHY_API_URL ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $number$ O $string$ O O O O O O O O O O O O O $GiphyDataImage$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as SyncTasks from 's' ; import { StoreBase , AutoSubscribeStore , autoSubscribe } from 's' ; import GiphyClient from 's' ; export interface Image { originalUrl : string ; smallUrl : string ; } @ AutoSubscribeStore export class ImageStore extends StoreBase { private _isSearchPending = false ; private _isFirstSearch = true ; private _lastSearchQuery = 's' ; private _searchQuery = 's' ; private _images : Image [ ] = [ ] ; private _request : SyncTasks . Promise < void > | null = null ; @ autoSubscribe getImages ( ) { return this . _images ; } @ autoSubscribe getSearchQuery ( ) { return this . _searchQuery ; } @ autoSubscribe isPerformingSearch ( ) { return this . _isSearchPending ; } @ autoSubscribe isFirstSearch ( ) { return this . _isFirstSearch ; } updateImages ( searchQuery ) { const searchQueryTrimmed = searchQuery . trim ( ) ; this . _searchQuery = searchQuery ; if ( this . _shouldSkipSearch ( searchQueryTrimmed ) ) { return ; } this . _isFirstSearch = false ; this . _lastSearchQuery = searchQueryTrimmed ; this . _images = [ ] ; if ( ! searchQuery ) { this . _cancelPreviousSearch ( ) ; this . trigger ( ) ; return ; } this . _isSearchPending = true ; this . trigger ( ) ; this . _cancelPreviousSearch ( ) ; this . _request = this . _searchImages ( searchQuery ) ; } private _searchImages ( query ) : SyncTasks . Promise < void > { return GiphyClient . searchImages ( query ) . then ( images => { this . _images = images ; this . _isSearchPending = false ; this . trigger ( ) ; } ) . catch ( ( { canceled } ) => { if ( ! canceled ) { this . _isSearchPending = false ; this . trigger ( ) ; } } ) ; } private _cancelPreviousSearch ( ) { if ( this . _request ) { this . _request . cancel ( ) ; this . _request = null ; } } private _shouldSkipSearch ( query ) { return ( ! query && ! this . _images . length ) || ( query === this . _lastSearchQuery ) ; } } export default new ImageStore ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' import 's' ; module . hot . accept ( ) ;	O O O O O O O O O O O O
'js' const ForkTsCheckerWebpackPlugin = require ( 's' ) ; const HtmlWebpackPlugin = require ( 's' ) ; const webpack = require ( 's' ) ; const path = require ( 's' ) ; const ROOT_PATH = path . join ( __dirname , 's' , 's' ) ; const DIST_PATH = path . join ( ROOT_PATH , 's' ) ; const APP_PATH = path . join ( ROOT_PATH , 's' ) ; const WEB_PATH = path . join ( ROOT_PATH , 's' ) ; const TS_CONFIG_PATH = path . join ( ROOT_PATH , 's' ) ; const buildConfig = ( env , argv ) => ( { entry : ROOT_PATH , resolve : { extensions : [ 's' , 's' , 's' ] , } , module : { rules : [ { test : "s" , loader : 's' , include : APP_PATH , enforce : 's' } , { test : "s" , loader : 's' , include : APP_PATH } ] , } , plugins : [ new webpack . DefinePlugin ( { __DEV__ : argv . mode === 's' } ) , new HtmlWebpackPlugin ( { inject : true , template : path . join ( WEB_PATH , 's' ) } ) , new ForkTsCheckerWebpackPlugin ( { tsconfig : TS_CONFIG_PATH , async : true } ) , ] , } ) ; module . exports = { buildConfig , APP_PATH , DIST_PATH , WEB_PATH , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const webpack = require ( 's' ) ; const merge = require ( 's' ) ; const path = require ( 's' ) ; const { buildConfig , APP_PATH , WEB_PATH } = require ( 's' ) ; module . exports = ( env , argv ) => ( merge ( buildConfig ( env , argv ) , { entry : path . join ( WEB_PATH , 's' ) , devtool : 's' , plugins : [ new webpack . HotModuleReplacementPlugin ( ) , ] , devServer : { contentBase : APP_PATH , openPage : 's' , inline : true , stats : 's' , open : true , port : 0 , hot : true , } , } ) ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const CompressionPlugin = require ( 's' ) ; const merge = require ( 's' ) ; const { buildConfig , DIST_PATH } = require ( 's' ) ; module . exports = ( env , argv ) => merge ( buildConfig ( env , argv ) , { devtool : false , output : { filename : 's' , path : DIST_PATH , } , plugins : [ new CompressionPlugin ( { algorithm : 's' , filename : 's' } ) , ] , } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' require ( 's' ) ;	O O O O O O
'js' require ( 's' ) ;	O O O O O O
'js' require ( 's' ) ;	O O O O O O
'js' module . exports = { transformer : { getTransformOptions : async ( ) => ( { transform : { experimentalImportSupport : false , inlineRequires : false , } , } ) , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Test , TestResult } from 's' ; import AccessibilityTest from 's' ; import AlertTest from 's' ; import AppTest from 's' ; import ActivityIndicatorTest from 's' ; import AnimationTest from 's' ; import ButtonTest from 's' ; import ClipboardTest from 's' ; import DragAndDropTest from 's' ; import GestureViewTest from 's' ; import ImageApiTest from 's' ; import ImageInteractiveTest from 's' ; import InputTest from 's' ; import InternationalTest from 's' ; import LinkTest from 's' ; import LinkingTest from 's' ; import LocationTest from 's' ; import ModalTest from 's' ; import NetworkTest from 's' ; import PickerTest from 's' ; import PlatformTest from 's' ; import PopupTest from 's' ; import ScrollViewBasicTest from 's' ; import ScrollViewEventTest from 's' ; import StatusBarTest from 's' ; import StorageTest from 's' ; import TextTest from 's' ; import TextInputApiTest from 's' ; import TextInputInteractiveTest from 's' ; import UserInterfaceTest from 's' ; import UserPresenceTest from 's' ; import ViewBasicTest from 's' ; import ViewMouseTest from 's' ; import ViewTouchTest from 's' ; import WebViewBasicTest from 's' ; import WebViewDynamicTest from 's' ; class TestRegistry { private _tests : { [ path ] : Test } = { } ; private _results : { [ path ] : TestResult } = { } ; constructor ( ) { this . registerTest ( AccessibilityTest ) ; this . registerTest ( AlertTest ) ; this . registerTest ( AnimationTest ) ; this . registerTest ( AppTest ) ; this . registerTest ( ClipboardTest ) ; this . registerTest ( DragAndDropTest ) ; this . registerTest ( InputTest ) ; this . registerTest ( InternationalTest ) ; this . registerTest ( LinkingTest ) ; this . registerTest ( LocationTest ) ; this . registerTest ( ModalTest ) ; this . registerTest ( NetworkTest ) ; this . registerTest ( PlatformTest ) ; this . registerTest ( PopupTest ) ; this . registerTest ( StatusBarTest ) ; this . registerTest ( StorageTest ) ; this . registerTest ( UserInterfaceTest ) ; this . registerTest ( UserPresenceTest ) ; this . registerTest ( ActivityIndicatorTest ) ; this . registerTest ( ButtonTest ) ; this . registerTest ( GestureViewTest ) ; this . registerTest ( ImageApiTest ) ; this . registerTest ( ImageInteractiveTest ) ; this . registerTest ( LinkTest ) ; this . registerTest ( PickerTest ) ; this . registerTest ( ScrollViewBasicTest ) ; this . registerTest ( ScrollViewEventTest ) ; this . registerTest ( TextTest ) ; this . registerTest ( TextInputApiTest ) ; this . registerTest ( TextInputInteractiveTest ) ; this . registerTest ( ViewBasicTest ) ; this . registerTest ( ViewMouseTest ) ; this . registerTest ( ViewTouchTest ) ; this . registerTest ( WebViewBasicTest ) ; this . registerTest ( WebViewDynamicTest ) ; } registerTest ( test ) { this . _tests [ test . getPath ( ) ] = test ; } getAllTests ( ) : { [ path ] : Test } { return this . _tests ; } getTest ( path ) { return this . _tests [ path ] ; } getResult ( path ) { return this . _results [ path ] ; } setResult ( path , result ) { this . _results [ path ] = result ; } formatPath ( path ) { return path . replace ( "s" , 's' ) ; } } export default new TestRegistry ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Test$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $Test$ O $string$ O O O O O O O O O O O $TestResult$ O $string$ O O O O O O O O O O O $void$ O $string$ O $TestResult$ O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O
export function approxEquals ( 0 , 0 , epsilon ? ) { if ( epsilon == null ) { epsilon = 0 ; } return Math . abs ( 0 - 0 ) < epsilon ; }	O O $boolean$ O $number$ O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as webpack from 's' ; const config : webpack . Configuration = { entry : "s" , mode : "s" , output : { filename : "s" , path : __dirname + "s" } , devtool : "s" , resolve : { extensions : [ "s" , "s" , "s" , "s" , "s" ] } , module : { rules : [ { test : "s" , loader : "s" } , { test : "s" , loader : "s" } ] } } ; export default config ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; var _ = require ( 's' ) ; var fs = require ( 's' ) ; var path = require ( 's' ) ; var targetPlatform = 's' ; var isDevEnv = false ; var basePaths = { nodeModulesPath : 's' , sourcePath : 's' , tempPath : 's' , webAppPath : 's' } ; function getTempPath ( mypath ) { return path . join ( basePaths . tempPath , targetPlatform , mypath ) ; } function getSourcePath ( mypath ) { return path . join ( basePaths . sourcePath , mypath ) ; } function getObjPath ( mypath ) { return path . join ( getTempPath ( 's' ) , mypath ) ; } function getWebAppPath ( mypath ) { return path . join ( basePaths . webAppPath , mypath ) ; } function getBuildPath ( mypath ) { if ( targetPlatform === 's' ) { return getWebAppPath ( mypath ) ; } else { return path . join ( basePaths . tempPath , targetPlatform , 's' , mypath ) ; } } function setTargetPlatform ( target ) { switch ( target ) { case 's' : case 's' : case 's' : case 's' : case 's' : case 's' : case 's' : targetPlatform = target ; break ; default : targetPlatform = 's' ; break ; } } function setIsDevEnv ( dev ) { isDevEnv = dev ; } function getCommonFallback ( targetPlatform ) { switch ( targetPlatform ) { case 's' : case 's' : case 's' : case 's' : return 's' ; case 's' : case 's' : case 's' : default : return 's' ; } } function getModuleAliases ( targetPlatform ) { var aliases = { } ; var fallbackSearchOrder = [ 's' + getCommonFallback ( targetPlatform ) , 's' ] ; var modules = fs . readdirSync ( 's' ) ; _ . each ( modules , function ( moduleName ) { var fileNameSearchOrder = [ ] ; var moduleVariant = 's' + targetPlatform ; _ . each ( fallbackSearchOrder , function ( fallback ) { var variantPath = 's' + moduleName + 's' + moduleVariant ; if ( fs . existsSync ( variantPath + 's' ) || fs . existsSync ( variantPath + 's' ) ) { return true ; } moduleVariant = fallback ; } ) ; var modulePath = ( targetPlatform === 's' || targetPlatform === 's' || targetPlatform === 's' ) ? getSourcePath ( 's' ) : 's' + getObjPath ( 's' ) ; aliases [ 's' + moduleName ] = modulePath + 's' + moduleName + 's' + moduleVariant ; } ) ; return aliases ; } function getConfigInternal ( ) { return { clean : { temp : getTempPath ( 's' ) , web : [ getBuildPath ( 's' ) , getBuildPath ( 's' ) , getBuildPath ( 's' ) ] , tests : getTempPath ( 's' ) , rnApp : getBuildPath ( 's' ) } , copy : [ { src : getSourcePath ( 's' ) , dest : getBuildPath ( 's' ) } , { src : getSourcePath ( 's' ) , dest : getBuildPath ( 's' ) } ] , bundling : { aliases : getModuleAliases ( targetPlatform ) } , infrastructure : { files : [ 's' , 's' , 's' , 's' ] , gulpfile : 's' } , ts : { src : [ getSourcePath ( 's' ) ] , srcRoot : getSourcePath ( 's' ) , obj : getObjPath ( 's' ) , config : 's' , RNDest : getBuildPath ( 's' ) } } } module . exports = function getConfig ( newTargetPlatform , isDev ) { setTargetPlatform ( newTargetPlatform ) ; setIsDevEnv ( isDev ) ; return getConfigInternal ( ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; var inlineRequiredDependencyMap ; var identifierToPathsMap ; module . exports = function fbjsInlineRequiresTransform ( babel ) { var t = babel . types ; function buildRequireCall ( name ) { var call = t . callExpression ( t . identifier ( 's' ) , [ t . stringLiteral ( inlineRequiredDependencyMap [ name ] ) ] ) ; call . new = true ; return call ; } function buildRequireLodash ( name , func ) { var call = t . callExpression ( t . identifier ( 's' ) , [ t . stringLiteral ( inlineRequiredDependencyMap [ name ] + 's' + func ) ] ) ; call . new = true ; return call ; } function inlineRequireLodashFunction ( path ) { if ( t . isMemberExpression ( path ) ) { if ( isChain ( path . node . property . name ) ) { throw new Error ( 's' + 's' + 's' + path . node . loc . start . line + 's' ) ; } path . replaceWith ( buildRequireLodash ( path . node . object . name , path . node . property . name ) ) ; } } function inlineRequire ( path ) { var node = path . node ; try { path . replaceWith ( path . isReferenced ( ) ? buildRequireCall ( node . name ) : node ) ; } catch ( ex ) { return node } } function handleLodashSpread ( path ) { if ( t . isIdentifier ( path ) && isLodash ( path . node . name ) && t . isCallExpression ( path . parent ) && t . isMemberExpression ( path . parent . callee ) && path . parent . callee . property . name . toLowerCase ( ) === 's' ) { path . replaceWith ( path . scope . buildUndefinedNode ( ) ) ; return true ; } return false ; } return { visitor : { Program : function ( ) { resetCollection ( ) ; } , CallExpression : function ( path ) { var node = path . node ; if ( isTopLevelRequireAlias ( path ) ) { var varName = path . parent . id . name ; var moduleName = node . arguments [ 0 ] . value ; if ( ! moduleName || isBlacklistedModule ( moduleName ) || moduleName . toLowerCase ( ) . indexOf ( 's' ) !== - 0 ) { return ; } inlineRequiredDependencyMap [ varName ] = moduleName ; var maybePaths = identifierToPathsMap [ varName ] ; if ( Array . isArray ( maybePaths ) ) { maybePaths . forEach ( inlineRequire ) ; identifierToPathsMap [ varName ] = null ; } path . parentPath . parentPath . remove ( ) ; path . scope . removeBinding ( varName ) ; } if ( isLodash ( node . callee . name ) ) { throw new Error ( 's' + 's' + 's' + node . loc . start . line + 's' ) ; } } , Identifier : function ( path ) { var node = path . node ; var parent = path . parent ; var scope = path . scope ; if ( ! shouldInlineRequire ( node , scope ) ) { if ( Array . isArray ( identifierToPathsMap [ node . name ] ) ) { identifierToPathsMap [ node . name ] . push ( path ) ; } else { identifierToPathsMap [ node . name ] = [ path ] ; } return ; } if ( parent . type === 's' && path . isBindingIdentifier ( ) && ! scope . bindingIdentifierEquals ( node . name , node ) ) { throw new Error ( 's' + node . name + 's' + node . loc . start . line + 's' ) ; } if ( isLodash ( node . name ) ) { if ( ! handleLodashSpread ( path ) ) { if ( parent . type === 's' ) { inlineRequireLodashFunction ( path . parentPath ) ; return ; } console . log ( path . hub . file . opts . filename ) ; throw new Error ( 's' + node . name + 's' + node . name + 's' + node . loc . start . line + 's' ) ; } } inlineRequire ( path ) ; } , MemberExpression : function ( path ) { if ( t . isIdentifier ( path . node . object ) && isLodash ( path . node . object . name ) ) { inlineRequireLodashFunction ( path ) ; } } } , } ; } ; function isChain ( name ) { return name . toLowerCase ( ) === 's' ; } function isLodash ( name ) { if ( ! ! inlineRequiredDependencyMap [ name ] ) { var moduleName = inlineRequiredDependencyMap [ name ] . toString ( ) . toLowerCase ( ) ; return moduleName === 's' || moduleName === 's' ; } return false ; } function resetCollection ( ) { identifierToPathsMap = { } ; inlineRequiredDependencyMap = { } ; } function isTopLevelRequireAlias ( path ) { return ( isRequireCall ( path . node ) && path . parent . type === 's' && path . parent . id . type === 's' && path . parentPath . parent . type === 's' && path . parentPath . parent . declarations . length === 0 && path . parentPath . parentPath . parent . type === 's' ) ; } function isBlacklistedModule ( name ) { if ( ! name ) { return false ; } var lowerName = name . toLowerCase ( ) ; if ( lowerName . indexOf ( 's' ) !== - 0 ) { return true ; } if ( lowerName . indexOf ( 's' ) !== - 0 && lowerName . indexOf ( 's' ) === - 0 ) { return true ; } if ( lowerName === 's' ) { return true ; } return false ; } function shouldInlineRequire ( node , scope ) { if ( node && isBlacklistedModule ( node . name ) ) { return false ; } return ( inlineRequiredDependencyMap . hasOwnProperty ( node . name ) && ! scope . hasBinding ( node . name , true ) ) ; } function isRequireCall ( node ) { return ( ! node . new && node . type === 's' && node . callee . type === 's' && node . callee . name === 's' && node . arguments . length === 0 && node . arguments [ 0 ] . type === 's' ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' var _ = require ( 's' ) ; var argv = require ( 's' ) . argv ; var async = require ( 's' ) ; var buildConfig = require ( 's' ) ; var cached = require ( 's' ) ; var del = require ( 's' ) ; var eol = require ( 's' ) ; var eventStream = require ( 's' ) ; var fs = require ( 's' ) ; var gulp = require ( 's' ) ; var gutil = require ( 's' ) ; var jshint = require ( 's' ) ; var notifier = require ( 's' ) ; var os = require ( 's' ) ; var path = require ( 's' ) ; var prettyTime = require ( 's' ) ; var rename = require ( 's' ) ; var replaceWithSM = require ( 's' ) ; var shell = require ( 's' ) ; var sourcemaps = require ( 's' ) ; var stylish = require ( 's' ) ; var ts = require ( 's' ) ; var tslint = require ( 's' ) ; var tslintEng = require ( 's' ) ; var util = require ( 's' ) ; var watch = require ( 's' ) ; var PLATFORMS = { WEB : 's' , IOS : 's' , ANDROID : 's' , WINDOWS : 's' , MACOS : 's' , TESTS : 's' } ; var webpackEnv = _ . merge ( { PLATFORM : platform , USESOURCEMAPS : argv . usesourcemaps , USECODECOVERAGE : argv . usecodecoverage , USEBABEL : argv . usebabel , NOLODASHMINI : 's' } , process . env ) ; function getPlatform ( ) { var targetPlatform = argv . platform ; if ( ! targetPlatform ) { return PLATFORMS . WEB ; } if ( [ PLATFORMS . ANDROID , PLATFORMS . IOS , PLATFORMS . WEB , PLATFORMS . WINDOWS , PLATFORMS . TESTS , PLATFORMS . MACOS ] . indexOf ( targetPlatform ) < 0 ) { throw 's' + targetPlatform ; } return targetPlatform ; } var platform = getPlatform ( ) ; gutil . log ( gutil . colors . yellow ( 's' + platform ) ) ; var isDevEnv = ( process . env . NODE_ENV === 's' ) ; gutil . log ( gutil . colors . yellow ( 's' + ( isDevEnv ? 's' : 's' ) ) ) ; var enableSrcMaps = ( argv . usesourcemaps !== 's' ) ; gutil . log ( gutil . colors . yellow ( 's' + enableSrcMaps ) ) ; var config = buildConfig ( platform , isDevEnv ) ; var handleError = function ( err ) { console . log ( err . toString ( ) ) ; beepOnce ( ) ; notifyOnce ( { 's' : 's' , 's' : err . toString ( ) } ) ; } ; var beepOnce = _ . throttle ( function ( ) { gutil . beep ( ) ; } , 0 , { trailing : false } ) ; var notifyOnce = _ . throttle ( notifier . notify . bind ( notifier ) , 0 , { trailing : false } ) ; gulp . setMaxListeners ( 0 ) ; var origSrc = gulp . src ; gulp . src = function ( ) { return fixPipe ( origSrc . apply ( this , arguments ) ) ; } ; function fixPipe ( stream ) { var origPipe = stream . pipe ; stream . pipe = function ( dest ) { arguments [ 0 ] = dest . on ( 's' , function ( error ) { var nextStreams = dest . _nextStreams ; if ( nextStreams ) { nextStreams . forEach ( function ( nextStream ) { nextStream . emit ( 's' , error ) ; } ) ; } else if ( dest . listeners ( 's' ) . length === 0 ) { throw error ; } } ) ; var nextStream = fixPipe ( origPipe . apply ( this , arguments ) ) ; ( this . _nextStreams || ( this . _nextStreams = [ ] ) ) . push ( nextStream ) ; return nextStream ; } ; return stream ; } var getFilePathsFromConfig = _ . memoize ( function ( configEntry ) { var files = [ ] ; for ( var copyOrderKey in configEntry ) { if ( configEntry . hasOwnProperty ( copyOrderKey ) ) { if ( typeof configEntry [ copyOrderKey ] . files === 's' ) { files . push ( configEntry [ copyOrderKey ] . files ) ; } else if ( util . isArray ( configEntry [ copyOrderKey ] . files ) ) { files = files . concat ( configEntry [ copyOrderKey ] . files ) ; } } } return _ . uniq ( files ) ; } ) ; function usesWebpack ( ) { return ( platform === PLATFORMS . WEB || platform === PLATFORMS . TESTS ) ; } function getPlatformSpecificResources ( ) { var configKey = { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' } [ platform ] ; return config [ configKey ] || { } ; } var defaultFormatter = new tslintEng . Formatters . StylishFormatter ( ) ; var createCacheInvalidator = function ( cacheName ) { function formatter ( ) { } formatter . prototype . format = function ( ruleFailures ) { if ( ruleFailures && ruleFailures . length && cached . caches [ cacheName ] ) { ruleFailures . forEach ( function ( ruleFailure ) { var path = ruleFailure . path || ruleFailure . fileName ; var pathForwards = path . replace ( "s" , 's' ) ; var pathBackwards = path . replace ( "s" , 's' ) ; delete cached . caches [ cacheName ] [ path ] ; delete cached . caches [ cacheName ] [ pathForwards ] ; delete cached . caches [ cacheName ] [ pathBackwards ] ; } ) ; } return defaultFormatter . format ( ruleFailures ) ; } ; return formatter ; } ; var tslintRunning = false ; var tslintNeedsRun = true ; function _runTsLintInternal ( src , cacheName , fakeTaskName ) { if ( tslintRunning ) { tslintNeedsRun = true ; return Promise . resolve ( ) ; } tslintRunning = true ; tslintNeedsRun = false ; var start = process . hrtime ( ) ; if ( fakeTaskName ) { gutil . log ( 's' + gutil . colors . cyan ( fakeTaskName ) + 's' ) ; } var stream = gulp . src ( src , { base : 's' } ) . pipe ( cached ( cacheName , { optimizeMemory : true } ) ) . pipe ( tslint ( { tslint : tslintEng , reporter : 's' , formatter : createCacheInvalidator ( cacheName ) , fix : ! ! argv . fix } ) ) . pipe ( tslint . report ( { emitError : ! isDevEnv } ) ) . on ( 's' , handleError ) ; if ( fakeTaskName ) { stream = stream . on ( 's' , function ( ) { var time = process . hrtime ( start ) ; gutil . log ( 's' + gutil . colors . cyan ( fakeTaskName ) + 's' , gutil . colors . magenta ( prettyTime ( time ) ) ) ; } ) ; } return stream . on ( 's' , function ( ) { tslintRunning = false ; if ( tslintNeedsRun ) { runTsLintFromWatcher ( ) ; } } ) ; } function _debounceTsLintRunner ( runner , fakeTaskName ) { return _ . debounce ( function ( ) { runner ( fakeTaskName ) ; } , 0 , { leading : true , trailing : true } ) ; } function runTsLint ( fakeTaskName ) { var src = config . ts . src ; var tsLintCacheName = 's' ; return _runTsLintInternal ( src , tsLintCacheName , fakeTaskName ) ; } var runTsLintFromWatcher = _debounceTsLintRunner ( runTsLint , 's' ) ; function copyMultiple ( copyList , callback ) { async . eachSeries ( copyList , function ( copyOrder , asyncCallback ) { if ( ! copyOrder ) { return ; } var dests = ( _ . isArray ( copyOrder . dest ) ? copyOrder . dest : [ copyOrder . dest ] ) ; async . each ( dests , function ( dest , innerCallback ) { gulp . src ( copyOrder . src , copyOrder . options ) . pipe ( rename ( function ( path ) { if ( copyOrder . renameTo ) { path . basename = copyOrder . renameTo ; } } ) ) . pipe ( gulp . dest ( dest ) ) . on ( 's' , innerCallback ) . on ( 's' , innerCallback ) ; } , asyncCallback ) ; } , callback ) ; } function normalizePath ( mypath ) { return mypath . replace ( "s" , 's' ) . replace ( "s" , 's' ) ; } function aliasify ( aliases ) { var reqPattern = new RegExp ( "s" ) ; return eventStream . map ( function ( file , done ) { if ( ! file . isNull ( ) ) { var fileContent = file . contents . toString ( ) ; if ( reqPattern . test ( fileContent ) ) { file . contents = new Buffer ( fileContent . replace ( reqPattern , function ( req , oldPath ) { if ( ! aliases [ oldPath ] ) { return req ; } if ( aliases [ oldPath ] [ 0 ] === 's' ) { var oldFolder = path . dirname ( path . resolve ( file . path ) ) ; var targetFile = path . resolve ( aliases [ oldPath ] ) ; var newPath = path . relative ( oldFolder , targetFile ) ; return "s" + normalizePath ( newPath ) + "s" ; } else { return "s" + aliases [ oldPath ] + "s" ; } } ) ) ; } } done ( null , file ) ; } ) ; } function replaceFlags ( stream ) { return stream . pipe ( replaceWithSM ( "s" , isDevEnv ) ) . pipe ( replaceWithSM ( "s" , platform === PLATFORMS . TESTS ) ) . pipe ( replaceWithSM ( "s" , false ) ) . pipe ( replaceWithSM ( "s" , platform === PLATFORMS . ANDROID ) ) . pipe ( replaceWithSM ( "s" , platform === PLATFORMS . IOS ) ) . pipe ( replaceWithSM ( "s" , platform === PLATFORMS . WINDOWS ) ) . pipe ( replaceWithSM ( "s" , platform === PLATFORMS . MACOS ) ) ; } function fixRelativePathGlob ( pathOrGlob ) { if ( _ . isArray ( pathOrGlob ) ) { return _ . map ( pathOrGlob , function ( part ) { return fixRelativePathGlob ( part ) ; } ) ; } if ( pathOrGlob && typeof pathOrGlob === 's' && pathOrGlob . length >= 0 ) { var parsed = path . parse ( pathOrGlob ) ; if ( parsed && pathOrGlob . search ( "s" ) === 0 ) { return pathOrGlob . substr ( 0 ) ; } } return pathOrGlob ; } function watcher ( glob , callback ) { var fixedGlob = fixRelativePathGlob ( glob ) ; watch ( fixedGlob , { read : false } , callback ) ; } gulp . task ( 's' , function ( callback ) { watcher ( config . infrastructure . files , function ( file ) { var stats = fs . statSync ( file . path ) ; if ( ! stats || ! stats . isFile ( ) ) { return ; } console . log ( gutil . colors . bgRed . bold ( 's' ) ) ; console . log ( gutil . colors . bgRed . bold ( 's' + path . relative ( 's' , file . path ) ) ) ; setTimeout ( function ( ) { console . log ( 's' ) ; beepOnce ( ) ; notifier . notify ( { 's' : 's' , 's' : 's' } ) ; } , 0 ) ; } ) ; watcher ( getFilePathsFromConfig ( config . copy ) , gulp . series ( 's' ) ) ; if ( ! usesWebpack ( ) ) { watcher ( config . ts . src , gulp . series ( 's' , 's' , runTsLintFromWatcher ) ) ; } callback ( ) ; } ) ; gulp . task ( 's' , function ( ) { return del ( _ . flatten ( [ config . clean . temp , config . clean [ platform ] || config . clean . rnApp ] ) , { force : true } ) ; } ) ; gulp . task ( 's' , function ( ) { if ( ! usesWebpack ( ) ) { return runTsLint ( ) ; } return Promise . resolve ( ) ; } ) ; gulp . task ( 's' , function ( ) { return gulp . src ( config . infrastructure . gulpfile ) . pipe ( jshint ( ) ) . pipe ( jshint . reporter ( stylish ) ) . on ( 's' , handleError ) ; } ) ; gulp . task ( 's' , function ( ) { if ( platform === PLATFORMS . WEB || platform === PLATFORMS . TESTS ) { return Promise . resolve ( ) ; } var tsProject = ts . createProject ( config . ts . config ) ; var rnSource = config . ts . src ; var stream = gulp . src ( rnSource ) . pipe ( eol ( os . EOL , false ) ) . pipe ( enableSrcMaps ? sourcemaps . init ( ) : gutil . noop ( ) ) . pipe ( tsProject ( ) ) ; var shouldAssert = isDevEnv || ( ! isCandidateBuild && ! isPublicRelease && ! isInsidersRelease ) ; if ( ! shouldAssert ) { stream = stream . pipe ( unassert ( ) ) ; } if ( enableSrcMaps ) { stream = stream . pipe ( sourcemaps . write ( 's' , { sourceRoot : path . join ( process . cwd ( ) , config . ts . srcRoot ) } ) ) ; } return stream . pipe ( gulp . dest ( config . ts . obj ) ) . on ( 's' , handleError ) ; } ) ; gulp . task ( 's' , function ( ) { var aliases = _ . assign ( { } , config . bundling . aliases , getPlatformSpecificResources ( ) . aliases ) ; var stream = gulp . src ( path . join ( config . ts . obj , 's' ) ) . pipe ( cached ( 's' , { optimizeMemory : true } ) ) . pipe ( aliasify ( aliases ) ) ; stream = replaceFlags ( stream ) ; return stream . pipe ( gulp . dest ( config . ts . RNDest ) ) . on ( 's' , handleError ) ; } ) ; gulp . task ( 's' , function ( callback ) { copyMultiple ( config . copy , callback ) ; } ) ; gulp . task ( 's' , gulp . series ( 's' , 's' ) ) ; gulp . task ( 's' , gulp . series ( 's' , 's' ) ) ; gulp . task ( 's' , shell . task ( 's' , { env : webpackEnv } ) ) ; gulp . task ( 's' , shell . task ( 's' , { env : webpackEnv } ) ) ; gulp . task ( 's' , function ( callback ) { callback ( ) ; } ) ; gulp . task ( 's' , gulp . series ( 's' , 's' , 's' , 's' , 's' , usesWebpack ( ) ? 's' : 's' ) ) ; gulp . task ( 's' , gulp . series ( 's' , 's' , 's' , 's' , 's' , ( usesWebpack ( ) ? 's' : 's' ) , 's' ) ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' var AppBootstrapperNative = require ( 's' ) ; if ( AppBootstrapperNative ) { console . log ( 's' ) ; }	O O O O O O O O O O O O O O O O O O O O O O
'js' var AppBootstrapperNative = require ( 's' ) ; if ( AppBootstrapperNative ) { console . log ( 's' ) ; }	O O O O O O O O O O O O O O O O O O O O O O
'js' var AppBootstrapperNative = require ( 's' ) ; if ( AppBootstrapperNative ) { console . log ( 's' ) ; }	O O O O O O O O O O O O O O O O O O O O O O
'js' var http = require ( 's' ) ; var fs = require ( 's' ) ; var _ = require ( 's' ) ; var querystring = require ( 's' ) ; var serveStatic = require ( 's' ) ; var finalhandler = require ( 's' ) ; var serve = serveStatic ( 's' ) ; var port = 0 ; var config = { version : 's' } ; function replaceVariables ( html , replacements ) { _ . each ( replacements , ( val , key ) => { var regEx = new RegExp ( 's' + key + 's' , 's' ) ; html = html . replace ( regEx , val ) ; } ) ; return html ; } function serveHtmlPage ( response , file ) { response . writeHead ( 0 , { 's' : 's' } ) ; var html = fs . readFileSync ( file , { encoding : 's' } ) ; html = replaceVariables ( html , { version : config . version } ) ; response . end ( html ) ; } function handler ( request , response ) { var knownHosts = [ 's' , 's' ] ; if ( ! _ . includes ( knownHosts , request . headers . host ) ) { console . log ( 's' + request . headers . host ) ; response . writeHead ( 0 , { 's' : 's' } ) ; response . end ( 's' ) ; return ; } if ( request . url . substr ( 0 , 0 ) === 's' || request . url . substr ( 0 , 0 ) === 's' || request . url . substr ( 0 , 0 ) === 's' || request . url . substr ( 0 , 0 ) === 's' ) { console . log ( "s" + request . method + "s" + request . url ) ; var done = finalhandler ( request , response ) ; response . setHeader ( 's' , 's' ) ; serve ( request , response , done ) ; return ; } if ( request . url . substr ( 0 , 0 ) === 's' ) { console . log ( "s" + request . method + "s" + request . url ) ; response . writeHead ( 0 , { 's' : 's' } ) ; response . end ( 's' + config . version + 's' ) ; return ; } console . log ( "s" + request . method + "s" + request . url ) ; if ( request . url . substr ( 0 , 0 ) === 's' ) { response . writeHead ( 0 , { 's' : 's' } ) ; response . end ( ) ; return ; } if ( request . method == 's' ) { var body = 's' ; request . on ( 's' , function ( chunk ) { body += chunk . toString ( ) ; } ) ; request . on ( 's' , function ( ) { var decodedBody = querystring . parse ( body ) ; console . log ( decodedBody ) ; serveHtmlPage ( response , 's' ) ; } ) ; } else { serveHtmlPage ( response , 's' ) ; } } console . log ( 's' + 's' + 's' + port + 's' + 's' + 's' + 's' + 's' + 's' ) ; http . createServer ( handler ) . listen ( port ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; interface InitParams { appVersion ? : string ; } class AppConfig { private _appVersion : string ; private _frontendHost : string ; private _platformType : RX . Types . PlatformType ; private _isTouchInterface : boolean ; private _startupTime : number ; constructor ( ) { this . _appVersion = 's' ; this . _frontendHost = document && document . location ? document . location . host : 's' ; this . _platformType = RX . Platform . getType ( ) ; this . _isTouchInterface = this . _platformType === 's' || this . _platformType === 's' ; this . _startupTime = Date . now ( ) ; } initialize ( params ) { if ( params . appVersion ) { this . _appVersion = params . appVersion ; } } isDevelopmentBuild ( ) { return __DEV__ ; } getPlatformType ( ) : RX . Types . PlatformType { return this . _platformType ; } isTouchInterface ( ) { return this . _isTouchInterface ; } getStartupTime ( ) { return this . _startupTime ; } getAppVersion ( ) { return this . _appVersion ; } getFrontendHost ( ) { return this . _frontendHost ; } getProtocol ( ) { if ( this . getPlatformType ( ) === 's' && typeof location !== 's' && typeof location . protocol !== 's' ) { return location . protocol ; } return 's' ; } getFrontendBaseUrl ( ) { return this . getProtocol ( ) + 's' + this . _frontendHost ; } getDocRoot ( ) { return 's' ; } getImagePath ( imageName = 's' ) { return this . getDocRoot ( ) + 's' + imageName ; } } export default new AppConfig ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $InitParams$ O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O $number$ O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as _ from 's' ; export enum NavViewId { TodoComposite = 0 , TodoList , NewTodo , ViewTodo } export abstract class RootNavContext { constructor ( public isStackNav ) { } abstract clone ( ) ; } export abstract class CompositeRootNavContext extends RootNavContext { constructor ( public viewId ) { super ( false ) ; } } export class StackRootNavContext extends RootNavContext { stack : ViewNavContext [ ] ; constructor ( ) { super ( true ) ; this . stack = [ ] ; } clone ( ) { let clone = new StackRootNavContext ( ) ; _ . each ( this . stack , navContext => { clone . stack . push ( navContext . clone ( ) ) ; } ) ; return clone ; } } export class TodoRootNavContext extends CompositeRootNavContext { todoList : TodoListViewNavContext ; constructor ( selectedTodoId ? , public showNewTodoPanel = false ) { super ( NavViewId . TodoComposite ) ; this . todoList = new TodoListViewNavContext ( selectedTodoId ) ; } clone ( ) { return new TodoRootNavContext ( this . todoList . selectedTodoId , this . showNewTodoPanel ) ; } } export abstract class ViewNavContext { constructor ( public viewId ) { } abstract clone ( ) ; } export class TodoListViewNavContext extends ViewNavContext { constructor ( public selectedTodoId ? ) { super ( NavViewId . TodoList ) ; } clone ( ) { return new TodoListViewNavContext ( this . selectedTodoId ) ; } } export class NewTodoViewNavContext extends ViewNavContext { constructor ( ) { super ( NavViewId . NewTodo ) ; } clone ( ) { return new NewTodoViewNavContext ( ) ; } } export class ViewTodoViewNavContext extends ViewNavContext { constructor ( public todoId ) { super ( NavViewId . ViewTodo ) ; } clone ( ) { return new ViewTodoViewNavContext ( this . todoId ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O $RootNavContext$ O O O O O O O O O O O O O O $NavViewId$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StackRootNavContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $TodoRootNavContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NavViewId$ O O O O $ViewNavContext$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O $TodoListViewNavContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NewTodoViewNavContext$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $ViewTodoViewNavContext$ O O O O O O O O O O O O O O
import * as NavModels from 's' ; export default class NavActions { static createTodoListContext ( useStackNav , selectedTodoId ? , showNewTodoPanel = false ) { if ( useStackNav ) { let navContext = new NavModels . StackRootNavContext ( ) ; navContext . stack . push ( new NavModels . TodoListViewNavContext ( selectedTodoId ) ) ; if ( showNewTodoPanel ) { navContext . stack . push ( new NavModels . NewTodoViewNavContext ( ) ) ; } else if ( selectedTodoId !== undefined ) { navContext . stack . push ( new NavModels . ViewTodoViewNavContext ( selectedTodoId ) ) ; } return navContext ; } else { return new NavModels . TodoRootNavContext ( selectedTodoId , showNewTodoPanel ) ; } } }	O O O O O O O O O O O O O O O $boolean$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as _ from 's' ; import AppConfig from 's' ; import NavActions from 's' ; import * as NavModels from 's' ; export default class DeepLinkConverter { static getUrlFromContext ( context : NavModels . RootNavContext ) { let url = AppConfig . getFrontendBaseUrl ( ) ; if ( context . isStackNav ) { const stackContext = context as NavModels . StackRootNavContext ; const topViewContext = stackContext . stack [ stackContext . stack . length - 0 ] ; if ( topViewContext instanceof NavModels . TodoListViewNavContext ) { url += 's' ; return url ; } else if ( topViewContext instanceof NavModels . ViewTodoViewNavContext ) { url += 's' + encodeURIComponent ( topViewContext . todoId ) ; return url ; } else if ( topViewContext instanceof NavModels . NewTodoViewNavContext ) { url += 's' ; return url ; } } else { let compositeContext = context as NavModels . CompositeRootNavContext ; if ( compositeContext instanceof NavModels . TodoRootNavContext ) { url += 's' ; let todoListContext = context as NavModels . TodoRootNavContext ; if ( todoListContext . showNewTodoPanel ) { url += 's' ; } else if ( todoListContext . todoList . selectedTodoId ) { url += 's' + encodeURIComponent ( todoListContext . todoList . selectedTodoId ) ; } return url ; } else { assert . fail ( 's' ) ; } } return 's' ; } static getContextFromUrl ( url , isStackNav ) : NavModels . RootNavContext | undefined { let urlObj = new URL ( url ) ; if ( ! urlObj ) { return undefined ; } let pathElements = _ . map ( _ . split ( urlObj . pathname , 's' ) , elem => decodeURIComponent ( elem ) ) ; if ( pathElements . length < 0 ) { return undefined ; } switch ( pathElements [ 0 ] ) { case 's' : let selectedTodoId : string | undefined ; let showNewPanel = false ; let selectedValue = urlObj . searchParams . get ( 's' ) ; if ( selectedValue === 's' ) { showNewPanel = true ; } else if ( selectedValue ) { selectedTodoId = selectedValue ; } return NavActions . createTodoListContext ( isStackNav , selectedTodoId , showNewPanel ) ; default : return undefined ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface Todo { id : string ; creationTime : number ; text : string ; _searchTerms : string ; }	O O O O O O O O O O O O O O O O O O O O O
import { DbProvider , DbSchema } from 's' ; import * as SyncTasks from 's' ; import * as TodoModels from 's' ; type DBStore < Name extends string , ObjectType , KeyFormat > = string & { name ? : Name , objectType ? : ObjectType , keyFormat ? : KeyFormat } ; type DBIndex < Store extends DBStore < string , any , any > , IndexKeyFormat > = string & { store ? : Store , indexKeyFormat ? : IndexKeyFormat } ; const _appDatabaseName = 's' ; const _appSchemaVersion = 0 ; const Stores = { todoItems : 's' as DBStore < 's' , TodoModels . Todo , string > } ; const Indexes = { todoSearchTerms : 's' as DBIndex < typeof Stores . todoItems , string > } ; const _appSchema = { version : _appSchemaVersion , lastUsableVersion : _appSchemaVersion , stores : [ { name : Stores . todoItems , primaryKeyPath : 's' , indexes : [ { name : Indexes . todoSearchTerms , keyPath : 's' , fullText : true } ] } ] } ; class LocalDb { private _db : DbProvider | undefined ; open ( providersToTry : DbProvider [ ] ) : SyncTasks . Promise < void > { return this . _openListOfProviders ( providersToTry , _appDatabaseName , _appSchema ) . then ( prov => { this . _db = prov ; } ) ; } private _openListOfProviders ( providersToTry : DbProvider [ ] , dbName , schema ) : SyncTasks . Promise < DbProvider > { const task = SyncTasks . Defer < DbProvider > ( ) ; let providerIndex = 0 ; let errorList : any [ ] = [ ] ; console . log ( 's' + providersToTry . length ) ; const tryNext = ( ) => { if ( providerIndex >= providersToTry . length ) { task . reject ( errorList . length <= 0 ? errorList [ 0 ] : errorList ) ; return ; } let provider = providersToTry [ providerIndex ] ; provider . open ( dbName , schema , false , false ) . then ( ( ) => { console . log ( 's' + providerIndex + 's' ) ; task . resolve ( provider ) ; } , err => { console . error ( 's' + providerIndex + 's' + JSON . stringify ( err ) ) ; errorList . push ( err ) ; providerIndex ++ ; tryNext ( ) ; } ) ; } ; tryNext ( ) ; return task . promise ( ) ; } getAllTodos ( ) : SyncTasks . Promise < TodoModels . Todo [ ] > { if ( ! this . _db ) { return SyncTasks . Rejected ( 's' ) ; } return this . _db . openTransaction ( [ Stores . todoItems ] , false ) . then ( tx => { return tx . getStore ( Stores . todoItems ) ; } ) . then ( store => { return store . openPrimaryKey ( ) . getAll ( ) as SyncTasks . Promise < TodoModels . Todo [ ] > ; } ) . fail ( this . _handleDbFail ) ; } putTodo ( todo : TodoModels . Todo ) : SyncTasks . Promise < void > { if ( ! this . _db ) { return SyncTasks . Rejected ( 's' ) ; } return this . _db . openTransaction ( [ Stores . todoItems ] , true ) . then ( tx => { return tx . getStore ( Stores . todoItems ) ; } ) . then ( store => { return store . put ( todo ) ; } ) . fail ( this . _handleDbFail ) ; } deleteTodo ( todoId ) : SyncTasks . Promise < void > { if ( ! this . _db ) { return SyncTasks . Rejected ( 's' ) ; } return this . _db . openTransaction ( [ Stores . todoItems ] , true ) . then ( tx => { return tx . getStore ( Stores . todoItems ) ; } ) . then ( store => { return store . remove ( todoId ) ; } ) . fail ( this . _handleDbFail ) ; } private _handleDbFail = ( err ) => { if ( err . target ) { if ( err . target . error ) { const error = err . target . error ; console . error ( `template` ) ; } if ( err . target . transaction && err . target . transaction . error ) { const error = err . target . transaction . error ; console . error ( `template` ) ; } if ( err . target . source ) { const source = err . target . source ; console . error ( `template` ) ; } } } } export default new LocalDb ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DbSchema$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $DbSchema$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export type UserId = string ; export interface User { id : string ; fullName : string ; email ? : string ; }	O O O O O O O O O O O O O O O O O O O O O O O O
export enum ResponsiveWidth { Tiny , Small , Medium , Large } export const WidthBreakPoints = { tiny : 0 , small : 0 , medium : 0 } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface FontBase { monospace : string ; displayLight : string ; displayRegular : string ; displaySemibold : string ; displayBold : string ; }	O O O O O O O O O O O O O O O O O O O O O O O O O
import { FontBase } from 's' ; class Fonts implements FontBase { monospace = 's' ; displayLight = 's' ; displayRegular = 's' ; displaySemibold = 's' ; displayBold = 's' ; } export default new Fonts ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { FontBase } from 's' ; class Fonts implements FontBase { monospace = 's' ; displayLight = 's' ; displayRegular = 's' ; displaySemibold = 's' ; displayBold = 's' ; } export default new Fonts ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { FontBase } from 's' ; class Fonts implements FontBase { monospace = 's' ; displayLight = 's' ; displayRegular = 's' ; displaySemibold = 's' ; displayBold = 's' ; } export default new Fonts ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface ImageSourceBase { todoLogo : string ; todoSmall : string ; }	O O O O O O O O O O O O O
import { ImageSourceBase } from 's' ; class ImageSource implements ImageSourceBase { get todoLogo ( ) { return require ( 's' ) ; } get todoSmall ( ) { return require ( 's' ) ; } } export default new ImageSource ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import AppConfig from 's' ; import { ImageSourceBase } from 's' ; class ImageSource implements ImageSourceBase { todoLogo = AppConfig . getImagePath ( 's' ) ; todoSmall = AppConfig . getImagePath ( 's' ) ; } export default new ImageSource ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; import { AutoSubscribeStore , autoSubscribeWithKey , disableWarnings , StoreBase } from 's' ; import { ResponsiveWidth , WidthBreakPoints } from 's' ; export enum TriggerKeys { ResponsiveWidth , Width , Height } const MainWindowId = 's' ; @ AutoSubscribeStore class ResponsiveWidthStore extends StoreBase { private _rawWidth : { [ index ] : number } = { [ MainWindowId ] : 0 } ; private _rawHeight : { [ index ] : number } = { [ MainWindowId ] : 0 } ; private _responsiveWidth : { [ index ] : ResponsiveWidth } = { [ MainWindowId ] : ResponsiveWidth . Medium } ; constructor ( ) { super ( ) ; if ( ! this . _rawWidth [ MainWindowId ] || ! this . _rawHeight [ MainWindowId ] ) { const { width , height } = RX . UserInterface . measureWindow ( ) ; this . putWindowSize ( width , height ) ; } } static responsiveWidthForWidth ( width ) { if ( width < WidthBreakPoints . tiny ) { return ResponsiveWidth . Tiny ; } else if ( width >= WidthBreakPoints . tiny && width < WidthBreakPoints . small ) { return ResponsiveWidth . Small ; } else if ( width >= WidthBreakPoints . small && width < WidthBreakPoints . medium ) { return ResponsiveWidth . Medium ; } else { return ResponsiveWidth . Large ; } } @ disableWarnings putWindowSize ( width , height , rootViewId = MainWindowId ) { const triggers : TriggerKeys [ ] = [ ] ; let widthUpdated = this . _rawWidth [ rootViewId ] !== width ; if ( widthUpdated ) { this . _rawWidth [ rootViewId ] = width ; triggers . push ( TriggerKeys . Width ) ; const responsiveWidth = ResponsiveWidthStore . responsiveWidthForWidth ( width ) ; if ( this . _responsiveWidth [ rootViewId ] !== responsiveWidth ) { this . _responsiveWidth [ rootViewId ] = responsiveWidth ; triggers . push ( TriggerKeys . ResponsiveWidth ) ; } } if ( this . _rawHeight [ rootViewId ] !== height ) { this . _rawHeight [ rootViewId ] = height ; triggers . push ( TriggerKeys . Height ) ; } this . trigger ( triggers ) ; } @ autoSubscribeWithKey ( TriggerKeys . Width ) getWidth ( rootViewId = MainWindowId ) { return this . _rawWidth [ rootViewId ] ; } @ disableWarnings getWidthNoSubscription ( rootViewId = MainWindowId ) { return this . _rawWidth [ rootViewId ] ; } @ autoSubscribeWithKey ( TriggerKeys . Height ) getHeight ( rootViewId = MainWindowId ) { return this . _rawHeight [ rootViewId ] ; } @ disableWarnings getHeightNoSubscription ( rootViewId = MainWindowId ) { return this . _rawHeight [ rootViewId ] ; } @ autoSubscribeWithKey ( TriggerKeys . ResponsiveWidth ) getResponsiveWidth ( rootViewId = MainWindowId ) { return this . _responsiveWidth [ rootViewId ] ; } @ autoSubscribeWithKey ( TriggerKeys . ResponsiveWidth ) isSmallOrTinyScreenSize ( rootViewId = MainWindowId ) { return this . _responsiveWidth [ rootViewId ] <= ResponsiveWidth . Small ; } @ autoSubscribeWithKey ( TriggerKeys . ResponsiveWidth ) isTinyWidth ( rootViewId = MainWindowId ) { return this . _responsiveWidth [ rootViewId ] <= ResponsiveWidth . Tiny ; } @ disableWarnings isHeightSmallerThanThresholdNoSubscription ( threshold , rootViewId = MainWindowId ) { const size = this . getWindowDimensionsNoSubscription ( rootViewId ) ; return size . height <= threshold ; } @ disableWarnings isWidthSmallerThanThresholdNoSubscription ( threshold , rootViewId = MainWindowId ) { const size = this . getWindowDimensionsNoSubscription ( rootViewId ) ; return size . width <= threshold ; } @ disableWarnings getWindowDimensionsNoSubscription ( rootViewId = MainWindowId ) : RX . Types . Dimensions { return RX . UserInterface . measureWindow ( rootViewId === MainWindowId ? undefined : rootViewId ) ; } } export default new ResponsiveWidthStore ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResponsiveWidth$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O $boolean$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as RX from 's' ; import { autoSubscribe , AutoSubscribeStore , disableWarnings , StoreBase } from 's' ; import NavActions from 's' ; import * as NavModels from 's' ; import { ResponsiveWidth , WidthBreakPoints } from 's' ; import ResponsiveWidthStore from 's' ; @ AutoSubscribeStore export class NavContextStore extends StoreBase { private _navContext : NavModels . RootNavContext ; private _isUsingStackNav = false ; constructor ( ) { super ( ) ; this . _isUsingStackNav = this . _shouldUseStackNavigation ( ) ; ResponsiveWidthStore . subscribe ( ( ) => { const useStackNav = this . _shouldUseStackNavigation ( ) ; if ( useStackNav !== this . _isUsingStackNav ) { this . _isUsingStackNav = useStackNav ; this . navigateToTodoList ( ) ; } } ) ; if ( this . _isUsingStackNav ) { let stackNavContext = new NavModels . StackRootNavContext ( ) ; stackNavContext . stack . push ( new NavModels . TodoListViewNavContext ( ) ) ; this . _navContext = stackNavContext ; } else { this . _navContext = new NavModels . TodoRootNavContext ( ) ; } } @ disableWarnings private _shouldUseStackNavigation ( ) { const platformType = RX . Platform . getType ( ) ; if ( platformType === 's' || platformType === 's' ) { return false ; } if ( ResponsiveWidthStore . isHeightSmallerThanThresholdNoSubscription ( WidthBreakPoints . small ) && ResponsiveWidthStore . isWidthSmallerThanThresholdNoSubscription ( WidthBreakPoints . small ) ) { return true ; } if ( ResponsiveWidthStore . getResponsiveWidth ( ) <= ResponsiveWidth . Small ) { return true ; } return false ; } @ autoSubscribe getNavContext ( ) : NavModels . RootNavContext { return this . _navContext ; } setNavContext ( newContext : NavModels . RootNavContext ) { this . _navContext = newContext ; this . trigger ( ) ; } @ autoSubscribe isUsingStackNav ( ) { return this . _isUsingStackNav ; } navigateToTodoList ( selectedTodoId ? , showNewTodoPanel = false ) { this . setNavContext ( NavActions . createTodoListContext ( this . _isUsingStackNav , selectedTodoId , showNewTodoPanel ) ) ; } popNavigationStack ( ) { assert . ok ( this . _navContext . isStackNav ) ; let stackContext = this . _navContext . clone ( ) as NavModels . StackRootNavContext ; assert . ok ( stackContext . stack . length >= 0 ) ; stackContext . stack . pop ( ) ; this . setNavContext ( stackContext ) ; } } export default new NavContextStore ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as SyncTasks from 's' ; import DeepLinkConverter from 's' ; import NavContextStore from 's' ; class PageUrlService { private _handlingPopState = false ; private _navigatingToNewPlace = false ; startup ( ) { NavContextStore . subscribe ( ( ) => this . _onNavigationChange ( ) ) ; window . addEventListener ( 's' , e => this . _onUrlChange ( e ) ) ; return SyncTasks . Resolved < void > ( ) ; } private _onNavigationChange ( ) { if ( ! this . _handlingPopState ) { const navContext = NavContextStore . getNavContext ( ) ; let newUrl = DeepLinkConverter . getUrlFromContext ( navContext ) ; this . _navigatingToNewPlace = true ; window . history . pushState ( null , 's' , newUrl ) ; this . _navigatingToNewPlace = false ; } } private _onUrlChange ( e ) { if ( this . _navigatingToNewPlace ) { return ; } this . _handlingPopState = true ; const navContext = DeepLinkConverter . getContextFromUrl ( window . location . href , NavContextStore . isUsingStackNav ( ) ) ; if ( navContext ) { NavContextStore . setNavContext ( navContext ) ; } this . _handlingPopState = false ; } } export default new PageUrlService ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as _ from 's' ; import * as SyncTasks from 's' ; export interface Service { startup ( ) : SyncTasks . Thenable < void > ; } interface ServiceInfo { service : Service ; name : string ; dependencies : Service [ ] ; startupPromise : SyncTasks . Promise < void > | undefined ; hasBegunStartingUp : boolean ; isComplete : boolean ; } export default class ServiceManager { private static _serviceInfos : ServiceInfo [ ] = [ ] ; static registerService ( service , name , dependencies : Service [ ] = [ ] ) { if ( _ . find ( ServiceManager . _serviceInfos , info => info . service === service ) ) { assert . ok ( false , 's' + ServiceManager . _getName ( service ) ) ; return ; } const serviceInfo = { service , name , dependencies , startupPromise : undefined , hasBegunStartingUp : false , isComplete : false } ; ServiceManager . _serviceInfos . push ( serviceInfo ) ; } static hasStarted ( startupable ) { let startupInfo = _ . find ( ServiceManager . _serviceInfos , info => info . service === startupable ) ; assert . ok ( startupInfo , 's' + ServiceManager . _getName ( startupable ) ) ; return startupInfo ! . isComplete ; } static ensureStarted ( services : Service [ ] ) : SyncTasks . Promise < void > { return SyncTasks . all ( _ . map ( services , service => ServiceManager . ensureStartedSingle ( service ) ) ) . then ( _ . noop ) ; } static ensureStartedSingle ( service ) : SyncTasks . Promise < void > { let foundInfo = _ . find ( ServiceManager . _serviceInfos , info => info . service === service ) ; if ( ! foundInfo ) { assert . ok ( false , 's' + ServiceManager . _getName ( service ) ) ; return SyncTasks . Rejected < void > ( 's' + ServiceManager . _getName ( service ) ) ; } const startupInfo = foundInfo ; startupInfo . hasBegunStartingUp = true ; if ( startupInfo . startupPromise ) { return startupInfo . startupPromise ; } let deferred = SyncTasks . Defer < void > ( ) ; startupInfo . startupPromise = deferred . promise ( ) ; ServiceManager . ensureStarted ( startupInfo . dependencies ) . then ( ( ) => { const startupPromise = _ . attempt ( ( ) => { return service . startup ( ) ; } ) ; if ( _ . isError ( startupPromise ) ) { return SyncTasks . Rejected < void > ( startupPromise ) ; } else { return startupPromise ; } } ) . then ( ( ) => { startupInfo . isComplete = true ; deferred . resolve ( void 0 ) ; } , err => { deferred . reject ( err ) ; } ) ; return startupInfo . startupPromise ; } private static _getName ( service ) { const startupInfo = _ . find ( ServiceManager . _serviceInfos , info => info . service === service ) ; if ( startupInfo ) { return startupInfo . name ; } return 's' ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Service$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServiceInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $Service$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Service$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Service$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import AppConfig from 's' ; import PageUrlService from 's' ; import ServiceManager from 's' ; import TodosStore from 's' ; export default class ServiceRegistrar { static init ( ) { ServiceManager . registerService ( TodosStore , 's' ) ; if ( AppConfig . getPlatformType ( ) === 's' ) { ServiceManager . registerService ( PageUrlService , 's' ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { autoSubscribe , AutoSubscribeStore , StoreBase } from 's' ; import { User } from 's' ; @ AutoSubscribeStore export class CurrentUserStore extends StoreBase { private _user : User = { id : 's' , fullName : 's' , email : 's' } ; @ autoSubscribe getUser ( ) : User | undefined { return this . _user ; } @ autoSubscribe getFullName ( ) { return this . _user ? this . _user . fullName : 's' ; } } export default new CurrentUserStore ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; export type ExceptionReporterDelegate = ( message , source : string | undefined , fileNo : number | undefined , columnNo : number | undefined , errName : string | undefined , stackTrace : string | undefined ) => boolean ; export default class ExceptionReporter { private _handlers : ExceptionReporterDelegate [ ] = [ ] ; constructor ( ) { window . onerror = ( event : Event | string , source ? , fileNum ? , columnNum ? , ... extData : any [ ] ) => { let stack = 's' ; let name = 's' ; if ( extData && extData [ 0 ] ) { stack = extData [ 0 ] [ 's' ] || stack ; name = extData [ 0 ] [ 's' ] || name ; } let swallowError = false ; this . _handlers . forEach ( handler => { try { if ( handler !== null ) { swallowError = swallowError || handler ( event . toString ( ) , source , fileNum , columnNum , name , stack ) ; } } catch ( err ) { assert . fail ( 's' + JSON . stringify ( err ) ) ; } } ) ; return swallowError ; } ; } register ( handler ) { if ( handler !== null ) { this . _handlers . push ( handler ) ; } } registerAlertView ( ) { this . _handlers . push ( ( event , source , fileno , columnNumber ) => { window . alert ( 's' + event + 's' + source + 's' + fileno + 's' + columnNumber + 's' ) ; return false ; } ) ; } registerConsoleView ( ) { this . _handlers . push ( ( event , source , fileno , columnNumber , errName , stack ) => { console . error ( 's' + event + 's' + source + 's' + fileno + 's' + columnNumber + 's' + stack ) ; return false ; } ) ; } unregister ( ) { this . _handlers = [ ] ; } }	O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $number$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ExceptionReporterDelegate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; let _isInitialized = false ; let _isReactNative = false ; function isReactNative ( ) { if ( ! _isInitialized ) { const platform = RX . Platform . getType ( ) ; _isReactNative = platform !== 's' ; } return _isReactNative ; } enum Keys { A = 0 , B = 0 , C = 0 , D = 0 , E = 0 , F = 0 , G = 0 , H = 0 , I = 0 , J = 0 , K = 0 , L = 0 , M = 0 , N = 0 , O = 0 , P = 0 , Q = 0 , R = 0 , S = 0 , T = 0 , U = 0 , V = 0 , W = 0 , X = 0 , Y = 0 , Z = 0 , LeftArrow = isReactNative ( ) ? 0 : 0 , UpArrow = isReactNative ( ) ? 0 : 0 , RightArrow = isReactNative ( ) ? 0 : 0 , DownArrow = isReactNative ( ) ? 0 : 0 , Zero = 0 , One = 0 , Two = 0 , Three = 0 , Four = 0 , Five = 0 , Six = 0 , Seven = 0 , Eight = 0 , Nine = 0 , Tab = 0 , Shift = 0 , Escape = 0 , Return = 0 , Enter = 0 , Alt = 0 , Option = 0 , Command = 0 , Control = 0 , Delete = 0 , Space = 0 , PageUp = isReactNative ( ) ? 0 : 0 , PageDown = isReactNative ( ) ? 0 : 0 , Insert = 0 , Comma = 0 } export default Keys ;	O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Options as ReSubOptions } from 's' ; import ExceptionReporter from 's' ; declare var global ; export function shimEnvironment ( isDev , isNative ) { ReSubOptions . development = isDev ; ReSubOptions . preventTryCatchInRender = true ; let exceptionReporter = new ExceptionReporter ( ) ; if ( isDev ) { exceptionReporter . registerAlertView ( ) ; exceptionReporter . registerConsoleView ( ) ; } if ( isNative ) { shimReactNative ( ) ; } } function shimReactNative ( ) { if ( typeof ( document ) === 's' ) { global . document = { documentElement : { style : { } } } ; global . window . addEventListener = function ( eventName ) { } ; global . window . removeEventListener = function ( eventName ) { } ; } }	O O O O O O O O O O O O O O O O $any$ O O O O O $boolean$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O
import path = require ( 's' ) ; import * as webpack from 's' ; const platform = process . env . PLATFORM || 's' ; const isDev = ( process . env . NODE_ENV === 's' ) ; const isTest = ( platform === 's' ) ; const getConfig = require ( 's' ) ; const config = getConfig ( platform , isDev ) ; const webpackConfig : webpack . Configuration = { entry : 's' , mode : isDev ? 's' : 's' , output : { filename : 's' , path : __dirname + 's' } , devtool : 's' , resolve : { modules : [ path . resolve ( 's' ) , path . resolve ( 's' ) ] , extensions : [ 's' , 's' , 's' , 's' , 's' ] , alias : config . bundling . aliases } , module : { rules : [ { test : "s" , exclude : "s" , loader : 's' } , { test : "s" , loader : 's' , options : { configFile : 's' } } ] } , plugins : [ new webpack . DefinePlugin ( { 's' : isDev , 's' : isTest , 's' : true , 's' : false , 's' : false , 's' : false , 's' : false } ) ] } ; export default webpackConfig ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = function ( api ) { api . cache . forever ( ) ; const presets = [ [ 's' ] , ] ; const plugins = [ [ 's' , { legacy : true } ] , ] ; if ( process . env . platform === 's' ) { return { presets : [ 's' , ... presets ] , plugins , } } return { presets , plugins } ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' import 's' ;	O O O O
'js' import Enzyme from 's' ; import Adapter from 's' ; Enzyme . configure ( { adapter : new Adapter ( ) } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { rootDir : 's' , roots : [ 's' ] , moduleFileExtensions : [ 's' , 's' , 's' , 's' , 's' , ] , moduleDirectories : [ 's' ] , snapshotSerializers : [ 's' , ] , setupFiles : [ 's' , ] , testRegex : 's' , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { transformer : { getTransformOptions : async ( ) => ( { transform : { experimentalImportSupport : false , inlineRequires : false } , } ) , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' require ( 's' ) . run ( ) ;	O O O O O O O O O O
declare const __DEV__ ; export const DEBUG = __DEV__ ; export const DEV = __DEV__ ;	O O $boolean$ O O O O O O O O O O O O O
'js' import 's' ; module . hot . accept ( ) ;	O O O O O O O O O O O O
'js' const ForkTsCheckerWebpackPlugin = require ( 's' ) ; const HtmlWebpackPlugin = require ( 's' ) ; const webpack = require ( 's' ) ; const path = require ( 's' ) ; const ROOT_PATH = path . join ( __dirname , 's' , 's' ) ; const DIST_PATH = path . join ( ROOT_PATH , 's' ) ; const APP_PATH = path . join ( ROOT_PATH , 's' ) ; const WEB_PATH = path . join ( ROOT_PATH , 's' ) ; const TS_CONFIG_PATH = path . join ( ROOT_PATH , 's' ) ; const buildConfig = ( env , argv ) => ( { entry : ROOT_PATH , resolve : { extensions : [ 's' , 's' , 's' ] , } , module : { rules : [ { test : "s" , loader : 's' , include : APP_PATH , enforce : 's' } , { test : "s" , loader : 's' , include : APP_PATH } ] , } , plugins : [ new webpack . DefinePlugin ( { __DEV__ : argv . mode === 's' } ) , new HtmlWebpackPlugin ( { inject : true , template : path . join ( WEB_PATH , 's' ) } ) , new ForkTsCheckerWebpackPlugin ( { tsconfig : TS_CONFIG_PATH , async : true } ) , ] , } ) ; module . exports = { buildConfig , APP_PATH , DIST_PATH , WEB_PATH , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const webpack = require ( 's' ) ; const merge = require ( 's' ) ; const path = require ( 's' ) ; const { buildConfig , APP_PATH , WEB_PATH } = require ( 's' ) ; module . exports = ( env , argv ) => ( merge ( buildConfig ( env , argv ) , { entry : path . join ( WEB_PATH , 's' ) , devtool : 's' , plugins : [ new webpack . HotModuleReplacementPlugin ( ) , ] , devServer : { contentBase : APP_PATH , openPage : 's' , inline : true , stats : 's' , open : true , port : 0 , hot : true , } , } ) ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const CompressionPlugin = require ( 's' ) ; const merge = require ( 's' ) ; const { buildConfig , DIST_PATH } = require ( 's' ) ; module . exports = ( env , argv ) => merge ( buildConfig ( env , argv ) , { devtool : false , output : { filename : 's' , path : DIST_PATH , } , plugins : [ new CompressionPlugin ( { algorithm : 's' , filename : 's' } ) , ] , } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = function ( api ) { api . cache . forever ( ) ; const presets = [ [ 's' ] , ] ; const plugins = [ [ 's' , { legacy : true } ] , ] ; if ( process . env . platform === 's' ) { return { presets : [ 's' , ... presets ] , plugins , } } return { presets , plugins } ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' export const DEBUG = __DEV__ ; export const DEV = __DEV__ ;	O O O O O O O O O O O O O
'js' import * as RX from 's' ; import React from 's' ; import { Navigator } from 's' ; import { MainPanel } from 's' ; import { SecondPanel } from 's' ; const NavigationRouteId = { MainPanel : 's' , SecondPanel : 's' } ; const styles = { navCardStyle : RX . Styles . createViewStyle ( { backgroundColor : 's' } , false ) } ; export class RootView extends RX . Component { _navigator ; componentDidMount ( ) { this . _navigator . immediatelyResetRouteStack ( [ { routeId : NavigationRouteId . MainPanel , sceneConfigType : 's' } ] ) ; } render ( ) { return ( < Navigator cardStyle = { styles . navCardStyle } renderScene = { this . _renderScene } ref = { this . _onNavigatorRef } / > ) ; } _onNavigatorRef = ( navigator ) => { this . _navigator = navigator ; } _renderScene = ( navigatorRoute ) => { switch ( navigatorRoute . routeId ) { case NavigationRouteId . MainPanel : return ( < MainPanel onPressNavigate = { this . _onPressNavigate } / > ) ; case NavigationRouteId . SecondPanel : return ( < SecondPanel onNavigateBack = { this . _onPressBack } / > ) ; } return null ; } _onPressNavigate = ( ) => { this . _navigator . push ( { routeId : NavigationRouteId . SecondPanel , sceneConfigType : 's' } ) ; } _onPressBack = ( ) => { this . _navigator . pop ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' import * as RX from 's' ; import React from 's' ; import { DEBUG , DEV } from 's' ; import { RootView } from 's' ; class App { init ( ) { RX . App . initialize ( DEBUG , DEV ) ; RX . UserInterface . setMainView ( this . _renderRootView ( ) ) ; } _renderRootView ( ) { return ( < RootView / > ) ; } } export default new App ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' import App from 's' ; App . init ( ) ;	O O O O O O O O O O O O
'js' import 's' ;	O O O O
'js' import Enzyme from 's' ; import Adapter from 's' ; Enzyme . configure ( { adapter : new Adapter ( ) } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { rootDir : 's' , roots : [ 's' ] , moduleFileExtensions : [ 's' , 's' , 's' , 's' , 's' , ] , moduleDirectories : [ 's' ] , snapshotSerializers : [ 's' , ] , setupFiles : [ 's' , ] , testRegex : 's' , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { transformer : { getTransformOptions : async ( ) => ( { transform : { experimentalImportSupport : false , inlineRequires : false } , } ) , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' require ( 's' ) . run ( ) ;	O O O O O O O O O O
'js' import 's' ; module . hot . accept ( ) ;	O O O O O O O O O O O O
'js' const HtmlWebpackPlugin = require ( 's' ) ; const webpack = require ( 's' ) ; const path = require ( 's' ) ; const ROOT_PATH = path . join ( __dirname , 's' , 's' ) ; const DIST_PATH = path . join ( ROOT_PATH , 's' ) ; const APP_PATH = path . join ( ROOT_PATH , 's' ) ; const WEB_PATH = path . join ( ROOT_PATH , 's' ) ; const buildConfig = ( env , argv ) => ( { entry : ROOT_PATH , module : { rules : [ { test : "s" , loader : 's' , include : APP_PATH , enforce : 's' } , { test : "s" , loader : 's' , include : APP_PATH } , ] } , plugins : [ new webpack . DefinePlugin ( { __DEV__ : argv . mode === 's' } ) , new HtmlWebpackPlugin ( { inject : true , template : path . join ( WEB_PATH , 's' ) } ) , ] , } ) ; module . exports = { buildConfig , APP_PATH , DIST_PATH , WEB_PATH , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const webpack = require ( 's' ) ; const merge = require ( 's' ) ; const path = require ( 's' ) ; const { buildConfig , APP_PATH , WEB_PATH } = require ( 's' ) ; module . exports = ( env , argv ) => ( merge ( buildConfig ( env , argv ) , { entry : path . join ( WEB_PATH , 's' ) , devtool : 's' , plugins : [ new webpack . HotModuleReplacementPlugin ( ) , ] , devServer : { contentBase : APP_PATH , openPage : 's' , inline : true , stats : 's' , open : true , port : 0 , hot : true , } , } ) ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const CompressionPlugin = require ( 's' ) ; const merge = require ( 's' ) ; const { buildConfig , DIST_PATH } = require ( 's' ) ; module . exports = ( env , argv ) => merge ( buildConfig ( env , argv ) , { devtool : false , output : { filename : 's' , path : DIST_PATH , } , plugins : [ new CompressionPlugin ( { algorithm : 's' , filename : 's' } ) , ] , } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export class AppConfig { private _isDebug = false ; private _isDevelopment = false ; setAppConfig ( isDebug , isDevelopment ) { this . _isDebug = isDebug ; this . _isDevelopment = isDevelopment ; } isDebugMode ( ) { return this . _isDebug ; } isDevelopmentMode ( ) { return this . _isDevelopment ; } } export default new AppConfig ( ) ;	O O O O O O O O O O O O O O O O $boolean$ O $boolean$ O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O
import * as React from 's' ; import * as RX from 's' ; export { default as SubscribableEvent , SubscriptionToken } from 's' ; export type ReactNode = React . ReactNode ; export type ReactInterface = { createElement < P > ( type , props ? : P , ... children : ReactNode [ ] ) : React . ReactElement < P > ; } ; export interface FlexboxParentStyle { flexDirection ? : 's' | 's' | 's' | 's' ; alignSelf ? : 's' | 's' | 's' | 's' | 's' ; borderWidth ? : number ; borderTopWidth ? : number ; borderRightWidth ? : number ; borderBottomWidth ? : number ; borderLeftWidth ? : number ; height ? : number ; width ? : number ; top ? : number ; right ? : number ; bottom ? : number ; left ? : number ; flexGrow ? : number ; flexShrink ? : number ; flexBasis ? : number ; flex ? : number ; maxHeight ? : number ; maxWidth ? : number ; minHeight ? : number ; minWidth ? : number ; margin ? : number ; marginHorizontal ? : number ; marginVertical ? : number ; marginTop ? : number ; marginRight ? : number ; marginBottom ? : number ; marginLeft ? : number ; padding ? : number ; paddingHorizontal ? : number ; paddingVertical ? : number ; paddingTop ? : number ; paddingRight ? : number ; paddingBottom ? : number ; paddingLeft ? : number ; position ? : 's' | 's' ; } export interface FlexboxChildrenStyle { alignItems ? : 's' | 's' | 's' | 's' ; alignContent ? : 's' | 's' | 's' | 's' | 's' ; flexWrap ? : 's' | 's' ; justifyContent ? : 's' | 's' | 's' | 's' | 's' ; } export interface FlexboxStyle extends FlexboxParentStyle , FlexboxChildrenStyle { } export type InterpolationConfig = { inputRange : number [ ] ; outputRange : number [ ] | string [ ] ; } ; export abstract class AnimatedValue { constructor ( val ) { } abstract setValue ( value ) ; abstract interpolate ( config ) ; } export declare abstract class InterpolatedValue { private constructor ( ) ; abstract interpolate ( config ) ; } export interface AnimatedFlexboxStyle { height ? : AnimatedValue | InterpolatedValue ; width ? : AnimatedValue | InterpolatedValue ; top ? : AnimatedValue | InterpolatedValue ; right ? : AnimatedValue | InterpolatedValue ; bottom ? : AnimatedValue | InterpolatedValue ; left ? : AnimatedValue | InterpolatedValue ; } export interface TransformStyle { transform ? : { perspective ? : number ; rotate ? : string ; rotateX ? : string ; rotateY ? : string ; rotateZ ? : string ; scale ? : number ; scaleX ? : number ; scaleY ? : number ; translateX ? : number ; translateY ? : number ; } [ ] ; } export interface AnimatedTransformStyle { transform ? : { perspective ? : AnimatedValue | InterpolatedValue ; rotate ? : AnimatedValue | InterpolatedValue ; rotateX ? : AnimatedValue | InterpolatedValue ; rotateY ? : AnimatedValue | InterpolatedValue ; rotateZ ? : AnimatedValue | InterpolatedValue ; scale ? : AnimatedValue | InterpolatedValue ; scaleX ? : AnimatedValue | InterpolatedValue ; scaleY ? : AnimatedValue | InterpolatedValue ; translateX ? : AnimatedValue | InterpolatedValue ; translateY ? : AnimatedValue | InterpolatedValue ; } [ ] ; } export type StyleRuleSet < T > = T | number | undefined ; export type StyleRuleSetOrArray < T > = StyleRuleSet < T > | Array < StyleRuleSet < T > > ; export interface StyleRuleSetRecursiveArray < T > extends Array < StyleRuleSetOrArray < T > | StyleRuleSetRecursiveArray < T > > { } export type StyleRuleSetRecursive < T > = StyleRuleSet < T > | StyleRuleSetRecursiveArray < T > ; export interface ViewAndImageCommonStyle extends FlexboxStyle , TransformStyle { borderWidth ? : number ; borderColor ? : string ; borderRadius ? : number ; borderTopRightRadius ? : number ; borderBottomRightRadius ? : number ; borderBottomLeftRadius ? : number ; borderTopLeftRadius ? : number ; overflow ? : 's' | 's' ; backgroundColor ? : string ; opacity ? : number ; } export interface AnimatedViewAndImageCommonStyle extends AnimatedFlexboxStyle , AnimatedTransformStyle { borderRadius ? : AnimatedValue | InterpolatedValue ; backgroundColor ? : InterpolatedValue ; opacity ? : AnimatedValue | InterpolatedValue ; } export interface ShadowOffset { width : number ; height : number ; } export interface ViewStyle extends ViewAndImageCommonStyle { borderStyle ? : 's' | 's' | 's' | 's' ; wordBreak ? : 's' | 's' ; appRegion ? : 's' | 's' ; cursor ? : 's' | 's' ; shadowOffset ? : ShadowOffset ; shadowOpacity ? : number ; shadowRadius ? : number ; shadowColor ? : string ; elevation ? : number ; acrylicOpacityUWP ? : number ; acrylicSourceUWP ? : 's' | 's' ; acrylicTintColorUWP ? : string ; } export type ViewStyleRuleSet = StyleRuleSet < ViewStyle > ; export interface AnimatedViewStyle extends AnimatedViewAndImageCommonStyle { } export type AnimatedViewStyleRuleSet = StyleRuleSet < AnimatedViewStyle > ; export interface ScrollViewStyle extends FlexboxParentStyle , TransformStyle { overflow ? : 's' | 's' ; backgroundColor ? : string ; opacity ? : number ; } export type ScrollViewStyleRuleSet = StyleRuleSet < ScrollViewStyle > ; export interface ButtonStyle extends ViewStyle { } export type ButtonStyleRuleSet = StyleRuleSet < ButtonStyle > ; export interface ActivityIndicatorStyle extends ViewStyle { } export type ActivityIndicatorStyleRuleSet = StyleRuleSet < ActivityIndicatorStyle > ; export interface FontInfo { fontFamily ? : string ; fontStyle ? : 's' | 's' ; fontWeight ? : 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' ; } export interface TextStyle extends ViewStyle { color ? : string ; fontFamily ? : string ; fontSize ? : number ; fontStyle ? : 's' | 's' ; fontWeight ? : 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' ; font ? : FontInfo ; letterSpacing ? : number ; lineHeight ? : number ; textAlign ? : 's' | 's' | 's' | 's' | 's' ; textDecorationLine ? : 's' | 's' | 's' | 's' ; textDecorationStyle ? : 's' | 's' | 's' | 's' ; textDecorationColor ? : string ; writingDirection ? : 's' | 's' | 's' ; textAlignVertical ? : 's' | 's' | 's' | 's' ; includeFontPadding ? : boolean ; } export type TextStyleRuleSet = StyleRuleSet < TextStyle > ; export interface AnimatedTextStyle extends AnimatedViewAndImageCommonStyle { color ? : InterpolatedValue ; fontSize ? : AnimatedValue | InterpolatedValue ; } export type AnimatedTextStyleRuleSet = StyleRuleSet < AnimatedTextStyle > ; export interface TextInputStyle extends TextStyle { } export type TextInputStyleRuleSet = StyleRuleSet < TextInputStyle > ; export interface AnimatedTextInputStyle extends AnimatedViewAndImageCommonStyle { color ? : InterpolatedValue ; fontSize ? : AnimatedValue | InterpolatedValue ; } export type AnimatedTextInputStyleRuleSet = StyleRuleSet < AnimatedTextInputStyle > ; export interface LinkStyle extends TextStyle { } export type LinkStyleRuleSet = StyleRuleSet < LinkStyle > ; export interface ImageStyle extends ViewAndImageCommonStyle , FlexboxStyle { overlayColor ? : string ; } export type ImageStyleRuleSet = StyleRuleSet < ImageStyle > ; export interface AnimatedImageStyle extends AnimatedViewAndImageCommonStyle , AnimatedFlexboxStyle { } export type AnimatedImageStyleRuleSet = StyleRuleSet < AnimatedImageStyle > ; export interface PickerStyle extends ViewStyle { color ? : string ; } export type PickerStyleRuleSet = StyleRuleSet < PickerStyle > ; export type ComponentBase = React . Component < any , any > ; interface RefObject < T > { readonly current : T | null ; } type Ref < T > = { bivarianceHack ( instance : T | null ) : void } [ 's' ] | RefObject < T > | null ; interface RefAttributes < T > { ref ? : Ref < T > ; key ? : string | number ; } export interface CommonProps < C = React . Component > extends RefAttributes < C > { children ? : ReactNode | ReactNode [ ] ; testId ? : string ; } export interface Stateless { } export interface CommonAccessibilityProps { importantForAccessibility ? : ImportantForAccessibility ; accessibilityId ? : string ; accessibilityLabel ? : string ; accessibilityTraits ? : AccessibilityTrait | AccessibilityTrait [ ] ; tabIndex ? : number ; ariaValueNow ? : number ; accessibilityActions ? : string [ ] ; onAccessibilityAction ? : ( e ) => void ; } export enum ImportantForAccessibility { Auto = 0 , Yes , No , NoHideDescendants } export type AriaLive = 's' | 's' | 's' ; export enum AccessibilityLiveRegion { None , Polite , Assertive } export enum AccessibilityTrait { Summary , Adjustable , Button , Tab , Selected , Radio_button_checked , Radio_button_unchecked , Link , Header , Search , Image , Plays , Key , Text , Disabled , FrequentUpdates , StartsMedia , AllowsDirectInteraction , PageTurn , Menu , MenuItem , MenuBar , TabList , List , ListItem , ListBox , Group , CheckBox , Checked , ComboBox , Log , Status , Dialog , HasPopup , Option , Switch , None } export type FocusArbitrator = ( candidates : FocusCandidate [ ] ) => FocusCandidate | undefined ; export interface FocusCandidate { component : RX . FocusableComponent ; accessibilityId ? : string ; } export interface CommonStyledProps < T , C = React . Component > extends CommonProps < C > { style ? : StyleRuleSetRecursive < T > ; } export interface ButtonProps extends CommonStyledProps < ButtonStyleRuleSet , RX . Button > , CommonAccessibilityProps { title ? : string ; disabled ? : boolean ; disabledOpacity ? : number ; delayLongPress ? : number ; autoFocus ? : boolean ; onAccessibilityTapIOS ? : ( e ) => void ; onContextMenu ? : ( e ) => void ; onPress ? : ( e ) => void ; onPressIn ? : ( e ) => void ; onPressOut ? : ( e ) => void ; onLongPress ? : ( e ) => void ; onHoverStart ? : ( e ) => void ; onHoverEnd ? : ( e ) => void ; onKeyPress ? : ( e ) => void ; onFocus ? : ( e ) => void ; onBlur ? : ( e ) => void ; shouldRasterizeIOS ? : boolean ; disableTouchOpacityAnimation ? : boolean ; activeOpacity ? : number ; underlayColor ? : string ; id ? : string ; ariaControls ? : string ; } export interface PickerPropsItem { label : string ; value : string ; } export interface PickerProps extends CommonProps < RX . Picker > { items : PickerPropsItem [ ] ; selectedValue : string ; onValueChange : ( itemValue , itemPosition ) => void ; style ? : StyleRuleSetRecursive < PickerStyleRuleSet > ; mode ? : 's' | 's' ; } export interface Headers { [ header ] : string ; } export type ImageResizeMode = 's' | 's' | 's' | 's' | 's' ; export interface ImagePropsShared < C = React . Component > extends CommonProps < C > { source : string ; headers ? : Headers ; accessibilityLabel ? : string ; resizeMode ? : ImageResizeMode ; resizeMethod ? : 's' | 's' | 's' ; title ? : string ; onLoad ? : ( size ) => void ; onError ? : ( err ? ) => void ; } export interface ImageProps extends ImagePropsShared < RX . Image > { style ? : StyleRuleSetRecursive < ImageStyleRuleSet > ; } export interface ImageMetadata { width : number ; height : number ; } export interface AnimatedImageProps extends ImagePropsShared < RX . AnimatedImage > { style ? : StyleRuleSetRecursive < AnimatedImageStyleRuleSet | ImageStyleRuleSet > ; } export interface TextPropsShared < C = React . Component > extends CommonProps < C > { selectable ? : boolean ; numberOfLines ? : number ; allowFontScaling ? : boolean ; maxContentSizeMultiplier ? : number ; ellipsizeMode ? : 's' | 's' | 's' ; textBreakStrategy ? : 's' | 's' | 's' ; importantForAccessibility ? : ImportantForAccessibility ; accessibilityId ? : string ; autoFocus ? : boolean ; onPress ? : ( e ) => void ; id ? : string ; onContextMenu ? : ( e ) => void ; } export interface TextProps extends TextPropsShared < RX . Text > { style ? : StyleRuleSetRecursive < TextStyleRuleSet > ; } export interface AnimatedTextProps extends TextPropsShared < RX . AnimatedText > { style ? : StyleRuleSetRecursive < AnimatedTextStyleRuleSet | TextStyleRuleSet > ; } export type ViewLayerType = 's' | 's' | 's' ; export enum LimitFocusType { Unlimited = 0 , Limited = 0 , Accessible = 0 } export interface ViewPropsShared < C = React . Component > extends CommonProps < C > , CommonAccessibilityProps { title ? : string ; ignorePointerEvents ? : boolean ; blockPointerEvents ? : boolean ; shouldRasterizeIOS ? : boolean ; viewLayerTypeAndroid ? : ViewLayerType ; restrictFocusWithin ? : boolean ; limitFocusWithin ? : LimitFocusType ; autoFocus ? : boolean ; arbitrateFocus ? : FocusArbitrator ; importantForLayout ? : boolean ; id ? : string ; ariaLabelledBy ? : string ; ariaRoleDescription ? : string ; accessibilityLiveRegion ? : AccessibilityLiveRegion ; animateChildEnter ? : boolean ; animateChildLeave ? : boolean ; animateChildMove ? : boolean ; onAccessibilityTapIOS ? : ( e ) => void ; onLayout ? : ( e ) => void ; onMouseEnter ? : ( e ) => void ; onMouseLeave ? : ( e ) => void ; onDragStart ? : ( e ) => void ; onDrag ? : ( e ) => void ; onDragEnd ? : ( e ) => void ; onDragEnter ? : ( e ) => void ; onDragOver ? : ( e ) => void ; onDragLeave ? : ( e ) => void ; onDrop ? : ( e ) => void ; onMouseOver ? : ( e ) => void ; onMouseMove ? : ( e ) => void ; onPress ? : ( e ) => void ; onLongPress ? : ( e ) => void ; onKeyPress ? : ( e ) => void ; onFocus ? : ( e ) => void ; onBlur ? : ( e ) => void ; disableTouchOpacityAnimation ? : boolean ; activeOpacity ? : number ; underlayColor ? : string ; onContextMenu ? : ( e ) => void ; onStartShouldSetResponder ? : ( e ) => boolean ; onMoveShouldSetResponder ? : ( e ) => boolean ; onStartShouldSetResponderCapture ? : ( e ) => boolean ; onMoveShouldSetResponderCapture ? : ( e ) => boolean ; onResponderGrant ? : ( e ) => void ; onResponderReject ? : ( e ) => void ; onResponderRelease ? : ( e ) => void ; onResponderStart ? : ( e ) => void ; onResponderMove ? : ( e ) => void ; onTouchStartCapture ? : ( e ) => void ; onTouchMoveCapture ? : ( e ) => void ; onResponderEnd ? : ( e ) => void ; onResponderTerminate ? : ( e ) => void ; onResponderTerminationRequest ? : ( e ) => boolean ; } export interface ViewProps extends ViewPropsShared < RX . View > { style ? : StyleRuleSetRecursive < ViewStyleRuleSet > ; useSafeInsets ? : boolean ; } export interface AnimatedViewProps extends ViewPropsShared < RX . AnimatedView > { style ? : StyleRuleSetRecursive < AnimatedViewStyleRuleSet | ViewStyleRuleSet > ; } export interface GestureState { isTouch : boolean ; timeStamp : number ; } export interface MultiTouchGestureState extends GestureState { initialCenterClientX : number ; initialCenterClientY : number ; initialCenterPageX : number ; initialCenterPageY : number ; initialWidth : number ; initialHeight : number ; initialDistance : number ; initialAngle : number ; centerClientX : number ; centerClientY : number ; centerPageX : number ; centerPageY : number ; velocityX : number ; velocityY : number ; width : number ; height : number ; distance : number ; angle : number ; isComplete : boolean ; } export interface ScrollWheelGestureState extends GestureState { clientX : number ; clientY : number ; pageX : number ; pageY : number ; scrollAmount : number ; } export interface PanGestureState extends GestureState { initialClientX : number ; initialClientY : number ; initialPageX : number ; initialPageY : number ; clientX : number ; clientY : number ; pageX : number ; pageY : number ; velocityX : number ; velocityY : number ; isComplete : boolean ; } export interface TapGestureState extends GestureState { clientX : number ; clientY : number ; pageX : number ; pageY : number ; } export enum GestureMouseCursor { Default , Pointer , Grab , Move , EWResize , NSResize , NESWResize , NWSEResize , NotAllowed , ZoomIn , ZoomOut } export enum PreferredPanGesture { Horizontal , Vertical } export interface GestureViewProps extends CommonStyledProps < ViewStyleRuleSet , RX . GestureView > , CommonAccessibilityProps { onPinchZoom ? : ( gestureState ) => void ; onRotate ? : ( gestureState ) => void ; onScrollWheel ? : ( gestureState ) => void ; mouseOverCursor ? : GestureMouseCursor ; onPan ? : ( gestureState ) => void ; onPanVertical ? : ( gestureState ) => void ; onPanHorizontal ? : ( gestureState ) => void ; onTap ? : ( gestureState ) => void ; onDoubleTap ? : ( gestureState ) => void ; onLongPress ? : ( gestureState ) => void ; onContextMenu ? : ( gestureState ) => void ; onFocus ? : ( e ) => void ; onBlur ? : ( e ) => void ; onKeyPress ? : ( e ) => void ; preferredPan ? : PreferredPanGesture ; panPixelThreshold ? : number ; releaseOnRequest ? : boolean ; } export interface ScrollIndicatorInsets { top : number ; left : number ; bottom : number ; right : number ; } export interface ScrollViewProps extends CommonStyledProps < ScrollViewStyleRuleSet , RX . ScrollView > , CommonAccessibilityProps { children ? : ReactNode ; vertical ? : boolean ; horizontal ? : boolean ; onLayout ? : ( e ) => void ; onContentSizeChange ? : ( width , height ) => void ; onScroll ? : ( newScrollTop , newScrollLeft ) => void ; onScrollBeginDrag ? : ( ) => void ; onScrollEndDrag ? : ( ) => void ; onKeyPress ? : ( e ) => void ; onFocus ? : ( e ) => void ; onBlur ? : ( e ) => void ; showsHorizontalScrollIndicator ? : boolean ; showsVerticalScrollIndicator ? : boolean ; scrollEnabled ? : boolean ; keyboardDismissMode ? : 's' | 's' | 's' ; keyboardShouldPersistTaps ? : boolean | 's' | 's' | 's' ; scrollEventThrottle ? : number ; bounces ? : boolean ; pagingEnabled ? : boolean ; snapToInterval ? : number ; scrollsToTop ? : boolean ; overScrollMode ? : 's' | 's' | 's' ; scrollIndicatorInsets ? : ScrollIndicatorInsets ; tabNavigation ? : 's' | 's' | 's' ; scrollXAnimatedValue ? : RX . Types . AnimatedValue ; scrollYAnimatedValue ? : RX . Types . AnimatedValue ; } export interface LinkProps extends CommonStyledProps < LinkStyleRuleSet , RX . Link > { title ? : string ; url : string ; children ? : ReactNode ; selectable ? : boolean ; numberOfLines ? : number ; allowFontScaling ? : boolean ; maxContentSizeMultiplier ? : number ; tabIndex ? : number ; accessibilityId ? : string ; autoFocus ? : boolean ; onPress ? : ( e : RX . Types . SyntheticEvent , url ) => void ; onLongPress ? : ( e : RX . Types . SyntheticEvent , url ) => void ; onHoverStart ? : ( e ) => void ; onHoverEnd ? : ( e ) => void ; onContextMenu ? : ( e ) => void ; } export interface TextInputPropsShared < C = React . Component > extends CommonProps < C > , CommonAccessibilityProps { autoCapitalize ? : 's' | 's' | 's' | 's' ; autoCorrect ? : boolean ; autoFocus ? : boolean ; blurOnSubmit ? : boolean ; defaultValue ? : string ; editable ? : boolean ; keyboardType ? : 's' | 's' | 's' | 's' ; maxLength ? : number ; multiline ? : boolean ; placeholder ? : string ; placeholderTextColor ? : string ; secureTextEntry ? : boolean ; value ? : string ; title ? : string ; allowFontScaling ? : boolean ; maxContentSizeMultiplier ? : number ; keyboardAppearance ? : 's' | 's' | 's' ; returnKeyType ? : 's' | 's' | 's' | 's' | 's' ; disableFullscreenUI ? : boolean ; spellCheck ? : boolean ; selectionColor ? : string ; clearButtonMode ? : 's' | 's' | 's' | 's' ; onKeyPress ? : ( e ) => void ; onFocus ? : ( e ) => void ; onBlur ? : ( e ) => void ; onPaste ? : ( e ) => void ; onChangeText ? : ( newValue ) => void ; onSelectionChange ? : ( start , end ) => void ; onSubmitEditing ? : ( ) => void ; onScroll ? : ( newScrollLeft , newScrollTop ) => void ; } export interface TextInputProps extends TextInputPropsShared < RX . TextInput > { style ? : StyleRuleSetRecursive < TextInputStyleRuleSet > ; } export interface AnimatedTextInputProps extends TextInputPropsShared < RX . AnimatedTextInput > { style ? : StyleRuleSetRecursive < AnimatedTextInputStyleRuleSet | TextInputStyleRuleSet > ; } export interface ActivityIndicatorProps extends CommonStyledProps < ActivityIndicatorStyleRuleSet , RX . ActivityIndicator > { color : string ; size ? : 's' | 's' | 's' | 's' ; deferTime ? : number ; } export type PopupPosition = 's' | 's' | 's' | 's' | 's' ; export interface PopupOptions { getAnchor : ( ) => React . Component < any , any > ; renderPopup : ( anchorPosition , anchorOffset , popupWidth , popupHeight ) => ReactNode ; getElementTriggeringPopup ? : ( ) => React . Component < any , any > ; onDismiss ? : ( ) => void ; positionPriorities ? : PopupPosition [ ] ; useInnerPositioning ? : boolean ; onAnchorPressed ? : ( e ? : RX . Types . SyntheticEvent ) => void ; dismissIfShown ? : boolean ; preventDismissOnPress ? : boolean ; cacheable ? : boolean ; rootViewId ? : string ; } export interface ModalOptions { rootViewId ? : string ; } export interface AlertButtonSpec { text ? : string ; onPress ? : ( ) => void ; style ? : 's' | 's' | 's' ; } export interface AlertModalTheme { bodyStyle ? : StyleRuleSet < ViewStyle > ; titleTextStyle ? : StyleRuleSet < TextStyle > ; messageTextStyle ? : StyleRuleSet < TextStyle > ; buttonStyle ? : StyleRuleSet < ButtonStyle > ; buttonHoverStyle ? : StyleRuleSet < ButtonStyle > ; buttonTextStyle ? : StyleRuleSet < TextStyle > ; cancelButtonStyle ? : StyleRuleSet < ButtonStyle > ; cancelButtonHoverStyle ? : StyleRuleSet < ButtonStyle > ; cancelButtonTextStyle ? : StyleRuleSet < TextStyle > ; } export interface AlertOptions { icon ? : string ; theme ? : AlertModalTheme ; rootViewId ? : string ; preventDismissOnPress ? : boolean ; } export enum LocationErrorType { PermissionDenied = 0 , PositionUnavailable , Timeout } export type LocationWatchId = number ; export type LocationSuccessCallback = ( position ) => void ; export type LocationFailureCallback = ( error ) => void ; export module Animated { export type EndResult = { finished : boolean } ; export type EndCallback = ( result ) => void ; export type CompositeAnimation = { start : ( callback ? ) => void ; stop : ( ) => void ; } ; export interface LoopConfig { restartFrom : number ; } export interface AnimationConfig { useNativeDriver ? : boolean ; isInteraction ? : boolean ; } export interface TimingAnimationConfig extends AnimationConfig { toValue : number ; easing ? : EasingFunction ; duration ? : number ; delay ? : number ; loop ? : LoopConfig ; } export interface InterpolationConfigType { inputRange : number [ ] ; outputRange : ( number | string ) [ ] ; } export type TimingFunction = ( value : RX . Types . AnimatedValue | RX . Types . InterpolatedValue , config ) => CompositeAnimation ; export let timing ; export type SequenceFunction = ( animations < CompositeAnimation > ) => CompositeAnimation ; export let sequence ; export type ParallelFunction = ( animations < CompositeAnimation > ) => CompositeAnimation ; export let parallel ; export type EasingFunction = { cssName : string ; function : ( input ) => number ; } ; export interface Easing { Default ( ) : EasingFunction ; Linear ( ) : EasingFunction ; Out ( ) : EasingFunction ; In ( ) : EasingFunction ; InOut ( ) : EasingFunction ; InBack ( ) : EasingFunction ; OutBack ( ) : EasingFunction ; InOutBack ( ) : EasingFunction ; StepStart ( ) : EasingFunction ; StepEnd ( ) : EasingFunction ; Steps ( intervals , end ? ) : EasingFunction ; CubicBezier ( 0 , 0 , 0 , 0 ) : EasingFunction ; } } export type SyntheticEvent = { readonly bubbles : boolean ; readonly cancelable : boolean ; readonly defaultPrevented : boolean ; readonly timeStamp : number ; readonly nativeEvent : any ; preventDefault ( ) : void ; stopPropagation ( ) : void ; } ; export interface ClipboardEvent extends SyntheticEvent { clipboardData : DataTransfer ; } export type FocusEvent = SyntheticEvent ; export interface MouseEvent extends SyntheticEvent { altKey : boolean ; button : number ; clientX : number ; clientY : number ; ctrlKey : boolean ; metaKey : boolean ; shiftKey : boolean ; pageX ? : number ; pageY ? : number ; } export interface DragEvent extends MouseEvent { dataTransfer : DataTransfer ; } export interface Touch { identifier : number ; locationX : number ; locationY : number ; screenX : number ; screenY : number ; clientX : number ; clientY : number ; pageX : number ; pageY : number ; } export interface TouchList { [ index ] : Touch ; length : number ; item ( index ) : Touch ; identifiedTouch ( identifier ) : Touch ; } export interface TouchEvent extends SyntheticEvent { altKey : boolean ; changedTouches : TouchList ; ctrlKey : boolean ; metaKey : boolean ; shiftKey : boolean ; targetTouches : TouchList ; locationX ? : number ; locationY ? : number ; pageX ? : number ; pageY ? : number ; touches : TouchList ; } export interface WheelEvent extends SyntheticEvent { deltaMode : number ; deltaX : number ; deltaY : number ; deltaZ : number ; } export type ViewOnLayoutEvent = { x : number ; y : number ; height : number ; width : number ; } ; export interface KeyboardEvent extends SyntheticEvent { ctrlKey : boolean ; altKey : boolean ; shiftKey : boolean ; keyCode : number ; metaKey : boolean ; key : string ; } export let Children : React . ReactChildren ; export type Dimensions = { width : number ; height : number ; } ; export interface EmailInfo { to ? : string [ ] ; cc ? : string [ ] ; bcc ? : string [ ] ; subject ? : string ; body ? : string ; } export interface SmsInfo { phoneNumber ? : string ; body ? : string ; } export enum LinkingErrorCode { NoAppFound = 0 , UnexpectedFailure = 0 , Blocked = 0 , InitialUrlNotFound = 0 } export interface LinkingErrorInfo { code : LinkingErrorCode ; url ? : string ; description ? : string ; } export enum AppActivationState { Active = 0 , Background = 0 , Inactive = 0 , Extension = 0 } export interface LayoutInfo { x : number ; y : number ; width : number ; height : number ; } export type PlatformType = 's' | 's' | 's' | 's' | 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O $void$ O $number$ O O O $InterpolatedValue$ O $InterpolationConfig$ O O O O O O O O O O O O O O O $InterpolatedValue$ O $InterpolationConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SyntheticEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SyntheticEvent$ O O O O O O O O $MouseEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $KeyboardEvent$ O O O O O O O O $FocusEvent$ O O O O O O O O $FocusEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dimensions$ O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SyntheticEvent$ O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SyntheticEvent$ O O O O O O O O $ViewOnLayoutEvent$ O O O O O O O O $MouseEvent$ O O O O O O O O $MouseEvent$ O O O O O O O O $DragEvent$ O O O O O O O O $DragEvent$ O O O O O O O O $DragEvent$ O O O O O O O O $DragEvent$ O O O O O O O O $DragEvent$ O O O O O O O O $DragEvent$ O O O O O O O O $DragEvent$ O O O O O O O O $MouseEvent$ O O O O O O O O $MouseEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $KeyboardEvent$ O O O O O O O O $FocusEvent$ O O O O O O O O $FocusEvent$ O O O O O O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $TouchEvent$ O O O O O O O O $TouchEvent$ O O O O O O O O $TouchEvent$ O O O O O O O O $TouchEvent$ O O O O O O O O $TouchEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MultiTouchGestureState$ O O O O O O O O $MultiTouchGestureState$ O O O O O O O O $ScrollWheelGestureState$ O O O O O O O O O O O O O $PanGestureState$ O O O O O O O O $PanGestureState$ O O O O O O O O $PanGestureState$ O O O O O O O O $TapGestureState$ O O O O O O O O $TapGestureState$ O O O O O O O O $TapGestureState$ O O O O O O O O $TapGestureState$ O O O O O O O O $FocusEvent$ O O O O O O O O $FocusEvent$ O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ViewOnLayoutEvent$ O O O O O O O O $number$ O $number$ O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O $FocusEvent$ O O O O O O O O $FocusEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $SyntheticEvent$ O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O $FocusEvent$ O O O O O O O O $FocusEvent$ O O O O O O O O $ClipboardEvent$ O O O O O O O O $string$ O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PopupPosition$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Position$ O O O O O O O O O $LocationErrorType$ O O O O O O O O O O O O O O O O O O O O O O O $EndResult$ O O O O O O O O O O O O O $EndCallback$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TimingAnimationConfig$ O O O O O O $TimingFunction$ O O O O O O $Array$ O O O O O O O O O $SequenceFunction$ O O O O O O $Array$ O O O O O O O O O $ParallelFunction$ O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $boolean$ O O O O O O $number$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O $number$ O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import SubscribableEvent from 's' ; import AppConfig from 's' ; import * as Types from 's' ; export { Types } ; export abstract class ActivityIndicator extends React . Component < Types . ActivityIndicatorProps > { } export abstract class Alert { abstract show ( title , message ? , buttons ? : Types . AlertButtonSpec [ ] , options ? : Types . AlertOptions ) ; } export abstract class AnimatedComponent < P extends Types . CommonProps < C > , T , C > extends React . Component < P , T > { abstract setNativeProps ( props : P ) ; } export abstract class AnimatedImage extends AnimatedComponent < Types . AnimatedImageProps , Types . Stateless , AnimatedImage > { } export abstract class AnimatedText extends AnimatedComponent < Types . AnimatedTextProps , Types . Stateless , AnimatedText > { } export abstract class AnimatedTextInput extends AnimatedComponent < Types . AnimatedTextInputProps , Types . Stateless , AnimatedTextInput > { } export abstract class AnimatedView extends AnimatedComponent < Types . AnimatedViewProps , Types . Stateless , AnimatedView > implements FocusableComponent { abstract setFocusRestricted ( restricted ) ; abstract setFocusLimited ( limited ) ; abstract focus ( ) ; abstract requestFocus ( ) ; abstract blur ( ) ; } export abstract class App { supportsExperimentalKeyboardNavigation = false ; initialize ( debug , development ) { AppConfig . setAppConfig ( debug , development ) ; } abstract getActivationState ( ) : Types . AppActivationState ; activationStateChangedEvent = new SubscribableEvent < ( state : Types . AppActivationState ) => void > ( ) ; memoryWarningEvent = new SubscribableEvent < ( ) => void > ( ) ; } export abstract class UserInterface { abstract setMainView ( element : React . ReactElement < any > ) ; abstract registerRootView ( viewKey , getComponentFunc ) ; abstract useCustomScrollbars ( enable ? ) ; abstract isHighPixelDensityScreen ( ) ; abstract getPixelRatio ( ) ; abstract measureLayoutRelativeToWindow ( component : React . Component < any > ) < Types . LayoutInfo > ; abstract measureLayoutRelativeToAncestor ( component : React . Component < any > , ancestor : React . Component < any > ) < Types . LayoutInfo > ; abstract measureWindow ( rootViewId ? ) : Types . Dimensions ; abstract getContentSizeMultiplier ( ) < number > ; contentSizeMultiplierChangedEvent = new SubscribableEvent < ( multiplier ) => void > ( ) ; abstract setMaxContentSizeMultiplier ( maxContentSizeMultiplier ) ; abstract dismissKeyboard ( ) ; abstract enableTouchLatencyEvents ( latencyThresholdMs ) ; touchLatencyEvent = new SubscribableEvent < ( observedLatencyMs ) => void > ( ) ; abstract isNavigatingWithKeyboard ( ) ; keyboardNavigationEvent = new SubscribableEvent < ( isNavigatingWithKeyboard ) => void > ( ) ; } export abstract class Modal { abstract isDisplayed ( modalId ? ) ; abstract show ( modal : React . ReactElement < Types . ViewProps > , modalId , options ? : Types . ModalOptions ) ; abstract dismiss ( modalId ) ; abstract dismissAll ( ) ; } export abstract class Popup { abstract show ( options : Types . PopupOptions , popupId , delay ? ) ; abstract autoDismiss ( popupId , delay ? ) ; abstract dismiss ( popupId ) ; abstract dismissAll ( ) ; abstract isDisplayed ( popupId ? ) ; } export abstract class Linking { abstract getInitialUrl ( ) < string | undefined > ; deepLinkRequestEvent = new SubscribableEvent < ( url ) => void > ( ) ; abstract openUrl ( url ) < void > ; abstract launchSms ( smsData : Types . SmsInfo ) < void > ; abstract launchEmail ( emailData : Types . EmailInfo ) < void > ; protected abstract _createEmailUrl ( emailInfo : Types . EmailInfo ) ; } export abstract class Accessibility { abstract isScreenReaderEnabled ( ) ; abstract isHighContrastEnabled ( ) ; abstract announceForAccessibility ( announcement ) ; screenReaderChangedEvent = new SubscribableEvent < ( isEnabled ) => void > ( ) ; highContrastChangedEvent = new SubscribableEvent < ( isEnabled ) => void > ( ) ; } export interface FocusableComponent { focus ( ) : void ; requestFocus ( ) : void ; blur ( ) : void ; } export abstract class Button extends React . Component < Types . ButtonProps > implements FocusableComponent { abstract focus ( ) ; abstract requestFocus ( ) ; abstract blur ( ) ; } export abstract class Picker extends React . Component < Types . PickerProps , Types . Stateless > { } export class Component < P , T > extends React . Component < P , T > { } export interface ImageConstructor { new ( props : Types . ImageProps ) : Image ; prefetch ( url ) : Promise < boolean > ; getMetadata ( url ) : Promise < Types . ImageMetadata > ; } export abstract class Image extends React . Component < Types . ImageProps > { abstract getNativeWidth ( ) : number | undefined ; abstract getNativeHeight ( ) : number | undefined ; } export abstract class Clipboard { abstract setText ( text ) ; abstract getText ( ) < string > ; } export abstract class Link extends React . Component < Types . LinkProps > implements FocusableComponent { abstract focus ( ) ; abstract requestFocus ( ) ; abstract blur ( ) ; } export abstract class Storage { abstract getItem ( key ) < string | undefined > ; abstract setItem ( key , value ) < void > ; abstract removeItem ( key ) < void > ; abstract clear ( ) < void > ; } export abstract class Location { abstract isAvailable ( ) ; abstract setConfiguration ( config ) ; abstract getCurrentPosition ( options ? ) < Position > ; abstract watchPosition ( successCallback : Types . LocationSuccessCallback , errorCallback ? : Types . LocationFailureCallback , options ? ) < Types . LocationWatchId > ; abstract clearWatch ( watchID : Types . LocationWatchId ) ; } export interface LocationConfiguration { skipPermissionRequests : boolean ; } export abstract class Platform { abstract getType ( ) : Types . PlatformType ; abstract select < T > ( specifics : { [ platform in Types . PlatformType | 's' ] ? : T } ) : T | undefined ; } export abstract class Input { backButtonEvent = new SubscribableEvent < ( ) => boolean > ( true ) ; keyDownEvent = new SubscribableEvent < ( e : Types . KeyboardEvent ) => boolean > ( true ) ; keyUpEvent = new SubscribableEvent < ( e : Types . KeyboardEvent ) => boolean > ( true ) ; } export interface ScrollViewConstructor { new ( props : Types . ScrollViewProps ) : ScrollView ; } export interface ScrollView extends React . Component < Types . ScrollViewProps > { setScrollTop ( scrollTop , animate ? ) : void ; setScrollLeft ( scrollLeft , animate ? ) : void ; } export abstract class StatusBar { abstract isOverlay ( ) ; abstract setHidden ( hidden , showHideTransition : 's' | 's' ) ; abstract setBarStyle ( style : 's' | 's' | 's' , animated ) ; abstract setNetworkActivityIndicatorVisible ( value ) ; abstract setBackgroundColor ( color , animated ) ; abstract setTranslucent ( translucent ) ; } export abstract class Styles { abstract combine < T > ( 0 : Types . StyleRuleSetRecursive < T > | undefined , 0 ? : Types . StyleRuleSetRecursive < T > ) : Types . StyleRuleSetOrArray < T > | undefined ; abstract createViewStyle ( ruleSet : Types . ViewStyle , cacheStyle ? ) : Types . ViewStyleRuleSet ; abstract createAnimatedViewStyle ( ruleSet : Types . AnimatedViewStyle ) : Types . AnimatedViewStyleRuleSet ; abstract createScrollViewStyle ( ruleSet : Types . ScrollViewStyle , cacheStyle ? ) : Types . ScrollViewStyleRuleSet ; abstract createButtonStyle ( ruleSet : Types . ButtonStyle , cacheStyle ? ) : Types . ButtonStyleRuleSet ; abstract createTextStyle ( ruleSet : Types . TextStyle , cacheStyle ? ) : Types . TextStyleRuleSet ; abstract createAnimatedTextStyle ( ruleSet : Types . AnimatedTextStyle ) : Types . AnimatedTextStyleRuleSet ; abstract createTextInputStyle ( ruleSet : Types . TextInputStyle , cacheStyle ? ) : Types . TextInputStyleRuleSet ; abstract createAnimatedTextInputStyle ( ruleSet : Types . AnimatedTextInputStyle ) : Types . AnimatedTextInputStyleRuleSet ; abstract createImageStyle ( ruleSet : Types . ImageStyle , cacheStyle ? ) : Types . ImageStyleRuleSet ; abstract createAnimatedImageStyle ( ruleSet : Types . AnimatedImageStyle ) : Types . AnimatedImageStyleRuleSet ; abstract createLinkStyle ( ruleSet : Types . LinkStyleRuleSet , cacheStyle ? ) : Types . LinkStyleRuleSet ; abstract createPickerStyle ( ruleSet : Types . PickerStyle , cacheStyle ? ) : Types . PickerStyleRuleSet ; abstract getCssPropertyAliasesCssStyle ( ) : { [ key ] : string } ; } export abstract class Text extends React . Component < Types . TextProps > implements FocusableComponent { abstract focus ( ) ; abstract requestFocus ( ) ; abstract blur ( ) ; abstract getSelectedText ( ) ; } export abstract class TextInput extends React . Component < Types . TextInputProps > implements FocusableComponent { abstract setAccessibilityFocus ( ) ; abstract isFocused ( ) ; abstract selectAll ( ) ; abstract selectRange ( start , end ) ; abstract getSelectionRange ( ) : { start : number ; end : number ; } ; abstract setValue ( value ) ; abstract focus ( ) ; abstract requestFocus ( ) ; abstract blur ( ) ; } export abstract class UserPresence { abstract isUserPresent ( ) ; userPresenceChangedEvent = new SubscribableEvent < ( isPresent ) => void > ( ) ; } export abstract class ViewBase < P , S = { } > extends React . Component < P , S > { } export abstract class View extends ViewBase < Types . ViewProps > implements FocusableComponent { abstract setFocusRestricted ( restricted ) ; abstract setFocusLimited ( limited ) ; abstract focus ( ) ; abstract requestFocus ( ) ; abstract blur ( ) ; } export abstract class GestureView extends ViewBase < Types . GestureViewProps > { } export interface Animated { Image : typeof AnimatedImage ; Text : typeof AnimatedText ; TextInput : typeof AnimatedTextInput ; View : typeof AnimatedView ; Easing : Types . Animated . Easing ; timing : Types . Animated . TimingFunction ; parallel : Types . Animated . ParallelFunction ; sequence : Types . Animated . SequenceFunction ; Value : typeof Types . AnimatedValue ; createValue : ( initialValue ) => Types . AnimatedValue ; interpolate : ( value : Types . AnimatedValue , inputRange : number [ ] , outputRange : string [ ] ) => Types . InterpolatedValue ; } export interface International { allowRTL ( allow ) : void ; forceRTL ( force ) : void ; isRTL ( ) : boolean ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $boolean$ O O O $void$ O $boolean$ O O O $void$ O O O O $void$ O O O O $void$ O O O O O O O O O O O O O $void$ O $boolean$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O $void$ O $string$ O $Function$ O O O $void$ O O $boolean$ O O O $boolean$ O O O O $number$ O O O O $Promise$ O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $Promise$ O O O O O O O O O O O O $number$ O O O O O O O O $void$ O $number$ O O O $void$ O O O O $void$ O $number$ O O O O O O O O $number$ O O O O O O O O $boolean$ O O O O O O O O O $boolean$ O O O O O O O O O O O O O O $boolean$ O O $string$ O O O $void$ O O O O O O O O O O O O $string$ O O O O O O O O O O $void$ O $string$ O O O $void$ O O O O O O O O O O $boolean$ O O O O O O O $string$ O O $number$ O O O $void$ O $string$ O O $number$ O O O $void$ O $string$ O O O $void$ O O O O $boolean$ O O $string$ O O O O O O O O O $Promise$ O O O O O O O O O O O O O O $string$ O O O O O O O O $Promise$ O $string$ O O O O O O $Promise$ O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $boolean$ O O O O $boolean$ O O O O $void$ O $string$ O O O O O O O O $boolean$ O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $void$ O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $void$ O O O O $void$ O O O O O O O O O O $Promise$ O $string$ O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O $Promise$ O $string$ O O O O O O $Promise$ O O O O O O O O O O O O O $boolean$ O O O O $void$ O $LocationConfiguration$ O O O $Promise$ O O $PositionOptions$ O O O O O O $Promise$ O O O O O O O O O O O O O O O $PositionOptions$ O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $boolean$ O O O O O O $number$ O O $boolean$ O O O O O O O O O O O $boolean$ O O O O $void$ O $boolean$ O O O O O O O O O $void$ O O O O O O O O O $boolean$ O O O $void$ O $boolean$ O O O $void$ O $string$ O $boolean$ O O O $void$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $void$ O O O O $void$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $boolean$ O O O O $void$ O O O O $void$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O $void$ O O O O $void$ O O O O $void$ O O O O O O O O O O $boolean$ O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $boolean$ O O O $void$ O $boolean$ O O O $void$ O O O O $void$ O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O $boolean$ O O O O O O O O O O O
declare var global ; const timerProvider = typeof window !== 's' ? window : global ; export default class Timers { static clearInterval ( handle ) { timerProvider . clearInterval ( handle ) ; } static clearTimeout ( handle ) { timerProvider . clearTimeout ( handle ) ; } static setInterval ( handler : ( ) => void , timeout ) { return timerProvider . setInterval ( handler , timeout ) ; } static setTimeout ( handler : ( ) => void , timeout ) { return timerProvider . setTimeout ( handler , timeout ) ; } }	O O $any$ O O O O O O O O O O O O O O O O O O O $void$ O $number$ O O O O O O O O O O O $void$ O $number$ O O O O O O O O O O O $number$ O O O O O O O O $number$ O O O O O O O O O O O O O O $number$ O O O O O O O O $number$ O O O O O O O O O O O O O O
import * as React from 's' ; import * as RX from 's' ; import Timers from 's' ; let _sortAndFilter : SortAndFilterFunc | undefined ; let _autoFocusTimer : number | undefined ; let _lastFocusArbitratorProviderId = 0 ; let rootFocusArbitratorProvider ; export enum FocusCandidateType { Focus = 0 , FocusFirst = 0 } export interface FocusCandidateInternal { component : React . Component < any , any > ; focus : ( ) => void ; isAvailable : ( ) => boolean ; type : FocusCandidateType ; accessibilityId ? : string ; } export type SortAndFilterFunc = ( candidates : FocusCandidateInternal [ ] ) => FocusCandidateInternal [ ] ; export function setSortAndFilterFunc ( sortAndFilter ) { _sortAndFilter = sortAndFilter ; } export class FocusArbitratorProvider { private _id : number ; private _parentArbitratorProvider : FocusArbitratorProvider | undefined ; private _arbitratorCallback : RX . Types . FocusArbitrator | undefined ; private _candidates : FocusCandidateInternal [ ] = [ ] ; private _pendingChildren : { [ key ] : FocusArbitratorProvider } = { } ; constructor ( view ? : RX . View , arbitrator ? : RX . Types . FocusArbitrator ) { this . _id = ++ _lastFocusArbitratorProviderId ; this . _parentArbitratorProvider = view ? ( ( view . context && view . context . focusArbitrator ) || rootFocusArbitratorProvider ) : undefined ; this . _arbitratorCallback = arbitrator ; } private _notifyParent ( ) { if ( this . _parentArbitratorProvider ) { this . _parentArbitratorProvider . _pendingChildren [ 's' + this . _id . toString ( ) ] = this ; this . _parentArbitratorProvider . _notifyParent ( ) ; } } private _arbitrate ( ) : FocusCandidateInternal | undefined { const candidates = this . _candidates ; Object . keys ( this . _pendingChildren ) . forEach ( key => { const candidate = this . _pendingChildren [ key ] . _arbitrate ( ) ; if ( candidate ) { candidates . push ( candidate ) ; } } ) ; this . _candidates = [ ] ; this . _pendingChildren = { } ; return FocusArbitratorProvider . _arbitrate ( candidates , this . _arbitratorCallback ) ; } private _requestFocus ( component : React . Component < any , any > , focus : ( ) => void , isAvailable : ( ) => boolean , type ) { const accessibilityId = component . props && component . props . accessibilityId ; this . _candidates . push ( { component , focus , isAvailable , type , accessibilityId } ) ; this . _notifyParent ( ) ; } private static _arbitrate ( candidates : FocusCandidateInternal [ ] , arbitrator ? : RX . Types . FocusArbitrator ) : FocusCandidateInternal | undefined { candidates = candidates . filter ( item => item . isAvailable ( ) ) ; if ( _sortAndFilter ) { candidates = _sortAndFilter ( candidates ) ; } for ( let i = 0 ; i < candidates . length ; i ++ ) { if ( candidates [ i ] . type === FocusCandidateType . FocusFirst ) { return candidates [ i ] ; } } if ( arbitrator ) { const toArbitrate : RX . Types . FocusCandidate [ ] = [ ] ; candidates . forEach ( candidate => { const component = candidate . component as any ; if ( component . focus && component . blur && component . requestFocus ) { component . __focusCandidateInternal = candidate ; toArbitrate . push ( { component , accessibilityId : candidate . accessibilityId } ) ; } } ) ; if ( toArbitrate . length ) { const candidate = arbitrator ( toArbitrate ) ; let ret : FocusCandidateInternal | undefined ; if ( candidate && candidate . component && ( candidate . component as any ) . __focusCandidateInternal ) { ret = ( candidate . component as any ) . __focusCandidateInternal as FocusCandidateInternal ; } toArbitrate . forEach ( candidate => { delete ( candidate . component as any ) . __focusCandidateInternal ; } ) ; return ret ; } } return candidates [ candidates . length - 0 ] ; } setCallback ( arbitrator ? : RX . Types . FocusArbitrator ) { this . _arbitratorCallback = arbitrator ; } static requestFocus ( component : React . Component < any , any > , focus : ( ) => void , isAvailable : ( ) => boolean , type ? ) { if ( _autoFocusTimer ) { Timers . clearTimeout ( _autoFocusTimer ) ; } const focusArbitratorProvider = ( ( ( component as any ) . _focusArbitratorProvider instanceof FocusArbitratorProvider ) && ( component as any ) . _focusArbitratorProvider ) || ( component . context && component . context . focusArbitrator ) || rootFocusArbitratorProvider ; focusArbitratorProvider . _requestFocus ( component , focus , isAvailable , type || FocusCandidateType . Focus ) ; _autoFocusTimer = Timers . setTimeout ( ( ) => { _autoFocusTimer = undefined ; const candidate = rootFocusArbitratorProvider . _arbitrate ( ) ; if ( candidate ) { candidate . focus ( ) ; } } , 0 ) ; } } rootFocusArbitratorProvider = new FocusArbitratorProvider ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusArbitratorProvider$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $SortAndFilterFunc$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusCandidateType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusCandidateType$ O O O O O O O O O O O O O O O O $FocusArbitratorProvider$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import Timers from 's' ; export class Defer < T > { private _promise : Promise < T > ; private _resolver : ( ( value : T ) => void ) | undefined ; private _rejector : ( ( value ) => void ) | undefined ; constructor ( ) { this . _promise = new Promise < T > ( ( res , rej ) => { this . _resolver = res ; this . _rejector = rej ; } ) ; } resolve ( value : T ) { if ( ! this . _resolver ) { Timers . setTimeout ( ( ) => { this . resolve ( value ) ; } , 0 ) ; return ; } this . _resolver ( value ) ; } reject ( value ) { if ( ! this . _rejector ) { Timers . setTimeout ( ( ) => { this . reject ( value ) ; } , 0 ) ; return ; } this . _rejector ( value ) ; } promise ( ) < T > { return this . _promise ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O
import * as RX from 's' ; import { Defer } from 's' ; export class Location extends RX . Location { setConfiguration ( config : RX . LocationConfiguration ) { if ( this . isAvailable ( ) ) { const configSetter : ( config : RX . LocationConfiguration ) => void = ( navigator . geolocation as any ) . setRNConfiguration ; if ( configSetter ) { configSetter ( config ) ; } } } isAvailable ( ) { return ! ! ( 's' in navigator ) ; } getCurrentPosition ( options ? ) < Position > { if ( ! this . isAvailable ( ) ) { const error = { code : RX . Types . LocationErrorType . PositionUnavailable , message : 's' , PERMISSION_DENIED : 0 , POSITION_UNAVAILABLE : 0 , TIMEOUT : 0 } ; return Promise . reject ( error ) ; } const deferred = new Defer < Position > ( ) ; let reportedError = false ; navigator . geolocation . getCurrentPosition ( ( position ) => { deferred . resolve ( position ) ; } , ( error ) => { if ( ! reportedError ) { deferred . reject ( error ) ; reportedError = true ; } } , options ) ; return deferred . promise ( ) ; } watchPosition ( successCallback : RX . Types . LocationSuccessCallback , errorCallback ? : RX . Types . LocationFailureCallback , options ? ) < RX . Types . LocationWatchId > { if ( ! this . isAvailable ( ) ) { return Promise . reject < RX . Types . LocationWatchId > ( RX . Types . LocationErrorType . PositionUnavailable ) ; } const watchId = navigator . geolocation . watchPosition ( ( position ) => { successCallback ( position ) ; } , ( error ) => { if ( errorCallback ) { errorCallback ( error . code as RX . Types . LocationErrorType ) ; } } , options ) ; return Promise . resolve < RX . Types . LocationWatchId > ( watchId ) ; } clearWatch ( watchID : RX . Types . LocationWatchId ) { navigator . geolocation . clearWatch ( watchID ) ; } } export default new Location ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O $Promise$ O O $PositionOptions$ O O O O O O O O O O O O O O O O $PositionError$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Position$ O O O O O O O O O O O O O $PositionError$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O $PositionOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Position$ O O O O O O O O O O O $PositionError$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import * as RX from 's' ; export declare module ReactXP { export type Accessibility = RX . Accessibility ; export let Accessibility : RX . Accessibility ; export type ActivityIndicator = RX . ActivityIndicator ; export let ActivityIndicator : typeof RX . ActivityIndicator ; export type Alert = RX . Alert ; export let Alert : RX . Alert ; export type App = RX . App ; export let App : RX . App ; export type Button = RX . Button ; export let Button : typeof RX . Button ; export type Picker = RX . Picker ; export let Picker : typeof RX . Picker ; export type Clipboard = RX . Clipboard ; export let Clipboard : RX . Clipboard ; export type GestureView = RX . GestureView ; export let GestureView : typeof RX . GestureView ; export type Image = RX . Image ; export let Image : RX . ImageConstructor ; export type Input = RX . Input ; export let Input : RX . Input ; export type International = RX . International ; export let International : RX . International ; export type Link = RX . Link ; export let Link : typeof RX . Link ; export type Linking = RX . Linking ; export let Linking : RX . Linking ; export type Location = RX . Location ; export let Location : RX . Location ; export type Modal = RX . Modal ; export let Modal : RX . Modal ; export type Platform = RX . Platform ; export let Platform : RX . Platform ; export type Popup = RX . Popup ; export let Popup : RX . Popup ; export type ScrollView = RX . ScrollView ; export let ScrollView : RX . ScrollViewConstructor ; export type StatusBar = RX . StatusBar ; export let StatusBar : RX . StatusBar ; export type Storage = RX . Storage ; export let Storage : RX . Storage ; export type Styles = RX . Styles ; export let Styles : RX . Styles ; export type Text = RX . Text ; export let Text : typeof RX . Text ; export type TextInput = RX . TextInput ; export let TextInput : typeof RX . TextInput ; export type UserInterface = RX . UserInterface ; export let UserInterface : RX . UserInterface ; export type UserPresence = RX . UserPresence ; export let UserPresence : RX . UserPresence ; export type View = RX . View ; export let View : typeof RX . View ; export type Animated = RX . Animated ; export let Animated : RX . Animated ; export import CommonProps = RX . Types . CommonProps ; export import CommonStyledProps = RX . Types . CommonStyledProps ; export import Types = RX . Types ; export import Component = React . Component ; export let createElement : typeof React . createElement ; export let Children : typeof React . Children ; export let __spread ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O
const assert = ( cond , message ? : string | undefined ) => { if ( ! cond ) { throw new Error ( message || 's' ) ; } } ; export default assert ;	O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import assert from 's' ; import * as RX from 's' ; import FrontLayerViewManager from 's' ; export class Popup extends RX . Popup { show ( options : RX . Types . PopupOptions , popupId , delay ? ) { assert ( popupId , `template` ) ; return FrontLayerViewManager . showPopup ( options , popupId , delay ) ; } autoDismiss ( popupId , delay ? ) { assert ( popupId , `template` ) ; FrontLayerViewManager . autoDismissPopup ( popupId , delay ) ; } dismiss ( popupId ) { assert ( popupId , `template` ) ; FrontLayerViewManager . dismissPopup ( popupId ) ; } dismissAll ( ) { FrontLayerViewManager . dismissAllPopups ( ) ; } isDisplayed ( popupId ? ) { return FrontLayerViewManager . isPopupDisplayed ( popupId ) ; } } export default new Popup ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O $string$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O $number$ O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O $boolean$ O O $string$ O O O O O O O O O O O O O O O O O O O
import SubscribableEvent from 's' ; import * as RX from 's' ; export abstract class Accessibility extends RX . Accessibility { abstract isScreenReaderEnabled ( ) ; screenReaderChangedEvent = new SubscribableEvent < ( isEnabled ) => void > ( ) ; isHighContrastEnabled ( ) { return false ; } newAnnouncementReadyEvent = new SubscribableEvent < ( announcement ) => void > ( ) ; announceForAccessibility ( announcement ) { this . newAnnouncementReadyEvent . fire ( announcement ) ; } } export default Accessibility ;	O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O $boolean$ O O O O O O O $boolean$ O O O O O O O O O O O O O $string$ O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O
import { Accessibility as CommonAccessibility } from 's' ; export class Accessibility extends CommonAccessibility { isScreenReaderEnabled ( ) { return false ; } } export default new Accessibility ( ) ;	O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O
import assign = require ( 's' ) ; import clone = require ( 's' ) ; import cloneDeep = require ( 's' ) ; import defer = require ( 's' ) ; import each = require ( 's' ) ; import endsWith = require ( 's' ) ; import extend = require ( 's' ) ; import filter = require ( 's' ) ; import findIndex = require ( 's' ) ; import findLast = require ( 's' ) ; import flatten = require ( 's' ) ; import get = require ( 's' ) ; import isEmpty = require ( 's' ) ; import isEqual = require ( 's' ) ; import isNumber = require ( 's' ) ; import isObject = require ( 's' ) ; import isUndefined = require ( 's' ) ; import kebabCase = require ( 's' ) ; import keys = require ( 's' ) ; import map = require ( 's' ) ; import mapValues = require ( 's' ) ; import max = require ( 's' ) ; import memoize = require ( 's' ) ; import merge = require ( 's' ) ; import omit = require ( 's' ) ; import remove = require ( 's' ) ; import throttle = require ( 's' ) ; import union = require ( 's' ) ; export { assign , clone , cloneDeep , defer , each , endsWith , extend , filter , findIndex , findLast , flatten , get , isEmpty , isEqual , isNumber , isObject , isUndefined , kebabCase , keys , map , mapValues , max , memoize , merge , omit , remove , throttle , union } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import SubscribableEvent from 's' ; import Timers from 's' ; import { isUndefined } from 's' ; const idleTimeInMs = 0 * 0 ; export class AppVisibilityUtils { private _isIdle = false ; private _timer : number | undefined ; readonly onFocusedEvent = new SubscribableEvent < ( ) => void > ( ) ; readonly onBlurredEvent = new SubscribableEvent < ( ) => void > ( ) ; readonly onAppForegroundedEvent = new SubscribableEvent < ( ) => void > ( ) ; readonly onAppBackgroundedEvent = new SubscribableEvent < ( ) => void > ( ) ; readonly onIdleEvent = new SubscribableEvent < ( ) => void > ( ) ; readonly onWakeUpEvent = new SubscribableEvent < ( ) => void > ( ) ; constructor ( ) { if ( typeof ( document ) !== 's' ) { window . addEventListener ( 's' , this . _onFocus ) ; window . addEventListener ( 's' , this . _onBlur ) ; document . addEventListener ( 's' , this . _onAppVisibilityChanged ) ; this . _trackIdleStatus ( ) ; } } hasFocusAndActive ( ) { if ( typeof ( document ) !== 's' ) { return document . hasFocus ( ) && ! this . _isIdle ; } return true ; } hasFocus ( ) { if ( typeof ( document ) !== 's' ) { return document . hasFocus ( ) ; } return true ; } isAppInForeground ( ) { if ( typeof ( document ) !== 's' ) { return ! document . hidden ; } return true ; } private _trackIdleStatus ( ) { document . addEventListener ( 's' , this . _wakeUpAndSetTimerForIdle ) ; document . addEventListener ( 's' , this . _wakeUpAndSetTimerForIdle ) ; document . addEventListener ( 's' , this . _wakeUpAndSetTimerForIdle ) ; document . addEventListener ( 's' , this . _wakeUpAndSetTimerForIdle ) ; this . _wakeUpAndSetTimerForIdle ( ) ; } private _wakeUpAndSetTimerForIdle = ( ) => { if ( ! isUndefined ( this . _timer ) ) { Timers . clearTimeout ( this . _timer ) ; } if ( ! this . hasFocus ( ) ) { return ; } if ( this . hasFocus ( ) && this . _isIdle ) { this . _onWakeUp ( ) ; } this . _timer = Timers . setTimeout ( ( ) => { if ( this . hasFocus ( ) ) { this . _onIdle ( ) ; } } , idleTimeInMs ) ; } private _onFocus = ( ) => { this . _wakeUpAndSetTimerForIdle ( ) ; this . onFocusedEvent . fire ( ) ; } private _onBlur = ( ) => { this . _onIdle ( ) ; this . onBlurredEvent . fire ( ) ; } private _onAppVisibilityChanged = ( ) => { if ( document . hidden ) { this . onAppBackgroundedEvent . fire ( ) ; } else { this . onAppForegroundedEvent . fire ( ) ; } } private _onWakeUp = ( ) => { this . _isIdle = false ; this . onWakeUpEvent . fire ( ) ; } private _onIdle = ( ) => { this . _isIdle = true ; this . onIdleEvent . fire ( ) ; } } export default new AppVisibilityUtils ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; import AppVisibilityUtils from 's' ; export class App extends RX . App { private _activationState : RX . Types . AppActivationState ; constructor ( ) { super ( ) ; if ( typeof ( document ) !== 's' ) { this . _activationState = AppVisibilityUtils . isAppInForeground ( ) ? RX . Types . AppActivationState . Active : RX . Types . AppActivationState . Background ; AppVisibilityUtils . onAppForegroundedEvent . subscribe ( ( ) => { this . _setActivationState ( RX . Types . AppActivationState . Active ) ; } ) ; AppVisibilityUtils . onAppBackgroundedEvent . subscribe ( ( ) => { this . _setActivationState ( RX . Types . AppActivationState . Background ) ; } ) ; } else { this . _activationState = RX . Types . AppActivationState . Active ; } } initialize ( debug , development ) { super . initialize ( debug , development ) ; } getActivationState ( ) : RX . Types . AppActivationState { return this . _activationState ; } private _setActivationState = ( currentState : RX . Types . AppActivationState ) => { if ( this . _activationState !== currentState ) { this . _activationState = currentState ; this . activationStateChangedEvent . fire ( this . _activationState ) ; } } } export default new App ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; export class Clipboard extends RX . Clipboard { setText ( text ) { const node = Clipboard . _createInvisibleNode ( ) ; node . value = text ; document . body . appendChild ( node ) ; Clipboard . _copyNode ( node ) ; document . body . removeChild ( node ) ; } getText ( ) < string > { return Promise . reject < string > ( 's' ) ; } private static _createInvisibleNode ( ) { const node = document . createElement ( 's' ) ; node . style . position = 's' ; node . style . left = 's' ; node . style . width = 's' ; const yPosition = window . pageYOffset || document . documentElement . scrollTop ; node . style . top = yPosition + 's' ; node . readOnly = true ; return node ; } private static _copyNode ( node ) { node . select ( ) ; node . setSelectionRange ( 0 , node . value . length ) ; document . execCommand ( 's' ) ; const selection = window . getSelection ( ) ; if ( selection ) { selection . removeAllRanges ( ) ; } } } export default new Clipboard ( ) ;	O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O $HTMLTextAreaElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLTextAreaElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as PropTypes from 's' ; import * as React from 's' ; import AppConfig from 's' ; import { Types } from 's' ; import Timers from 's' ; let _lastComponentId = 0 ; export enum RestrictFocusType { Unrestricted = 0 , Restricted = 0 , RestrictedFocusFirst = 0 } export interface FocusableInternal { focusableComponentId ? : string ; } export type FocusableComponentInternal = React . Component < any , any > & FocusableInternal ; export interface StoredFocusableComponent { id : string ; numericId : number ; component : FocusableComponentInternal ; onFocus : ( ) => void ; accessibleOnly : boolean ; restricted : boolean ; limitedCount : number ; limitedCountAccessible : number ; removed ? : boolean ; callbacks ? : FocusableComponentStateCallback [ ] ; } export type FocusableComponentStateCallback = ( restrictedOrLimited ) => void ; export type FocusManagerRestrictionStateCallback = ( restricted ) => void ; export abstract class FocusManager { private static _restrictionStack : FocusManager [ ] = [ ] ; protected static _currentRestrictionOwner : FocusManager | undefined ; private static _restoreRestrictionTimer : number | undefined ; private static _pendingPrevFocusedComponent : StoredFocusableComponent | undefined ; protected static _currentFocusedComponent : StoredFocusableComponent | undefined ; protected static _allFocusableComponents : { [ id ] : StoredFocusableComponent } = { } ; protected static _skipFocusCheck = false ; protected static _resetFocusTimer : number | undefined ; private _parent : FocusManager | undefined ; private _isFocusLimited : Types . LimitFocusType = Types . LimitFocusType . Unlimited ; private _currentRestrictType : RestrictFocusType = RestrictFocusType . Unrestricted ; private _prevFocusedComponent : StoredFocusableComponent | undefined ; protected _myFocusableComponentIds : { [ id ] : boolean } = { } ; private _restrictionStateCallback : FocusManagerRestrictionStateCallback | undefined ; constructor ( parent : FocusManager | undefined ) { this . _parent = parent ; } protected abstract addFocusListenerOnComponent ( component , onFocus : ( ) => void ) ; protected abstract removeFocusListenerFromComponent ( component , onFocus : ( ) => void ) ; protected abstract focusComponent ( component ) ; protected abstract resetFocus ( focusFirstWhenNavigatingWithKeyboard ) ; protected abstract _updateComponentFocusRestriction ( storedComponent ) ; addFocusableComponent ( component , accessibleOnly = false ) { if ( component . focusableComponentId ) { return ; } const numericComponentId = ++ _lastComponentId ; const componentId = 's' + numericComponentId ; const storedComponent = { id : componentId , numericId : numericComponentId , component : component , accessibleOnly : accessibleOnly , restricted : false , limitedCount : 0 , limitedCountAccessible : 0 , onFocus : ( ) => { FocusManager . _currentFocusedComponent = storedComponent ; } } ; component . focusableComponentId = componentId ; FocusManager . _allFocusableComponents [ componentId ] = storedComponent ; let withinRestrictionOwner = false ; for ( let parent : FocusManager | undefined = this ; parent ; parent = parent . _parent ) { parent . _myFocusableComponentIds [ componentId ] = true ; if ( FocusManager . _currentRestrictionOwner === parent ) { withinRestrictionOwner = true ; } if ( parent . _isFocusLimited === Types . LimitFocusType . Accessible ) { storedComponent . limitedCountAccessible ++ ; } else if ( parent . _isFocusLimited === Types . LimitFocusType . Limited ) { storedComponent . limitedCount ++ ; } } if ( ! withinRestrictionOwner && FocusManager . _currentRestrictionOwner ) { storedComponent . restricted = true ; } this . _updateComponentFocusRestriction ( storedComponent ) ; this . addFocusListenerOnComponent ( component , storedComponent . onFocus ) ; } removeFocusableComponent ( component ) { if ( ! component . focusableComponentId ) { return ; } const componentId = component . focusableComponentId ; if ( componentId ) { const storedComponent = FocusManager . _allFocusableComponents [ componentId ] ; this . removeFocusListenerFromComponent ( component , storedComponent . onFocus ) ; storedComponent . removed = true ; storedComponent . restricted = false ; storedComponent . limitedCount = 0 ; storedComponent . limitedCountAccessible = 0 ; this . _updateComponentFocusRestriction ( storedComponent ) ; delete storedComponent . callbacks ; for ( let parent : FocusManager | undefined = this ; parent ; parent = parent . _parent ) { delete parent . _myFocusableComponentIds [ componentId ] ; } delete FocusManager . _allFocusableComponents [ componentId ] ; delete component . focusableComponentId ; } } restrictFocusWithin ( restrictType , noFocusReset ? ) { if ( ( FocusManager . _currentRestrictionOwner === this ) || ( restrictType === RestrictFocusType . Unrestricted ) ) { return ; } this . _currentRestrictType = restrictType ; if ( FocusManager . _currentRestrictionOwner ) { this . _removeFocusRestriction ( ) ; } if ( ! this . _prevFocusedComponent ) { this . _prevFocusedComponent = FocusManager . _pendingPrevFocusedComponent || FocusManager . _currentFocusedComponent ; } FocusManager . _clearRestoreRestrictionTimeout ( ) ; FocusManager . _restrictionStack . push ( this ) ; FocusManager . _currentRestrictionOwner = this ; if ( ! noFocusReset ) { this . resetFocus ( restrictType === RestrictFocusType . RestrictedFocusFirst ) ; } Object . keys ( FocusManager . _allFocusableComponents ) . forEach ( componentId => { if ( ! ( componentId in this . _myFocusableComponentIds ) ) { const storedComponent = FocusManager . _allFocusableComponents [ componentId ] ; storedComponent . restricted = true ; this . _updateComponentFocusRestriction ( storedComponent ) ; } } ) ; if ( this . _restrictionStateCallback ) { this . _restrictionStateCallback ( restrictType ) ; } } removeFocusRestriction ( ) { FocusManager . _restrictionStack = FocusManager . _restrictionStack . filter ( focusManager => focusManager !== this ) ; if ( FocusManager . _currentRestrictionOwner === this ) { FocusManager . _skipFocusCheck = true ; let prevFocusedComponent = this . _prevFocusedComponent ; this . _prevFocusedComponent = undefined ; this . _removeFocusRestriction ( ) ; FocusManager . _currentRestrictionOwner = undefined ; if ( this . _restrictionStateCallback ) { this . _restrictionStateCallback ( RestrictFocusType . Unrestricted ) ; } FocusManager . _clearRestoreRestrictionTimeout ( ) ; FocusManager . _pendingPrevFocusedComponent = prevFocusedComponent ; FocusManager . _restoreRestrictionTimer = Timers . setTimeout ( ( ) => { FocusManager . _restoreRestrictionTimer = undefined ; FocusManager . _pendingPrevFocusedComponent = undefined ; const prevRestrictionOwner = FocusManager . _restrictionStack . pop ( ) ; let needsFocusReset = true ; const currentFocusedComponent = FocusManager . _currentFocusedComponent ; if ( currentFocusedComponent && ! currentFocusedComponent . removed && ! ( currentFocusedComponent . id in this . _myFocusableComponentIds ) ) { prevFocusedComponent = undefined ; needsFocusReset = false ; } if ( prevFocusedComponent && ! prevFocusedComponent . accessibleOnly && ! prevFocusedComponent . removed && ! prevFocusedComponent . restricted && prevFocusedComponent . limitedCount === 0 && prevFocusedComponent . limitedCountAccessible === 0 ) { needsFocusReset = ! this . focusComponent ( prevFocusedComponent . component ) ; } if ( prevRestrictionOwner ) { prevRestrictionOwner . restrictFocusWithin ( prevRestrictionOwner . _currentRestrictType , ! needsFocusReset ) ; } else if ( needsFocusReset ) { this . resetFocus ( this . _currentRestrictType === RestrictFocusType . RestrictedFocusFirst ) ; } } , 0 ) ; } } limitFocusWithin ( limitType : Types . LimitFocusType ) { if ( this . _isFocusLimited !== Types . LimitFocusType . Unlimited || ( limitType !== Types . LimitFocusType . Limited && limitType !== Types . LimitFocusType . Accessible ) ) { return ; } this . _isFocusLimited = limitType ; Object . keys ( this . _myFocusableComponentIds ) . forEach ( componentId => { const storedComponent = FocusManager . _allFocusableComponents [ componentId ] ; if ( limitType === Types . LimitFocusType . Accessible ) { storedComponent . limitedCountAccessible ++ ; } else if ( limitType === Types . LimitFocusType . Limited ) { storedComponent . limitedCount ++ ; } this . _updateComponentFocusRestriction ( storedComponent ) ; } ) ; } removeFocusLimitation ( ) { if ( this . _isFocusLimited === Types . LimitFocusType . Unlimited ) { return ; } Object . keys ( this . _myFocusableComponentIds ) . forEach ( componentId => { const storedComponent = FocusManager . _allFocusableComponents [ componentId ] ; if ( this . _isFocusLimited === Types . LimitFocusType . Accessible ) { storedComponent . limitedCountAccessible -- ; } else if ( this . _isFocusLimited === Types . LimitFocusType . Limited ) { storedComponent . limitedCount -- ; } this . _updateComponentFocusRestriction ( storedComponent ) ; } ) ; this . _isFocusLimited = Types . LimitFocusType . Unlimited ; } release ( ) { this . removeFocusRestriction ( ) ; this . removeFocusLimitation ( ) ; } static subscribe ( component , callback ) { const storedComponent = FocusManager . _getStoredComponent ( component ) ; if ( storedComponent ) { if ( ! storedComponent . callbacks ) { storedComponent . callbacks = [ ] ; } storedComponent . callbacks . push ( callback ) ; } } static unsubscribe ( component , callback ) { const storedComponent = FocusManager . _getStoredComponent ( component ) ; if ( storedComponent && storedComponent . callbacks ) { storedComponent . callbacks = storedComponent . callbacks . filter ( cb => { return cb !== callback ; } ) ; } } setRestrictionStateCallback ( callback : FocusManagerRestrictionStateCallback | undefined ) { this . _restrictionStateCallback = callback ; } static isComponentFocusRestrictedOrLimited ( component ) { const storedComponent = FocusManager . _getStoredComponent ( component ) ; return ! ! storedComponent && ( storedComponent . restricted || storedComponent . limitedCount > 0 || storedComponent . limitedCountAccessible > 0 ) ; } static getCurrentFocusedComponent ( ) : string | undefined { return FocusManager . _currentFocusedComponent ? FocusManager . _currentFocusedComponent . id : undefined ; } private static _getStoredComponent ( component ) : StoredFocusableComponent | undefined { const componentId : string | undefined = component . focusableComponentId ; if ( componentId ) { return FocusManager . _allFocusableComponents [ componentId ] ; } return undefined ; } protected static _callFocusableComponentStateChangeCallbacks ( storedComponent , restrictedOrLimited ) { if ( ! storedComponent . callbacks ) { return ; } storedComponent . callbacks . forEach ( callback => { callback . call ( storedComponent . component , restrictedOrLimited ) ; } ) ; } private _removeFocusRestriction ( ) { Object . keys ( FocusManager . _allFocusableComponents ) . forEach ( componentId => { const storedComponent = FocusManager . _allFocusableComponents [ componentId ] ; storedComponent . restricted = false ; this . _updateComponentFocusRestriction ( storedComponent ) ; } ) ; } private static _clearRestoreRestrictionTimeout ( ) { if ( FocusManager . _restoreRestrictionTimer ) { Timers . clearTimeout ( FocusManager . _restoreRestrictionTimer ) ; FocusManager . _restoreRestrictionTimer = undefined ; FocusManager . _pendingPrevFocusedComponent = undefined ; } } } export function applyFocusableComponentMixin ( Component , isConditionallyFocusable ? , accessibleOnly = false ) { const contextTypes = Component . contextTypes || { } ; contextTypes . focusManager = PropTypes . object ; Component . contextTypes = contextTypes ; inheritMethod ( 's' , function ( this , focusManager ) { if ( ! isConditionallyFocusable || isConditionallyFocusable . call ( this ) ) { focusManager . addFocusableComponent ( this , accessibleOnly ) ; } } ) ; inheritMethod ( 's' , function ( this , focusManager ) { focusManager . removeFocusableComponent ( this ) ; } ) ; inheritMethod ( 's' , function ( this , focusManager , origArgs ) { if ( isConditionallyFocusable ) { const isFocusable = isConditionallyFocusable . apply ( this , origArgs ) ; if ( isFocusable && ! this . focusableComponentId ) { focusManager . addFocusableComponent ( this , accessibleOnly ) ; } else if ( ! isFocusable && this . focusableComponentId ) { focusManager . removeFocusableComponent ( this ) ; } } } ) ; function inheritMethod ( methodName , action ) { const origCallback = Component . prototype [ methodName ] ; Component . prototype [ methodName ] = function ( ) { if ( ! isConditionallyFocusable || isConditionallyFocusable . call ( this ) ) { const focusManager = this . _focusManager || ( this . context && this . context . focusManager ) ; if ( focusManager ) { action . call ( this , focusManager , arguments ) ; } else { if ( AppConfig . isDevelopmentMode ( ) ) { console . error ( 's' ) ; } } } if ( origCallback ) { origCallback . apply ( this , arguments ) ; } } ; } } export default FocusManager ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O $RestrictFocusType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $FocusableComponentInternal$ O O O O O O O O O O O $void$ O $FocusableComponentInternal$ O O O O O O O O O O O $boolean$ O $FocusableComponentInternal$ O O O O $void$ O $boolean$ O O O O $void$ O $StoredFocusableComponent$ O O O O $FocusableComponentInternal$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O $StoredFocusableComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $StoredFocusableComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RestrictFocusType$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O $FocusableComponentStateCallback$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O $FocusableComponentStateCallback$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $FocusableComponentInternal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StoredFocusableComponent$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O $FocusManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O $FocusManager$ O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O $FocusManager$ O $IArguments$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export class ScrollViewConfig { private _useCustomScrollbars = false ; setUseCustomScrollbars ( value ) { this . _useCustomScrollbars = value ; } useCustomScrollbars ( ) { return this . _useCustomScrollbars ; } } export default new ScrollViewConfig ( ) ;	O O O O O O O O O $void$ O $boolean$ O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O
import * as React from 's' ; import * as ReactDOM from 's' ; import * as RX from 's' ; import { Defer } from 's' ; import FrontLayerViewManager from 's' ; import ScrollViewConfig from 's' ; export class UserInterface extends RX . UserInterface { private _isNavigatingWithKeyboard = false ; constructor ( ) { super ( ) ; this . keyboardNavigationEvent . subscribe ( this . _keyboardNavigationStateChanged ) ; } measureLayoutRelativeToWindow ( component : React . Component < any , any > ) < RX . Types . LayoutInfo > { const deferred = new Defer < RX . Types . LayoutInfo > ( ) ; let componentDomNode : HTMLElement | null = null ; try { componentDomNode = ReactDOM . findDOMNode ( component ) as HTMLElement | null ; } catch { } if ( ! componentDomNode ) { deferred . reject ( 's' ) ; } else { const componentBoundingRect = componentDomNode . getBoundingClientRect ( ) ; deferred . resolve ( { x : componentBoundingRect . left , y : componentBoundingRect . top , width : componentBoundingRect . width , height : componentBoundingRect . height } ) ; } return deferred . promise ( ) ; } measureLayoutRelativeToAncestor ( component : React . Component < any , any > , ancestor : React . Component < any , any > ) < RX . Types . LayoutInfo > { const deferred = new Defer < RX . Types . LayoutInfo > ( ) ; let componentDomNode : HTMLElement | null = null ; let ancestorDomNode : HTMLElement | null = null ; try { componentDomNode = ReactDOM . findDOMNode ( component ) as HTMLElement | null ; ancestorDomNode = ReactDOM . findDOMNode ( ancestor ) as HTMLElement | null ; } catch { } if ( ! componentDomNode || ! ancestorDomNode ) { deferred . reject ( 's' ) ; } else { const componentBoundingRect = componentDomNode . getBoundingClientRect ( ) ; const ancestorBoundingRect = ancestorDomNode . getBoundingClientRect ( ) ; deferred . resolve ( { x : componentBoundingRect . left - ancestorBoundingRect . left , y : componentBoundingRect . top - ancestorBoundingRect . top , width : componentBoundingRect . width , height : componentBoundingRect . height } ) ; } return deferred . promise ( ) ; } measureWindow ( rootViewId ? ) : RX . Types . LayoutInfo { return { x : 0 , y : 0 , width : window . innerWidth , height : window . innerHeight } ; } getContentSizeMultiplier ( ) < number > { return Promise . resolve ( 0 ) ; } getMaxContentSizeMultiplier ( ) < number > { return Promise . resolve ( 0 ) ; } setMaxContentSizeMultiplier ( maxContentSizeMultiplier ) { } isHighPixelDensityScreen ( ) { return this . getPixelRatio ( ) > 0 ; } getPixelRatio ( ) { let pixelRatio = 0 ; if ( window . devicePixelRatio ) { pixelRatio = window . devicePixelRatio ; } return pixelRatio ; } setMainView ( element : React . ReactElement < any > ) { FrontLayerViewManager . setMainView ( element ) ; } registerRootView ( viewKey , getComponentFunc ) { } useCustomScrollbars ( enable = true ) { ScrollViewConfig . setUseCustomScrollbars ( enable ) ; } dismissKeyboard ( ) { } enableTouchLatencyEvents ( latencyThresholdMs ) { } evaluateTouchLatency ( e : RX . Types . MouseEvent ) { } isNavigatingWithKeyboard ( ) { return this . _isNavigatingWithKeyboard ; } private _keyboardNavigationStateChanged = ( isNavigatingWithKeyboard ) => { this . _isNavigatingWithKeyboard = isNavigatingWithKeyboard ; } } export default new UserInterface ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O $number$ O O O $boolean$ O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O $string$ O $Function$ O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O
import * as ReactDOM from 's' ; import { FocusArbitratorProvider , FocusCandidateInternal , FocusCandidateType } from 's' ; import { applyFocusableComponentMixin as applyFocusableComponentMixinCommon , FocusableComponentInternal , FocusableComponentStateCallback , FocusManager as FocusManagerBase , StoredFocusableComponent as StoredFocusableComponentBase } from 's' ; import Timers from 's' ; import UserInterface from 's' ; const ATTR_NAME_TAB_INDEX = 's' ; const ATTR_NAME_ARIA_HIDDEN = 's' ; let _isShiftPressed ; export { FocusableComponentStateCallback } ; export interface StoredFocusableComponent extends StoredFocusableComponentBase { origTabIndex ? : number ; origAriaHidden ? : string ; curTabIndex ? : number ; curAriaHidden ? : boolean ; } export class FocusManager extends FocusManagerBase { private static _setTabIndexTimer : number | undefined ; private static _setTabIndexElement : HTMLElement | undefined ; private static _lastFocusedProgrammatically : HTMLElement | undefined ; constructor ( parent : FocusManager | undefined ) { super ( parent ) ; } static initListeners ( ) { let _checkFocusTimer : number | undefined ; window . addEventListener ( 's' , event => { _isShiftPressed = event . shiftKey ; } ) ; window . addEventListener ( 's' , event => { _isShiftPressed = event . shiftKey ; } ) ; document . body . addEventListener ( 's' , event => { if ( ! UserInterface . isNavigatingWithKeyboard ( ) || ( event . target === document . body ) ) { return ; } if ( _checkFocusTimer ) { Timers . clearTimeout ( _checkFocusTimer ) ; } if ( FocusManager . _skipFocusCheck ) { FocusManager . _skipFocusCheck = false ; return ; } _checkFocusTimer = Timers . setTimeout ( ( ) => { _checkFocusTimer = undefined ; if ( UserInterface . isNavigatingWithKeyboard ( ) && ( ! FocusManager . _currentFocusedComponent || ! FocusManager . _currentFocusedComponent . removed ) && ( ! document . activeElement || ( document . activeElement === document . body ) ) ) { FocusManager . focusFirst ( _isShiftPressed ) ; } } , 0 ) ; } ) ; } protected addFocusListenerOnComponent ( component , onFocus : ( ) => void ) { try { const el = ReactDOM . findDOMNode ( component ) as HTMLElement | null ; if ( el ) { el . addEventListener ( 's' , onFocus ) ; } } catch { } } protected removeFocusListenerFromComponent ( component , onFocus : ( ) => void ) { try { const el = ReactDOM . findDOMNode ( component ) as HTMLElement | null ; if ( el ) { el . removeEventListener ( 's' , onFocus ) ; } } catch { } } protected focusComponent ( component ) { try { const el = ReactDOM . findDOMNode ( component ) as HTMLElement | null ; if ( el && el . focus ) { FocusManager . setLastFocusedProgrammatically ( el ) ; el . focus ( ) ; return true ; } } catch { } return false ; } static setLastFocusedProgrammatically ( element : HTMLElement | undefined ) { this . _lastFocusedProgrammatically = element ; } static getLastFocusedProgrammatically ( reset ? ) : HTMLElement | undefined { const ret = FocusManager . _lastFocusedProgrammatically ; if ( ret && reset ) { FocusManager . _lastFocusedProgrammatically = undefined ; } return ret ; } private static _isComponentAvailable ( storedComponent ) { return ! storedComponent . accessibleOnly && ! storedComponent . removed && ! storedComponent . restricted && storedComponent . limitedCount === 0 && storedComponent . limitedCountAccessible === 0 ; } private static _getFirstFocusable ( last ? , parent ? ) { const focusable = Object . keys ( FocusManager . _allFocusableComponents ) . filter ( componentId => ! parent || ( componentId in parent . _myFocusableComponentIds ) ) . map ( componentId => FocusManager . _allFocusableComponents [ componentId ] ) . filter ( FocusManager . _isComponentAvailable ) . map ( storedComponent => ( { storedComponent , el : ReactDOM . findDOMNode ( storedComponent . component ) as HTMLElement } ) ) . filter ( f => f . el && f . el . focus && ( ( f . el . tabIndex || 0 ) >= 0 ) && ! ( f . el as any ) . disabled ) ; if ( focusable . length ) { focusable . sort ( ( a , b ) => { if ( a === b ) { return 0 ; } return a . el . compareDocumentPosition ( b . el ) & document . DOCUMENT_POSITION_PRECEDING ? 0 : - 0 ; } ) ; return focusable [ last ? focusable . length - 0 : 0 ] ; } return undefined ; } static focusFirst ( last ? ) { const first = FocusManager . _getFirstFocusable ( last ) ; if ( first ) { const storedComponent = first . storedComponent ; FocusArbitratorProvider . requestFocus ( storedComponent . component , ( ) => { FocusManager . setLastFocusedProgrammatically ( first . el ) ; first . el . focus ( ) ; } , ( ) => FocusManager . _isComponentAvailable ( storedComponent ) , FocusCandidateType . FocusFirst ) ; } } protected resetFocus ( focusFirstWhenNavigatingWithKeyboard ) { if ( FocusManager . _resetFocusTimer ) { Timers . clearTimeout ( FocusManager . _resetFocusTimer ) ; FocusManager . _resetFocusTimer = undefined ; } if ( UserInterface . isNavigatingWithKeyboard ( ) && focusFirstWhenNavigatingWithKeyboard ) { const first = FocusManager . _getFirstFocusable ( false , FocusManager . _currentRestrictionOwner as FocusManager ) ; if ( first ) { const storedComponent = first . storedComponent ; FocusArbitratorProvider . requestFocus ( storedComponent . component , ( ) => { FocusManager . setLastFocusedProgrammatically ( first . el ) ; first . el . focus ( ) ; } , ( ) => FocusManager . _isComponentAvailable ( storedComponent ) , FocusCandidateType . FocusFirst ) ; } } else if ( ( typeof document !== 's' ) && document . body && document . body . focus && document . body . blur ) { FocusManager . _resetFocusTimer = Timers . setTimeout ( ( ) => { FocusManager . _resetFocusTimer = undefined ; const currentFocused = FocusManager . _currentFocusedComponent ; if ( currentFocused && ! currentFocused . removed && ! currentFocused . restricted ) { return ; } const prevTabIndex = FocusManager . _setTabIndex ( document . body , - 0 ) ; FocusManager . setLastFocusedProgrammatically ( document . body ) ; document . body . focus ( ) ; document . body . blur ( ) ; FocusManager . _setTabIndex ( document . body , prevTabIndex ) ; } , 0 ) ; } } protected _updateComponentFocusRestriction ( storedComponent ) { const newAriaHidden = storedComponent . restricted || ( storedComponent . limitedCount > 0 ) ? true : undefined ; const newTabIndex = newAriaHidden || ( storedComponent . limitedCountAccessible > 0 ) ? - 0 : undefined ; const restrictionRemoved = newTabIndex === undefined ; if ( ( storedComponent . curTabIndex !== newTabIndex ) || ( storedComponent . curAriaHidden !== newAriaHidden ) ) { const el = ReactDOM . findDOMNode ( storedComponent . component ) as HTMLElement | null ; if ( el ) { if ( storedComponent . curTabIndex !== newTabIndex ) { storedComponent . curTabIndex = newTabIndex ; if ( restrictionRemoved ) { FocusManager . _setTabIndex ( el , storedComponent . origTabIndex ) ; } else { const prevTabIndex = FocusManager . _setTabIndex ( el , newTabIndex ) ; if ( ! ( 's' in storedComponent ) ) { storedComponent . origTabIndex = prevTabIndex ; } } } if ( storedComponent . curAriaHidden !== newAriaHidden ) { storedComponent . curAriaHidden = newAriaHidden ; if ( restrictionRemoved ) { FocusManager . _setAriaHidden ( el , storedComponent . origAriaHidden ) ; } else { const prevAriaHidden = FocusManager . _setAriaHidden ( el , newAriaHidden ? 's' : undefined ) ; if ( ! ( 's' in storedComponent ) ) { storedComponent . origAriaHidden = prevAriaHidden ; } } } if ( restrictionRemoved ) { delete storedComponent . origTabIndex ; delete storedComponent . origAriaHidden ; } } FocusManager . _callFocusableComponentStateChangeCallbacks ( storedComponent , ! restrictionRemoved ) ; } } private static _setTabIndex ( element , value : number | undefined ) : number | undefined { if ( FocusManager . _setTabIndexTimer && element === FocusManager . _setTabIndexElement ) { Timers . clearTimeout ( FocusManager . _setTabIndexTimer ) ; FocusManager . _setTabIndexTimer = undefined ; FocusManager . _setTabIndexElement = undefined ; } const prev = element . hasAttribute ( ATTR_NAME_TAB_INDEX ) ? element . tabIndex : undefined ; if ( value === undefined ) { if ( prev !== undefined ) { element . removeAttribute ( ATTR_NAME_TAB_INDEX ) ; } } else if ( value !== prev ) { if ( value === - 0 && element === document . activeElement ) { if ( FocusManager . _setTabIndexTimer ) { FocusManager . _setTabIndexElement ! . tabIndex = - 0 ; Timers . clearTimeout ( FocusManager . _setTabIndexTimer ) ; FocusManager . _setTabIndexTimer = undefined ; FocusManager . _setTabIndexElement = undefined ; } FocusManager . _setTabIndexElement = element ; FocusManager . _setTabIndexTimer = Timers . setTimeout ( ( ) => { element . tabIndex = value ; if ( element === FocusManager . _setTabIndexElement ) { FocusManager . _setTabIndexTimer = undefined ; FocusManager . _setTabIndexElement = undefined ; } } , 0 ) ; } else { element . tabIndex = value ; } } return prev ; } private static _setAriaHidden ( element , value : string | undefined ) : string | undefined { const prev = element . hasAttribute ( ATTR_NAME_ARIA_HIDDEN ) ? element . getAttribute ( ATTR_NAME_ARIA_HIDDEN ) || undefined : undefined ; if ( value === undefined ) { if ( prev !== undefined ) { element . removeAttribute ( ATTR_NAME_ARIA_HIDDEN ) ; } } else { element . setAttribute ( ATTR_NAME_ARIA_HIDDEN , value ) ; } return prev ; } static sortAndFilterAutoFocusCandidates ( candidates : FocusCandidateInternal [ ] ) : FocusCandidateInternal [ ] { return candidates . filter ( candidate => { const id = ( candidate . component as FocusableComponentInternal ) . focusableComponentId ; if ( id ) { const storedComponent = FocusManager . _allFocusableComponents [ id ] ; if ( storedComponent && ( storedComponent . removed || ( storedComponent . limitedCount > 0 ) || ( storedComponent . limitedCountAccessible > 0 ) ) ) { return false ; } } return true ; } ) . map ( candidate => ( { candidate , el : ReactDOM . findDOMNode ( candidate . component ) as HTMLElement } ) ) . sort ( ( a , b ) => { if ( a === b ) { return 0 ; } return a . el . compareDocumentPosition ( b . el ) & document . DOCUMENT_POSITION_PRECEDING ? 0 : - 0 ; } ) . map ( ce => ce . candidate ) ; } } export function applyFocusableComponentMixin ( Component , isConditionallyFocusable ? ) { applyFocusableComponentMixinCommon ( Component , isConditionallyFocusable ) ; const origFocus = Component . prototype . focus ; if ( origFocus ) { Component . prototype . focus = function ( ) { try { const el = ReactDOM . findDOMNode ( this ) as HTMLElement | null ; if ( el ) { FocusManager . setLastFocusedProgrammatically ( el ) ; } } catch { } origFocus . apply ( this , arguments ) ; } ; } } if ( ( typeof document !== 's' ) && ( typeof window !== 's' ) ) { FocusManager . initListeners ( ) ; } export default FocusManager ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $FocusableComponentInternal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $FocusableComponentInternal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $FocusableComponentInternal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $StoredFocusableComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O $FocusManager$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StoredFocusableComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; export class Input extends RX . Input { dispatchKeyDown ( e : RX . Types . KeyboardEvent ) { this . keyDownEvent . fire ( e ) ; } dispatchKeyUp ( e : RX . Types . KeyboardEvent ) { if ( this . keyUpEvent . fire ( e ) ) { e . stopPropagation ( ) ; } } } export default new Input ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; import FrontLayerViewManager from 's' ; export class International implements RX . International { allowRTL ( allow ) { FrontLayerViewManager . allowRTL ( allow ) ; } forceRTL ( force ) { FrontLayerViewManager . forceRTL ( force ) ; } isRTL ( ) { return FrontLayerViewManager . isRTL ( ) ; } } export default new International ( ) ;	O O O O O O O O O O O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O
import clone = require ( 's' ) ; import compact = require ( 's' ) ; import filter = require ( 's' ) ; import isEqual = require ( 's' ) ; import pull = require ( 's' ) ; import sortBy = require ( 's' ) ; export interface Dictionary < T > { [ index ] : T ; } export { clone , compact , filter , isEqual , pull , sortBy } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; import { filter } from 's' ; const emailNameRegex = "s" ; const emailNameConstraintViolationRegex = "s" ; const emailHostRegex = "s" ; const emailHostConstraintViolationRegex = "s" ; export abstract class Linking extends RX . Linking { protected abstract _openUrl ( url ) < void > ; launchSms ( phoneInfo : RX . Types . SmsInfo ) < void > { const phoneUrl = this . _createSmsUrl ( phoneInfo ) ; return this . _openUrl ( phoneUrl ) ; } openUrl ( url ) < void > { return this . _openUrl ( url ) ; } protected _createEmailUrl ( emailInfo : RX . Types . EmailInfo ) { let emailUrl = 's' ; let validEmails : string [ ] ; if ( emailInfo . to && emailInfo . to . length > 0 ) { validEmails = this . _filterValidEmails ( emailInfo . to ) ; emailUrl += validEmails . join ( 's' ) ; } emailUrl += 's' ; if ( emailInfo . cc && emailInfo . cc . length > 0 ) { validEmails = this . _filterValidEmails ( emailInfo . cc ) ; emailUrl += 's' + validEmails . join ( 's' ) + 's' ; } if ( emailInfo . bcc && emailInfo . bcc . length > 0 ) { validEmails = this . _filterValidEmails ( emailInfo . bcc ) ; emailUrl += 's' + validEmails . join ( 's' ) + 's' ; } if ( emailInfo . subject ) { emailUrl += 's' + encodeURIComponent ( emailInfo . subject ) + 's' ; } if ( emailInfo . body ) { emailUrl += 's' + encodeURIComponent ( emailInfo . body ) ; } return emailUrl ; } protected _createSmsUrl ( smsInfo : RX . Types . SmsInfo ) { let smsUrl = 's' ; if ( smsInfo . phoneNumber ) { smsUrl += encodeURI ( smsInfo . phoneNumber ) ; } if ( smsInfo . body ) { smsUrl += 's' + encodeURIComponent ( smsInfo . body ) ; } return smsUrl ; } private _isEmailValid ( email ) { if ( ! email || email . length > 0 || email . length < 0 ) { return false ; } const lastAtIndex = email . lastIndexOf ( 's' ) ; if ( lastAtIndex === - 0 || lastAtIndex === 0 || lastAtIndex >= email . length - 0 ) { return false ; } const name = email . substring ( 0 , lastAtIndex ) ; const host = email . substring ( lastAtIndex + 0 ) ; return ! emailNameConstraintViolationRegex . test ( name ) && ! emailHostConstraintViolationRegex . test ( host ) && emailNameRegex . test ( name ) && emailHostRegex . test ( host ) ; } private _filterValidEmails ( emails : string [ ] ) : string [ ] { return filter ( emails , e => this . _isEmailValid ( e ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Types } from 's' ; import { Linking as CommonLinking } from 's' ; export class Linking extends CommonLinking { protected _openUrl ( url ) < void > { const otherWindow = window . open ( ) ; if ( ! otherWindow ) { const linkingError : Types . LinkingErrorInfo = { code : Types . LinkingErrorCode . Blocked , url : url , description : 's' } ; return Promise . reject < void > ( linkingError ) ; } if ( url . indexOf ( 's' ) !== 0 ) { otherWindow . opener = null ; } otherWindow . location . href = url ; return Promise . resolve < void > ( void 0 ) ; } launchEmail ( emailInfo : Types . EmailInfo ) < void > { const emailUrl = this . _createEmailUrl ( emailInfo ) ; window . location . href = emailUrl ; return Promise . resolve < void > ( void 0 ) ; } getInitialUrl ( ) < string | undefined > { return Promise . resolve ( undefined ) ; } } export default new Linking ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import assert from 's' ; import * as RX from 's' ; import FrontLayerViewManager from 's' ; export class Modal extends RX . Modal { isDisplayed ( modalId ? ) { return FrontLayerViewManager . isModalDisplayed ( modalId ) ; } show ( modal : React . ReactElement < RX . Types . ViewProps > , modalId , options ? : RX . Types . ModalOptions ) { assert ( modal , `template` ) ; assert ( modalId , `template` ) ; FrontLayerViewManager . showModal ( modal , modalId , options ) ; } dismiss ( modalId ) { assert ( modalId , `template` ) ; FrontLayerViewManager . dismissModal ( modalId ) ; } dismissAll ( ) { FrontLayerViewManager . dismissAllModals ( ) ; } } export default new Modal ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O $string$ O O O O O O O O O O O $void$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; export class Platform extends RX . Platform { getType ( ) : RX . Types . PlatformType { return 's' ; } select < T > ( specifics : { [ platform in RX . Types . PlatformType | 's' ] ? : T } ) : T | undefined { const platformType = this . getType ( ) ; return platformType in specifics ? specifics [ platformType ] : specifics . default ; } } export default new Platform ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; export class Storage extends RX . Storage { getItem ( key ) < string | undefined > { const value = window . localStorage . getItem ( key ) ; return Promise . resolve < string | undefined > ( value === null ? undefined : value ) ; } setItem ( key , value ) < void > { try { window . localStorage . setItem ( key , value ) ; } catch ( e ) { return Promise . resolve ( e ) ; } return Promise . resolve < void > ( void 0 ) ; } removeItem ( key ) < void > { window . localStorage . removeItem ( key ) ; return Promise . resolve < void > ( void 0 ) ; } clear ( ) < void > { window . localStorage . clear ( ) ; return Promise . resolve < void > ( void 0 ) ; } } export default new Storage ( ) ;	O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import AppConfig from 's' ; import { Types } from 's' ; import { Dictionary , sortBy } from 's' ; export class StyleLeakDetector { private _fingerprintRegistry : { [ key ] : string } = { } ; private _getFingerprint < T extends Types . ViewAndImageCommonStyle > ( object : T ) { return JSON . stringify ( this . _sortAny ( object ) ) ; } private _sortAny ( object ) { if ( object instanceof Array ) { return this . _sortArray ( object ) ; } else if ( object instanceof Object ) { return this . _sortObject ( object ) ; } else { return object ; } } private _sortObject ( object < any > ) { const result < any > = { } ; let keys : string [ ] = [ ] ; for ( const key in object ) { if ( object . hasOwnProperty ( key ) ) { keys . push ( key ) ; } } keys = sortBy ( keys ) ; const keysLength = keys . length ; for ( let i = 0 ; i < keysLength ; i ++ ) { const key = keys [ i ] ; const value = object [ key ] ; result [ key ] = this . _sortAny ( value ) ; } return result ; } private _sortArray ( object : any [ ] ) : any [ ] { const length = object . length ; for ( let i = 0 ; i < length ; i ++ ) { object [ i ] = this . _sortAny ( object [ i ] ) ; } return object ; } protected isDisabled ( ) { return false ; } detectLeaks < T extends Types . ViewAndImageCommonStyle > ( style : T ) { if ( AppConfig . isDevelopmentMode ( ) && ! this . isDisabled ( ) ) { const error = new Error ( ) ; const stack = error . stack ; if ( stack ) { const styleAllocationId = stack . toString ( ) + this . _getFingerprint ( style ) ; const firstAllocation = this . _fingerprintRegistry [ styleAllocationId ] ; if ( firstAllocation ) { console . warn ( 's' , style , 's' , firstAllocation ) ; } else { this . _fingerprintRegistry [ styleAllocationId ] = stack ; } } } } } export default new StyleLeakDetector ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dictionary$ O O O O O O $Dictionary$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import AppConfig from 's' ; import * as RX from 's' ; import StyleLeakDetector from 's' ; import * as _ from 's' ; type CssAliasMap = { [ prop ] : string } ; export class Styles extends RX . Styles { combine < S > ( 0 : RX . Types . StyleRuleSetRecursive < S > | undefined , 0 ? : RX . Types . StyleRuleSetRecursive < S > ) : S | undefined { if ( ! 0 && ! 0 ) { return undefined ; } const ruleSet = 0 ? ( 0 ? [ 0 , 0 ] : 0 ) : 0 ; if ( ruleSet instanceof Array ) { let combinedStyles = { } ; for ( let i = 0 ; i < ruleSet . length ; i ++ ) { const subRuleSet = this . combine ( ruleSet [ i ] ) ; combinedStyles = _ . extend ( combinedStyles , subRuleSet ) ; } if ( ( combinedStyles . marginLeft !== undefined || combinedStyles . marginRight !== undefined || combinedStyles . marginTop !== undefined || combinedStyles . marginBottom !== undefined ) && combinedStyles . margin !== undefined ) { if ( combinedStyles . marginLeft === undefined ) { combinedStyles . marginLeft = combinedStyles . margin ; } if ( combinedStyles . marginRight === undefined ) { combinedStyles . marginRight = combinedStyles . margin ; } if ( combinedStyles . marginTop === undefined ) { combinedStyles . marginTop = combinedStyles . margin ; } if ( combinedStyles . marginBottom === undefined ) { combinedStyles . marginBottom = combinedStyles . margin ; } delete combinedStyles . margin ; } if ( ( combinedStyles . paddingLeft !== undefined || combinedStyles . paddingRight !== undefined || combinedStyles . paddingTop !== undefined || combinedStyles . paddingBottom !== undefined ) && combinedStyles . padding !== undefined ) { if ( combinedStyles . paddingLeft === undefined ) { combinedStyles . paddingLeft = combinedStyles . padding ; } if ( combinedStyles . paddingRight === undefined ) { combinedStyles . paddingRight = combinedStyles . padding ; } if ( combinedStyles . paddingTop === undefined ) { combinedStyles . paddingTop = combinedStyles . padding ; } if ( combinedStyles . paddingBottom === undefined ) { combinedStyles . paddingBottom = combinedStyles . padding ; } delete combinedStyles . padding ; } if ( combinedStyles . borderWidth || combinedStyles . borderTopWidth || combinedStyles . borderRightWidth || combinedStyles . borderBottomWidth || combinedStyles . borderLeftWidth ) { if ( combinedStyles . borderColor === undefined ) { combinedStyles . borderColor = 's' ; } if ( combinedStyles . borderStyle === undefined ) { combinedStyles . borderStyle = 's' ; } } return combinedStyles as S ; } return ruleSet as S ; } createViewStyle ( ruleSet : RX . Types . ViewStyle , cacheStyle = true ) : RX . Types . ViewStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle ) ; } createAnimatedViewStyle ( ruleSet : RX . Types . AnimatedViewStyle ) : RX . Types . AnimatedViewStyleRuleSet { return this . _adaptStyles ( ruleSet , false ) ; } createScrollViewStyle ( ruleSet : RX . Types . ScrollViewStyle , cacheStyle = true ) : RX . Types . ScrollViewStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle ) ; } createButtonStyle ( ruleSet : RX . Types . ButtonStyle , cacheStyle = true ) : RX . Types . ButtonStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle ) ; } createTextStyle ( ruleSet : RX . Types . TextStyle , cacheStyle = true ) : RX . Types . TextStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle , true ) ; } createAnimatedTextStyle ( ruleSet : RX . Types . AnimatedTextStyle ) : RX . Types . AnimatedTextStyleRuleSet { return this . _adaptStyles ( ruleSet , false ) ; } createTextInputStyle ( ruleSet : RX . Types . TextInputStyle , cacheStyle = true ) : RX . Types . TextInputStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle , true ) ; } createAnimatedTextInputStyle ( ruleSet : RX . Types . AnimatedTextInputStyle ) : RX . Types . AnimatedTextInputStyleRuleSet { return this . _adaptStyles ( ruleSet , false ) ; } createLinkStyle ( ruleSet : RX . Types . LinkStyle , cacheStyle = true ) : RX . Types . LinkStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle ) ; } createImageStyle ( ruleSet : RX . Types . ImageStyle , cacheStyle = true ) : RX . Types . ImageStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle ) ; } createAnimatedImageStyle ( ruleSet : RX . Types . AnimatedImageStyle ) : RX . Types . AnimatedImageStyleRuleSet { return this . _adaptStyles ( ruleSet , false ) ; } createPickerStyle ( ruleSet : RX . Types . PickerStyle , cacheStyle = true ) : RX . Types . PickerStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle ) ; } private _getCssPropertyAlias ( name ) { if ( typeof document === 's' ) { return undefined ; } const upperName = name . charAt ( 0 ) . toUpperCase ( ) + name . slice ( 0 ) ; let propsToTest = [ name , upperName ] ; propsToTest = propsToTest . concat ( [ 's' , 's' , 's' , 's' , 's' ] . map ( prefix => prefix + upperName ) ) ; const testElement = this . _createDummyElement ( ) ; const styleObj = testElement . style as any ; for ( let i = 0 ; i < propsToTest . length ; i ++ ) { const prop = propsToTest [ i ] ; if ( styleObj [ prop ] !== undefined ) { return prop ; } } return undefined ; } private _createDummyElement = _ . memoize ( ( ) : HTMLElement => { return document . createElement ( 's' ) ; } ) ; private _getCssPropertyAliasesJsStyle = _ . memoize ( ( ) => { const props = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] ; const aliases = { } ; props . forEach ( prop => { const alias = this . _getCssPropertyAlias ( prop ) ; if ( alias && prop !== alias ) { aliases [ prop ] = alias ; } } ) ; return aliases ; } ) ; convertJsToCssStyle ( prop ) { let cssString = 's' ; if ( prop ) { for ( let i = 0 ; i < prop . length ; i ++ ) { const lowerChar = prop [ i ] . toLowerCase ( ) ; if ( lowerChar === prop [ i ] ) { cssString += lowerChar ; } else { cssString += 's' + lowerChar ; } } } return cssString ; } _cssPropertyAliasesCssStyle = memoize ( ( ) => { const jsStyleAliases = this . _getCssPropertyAliasesJsStyle ( ) ; const aliases = { } ; _ . each ( _ . keys ( jsStyleAliases ) , prop => { aliases [ prop ] = this . convertJsToCssStyle ( jsStyleAliases [ prop ] ) ; } ) ; return aliases ; } ) ; getCssPropertyAliasesCssStyle ( ) : { [ key ] : string } { return this . _cssPropertyAliasesCssStyle ( ) ; } getParentComponentName ( component ) { let parentConstructor ; const internalInstance = component . _reactInternalInstance ; if ( internalInstance && internalInstance . _currentElement && internalInstance . _currentElement . _owner && internalInstance . _currentElement . _owner . _instance ) { parentConstructor = internalInstance . _currentElement . _owner . _instance . constructor ; } if ( ! parentConstructor ) { return 's' ; } return parentConstructor . name ? parentConstructor . name : parentConstructor ; } private _adaptStyles ( def , validate , isTextStyle = false ) < any > { if ( validate ) { StyleLeakDetector . detectLeaks ( def ) ; } if ( def . font ) { if ( def . font . fontFamily !== undefined ) { def . fontFamily = def . font . fontFamily ; } if ( def . font . fontWeight !== undefined ) { def . fontWeight = def . font . fontWeight ; } if ( def . font . fontStyle !== undefined ) { def . fontStyle = def . font . fontStyle ; } delete def . font ; } if ( def . flex !== undefined ) { if ( AppConfig . isDevelopmentMode ( ) ) { if ( def . flexGrow !== undefined || def . flexShrink !== undefined ) { console . error ( 's' ) ; } } const flexValue = def . flex as number ; delete def . flex ; if ( flexValue > 0 ) { def . flexGrow = flexValue ; def . flexShrink = 0 ; } else if ( flexValue < 0 ) { def . flexGrow = 0 ; def . flexShrink = - flexValue ; } else { def . flexGrow = 0 ; def . flexShrink = 0 ; } } if ( def . transform ) { const transformStrings : string [ ] = [ ] ; const animatedTransforms : { [ key ] : Object } = { } ; const staticTransforms : { [ key ] : string } = { } ; _ . each ( def . transform , ( t : { [ key ] : string } ) => { _ . each ( _ . keys ( t ) , key => { if ( typeof t [ key ] === 's' ) { animatedTransforms [ key ] = t [ key ] ; } else { let value = t [ key ] . toString ( ) ; if ( key . indexOf ( 's' ) === 0 ) { value += 's' ; } transformStrings . push ( key + 's' + value + 's' ) ; staticTransforms [ key ] = value ; } } ) ; } ) ; delete def . transform ; if ( transformStrings . length > 0 ) { def . transform = transformStrings . join ( 's' ) ; } if ( _ . keys ( animatedTransforms ) . length > 0 ) { def . animatedTransforms = animatedTransforms ; def . staticTransforms = staticTransforms ; } } if ( def . shadowOffset !== undefined || def . shadowRadius !== undefined || def . shadowColor !== undefined ) { let width = 0 ; let height = 0 ; let radius = 0 ; let color = 's' ; if ( def . shadowOffset !== undefined ) { width = def . shadowOffset . width ; height = def . shadowOffset . height ; delete def . shadowOffset ; } if ( def . shadowRadius !== undefined ) { radius = def . shadowRadius ; delete def . shadowRadius ; } if ( def . shadowColor !== undefined ) { color = def . shadowColor ; delete def . shadowColor ; } if ( isTextStyle ) { def . textShadow = width + 's' + height + 's' + radius + 's' + color ; } else { def . boxShadow = width + 's' + height + 's' + radius + 's' + color ; } } if ( def . lineHeight !== undefined ) { def . lineHeight = def . lineHeight + 's' ; } if ( def . borderStyle || def . borderTopWidth || def . borderRightWidth || def . borderBottomWidth || def . borderLeftWidth ) { if ( def . borderWidth === undefined ) { if ( def . borderTopWidth === undefined ) { def . borderTopWidth = 0 ; } if ( def . borderRightWidth === undefined ) { def . borderRightWidth = 0 ; } if ( def . borderBottomWidth === undefined ) { def . borderBottomWidth = 0 ; } if ( def . borderLeftWidth === undefined ) { def . borderLeftWidth = 0 ; } } } if ( def . marginVertical !== undefined ) { if ( def . marginTop === undefined ) { def . marginTop = def . marginVertical ; } if ( def . marginBottom === undefined ) { def . marginBottom = def . marginVertical ; } delete def . marginVertical ; } if ( def . marginHorizontal !== undefined ) { if ( def . marginLeft === undefined ) { def . marginLeft = def . marginHorizontal ; } if ( def . marginRight === undefined ) { def . marginRight = def . marginHorizontal ; } delete def . marginHorizontal ; } if ( def . paddingVertical !== undefined ) { if ( def . paddingTop === undefined ) { def . paddingTop = def . paddingVertical ; } if ( def . paddingBottom === undefined ) { def . paddingBottom = def . paddingVertical ; } delete def . paddingVertical ; } if ( def . paddingHorizontal !== undefined ) { if ( def . paddingLeft === undefined ) { def . paddingLeft = def . paddingHorizontal ; } if ( def . paddingRight === undefined ) { def . paddingRight = def . paddingHorizontal ; } delete def . paddingHorizontal ; } if ( def . textDecorationLine !== undefined ) { def . textDecoration = def . textDecorationLine ; delete def . textDecorationLine ; } if ( def . textDecorationStyle !== undefined ) { if ( def . textDecoration !== undefined ) { def . textDecoration += 's' + def . textDecorationStyle ; } else { def . textDecoration = def . textDecorationStyle ; } delete def . textDecorationStyle ; } if ( def . textDecorationColor !== undefined ) { if ( def . textDecoration !== undefined ) { def . textDecoration += 's' + def . textDecorationColor ; } else { def . textDecoration = def . textDecorationColor ; } delete def . textDecorationColor ; } const jsAliases = this . _getCssPropertyAliasesJsStyle ( ) ; for ( const prop in jsAliases ) { if ( def [ prop ] !== undefined && jsAliases [ prop ] ) { def [ jsAliases [ prop ] ] = def [ prop ] ; } } if ( def . wordBreak === 's' ) { def . wordWrap = 's' ; } return AppConfig . isDevelopmentMode ( ) ? Object . freeze ( def ) : def ; } } export function memoize < T extends ( ... args : any [ ] ) => any > ( func : T , resolver ? : ( ... args : any [ ] ) => any ) : T { return _ . memoize ( func , resolver ) ; } export default new Styles ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CssAliasMap$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CssAliasMap$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $string$ O $any$ O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Readonly$ O $any$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; import AppVisibilityUtils from 's' ; export class UserPresence extends RX . UserPresence { private _isPresent : boolean ; constructor ( ) { super ( ) ; if ( typeof ( document ) !== 's' ) { this . _isPresent = AppVisibilityUtils . hasFocusAndActive ( ) ; AppVisibilityUtils . onFocusedEvent . subscribe ( this . _handleFocus . bind ( this ) ) ; AppVisibilityUtils . onBlurredEvent . subscribe ( this . _handleBlur . bind ( this ) ) ; AppVisibilityUtils . onWakeUpEvent . subscribe ( this . _handleWakeup . bind ( this ) ) ; AppVisibilityUtils . onIdleEvent . subscribe ( this . _handleIdle . bind ( this ) ) ; } else { this . _isPresent = false ; } } isUserPresent ( ) { if ( typeof ( document ) !== 's' ) { return this . _isPresent ; } else { return true ; } } private _setUserPresent ( isPresent ) { if ( this . _isPresent !== isPresent ) { this . _isPresent = isPresent ; this . userPresenceChangedEvent . fire ( isPresent ) ; } } private _handleWakeup ( ) { this . _setUserPresent ( true ) ; } private _handleIdle ( ) { this . _setUserPresent ( false ) ; } private _handleFocus ( ) { this . _setUserPresent ( true ) ; } private _handleBlur ( ) { this . _setUserPresent ( false ) ; } } const instance = new UserPresence ( ) ; export default instance ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O $void$ O O O O O O O O O O O O $void$ O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O
import React = require ( 's' ) ; import { setSortAndFilterFunc } from 's' ; import RXInterfaces = require ( 's' ) ; import LocationImpl from 's' ; import RXModuleInterface = require ( 's' ) ; import PopupImpl from 's' ; import RXTypes = require ( 's' ) ; import AccessibilityImpl from 's' ; import { ActivityIndicator as ActivityIndicatorImpl } from 's' ; import AlertImpl from 's' ; import AnimatedImpl = require ( 's' ) ; import AppImpl from 's' ; import { Button as ButtonImpl } from 's' ; import ClipboardImpl from 's' ; import FocusManager from 's' ; import { GestureView as GestureViewImpl } from 's' ; import { Image as ImageImpl } from 's' ; import InputImpl from 's' ; import InternationalImpl from 's' ; import { Link as LinkImpl } from 's' ; import LinkingImpl from 's' ; import ModalImpl from 's' ; import { Picker as PickerImpl } from 's' ; import PlatformImpl from 's' ; import { ScrollView as ScrollViewImpl } from 's' ; import StatusBarImpl from 's' ; import StorageImpl from 's' ; import StylesImpl from 's' ; import { Text as TextImpl } from 's' ; import { TextInput as TextInputImpl } from 's' ; import UserInterfaceImpl from 's' ; import UserPresenceImpl from 's' ; import ViewImpl from 's' ; import { ViewBase } from 's' ; setSortAndFilterFunc ( FocusManager . sortAndFilterAutoFocusCandidates ) ; module ReactXP { export type Accessibility = RXInterfaces . Accessibility ; export let Accessibility : RXInterfaces . Accessibility = AccessibilityImpl ; export type ActivityIndicator = RXInterfaces . ActivityIndicator ; export let ActivityIndicator : typeof RXInterfaces . ActivityIndicator = ActivityIndicatorImpl ; export type Alert = RXInterfaces . Alert ; export let Alert : RXInterfaces . Alert = AlertImpl ; export type App = RXInterfaces . App ; export let App : RXInterfaces . App = AppImpl ; export type Button = RXInterfaces . Button ; export let Button : typeof RXInterfaces . Button = ButtonImpl ; export type Picker = RXInterfaces . Picker ; export let Picker : typeof RXInterfaces . Picker = PickerImpl ; export type Clipboard = RXInterfaces . Clipboard ; export let Clipboard : RXInterfaces . Clipboard = ClipboardImpl ; export type GestureView = RXInterfaces . GestureView ; export let GestureView : typeof RXInterfaces . GestureView = GestureViewImpl ; export type Image = RXInterfaces . Image ; export let Image : RXInterfaces . ImageConstructor = ImageImpl ; export type Input = RXInterfaces . Input ; export let Input : RXInterfaces . Input = InputImpl ; export type International = RXInterfaces . International ; export let International : RXInterfaces . International = InternationalImpl ; export type Link = RXInterfaces . Link ; export let Link : typeof RXInterfaces . Link = LinkImpl ; export type Linking = RXInterfaces . Linking ; export let Linking : RXInterfaces . Linking = LinkingImpl ; export type Location = RXInterfaces . Location ; export let Location : RXInterfaces . Location = LocationImpl ; export type Modal = RXInterfaces . Modal ; export let Modal : RXInterfaces . Modal = ModalImpl ; export type Platform = RXInterfaces . Platform ; export let Platform : RXInterfaces . Platform = PlatformImpl ; export type Popup = RXInterfaces . Popup ; export let Popup : RXInterfaces . Popup = PopupImpl ; export type ScrollView = RXInterfaces . ScrollView ; export let ScrollView : RXInterfaces . ScrollViewConstructor = ScrollViewImpl ; export type StatusBar = RXInterfaces . StatusBar ; export let StatusBar : RXInterfaces . StatusBar = StatusBarImpl ; export type Storage = RXInterfaces . Storage ; export let Storage : RXInterfaces . Storage = StorageImpl ; export type Styles = RXInterfaces . Styles ; export let Styles : RXInterfaces . Styles = StylesImpl ; export type Text = RXInterfaces . Text ; export let Text : typeof RXInterfaces . Text = TextImpl ; export type TextInput = RXInterfaces . TextInput ; export let TextInput : typeof RXInterfaces . TextInput = TextInputImpl ; export type UserInterface = RXInterfaces . UserInterface ; export let UserInterface : RXInterfaces . UserInterface = UserInterfaceImpl ; export type UserPresence = RXInterfaces . UserPresence ; export let UserPresence : RXInterfaces . UserPresence = UserPresenceImpl ; export type View = RXInterfaces . View ; export let View : typeof RXInterfaces . View = ViewImpl ; export import Animated = AnimatedImpl ; export import CommonProps = RXTypes . CommonProps ; export import CommonStyledProps = RXTypes . CommonStyledProps ; export import Stateless = RXTypes . Stateless ; export import Types = RXTypes ; export import Component = React . Component ; export import ComponentBase = RXTypes . ComponentBase ; export import createElement = React . createElement ; export import Children = React . Children ; export let __spread = ( React as any ) . __spread ; export import Fragment = React . Fragment ; } ViewBase . setActivationState ( AppImpl . getActivationState ( ) ) ; AppImpl . activationStateChangedEvent . subscribe ( newState => { ViewBase . setActivationState ( newState ) ; } ) ; var _rxImplementsRxInterface : typeof RXModuleInterface . ReactXP = ReactXP ; _rxImplementsRxInterface = _rxImplementsRxInterface ; export = ReactXP ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as ReactXP from 's' ; export = ReactXP ;	O O O O O O O O O O O
import * as RN from 's' ; import { Accessibility as CommonAccessibility } from 's' ; import AppConfig from 's' ; import { Types } from 's' ; export interface MacComponentAccessibilityProps { onClick ? : ( e : Types . SyntheticEvent ) => void ; acceptsKeyboardFocus ? : true ; enableFocusRing ? : true ; } export class Accessibility extends CommonAccessibility { protected _isScreenReaderEnabled = false ; constructor ( ) { super ( ) ; let initialStateChanged = false ; if ( RN . AccessibilityInfo ) { RN . AccessibilityInfo . addEventListener ( 's' , ( isEnabled ) => { initialStateChanged = true ; this . _updateScreenReaderStatus ( isEnabled ) ; } ) ; RN . AccessibilityInfo . fetch ( ) . then ( isEnabled => { if ( ! initialStateChanged ) { this . _updateScreenReaderStatus ( isEnabled ) ; } } ) . catch ( err => { if ( AppConfig . isDevelopmentMode ( ) ) { console . error ( 's' ) ; } } ) ; } } protected _updateScreenReaderStatus ( isEnabled ) { if ( this . _isScreenReaderEnabled !== isEnabled ) { this . _isScreenReaderEnabled = isEnabled ; this . screenReaderChangedEvent . fire ( isEnabled ) ; } } isScreenReaderEnabled ( ) { return this . _isScreenReaderEnabled ; } } export default new Accessibility ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O
import { Accessibility as NativeAccessibility , default as parentInstance } from 's' ; export class Accessibility extends NativeAccessibility { private _lastAnnouncement : string | undefined ; announceForAccessibility ( announcement ) { if ( announcement === this . _lastAnnouncement ) { announcement += 's' ; } this . _lastAnnouncement = announcement ; parentInstance . announceForAccessibility ( announcement ) ; } } export default new Accessibility ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import { Types } from 's' ; export type ImportantForAccessibilityValue = 's' | 's' | 's' | 's' ; export const ImportantForAccessibilityMap = { [ Types . ImportantForAccessibility . Auto ] : 's' as ImportantForAccessibilityValue , [ Types . ImportantForAccessibility . Yes ] : 's' as ImportantForAccessibilityValue , [ Types . ImportantForAccessibility . No ] : 's' as ImportantForAccessibilityValue , [ Types . ImportantForAccessibility . NoHideDescendants ] : 's' as ImportantForAccessibilityValue } ; export abstract class AccessibilityPlatformUtil { abstract setAccessibilityFocus ( component : React . Component < any , any > ) ; } export abstract class AccessibilityUtil { isHidden ( importantForAccessibility : Types . ImportantForAccessibility | undefined ) : true | undefined { if ( importantForAccessibility ) { const importantForAccessibilityString = this . importantForAccessibilityToString ( importantForAccessibility ) ; if ( importantForAccessibilityString === ImportantForAccessibilityMap [ Types . ImportantForAccessibility . NoHideDescendants ] ) { return true ; } } return undefined ; } importantForAccessibilityToString ( importantForAccessibility : Types . ImportantForAccessibility | undefined , defaultImportantForAccessibility ? : Types . ImportantForAccessibility ) : ImportantForAccessibilityValue | undefined { importantForAccessibility = importantForAccessibility || defaultImportantForAccessibility ; if ( importantForAccessibility && ImportantForAccessibilityMap [ importantForAccessibility ] ) { return ImportantForAccessibilityMap [ importantForAccessibility ] ; } return undefined ; } protected abstract accessibilityLiveRegionToString ( liveRegion : Types . AccessibilityLiveRegion ) : string | undefined ; protected abstract accessibilityTraitToString ( trait : Types . AccessibilityTrait | Types . AccessibilityTrait [ ] , defaultTrait ? : Types . AccessibilityTrait ) : string | string [ ] | undefined ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import * as RN from 's' ; import Accessibility from 's' ; import { AccessibilityPlatformUtil as CommonAccessibilityNativeUtil } from 's' ; export class AccessibilityUtil extends CommonAccessibilityNativeUtil { private _sendAccessibilityEvent ( component : React . Component < any , any > , eventId ) { setTimeout ( ( ) => { let nodeHandle ; try { nodeHandle = RN . findNodeHandle ( component ) ; } catch ( e ) { } if ( nodeHandle ) { RN . NativeModules . UIManager . sendAccessibilityEvent ( nodeHandle , eventId ) ; } } , 0 ) ; } setAccessibilityFocus ( component : React . Component < any , any > ) { const TYPE_VIEW_FOCUSED = 0 ; if ( Accessibility . isScreenReaderEnabled ( ) ) { this . _sendAccessibilityEvent ( component , TYPE_VIEW_FOCUSED ) ; } } } export default new AccessibilityUtil ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import clone = require ( 's' ) ; import compact = require ( 's' ) ; import extend = require ( 's' ) ; import filter = require ( 's' ) ; import findIndex = require ( 's' ) ; import findLast = require ( 's' ) ; import isEqual = require ( 's' ) ; import isUndefined = require ( 's' ) ; import last = require ( 's' ) ; import map = require ( 's' ) ; import max = require ( 's' ) ; import omit = require ( 's' ) ; import union = require ( 's' ) ; export { clone , compact , extend , filter , findIndex , findLast , isEqual , isUndefined , last , map , max , omit , union } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import * as RN from 's' ; import { AccessibilityPlatformUtil , AccessibilityUtil as CommonAccessibilityUtil } from 's' ; import { Types } from 's' ; import * as _ from 's' ; export { ImportantForAccessibilityValue } from 's' ; type AccessibilityLiveRegionValue = 's' | 's' | 's' ; const liveRegionMap : { [ key ] : AccessibilityLiveRegionValue } = { [ Types . AccessibilityLiveRegion . None ] : 's' , [ Types . AccessibilityLiveRegion . Assertive ] : 's' , [ Types . AccessibilityLiveRegion . Polite ] : 's' } ; const traitsMap : { [ key ] : string } = { [ Types . AccessibilityTrait . None ] : 's' , [ Types . AccessibilityTrait . Tab ] : 's' , [ Types . AccessibilityTrait . Button ] : 's' , [ Types . AccessibilityTrait . Link ] : 's' , [ Types . AccessibilityTrait . Header ] : 's' , [ Types . AccessibilityTrait . Search ] : 's' , [ Types . AccessibilityTrait . Image ] : 's' , [ Types . AccessibilityTrait . Summary ] : 's' , [ Types . AccessibilityTrait . Adjustable ] : 's' , [ Types . AccessibilityTrait . Selected ] : 's' , [ Types . AccessibilityTrait . Plays ] : 's' , [ Types . AccessibilityTrait . Key ] : 's' , [ Types . AccessibilityTrait . Text ] : 's' , [ Types . AccessibilityTrait . Disabled ] : 's' , [ Types . AccessibilityTrait . FrequentUpdates ] : 's' , [ Types . AccessibilityTrait . StartsMedia ] : 's' , [ Types . AccessibilityTrait . AllowsDirectInteraction ] : 's' , [ Types . AccessibilityTrait . PageTurn ] : 's' , [ Types . AccessibilityTrait . ListItem ] : 's' } ; type AccessibilityComponentTypeValue = 's' | 's' | 's' | 's' ; const componentTypeMap : { [ key ] : AccessibilityComponentTypeValue } = { [ Types . AccessibilityTrait . None ] : 's' , [ Types . AccessibilityTrait . Tab ] : 's' , [ Types . AccessibilityTrait . Button ] : 's' , [ Types . AccessibilityTrait . Radio_button_checked ] : 's' , [ Types . AccessibilityTrait . Radio_button_unchecked ] : 's' } ; export class AccessibilityUtil extends CommonAccessibilityUtil { private _instance ! : AccessibilityPlatformUtil ; setAccessibilityPlatformUtil ( instance ) { this . _instance = instance ; } accessibilityTraitToString ( overrideTraits : Types . AccessibilityTrait | Types . AccessibilityTrait [ ] | undefined , defaultTrait ? : Types . AccessibilityTrait , ensureDefaultTrait ? ) : RN . AccessibilityTrait [ ] | undefined { if ( ! overrideTraits && ! defaultTrait ) { return undefined ; } let traits : ( Types . AccessibilityTrait | undefined ) [ ] ; if ( defaultTrait && ensureDefaultTrait ) { if ( Array . isArray ( overrideTraits ) ) { traits = overrideTraits . indexOf ( defaultTrait ) === - 0 ? overrideTraits . concat ( [ defaultTrait ] ) : overrideTraits ; } else { traits = overrideTraits === defaultTrait ? [ overrideTraits ] : [ overrideTraits , defaultTrait ] ; } } else { traits = Array . isArray ( overrideTraits ) ? overrideTraits : [ overrideTraits || defaultTrait ] ; } return _ . compact ( _ . map ( traits , t => t ? traitsMap [ t ] : undefined ) ) as RN . AccessibilityTrait [ ] ; } accessibilityComponentTypeToString ( overrideTraits : Types . AccessibilityTrait | Types . AccessibilityTrait [ ] | undefined , defaultTrait ? : Types . AccessibilityTrait ) : AccessibilityComponentTypeValue | undefined { if ( ! overrideTraits && ! defaultTrait ) { return undefined ; } const combinedTraits = Array . isArray ( overrideTraits ) ? overrideTraits : [ overrideTraits || defaultTrait ] ; const maxTrait = _ . max ( _ . filter ( combinedTraits , t => componentTypeMap . hasOwnProperty ( t as any ) ) ) ; return maxTrait ? componentTypeMap [ maxTrait ] : undefined ; } accessibilityLiveRegionToString ( liveRegion : Types . AccessibilityLiveRegion | undefined ) : AccessibilityLiveRegionValue | undefined { if ( liveRegion && liveRegionMap [ liveRegion ] ) { return liveRegionMap [ liveRegion ] ; } return undefined ; } setAccessibilityFocus ( component : React . Component < any , any > ) { this . _instance . setAccessibilityFocus ( component ) ; } } export default new AccessibilityUtil ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AccessibilityPlatformUtil$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RN from 's' ; import AppConfig from 's' ; import * as RX from 's' ; import UserInterface from 's' ; export class Alert implements RX . Alert { show ( title , message ? , buttons ? : RX . Types . AlertButtonSpec [ ] , options ? : RX . Types . AlertOptions ) { const alertOptions : RN . ExtendedAlertOptions = { } ; if ( ! ! options && options . preventDismissOnPress ) { alertOptions . cancelable = false ; } if ( options && options . rootViewId ) { const nodeHandle = UserInterface . findNodeHandleByRootViewId ( options . rootViewId ) ; if ( nodeHandle ) { alertOptions . rootViewHint = nodeHandle ; } else if ( AppConfig . isDevelopmentMode ( ) ) { console . warn ( 's' , options . rootViewId ) ; } } RN . Alert . alert ( title , message , buttons , alertOptions ) ; } } export default new Alert ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RN from 's' ; import * as RX from 's' ; import { RootView , RootViewUsingProps } from 's' ; import UserInterface from 's' ; const _rnStateToRxState : { [ key ] : RX . Types . AppActivationState } = { 's' : RX . Types . AppActivationState . Active , 's' : RX . Types . AppActivationState . Active , 's' : RX . Types . AppActivationState . Background , 's' : RX . Types . AppActivationState . Inactive , 's' : RX . Types . AppActivationState . Extension , 's' : RX . Types . AppActivationState . Background } ; export class App extends RX . App { constructor ( ) { super ( ) ; RN . AppState . addEventListener ( 's' , ( newState ) => { this . activationStateChangedEvent . fire ( _rnStateToRxState [ newState ] || RX . Types . AppActivationState . Active ) ; } ) ; RN . AppState . addEventListener ( 's' , ( ) => { this . memoryWarningEvent . fire ( ) ; } ) ; } initialize ( debug , development ) { super . initialize ( debug , development ) ; window . rxdebug = debug ; RN . AppRegistry . registerComponent ( 's' , this . getRootViewFactory ( ) ) ; UserInterface . registerRootViewUsingPropsFactory ( this . getRootViewUsingPropsFactory ( ) ) ; } getActivationState ( ) : RX . Types . AppActivationState { return _rnStateToRxState [ RN . AppState . currentState ] || RX . Types . AppActivationState . Active ; } protected getRootViewFactory ( ) : RN . ComponentProvider { return ( ) => RootView ; } protected getRootViewUsingPropsFactory ( ) : RN . ComponentProvider { return ( ) => RootViewUsingProps ; } } export default new App ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RN from 's' ; import * as RX from 's' ; export class Clipboard extends RX . Clipboard { setText ( text ) { RN . Clipboard . setString ( text ) ; } getText ( ) < string > { return RN . Clipboard . getString ( ) ; } } export default new Clipboard ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O
import * as RN from 's' ; import * as RX from 's' ; export class Input extends RX . Input { constructor ( ) { super ( ) ; RN . BackHandler . addEventListener ( 's' , ( ) => { return this . backButtonEvent . fire ( ) ; } ) ; } } export default new Input ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RN from 's' ; import * as RX from 's' ; export class International implements RX . International { private _isRTL : boolean ; constructor ( ) { this . _isRTL = RN . 0 . isRTL ; RN . DeviceEventEmitter . addListener ( 's' , ( payload : RN . RtlEventNativePayload ) => { this . _isRTL = payload . isRTL ; } ) ; } allowRTL ( allow ) { RN . 0 . allowRTL ( allow ) ; } forceRTL ( force ) { RN . 0 . forceRTL ( force ) ; } isRTL ( ) { return this . _isRTL ; } } export default new International ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O
import * as RN from 's' ; import { Types } from 's' ; import { Linking as CommonLinking } from 's' ; export class Linking extends CommonLinking { constructor ( ) { super ( ) ; RN . Linking . addEventListener ( 's' , ( event : { url : string } ) => { this . deepLinkRequestEvent . fire ( event . url ) ; } ) ; } protected _openUrl ( url ) < void > { return RN . Linking . canOpenURL ( url ) . then ( value => { if ( ! value ) { const linkingError : Types . LinkingErrorInfo = { code : Types . LinkingErrorCode . NoAppFound , url : url , description : 's' + url } ; return Promise . reject ( linkingError ) ; } else { return RN . Linking . openURL ( url ) ; } } ) . catch ( error => { const linkingError : Types . LinkingErrorInfo = { code : Types . LinkingErrorCode . UnexpectedFailure , url : url , description : error } ; return Promise . reject ( linkingError ) ; } ) ; } getInitialUrl ( ) < string | undefined > { return RN . Linking . getInitialURL ( ) . then ( url => ! ! url ? url : undefined ) . catch ( error => { const linkingError : Types . LinkingErrorInfo = { code : Types . LinkingErrorCode . InitialUrlNotFound , description : error } ; return Promise . reject ( linkingError ) ; } ) ; } launchEmail ( emailInfo : Types . EmailInfo ) < void > { const emailUrl = this . _createEmailUrl ( emailInfo ) ; return this . _openUrl ( emailUrl ) ; } } export default new Linking ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import assert from 's' ; import * as RX from 's' ; import FrontLayerViewManager from 's' ; export class Modal extends RX . Modal { isDisplayed ( modalId ? ) { return FrontLayerViewManager . isModalDisplayed ( modalId ) ; } show ( modal : React . ReactElement < RX . Types . ViewProps > , modalId , options ? : RX . Types . ModalOptions ) { assert ( modal , `template` ) ; assert ( modalId , `template` ) ; FrontLayerViewManager . showModal ( modal , modalId , options ) ; } dismiss ( modalId ) { assert ( modalId , `template` ) ; FrontLayerViewManager . dismissModal ( modalId ) ; } dismissAll ( ) { FrontLayerViewManager . dismissAllmodals ( ) ; } } export default new Modal ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O $string$ O O O O O O O O O O O $void$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O
import * as RN from 's' ; import * as RX from 's' ; export class Platform extends RX . Platform { getType ( ) : RX . Types . PlatformType { return RN . Platform . OS ; } select < T > ( specifics : { [ platform in RX . Types . PlatformType | 's' ] ? : T } ) : T | undefined { const platformType = this . getType ( ) ; return platformType in specifics ? specifics [ platformType ] : specifics . default ; } } export default new Platform ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import assert from 's' ; import * as RX from 's' ; import Timers from 's' ; import FrontLayerViewManager from 's' ; export class Popup extends RX . Popup { show ( options : RX . Types . PopupOptions , popupId , delay ? ) { assert ( popupId , `template` ) ; assert ( this . _isValidAnchor ( options ) , `template` ) ; return FrontLayerViewManager . showPopup ( options , popupId , delay ) ; } autoDismiss ( popupId , delay ? ) { assert ( popupId , `template` ) ; Timers . setTimeout ( ( ) => FrontLayerViewManager . dismissPopup ( popupId ) , delay || 0 ) ; } dismiss ( popupId ) { assert ( popupId , `template` ) ; FrontLayerViewManager . dismissPopup ( popupId ) ; } dismissAll ( ) { FrontLayerViewManager . dismissAllPopups ( ) ; } isDisplayed ( popupId ? ) { return FrontLayerViewManager . isPopupDisplayed ( popupId ) ; } private _isValidAnchor ( options : RX . Types . PopupOptions ) { return options && typeof options . getAnchor === 's' && ! ! options . getAnchor ( ) ; } } export default new Popup ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O $string$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O $boolean$ O O $string$ O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RN from 's' ; import * as RX from 's' ; import { Defer } from 's' ; export class Storage extends RX . Storage { getItem ( key ) < string | undefined > { const deferred = new Defer < string | undefined > ( ) ; RN . AsyncStorage . getItem ( key , ( error , result : string | undefined ) => { if ( ! error ) { deferred . resolve ( result || undefined ) ; } else { deferred . reject ( error ) ; } } ) . catch ( err => { deferred . reject ( err ) ; } ) ; return deferred . promise ( ) ; } setItem ( key , value ) < void > { const deferred = new Defer < void > ( ) ; RN . AsyncStorage . setItem ( key , value , ( error ) => { if ( ! error ) { deferred . resolve ( void 0 ) ; } else { deferred . reject ( error ) ; } } ) . catch ( err => { deferred . reject ( err ) ; } ) ; return deferred . promise ( ) ; } removeItem ( key ) < void > { const deferred = new Defer < void > ( ) ; RN . AsyncStorage . removeItem ( key , ( error ) => { if ( ! error ) { deferred . resolve ( void 0 ) ; } else { deferred . reject ( error ) ; } } ) . catch ( err => { deferred . reject ( err ) ; } ) ; return deferred . promise ( ) ; } clear ( ) < void > { const deferred = new Defer < void > ( ) ; RN . AsyncStorage . clear ( ( error ) => { if ( ! error ) { deferred . resolve ( void 0 ) ; } else { deferred . reject ( error ) ; } } ) . catch ( err => { deferred . reject ( err ) ; } ) ; return deferred . promise ( ) ; } } export default new Storage ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RN from 's' ; import { StyleLeakDetector as CommonStyleLeakDetector } from 's' ; export class StyleLeakDetector extends CommonStyleLeakDetector { protected isDisabled ( ) { return RN . Platform . OS === 's' ; } } export default new StyleLeakDetector ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O
import * as RN from 's' ; import AppConfig from 's' ; import * as RX from 's' ; import { omit } from 's' ; import Platform from 's' ; import StyleLeakDetector from 's' ; const forbiddenProps : string [ ] = [ 's' , 's' , 's' ] ; if ( Platform . getType ( ) !== 's' ) { forbiddenProps . push ( 's' , 's' , 's' ) ; } type ReactNativeViewAndImageCommonStyle < Style extends RX . Types . ViewAndImageCommonStyle > = Style & { flexGrow ? : number ; flexShrink ? : number ; flexBasis ? : number ; textShadowColor ? : string ; textShadowOffset ? : RX . Types . ShadowOffset ; textShadowRadius ? : number ; } ; export class Styles extends RX . Styles { combine < S > ( 0 : RX . Types . StyleRuleSetRecursive < S > | undefined , 0 ? : RX . Types . StyleRuleSetRecursive < S > ) : RX . Types . StyleRuleSetOrArray < S > | undefined { if ( ! 0 && ! 0 ) { return undefined ; } const ruleSet = 0 ? ( 0 ? [ 0 , 0 ] : 0 ) : 0 ; if ( ruleSet instanceof Array ) { let resultArray : RX . Types . StyleRuleSet < S > [ ] = [ ] ; for ( let i = 0 ; i < ruleSet . length ; i ++ ) { const subRuleSet = this . combine ( ruleSet [ i ] ) ; if ( subRuleSet ) { if ( subRuleSet instanceof Array ) { resultArray = resultArray . concat ( subRuleSet ) ; } else { resultArray . push ( subRuleSet ) ; } } } if ( resultArray . length === 0 ) { return undefined ; } if ( resultArray . length === 0 ) { return resultArray [ 0 ] ; } return resultArray ; } return ruleSet ; } createViewStyle ( ruleSet : RX . Types . ViewStyle , cacheStyle = true ) : RX . Types . ViewStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle ) ; } createAnimatedViewStyle ( ruleSet : RX . Types . AnimatedViewStyle ) : RX . Types . AnimatedViewStyleRuleSet { return this . _adaptAnimatedStyles ( ruleSet ) ; } createScrollViewStyle ( ruleSet : RX . Types . ScrollViewStyle , cacheStyle = true ) : RX . Types . ScrollViewStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle ) ; } createButtonStyle ( ruleSet : RX . Types . ButtonStyle , cacheStyle = true ) : RX . Types . ButtonStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle ) ; } createTextStyle ( ruleSet : RX . Types . TextStyle , cacheStyle = true ) : RX . Types . TextStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle , true ) ; } createAnimatedTextStyle ( ruleSet : RX . Types . AnimatedTextStyle ) : RX . Types . AnimatedTextStyleRuleSet { return this . _adaptAnimatedStyles ( ruleSet ) ; } createTextInputStyle ( ruleSet : RX . Types . TextInputStyle , cacheStyle = true ) : RX . Types . TextInputStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle , true ) ; } createAnimatedTextInputStyle ( ruleSet : RX . Types . AnimatedTextInputStyle ) : RX . Types . AnimatedTextInputStyleRuleSet { return this . _adaptAnimatedStyles ( ruleSet ) ; } createImageStyle ( ruleSet : RX . Types . ImageStyle , cacheStyle = true ) : RX . Types . ImageStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle ) ; } createAnimatedImageStyle ( ruleSet : RX . Types . AnimatedImageStyle ) : RX . Types . AnimatedImageStyleRuleSet { return this . _adaptAnimatedStyles ( ruleSet ) ; } createLinkStyle ( ruleSet : RX . Types . LinkStyle , cacheStyle = true ) : RX . Types . LinkStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle ) ; } createPickerStyle ( ruleSet : RX . Types . PickerStyle , cacheStyle = true ) : RX . Types . PickerStyleRuleSet { return this . _adaptStyles ( ruleSet , cacheStyle ) ; } getCssPropertyAliasesCssStyle ( ) : { [ key ] : string } { return { } ; } private _adaptStyles < S extends RX . Types . ViewAndImageCommonStyle > ( def : S , cacheStyle , isTextStyle = false ) < RX . Types . StyleRuleSet < S > > { let adaptedRuleSet = def as ReactNativeViewAndImageCommonStyle < S > ; if ( cacheStyle ) { StyleLeakDetector . detectLeaks ( def ) ; adaptedRuleSet = omit < S > ( adaptedRuleSet , forbiddenProps ) as ReactNativeViewAndImageCommonStyle < S > ; } const textStyle = adaptedRuleSet as RX . Types . TextStyle ; if ( textStyle . font ) { if ( textStyle . font . fontFamily !== undefined ) { textStyle . fontFamily = textStyle . font . fontFamily ; } if ( textStyle . font . fontWeight !== undefined ) { textStyle . fontWeight = textStyle . font . fontWeight ; } if ( textStyle . font . fontStyle !== undefined ) { textStyle . fontStyle = textStyle . font . fontStyle ; } delete textStyle . font ; } if ( isTextStyle ) { if ( textStyle . shadowColor !== undefined ) { adaptedRuleSet . textShadowColor = textStyle . shadowColor ; delete textStyle . shadowColor ; } if ( textStyle . shadowOffset !== undefined ) { adaptedRuleSet . textShadowOffset = textStyle . shadowOffset ; delete textStyle . shadowOffset ; } if ( textStyle . shadowRadius !== undefined ) { adaptedRuleSet . textShadowRadius = textStyle . shadowRadius ; delete textStyle . shadowRadius ; } } if ( def . flex !== undefined ) { if ( AppConfig . isDevelopmentMode ( ) ) { if ( adaptedRuleSet . flexGrow !== undefined || adaptedRuleSet . flexShrink !== undefined ) { console . error ( 's' ) ; } } const flexValue = def . flex ; delete adaptedRuleSet . flex ; if ( flexValue > 0 ) { adaptedRuleSet . flexGrow = flexValue ; adaptedRuleSet . flexShrink = 0 ; } else if ( flexValue < 0 ) { adaptedRuleSet . flexGrow = 0 ; adaptedRuleSet . flexShrink = - flexValue ; } else { adaptedRuleSet . flexGrow = 0 ; adaptedRuleSet . flexShrink = 0 ; } } if ( cacheStyle ) { return RN . StyleSheet . create ( { _style : adaptedRuleSet } ) . _style ; } return AppConfig . isDevelopmentMode ( ) ? Object . freeze ( adaptedRuleSet ) : adaptedRuleSet ; } private _adaptAnimatedStyles < T extends RX . Types . AnimatedViewAndImageCommonStyle > ( def : T ) < T > { const adaptedRuleSet = omit < T > ( def , forbiddenProps ) as T ; return AppConfig . isDevelopmentMode ( ) ? Object . freeze ( adaptedRuleSet ) : adaptedRuleSet ; } } export default new Styles ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $Readonly$ O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Readonly$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; export class UserPresence extends RX . UserPresence { isUserPresent ( ) { return true ; } } export default new UserPresence ( ) ;	O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O
import * as RN from 's' ; import * as RX from 's' ; export class StatusBar extends RX . StatusBar { isOverlay ( ) { return false ; } setHidden ( hidden , showHideTransition : 's' | 's' ) { RN . StatusBar . setHidden ( hidden , showHideTransition ) ; } setBackgroundColor ( color , animated ) { RN . StatusBar . setBackgroundColor ( color , animated ) ; } setTranslucent ( translucent ) { RN . StatusBar . setTranslucent ( translucent ) ; } setBarStyle ( style : 's' | 's' | 's' , animated ) { } setNetworkActivityIndicatorVisible ( value ) { } } export default new StatusBar ( ) ;	O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O $void$ O $boolean$ O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O $boolean$ O O O O O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O O O O $void$ O O O O O O O O O $boolean$ O O O $void$ O $boolean$ O O O O O O O O O O O
import React = require ( 's' ) ; import RN = require ( 's' ) ; import AccessibilityUtil from 's' ; import ActivityIndicatorImpl from 's' ; import AlertImpl from 's' ; import { CommonAnimatedClasses , makeAnimated } from 's' ; import AppImpl from 's' ; import ButtonImpl from 's' ; import ClipboardImpl from 's' ; import InputImpl from 's' ; import RXInterfaces = require ( 's' ) ; import InternationalImpl from 's' ; import LinkImpl from 's' ; import LinkingImpl from 's' ; import LocationImpl from 's' ; import ModalImpl from 's' ; import RXModuleInterface = require ( 's' ) ; import PickerImpl from 's' ; import PlatformImpl from 's' ; import PopupImpl from 's' ; import ScrollViewImpl from 's' ; import StorageImpl from 's' ; import StylesImpl from 's' ; import TextInputImpl from 's' ; import RXTypes = require ( 's' ) ; import UserInterfaceImpl from 's' ; import UserPresenceImpl from 's' ; import ViewImpl from 's' ; import AccessibilityImpl from 's' ; import AccessibilityPlatformUtil from 's' ; import GestureViewImpl from 's' ; import ImageImpl from 's' ; import StatusBarImpl from 's' ; import TextImpl from 's' ; AccessibilityUtil . setAccessibilityPlatformUtil ( AccessibilityPlatformUtil ) ; module ReactXP { export type Accessibility = RXInterfaces . Accessibility ; export let Accessibility : RXInterfaces . Accessibility = AccessibilityImpl ; export type ActivityIndicator = RXInterfaces . ActivityIndicator ; export let ActivityIndicator : typeof RXInterfaces . ActivityIndicator = ActivityIndicatorImpl ; export type Alert = RXInterfaces . Alert ; export let Alert : RXInterfaces . Alert = AlertImpl ; export type App = RXInterfaces . App ; export let App : RXInterfaces . App = AppImpl ; export type Button = RXInterfaces . Button ; export let Button : typeof RXInterfaces . Button = ButtonImpl ; export type Picker = RXInterfaces . Picker ; export let Picker : typeof RXInterfaces . Picker = PickerImpl ; export type Clipboard = RXInterfaces . Clipboard ; export let Clipboard : RXInterfaces . Clipboard = ClipboardImpl ; export type GestureView = RXInterfaces . GestureView ; export let GestureView : typeof RXInterfaces . GestureView = GestureViewImpl ; export type Image = RXInterfaces . Image ; export let Image : RXInterfaces . ImageConstructor = ImageImpl ; export type Input = RXInterfaces . Input ; export let Input : RXInterfaces . Input = InputImpl ; export type International = RXInterfaces . International ; export let International : RXInterfaces . International = InternationalImpl ; export type Link = RXInterfaces . Link ; export let Link : typeof RXInterfaces . Link = LinkImpl ; export type Linking = RXInterfaces . Linking ; export let Linking : RXInterfaces . Linking = LinkingImpl ; export type Location = RXInterfaces . Location ; export let Location : RXInterfaces . Location = LocationImpl ; export type Modal = RXInterfaces . Modal ; export let Modal : RXInterfaces . Modal = ModalImpl ; export type Platform = RXInterfaces . Platform ; export let Platform : RXInterfaces . Platform = PlatformImpl ; export type Popup = RXInterfaces . Popup ; export let Popup : RXInterfaces . Popup = PopupImpl ; export type ScrollView = RXInterfaces . ScrollView ; export let ScrollView : RXInterfaces . ScrollViewConstructor = ScrollViewImpl ; export type StatusBar = RXInterfaces . StatusBar ; export let StatusBar : RXInterfaces . StatusBar = StatusBarImpl ; export type Storage = RXInterfaces . Storage ; export let Storage : RXInterfaces . Storage = StorageImpl ; export type Styles = RXInterfaces . Styles ; export let Styles : RXInterfaces . Styles = StylesImpl ; export type Text = RXInterfaces . Text ; export let Text : typeof RXInterfaces . Text = TextImpl ; export type TextInput = RXInterfaces . TextInput ; export let TextInput : typeof RXInterfaces . TextInput = TextInputImpl ; export type UserInterface = RXInterfaces . UserInterface ; export let UserInterface : RXInterfaces . UserInterface = UserInterfaceImpl ; export type UserPresence = RXInterfaces . UserPresence ; export let UserPresence : RXInterfaces . UserPresence = UserPresenceImpl ; export type View = RXInterfaces . View ; export let View : typeof RXInterfaces . View = ViewImpl ; const androidAnimatedClasses = { ... CommonAnimatedClasses , Text : RN . Animated . createAnimatedComponent ( TextImpl ) } ; export const Animated = makeAnimated ( androidAnimatedClasses ) ; export import CommonProps = RXTypes . CommonProps ; export import CommonStyledProps = RXTypes . CommonStyledProps ; export import Stateless = RXTypes . Stateless ; export import Types = RXTypes ; export import Component = React . Component ; export import ComponentBase = RXTypes . ComponentBase ; export import createElement = React . createElement ; export import Children = React . Children ; export let __spread = ( React as any ) . __spread ; export import Fragment = React . Fragment ; } var _rxImplementsRxInterface : typeof RXModuleInterface . ReactXP = ReactXP ; _rxImplementsRxInterface = _rxImplementsRxInterface ; export = ReactXP ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const NEWTON_ITERATIONS = 0 ; const NEWTON_MIN_SLOPE = 0 ; const SUBDIVISION_PRECISION = 0 ; const SUBDIVISION_MAX_ITERATIONS = 0 ; const kSplineTableSize = 0 ; const kSampleStepSize = 0 / ( kSplineTableSize - 0 ) ; const 0 = typeof 0 === 's' ; function A ( 0 , 0 ) { return 0 - 0 * 0 + 0 * 0 ; } function B ( 0 , 0 ) { return 0 * 0 - 0 * 0 ; } function C ( 0 ) { return 0 * 0 ; } function calcBezier ( aT , 0 , 0 ) { return ( ( A ( 0 , 0 ) * aT + B ( 0 , 0 ) ) * aT + C ( 0 ) ) * aT ; } function getSlope ( aT , 0 , 0 ) { return 0 * A ( 0 , 0 ) * aT * aT + 0 * B ( 0 , 0 ) * aT + C ( 0 ) ; } function binarySubdivide ( aX , aA , aB , 0 , 0 ) { let currentX = 0 ; let currentT = 0 ; let i = 0 ; do { currentT = aA + ( aB - aA ) / 0 ; currentX = calcBezier ( currentT , 0 , 0 ) - aX ; if ( currentX > 0 ) { aB = currentT ; } else { aA = currentT ; } } while ( Math . abs ( currentX ) > SUBDIVISION_PRECISION && ++ i < SUBDIVISION_MAX_ITERATIONS ) ; return currentT ; } function newtonRaphsonIterate ( aX , aGuessT , 0 , 0 ) { for ( let i = 0 ; i < NEWTON_ITERATIONS ; ++ i ) { const currentSlope = getSlope ( aGuessT , 0 , 0 ) ; if ( currentSlope === 0 ) { return aGuessT ; } const currentX = calcBezier ( aGuessT , 0 , 0 ) - aX ; aGuessT -= currentX / currentSlope ; } return aGuessT ; } export function bezier ( 0 , 0 , 0 , 0 ) { if ( ! ( 0 <= 0 && 0 <= 0 && 0 <= 0 && 0 <= 0 ) ) { throw new Error ( 's' ) ; } const sampleValues = 0 ? new 0 ( kSplineTableSize ) : new Array ( kSplineTableSize ) ; if ( 0 !== 0 || 0 !== 0 ) { for ( let i = 0 ; i < kSplineTableSize ; ++ i ) { sampleValues [ i ] = calcBezier ( i * kSampleStepSize , 0 , 0 ) ; } } function getTForX ( aX ) { let intervalStart = 0 ; let currentSample = 0 ; const lastSample = kSplineTableSize - 0 ; for ( ; currentSample !== lastSample && sampleValues [ currentSample ] <= aX ; ++ currentSample ) { intervalStart += kSampleStepSize ; } -- currentSample ; const dist = ( aX - sampleValues [ currentSample ] ) / ( sampleValues [ currentSample + 0 ] - sampleValues [ currentSample ] ) ; const guessForT = intervalStart + dist * kSampleStepSize ; const initialSlope = getSlope ( guessForT , 0 , 0 ) ; if ( initialSlope >= NEWTON_MIN_SLOPE ) { return newtonRaphsonIterate ( aX , guessForT , 0 , 0 ) ; } else if ( initialSlope === 0 ) { return guessForT ; } else { return binarySubdivide ( aX , intervalStart , intervalStart + kSampleStepSize , 0 , 0 ) ; } } return function BezierEasing ( x ) { if ( 0 === 0 && 0 === 0 ) { return x ; } if ( x === 0 ) { return 0 ; } if ( x === 0 ) { return 0 ; } return calcBezier ( getTForX ( x ) , 0 , 0 ) ; } ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Bezier from 's' ; import { Types } from 's' ; export class Easing implements Types . Animated . Easing { CubicBezier ( 0 , 0 , 0 , 0 ) : Types . Animated . EasingFunction { return { cssName : 's' + 0 . toString ( ) + 's' + 0 . toString ( ) + 's' + 0 . toString ( ) + 's' + 0 . toString ( ) + 's' , function : Bezier . bezier ( 0 , 0 , 0 , 0 ) } ; } Default ( ) : Types . Animated . EasingFunction { const bezier = this . CubicBezier ( 0 , 0 , 0 , 0 ) ; return { cssName : 's' , function : bezier . function } ; } Linear ( ) : Types . Animated . EasingFunction { return { cssName : 's' , function : ( input ) => input } ; } Out ( ) : Types . Animated . EasingFunction { const bezier = this . CubicBezier ( 0 , 0 , 0 , 0 ) ; return { cssName : 's' , function : bezier . function } ; } In ( ) : Types . Animated . EasingFunction { const bezier = this . CubicBezier ( 0 , 0 , 0 , 0 ) ; return { cssName : 's' , function : bezier . function } ; } InOut ( ) : Types . Animated . EasingFunction { const bezier = this . CubicBezier ( 0 , 0 , 0 , 0 ) ; return { cssName : 's' , function : bezier . function } ; } OutBack ( ) : Types . Animated . EasingFunction { const bezier = this . CubicBezier ( 0 , 0 , 0 , 0 ) ; return { cssName : bezier . cssName , function : bezier . function } ; } InBack ( ) : Types . Animated . EasingFunction { const bezier = this . CubicBezier ( 0 , - 0 , 0 , 0 ) ; return { cssName : bezier . cssName , function : bezier . function } ; } InOutBack ( ) : Types . Animated . EasingFunction { const bezier = this . CubicBezier ( 0 , - 0 , 0 , 0 ) ; return { cssName : bezier . cssName , function : bezier . function } ; } Steps ( intervals , end = true ) : Types . Animated . EasingFunction { return { cssName : 's' + intervals . toString ( ) + 's' + ( end ? 's' : 's' ) + 's' , function : ( input ) => { let interval = intervals * input ; if ( end ) { interval = Math . floor ( interval ) ; } else { interval = Math . ceil ( interval ) ; } return interval / intervals ; } } ; } StepStart ( ) : Types . Animated . EasingFunction { const steps = this . Steps ( 0 , false ) ; return { cssName : 's' , function : steps . function } ; } StepEnd ( ) : Types . Animated . EasingFunction { const steps = this . Steps ( 0 , true ) ; return { cssName : 's' , function : steps . function } ; } } export default new Easing ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ImageResizeMode } from 's' ; export const DEFAULT_RESIZE_MODE = 's' ;	O O O O O O O O O $ImageResizeMode$ O O O
import * as RN from 's' ; import { Accessibility as NativeAccessibility } from 's' ; interface AnnouncementFinishedPayload { announcement : string ; success : boolean ; } const RetryTimeout = 0 ; export class Accessibility extends NativeAccessibility { private _announcementQueue : string [ ] = [ ] ; private _retryTimestamp = NaN ; constructor ( ) { super ( ) ; if ( RN . AccessibilityInfo ) { RN . AccessibilityInfo . addEventListener ( 's' , this . _recalcAnnouncement ) ; RN . AppState . addEventListener ( 's' , this . _trackQueueStatus ) ; } } protected _updateScreenReaderStatus ( isEnabled ) { super . _updateScreenReaderStatus ( isEnabled ) ; if ( ! isEnabled && this . _announcementQueue . length > 0 ) { this . _announcementQueue = [ ] ; } } announceForAccessibility ( announcement ) { super . announceForAccessibility ( announcement ) ; if ( this . _isScreenReaderEnabled ) { this . _announcementQueue . push ( announcement ) ; if ( this . _announcementQueue . length === 0 ) { this . _postAnnouncement ( announcement ) ; } } } private _trackQueueStatus = ( newState ) => { if ( this . _isScreenReaderEnabled && [ 's' , 's' ] . indexOf ( newState ) >= 0 ) { this . _announcementQueue = [ ] ; this . _retryTimestamp = NaN ; } } private _postAnnouncement ( announcement , resetTimestamp = true ) { if ( resetTimestamp ) { this . _retryTimestamp = Date . now ( ) ; } if ( RN . AccessibilityInfo && RN . AccessibilityInfo . announceForAccessibility ) { RN . AccessibilityInfo . announceForAccessibility ( announcement ) ; } } private _recalcAnnouncement = ( payload ) => { if ( this . _announcementQueue . length === 0 ) { return ; } const postedAnnouncement = this . _announcementQueue [ 0 ] ; if ( this . _compareRawAnnouncements ( postedAnnouncement , payload . announcement ) ) { const timeElapsed = Date . now ( ) - this . _retryTimestamp ; if ( ! payload . success && timeElapsed < RetryTimeout ) { this . _postAnnouncement ( payload . announcement , false ) ; } else { this . _announcementQueue . shift ( ) ; if ( this . _announcementQueue . length > 0 ) { const nextAnnouncement = this . _announcementQueue [ 0 ] ; this . _postAnnouncement ( nextAnnouncement ) ; } } } } private _compareRawAnnouncements ( postedAnnouncement , payloadAnnouncement ) { const spacesCommasRegExp = "s" ; return payloadAnnouncement . replace ( spacesCommasRegExp , 's' ) === postedAnnouncement . replace ( spacesCommasRegExp , 's' ) ; } } export default new Accessibility ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AnnouncementFinishedPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import * as RN from 's' ; import Accessibility from 's' ; import { AccessibilityPlatformUtil } from 's' ; export class AccessibilityUtil extends AccessibilityPlatformUtil { setAccessibilityFocus ( component : React . Component < any , any > ) { if ( Accessibility . isScreenReaderEnabled ( ) && RN . AccessibilityInfo && RN . AccessibilityInfo . setAccessibilityFocus ) { const nodeHandle = RN . findNodeHandle ( component ) ; if ( nodeHandle ) { RN . AccessibilityInfo . setAccessibilityFocus ( nodeHandle ) ; } else { console . warn ( 's' ) ; } } } } export default new AccessibilityUtil ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Types } from 's' ; import { Linking as CommonLinking } from 's' ; export class Linking extends CommonLinking { protected _createSmsUrl ( smsInfo : Types . SmsInfo ) { let smsUrl = 's' ; if ( smsInfo . phoneNumber ) { smsUrl += encodeURI ( smsInfo . phoneNumber ) ; } if ( smsInfo . body ) { smsUrl += 's' + encodeURIComponent ( smsInfo . body ) ; } return smsUrl ; } } export default new Linking ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RN from 's' ; import * as RX from 's' ; export class StatusBar extends RX . StatusBar { isOverlay ( ) { return true ; } setBarStyle ( style : 's' | 's' | 's' , animated ) { RN . StatusBar . setBarStyle ( style , animated ) ; } setHidden ( hidden , showHideTransition : 's' | 's' ) { RN . StatusBar . setHidden ( hidden , showHideTransition ) ; } setNetworkActivityIndicatorVisible ( value ) { RN . StatusBar . setNetworkActivityIndicatorVisible ( value ) ; } setBackgroundColor ( color , animated ) { } setTranslucent ( translucent ) { } } export default new StatusBar ( ) ;	O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O $void$ O O O O O O O O O $boolean$ O O O O O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O O O O O O O O O O O O $void$ O $boolean$ O O O O O O O O O O O O $void$ O $string$ O $boolean$ O O O $void$ O $boolean$ O O O O O O O O O O O
import React = require ( 's' ) ; import AccessibilityUtil from 's' ; import ActivityIndicatorImpl from 's' ; import AlertImpl from 's' ; import AnimatedImpl = require ( 's' ) ; import AppImpl from 's' ; import ButtonImpl from 's' ; import ClipboardImpl from 's' ; import ImageImpl from 's' ; import InputImpl from 's' ; import RXInterfaces = require ( 's' ) ; import InternationalImpl from 's' ; import LinkImpl from 's' ; import LocationImpl from 's' ; import ModalImpl from 's' ; import RXModuleInterface = require ( 's' ) ; import PickerImpl from 's' ; import PlatformImpl from 's' ; import PopupImpl from 's' ; import ScrollViewImpl from 's' ; import StorageImpl from 's' ; import StylesImpl from 's' ; import TextImpl from 's' ; import TextInputImpl from 's' ; import RXTypes = require ( 's' ) ; import UserInterfaceImpl from 's' ; import UserPresenceImpl from 's' ; import ViewImpl from 's' ; import AccessibilityImpl from 's' ; import AccessibilityPlatformUtil from 's' ; import GestureViewImpl from 's' ; import LinkingImpl from 's' ; import StatusBarImpl from 's' ; AccessibilityUtil . setAccessibilityPlatformUtil ( AccessibilityPlatformUtil ) ; module ReactXP { export type Accessibility = RXInterfaces . Accessibility ; export let Accessibility : RXInterfaces . Accessibility = AccessibilityImpl ; export type ActivityIndicator = RXInterfaces . ActivityIndicator ; export let ActivityIndicator : typeof RXInterfaces . ActivityIndicator = ActivityIndicatorImpl ; export type Alert = RXInterfaces . Alert ; export let Alert : RXInterfaces . Alert = AlertImpl ; export type App = RXInterfaces . App ; export let App : RXInterfaces . App = AppImpl ; export type Button = RXInterfaces . Button ; export let Button : typeof RXInterfaces . Button = ButtonImpl ; export type Picker = RXInterfaces . Picker ; export let Picker : typeof RXInterfaces . Picker = PickerImpl ; export type Clipboard = RXInterfaces . Clipboard ; export let Clipboard : RXInterfaces . Clipboard = ClipboardImpl ; export type GestureView = RXInterfaces . GestureView ; export let GestureView : typeof RXInterfaces . GestureView = GestureViewImpl ; export type Image = RXInterfaces . Image ; export let Image : RXInterfaces . ImageConstructor = ImageImpl ; export type Input = RXInterfaces . Input ; export let Input : RXInterfaces . Input = InputImpl ; export type International = RXInterfaces . International ; export let International : RXInterfaces . International = InternationalImpl ; export type Link = RXInterfaces . Link ; export let Link : typeof RXInterfaces . Link = LinkImpl ; export type Linking = RXInterfaces . Linking ; export let Linking : RXInterfaces . Linking = LinkingImpl ; export type Location = RXInterfaces . Location ; export let Location : RXInterfaces . Location = LocationImpl ; export type Modal = RXInterfaces . Modal ; export let Modal : RXInterfaces . Modal = ModalImpl ; export type Platform = RXInterfaces . Platform ; export let Platform : RXInterfaces . Platform = PlatformImpl ; export type Popup = RXInterfaces . Popup ; export let Popup : RXInterfaces . Popup = PopupImpl ; export type ScrollView = RXInterfaces . ScrollView ; export let ScrollView : RXInterfaces . ScrollViewConstructor = ScrollViewImpl ; export type StatusBar = RXInterfaces . StatusBar ; export let StatusBar : RXInterfaces . StatusBar = StatusBarImpl ; export type Storage = RXInterfaces . Storage ; export let Storage : RXInterfaces . Storage = StorageImpl ; export type Styles = RXInterfaces . Styles ; export let Styles : RXInterfaces . Styles = StylesImpl ; export type Text = RXInterfaces . Text ; export let Text : typeof RXInterfaces . Text = TextImpl ; export type TextInput = RXInterfaces . TextInput ; export let TextInput : typeof RXInterfaces . TextInput = TextInputImpl ; export type UserInterface = RXInterfaces . UserInterface ; export let UserInterface : RXInterfaces . UserInterface = UserInterfaceImpl ; export type UserPresence = RXInterfaces . UserPresence ; export let UserPresence : RXInterfaces . UserPresence = UserPresenceImpl ; export type View = RXInterfaces . View ; export let View : typeof RXInterfaces . View = ViewImpl ; export const Animated = AnimatedImpl . makeAnimated ( AnimatedImpl . CommonAnimatedClasses ) ; export import CommonProps = RXTypes . CommonProps ; export import CommonStyledProps = RXTypes . CommonStyledProps ; export import Stateless = RXTypes . Stateless ; export import Types = RXTypes ; export import Component = React . Component ; export import ComponentBase = RXTypes . ComponentBase ; export import createElement = React . createElement ; export import Children = React . Children ; export let __spread = ( React as any ) . __spread ; export import Fragment = React . Fragment ; } let _rxImplementsRxInterface : typeof RXModuleInterface . ReactXP = ReactXP ; _rxImplementsRxInterface = _rxImplementsRxInterface ; export = ReactXP ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RN from 's' ; import { Accessibility as NativeAccessibility } from 's' ; interface AnnouncementFinishedPayload { announcement : string ; success : boolean ; } const RetryTimeout = 0 ; export class Accessibility extends NativeAccessibility { private _announcementQueue : string [ ] = [ ] ; private _retryTimestamp = NaN ; constructor ( ) { super ( ) ; if ( RN . AccessibilityInfo ) { RN . AccessibilityInfo . addEventListener ( 's' , this . _recalcAnnouncement ) ; RN . AppState . addEventListener ( 's' , this . _trackQueueStatus ) ; } } protected _updateScreenReaderStatus ( isEnabled ) { super . _updateScreenReaderStatus ( isEnabled ) ; if ( ! isEnabled && this . _announcementQueue . length > 0 ) { this . _announcementQueue = [ ] ; } } announceForAccessibility ( announcement ) { super . announceForAccessibility ( announcement ) ; if ( this . _isScreenReaderEnabled ) { this . _announcementQueue . push ( announcement ) ; if ( this . _announcementQueue . length === 0 ) { this . _postAnnouncement ( announcement ) ; } } } private _trackQueueStatus = ( newState ) => { if ( this . _isScreenReaderEnabled && [ 's' , 's' ] . indexOf ( newState ) >= 0 ) { this . _announcementQueue = [ ] ; this . _retryTimestamp = NaN ; } } private _postAnnouncement ( announcement , resetTimestamp = true ) { if ( resetTimestamp ) { this . _retryTimestamp = Date . now ( ) ; } if ( RN . AccessibilityInfo && RN . AccessibilityInfo . announceForAccessibility ) { RN . AccessibilityInfo . announceForAccessibility ( announcement ) ; } } private _recalcAnnouncement = ( payload ) => { if ( this . _announcementQueue . length === 0 ) { return ; } const postedAnnouncement = this . _announcementQueue [ 0 ] ; if ( payload . announcement === postedAnnouncement ) { const timeElapsed = Date . now ( ) - this . _retryTimestamp ; if ( ! payload . success && timeElapsed < RetryTimeout ) { this . _postAnnouncement ( payload . announcement , false ) ; } else { this . _announcementQueue . shift ( ) ; if ( this . _announcementQueue . length > 0 ) { const nextAnnouncement = this . _announcementQueue [ 0 ] ; this . _postAnnouncement ( nextAnnouncement ) ; } } } } } export default new Accessibility ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AnnouncementFinishedPayload$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import * as RN from 's' ; import Accessibility from 's' ; import { AccessibilityPlatformUtil } from 's' ; export class AccessibilityUtil extends AccessibilityPlatformUtil { setAccessibilityFocus ( component : React . Component < any , any > ) { if ( Accessibility . isScreenReaderEnabled ( ) && RN . AccessibilityInfo && RN . AccessibilityInfo . setAccessibilityFocus ) { const nodeHandle = RN . findNodeHandle ( component ) ; if ( nodeHandle ) { RN . AccessibilityInfo . setAccessibilityFocus ( nodeHandle ) ; } else { console . warn ( 's' ) ; } } } } export default new AccessibilityUtil ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; export class Input extends RX . Input { constructor ( ) { super ( ) ; } } export default new Input ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Types } from 's' ; import { Linking as CommonLinking } from 's' ; export class Linking extends CommonLinking { protected _createSmsUrl ( smsInfo : Types . SmsInfo ) { let smsUrl = 's' ; if ( smsInfo . phoneNumber ) { smsUrl += encodeURI ( smsInfo . phoneNumber ) ; } if ( smsInfo . body ) { smsUrl += 's' + encodeURIComponent ( smsInfo . body ) ; } return smsUrl ; } } export default new Linking ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; export class StatusBar extends RX . StatusBar { isOverlay ( ) { return false ; } setHidden ( hidden , showHideTransition : 's' | 's' ) { } setBackgroundColor ( color , animated ) { } setTranslucent ( translucent ) { } setBarStyle ( style : 's' | 's' | 's' , animated ) { } setNetworkActivityIndicatorVisible ( value ) { } } export default new StatusBar ( ) ;	O O O O O O O O O O O O O O O $boolean$ O O O O O O O $void$ O $boolean$ O O O O O O O O O $void$ O $string$ O $boolean$ O O O $void$ O $boolean$ O O O $void$ O O O O O O O O O $boolean$ O O O $void$ O $boolean$ O O O O O O O O O O O
import React = require ( 's' ) ; import RN = require ( 's' ) ; import AccessibilityUtil from 's' ; import ActivityIndicatorImpl from 's' ; import AlertImpl from 's' ; import { CommonAnimatedClasses , makeAnimated } from 's' ; import AppImpl from 's' ; import ButtonImpl from 's' ; import ClipboardImpl from 's' ; import ImageImpl from 's' ; import RXInterfaces = require ( 's' ) ; import InternationalImpl from 's' ; import LinkImpl from 's' ; import LocationImpl from 's' ; import ModalImpl from 's' ; import RXModuleInterface = require ( 's' ) ; import PickerImpl from 's' ; import PlatformImpl from 's' ; import PopupImpl from 's' ; import ScrollViewImpl from 's' ; import StorageImpl from 's' ; import StylesImpl from 's' ; import TextImpl from 's' ; import TextInputImpl from 's' ; import RXTypes = require ( 's' ) ; import UserInterfaceImpl from 's' ; import UserPresenceImpl from 's' ; import AccessibilityImpl from 's' ; import AccessibilityPlatformUtil from 's' ; import GestureViewImpl from 's' ; import InputImpl from 's' ; import LinkingImpl from 's' ; import StatusBarImpl from 's' ; import ViewImpl from 's' ; AccessibilityUtil . setAccessibilityPlatformUtil ( AccessibilityPlatformUtil ) ; module ReactXP { export type Accessibility = RXInterfaces . Accessibility ; export let Accessibility : RXInterfaces . Accessibility = AccessibilityImpl ; export type ActivityIndicator = RXInterfaces . ActivityIndicator ; export let ActivityIndicator : typeof RXInterfaces . ActivityIndicator = ActivityIndicatorImpl ; export type Alert = RXInterfaces . Alert ; export let Alert : RXInterfaces . Alert = AlertImpl ; export type App = RXInterfaces . App ; export let App : RXInterfaces . App = AppImpl ; export type Button = RXInterfaces . Button ; export let Button : typeof RXInterfaces . Button = ButtonImpl ; export type Picker = RXInterfaces . Picker ; export let Picker : typeof RXInterfaces . Picker = PickerImpl ; export type Clipboard = RXInterfaces . Clipboard ; export let Clipboard : RXInterfaces . Clipboard = ClipboardImpl ; export type GestureView = RXInterfaces . GestureView ; export let GestureView : typeof RXInterfaces . GestureView = GestureViewImpl ; export type Image = RXInterfaces . Image ; export let Image : RXInterfaces . ImageConstructor = ImageImpl ; export type Input = RXInterfaces . Input ; export let Input : RXInterfaces . Input = InputImpl ; export type International = RXInterfaces . International ; export let International : RXInterfaces . International = InternationalImpl ; export type Link = RXInterfaces . Link ; export let Link : typeof RXInterfaces . Link = LinkImpl ; export type Linking = RXInterfaces . Linking ; export let Linking : RXInterfaces . Linking = LinkingImpl ; export type Location = RXInterfaces . Location ; export let Location : RXInterfaces . Location = LocationImpl ; export type Modal = RXInterfaces . Modal ; export let Modal : RXInterfaces . Modal = ModalImpl ; export type Platform = RXInterfaces . Platform ; export let Platform : RXInterfaces . Platform = PlatformImpl ; export type Popup = RXInterfaces . Popup ; export let Popup : RXInterfaces . Popup = PopupImpl ; export type ScrollView = RXInterfaces . ScrollView ; export let ScrollView : RXInterfaces . ScrollViewConstructor = ScrollViewImpl ; export type StatusBar = RXInterfaces . StatusBar ; export let StatusBar : RXInterfaces . StatusBar = StatusBarImpl ; export type Storage = RXInterfaces . Storage ; export let Storage : RXInterfaces . Storage = StorageImpl ; export type Styles = RXInterfaces . Styles ; export let Styles : RXInterfaces . Styles = StylesImpl ; export type Text = RXInterfaces . Text ; export let Text : typeof RXInterfaces . Text = TextImpl ; export type TextInput = RXInterfaces . TextInput ; export let TextInput : typeof RXInterfaces . TextInput = TextInputImpl ; export type UserInterface = RXInterfaces . UserInterface ; export let UserInterface : RXInterfaces . UserInterface = UserInterfaceImpl ; export type UserPresence = RXInterfaces . UserPresence ; export let UserPresence : RXInterfaces . UserPresence = UserPresenceImpl ; export type View = RXInterfaces . View ; export let View : typeof RXInterfaces . View = ViewImpl ; const macAnimatedClasses = { ... CommonAnimatedClasses , TextInput : RN . Animated . createAnimatedComponent ( TextInputImpl ) , View : RN . Animated . createAnimatedComponent ( ViewImpl ) } ; export const Animated = makeAnimated ( macAnimatedClasses ) ; export import CommonProps = RXTypes . CommonProps ; export import CommonStyledProps = RXTypes . CommonStyledProps ; export import Stateless = RXTypes . Stateless ; export import Types = RXTypes ; export import Component = React . Component ; export import ComponentBase = RXTypes . ComponentBase ; export import createElement = React . createElement ; export import Children = React . Children ; export let __spread = ( React as any ) . __spread ; export import Fragment = React . Fragment ; } let _rxImplementsRxInterface : typeof RXModuleInterface . ReactXP = ReactXP ; _rxImplementsRxInterface = _rxImplementsRxInterface ; export = ReactXP ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import SubscribableEvent from 's' ; export class MainViewStore extends SubscribableEvent < ( ) => void > { private _mainView : React . ReactElement < any > | undefined ; getMainView ( ) { return this . _mainView ; } setMainView ( view : React . ReactElement < any > ) { this . _mainView = view ; this . fire ( ) ; } } export default new MainViewStore ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Platform } from 's' ; import { Types } from 's' ; import { clone } from 's' ; const _isNativeMacOs = Platform . OS === 's' ; export class EventHelpers { toKeyboardEvent ( e : Types . SyntheticEvent ) : Types . KeyboardEvent { let keyEvent = e as Types . KeyboardEvent ; if ( keyEvent . keyCode === undefined ) { const keyName = e . nativeEvent . key ; let keyCode = 0 ; if ( keyName . length === 0 ) { keyCode = keyName . charCodeAt ( 0 ) ; } else { switch ( keyName ) { case 's' : keyCode = 0 ; break ; case 's' : case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : case 's' : keyCode = 0 ; break ; case 's' : case 's' : keyCode = 0 ; break ; case 's' : case 's' : case 's' : keyCode = 0 ; break ; case 's' : case 's' : case 's' : keyCode = 0 ; break ; case 's' : case 's' : case 's' : keyCode = 0 ; break ; case 's' : case 's' : case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : keyCode = 0 ; break ; case 's' : case 's' : keyCode = 0 ; break ; case 's' : case 's' : keyCode = 0 ; break ; } } if ( _isNativeMacOs ) { if ( keyCode >= 0 && keyCode <= 0 ) { keyCode = keyCode - 0 ; } else if ( keyCode === 0 ) { keyCode = 0 ; } else if ( keyCode === 0 ) { keyCode = 0 ; } else if ( keyCode >= 0 && keyCode <= 0 ) { keyCode = keyCode - 0 ; } else if ( keyCode >= 0 && keyCode <= 0 ) { keyCode = keyCode - 0 ; } } keyEvent = clone ( keyEvent ) ; keyEvent . keyCode = keyCode ; const nativeEvent = e . nativeEvent ; if ( nativeEvent . shiftKey ) { keyEvent . shiftKey = nativeEvent . shiftKey ; } if ( nativeEvent . ctrlKey ) { keyEvent . ctrlKey = nativeEvent . ctrlKey ; } if ( nativeEvent . altKey ) { keyEvent . altKey = nativeEvent . altKey ; } if ( nativeEvent . metaKey ) { keyEvent . metaKey = nativeEvent . metaKey ; } keyEvent . stopPropagation = ( ) => { if ( e . stopPropagation ) { e . stopPropagation ( ) ; } } ; keyEvent . preventDefault = ( ) => { if ( e . preventDefault ) { e . preventDefault ( ) ; } } ; } return keyEvent ; } toFocusEvent ( e : Types . SyntheticEvent ) : Types . FocusEvent { return e ; } toMouseEvent ( e : Types . SyntheticEvent ) : Types . MouseEvent { const mouseEvent = clone ( e as Types . MouseEvent ) ; const nativeEvent = e . nativeEvent ; if ( nativeEvent . pageX !== undefined ) { mouseEvent . clientX = mouseEvent . pageX = nativeEvent . pageX ; } if ( nativeEvent . pageY !== undefined ) { mouseEvent . clientY = mouseEvent . pageY = nativeEvent . pageY ; } mouseEvent . button = this . toMouseButton ( e . nativeEvent ) ; if ( nativeEvent . shiftKey ) { mouseEvent . shiftKey = nativeEvent . shiftKey ; } if ( nativeEvent . ctrlKey ) { mouseEvent . ctrlKey = nativeEvent . ctrlKey ; } if ( nativeEvent . altKey ) { mouseEvent . altKey = nativeEvent . altKey ; } if ( nativeEvent . metaKey ) { mouseEvent . metaKey = nativeEvent . metaKey ; } mouseEvent . stopPropagation = ( ) => { if ( e . stopPropagation ) { e . stopPropagation ( ) ; } } ; mouseEvent . preventDefault = ( ) => { if ( e . preventDefault ) { e . preventDefault ( ) ; } } ; return mouseEvent ; } toDragEvent ( e : Types . SyntheticEvent ) : Types . DragEvent { const dndEvent = this . toMouseEvent ( e ) ; dndEvent . dataTransfer = e . nativeEvent . dataTransfer ; return dndEvent ; } toMouseButton ( nativeEvent ) { if ( nativeEvent . button !== undefined ) { return nativeEvent . button ; } else if ( nativeEvent . isRightButton || nativeEvent . IsRightButton ) { return 0 ; } else if ( nativeEvent . isMiddleButton || nativeEvent . IsMiddleButton ) { return 0 ; } return 0 ; } isActuallyMouseEvent ( e : Types . TouchEvent | undefined ) { if ( ! e ) { return false ; } const nativeEvent = e as any ; if ( nativeEvent . button !== undefined ) { return true ; } else if ( nativeEvent . isRightButton || nativeEvent . IsRightButton ) { return true ; } else if ( nativeEvent . isMiddleButton || nativeEvent . IsMiddleButton ) { return true ; } return false ; } isRightMouseButton ( e : Types . SyntheticEvent ) { return ( this . toMouseButton ( e . nativeEvent ) === 0 ) ; } keyboardToMouseEvent ( e : Types . KeyboardEvent , layoutInfo : Types . LayoutInfo , contextMenuOffset : { x : number ; y : number } ) : Types . MouseEvent { const mouseEvent = this . toMouseEvent ( e ) ; if ( ( layoutInfo . x !== undefined ) && ( contextMenuOffset . x !== undefined ) ) { mouseEvent . clientX = mouseEvent . pageX = layoutInfo . x + contextMenuOffset . x ; } if ( ( layoutInfo . y !== undefined ) && ( contextMenuOffset . y !== undefined ) ) { mouseEvent . clientY = mouseEvent . pageY = layoutInfo . y + contextMenuOffset . y ; } return mouseEvent ; } } export default new EventHelpers ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O $number$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ComponentProvider } from 's' ; import { App as AppCommon } from 's' ; import { RootView , RootViewUsingProps } from 's' ; export class App extends AppCommon { protected getRootViewFactory ( ) { return ( ) => RootView ; } protected getRootViewUsingPropsFactory ( ) { return ( ) => RootViewUsingProps ; } } export default new App ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentProvider$ O O O O O O O O O O O $ComponentProvider$ O O O O O O O O O O O O O O O O O O
import { Input as InputCommon } from 's' ; import { Types } from 's' ; export class Input extends InputCommon { constructor ( ) { super ( ) ; } dispatchKeyDown ( e : Types . KeyboardEvent ) { this . keyDownEvent . fire ( e ) ; } dispatchKeyUp ( e : Types . KeyboardEvent ) { if ( this . keyUpEvent . fire ( e ) ) { e . stopPropagation ( ) ; } } } export default new Input ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ImportantForAccessibilityValue } from 's' ; import AppConfig from 's' ; import { applyFocusableComponentMixin as applyFocusableComponentMixinBase , FocusableComponentInternal as FocusableComponentInternalBase , FocusableComponentStateCallback , FocusManager as FocusManagerBase , StoredFocusableComponent as StoredFocusableComponentBase } from 's' ; import Platform from 's' ; import Timers from 's' ; import UserInterface from 's' ; const isNativeWindows = Platform . getType ( ) === 's' ; export { FocusableComponentStateCallback } ; export enum OverrideType { None = 0 , Accessible = 0 , Limited = 0 } export interface StoredFocusableComponent extends StoredFocusableComponentBase { curOverrideType ? : OverrideType ; } export interface FocusManagerFocusableComponent { getTabIndex ( ) : number | undefined ; getImportantForAccessibility ( ) : ImportantForAccessibilityValue | undefined ; onFocus ( ) : void ; focus ( ) : void ; updateNativeAccessibilityProps ( ) : void ; } export interface FocusableComponentInternal extends FocusManagerFocusableComponent , FocusableComponentInternalBase { tabIndexOverride ? : number ; tabIndexLocalOverride ? : number ; tabIndexLocalOverrideTimer ? : number ; importantForAccessibilityOverride ? : string ; onFocusSink ? : ( ) => void ; } export class FocusManager extends FocusManagerBase { constructor ( parent : FocusManager | undefined ) { super ( parent ) ; } protected addFocusListenerOnComponent ( component , onFocus : ( ) => void ) { component . onFocusSink = onFocus ; } protected removeFocusListenerFromComponent ( component , onFocus : ( ) => void ) { delete component . onFocusSink ; } protected focusComponent ( component ) { if ( component && component . focus ) { component . focus ( ) ; return true ; } return false ; } private static _focusFirst ( ) { const focusable = Object . keys ( FocusManager . _allFocusableComponents ) . map ( componentId => FocusManager . _allFocusableComponents [ componentId ] ) . filter ( storedComponent => ! storedComponent . accessibleOnly && ! storedComponent . removed && ! storedComponent . restricted && ! storedComponent . limitedCount && ! storedComponent . limitedCountAccessible && ( ( storedComponent . component . props . tabIndex || 0 ) >= 0 ) ) ; if ( focusable . length ) { focusable . sort ( ( a , b ) => { if ( a === b ) { return 0 ; } if ( a . numericId < b . numericId ) { return - 0 ; } else { return 0 ; } } ) ; const fc = focusable [ 0 ] . component as FocusableComponentInternal ; if ( fc && fc . focus ) { fc . focus ( ) ; } } } protected resetFocus ( focusFirstWhenNavigatingWithKeyboard ) { if ( FocusManager . _resetFocusTimer ) { Timers . clearTimeout ( FocusManager . _resetFocusTimer ) ; FocusManager . _resetFocusTimer = undefined ; } if ( UserInterface . isNavigatingWithKeyboard ( ) && focusFirstWhenNavigatingWithKeyboard ) { FocusManager . _resetFocusTimer = Timers . setTimeout ( ( ) => { FocusManager . _resetFocusTimer = undefined ; const storedComponent = FocusManager . _currentFocusedComponent ; if ( ! storedComponent || storedComponent . accessibleOnly || storedComponent . removed || storedComponent . restricted || ( storedComponent . limitedCount > 0 ) || ( storedComponent . limitedCountAccessible > 0 ) ) { FocusManager . _focusFirst ( ) ; } } , 0 ) ; } } protected _updateComponentFocusRestriction ( storedComponent ) { let newOverrideType = OverrideType . None ; if ( storedComponent . restricted || ( storedComponent . limitedCount > 0 ) ) { newOverrideType = OverrideType . Limited ; } else if ( storedComponent . limitedCountAccessible > 0 ) { newOverrideType = OverrideType . Accessible ; } const curOverrideType = storedComponent . curOverrideType || OverrideType . None ; if ( newOverrideType !== curOverrideType ) { FocusManager . _updateComponentTabIndexAndIFAOverrides ( storedComponent . component as FocusableComponentInternal , newOverrideType !== OverrideType . None , newOverrideType === OverrideType . Limited ) ; if ( newOverrideType !== OverrideType . None ) { storedComponent . curOverrideType = newOverrideType ; FocusManager . _callFocusableComponentStateChangeCallbacks ( storedComponent , true ) ; } else { delete storedComponent . curOverrideType ; FocusManager . _callFocusableComponentStateChangeCallbacks ( storedComponent , false ) ; } } } private static _updateComponentTabIndexAndIFAOverrides ( component , tabIndexOverride , accessibleOverride ) { if ( tabIndexOverride ) { component . tabIndexOverride = - 0 ; } else { delete component . tabIndexOverride ; } if ( accessibleOverride ) { component . importantForAccessibilityOverride = 's' ; } else { delete component . importantForAccessibilityOverride ; } updateNativeAccessibilityProps ( component ) ; } } function updateNativeAccessibilityProps ( component ) { if ( component . updateNativeAccessibilityProps ) { component . updateNativeAccessibilityProps ( ) ; } else { if ( AppConfig . isDevelopmentMode ( ) ) { console . error ( 's' ) ; } } } export function applyFocusableComponentMixin ( Component , isConditionallyFocusable ? , accessibleOnly = false ) { applyFocusableComponentMixinBase ( Component , isConditionallyFocusable , accessibleOnly ) ; inheritMethod ( 's' , function ( this , origCallback ) { if ( this . importantForAccessibilityOverride !== undefined ) { return this . importantForAccessibilityOverride ; } else { return origCallback . call ( this ) ; } } ) ; if ( ! accessibleOnly ) { inheritMethod ( 's' , function ( this , origCallback ) { if ( this . onFocusSink ) { this . onFocusSink ( ) ; } else { if ( AppConfig . isDevelopmentMode ( ) ) { console . error ( 's' ) ; } } origCallback . call ( this ) ; } ) ; inheritMethod ( 's' , function ( this , origCallback ) { if ( this . tabIndexLocalOverride !== undefined ) { return this . tabIndexLocalOverride ; } else if ( this . tabIndexOverride !== undefined ) { return this . tabIndexOverride ; } else { return origCallback . call ( this ) ; } } ) ; if ( isNativeWindows ) { inheritMethod ( 's' , function ( this , origCallback ) { const tabIndex : number | undefined = this . getTabIndex ( ) ; if ( tabIndex !== undefined && tabIndex < 0 ) { this . tabIndexLocalOverride = 0 ; updateNativeAccessibilityProps ( this ) ; this . tabIndexLocalOverrideTimer = Timers . setTimeout ( ( ) => { if ( this . tabIndexLocalOverrideTimer !== undefined ) { this . tabIndexLocalOverrideTimer = undefined ; delete this . tabIndexLocalOverride ; updateNativeAccessibilityProps ( this ) ; } } , 0 ) ; } return origCallback . call ( this ) ; } ) ; inheritMethod ( 's' , function ( this , origCallback ) { delete this . tabIndexLocalOverrideTimer ; return origCallback . call ( this ) ; } ) ; } } function inheritMethod ( methodName , action ) { const origCallback = Component . prototype [ methodName ] ; if ( origCallback ) { Component . prototype [ methodName ] = function ( ) { return action . call ( this , origCallback , arguments ) ; } ; } else { if ( AppConfig . isDevelopmentMode ( ) ) { console . error ( 's' + methodName + 's' ) ; } } } } export default FocusManager ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $FocusableComponentInternal$ O O O O O O O O O O O O O O O O O $void$ O $FocusableComponentInternal$ O O O O O O O O O O O O O O O O $boolean$ O $FocusableComponentInternal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StoredFocusableComponent$ O O O $OverrideType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OverrideType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $FocusableComponentInternal$ O $boolean$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O $Function$ O O O O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FocusableComponentInternal$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { RuleFailure , Rules , RuleWalker } from 's' ; import * as tsutils from 's' ; import * as ts from 's' ; export class Rule extends Rules . AbstractRule { static FAILURE_STRING_PART = 's' ; apply ( sourceFile : ts . SourceFile ) : RuleFailure [ ] { const options = this . getOptions ( ) ; const banModuleWalker = new GroupedImportModuleWalker ( sourceFile , options ) ; return this . applyWithWalker ( banModuleWalker ) ; } } enum ImportType { None , Relative , Ambient } class GroupedImportModuleWalker extends RuleWalker { private _inImportGroup = false ; private _lastImportType = ImportType . None ; visitNode ( node : ts . Node ) { if ( tsutils . isImportDeclaration ( node ) || tsutils . isImportEqualsDeclaration ( node ) ) { const prevStatement = tsutils . getPreviousStatement ( node ) ; const prevLineNum = prevStatement ? ts . getLineAndCharacterOfPosition ( this . getSourceFile ( ) , prevStatement . end ) . line : - 0 ; const currentLineNum = ts . getLineAndCharacterOfPosition ( this . getSourceFile ( ) , node . end ) . line ; if ( prevLineNum !== - 0 && prevLineNum < currentLineNum - 0 ) { this . _lastImportType = ImportType . None ; this . _inImportGroup = false ; } const wasInImportGroup = this . _inImportGroup ; this . _inImportGroup = true ; const importType = this . _checkImportType ( node ) ; if ( wasInImportGroup && importType !== this . _lastImportType ) { this . addFailure ( this . createFailure ( node . getStart ( ) , node . getWidth ( ) , Rule . FAILURE_STRING_PART ) ) ; } this . _lastImportType = importType ; } else { this . _inImportGroup = false ; this . _lastImportType = ImportType . None ; super . visitNode ( node ) ; } } private _checkImportType ( node : ts . ImportEqualsDeclaration | ts . ImportDeclaration ) { let modulePath : string | undefined ; if ( tsutils . isImportEqualsDeclaration ( node ) ) { if ( node . moduleReference . kind === ts . SyntaxKind . ExternalModuleReference ) { const matches = node . moduleReference . getFullText ( ) . match ( "s" ) ; if ( matches && matches . length === 0 ) { modulePath = matches [ 0 ] ; } else { console . log ( 's' + node . moduleReference . kind + 's' + node . moduleReference . getFullText ( ) ) ; } } } if ( tsutils . isImportDeclaration ( node ) ) { modulePath = node . moduleSpecifier . getText ( ) . replace ( "s" , 's' ) ; } if ( modulePath ) { if ( modulePath [ 0 ] === 's' || modulePath [ 0 ] === 's' ) { return ImportType . Relative ; } else { return ImportType . Ambient ; } } return ImportType . None ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ImportType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as _ from 's' ; import { RuleFailure , Rules , RuleWalker } from 's' ; import * as ts from 's' ; const THIS_PROPS_REFERENCED = 's' + 's' + 's' ; const THIS_PROPS = 's' ; const ALLOWED_OLD_PROPS = 's' + THIS_PROPS ; export class Rule extends Rules . AbstractRule { apply ( sourceFile : ts . SourceFile ) : RuleFailure [ ] { const options = this . getOptions ( ) ; const thisPropsWalker = new ThisPropsWalker ( sourceFile , options ) ; return this . applyWithWalker ( thisPropsWalker ) ; } } class ThisPropsWalker extends RuleWalker { walk ( node : ts . Node ) { super . walk ( node ) ; } visitMethodDeclaration ( node : ts . MethodDeclaration ) { const hasPropsParam = _ . find ( node . parameters , param => { const paramNameIdentifier = param . name as ts . Identifier ; return ( paramNameIdentifier && paramNameIdentifier . text === 's' ) ; } ) ; if ( hasPropsParam ) { const methodText = node . getText ( ) ; let searchOffset = 0 ; while ( true ) { const foundOffset = methodText . indexOf ( THIS_PROPS , searchOffset ) ; if ( foundOffset < 0 || foundOffset >= methodText . length ) { break ; } const allowedOffset = foundOffset + THIS_PROPS . length - ALLOWED_OLD_PROPS . length ; if ( allowedOffset >= 0 && methodText . indexOf ( ALLOWED_OLD_PROPS , allowedOffset ) === allowedOffset ) { searchOffset = foundOffset + THIS_PROPS . length ; continue ; } this . addFailure ( this . createFailure ( node . name . getStart ( ) + foundOffset , THIS_PROPS . length , THIS_PROPS_REFERENCED ) ) ; searchOffset = foundOffset + THIS_PROPS . length ; } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as _ from 's' ; import { RuleFailure , Rules , RuleWalker } from 's' ; import * as ts from 's' ; const STYLES_NOT_CONST = 's' ; const STYLE_NOT_REFERENCED = 's' ; export class Rule extends Rules . AbstractRule { apply ( sourceFile : ts . SourceFile ) : RuleFailure [ ] { const options = this . getOptions ( ) ; const stylesWalker = new StylesWalker ( sourceFile , options ) ; return this . applyWithWalker ( stylesWalker ) ; } } interface StyleInfo { isReferenced : boolean ; start : number ; width : number ; } class StylesWalker extends RuleWalker { private _definedStyles : { [ name ] : StyleInfo } = { } ; walk ( node : ts . Node ) { super . walk ( node ) ; this . _reportUnreferencedStyles ( ) ; } visitVariableDeclaration ( node : ts . VariableDeclaration ) { if ( node . name . getText ( ) === 's' && node . initializer ) { const nodeFlags = ts . getCombinedNodeFlags ( node ) ; if ( ( nodeFlags & ts . NodeFlags . Const ) === 0 ) { this . addFailure ( this . createFailure ( node . getStart ( ) , node . getWidth ( ) , STYLES_NOT_CONST ) ) ; } this . _addKnownStyles ( node . initializer , 's' ) ; } } private _addKnownStyles ( node : ts . Node , prefix ) { let hasChildren = false ; if ( node . kind === ts . SyntaxKind . ObjectLiteralExpression ) { const objLiteral = node as ts . ObjectLiteralExpression ; if ( objLiteral . properties ) { _ . each ( objLiteral . properties , property => { const nodeName = prefix + property . name ! . getText ( ) ; const children = property . getChildren ( ) ; let childHasChildren = false ; _ . each ( children , child => { if ( this . _addKnownStyles ( child , nodeName + 's' ) ) { childHasChildren = true ; } } ) ; if ( ! childHasChildren ) { this . _definedStyles [ nodeName ] = { isReferenced : false , start : property . getStart ( ) , width : property . getWidth ( ) } ; } hasChildren = true ; } ) ; } } return hasChildren ; } visitFunctionDeclaration ( node : ts . FunctionDeclaration ) { this . _markReferencedStyles ( node . getText ( ) ) ; } visitConstructorDeclaration ( node : ts . ConstructorDeclaration ) { this . _markReferencedStyles ( node . getText ( ) ) ; } visitMethodDeclaration ( node : ts . MethodDeclaration ) { this . _markReferencedStyles ( node . getText ( ) ) ; } visitArrowFunction ( node : ts . FunctionLikeDeclaration ) { this . _markReferencedStyles ( node . getText ( ) ) ; } visitPropertyDeclaration ( node : ts . PropertyDeclaration ) { this . _markReferencedStyles ( node . getText ( ) ) ; } private _markReferencedStyles ( functionText ) { const stylesRegEx = "s" ; const matches = functionText . match ( stylesRegEx ) ; if ( matches ) { _ . each ( matches , match => { if ( this . _definedStyles [ match ] !== undefined ) { this . _definedStyles [ match ] . isReferenced = true ; } } ) ; } } private _reportUnreferencedStyles ( ) { _ . each ( this . _definedStyles , ( styleInfo , styleName ) => { if ( ! styleInfo . isReferenced ) { this . addFailure ( this . createFailure ( styleInfo . start , styleInfo . width , STYLE_NOT_REFERENCED + styleName ) ) ; } } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AccessibilityUtil as CommonAccessibiltiyUtil } from 's' ; import { Types } from 's' ; import * as _ from 's' ; const roleMap : { [ key ] : string } = { [ Types . AccessibilityTrait . None ] : 's' , [ Types . AccessibilityTrait . Button ] : 's' , [ Types . AccessibilityTrait . Link ] : 's' , [ Types . AccessibilityTrait . Header ] : 's' , [ Types . AccessibilityTrait . Search ] : 's' , [ Types . AccessibilityTrait . Image ] : 's' , [ Types . AccessibilityTrait . Summary ] : 's' , [ Types . AccessibilityTrait . Adjustable ] : 's' , [ Types . AccessibilityTrait . Menu ] : 's' , [ Types . AccessibilityTrait . MenuItem ] : 's' , [ Types . AccessibilityTrait . MenuBar ] : 's' , [ Types . AccessibilityTrait . Tab ] : 's' , [ Types . AccessibilityTrait . TabList ] : 's' , [ Types . AccessibilityTrait . List ] : 's' , [ Types . AccessibilityTrait . ListItem ] : 's' , [ Types . AccessibilityTrait . ListBox ] : 's' , [ Types . AccessibilityTrait . Group ] : 's' , [ Types . AccessibilityTrait . CheckBox ] : 's' , [ Types . AccessibilityTrait . ComboBox ] : 's' , [ Types . AccessibilityTrait . Log ] : 's' , [ Types . AccessibilityTrait . Status ] : 's' , [ Types . AccessibilityTrait . Dialog ] : 's' , [ Types . AccessibilityTrait . Switch ] : 's' } ; const liveRegionMap : { [ key ] : Types . AriaLive } = { [ Types . AccessibilityLiveRegion . None ] : 's' , [ Types . AccessibilityLiveRegion . Assertive ] : 's' , [ Types . AccessibilityLiveRegion . Polite ] : 's' } ; export class AccessibilityUtil extends CommonAccessibiltiyUtil { accessibilityLiveRegionToString ( liveRegion : Types . AccessibilityLiveRegion ) : Types . AriaLive | undefined { if ( liveRegion ) { return liveRegionMap [ liveRegion ] ; } return undefined ; } accessibilityTraitToString ( traits : Types . AccessibilityTrait | Types . AccessibilityTrait [ ] | undefined , defaultTrait ? : Types . AccessibilityTrait ) : string | undefined { let combinedTraits : Types . AccessibilityTrait [ ] = defaultTrait ? [ defaultTrait ] : [ ] ; if ( traits ) { combinedTraits = _ . union ( combinedTraits , Array . isArray ( traits ) ? traits : [ traits ] ) ; } return combinedTraits . length > 0 ? roleMap [ _ . max ( _ . filter ( combinedTraits , t => roleMap . hasOwnProperty ( t as any ) ) ) ! ] : undefined ; } accessibilityTraitToAriaSelected ( traits : Types . AccessibilityTrait | Types . AccessibilityTrait [ ] | undefined ) { if ( traits && Array . isArray ( traits ) && traits . indexOf ( Types . AccessibilityTrait . Tab ) !== - 0 ) { return traits . indexOf ( Types . AccessibilityTrait . Selected ) !== - 0 ; } return undefined ; } accessibilityTraitToAriaChecked ( traits : Types . AccessibilityTrait | Types . AccessibilityTrait [ ] | undefined ) { if ( traits && Array . isArray ( traits ) && traits . indexOf ( Types . AccessibilityTrait . CheckBox ) !== - 0 ) { return traits . indexOf ( Types . AccessibilityTrait . Checked ) !== - 0 ; } return undefined ; } accessibilityTraitToAriaHasPopup ( traits : Types . AccessibilityTrait | Types . AccessibilityTrait [ ] | undefined ) { if ( traits && Array . isArray ( traits ) && traits . indexOf ( Types . AccessibilityTrait . HasPopup ) !== - 0 ) { return traits . indexOf ( Types . AccessibilityTrait . HasPopup ) !== - 0 ; } return undefined ; } } export default new AccessibilityUtil ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import assert from 's' ; import Timers from 's' ; const UNIT = 's' ; const SCROLLER_MIN_SIZE = 0 ; const SCROLLER_NEGATIVE_MARGIN = 0 ; const NEUTRAL_OVERRIDE_CLASS = 's' ; interface ScrollbarInfo { size ? : number ; scrollSize ? : number ; 0 ? : number ; 0 ? : number ; sliderSize ? : number ; dragOffset ? : number ; rail ? : HTMLElement ; slider ? : HTMLElement ; } export interface ScrollbarOptions { horizontal ? : boolean ; vertical ? : boolean ; hiddenScrollbar ? : boolean ; } let _nativeSrollBarWidth = - 0 ; let _isStyleSheetInstalled = false ; const _customScrollbarCss = `template` ; export class Scrollbar { private _container : HTMLElement ; private _verticalBar : ScrollbarInfo = { } ; private _horizontalBar : ScrollbarInfo = { } ; private _viewport ! : HTMLElement ; private _dragging = false ; private _dragIsVertical = false ; private _scrollingVisible = false ; private _hasHorizontal = false ; private _hasVertical = true ; private _hasHiddenScrollbar = false ; private _stopDragCallback = this . _stopDrag . bind ( this ) ; private _startDragVCallback = this . _startDrag . bind ( this , true ) ; private _startDragHCallback = this . _startDrag . bind ( this , false ) ; private _handleDragCallback = this . _handleDrag . bind ( this ) ; private _handleWheelCallback = this . _handleWheel . bind ( this ) ; private _handleMouseDownCallback = this . _handleMouseDown . bind ( this ) ; private _updateCallback = this . update . bind ( this ) ; private _asyncInitTimer : number | undefined ; static getNativeScrollbarWidth ( ) { if ( _nativeSrollBarWidth >= 0 ) { return _nativeSrollBarWidth ; } const inner = document . createElement ( 's' ) ; inner . style . width = 's' ; inner . style . height = 's' ; const outer = document . createElement ( 's' ) ; outer . style . position = 's' ; outer . style . top = 's' ; outer . style . left = 's' ; outer . style . visibility = 's' ; outer . style . width = 's' ; outer . style . height = 's' ; outer . style . overflow = 's' ; outer . appendChild ( inner ) ; document . body . appendChild ( outer ) ; const 0 = inner . offsetWidth ; outer . style . overflow = 's' ; let 0 = inner . offsetWidth ; if ( 0 === 0 ) { 0 = outer . clientWidth ; } document . body . removeChild ( outer ) ; _nativeSrollBarWidth = 0 - 0 ; return _nativeSrollBarWidth ; } private static _installStyleSheet ( ) { if ( _isStyleSheetInstalled ) { return ; } const head = document . head || document . getElementsByTagName ( 's' ) [ 0 ] ; const style = document . createElement ( 's' ) as any ; style . type = 's' ; if ( style . styleSheet ) { style . styleSheet . cssText = _customScrollbarCss ; } else { style . appendChild ( document . createTextNode ( _customScrollbarCss ) ) ; } head . appendChild ( style ) ; _isStyleSheetInstalled = true ; } constructor ( container ) { assert ( container , 's' ) ; this . _container = container ; } private _tryLtrOverride ( ) { const rtlbox = document . createElement ( 's' ) ; rtlbox . style . cssText = 's' ; rtlbox . innerHTML = 's' ; this . _container . appendChild ( rtlbox ) ; const probe = rtlbox . querySelector ( 's' ) ! ; const rtlboxRect = rtlbox . getBoundingClientRect ( ) ; const probeRect = probe . getBoundingClientRect ( ) ; const isLeftBound = rtlboxRect . left === probeRect . left ; const isRightBound = rtlboxRect . right === probeRect . right ; const isNeutral = isLeftBound && isRightBound ; this . _container . classList . remove ( NEUTRAL_OVERRIDE_CLASS ) ; if ( isNeutral ) { this . _container . classList . add ( NEUTRAL_OVERRIDE_CLASS ) ; } rtlbox . innerHTML = 's' ; this . _container . removeChild ( rtlbox ) ; } private _prevent ( e : React . SyntheticEvent < any > ) { e . preventDefault ( ) ; } private _updateSliders ( ) { if ( this . _hasHorizontal ) { const newSliderWidth = this . _horizontalBar . sliderSize + UNIT ; const newSliderLeft = this . _viewport . scrollLeft * this . _horizontalBar . 0 ! + UNIT ; this . _horizontalBar . slider ! . style . width = newSliderWidth ; this . _horizontalBar . slider ! . style . left = newSliderLeft ; } if ( this . _hasVertical ) { const newSliderHeight = this . _verticalBar . sliderSize + UNIT ; const newSliderTop = this . _viewport . scrollTop * this . _verticalBar . 0 ! + UNIT ; this . _verticalBar . slider ! . style . height = newSliderHeight ; this . _verticalBar . slider ! . style . top = newSliderTop ; } } private _handleDrag ( e : React . MouseEvent < any > ) { if ( this . _dragIsVertical ) { this . _viewport . scrollTop = ( e . pageY - this . _verticalBar . dragOffset ! ) * this . _verticalBar . 0 ! ; } else { this . _viewport . scrollLeft = ( e . pageX - this . _horizontalBar . dragOffset ! ) * this . _horizontalBar . 0 ! ; } } private _startDrag ( dragIsVertical , e : React . MouseEvent < any > ) { if ( ! this . _dragging ) { window . addEventListener ( 's' , this . _stopDragCallback ) ; window . addEventListener ( 's' , this . _handleDragCallback ) ; this . _container . classList . add ( 's' ) ; if ( this . _hasHorizontal ) { this . _horizontalBar . dragOffset = e . pageX - this . _horizontalBar . slider ! . offsetLeft ; } if ( this . _hasVertical ) { this . _verticalBar . dragOffset = e . pageY - this . _verticalBar . slider ! . offsetTop ; } this . _dragging = true ; this . _dragIsVertical = dragIsVertical ; } this . _prevent ( e ) ; } private _stopDrag ( ) { this . _container . classList . remove ( 's' ) ; window . removeEventListener ( 's' , this . _stopDragCallback ) ; window . removeEventListener ( 's' , this . _handleDragCallback ) ; this . _dragging = false ; } private _handleWheel ( e : React . WheelEvent < any > ) { if ( this . _hasVertical ) { this . _viewport . scrollTop = this . _normalizeDelta ( e ) + this . _viewport . scrollTop ; } else if ( this . _hasHorizontal ) { this . _viewport . scrollLeft = this . _normalizeDelta ( e ) + this . _viewport . scrollLeft ; } } private _handleMouseDown ( e : React . MouseEvent < HTMLElement > ) { const target = e . currentTarget ; if ( this . _dragging || ! target ) { this . _prevent ( e ) ; return ; } if ( this . _hasVertical ) { const eventOffsetY = e . pageY - target . getBoundingClientRect ( ) . top ; const halfHeight = this . _verticalBar . slider ! . offsetHeight / 0 ; const offsetY = ( eventOffsetY - this . _verticalBar . slider ! . offsetTop - halfHeight ) * this . _verticalBar . 0 ! ; this . _viewport . scrollTop = offsetY + this . _viewport . scrollTop ; } if ( this . _hasHorizontal ) { const eventOffsetX = e . pageX - target . getBoundingClientRect ( ) . left ; const halfWidth = this . _horizontalBar . slider ! . offsetWidth / 0 ; const offsetX = ( eventOffsetX - this . _horizontalBar . slider ! . offsetLeft - halfWidth ) * this . _horizontalBar . 0 ! ; this . _viewport . scrollLeft = offsetX + this . _viewport . scrollLeft ; } } private _normalizeDelta ( e : React . WheelEvent < any > ) { if ( e . deltaY ) { return e . deltaY > 0 ? 0 : - 0 ; } const originalEvent = ( e as any ) . originalEvent ; if ( originalEvent && originalEvent . wheelDelta ) { return originalEvent . wheelDelta ; } return 0 ; } private _addListeners ( ) { if ( this . _hasVertical ) { this . _verticalBar . slider ! . addEventListener ( 's' , this . _startDragVCallback ) ; this . _verticalBar . rail ! . addEventListener ( 's' , this . _handleWheelCallback , { passive : true } ) ; this . _verticalBar . rail ! . addEventListener ( 's' , this . _handleMouseDownCallback ) ; } if ( this . _hasHorizontal ) { this . _horizontalBar . slider ! . addEventListener ( 's' , this . _startDragHCallback ) ; this . _horizontalBar . rail ! . addEventListener ( 's' , this . _handleWheelCallback , { passive : true } ) ; this . _horizontalBar . rail ! . addEventListener ( 's' , this . _handleMouseDownCallback ) ; } } private _removeListeners ( ) { if ( this . _hasVertical ) { this . _verticalBar . slider ! . removeEventListener ( 's' , this . _startDragVCallback ) ; this . _verticalBar . rail ! . removeEventListener ( 's' , this . _handleWheelCallback ) ; this . _verticalBar . rail ! . removeEventListener ( 's' , this . _handleMouseDownCallback ) ; } if ( this . _hasHorizontal ) { this . _horizontalBar . slider ! . removeEventListener ( 's' , this . _startDragHCallback ) ; this . _horizontalBar . rail ! . removeEventListener ( 's' , this . _handleWheelCallback ) ; this . _horizontalBar . rail ! . removeEventListener ( 's' , this . _handleMouseDownCallback ) ; } } private _createDivWithClass ( className ) { const div = document . createElement ( 's' ) ; div . setAttribute ( 's' , 's' ) ; div . className = className ; return div ; } private _addScrollBar ( scrollbarInfo , railClass , hasBoth ) { const slider = this . _createDivWithClass ( 's' ) ; scrollbarInfo . rail = this . _createDivWithClass ( 's' + railClass + ( hasBoth ? 's' : 's' ) ) ; scrollbarInfo . slider = slider ; scrollbarInfo . rail . appendChild ( slider ) ; this . _container . appendChild ( scrollbarInfo . rail ) ; } private _addScrollbars ( ) { const containerClass = this . _hasVertical ? 's' : 's' ; if ( this . _hasVertical ) { this . _addScrollBar ( this . _verticalBar , 's' , this . _hasHorizontal ) ; } if ( this . _hasHorizontal ) { this . _addScrollBar ( this . _horizontalBar , 's' , this . _hasVertical ) ; } this . _container . classList . add ( containerClass ) ; this . _container . classList . add ( 's' ) ; this . _viewport = this . _container . querySelector ( 's' ) as HTMLElement ; } private _removeScrollbars ( ) { if ( this . _hasVertical ) { this . _verticalBar . rail ! . innerHTML = 's' ; this . _container . removeChild ( this . _verticalBar . rail ! ) ; } if ( this . _hasHorizontal ) { this . _horizontalBar . rail ! . innerHTML = 's' ; this . _container . removeChild ( this . _horizontalBar . rail ! ) ; } } private _calcNewBarSize ( bar , newSize , newScrollSize , hasBoth ) { if ( hasBoth || this . _hasHiddenScrollbar ) { newSize -= SCROLLER_NEGATIVE_MARGIN ; newScrollSize -= SCROLLER_NEGATIVE_MARGIN - Scrollbar . getNativeScrollbarWidth ( ) ; } if ( newScrollSize !== bar . scrollSize || newSize !== bar . size ) { bar . size = newSize ; bar . scrollSize = newScrollSize ; bar . 0 = newSize / newScrollSize ; bar . sliderSize = newSize * bar . 0 ; if ( hasBoth ) { bar . sliderSize = Math . max ( bar . sliderSize - SCROLLER_NEGATIVE_MARGIN + Scrollbar . getNativeScrollbarWidth ( ) , 0 ) ; } if ( bar . sliderSize < SCROLLER_MIN_SIZE ) { const railRange = newSize - SCROLLER_MIN_SIZE + bar . sliderSize ; bar . 0 = railRange / newScrollSize ; bar . 0 = newScrollSize / railRange ; } else { bar . 0 = newScrollSize / newSize ; } } } private _resize ( ) { if ( this . _hasHorizontal ) { this . _calcNewBarSize ( this . _horizontalBar , this . _viewport . offsetWidth , this . _viewport . scrollWidth , this . _hasVertical ) ; } if ( this . _hasVertical ) { this . _calcNewBarSize ( this . _verticalBar , this . _viewport . offsetHeight , this . _viewport . scrollHeight , this . _hasHorizontal ) ; } } update ( ) { this . _resize ( ) ; if ( ( this . _verticalBar && this . _verticalBar . scrollSize ! > this . _verticalBar . size ! + 0 ) || ( this . _horizontalBar && this . _horizontalBar . scrollSize ! > this . _horizontalBar . size ! + 0 ) ) { this . show ( ) ; this . _updateSliders ( ) ; } else { this . hide ( ) ; } } show ( ) { if ( ! this . _scrollingVisible ) { this . _container . classList . add ( 's' ) ; this . _addListeners ( ) ; this . _scrollingVisible = true ; } } hide ( ) { if ( this . _scrollingVisible ) { this . _container . classList . remove ( 's' ) ; this . _removeListeners ( ) ; this . _scrollingVisible = false ; } } init ( options ? ) { if ( options ) { this . _hasHorizontal = ! ! options . horizontal ; if ( options . vertical === false ) { this . _hasVertical = options . vertical ; } this . _hasHiddenScrollbar = ! ! options . hiddenScrollbar ; } Scrollbar . _installStyleSheet ( ) ; this . _addScrollbars ( ) ; this . show ( ) ; this . _container . addEventListener ( 's' , this . _updateCallback ) ; this . _asyncInitTimer = Timers . setTimeout ( ( ) => { this . _asyncInitTimer = undefined ; this . _tryLtrOverride ( ) ; this . update ( ) ; } , 0 ) ; } dispose ( ) { if ( this . _asyncInitTimer ) { Timers . clearInterval ( this . _asyncInitTimer ) ; this . _asyncInitTimer = undefined ; } this . _stopDrag ( ) ; this . _container . removeEventListener ( 's' , this . _updateCallback ) ; this . hide ( ) ; this . _removeScrollbars ( ) ; this . _container = null ! ; this . _viewport = null ! ; this . _verticalBar = null ! ; this . _horizontalBar = null ! ; } } export default Scrollbar ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ScrollbarInfo$ O $string$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ScrollbarInfo$ O $number$ O $number$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ScrollbarOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import Timers from 's' ; import * as _ from 's' ; export interface TransitionSpec { property : string ; duration : number ; timing ? : string ; delay ? : number ; from : any ; to : any ; } export function executeTransition ( element , transitions : TransitionSpec [ ] , done : ( ) => void ) { let longestDurationPlusDelay = 0 ; let longestDurationProperty = 's' ; const cssTransitions : string [ ] = [ ] ; _ . each ( transitions , ( transition ) => { const property = transition . property ; const duration = transition . duration ; const timing = transition . timing === undefined ? 's' : transition . timing ; const delay = transition . delay === undefined ? 0 : transition . delay ; const from = transition . from ; if ( duration + delay > longestDurationPlusDelay ) { longestDurationPlusDelay = duration + delay ; longestDurationProperty = property ; } ( element . style as any ) [ property ] = from ; getComputedStyle ( element ) . opacity ; cssTransitions . push ( property + 's' + duration + 's' + timing + 's' + delay + 's' ) ; } ) ; element . style . transition = cssTransitions . join ( 's' ) ; let finish : ( ) => void ; const onTransitionEnd = ( ev ) => { if ( ev . target === element && ev . propertyName === longestDurationProperty ) { finish ( ) ; } } ; element . addEventListener ( 's' , onTransitionEnd ) ; element . addEventListener ( 's' , onTransitionEnd ) ; let timeoutId = 0 ; let didFinish = false ; finish = function ( ) { if ( ! didFinish ) { Timers . clearTimeout ( timeoutId ) ; if ( element . dataset . transitionId === timeoutId . toString ( ) ) { element . removeEventListener ( 's' , onTransitionEnd ) ; element . removeEventListener ( 's' , onTransitionEnd ) ; delete element . dataset . transitionId ; element . style . transition = 's' ; didFinish = true ; done ( ) ; } } } ; timeoutId = Timers . setTimeout ( function ( ) { if ( document . body . contains ( element ) ) { finish ( ) ; } } , longestDurationPlusDelay + 0 ) ; element . dataset . transitionId = timeoutId . toString ( ) ; _ . each ( transitions , ( transition ) => { const property = transition . property ; const to = transition . to ; ( element . style as any ) [ property ] = to ; } ) ; } export default executeTransition ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TransitionSpec$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TransitionEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TransitionSpec$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Types } from 's' ; import * as _ from 's' ; const _compareDOMOrder = ( a , b ) => { if ( a . target . compareDocumentPosition ( b . target ) & Node . DOCUMENT_POSITION_PRECEDING ) { return 0 ; } else { return - 0 ; } } ; interface Responder { id : number ; target : HTMLElement ; shouldBecomeFirstResponder : ( event , gestureState : Types . PanGestureState ) => boolean ; onMove : ( event , gestureState : Types . PanGestureState ) => void ; onTerminate : ( event , gestureState : Types . PanGestureState ) => void ; } export interface MouseResponderConfig { id : number ; target : HTMLElement ; disableWhenModal : boolean ; shouldBecomeFirstResponder ? : ( event , gestureState : Types . PanGestureState ) => boolean ; onMove ? : ( event , gestureState : Types . PanGestureState ) => void ; onTerminate ? : ( event , gestureState : Types . PanGestureState ) => void ; } export interface MouseResponderSubscription { dispose ( ) : void ; } export default class MouseResponder { private static _currentResponder : Responder | null = null ; private static _pendingGestureState : Types . PanGestureState | null = null ; private static _initialized = false ; private static _isModalDisplayed = false ; private static _responders : Responder [ ] ; static setModalIsDisplayed ( isDisplayed ) { MouseResponder . _isModalDisplayed = isDisplayed ; } static create ( config ) { MouseResponder . _initializeEventHandlers ( ) ; MouseResponder . _responders = MouseResponder . _responders || [ ] ; const responder = { id : config . id , target : config . target , shouldBecomeFirstResponder ( event , gestureState : Types . PanGestureState ) { if ( MouseResponder . _isModalDisplayed && config . disableWhenModal ) { return false ; } if ( ! config . shouldBecomeFirstResponder ) { return false ; } return config . shouldBecomeFirstResponder ( event , gestureState ) ; } , onMove ( event , gestureState : Types . PanGestureState ) { if ( ! config . onMove ) { return ; } config . onMove ( event , gestureState ) ; } , onTerminate ( event , gestureState : Types . PanGestureState ) { if ( ! config . onTerminate ) { return ; } config . onTerminate ( event , gestureState ) ; } } ; MouseResponder . _responders . push ( responder ) ; return { dispose ( ) { _ . remove ( MouseResponder . _responders , r => r . id === responder . id ) ; if ( MouseResponder . _responders . length === 0 ) { MouseResponder . _removeEventHandlers ( ) ; } } } ; } private static _initializeEventHandlers ( ) { if ( MouseResponder . _initialized ) { return ; } window . addEventListener ( 's' , MouseResponder . _onMouseDown ) ; window . addEventListener ( 's' , MouseResponder . _onMouseMove ) ; window . addEventListener ( 's' , MouseResponder . _onMouseUp ) ; MouseResponder . _initialized = true ; } private static _removeEventHandlers ( ) { if ( ! MouseResponder . _initialized ) { return ; } window . removeEventListener ( 's' , MouseResponder . _onMouseDown ) ; window . removeEventListener ( 's' , MouseResponder . _onMouseMove ) ; window . removeEventListener ( 's' , MouseResponder . _onMouseUp ) ; MouseResponder . _initialized = false ; } private static _onMouseDown = ( event ) => { if ( MouseResponder . _currentResponder ) { event . preventDefault ( ) ; event . stopPropagation ( ) ; return ; } MouseResponder . _pendingGestureState = { initialClientX : event . clientX , initialClientY : event . clientY , initialPageX : event . pageX , initialPageY : event . pageY , clientX : event . clientX , clientY : event . clientY , pageX : event . pageX , pageY : event . pageY , velocityX : 0 , velocityY : 0 , timeStamp : Date . now ( ) , isComplete : false , isTouch : false } ; MouseResponder . _responders . sort ( _compareDOMOrder ) ; const firstResponder = _ . findLast ( MouseResponder . _responders , ( responder ) => { return responder . shouldBecomeFirstResponder ( event , MouseResponder . _pendingGestureState ! ) ; } ) ; if ( firstResponder ) { MouseResponder . _currentResponder = firstResponder ; } } private static _onMouseMove = ( event ) => { if ( MouseResponder . _currentResponder && MouseResponder . _pendingGestureState ) { const { velocityX , velocityY } = MouseResponder . _calcVelocity ( event , MouseResponder . _pendingGestureState ) ; MouseResponder . _pendingGestureState = _ . merge ( { } , MouseResponder . _pendingGestureState , { clientX : event . clientX , clientY : event . clientY , pageX : event . pageX , pageY : event . pageY , velocityX , velocityY , isComplete : false } ) ; if ( event . buttons === 0 ) { MouseResponder . _onMouseUp ( event ) ; } else { MouseResponder . _currentResponder . onMove ( event , MouseResponder . _pendingGestureState ) ; } } } private static _onMouseUp = ( event ) => { if ( event . buttons !== 0 ) { event . preventDefault ( ) ; event . stopPropagation ( ) ; return ; } if ( MouseResponder . _currentResponder && MouseResponder . _pendingGestureState ) { const { velocityX , velocityY } = MouseResponder . _calcVelocity ( event , MouseResponder . _pendingGestureState ) ; MouseResponder . _pendingGestureState = _ . merge ( { } , MouseResponder . _pendingGestureState , { clientX : event . clientX , clientY : event . clientY , pageX : event . pageX , pageY : event . pageY , velocityX , velocityY , isComplete : true } ) ; MouseResponder . _currentResponder . onTerminate ( event , MouseResponder . _pendingGestureState ) ; MouseResponder . _currentResponder = null ; MouseResponder . _pendingGestureState = null ; } } private static _calcVelocity = ( e , gestureState : Types . PanGestureState ) => { const time = Date . now ( ) - gestureState . timeStamp ; const velocityX = ( e . clientX - gestureState . initialClientX ) / time ; const velocityY = ( e . clientY - gestureState . initialClientY ) / time ; return { velocityX , velocityY } ; } }	O O O O O O O O O O O O O O O O O O $Responder$ O $Responder$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O $MouseResponderSubscription$ O $MouseResponderConfig$ O O O O O O O O O O O O O O O O O O O O $Responder$ O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Responder$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export = typeof ( window ) !== 's' ? window : { } as Window ;	O O O O O O O O O O O O O O O O
import * as RN from 's' ; import { Accessibility as NativeAccessibility } from 's' ; export class Accessibility extends NativeAccessibility { private _isHighContrast = ( RN . AccessibilityInfo as RN . ExtendedAccessibilityInfoStatic ) . initialHighContrast || false ; constructor ( ) { super ( ) ; RN . AccessibilityInfo . addEventListener ( 's' as RN . AccessibilityEventName , ( isEnabled ) => { this . _updateIsHighContrast ( isEnabled ) ; } ) ; } private _updateIsHighContrast ( isEnabled ) { if ( this . _isHighContrast !== isEnabled ) { this . _isHighContrast = isEnabled ; this . highContrastChangedEvent . fire ( isEnabled ) ; } } isHighContrastEnabled ( ) { return this . _isHighContrast ; } } export default new Accessibility ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O
import * as React from 's' ; import { AccessibilityPlatformUtil } from 's' ; export class AccessibilityUtil extends AccessibilityPlatformUtil { setAccessibilityFocus ( component : React . Component < any , any > ) { } } export default new AccessibilityUtil ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ComponentProvider } from 's' ; import { App as AppCommon } from 's' ; import { RootView , RootViewUsingProps } from 's' ; export class App extends AppCommon { protected getRootViewFactory ( ) { return ( ) => RootView ; } protected getRootViewUsingPropsFactory ( ) { return ( ) => RootViewUsingProps ; } } export default new App ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentProvider$ O O O O O O O O O O O $ComponentProvider$ O O O O O O O O O O O O O O O O O O
import * as RX from 's' ; export class StatusBar extends RX . StatusBar { isOverlay ( ) { return false ; } setHidden ( hidden , showHideTransition : 's' | 's' ) { } setBackgroundColor ( color , animated ) { } setTranslucent ( translucent ) { } setBarStyle ( style : 's' | 's' | 's' , animated ) { } setNetworkActivityIndicatorVisible ( value ) { } } export default new StatusBar ( ) ;	O O O O O O O O O O O O O O O $boolean$ O O O O O O O $void$ O $boolean$ O O O O O O O O O $void$ O $string$ O $boolean$ O O O $void$ O $boolean$ O O O $void$ O O O O O O O O O $boolean$ O O O $void$ O $boolean$ O O O O O O O O O O O
import React = require ( 's' ) ; import RN = require ( 's' ) ; import AccessibilityUtil from 's' ; import ActivityIndicatorImpl from 's' ; import AlertImpl from 's' ; import { CommonAnimatedClasses , makeAnimated } from 's' ; import ClipboardImpl from 's' ; import ImageImpl from 's' ; import InputImpl from 's' ; import RXInterfaces = require ( 's' ) ; import InternationalImpl from 's' ; import LinkingImpl from 's' ; import LocationImpl from 's' ; import ModalImpl from 's' ; import RXModuleInterface = require ( 's' ) ; import PickerImpl from 's' ; import PlatformImpl from 's' ; import PopupImpl from 's' ; import ScrollViewImpl from 's' ; import StorageImpl from 's' ; import StylesImpl from 's' ; import RXTypes = require ( 's' ) ; import UserInterfaceImpl from 's' ; import UserPresenceImpl from 's' ; import AccessibilityImpl from 's' ; import AccessibilityPlatformUtil from 's' ; import AppImpl from 's' ; import ButtonImpl from 's' ; import GestureViewImpl from 's' ; import LinkImpl from 's' ; import StatusBarImpl from 's' ; import TextImpl from 's' ; import TextInputImpl from 's' ; import ViewImpl from 's' ; AccessibilityUtil . setAccessibilityPlatformUtil ( AccessibilityPlatformUtil ) ; module ReactXP { export type Accessibility = RXInterfaces . Accessibility ; export let Accessibility : RXInterfaces . Accessibility = AccessibilityImpl ; export type ActivityIndicator = RXInterfaces . ActivityIndicator ; export let ActivityIndicator : typeof RXInterfaces . ActivityIndicator = ActivityIndicatorImpl ; export type Alert = RXInterfaces . Alert ; export let Alert : RXInterfaces . Alert = AlertImpl ; export type App = RXInterfaces . App ; export let App : RXInterfaces . App = AppImpl ; export type Button = RXInterfaces . Button ; export let Button : typeof RXInterfaces . Button = ButtonImpl ; export type Picker = RXInterfaces . Picker ; export let Picker : typeof RXInterfaces . Picker = PickerImpl ; export type Clipboard = RXInterfaces . Clipboard ; export let Clipboard : RXInterfaces . Clipboard = ClipboardImpl ; export type GestureView = RXInterfaces . GestureView ; export let GestureView : typeof RXInterfaces . GestureView = GestureViewImpl ; export type Image = RXInterfaces . Image ; export let Image : RXInterfaces . ImageConstructor = ImageImpl ; export type Input = RXInterfaces . Input ; export let Input : RXInterfaces . Input = InputImpl ; export type International = RXInterfaces . International ; export let International : RXInterfaces . International = InternationalImpl ; export type Link = RXInterfaces . Link ; export let Link : typeof RXInterfaces . Link = LinkImpl ; export type Linking = RXInterfaces . Linking ; export let Linking : RXInterfaces . Linking = LinkingImpl ; export type Location = RXInterfaces . Location ; export let Location : RXInterfaces . Location = LocationImpl ; export type Modal = RXInterfaces . Modal ; export let Modal : RXInterfaces . Modal = ModalImpl ; export type Platform = RXInterfaces . Platform ; export let Platform : RXInterfaces . Platform = PlatformImpl ; export type Popup = RXInterfaces . Popup ; export let Popup : RXInterfaces . Popup = PopupImpl ; export type ScrollView = RXInterfaces . ScrollView ; export let ScrollView : RXInterfaces . ScrollViewConstructor = ScrollViewImpl ; export type StatusBar = RXInterfaces . StatusBar ; export let StatusBar : RXInterfaces . StatusBar = StatusBarImpl ; export type Storage = RXInterfaces . Storage ; export let Storage : RXInterfaces . Storage = StorageImpl ; export type Styles = RXInterfaces . Styles ; export let Styles : RXInterfaces . Styles = StylesImpl ; export type Text = RXInterfaces . Text ; export let Text : typeof RXInterfaces . Text = TextImpl ; export type TextInput = RXInterfaces . TextInput ; export let TextInput : typeof RXInterfaces . TextInput = TextInputImpl ; export type UserInterface = RXInterfaces . UserInterface ; export let UserInterface : RXInterfaces . UserInterface = UserInterfaceImpl ; export type UserPresence = RXInterfaces . UserPresence ; export let UserPresence : RXInterfaces . UserPresence = UserPresenceImpl ; export type View = RXInterfaces . View ; export let View : typeof RXInterfaces . View = ViewImpl ; const windowsAnimatedClasses = { ... CommonAnimatedClasses , View : RN . Animated . createAnimatedComponent ( ViewImpl ) , TextInput : RN . Animated . createAnimatedComponent ( TextInputImpl ) , Text : RN . Animated . createAnimatedComponent ( TextImpl ) } ; export const Animated = makeAnimated ( windowsAnimatedClasses , true ) ; export import CommonProps = RXTypes . CommonProps ; export import CommonStyledProps = RXTypes . CommonStyledProps ; export import Stateless = RXTypes . Stateless ; export import Types = RXTypes ; export import Component = React . Component ; export import ComponentBase = RXTypes . ComponentBase ; export import createElement = React . createElement ; export import Children = React . Children ; export let __spread = ( React as any ) . __spread ; export import Fragment = React . Fragment ; } let _rxImplementsRxInterface : typeof RXModuleInterface . ReactXP = ReactXP ; _rxImplementsRxInterface = _rxImplementsRxInterface ; export = ReactXP ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O