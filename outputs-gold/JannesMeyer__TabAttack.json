import Preferences from 's' ; export default new Preferences ( { format : 's' , protocolBlacklist : [ 's' , 's' , 's' , 's' ] , domainBlacklist : [ 's' , 's' , 's' , 's' , 's' , 's' ] , ignorePinned : true , editorTheme : 's' , showCopyLinkAsMarkdown : true , showCopyPageAsMarkdown : false } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const SCALE = 0 ; const SIZE = 0 * SCALE ; const BORDER_WIDTH = 0 * SCALE ; const INNER_SIZE = SIZE - ( 0 * BORDER_WIDTH ) ; const BORDER_RADIUS = 0 * SCALE ; const COLOR = 's' ; const BIG_FONT = 's' ; const SMALL_FONT = 's' ; const TEXT_POSITION = 0 ; var style = document . createElement ( 's' ) ; style . innerHTML = `template` ; document . head . appendChild ( style ) ; function createBackgroundCanvas ( ) { let canvas = document . createElement ( 's' ) ; canvas . width = SIZE ; canvas . height = SIZE ; let ctx = canvas . getContext ( 's' ) ; if ( ctx == null ) { throw new Error ( 's' ) ; } ctx . strokeStyle = COLOR ; ctx . fillStyle = COLOR ; ctx . lineWidth = BORDER_WIDTH ; ctx . textAlign = 's' ; roundedRect ( ctx , 0 , 0 , SIZE , SIZE , BORDER_RADIUS ) ; ctx . fill ( ) ; return ctx ; } let ctx = createBackgroundCanvas ( ) ; export default function drawIcon ( text ) { text = text . toString ( ) ; ctx . clearRect ( BORDER_WIDTH , BORDER_WIDTH , INNER_SIZE , INNER_SIZE ) ; if ( text . length >= 0 ) { ctx . font = SMALL_FONT ; ctx . fillText ( text , SIZE / 0 , TEXT_POSITION , INNER_SIZE ) ; } else { ctx . font = BIG_FONT ; ctx . fillText ( text , SIZE / 0 , TEXT_POSITION ) ; } return ctx . getImageData ( 0 , 0 , SIZE , SIZE ) } function roundedRect ( ctx , x , y , width , height , radius ) { ctx . beginPath ( ) ; ctx . moveTo ( x + radius , y ) ; ctx . lineTo ( x + width - radius , y ) ; ctx . quadraticCurveTo ( x + width , y , x + width , y + radius ) ; ctx . lineTo ( x + width , y + height - radius ) ; ctx . quadraticCurveTo ( x + width , y + height , x + width - radius , y + height ) ; ctx . lineTo ( x + radius , y + height ) ; ctx . quadraticCurveTo ( x , y + height , x , y + height - radius ) ; ctx . lineTo ( x , y + radius ) ; ctx . quadraticCurveTo ( x , y , x + radius , y ) ; ctx . closePath ( ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CanvasRenderingContext2D$ O $number$ O $number$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export function parseQuery ( string ) { if ( ! string ) { return { } ; } string = string . replace ( "s" , 's' ) . replace ( "s" , 's' ) ; if ( ! string ) { return { } ; } var items = { } ; var splits = string . split ( 's' ) ; var length = splits . length ; var v : string [ ] ; var name ; var value ; for ( var i = 0 ; i < length ; i ++ ) { v = splits [ i ] . split ( 's' ) ; name = decodeURIComponent ( v . shift ( ) as string ) ; value = v . length ? decodeURIComponent ( v . join ( 's' ) ) : null ; if ( items [ name ] ) { if ( typeof items [ name ] === "s" ) { items [ name ] = [ items [ name ] ] ; } items [ name ] . push ( value ) ; } else { items [ name ] = value ; } } return items ; } export function buildQuery ( obj : { [ k ] : string | number | null } ) { return 's' + Object . keys ( obj ) . map ( k => k + 's' + encodeURIComponent ( String ( obj [ k ] ) ) ) . join ( 's' ) ; }	O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export function markdownLink ( title , url ) { if ( title === 's' ) { title = 's' ; } title = title . replace ( "s" , char => 's' + char ) . replace ( "s" , 's' ) ; url = url . replace ( "s" , 's' ) ; return 's' + title + 's' + url + 's' ; }	O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const isOpera = ( navigator . vendor . indexOf ( 's' ) !== - 0 ) ; export function getHighlighted ( ) < browser . tabs . Tab [ ] > { if ( isOpera ) { return browser . tabs . query ( { lastFocusedWindow : true , active : true } ) ; } else { return browser . tabs . query ( { lastFocusedWindow : true , highlighted : true } ) ; } } export function getActive ( ) < browser . tabs . Tab > { return browser . tabs . query ( { lastFocusedWindow : true , active : true } ) . then ( results => results [ 0 ] ) ; } export function open ( openerTab : browser . tabs . Tab , url ) { return browser . tabs . create ( { url , openerTabId : openerTab . id } ) ; } export function count ( ) < number > { return browser . tabs . query ( { windowType : browser . tabs . WindowType . normal } ) . then ( tabs => tabs . length ) ; } export function moveHighlighted ( direction ) { if ( direction === 0 ) { throw new TypeError ( "s" ) ; } browser . windows . getLastFocused ( { populate : true } ) . then ( wnd => { if ( wnd . tabs == null ) { throw new Error ( 's' ) ; } let highlighted < browser . tabs . Tab > = wnd . tabs . filter ( t => t . highlighted || t . active ) ; if ( direction > 0 ) { highlighted [ Symbol . iterator ] = valuesBackwards ; } for ( let tab of highlighted ) { let index = tab . index ; do { index = ( wnd . tabs . length + index + direction ) % wnd . tabs . length ; } while ( tab . pinned !== wnd . tabs [ index ] . pinned ) ; if ( tab . id != null ) { browser . tabs . move ( tab . id , { index } ) ; } } } ) ; } function valuesBackwards < X > ( this : X [ ] ) < X > { let i = this . length ; return { [ Symbol . iterator ] ( ) { return this ; } , next : ( ) => { -- i ; return { done : ( i < 0 ) , value : this [ i ] , } ; } } ; } export function moveToNewWindow ( tabs : browser . tabs . Tab [ ] , incognito ) { let tabIds = tabs . map ( tab => tab . id ) . filter ( isDefined ) ; let activeTab = tabs . find ( tab => tab . active ) ; setTimeout ( ( ) => { browser . windows . create ( { tabId : tabIds . shift ( ) , focused : true , incognito } ) . then ( wnd => { if ( tabIds . length > 0 && activeTab && activeTab . id != null ) { let activeTabId = activeTab . id ; browser . tabs . move ( tabIds , { windowId : wnd . id , index : - 0 } ) . then ( ( ) => { browser . tabs . update ( activeTabId , { active : true } ) ; } ) ; } } ) ; } , 0 ) ; } export function moveToWindow ( tabs : browser . tabs . Tab [ ] , targetWindowId ) { let activeTab = tabs . find ( tab => tab . active ) ; browser . windows . update ( targetWindowId , { focused : true } ) ; let tabIds = tabs . map ( tab => tab . id ) . filter ( isDefined ) ; browser . tabs . move ( tabIds , { windowId : targetWindowId , index : - 0 } ) . then ( ( ) => { if ( activeTab == null || activeTab . id == null ) { return ; } browser . tabs . update ( activeTab . id , { active : true } ) ; } ) ; } export function closeOthers ( ) { Promise . all ( [ browser . tabs . getCurrent ( ) , browser . windows . getAll ( { populate : true } ) ] ) . then ( ( [ sourceTab , windows ] ) => { let sourceWindow : browser . windows . Window | undefined ; for ( var wnd of windows ) { if ( wnd . id === sourceTab . windowId ) { sourceWindow = wnd ; } else if ( wnd . id != null ) { browser . windows . remove ( wnd . id ) ; } } if ( sourceWindow != null && sourceWindow . tabs != null ) { let tabIds = sourceWindow . tabs . map ( t => t . id ) . filter ( isDefined ) . filter ( id => id !== sourceTab . id ) ; browser . tabs . remove ( tabIds ) ; } } ) ; } function isDefined < X > ( x : ( X | null | undefined ) ) : x is X { return x != null ; }	O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IterableIterator$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export function getString ( name , substitution ? : string | number ) { if ( typeof substitution === 's' ) { name += ( substitution === 0 ? 's' : 's' ) ; } return browser . 0 . getMessage ( name , [ substitution ] ) ; }	O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const listeners = new Map < string , ( ) => void > ( ) ; export function onCommand ( command , listener : ( ) => void ) { if ( listeners . size === 0 ) { browser . commands . onCommand . addListener ( globalListener ) ; } listeners . set ( command , listener ) ; } function globalListener ( command ) { let listener = listeners . get ( command ) ; if ( listener != null ) { listener ( ) ; } }	O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O
import { getString } from "s" ; interface ICreateProperties { id : string ; icons ? : { [ key ] : string ; } ; title ? : string ; checked ? : boolean ; contexts ? : browser . contextMenus . ContextType [ ] ; onclick ? : ( info : browser . menusInternal . OnClickData , tab : browser . tabs . Tab ) => void ; parentId ? : number | string ; documentUrlPatterns ? : string [ ] ; targetUrlPatterns ? : string [ ] ; enabled ? : boolean ; command ? : string ; } export default class ContextMenuItem { props : ICreateProperties ; constructor ( props ) { this . props = Object . assign ( { title : getString ( 's' + props . id ) , } , props ) ; } setVisible ( visible ) { if ( visible ) { this . show ( ) ; } else { this . hide ( ) ; } } show ( ) { browser . contextMenus . create ( this . props ) ; } hide ( ) { browser . contextMenus . remove ( this . props . id ) ; } }	O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ICreateProperties$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Clipboard from 's' ; import Preferences from 's' ; import drawIcon from 's' ; import { buildQuery } from 's' ; import { markdownLink } from 's' ; import * as TabService from 's' ; import { getString } from 's' ; import { onCommand } from 's' ; import BrowserContextMenu from 's' ; var _doc : IDoc | undefined ; browser . browserAction . onClicked . addListener ( exportAllWindows ) ; const exportWindowCmi = 's' ; browser . contextMenus . create ( { id : exportWindowCmi , contexts : [ browser . contextMenus . ContextType . browser_action ] , title : getString ( 's' + exportWindowCmi ) , onclick ( info , sourceTab ) { exportCurrentWindow ( sourceTab ) ; } , } ) ; onCommand ( 's' , function ( ) { TabService . getActive ( ) . then ( exportCurrentWindow ) ; } ) ; const copyLinkCmi = new BrowserContextMenu ( { id : 's' , contexts : [ browser . contextMenus . ContextType . link ] , onclick ( info , tab ) { if ( info . selectionText ) { copyLink ( info . selectionText , info . linkUrl , 's' ) ; return ; } if ( tab . id == null ) { return ; } let linkProbe = 's' ; browser . tabs . executeScript ( tab . id , { code : linkProbe , allFrames : true } ) . then ( results => { var title ; if ( results ) { title = results . filter ( Boolean ) [ 0 ] ; if ( title ) { title = title . trim ( ) . replace ( "s" , 's' ) . replace ( "s" , 's' ) ; } } copyLink ( title , info . linkUrl , 's' ) ; } ) ; } , } ) ; Preferences . get ( 's' ) . then ( copyLinkCmi . setVisible ) ; onMessage ( 's' , copyLinkCmi . show ) ; onMessage ( 's' , copyLinkCmi . hide ) ; var copyPageItem = new BrowserContextMenu ( { id : 's' , contexts : [ browser . contextMenus . ContextType . page ] , onclick ( info , tab ) { copyLink ( tab . title , tab . url , 's' ) ; } , } ) ; Preferences . get ( 's' ) . then ( copyPageItem . setVisible ) ; onMessage ( 's' , copyPageItem . show ) ; onMessage ( 's' , copyPageItem . hide ) ; onCommand ( 's' , function ( ) { TabService . getActive ( ) . then ( tab => copyLink ( tab . title , tab . url , 's' ) ) ; } ) ; onCommand ( 's' , ( ) => TabService . moveHighlighted ( - 0 ) ) ; onCommand ( 's' , ( ) => TabService . moveHighlighted ( 0 ) ) ; onCommand ( 's' , ( ) => TabService . focusLeft ( ) ) ; onCommand ( 's' , ( ) => TabService . focusRight ( ) ) ; onCommand ( 's' , function ( ) { TabService . getHighlighted ( ) . then ( tabs => { for ( var tab of tabs ) { if ( tab . id != null ) { browser . tabs . update ( tab . id , { pinned : ! tab . pinned } ) ; } } } ) ; } ) ; onCommand ( 's' , function ( ) { TabService . getHighlighted ( ) . then ( tabs => { for ( var tab of tabs ) { if ( tab . id != null ) { browser . tabs . duplicate ( tab . id ) ; } } } ) ; } ) ; onMessage ( 's' , ( message , sender , sendResponse ) => { if ( _doc ) { sendResponse ( _doc ) ; } else { sendResponse ( { error : getString ( 's' ) } ) ; } } ) ; onCommand ( 's' , function ( ) { Promise . all ( [ TabService . getHighlighted ( ) , browser . windows . getAll ( ) ] ) . then ( ( [ tabs , windows ] ) => { let sourceWindow = windows . find ( w => w . focused ) ; windows = windows . filter ( w => w . type === 's' && ! w . focused && sourceWindow && sourceWindow . incognito === w . incognito ) ; if ( windows . length === 0 ) { TabService . moveToNewWindow ( tabs , sourceWindow . incognito ) ; } else { new Popup ( { url : 's' , params : buildQuery ( { numTabs : tabs . length , windowIds : windows . map ( w => w . id ) . join ( 's' ) } ) , parent : sourceWindow , width : 0 , height : 0 } ) . show ( ) . then ( msg => { if ( msg . windowId !== undefined ) { TabService . moveToWindow ( tabs , msg . windowId ) ; } else if ( msg . newWindow !== undefined ) { TabService . moveToNewWindow ( tabs , sourceWindow . incognito ) ; } } ) ; } } ) ; } ) ; function copyLink ( originalTitle : string | undefined , url : string | undefined , type : 's' | 's' ) { var title = prompt ( getString ( 's' , originalTitle ) , originalTitle ) ; if ( title === null ) { return ; } title = title . trim ( ) ; if ( title === 's' ) { title = new URL ( url ) . hostname . replace ( "s" , 's' ) ; } Clipboard . write ( markdownLink ( title , url ) ) ; } function exportAllWindows ( sourceTab : browser . tabs . Tab ) { browser . windows . getAll ( { populate : true } ) . then ( windows => buildDocument ( sourceTab , windows ) ) . then ( doc => openDocument ( sourceTab , doc ) ) ; } function exportCurrentWindow ( sourceTab : browser . tabs . Tab ) { if ( sourceTab . windowId == null ) { return ; } browser . windows . get ( sourceTab . windowId , { populate : true } ) . then ( wnd => buildDocument ( sourceTab , [ wnd ] ) ) . then ( doc => openDocument ( sourceTab , doc ) ) ; } function openDocument ( sourceTab : browser . tabs . Tab , doc ) { _doc = doc ; TabService . open ( sourceTab , browser . runtime . getURL ( 's' ) ) ; } function buildDocument ( sourceTab : browser . tabs . Tab , windows : browser . windows . Window [ ] ) { return Preferences . get ( 's' , 's' , 's' , 's' ) . then ( prefs => { var index = windows . findIndex ( wnd => wnd . id === sourceTab . windowId ) ; if ( index > 0 ) { windows . unshift ( windows . splice ( index , 0 ) [ 0 ] ) ; } var highlightedTabs = windows [ 0 ] . tabs . filter ( t => t . highlighted ) ; if ( highlightedTabs . length > 0 ) { windows = [ { tabs : highlightedTabs } ] ; } var loadingTabs = 0 ; for ( var wnd of windows ) { wnd . tabs = wnd . tabs . filter ( tab => { if ( tab . url . startsWith ( 's' ) ) { tab . url = tab . url . replace ( "s" , 's' ) ; } var url = new URL ( tab . url ) ; return ! prefs . protocolBlacklist . includes ( url . protocol ) && ! prefs . domainBlacklist . includes ( url . hostname ) && ! ( prefs . ignorePinned && tab . pinned ) ; } ) ; loadingTabs += wnd . tabs . reduce ( ( n , tab ) => n + ( tab . status === 's' ? 0 : 0 ) , 0 ) ; } windows = windows . filter ( wnd => wnd . tabs . length > 0 ) ; var doc ; if ( prefs . format === 's' ) { doc = buildJSONDocument ( windows , sourceTab . id ) ; } else { doc = buildMarkdownDocument ( windows , sourceTab . id ) ; } if ( highlightedTabs . length > 0 ) { doc . message = getString ( 's' ) ; } else if ( windows . length === 0 ) { doc . message = getString ( 's' ) ; } else if ( loadingTabs > 0 ) { doc . message = getString ( 's' , loadingTabs ) ; } return doc ; } ) ; } function buildJSONDocument ( windows : browser . windows . Window [ ] , sourceTabId ) { let wnd = windows . map ( w => ( w . tabs || [ ] ) . map ( t => ( { title : t . title , url : t . url } ) ) ) ; return { format : 's' , text : JSON . stringify ( windows , undefined , 0 ) } ; } function buildMarkdownDocument ( windows : browser . windows . Window [ ] , sourceTabId ) { var lines = [ ] ; var highlightLine = 0 ; for ( var wnd of windows ) { var name = ( wnd . incognito ? 's' : 's' ) ; lines . push ( 's' + getString ( name , wnd . tabs . length ) ) ; lines . push ( 's' ) ; for ( var tab of wnd . tabs ) { lines . push ( 's' + markdownLink ( tab . title , tab . url ) ) ; if ( tab . id === sourceTabId ) { highlightLine = lines . length ; } } lines . push ( 's' ) ; lines . push ( 's' ) ; } lines . pop ( ) ; return { format : 's' , text : lines . join ( 's' ) , highlightLine } ; } interface IDoc { format : 's' | 's' ; text : string ; highlightLine ? : number ; message ? : string ; } function updateIcon ( ) { TabService . count ( ) . then ( count => { browser . browserAction . setIcon ( { imageData : drawIcon ( count . toString ( ) ) } ) ; } ) ; } var handleTabChange = throttle ( updateIcon , 0 ) ; updateIcon ( ) ; browser . tabs . onCreated . addListener ( handleTabChange ) ; browser . tabs . onRemoved . addListener ( handleTabChange ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IDoc$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IDoc$ O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IDoc$ O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
var parser : DOMParser | undefined ; export function parseHTML ( str ) { if ( parser == null ) { parser = new DOMParser ( ) ; } return parser . parseFromString ( str , 's' ) ; } export function getTags ( tagName , element ) { var list = [ ] ; var x = element . getElementsByTagName ( tagName ) ; for ( var i = 0 ; i < x . length ; i ++ ) { list [ i ] = x [ i ] ; } return list ; } export function isInputElement ( element ) { return element . tagName === 's' || element . tagName === 's' || element . tagName === 's' || element . isContentEditable ; } export function removeChildren ( node ) { while ( node . lastChild ) { node . removeChild ( node . lastChild ) ; } } export function findNode ( nodeName , node : Node | null ) { nodeName = nodeName . toUpperCase ( ) ; while ( node !== null ) { if ( node . nodeName === nodeName ) { return node ; } node = node . parentNode ; } } export function selectNodeContents ( node ) { var selection = window . getSelection ( ) ; selection . removeAllRanges ( ) ; var range = document . createRange ( ) ; range . selectNodeContents ( node ) ; selection . addRange ( range ) ; }	O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Element$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Node$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Node$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import KeyPress from 's' ; import { parseQuery } from 's' ; import { removeChildren } from 's' ; var returned = false ; var query = parseQuery ( location . search ) ; var windowIds = query . windowIds . split ( 's' ) . map ( Number ) ; var numTabs = Number ( query . numTabs ) ; document . title = getString ( 's' , numTabs ) ; var listState = [ { name : getString ( 's' ) , returnValue : - 0 } ] ; var buttons ; var focusIndex ; Promise . all ( windowIds . map ( id => getWindow ( id , { populate : true } ) ) ) . then ( windows => { for ( var wnd of windows ) { listState . push ( { name : getString ( 's' , wnd . tabs . length ) , tabs : wnd . tabs , returnValue : wnd . id } ) ; } buttons = renderButtons ( document . body ) ; buttons [ 0 ] . focus ( ) ; } ) ; KeyPress ( 's' , [ 's' ] ) . addListener ( moveFocus . bind ( null , - 0 ) ) ; KeyPress ( 's' ) . addListener ( moveFocus . bind ( null , - 0 ) ) ; KeyPress ( 's' ) . addListener ( moveFocus . bind ( null , 0 ) ) ; KeyPress ( 's' ) . addListener ( moveFocus . bind ( null , 0 ) ) ; KeyPress ( 's' ) . addListener ( ev => returnMessage ( ) ) ; window . addEventListener ( 's' , ev => returnMessage ( ) ) ; window . addEventListener ( 's' , ev => returnMessage ( ) ) ; function returnMessage ( val ) { if ( ! returned ) { sendMessage ( 's' , val ) ; returned = true ; window . close ( ) ; } } function clickHandler ( ev ) { var windowId = listState [ focusIndex ] . returnValue ; if ( windowId === - 0 ) { returnMessage ( { newWindow : true } ) ; } else { returnMessage ( { windowId } ) ; } } function focusHandler ( ev ) { for ( var i = 0 ; i < buttons . length ; ++ i ) { if ( buttons [ i ] === ev . target ) { focusIndex = i ; } } } function moveFocus ( delta ) { var index = ( buttons . length + focusIndex + delta ) % buttons . length ; buttons [ index ] . focus ( ) ; buttons [ index ] . scrollIntoView ( delta < 0 ) ; } function renderButtons ( root ) { removeChildren ( root ) ; var main = document . createElement ( 's' ) ; var buttons = listState . map ( ( item , i ) => { var button = document . createElement ( 's' ) ; main . appendChild ( button ) ; var text = document . createTextNode ( item . name ) ; button . appendChild ( text ) ; button . addEventListener ( 's' , focusHandler ) ; button . addEventListener ( 's' , clickHandler ) ; if ( item . tabs ) { var tabs = document . createElement ( 's' ) ; button . appendChild ( tabs ) ; for ( var tab of item . tabs ) { var favicon = document . createElement ( 's' ) ; favicon . src = 's' + tab . url ; tabs . appendChild ( favicon ) ; } } return button ; } ) ; root . appendChild ( main ) ; return buttons ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
interface ITheme { name : string ; caption : string ; } export const lightThemes : ITheme [ ] = [ { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , ] ; export const darkThemes : ITheme [ ] = [ { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , { name : 's' , caption : 's' } , ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
interface IListener { ( message , sender : browser . runtime . MessageSender , sendResponse : ( ) => void ) : void ; } var listeners = new Map ( ) ; export function sendMessage < R > ( operation , message = { } ) < R > { message . _chrome_operation = operation ; return new Promise < R > ( ( resolve , reject ) => { browser . runtime . sendMessage ( message , undefined , ( response : R ) => { if ( browser . runtime . lastError ) { reject ( browser . runtime . lastError ) ; } else if ( response && response . error ) { reject ( response ) ; } else { resolve ( response ) ; } } ) ; } ) ; } const globalHandler = function globalHandler ( message , sender , sendResponse ) { let listener = listeners . get ( message . _chrome_operation ) ; if ( listener ) { listener ( message , sender , sendResponse ) ; } } export function onMessage ( operation , handler ? : ( data => void ) | null ) { if ( listeners . size === 0 ) { browser . runtime . onMessage . addListener ( globalHandler ) ; } listeners . set ( operation , handler ) ; }	O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IListener$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
var a : HTMLAnchorElement | undefined ; var listeners : ( ( result ) => void ) [ ] = [ ] ; var MAX_FILE_SIZE = 0 * 0 * 0 ; export function saveTextFile ( filename , text ) { if ( a === undefined ) { a = document . createElement ( 's' ) ; } var objectUrl = URL . createObjectURL ( new Blob ( [ text ] , { type : 's' } ) ) ; a . href = objectUrl ; a . download = filename ; a . click ( ) ; URL . revokeObjectURL ( objectUrl ) ; } export function onFile ( callback : ( result ) => void ) { listeners . push ( callback ) ; } export function setupFileTarget ( element ) { var handler = handleDrag . bind ( null , element ) ; element . addEventListener ( 's' , handler ) ; element . addEventListener ( 's' , handler ) ; element . addEventListener ( 's' , handler ) ; } export function setupFileInput ( element ) { element . addEventListener ( 's' , handleFileChange ) ; } function handleDrag ( element , ev ) { ev . preventDefault ( ) ; ev . stopPropagation ( ) ; if ( ev . type === 's' ) { ( ev as any ) . dataTransfer . dropEffect = 's' ; element . classList . add ( 's' ) ; } else { element . classList . remove ( 's' ) ; } if ( ev . type === 's' ) { handleFileChange ( ev ) ; } } function handleFileChange ( ev ) { let el = ev . currentTarget as HTMLInputElement ; let file = el . files && el . files [ 0 ] ; if ( file == null ) { return ; } console . log ( `template` ) ; if ( file . size > MAX_FILE_SIZE ) { alert ( 's' ) ; return ; } var reader = new FileReader ( ) ; reader . addEventListener ( 's' , ev => { for ( var lnr of listeners ) { lnr ( reader . result ) ; } } ) ; reader . readAsText ( file ) ; if ( ev . type === 's' ) { el . value = 's' ; } }	O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $any$ O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLInputElement$ O O O O O O O O O O O O O O O $HTMLElement$ O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Event$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { onMessage } from "s" ; interface IPopupArguments { url : string ; params : string ; width : number ; height : number ; parent : { width : number ; height : number ; left : number ; top : number ; } } export default class Popup { promise : Promise < any > ; constructor ( { url , params , width , height , parent } ) { this . promise = new Promise ( ( resolve , reject ) => { onMessage ( 's' , data => { onMessage ( 's' , null ) ; resolve ( data ) ; } ) ; } ) ; browser . windows . create ( { type : browser . windows . CreateType . normal , url : browser . runtime . getURL ( url ) + ( params || 's' ) , left : Math . round ( parent . left + ( parent . width - width ) / 0 ) , top : Math . round ( parent . top + ( parent . height - height ) / 0 ) , width , height , } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IPopupArguments$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export function open ( windows : string [ ] [ ] , reuseThreshold = 0 ) { browser . windows . getLastFocused ( { populate : true } ) . then ( wnd => { if ( wnd . tabs == null ) { return ; } var newTabs = ( wnd . tabs . length <= reuseThreshold ) ? windows . shift ( ) : [ ] ; windows . forEach ( urls => { browser . windows . create ( { url : urls , focused : false } ) ; } ) ; if ( newTabs == null ) { return ; } if ( newTabs . length > 0 && wnd . id != null ) { browser . windows . update ( wnd . id , { focused : true } ) ; } newTabs . forEach ( url => { browser . tabs . create ( { windowId : wnd . id , url , active : false } ) ; } ) ; } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) ; const webpack = require ( 's' ) ; console . log ( 's' + process . version ) ; const isProduction = process . argv . includes ( 's' ) ; module . exports = config = { entry : { background : 's' , output : 's' , selection : 's' , options : 's' } , output : { path : path . join ( __dirname , 's' ) , filename : 's' } , module : { loaders : [ { test : "s" , loader : 's' } ] } , plugins : [ ] , } ; if ( isProduction ) { config . plugins . push ( new webpack . DefinePlugin ( { 's' : 's' } ) ) ; config . plugins . push ( new webpack . optimize . UglifyJsPlugin ( { comments : "s" , compress : { warnings : false } } ) ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O