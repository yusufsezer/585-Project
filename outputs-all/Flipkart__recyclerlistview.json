export default interface ItemAnimator { animateWillMount : ( atX , atY , itemIndex ) => object | undefined ; animateDidMount : ( atX , atY , itemRef , itemIndex ) => void ; animateWillUpdate : ( fromX , fromY , toX , toY , itemRef , itemIndex ) => void ; animateShift : ( fromX , fromY , toX , toY , itemRef , itemIndex ) => boolean ; animateWillUnmount : ( atX , atY , itemRef , itemIndex ) => void ; } export class BaseItemAnimator implements ItemAnimator { public static USE_NATIVE_DRIVER = true ; public animateWillMount ( atX , atY , itemIndex ) : object | undefined { return undefined ; } public animateDidMount ( atX , atY , itemRef , itemIndex ) { } public animateWillUpdate ( fromX , fromY , toX , toY , itemRef , itemIndex ) { } public animateShift ( fromX , fromY , toX , toY , itemRef , itemIndex ) { return false ; } public animateWillUnmount ( atX , atY , itemRef , itemIndex ) { } }	O O O $any$ O $object$ O O $number$ O $number$ O $number$ O O O O O O $void$ O O $number$ O $number$ O $object$ O $number$ O O O O $void$ O O $number$ O $number$ O $number$ O $number$ O $object$ O $number$ O O O O $boolean$ O O $number$ O $number$ O $number$ O $number$ O $object$ O $number$ O O O O $void$ O O $number$ O $number$ O $object$ O $number$ O O O O O O O $any$ O $any$ O O O $boolean$ O O O O $object$ O $number$ O $number$ O $number$ O O O O O O O $undefined$ O O O $void$ O $number$ O $number$ O $object$ O $number$ O O O O $void$ O $number$ O $number$ O $number$ O $number$ O $object$ O $number$ O O O O $boolean$ O $number$ O $number$ O $number$ O $number$ O $object$ O $number$ O O O O O O O $void$ O $number$ O $number$ O $object$ O $number$ O O O O
export default class CustomError extends Error { constructor ( exception ) { super ( exception . message ) ; this . name = exception . type ; } } export interface Exception { type : string ; message : string ; }	O O O $any$ O $ErrorConstructor$ O O O $Exception$ O O O O $Exception$ O $string$ O O O O $string$ O $Exception$ O $string$ O O O O O $any$ O $string$ O O O $string$ O O O O
import CustomError from "s" ; export interface ValueAndIndex { value : number ; index : number ; } export default class BinarySearch { public static findClosestHigherValueIndex ( size , targetValue , valueExtractor : ( index ) => number ) { let low = 0 ; let high = size - 0 ; let mid = Math . floor ( ( low + high ) / 0 ) ; let lastValue = 0 ; let absoluteLastDiff = Math . abs ( valueExtractor ( mid ) - targetValue ) ; let result = mid ; let diff = 0 ; let absoluteDiff = 0 ; if ( absoluteLastDiff === 0 ) { return result ; } if ( high < 0 ) { throw new CustomError ( { message : "s" , type : "s" , } ) ; } while ( low <= high ) { mid = Math . floor ( ( low + high ) / 0 ) ; lastValue = valueExtractor ( mid ) ; diff = lastValue - targetValue ; absoluteDiff = Math . abs ( diff ) ; if ( diff >= 0 && absoluteDiff < absoluteLastDiff ) { absoluteLastDiff = absoluteDiff ; result = mid ; } if ( targetValue < lastValue ) { high = mid - 0 ; } else if ( targetValue > lastValue ) { low = mid + 0 ; } else { return mid ; } } return result ; } public static findClosestValueToTarget ( values : number [ ] , target ) { let low = 0 ; let high = values . length - 0 ; let mid = Math . floor ( ( low + high ) / 0 ) ; let midValue = values [ mid ] ; let lastMidValue = midValue + 0 ; while ( low <= high && midValue !== lastMidValue ) { if ( midValue === target ) { break ; } else if ( midValue < target ) { low = mid ; } else if ( midValue > target ) { high = mid ; } mid = Math . floor ( ( low + high ) / 0 ) ; lastMidValue = midValue ; midValue = values [ mid ] ; } return { value : midValue , index : mid , } ; } public static findValueSmallerThanTarget ( values : number [ ] , target ) : ValueAndIndex | undefined { const low = 0 ; const high = values . length - 0 ; if ( target >= values [ high ] ) { return { value : values [ high ] , index : high , } ; } else if ( target < values [ low ] ) { return undefined ; } const midValueAndIndex = this . findClosestValueToTarget ( values , target ) ; const midValue = midValueAndIndex . value ; const mid = midValueAndIndex . index ; if ( midValue <= target ) { return { value : midValue , index : mid , } ; } else { return { value : values [ mid - 0 ] , index : mid - 0 , } ; } } public static findValueLargerThanTarget ( values : number [ ] , target ) : ValueAndIndex | undefined { const low = 0 ; const high = values . length - 0 ; if ( target < values [ low ] ) { return { value : values [ low ] , index : low , } ; } else if ( target > values [ high ] ) { return undefined ; } const midValueAndIndex = this . findClosestValueToTarget ( values , target ) ; const midValue = midValueAndIndex . value ; const mid = midValueAndIndex . index ; if ( midValue >= target ) { return { value : midValue , index : mid , } ; } else { return { value : values [ mid + 0 ] , index : mid + 0 , } ; } } public static findIndexOf ( array : number [ ] , value ) { let j = 0 ; let length = array . length ; let i = 0 ; while ( j < length ) { i = length + j - 0 >> 0 ; if ( value > array [ i ] ) { j = i + 0 ; } else if ( value < array [ i ] ) { length = i ; } else { return i ; } } return - 0 ; } }	O $any$ O O O O O $any$ O $number$ O O O $number$ O O O O O O O $any$ O O O $number$ O $number$ O $number$ O $number$ O O $number$ O O O O O O $number$ O O O O $number$ O $number$ O O O O $number$ O $Math$ O $number$ O O $number$ O $number$ O O O O O O $number$ O O O O $number$ O $Math$ O $number$ O $number$ O $number$ O O $number$ O O O $number$ O $number$ O O $number$ O O O O $number$ O O O O O $number$ O O O O O $number$ O O O O $number$ O O O O O O $any$ O O $string$ O O O $string$ O O O O O O O O O $number$ O $number$ O O $number$ O $Math$ O $number$ O O $number$ O $number$ O O O O O $number$ O $number$ O $number$ O O $number$ O $number$ O $number$ O $number$ O $Math$ O $number$ O $number$ O O O O $number$ O O O $number$ O $number$ O O $number$ O $number$ O $number$ O $number$ O O O O $number$ O $number$ O O $number$ O $number$ O O O O O O O $number$ O $number$ O O $number$ O $number$ O O O O O O O $number$ O O O O $number$ O O O O $ValueAndIndex$ O $number[]$ O O O O O $number$ O O O $number$ O O O O $number$ O $number[]$ O $number$ O O O O $number$ O $Math$ O $number$ O O $number$ O $number$ O O O O O O $number$ O $number[]$ O $number$ O O O $number$ O $number$ O O O O O $number$ O $number$ O $number$ O $number$ O O O O $number$ O $number$ O O O O O O O O $number$ O $number$ O O $number$ O $number$ O O O O O $number$ O $number$ O O $number$ O $number$ O O $number$ O $Math$ O $number$ O O $number$ O $number$ O O O O O $number$ O $number$ O $number$ O $number[]$ O $number$ O O O O O $number$ O $number$ O $number$ O $number$ O O O O O O $ValueAndIndex$ O $number[]$ O O O O O $number$ O O $any$ O O O O O O O O O $number$ O $number[]$ O $number$ O O O O O $number$ O $number[]$ O $number$ O O O O O $number$ O $number[]$ O $number$ O O $number$ O $number$ O O O O O O O $number$ O $number[]$ O O O O O O $undefined$ O O O $ValueAndIndex$ O O O $ValueAndIndex$ O $number[]$ O $number$ O O O $number$ O $ValueAndIndex$ O $number$ O O $number$ O $ValueAndIndex$ O $number$ O O O $number$ O $number$ O O O O $number$ O $number$ O $number$ O $number$ O O O O O O O O $number$ O $number[]$ O $number$ O O O O $number$ O $number$ O O O O O O O O O $ValueAndIndex$ O $number[]$ O O O O O $number$ O O $any$ O O O O O O O O O $number$ O $number[]$ O $number$ O O O O O $number$ O $number[]$ O O O O O O O $number$ O $number[]$ O O O O $number$ O O O O O O O O O $number$ O $number[]$ O $number$ O O O O $undefined$ O O O $ValueAndIndex$ O O O $ValueAndIndex$ O $number[]$ O $number$ O O O $number$ O $ValueAndIndex$ O $number$ O O $number$ O $ValueAndIndex$ O $number$ O O O $number$ O $number$ O O O O $number$ O $number$ O $number$ O $number$ O O O O O O O O $number$ O $number[]$ O $number$ O O O O $number$ O $number$ O O O O O O O O O $number$ O $number[]$ O O O O O $number$ O O O $number$ O O O O $number$ O $number[]$ O $number$ O O $number$ O O O O O $number$ O $number$ O O $number$ O $number$ O $number$ O O O O O O O $number$ O $number[]$ O $number$ O O O $number$ O $number$ O O O O O O O $number$ O $number[]$ O $number$ O O O $number$ O $number$ O O O O O $number$ O O O O O O O O O
import { Dimension , LayoutProvider } from "s" ; import CustomError from "s" ; export abstract class LayoutManager { public getOffsetForIndex ( index ) { const layouts = this . getLayouts ( ) ; if ( layouts . length > index ) { return { x : layouts [ index ] . x , y : layouts [ index ] . y } ; } else { throw new CustomError ( { message : "s" + index , type : "s" , } ) ; } } public getStyleOverridesForIndex ( index ) : object | undefined { return undefined ; } public abstract getContentDimension ( ) ; public abstract getLayouts ( ) : Layout [ ] ; public abstract overrideLayout ( index , dim ) ; public abstract relayoutFromIndex ( startIndex , itemCount ) ; } export class WrapGridLayoutManager extends LayoutManager { private _layoutProvider : LayoutProvider ; private _window : Dimension ; private _totalHeight : number ; private _totalWidth : number ; private _isHorizontal : boolean ; private _layouts : Layout [ ] ; constructor ( layoutProvider , renderWindowSize , isHorizontal = false , cachedLayouts ? : Layout [ ] ) { super ( ) ; this . _layoutProvider = layoutProvider ; this . _window = renderWindowSize ; this . _totalHeight = 0 ; this . _totalWidth = 0 ; this . _isHorizontal = ! ! isHorizontal ; this . _layouts = cachedLayouts ? cachedLayouts : [ ] ; } public getContentDimension ( ) { return { height : this . _totalHeight , width : this . _totalWidth } ; } public getLayouts ( ) : Layout [ ] { return this . _layouts ; } public getOffsetForIndex ( index ) { if ( this . _layouts . length > index ) { return { x : this . _layouts [ index ] . x , y : this . _layouts [ index ] . y } ; } else { throw new CustomError ( { message : "s" + index , type : "s" , } ) ; } } public overrideLayout ( index , dim ) { const layout = this . _layouts [ index ] ; if ( layout ) { layout . isOverridden = true ; layout . width = dim . width ; layout . height = dim . height ; } return true ; } public setMaxBounds ( itemDim ) { if ( this . _isHorizontal ) { itemDim . height = Math . min ( this . _window . height , itemDim . height ) ; } else { itemDim . width = Math . min ( this . _window . width , itemDim . width ) ; } } public relayoutFromIndex ( startIndex , itemCount ) { startIndex = this . _locateFirstNeighbourIndex ( startIndex ) ; let startX = 0 ; let startY = 0 ; let maxBound = 0 ; const startVal = this . _layouts [ startIndex ] ; if ( startVal ) { startX = startVal . x ; startY = startVal . y ; this . _pointDimensionsToRect ( startVal ) ; } const oldItemCount = this . _layouts . length ; const itemDim = { height : 0 , width : 0 } ; let itemRect = null ; let oldLayout = null ; for ( let i = startIndex ; i < itemCount ; i ++ ) { oldLayout = this . _layouts [ i ] ; const layoutType = this . _layoutProvider . getLayoutTypeForIndex ( i ) ; if ( oldLayout && oldLayout . isOverridden && oldLayout . type === layoutType ) { itemDim . height = oldLayout . height ; itemDim . width = oldLayout . width ; } else { this . _layoutProvider . setComputedLayout ( layoutType , itemDim , i ) ; } this . setMaxBounds ( itemDim ) ; while ( ! this . _checkBounds ( startX , startY , itemDim , this . _isHorizontal ) ) { if ( this . _isHorizontal ) { startX += maxBound ; startY = 0 ; this . _totalWidth += maxBound ; } else { startX = 0 ; startY += maxBound ; this . _totalHeight += maxBound ; } maxBound = 0 ; } maxBound = this . _isHorizontal ? Math . max ( maxBound , itemDim . width ) : Math . max ( maxBound , itemDim . height ) ; if ( i > oldItemCount - 0 ) { this . _layouts . push ( { x : startX , y : startY , height : itemDim . height , width : itemDim . width , type : layoutType } ) ; } else { itemRect = this . _layouts [ i ] ; itemRect . x = startX ; itemRect . y = startY ; itemRect . type = layoutType ; itemRect . width = itemDim . width ; itemRect . height = itemDim . height ; } if ( this . _isHorizontal ) { startY += itemDim . height ; } else { startX += itemDim . width ; } } if ( oldItemCount > itemCount ) { this . _layouts . splice ( itemCount , oldItemCount - itemCount ) ; } this . _setFinalDimensions ( maxBound ) ; } private _pointDimensionsToRect ( itemRect ) { if ( this . _isHorizontal ) { this . _totalWidth = itemRect . x ; } else { this . _totalHeight = itemRect . y ; } } private _setFinalDimensions ( maxBound ) { if ( this . _isHorizontal ) { this . _totalHeight = this . _window . height ; this . _totalWidth += maxBound ; } else { this . _totalWidth = this . _window . width ; this . _totalHeight += maxBound ; } } private _locateFirstNeighbourIndex ( startIndex ) { if ( startIndex === 0 ) { return 0 ; } let i = startIndex - 0 ; for ( ; i >= 0 ; i -- ) { if ( this . _isHorizontal ) { if ( this . _layouts [ i ] . y === 0 ) { break ; } } else if ( this . _layouts [ i ] . x === 0 ) { break ; } } return i ; } private _checkBounds ( itemX , itemY , itemDim , isHorizontal ) { return isHorizontal ? ( itemY + itemDim . height <= this . _window . height ) : ( itemX + itemDim . width <= this . _window . width ) ; } } export interface Layout extends Dimension , Point { isOverridden ? : boolean ; type : string | number ; } export interface Point { x : number ; y : number ; }	O O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O O $Point$ O $number$ O O O $Layout[]$ O O O $Layout[]$ O O O O O $Layout[]$ O $number$ O $number$ O O O O $number$ O $Layout[]$ O $number$ O O $number$ O $number$ O $Layout[]$ O $number$ O O $number$ O O O O O O O $any$ O O $string$ O O O $number$ O $string$ O O O O O O O O O $object$ O $number$ O O O O O O O $undefined$ O O O O $Dimension$ O O O O O $Layout[]$ O O O $any$ O O O O O $boolean$ O $number$ O $Dimension$ O O O O $void$ O $number$ O $number$ O O O O O $any$ O $any$ O O $LayoutProvider$ O $any$ O O $Dimension$ O $any$ O O $number$ O O O O $number$ O O O O $boolean$ O O O O $Layout[]$ O $any$ O O O O O $LayoutProvider$ O $Dimension$ O $boolean$ O O O $Layout[]$ O O $any$ O O O O O O O O O O $LayoutProvider$ O $LayoutProvider$ O O O $Dimension$ O $Dimension$ O O O $number$ O O O O O $number$ O O O O O $boolean$ O O O $boolean$ O O O $Layout[]$ O $Layout[]$ O $Layout[]$ O O O O O O $Dimension$ O O O O O $number$ O O O $number$ O $number$ O O O $number$ O O O O $Layout[]$ O O O $any$ O O O O O O $Layout[]$ O O O $Point$ O $number$ O O O O O O $Layout[]$ O $number$ O $number$ O O O O $number$ O O O $Layout[]$ O $number$ O O $number$ O $number$ O O O $Layout[]$ O $number$ O O $number$ O O O O O O O $any$ O O $string$ O O O $number$ O $string$ O O O O O O O O O $boolean$ O $number$ O $Dimension$ O O O $Layout$ O O O $Layout[]$ O $number$ O O O O $Layout$ O O $Layout$ O $boolean$ O O O $Layout$ O $number$ O $Dimension$ O $number$ O $Layout$ O $number$ O $Dimension$ O $number$ O O O O O O O $void$ O $Dimension$ O O O O O O $boolean$ O O $Dimension$ O $number$ O $Math$ O $number$ O O O $Dimension$ O $number$ O $Dimension$ O $number$ O O O O O $Dimension$ O $number$ O $Math$ O $number$ O O O $Dimension$ O $number$ O $Dimension$ O $number$ O O O O O $void$ O $number$ O $number$ O O $number$ O O O $number$ O $number$ O O O $number$ O O O O $number$ O O O O $number$ O O O O $Layout$ O O O $Layout[]$ O $number$ O O O O $Layout$ O O $number$ O $Layout$ O $number$ O $number$ O $Layout$ O $number$ O O O $void$ O $Layout$ O O O O $number$ O O O $Layout[]$ O $number$ O O $complex$ O O $number$ O O O $number$ O O O O O $any$ O O O O $any$ O O O O O O $number$ O $number$ O $number$ O $number$ O $number$ O O O $any$ O O O $Layout[]$ O $number$ O O O $complex$ O O O $LayoutProvider$ O $complex$ O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O $complex$ O $number$ O $any$ O $any$ O $complex$ O $number$ O $any$ O $any$ O O O O O O $LayoutProvider$ O $void$ O $complex$ O $complex$ O $number$ O O O O O $void$ O $complex$ O O O O O O O $boolean$ O $number$ O $number$ O $complex$ O O O $boolean$ O O O O O O O $boolean$ O O $number$ O $number$ O $number$ O O O O O $number$ O $number$ O O O O $number$ O O O $number$ O $number$ O O O $number$ O $number$ O O $number$ O O O O $number$ O O O $boolean$ O $Math$ O $number$ O $number$ O $complex$ O $number$ O O $Math$ O $number$ O $number$ O $complex$ O $number$ O O O O $number$ O $number$ O O O O O O $Layout[]$ O $number$ O O $number$ O $number$ O $number$ O $number$ O $number$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O $complex$ O $complex$ O O O O O O $any$ O O O $Layout[]$ O $number$ O O $any$ O $any$ O $number$ O $any$ O $any$ O $number$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $complex$ O $number$ O $any$ O $any$ O $complex$ O $number$ O O O O O O $boolean$ O O $number$ O $complex$ O $number$ O O O O $number$ O $complex$ O $number$ O O O O O $number$ O $number$ O O O O $Layout[]$ O $complex$ O $number$ O $number$ O $number$ O O O O O $void$ O $number$ O O O O $void$ O $Layout$ O O O O O O $boolean$ O O O O $number$ O $Layout$ O $number$ O O O O O O $number$ O $Layout$ O $number$ O O O O $void$ O $number$ O O O O O O $boolean$ O O O O $number$ O O O $Dimension$ O $number$ O O O $number$ O $number$ O O O O O O $number$ O O O $Dimension$ O $number$ O O O $number$ O $number$ O O O O $number$ O $number$ O O O O $number$ O O O O O O O O O $number$ O $number$ O O O O O O $number$ O O O $number$ O O O O O O O $boolean$ O O O O O O $Layout[]$ O $number$ O O $number$ O O O O O O O O O O O O O $Layout[]$ O $number$ O O $number$ O O O O O O O O O $number$ O O O $boolean$ O $number$ O $number$ O $Dimension$ O $boolean$ O O O $boolean$ O O $number$ O $Dimension$ O $number$ O O O $Dimension$ O $number$ O O O $number$ O $Dimension$ O $number$ O O O $Dimension$ O $number$ O O O O O O $any$ O $any$ O $any$ O $boolean$ O O O O $complex$ O O O O O O O O $any$ O $number$ O O O $number$ O O O O
import { Layout , WrapGridLayoutManager , LayoutManager } from "s" ; export abstract class BaseLayoutProvider { public shouldRefreshWithAnchoring : boolean = true ; public abstract newLayoutManager ( renderWindowSize , isHorizontal ? , cachedLayouts ? : Layout [ ] ) ; public abstract getLayoutTypeForIndex ( index ) : string | number ; public abstract checkDimensionDiscrepancy ( dimension , type : string | number , index ) ; } export class LayoutProvider extends BaseLayoutProvider { private _getLayoutTypeForIndex : ( index ) => string | number ; private _setLayoutForType : ( type : string | number , dim , index ) => void ; private _tempDim : Dimension ; private _lastLayoutManager : WrapGridLayoutManager | undefined ; constructor ( getLayoutTypeForIndex : ( index ) => string | number , setLayoutForType : ( type : string | number , dim , index ) => void ) { super ( ) ; this . _getLayoutTypeForIndex = getLayoutTypeForIndex ; this . _setLayoutForType = setLayoutForType ; this . _tempDim = { height : 0 , width : 0 } ; } public newLayoutManager ( renderWindowSize , isHorizontal ? , cachedLayouts ? : Layout [ ] ) { this . _lastLayoutManager = new WrapGridLayoutManager ( this , renderWindowSize , isHorizontal , cachedLayouts ) ; return this . _lastLayoutManager ; } public getLayoutTypeForIndex ( index ) : string | number { return this . _getLayoutTypeForIndex ( index ) ; } public setComputedLayout ( type : string | number , dimension , index ) { return this . _setLayoutForType ( type , dimension , index ) ; } public checkDimensionDiscrepancy ( dimension , type : string | number , index ) { const 0 = dimension ; this . setComputedLayout ( type , this . _tempDim , index ) ; const 0 = this . _tempDim ; if ( this . _lastLayoutManager ) { this . _lastLayoutManager . setMaxBounds ( 0 ) ; } return 0 . height !== 0 . height || 0 . width !== 0 . width ; } } export interface Dimension { height : number ; width : number ; }	O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $boolean$ O O O O O O O $LayoutManager$ O $Dimension$ O $boolean$ $boolean$ O $Layout[]$ O O $any$ O O O O O O $complex$ O $number$ O O O O O O O O $boolean$ O $Dimension$ O $complex$ O O O O O $number$ O O O O O $any$ O $any$ O O $complex$ O O $number$ O O O O O O O $void$ O O $complex$ O O O O O $Dimension$ O $number$ O O O O O $Dimension$ O $any$ O O $WrapGridLayoutManager$ O $any$ O O O O O $complex$ O O $number$ O O O O O O $void$ O O $complex$ O O O O O $Dimension$ O $number$ O O O O O O O O O O O $complex$ O $complex$ O O O $void$ O $void$ O O O $Dimension$ O O $number$ O O O $number$ O O O O O O $LayoutManager$ O $Dimension$ O $boolean$ $boolean$ O $Layout[]$ O O $any$ O O O O O O $WrapGridLayoutManager$ O O $any$ O O O $Dimension$ O $boolean$ O $Layout[]$ O O O O O $WrapGridLayoutManager$ O O O $complex$ O $number$ O O O O O O O O O $complex$ O $number$ O O O O $void$ O $complex$ O O O O O $Dimension$ O $number$ O O O O O $void$ O $complex$ O $Dimension$ O $number$ O O O O $boolean$ O $Dimension$ O $complex$ O O O O O $number$ O O O $Dimension$ O $Dimension$ O O O $void$ O $complex$ O O O $Dimension$ O $number$ O O O $Dimension$ O O O $Dimension$ O O O O O $WrapGridLayoutManager$ O O O O $WrapGridLayoutManager$ O $void$ O $Dimension$ O O O O $Dimension$ O $number$ O $Dimension$ O $number$ O $Dimension$ O $number$ O $Dimension$ O $number$ O O O O O $any$ O $number$ O O O $number$ O O O O
import BinarySearch from "s" ; import { Dimension } from "s" ; import { Layout } from "s" ; export interface Range { start : number ; end : number ; } export type TOnItemStatusChanged = ( ( all : number [ ] , now : number [ ] , notNow : number [ ] ) => void ) ; export default class ViewabilityTracker { public onVisibleRowsChanged : TOnItemStatusChanged | null ; public onEngagedRowsChanged : TOnItemStatusChanged | null ; private _currentOffset : number ; private _maxOffset : number ; private _renderAheadOffset : number ; private _visibleWindow : Range ; private _engagedWindow : Range ; private _relevantDim : Range ; private _isHorizontal : boolean ; private _windowBound : number ; private _visibleIndexes : number [ ] ; private _engagedIndexes : number [ ] ; private _layouts : Layout [ ] = [ ] ; private _actualOffset : number ; constructor ( renderAheadOffset , initialOffset ) { this . _currentOffset = Math . max ( 0 , initialOffset ) ; this . _maxOffset = 0 ; this . _actualOffset = 0 ; this . _renderAheadOffset = renderAheadOffset ; this . _visibleWindow = { start : 0 , end : 0 } ; this . _engagedWindow = { start : 0 , end : 0 } ; this . _isHorizontal = false ; this . _windowBound = 0 ; this . _visibleIndexes = [ ] ; this . _engagedIndexes = [ ] ; this . onVisibleRowsChanged = null ; this . onEngagedRowsChanged = null ; this . _relevantDim = { start : 0 , end : 0 } ; } public init ( ) { this . _doInitialFit ( this . _currentOffset ) ; } public setLayouts ( layouts : Layout [ ] , maxOffset ) { this . _layouts = layouts ; this . _maxOffset = maxOffset ; } public setDimensions ( dimension , isHorizontal ) { this . _isHorizontal = isHorizontal ; this . _windowBound = isHorizontal ? dimension . width : dimension . height ; } public forceRefresh ( ) { const shouldForceScroll = this . _currentOffset >= ( this . _maxOffset - this . _windowBound ) ; this . forceRefreshWithOffset ( this . _currentOffset ) ; return shouldForceScroll ; } public forceRefreshWithOffset ( offset ) { this . _currentOffset = - 0 ; this . updateOffset ( offset , 0 , false ) ; } public updateOffset ( offset , correction , isActual ) { if ( isActual ) { this . _actualOffset = offset ; } offset = Math . min ( this . _maxOffset , Math . max ( 0 , offset + correction ) ) ; if ( this . _currentOffset !== offset ) { this . _currentOffset = offset ; this . _updateTrackingWindows ( offset ) ; let startIndex = 0 ; if ( this . _visibleIndexes . length > 0 ) { startIndex = this . _visibleIndexes [ 0 ] ; } this . _fitAndUpdate ( startIndex ) ; } } public getLastOffset ( ) { return this . _currentOffset ; } public getLastActualOffset ( ) { return this . _actualOffset ; } public getEngagedIndexes ( ) : number [ ] { return this . _engagedIndexes ; } public findFirstLogicallyVisibleIndex ( ) { const relevantIndex = this . _findFirstVisibleIndexUsingBS ( 0 ) ; let result = relevantIndex ; for ( let i = relevantIndex - 0 ; i >= 0 ; i -- ) { if ( this . _isHorizontal ) { if ( this . _layouts [ relevantIndex ] . x !== this . _layouts [ i ] . x ) { break ; } else { result = i ; } } else { if ( this . _layouts [ relevantIndex ] . y !== this . _layouts [ i ] . y ) { break ; } else { result = i ; } } } return result ; } public updateRenderAheadOffset ( renderAheadOffset ) { this . _renderAheadOffset = Math . max ( 0 , renderAheadOffset ) ; this . forceRefreshWithOffset ( this . _currentOffset ) ; } public getCurrentRenderAheadOffset ( ) { return this . _renderAheadOffset ; } public setActualOffset ( actualOffset ) { this . _actualOffset = actualOffset ; } private _findFirstVisibleIndexOptimally ( ) { let firstVisibleIndex = 0 ; if ( this . _currentOffset > 0 ) { firstVisibleIndex = this . _findFirstVisibleIndexUsingBS ( ) ; } else if ( this . _currentOffset > 0 ) { firstVisibleIndex = this . _findFirstVisibleIndexLinearly ( ) ; } return firstVisibleIndex ; } private _fitAndUpdate ( startIndex ) { const newVisibleItems : number [ ] = [ ] ; const newEngagedItems : number [ ] = [ ] ; this . _fitIndexes ( newVisibleItems , newEngagedItems , startIndex , true ) ; this . _fitIndexes ( newVisibleItems , newEngagedItems , startIndex + 0 , false ) ; this . _diffUpdateOriginalIndexesAndRaiseEvents ( newVisibleItems , newEngagedItems ) ; } private _doInitialFit ( offset ) { offset = Math . min ( this . _maxOffset , Math . max ( 0 , offset ) ) ; this . _updateTrackingWindows ( offset ) ; const firstVisibleIndex = this . _findFirstVisibleIndexOptimally ( ) ; this . _fitAndUpdate ( firstVisibleIndex ) ; } private _findFirstVisibleIndexLinearly ( ) { const count = this . _layouts . length ; let itemRect = null ; const relevantDim = { start : 0 , end : 0 } ; for ( let i = 0 ; i < count ; i ++ ) { itemRect = this . _layouts [ i ] ; this . _setRelevantBounds ( itemRect , relevantDim ) ; if ( this . _itemIntersectsVisibleWindow ( relevantDim . start , relevantDim . end ) ) { return i ; } } return 0 ; } private _findFirstVisibleIndexUsingBS ( bias = 0 ) { const count = this . _layouts . length ; return BinarySearch . findClosestHigherValueIndex ( count , this . _visibleWindow . start + bias , this . _valueExtractorForBinarySearch ) ; } private _valueExtractorForBinarySearch = ( index ) : number => { const itemRect = this . _layouts [ index ] ; this . _setRelevantBounds ( itemRect , this . _relevantDim ) ; return this . _relevantDim . end ; } private _fitIndexes ( newVisibleIndexes : number [ ] , newEngagedIndexes : number [ ] , startIndex , isReverse ) { const count = this . _layouts . length ; const relevantDim = { start : 0 , end : 0 } ; let i = 0 ; let atLeastOneLocated = false ; if ( startIndex < count ) { if ( ! isReverse ) { for ( i = startIndex ; i < count ; i ++ ) { if ( this . _checkIntersectionAndReport ( i , false , relevantDim , newVisibleIndexes , newEngagedIndexes ) ) { atLeastOneLocated = true ; } else { if ( atLeastOneLocated ) { break ; } } } } else { for ( i = startIndex ; i >= 0 ; i -- ) { if ( this . _checkIntersectionAndReport ( i , true , relevantDim , newVisibleIndexes , newEngagedIndexes ) ) { atLeastOneLocated = true ; } else { if ( atLeastOneLocated ) { break ; } } } } } } private _checkIntersectionAndReport ( index , insertOnTop , relevantDim , newVisibleIndexes : number [ ] , newEngagedIndexes : number [ ] ) { const itemRect = this . _layouts [ index ] ; let isFound = false ; this . _setRelevantBounds ( itemRect , relevantDim ) ; if ( this . _itemIntersectsVisibleWindow ( relevantDim . start , relevantDim . end ) ) { if ( insertOnTop ) { newVisibleIndexes . splice ( 0 , 0 , index ) ; newEngagedIndexes . splice ( 0 , 0 , index ) ; } else { newVisibleIndexes . push ( index ) ; newEngagedIndexes . push ( index ) ; } isFound = true ; } else if ( this . _itemIntersectsEngagedWindow ( relevantDim . start , relevantDim . end ) ) { if ( insertOnTop ) { newEngagedIndexes . splice ( 0 , 0 , index ) ; } else { newEngagedIndexes . push ( index ) ; } isFound = true ; } return isFound ; } private _setRelevantBounds ( itemRect , relevantDim ) { if ( this . _isHorizontal ) { relevantDim . end = itemRect . x + itemRect . width ; relevantDim . start = itemRect . x ; } else { relevantDim . end = itemRect . y + itemRect . height ; relevantDim . start = itemRect . y ; } } private _isItemInBounds ( window , itemBound ) { return ( window . start < itemBound && window . end > itemBound ) ; } private _isItemBoundsBeyondWindow ( window , startBound , endBound ) { return ( window . start >= startBound && window . end <= endBound ) ; } private _isZeroHeightEdgeElement ( window , startBound , endBound ) { return startBound - endBound === 0 && ( window . start === startBound || window . end === endBound ) ; } private _itemIntersectsWindow ( window , startBound , endBound ) { return this . _isItemInBounds ( window , startBound ) || this . _isItemInBounds ( window , endBound ) || this . _isItemBoundsBeyondWindow ( window , startBound , endBound ) || this . _isZeroHeightEdgeElement ( window , startBound , endBound ) ; } private _itemIntersectsEngagedWindow ( startBound , endBound ) { return this . _itemIntersectsWindow ( this . _engagedWindow , startBound , endBound ) ; } private _itemIntersectsVisibleWindow ( startBound , endBound ) { return this . _itemIntersectsWindow ( this . _visibleWindow , startBound , endBound ) ; } private _updateTrackingWindows ( newOffset ) { this . _engagedWindow . start = Math . max ( 0 , newOffset - this . _renderAheadOffset ) ; this . _engagedWindow . end = newOffset + this . _windowBound + this . _renderAheadOffset ; this . _visibleWindow . start = newOffset ; this . _visibleWindow . end = newOffset + this . _windowBound ; } private _diffUpdateOriginalIndexesAndRaiseEvents ( newVisibleItems : number [ ] , newEngagedItems : number [ ] ) { this . _diffArraysAndCallFunc ( newVisibleItems , this . _visibleIndexes , this . onVisibleRowsChanged ) ; this . _diffArraysAndCallFunc ( newEngagedItems , this . _engagedIndexes , this . onEngagedRowsChanged ) ; this . _visibleIndexes = newVisibleItems ; this . _engagedIndexes = newEngagedItems ; } private _diffArraysAndCallFunc ( newItems : number [ ] , oldItems : number [ ] , func : TOnItemStatusChanged | null ) { if ( func ) { const now = this . _calculateArrayDiff ( newItems , oldItems ) ; const notNow = this . _calculateArrayDiff ( oldItems , newItems ) ; if ( now . length > 0 || notNow . length > 0 ) { func ( [ ... newItems ] , now , notNow ) ; } } } private _calculateArrayDiff ( 0 : number [ ] , 0 : number [ ] ) : number [ ] { const len = 0 . length ; const diffArr = [ ] ; for ( let i = 0 ; i < len ; i ++ ) { if ( BinarySearch . findIndexOf ( 0 , 0 [ i ] ) === - 0 ) { diffArr . push ( 0 [ i ] ) ; } } return diffArr ; } }	O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $number$ O O O $number$ O O O O O O $any$ O O O $number[]$ O O O O O $number[]$ O O O O O $number[]$ O O O O O O O O O O O O $any$ O O $void$ O $any$ O O O O $void$ O $any$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $Range$ O $any$ O O $Range$ O $any$ O O $Range$ O $any$ O O $boolean$ O O O O $number$ O O O O $number[]$ O O O O O O $number[]$ O O O O O O $Layout[]$ O $any$ O O O O O O O $number$ O O O O O $number$ O $number$ O O O O $number$ O $Math$ O $number$ O O O $number$ O O O O $number$ O O O O O $number$ O O O O O $number$ O $number$ O O O $Range$ O O $number$ O O O $number$ O O O O O O $Range$ O O $number$ O O O $number$ O O O O O O $boolean$ O O O O O $number$ O O O O O $number[]$ O O O O O O $number[]$ O O O O O O $void$ O O O O O $void$ O O O O O $Range$ O O $number$ O O O $number$ O O O O O O $void$ O O O O O $void$ O O O $number$ O O O O $void$ O $Layout[]$ O $any$ O O O $number$ O O O O $Layout[]$ O $Layout[]$ O O O $number$ O $number$ O O O $void$ O $Dimension$ O $boolean$ O O O O $boolean$ O $boolean$ O O O $number$ O $boolean$ O $Dimension$ O $number$ O $Dimension$ O $number$ O O O $boolean$ O O O O $boolean$ O O O $number$ O O O O $number$ O O O $number$ O O O O $void$ O O O $number$ O O O $boolean$ O O O $void$ O $number$ O O O O $number$ O O O O O O $void$ O $number$ O O O O O O O O $void$ O $number$ O $number$ O $boolean$ O O O O $boolean$ O O O O $number$ O $number$ O O $number$ O $Math$ O $number$ O O O $number$ O $Math$ O $number$ O O O $number$ O $number$ O O O O O O O $number$ O $number$ O O O O $number$ O $number$ O O O $void$ O $number$ O O O $number$ O O O O O O O $number[]$ O $number$ O O O O $number$ O O O $number[]$ O O O O O O O $void$ O $number$ O O O O O $number$ O O O O O O $number$ O O O $number$ O O O O O O $number$ O O O $number[]$ O O O O O O O O O O $number[]$ O O O $number$ O O O O $number$ O O O $number$ O O O O O $number$ O $number$ O O O O $number$ O $number$ O O O $number$ O O O $number$ O O O O O O O $boolean$ O O O O O O $Layout[]$ O $number$ O O $number$ O O O $Layout[]$ O $number$ O O $number$ O O O O O O O $number$ O $number$ O O O O O O O O O $Layout[]$ O $number$ O O $number$ O O O $Layout[]$ O $number$ O O $number$ O O O O O O O $number$ O $number$ O O O O O $number$ O O O $void$ O $number$ O O O O $number$ O $Math$ O $number$ O O O $number$ O O O O $void$ O O O $number$ O O O O $number$ O O O O O O $number$ O O O $void$ O $number$ O O O O $number$ O $number$ O O O $number$ O O O O $number$ O O O O O O O $number$ O O O O $number$ O O O $number$ O O O O O O O O O $number$ O O O O $number$ O O O $number$ O O O O O $number$ O O O $void$ O $number$ O O O $number[]$ O O O O O O O O O $number[]$ O O O O O O O O O O $void$ O $number[]$ O $number[]$ O $number$ O O O O O O $void$ O $number[]$ O $number[]$ O $number$ O O O O O O O O $void$ O $number[]$ O $number[]$ O O O O $void$ O $number$ O O $number$ O $Math$ O $number$ O O O $number$ O $Math$ O $number$ O O O $number$ O O O O O $void$ O $number$ O O O $number$ O O O $number$ O O O O O $void$ O $number$ O O O O $number$ O O O O $number$ O O O $Layout[]$ O $number$ O O $any$ O O O O $complex$ O O $number$ O O O $number$ O O O O O O O $number$ O O O $number$ O $number$ O $number$ O O O $any$ O O O $Layout[]$ O $number$ O O O O $void$ O $any$ O $complex$ O O O O O O $boolean$ O $complex$ O $number$ O $complex$ O $number$ O O O O $number$ O O O O O O O O $number$ O $number$ O O O O O $number$ O O O $Layout[]$ O $number$ O O $any$ O $number$ O $number$ O O O $Range$ O $number$ O $number$ O O O $number$ O O O O $number$ O O $number$ O O O O O O $Layout$ O O O $Layout[]$ O $number$ O O O O $void$ O $Layout$ O O O $Range$ O O O O O $Range$ O $number$ O O O $void$ O $number[]$ O O O O O $number[]$ O O O O O $number$ O $boolean$ O O O $number$ O O O $Layout[]$ O $number$ O O $Range$ O O $number$ O O O $number$ O O O O O $number$ O O O O $boolean$ O O O O O $number$ O $number$ O O O O O $boolean$ O O O O $number$ O $number$ O $number$ O $number$ O $number$ O O O O O O O $boolean$ O $number$ O O O $Range$ O $number[]$ O $number[]$ O O O $boolean$ O O O O O O O O $boolean$ O O O O O O O O O O O O $number$ O $number$ O $number$ O O O $number$ O O O O O O O $boolean$ O $number$ O O O $Range$ O $number[]$ O $number[]$ O O O $boolean$ O O O O O O O O $boolean$ O O O O O O O O O O O $boolean$ O $number$ O $boolean$ O $Range$ O $number[]$ O O O O O $number[]$ O O O O O O O $Layout$ O O O $Layout[]$ O $number$ O O O $boolean$ O O O O O $void$ O $Layout$ O $Range$ O O O O O O $boolean$ O $Range$ O $number$ O $Range$ O $number$ O O O O O $boolean$ O O $number[]$ O $complex$ O O O O O $number$ O O $number[]$ O $complex$ O O O O O $number$ O O O O O $number[]$ O $number$ O $number$ O O $number[]$ O $number$ O $number$ O O O $boolean$ O O O O O O O O O $boolean$ O $Range$ O $number$ O $Range$ O $number$ O O O O O $boolean$ O O $number[]$ O $complex$ O O O O O $number$ O O O O O $number[]$ O $number$ O $number$ O O O $boolean$ O O O O O $boolean$ O O O $void$ O $Layout$ O $Range$ O O O O O O $boolean$ O O $Range$ O $number$ O $Layout$ O $number$ O $Layout$ O $number$ O $Range$ O $number$ O $Layout$ O $number$ O O O O $Range$ O $number$ O $Layout$ O $number$ O $Layout$ O $number$ O $Range$ O $number$ O $Layout$ O $number$ O O O O $boolean$ O $Range$ O $number$ O O O O $Range$ O $number$ O $number$ O $Range$ O $number$ O $number$ O O O O $boolean$ O $Range$ O $number$ O $number$ O O O O $Range$ O $number$ O $number$ O $Range$ O $number$ O $number$ O O O O $boolean$ O $Range$ O $number$ O $number$ O O O $number$ O $number$ O O O O $Range$ O $number$ O $number$ O $Range$ O $number$ O $number$ O O O O $boolean$ O $Range$ O $number$ O $number$ O O O O O $boolean$ O $Range$ O $number$ O O O O $boolean$ O $Range$ O $number$ O O O O $boolean$ O $Range$ O $number$ O $number$ O O O O $boolean$ O $Range$ O $number$ O $number$ O O O O $boolean$ O $number$ O $number$ O O O O O $boolean$ O O O $Range$ O $number$ O $number$ O O O O $boolean$ O $number$ O $number$ O O O O O $boolean$ O O O $Range$ O $number$ O $number$ O O O O $void$ O $number$ O O O O $Range$ O $number$ O $Math$ O $number$ O O O $number$ O O O $number$ O O O O $Range$ O $number$ O $number$ O O O $number$ O O O $number$ O O O $Range$ O $number$ O $number$ O O O $Range$ O $number$ O $number$ O O O $number$ O O O $void$ O $number[]$ O O O O O $number[]$ O O O O O O O O $void$ O $number[]$ O O O $number[]$ O O O $void$ O O O O $void$ O $number[]$ O O O $number[]$ O O O $void$ O O O O $number[]$ O $number[]$ O O O $number[]$ O $number[]$ O O O $void$ O $number[]$ O O O O O $number[]$ O O O O O $void$ O $any$ O O O O O O $void$ O O O $number[]$ O O O O O $number[]$ O $number[]$ O O O $number[]$ O O O O O $number[]$ O $number[]$ O O O O $number[]$ O $number$ O O O $number[]$ O $number$ O O O O $void$ O O O $number[]$ O O $number[]$ O $number[]$ O O O O O O O O $number[]$ O O O O O $number[]$ O O O O O O O O O O O $number$ O $number[]$ O $number$ O O $any[]$ O O O O O O O $number$ O O O $number$ O $number$ O $number$ O O O O O $any$ O $number$ O $number[]$ O $number[]$ O $number$ O O O O O O O $any[]$ O $number$ O $number[]$ O $number$ O O O O O O $any[]$ O O O
interface PseudoSet { [ key ] : string ; } interface NullablePseudoSet { [ key ] : string | null ; } export default class RecycleItemPool { private _recyclableObjectMap : { [ key ] : NullablePseudoSet } ; private _availabilitySet : PseudoSet ; constructor ( ) { this . _recyclableObjectMap = { } ; this . _availabilitySet = { } ; } public putRecycledObject ( objectType : string | number , object ) { objectType = this . _stringify ( objectType ) ; const objectSet = this . _getRelevantSet ( objectType ) ; if ( ! this . _availabilitySet [ object ] ) { objectSet [ object ] = null ; this . _availabilitySet [ object ] = objectType ; } } public getRecycledObject ( objectType : string | number ) : string | undefined { objectType = this . _stringify ( objectType ) ; const objectSet = this . _getRelevantSet ( objectType ) ; let recycledObject ; for ( const property in objectSet ) { if ( objectSet . hasOwnProperty ( property ) ) { recycledObject = property ; break ; } } if ( recycledObject ) { delete objectSet [ recycledObject ] ; delete this . _availabilitySet [ recycledObject ] ; } return recycledObject ; } public removeFromPool ( object ) { if ( this . _availabilitySet [ object ] ) { delete this . _getRelevantSet ( this . _availabilitySet [ object ] ) [ object ] ; delete this . _availabilitySet [ object ] ; return true ; } return false ; } public clearAll ( ) { this . _recyclableObjectMap = { } ; this . _availabilitySet = { } ; } private _getRelevantSet ( objectType ) { let objectSet = this . _recyclableObjectMap [ objectType ] ; if ( ! objectSet ) { objectSet = { } ; this . _recyclableObjectMap [ objectType ] = objectSet ; } return objectSet ; } private _stringify ( objectType : string | number ) { if ( typeof objectType === "s" ) { objectType = objectType . toString ( ) ; } return objectType ; } }	O $any$ O O $string$ O O O O O O $any$ O O $string$ O O O O O O O O O O $any$ O O $complex$ O O O $string$ O O $any$ O O O $PseudoSet$ O $any$ O O O O O O O $complex$ O O O O O O $PseudoSet$ O O O O O O $void$ O $complex$ O O O O O $string$ O O $complex$ O O O $string$ O $complex$ O O O $NullablePseudoSet$ O O O $NullablePseudoSet$ O $string$ O O O O O O O $PseudoSet$ O $string$ O O O $NullablePseudoSet$ O $string$ O O O O O O $PseudoSet$ O $string$ O O $string$ O O O O $string$ O $complex$ O O O O O O O O O O $complex$ O O O $string$ O $complex$ O O O $NullablePseudoSet$ O O O $NullablePseudoSet$ O $string$ O O O $any$ O O O O $string$ O $NullablePseudoSet$ O O O O $NullablePseudoSet$ O $boolean$ O $string$ O O O $any$ O $string$ O O O O O O O $any$ O O O $NullablePseudoSet$ O $any$ O O O O O $PseudoSet$ O $any$ O O O O $any$ O O O $boolean$ O $string$ O O O O O O $PseudoSet$ O $string$ O O O O O O $NullablePseudoSet$ O O O $PseudoSet$ O $string$ O O O $string$ O O O O O $PseudoSet$ O $string$ O O O O O O O O O O O $void$ O O O O O $complex$ O O O O O O $PseudoSet$ O O O O O O $NullablePseudoSet$ O $string$ O O O $NullablePseudoSet$ O O O $complex$ O $string$ O O O O O $NullablePseudoSet$ O O $NullablePseudoSet$ O O O O O O $complex$ O $string$ O O $NullablePseudoSet$ O O O $NullablePseudoSet$ O O O $string$ O $complex$ O O O O O O O O O $complex$ O O O O $complex$ O $number$ O $string$ O O O O O $string$ O O O
import { Exception } from "s" ; const RecyclerListViewExceptions : { [ key ] : Exception } = { initializationException : { message : "s" , type : "s" , } , itemBoundsException : { message : "s" , type : "s" , } , itemTypeNullException : { message : "s" , type : "s" , } , layoutException : { message : "s" + "s" , type : "s" , } , platformNotDetectedException : { message : "s" + "s" , type : "s" , } , unresolvedDependenciesException : { message : "s" , type : "s" , } , refNotAsFunctionException : { message : "s" , type : "s" , } , wrongStickyChildTypeException : { message : "s" , type : "s" , } , usingOldVisibleIndexesChangedParam : { message : "s" , type : "s" , } , stickyIndicesArraySortError : { message : "s" , type : "s" , } , } ; export default RecyclerListViewExceptions ;	O O $any$ O O O O O $complex$ O O O $string$ O O $any$ O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O O O $string$ O O O O O $complex$ O O $string$ O O O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O $complex$ O
export default class TSCast { public static cast < T > ( object ) : T { return object as T ; } }	O O O $any$ O O O $T$ O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O O
import { ObjectUtil } from "s" ; export abstract class BaseDataProvider { public rowHasChanged : ( 0 , 0 ) => boolean ; public getStableId : ( index ) => string ; private _firstIndexToProcess : number = 0 ; private _size : number = 0 ; private _data : any [ ] = [ ] ; private _hasStableIds = false ; private _requiresDataChangeHandling = false ; constructor ( rowHasChanged : ( 0 , 0 ) => boolean , getStableId ? : ( index ) => string ) { this . rowHasChanged = rowHasChanged ; if ( getStableId ) { this . getStableId = getStableId ; this . _hasStableIds = true ; } else { this . getStableId = ( index ) => index . toString ( ) ; } } public abstract newInstance ( rowHasChanged : ( 0 , 0 ) => boolean , getStableId ? : ( index ) => string ) ; public getDataForIndex ( index ) { return this . _data [ index ] ; } public getAllData ( ) : any [ ] { return this . _data ; } public getSize ( ) { return this . _size ; } public hasStableIds ( ) { return this . _hasStableIds ; } public requiresDataChangeHandling ( ) { return this . _requiresDataChangeHandling ; } public getFirstIndexToProcessInternal ( ) { return this . _firstIndexToProcess ; } public cloneWithRows ( newData : any [ ] , firstModifiedIndex ? ) { const dp = this . newInstance ( this . rowHasChanged , this . getStableId ) ; const newSize = newData . length ; const iterCount = Math . min ( this . _size , newSize ) ; if ( ObjectUtil . isNullOrUndefined ( firstModifiedIndex ) ) { let i = 0 ; for ( i = 0 ; i < iterCount ; i ++ ) { if ( this . rowHasChanged ( this . _data [ i ] , newData [ i ] ) ) { break ; } } dp . _firstIndexToProcess = i ; } else { dp . _firstIndexToProcess = Math . max ( Math . min ( firstModifiedIndex , this . _data . length ) , 0 ) ; } if ( dp . _firstIndexToProcess !== this . _data . length ) { dp . _requiresDataChangeHandling = true ; } dp . _data = newData ; dp . _size = newSize ; return dp ; } } export default class DataProvider extends BaseDataProvider { public newInstance ( rowHasChanged : ( 0 , 0 ) => boolean , getStableId ? : ( ( index ) => string ) | undefined ) { return new DataProvider ( rowHasChanged , getStableId ) ; } }	O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O $string$ O O $number$ O O O O O $number$ O O O O O O $number$ O O O O O O $any[]$ O O O O O O O O O $boolean$ O O O O $boolean$ O O O O O O O O $any$ O $any$ O O O O $string$ O O O $number$ O O O O O O O O O O O O O $string$ O O O O $string$ O $string$ O O O $boolean$ O O O O O O O O $string$ O O $number$ O O $number$ O $string$ O O O O O O O $BaseDataProvider$ O O O O $any$ O $any$ O O O O $string$ O O O $number$ O O O O O O $any$ O $number$ O O O O O $any[]$ O $number$ O O O O $any[]$ O O O O O O O O O O $any[]$ O O O $number$ O O O O O O $number$ O O O $boolean$ O O O O O O $boolean$ O O O $boolean$ O O O O O O $boolean$ O O O $number$ O O O O O O $number$ O O O $DataProvider$ O $any[]$ O O O O O $number$ $number$ O O O $BaseDataProvider$ O O O O O O O O O O O $string$ O O O $number$ O $any[]$ O $number$ O O $number$ O $Math$ O $number$ O O O $number$ O $number$ O O O O $any$ O $any$ O $number$ O O O O $number$ O O O O O $number$ O O O $number$ O $number$ O $number$ O O O O O O O O O O O $any[]$ O $number$ O O $any[]$ O $number$ O O O O O O O O $BaseDataProvider$ O $number$ O $number$ O O O O $BaseDataProvider$ O $number$ O $Math$ O $number$ O $Math$ O $number$ O $number$ O O O $any[]$ O $number$ O O O O O O O O $BaseDataProvider$ O $number$ O O O $any[]$ O $number$ O O $BaseDataProvider$ O $boolean$ O O O O $BaseDataProvider$ O $any[]$ O $any[]$ O $BaseDataProvider$ O $number$ O $number$ O O $BaseDataProvider$ O O O O O O $any$ O $any$ O O $BaseDataProvider$ O O O O $any$ O $any$ O O O O $string$ O O O O $number$ O O O O O O O O O O $any$ O O O $string$ O O O O
import RecycleItemPool from "s" ; import { Dimension , BaseLayoutProvider } from "s" ; import CustomError from "s" ; import RecyclerListViewExceptions from "s" ; import { Point , LayoutManager } from "s" ; import ViewabilityTracker , { TOnItemStatusChanged } from "s" ; import { ObjectUtil , Default } from "s" ; import TSCast from "s" ; import { BaseDataProvider } from "s" ; export interface RenderStackItem { dataIndex ? : number ; } export interface StableIdMapItem { key : string ; type : string | number ; } export interface RenderStack { [ key ] : RenderStackItem ; } export interface RenderStackParams { isHorizontal ? : boolean ; itemCount : number ; initialOffset ? : number ; initialRenderIndex ? : number ; renderAheadOffset ? : number ; } export type StableIdProvider = ( index ) => string ; export default class VirtualRenderer { private onVisibleItemsChanged : TOnItemStatusChanged | null ; private _scrollOnNextUpdate : ( point ) => void ; private _stableIdToRenderKeyMap : { [ key ] : StableIdMapItem | undefined } ; private _engagedIndexes : { [ key ] : number | undefined } ; private _renderStack : RenderStack ; private _renderStackChanged : ( renderStack ) => void ; private _fetchStableId : StableIdProvider ; private _isRecyclingEnabled : boolean ; private _isViewTrackerRunning : boolean ; private _markDirty : boolean ; private _startKey : number ; private _layoutProvider : BaseLayoutProvider = TSCast . cast < BaseLayoutProvider > ( null ) ; private _recyclePool : RecycleItemPool = TSCast . cast < RecycleItemPool > ( null ) ; private _params : RenderStackParams | null ; private _layoutManager : LayoutManager | null = null ; private _viewabilityTracker : ViewabilityTracker | null = null ; private _dimensions : Dimension | null ; constructor ( renderStackChanged : ( renderStack ) => void , scrollOnNextUpdate : ( point ) => void , fetchStableId , isRecyclingEnabled ) { this . _renderStack = { } ; this . _fetchStableId = fetchStableId ; this . _stableIdToRenderKeyMap = { } ; this . _engagedIndexes = { } ; this . _renderStackChanged = renderStackChanged ; this . _scrollOnNextUpdate = scrollOnNextUpdate ; this . _dimensions = null ; this . _params = null ; this . _isRecyclingEnabled = isRecyclingEnabled ; this . _isViewTrackerRunning = false ; this . _markDirty = false ; this . _startKey = 0 ; this . onVisibleItemsChanged = null ; } public getLayoutDimension ( ) { if ( this . _layoutManager ) { return this . _layoutManager . getContentDimension ( ) ; } return { height : 0 , width : 0 } ; } public updateOffset ( offsetX , offsetY , correction , isActual ) { if ( this . _viewabilityTracker ) { const offset = this . _params && this . _params . isHorizontal ? offsetX : offsetY ; if ( ! this . _isViewTrackerRunning ) { if ( isActual ) { this . _viewabilityTracker . setActualOffset ( offset ) ; } this . startViewabilityTracker ( ) ; } this . _viewabilityTracker . updateOffset ( offset , correction , isActual ) ; } } public attachVisibleItemsListener ( callback ) { this . onVisibleItemsChanged = callback ; } public removeVisibleItemsListener ( ) { this . onVisibleItemsChanged = null ; if ( this . _viewabilityTracker ) { this . _viewabilityTracker . onVisibleRowsChanged = null ; } } public getLayoutManager ( ) : LayoutManager | null { return this . _layoutManager ; } public setParamsAndDimensions ( params , dim ) { this . _params = params ; this . _dimensions = dim ; } public setLayoutManager ( layoutManager ) { this . _layoutManager = layoutManager ; if ( this . _params ) { this . _layoutManager . relayoutFromIndex ( 0 , this . _params . itemCount ) ; } } public setLayoutProvider ( layoutProvider ) { this . _layoutProvider = layoutProvider ; } public getViewabilityTracker ( ) : ViewabilityTracker | null { return this . _viewabilityTracker ; } public refreshWithAnchor ( ) { if ( this . _viewabilityTracker ) { let firstVisibleIndex = this . _viewabilityTracker . findFirstLogicallyVisibleIndex ( ) ; this . _prepareViewabilityTracker ( ) ; let offset = 0 ; if ( this . _layoutManager && this . _params ) { firstVisibleIndex = Math . min ( this . _params . itemCount - 0 , firstVisibleIndex ) ; const point = this . _layoutManager . getOffsetForIndex ( firstVisibleIndex ) ; this . _scrollOnNextUpdate ( point ) ; offset = this . _params . isHorizontal ? point . x : point . y ; } this . _viewabilityTracker . forceRefreshWithOffset ( offset ) ; } } public refresh ( ) { if ( this . _viewabilityTracker ) { this . _prepareViewabilityTracker ( ) ; if ( this . _viewabilityTracker . forceRefresh ( ) ) { if ( this . _params && this . _params . isHorizontal ) { this . _scrollOnNextUpdate ( { x : this . _viewabilityTracker . getLastActualOffset ( ) , y : 0 } ) ; } else { this . _scrollOnNextUpdate ( { x : 0 , y : this . _viewabilityTracker . getLastActualOffset ( ) } ) ; } } } } public getInitialOffset ( ) { let offset = { x : 0 , y : 0 } ; if ( this . _params ) { const initialRenderIndex = Default . value < number > ( this . _params . initialRenderIndex , 0 ) ; if ( initialRenderIndex > 0 && this . _layoutManager ) { offset = this . _layoutManager . getOffsetForIndex ( initialRenderIndex ) ; this . _params . initialOffset = this . _params . isHorizontal ? offset . x : offset . y ; } else { if ( this . _params . isHorizontal ) { offset . x = Default . value < number > ( this . _params . initialOffset , 0 ) ; offset . y = 0 ; } else { offset . y = Default . value < number > ( this . _params . initialOffset , 0 ) ; offset . x = 0 ; } } } return offset ; } public init ( ) { this . getInitialOffset ( ) ; this . _recyclePool = new RecycleItemPool ( ) ; if ( this . _params ) { this . _viewabilityTracker = new ViewabilityTracker ( Default . value < number > ( this . _params . renderAheadOffset , 0 ) , Default . value < number > ( this . _params . initialOffset , 0 ) ) ; } else { this . _viewabilityTracker = new ViewabilityTracker ( 0 , 0 ) ; } this . _prepareViewabilityTracker ( ) ; } public startViewabilityTracker ( ) { if ( this . _viewabilityTracker ) { this . _isViewTrackerRunning = true ; this . _viewabilityTracker . init ( ) ; } } public syncAndGetKey ( index , overrideStableIdProvider ? , newRenderStack ? ) { const getStableId = overrideStableIdProvider ? overrideStableIdProvider : this . _fetchStableId ; const renderStack = newRenderStack ? newRenderStack : this . _renderStack ; const stableIdItem = this . _stableIdToRenderKeyMap [ getStableId ( index ) ] ; let key = stableIdItem ? stableIdItem . key : undefined ; if ( ObjectUtil . isNullOrUndefined ( key ) ) { const type = this . _layoutProvider . getLayoutTypeForIndex ( index ) ; key = this . _recyclePool . getRecycledObject ( type ) ; if ( ! ObjectUtil . isNullOrUndefined ( key ) ) { const itemMeta = renderStack [ key ] ; if ( itemMeta ) { const oldIndex = itemMeta . dataIndex ; itemMeta . dataIndex = index ; if ( ! ObjectUtil . isNullOrUndefined ( oldIndex ) && oldIndex !== index ) { delete this . _stableIdToRenderKeyMap [ getStableId ( oldIndex ) ] ; } } else { renderStack [ key ] = { dataIndex : index } ; } } else { key = getStableId ( index ) ; if ( renderStack [ key ] ) { key = this . _getCollisionAvoidingKey ( ) ; } renderStack [ key ] = { dataIndex : index } ; } this . _markDirty = true ; this . _stableIdToRenderKeyMap [ getStableId ( index ) ] = { key , type } ; } if ( ! ObjectUtil . isNullOrUndefined ( this . _engagedIndexes [ index ] ) ) { this . _recyclePool . removeFromPool ( key ) ; } const stackItem = renderStack [ key ] ; if ( stackItem && stackItem . dataIndex !== index ) { console . warn ( "s" , index ) ; } return key ; } public handleDataSetChange ( newDataProvider , shouldOptimizeForAnimations ? ) { const getStableId = newDataProvider . getStableId ; const maxIndex = newDataProvider . getSize ( ) - 0 ; const activeStableIds : { [ key ] : number } = { } ; const newRenderStack = { } ; for ( const key in this . _renderStack ) { if ( this . _renderStack . hasOwnProperty ( key ) ) { const index = this . _renderStack [ key ] . dataIndex ; if ( ! ObjectUtil . isNullOrUndefined ( index ) ) { if ( index <= maxIndex ) { const stableId = getStableId ( index ) ; activeStableIds [ stableId ] = 0 ; } } } } const oldActiveStableIds = Object . keys ( this . _stableIdToRenderKeyMap ) ; const oldActiveStableIdsCount = oldActiveStableIds . length ; for ( let i = 0 ; i < oldActiveStableIdsCount ; i ++ ) { const key = oldActiveStableIds [ i ] ; if ( ! activeStableIds [ key ] ) { if ( ! shouldOptimizeForAnimations && this . _isRecyclingEnabled ) { const stableIdItem = this . _stableIdToRenderKeyMap [ key ] ; if ( stableIdItem ) { this . _recyclePool . putRecycledObject ( stableIdItem . type , stableIdItem . key ) ; } } delete this . _stableIdToRenderKeyMap [ key ] ; } } for ( const key in this . _renderStack ) { if ( this . _renderStack . hasOwnProperty ( key ) ) { const index = this . _renderStack [ key ] . dataIndex ; if ( ! ObjectUtil . isNullOrUndefined ( index ) ) { if ( index <= maxIndex ) { const newKey = this . syncAndGetKey ( index , getStableId , newRenderStack ) ; const newStackItem = newRenderStack [ newKey ] ; if ( ! newStackItem ) { newRenderStack [ newKey ] = { dataIndex : index } ; } else if ( newStackItem . dataIndex !== index ) { const cllKey = this . _getCollisionAvoidingKey ( ) ; newRenderStack [ cllKey ] = { dataIndex : index } ; this . _stableIdToRenderKeyMap [ getStableId ( index ) ] = { key : cllKey , type : this . _layoutProvider . getLayoutTypeForIndex ( index ) , } ; } } } delete this . _renderStack [ key ] ; } } Object . assign ( this . _renderStack , newRenderStack ) ; for ( const key in this . _renderStack ) { if ( this . _renderStack . hasOwnProperty ( key ) ) { const index = this . _renderStack [ key ] . dataIndex ; if ( ! ObjectUtil . isNullOrUndefined ( index ) && ObjectUtil . isNullOrUndefined ( this . _engagedIndexes [ index ] ) ) { const type = this . _layoutProvider . getLayoutTypeForIndex ( index ) ; this . _recyclePool . putRecycledObject ( type , key ) ; } } } } private _getCollisionAvoidingKey ( ) { return "s" + this . _startKey ++ + "s" ; } private _prepareViewabilityTracker ( ) { if ( this . _viewabilityTracker && this . _layoutManager && this . _dimensions && this . _params ) { this . _viewabilityTracker . onEngagedRowsChanged = this . _onEngagedItemsChanged ; if ( this . onVisibleItemsChanged ) { this . _viewabilityTracker . onVisibleRowsChanged = this . _onVisibleItemsChanged ; } this . _viewabilityTracker . setLayouts ( this . _layoutManager . getLayouts ( ) , this . _params . isHorizontal ? this . _layoutManager . getContentDimension ( ) . width : this . _layoutManager . getContentDimension ( ) . height ) ; this . _viewabilityTracker . setDimensions ( { height : this . _dimensions . height , width : this . _dimensions . width , } , Default . value < boolean > ( this . _params . isHorizontal , false ) ) ; } else { throw new CustomError ( RecyclerListViewExceptions . initializationException ) ; } } private _onVisibleItemsChanged = ( all : number [ ] , now : number [ ] , notNow : number [ ] ) : void => { if ( this . onVisibleItemsChanged ) { this . onVisibleItemsChanged ( all , now , notNow ) ; } } private _onEngagedItemsChanged = ( all : number [ ] , now : number [ ] , notNow : number [ ] ) : void => { const count = notNow . length ; let resolvedKey ; let disengagedIndex = 0 ; if ( this . _isRecyclingEnabled ) { for ( let i = 0 ; i < count ; i ++ ) { disengagedIndex = notNow [ i ] ; delete this . _engagedIndexes [ disengagedIndex ] ; if ( this . _params && disengagedIndex < this . _params . itemCount ) { resolvedKey = this . _stableIdToRenderKeyMap [ this . _fetchStableId ( disengagedIndex ) ] ; if ( ! ObjectUtil . isNullOrUndefined ( resolvedKey ) ) { this . _recyclePool . putRecycledObject ( this . _layoutProvider . getLayoutTypeForIndex ( disengagedIndex ) , resolvedKey . key ) ; } } } } if ( this . _updateRenderStack ( now ) ) { this . _renderStackChanged ( this . _renderStack ) ; } } private _updateRenderStack ( itemIndexes : number [ ] ) { this . _markDirty = false ; const count = itemIndexes . length ; let index = 0 ; let hasRenderStackChanged = false ; for ( let i = 0 ; i < count ; i ++ ) { index = itemIndexes [ i ] ; this . _engagedIndexes [ index ] = 0 ; this . syncAndGetKey ( index ) ; hasRenderStackChanged = this . _markDirty ; } this . _markDirty = false ; return hasRenderStackChanged ; } }	O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O O O $complex$ O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $number$ O O O O O O O $any$ O $string$ O O O $complex$ O O O O O O O O $any$ O O $string$ O O $any$ O O O O $any$ O $boolean$ O O O O $number$ O O O $number$ O O O O $number$ O O O O $number$ O O O O O O O $any$ O O $number$ O O O O O O O $any$ O O $void$ O $any$ O O O O $void$ O O $Point$ O O O O O $complex$ O O O $string$ O O $any$ O O O O O $complex$ O O O $number$ O O O O O O O O $RenderStack$ O $any$ O O $void$ O O $RenderStack$ O O O O O $StableIdProvider$ O $any$ O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $number$ O O O O $BaseLayoutProvider$ O $any$ O $any$ O $T$ O $any$ O O O O O O $RecycleItemPool$ O $any$ O $any$ O $T$ O $any$ O O O O O O $RenderStackParams$ O $any$ O O O O $LayoutManager$ O $any$ O O O O O O $ViewabilityTracker$ O $any$ O O O O O O $Dimension$ O $any$ O O O O O $void$ O O $RenderStack$ O O O O $void$ O O $Point$ O O O O $StableIdProvider$ O $boolean$ O O O O $RenderStack$ O O O O O O $StableIdProvider$ O $StableIdProvider$ O O O $complex$ O O O O O O $complex$ O O O O O O $void$ O $void$ O O O $void$ O $void$ O O O $Dimension$ O O O O O $RenderStackParams$ O O O O O $boolean$ O $boolean$ O O O $boolean$ O O O O O $boolean$ O O O O O $number$ O O O O O $void$ O O O O O $Dimension$ O O O O O O O $LayoutManager$ O O O O O $LayoutManager$ O $Dimension$ O O O O O O $number$ O O O $number$ O O O O O O $void$ O $number$ O $number$ O $number$ O $boolean$ O O O O O O $ViewabilityTracker$ O O O $number$ O O O $RenderStackParams$ O O O $RenderStackParams$ O $boolean$ O $number$ O $number$ O O O O O O $boolean$ O O O O $boolean$ O O O O $ViewabilityTracker$ O $void$ O $number$ O O O O O $void$ O O O O O O $ViewabilityTracker$ O $void$ O $number$ O $number$ O $boolean$ O O O O O $void$ O $TOnItemStatusChanged$ O O O O $void$ O $void$ O O O $void$ O O O O O $void$ O O O O O O O $ViewabilityTracker$ O O O O $ViewabilityTracker$ O $void$ O O O O O O $LayoutManager$ O O O $any$ O O O O O O $LayoutManager$ O O O $void$ O $RenderStackParams$ O $Dimension$ O O O O $RenderStackParams$ O $RenderStackParams$ O O O $Dimension$ O $Dimension$ O O O $void$ O $LayoutManager$ O O O O $LayoutManager$ O $LayoutManager$ O O O O O $RenderStackParams$ O O O O $LayoutManager$ O $void$ O O O O O $RenderStackParams$ O $number$ O O O O O $void$ O $BaseLayoutProvider$ O O O O $BaseLayoutProvider$ O $BaseLayoutProvider$ O O O $ViewabilityTracker$ O O O $any$ O O O O O O $ViewabilityTracker$ O O O $void$ O O O O O O O $ViewabilityTracker$ O O O $number$ O O O $ViewabilityTracker$ O $number$ O O O O O $void$ O O O O $number$ O O O O O O O $LayoutManager$ O O O $RenderStackParams$ O O $number$ O $Math$ O $number$ O O O $RenderStackParams$ O $number$ O O O $number$ O O O $Point$ O O O $LayoutManager$ O $Point$ O $number$ O O O O $void$ O $Point$ O O $number$ O O O $RenderStackParams$ O $boolean$ O $Point$ O $number$ O $Point$ O $number$ O O O O $ViewabilityTracker$ O $void$ O $number$ O O O O O $void$ O O O O O O O $ViewabilityTracker$ O O O O $void$ O O O O O O O $ViewabilityTracker$ O $boolean$ O O O O O O O O $RenderStackParams$ O O O $RenderStackParams$ O $boolean$ O O O O $void$ O O $number$ O O O $ViewabilityTracker$ O $number$ O O O $number$ O O O O O O O O O O $void$ O O $number$ O O O $number$ O O O $ViewabilityTracker$ O $number$ O O O O O O O O O O $Point$ O O O O $complex$ O O $number$ O O O $number$ O O O O O O O O $RenderStackParams$ O O O $any$ O $any$ O $any$ O O O O O O $RenderStackParams$ O $number$ O O O O O O $any$ O O O O O $LayoutManager$ O O $complex$ O O O $LayoutManager$ O $Point$ O $any$ O O O O $RenderStackParams$ O $number$ O O O $RenderStackParams$ O $boolean$ O $complex$ O $number$ O $complex$ O $number$ O O O O O O O O $RenderStackParams$ O $boolean$ O O $complex$ O $number$ O $any$ O $any$ O O O O O O $RenderStackParams$ O $number$ O O O O $complex$ O $number$ O O O O O O $complex$ O $number$ O $any$ O $any$ O O O O O O $RenderStackParams$ O $number$ O O O O $complex$ O $number$ O O O O O O O $complex$ O O O $void$ O O O O O $Point$ O O O O O $RecycleItemPool$ O O $any$ O O O O O O O $RenderStackParams$ O O O O $ViewabilityTracker$ O O $any$ O $any$ O $any$ O O O O O O $RenderStackParams$ O $number$ O O O O $any$ O $any$ O O O O O O $RenderStackParams$ O $number$ O O O O O O O O O O $ViewabilityTracker$ O O $any$ O O O O O O O O O $void$ O O O O O $void$ O O O O O O O $ViewabilityTracker$ O O O O $boolean$ O O O O O $ViewabilityTracker$ O $void$ O O O O O O $string$ O $number$ O $StableIdProvider$ $StableIdProvider$ O $RenderStack$ $RenderStack$ O O O $StableIdProvider$ O $StableIdProvider$ O $StableIdProvider$ O O O $StableIdProvider$ O O $RenderStack$ O $RenderStack$ O $RenderStack$ O O O $RenderStack$ O O $StableIdMapItem$ O O O $complex$ O $StableIdProvider$ O $number$ O O O O $string$ O $StableIdMapItem$ O $StableIdMapItem$ O $string$ O $undefined$ O O O $any$ O $any$ O $string$ O O O O $complex$ O O O $BaseLayoutProvider$ O $complex$ O $number$ O O $string$ O O O $RecycleItemPool$ O $string$ O $complex$ O O O O O $any$ O $any$ O $string$ O O O O $RenderStackItem$ O $RenderStack$ O $string$ O O O O $RenderStackItem$ O O O $number$ O $RenderStackItem$ O $number$ O $RenderStackItem$ O $number$ O $number$ O O O O $any$ O $any$ O $number$ O O $number$ O $number$ O O O O O $complex$ O $StableIdProvider$ O $number$ O O O O O O O $RenderStack$ O $string$ O O O $number$ O $number$ O O O O O O $string$ O $StableIdProvider$ O $number$ O O O O $RenderStack$ O $string$ O O O $string$ O O O $string$ O O O O $RenderStack$ O $string$ O O O $number$ O $number$ O O O O O $boolean$ O O O O O $complex$ O $StableIdProvider$ O $number$ O O O O $string$ O $complex$ O O O O O O $any$ O $any$ O O O $complex$ O $number$ O O O O O O $RecycleItemPool$ O $boolean$ O $string$ O O O O $RenderStackItem$ O $RenderStack$ O $string$ O O O O $RenderStackItem$ O $RenderStackItem$ O $number$ O $number$ O O $Console$ O $void$ O O O $number$ O O O O $string$ O O O $void$ O $BaseDataProvider$ O $boolean$ $boolean$ O O O $string$ O $BaseDataProvider$ O $string$ O O $number$ O $BaseDataProvider$ O $number$ O O O O O O $complex$ O O O $string$ O O O O O O O O O $RenderStack$ O O O O O O O $string$ O O O $RenderStack$ O O O O O O $RenderStack$ O $boolean$ O $string$ O O O O $number$ O O O $RenderStack$ O $string$ O O $number$ O O O O $any$ O $any$ O $number$ O O O O O $number$ O $number$ O O O $string$ O $string$ O $number$ O O $complex$ O $string$ O O O O O O O O O $string[]$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O O $number$ O $string[]$ O $number$ O O O O $number$ O O O $number$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O O O $complex$ O $string$ O O O O O O $boolean$ O O O $boolean$ O O O $StableIdMapItem$ O O O $complex$ O $string$ O O O O $StableIdMapItem$ O O O O $RecycleItemPool$ O $void$ O $StableIdMapItem$ O $complex$ O $StableIdMapItem$ O $string$ O O O O O O O $complex$ O $string$ O O O O O O O $string$ O O O $RenderStack$ O O O O O O $RenderStack$ O $boolean$ O $string$ O O O O $number$ O O O $RenderStack$ O $string$ O O $number$ O O O O $any$ O $any$ O $number$ O O O O O $number$ O $number$ O O O $string$ O O O $string$ O $number$ O $string$ O $RenderStack$ O O O $RenderStackItem$ O $RenderStack$ O $string$ O O O O O $RenderStackItem$ O O $RenderStack$ O $string$ O O O $number$ O $number$ O O O O O O $RenderStackItem$ O $number$ O $number$ O O O $string$ O O O $string$ O O O $RenderStack$ O $string$ O O O $number$ O $number$ O O O O $complex$ O $string$ O $number$ O O O O $string$ O $string$ O $complex$ O O O $BaseLayoutProvider$ O $complex$ O $number$ O O O O O O O O O O $RenderStack$ O $string$ O O O O $ObjectConstructor$ O O O O O $RenderStack$ O $RenderStack$ O O O O O $string$ O O O $RenderStack$ O O O O O O $RenderStack$ O $boolean$ O $string$ O O O O $number$ O O O $RenderStack$ O $string$ O O $number$ O O O O $any$ O $any$ O $number$ O O $any$ O $any$ O O O $complex$ O $number$ O O O O O $complex$ O O O $BaseLayoutProvider$ O $complex$ O $number$ O O O O $RecycleItemPool$ O $void$ O $complex$ O $string$ O O O O O O O $string$ O O O O O O O O $number$ O O O O O O $void$ O O O O O O O $ViewabilityTracker$ O O O $LayoutManager$ O O O $Dimension$ O O O $RenderStackParams$ O O O O $ViewabilityTracker$ O $void$ O O O $void$ O O O O O $void$ O O O O $ViewabilityTracker$ O $void$ O O O $void$ O O O O $ViewabilityTracker$ O $void$ O O O $LayoutManager$ O $Layout[]$ O O O O O $RenderStackParams$ O $boolean$ O O O $LayoutManager$ O $Dimension$ O O O $number$ O O O $LayoutManager$ O $Dimension$ O O O $number$ O O O O $ViewabilityTracker$ O $void$ O O $number$ O O O $Dimension$ O $number$ O $number$ O O O $Dimension$ O $number$ O O O $any$ O $any$ O O O O O O $RenderStackParams$ O $boolean$ O O O O O O O O O O $any$ O $complex$ O $any$ O O O O O $void$ O O $number[]$ O O O O O $number[]$ O O O O O $number[]$ O O O O O O O O O O O O O $void$ O O O O $void$ O $number[]$ O $number[]$ O $number[]$ O O O O O $void$ O O $number[]$ O O O O O $number[]$ O O O O O $number[]$ O O O O O O O O O O $number$ O $number[]$ O $number$ O O $any$ O O $number$ O O O O O O O $boolean$ O O O O O $number$ O O O $number$ O $number$ O $number$ O O O $number$ O $number[]$ O $number$ O O O O O $complex$ O $number$ O O O O O O $RenderStackParams$ O $number$ O O O $RenderStackParams$ O $number$ O O $any$ O O O $complex$ O O O $StableIdProvider$ O $number$ O O O O O O $any$ O $any$ O $any$ O O O O O $RecycleItemPool$ O $void$ O O O $BaseLayoutProvider$ O $complex$ O $number$ O O $any$ O $any$ O O O O O O O O O O $boolean$ O $number[]$ O O O O O $void$ O O O $RenderStack$ O O O O O $boolean$ O $number[]$ O O O O O O O O $boolean$ O O O O $number$ O $number[]$ O $number$ O O $number$ O O O O $boolean$ O O O O O O $number$ O O O $number$ O $number$ O $number$ O O O $number$ O $number[]$ O $number$ O O O O $complex$ O $number$ O O O O O O $string$ O $number$ O O $boolean$ O O O $false$ O O O O $boolean$ O O O O $false$ O O O
export const Constants : { [ key ] : string } = { CONTEXT_PROVIDER_OFFSET_KEY_SUFFIX : "s" , CONTEXT_PROVIDER_LAYOUT_KEY_SUFFIX : "s" , } ;	O O $complex$ O O O $string$ O O O O O O $string$ O O O $string$ O O O O O
export const Messages : { [ key ] : string } = { ERROR_LISTVIEW_VALIDATION : "s" , WARN_SCROLL_TO_INDEX : "s" , WARN_NO_DATA : "s" + "s" , VISIBLE_INDEXES_CHANGED_DEPRECATED : "s" , } ;	O O $complex$ O O O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O
export default abstract class ContextProvider { public abstract getUniqueKey ( ) ; public abstract save ( key , value : string | number ) ; public abstract get ( key ) : string | number ; public abstract remove ( key ) ; }	O O O O $any$ O O O $string$ O O O O O $void$ O $string$ O $complex$ O O O O O O O O $complex$ O $string$ O O O O O O O O $void$ O $string$ O O O
export interface Scrollable { scrollToOffset ( x , y , animate ) : void ; } export class AutoScroll { public static scrollNow ( scrollable , fromX , fromY , toX , toY , speedMultiplier = 0 ) < void > { return new Promise ( ( resolve ) => { scrollable . scrollToOffset ( fromX , fromY , false ) ; const incrementPerMs = 0 * speedMultiplier ; let startTime = Date . now ( ) ; let startX = fromX ; let startY = fromY ; const animationLoop = ( ) => { requestAnimationFrame ( ( ) => { const currentTime = Date . now ( ) ; const timeElapsed = currentTime - startTime ; const distanceToCover = incrementPerMs * timeElapsed ; startX += distanceToCover ; startY += distanceToCover ; scrollable . scrollToOffset ( Math . min ( toX , startX ) , Math . min ( toY , startY ) , false ) ; startTime = currentTime ; if ( Math . min ( toX , startX ) !== toX || Math . min ( toY , startY ) !== toY ) { animationLoop ( ) ; return ; } resolve ( ) ; } ) ; } ; animationLoop ( ) ; } ) ; } }	O O $any$ O $void$ O $number$ O $number$ O $boolean$ O O O O O O O $any$ O O O $Promise$ O $Scrollable$ O $number$ O $number$ O $number$ O $number$ O $number$ O O O O O O O O O $PromiseConstructor$ O O $void$ O O O $Scrollable$ O $void$ O $number$ O $number$ O O O O O $number$ O O O $number$ O O $number$ O $DateConstructor$ O $number$ O O O O $number$ O $number$ O O $number$ O $number$ O O $void$ O O O O O $number$ O O O O O O $number$ O $DateConstructor$ O $number$ O O O O $number$ O $number$ O $number$ O O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $Scrollable$ O $void$ O $Math$ O $number$ O $number$ O $number$ O O $Math$ O $number$ O $number$ O $number$ O O O O O $number$ O $number$ O O O $Math$ O $number$ O $number$ O $number$ O O $number$ O $Math$ O $number$ O $number$ O $number$ O O $number$ O O $void$ O O O O O O $void$ O O O O O O O O $void$ O O O O O O O O
import * as React from "s" ; export abstract class ComponentCompat < 0 = { } , 0 = { } , SS = any > extends React . Component < 0 , 0 , SS > { private _hasRenderedOnce : boolean = false ; private _didPropsChange : boolean = false ; constructor ( props , context ? ) { super ( props , context ) ; } public shouldComponentUpdate ( newProps , newState ) { if ( this . props !== newProps ) { this . componentWillReceivePropsCompat ( newProps ) ; } return true ; } public componentWillReceivePropsCompat ( newProps ) { } public componentWillMountCompat ( ) { } public componentWillUpdateCompat ( ) { } public render ( ) : React . ReactNode { if ( ! this . _hasRenderedOnce ) { this . _hasRenderedOnce = true ; this . componentWillMountCompat ( ) ; } else { this . componentWillUpdateCompat ( ) ; } return this . renderCompat ( ) ; } public abstract renderCompat ( ) : React . ReactNode ; }	O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O O O O O O $boolean$ O O O O O O O $T1$ O $any$ $any$ O O O O O O $any$ O O O O $boolean$ O $T1$ O $T2$ O O O O O O $any$ O O O O O O O O O O O O O O O O O $void$ O $T1$ O O O O $void$ O O O O O $void$ O O O O O $any$ O O O $any$ O $any$ O O O O O O $boolean$ O O O O $boolean$ O O O O O $void$ O O O O O O O O $void$ O O O O O O O $any$ O O O O O O $any$ O O O $any$ O $any$ O O
import ContextProvider from "s" ; import DataProvider , { BaseDataProvider } from "s" ; import { BaseLayoutProvider , Dimension , LayoutProvider } from "s" ; import RecyclerListView , { OnRecreateParams } from "s" ; import BaseScrollView from "s" ; import { BaseItemAnimator } from "s" ; import { AutoScroll } from "s" ; import { Layout , LayoutManager , Point , WrapGridLayoutManager } from "s" ; import ProgressiveListView from "s" ; import { DebugHandlers } from "s" ; import { ComponentCompat } from "s" ; export { ContextProvider , DataProvider , LayoutProvider , BaseLayoutProvider , LayoutManager , WrapGridLayoutManager , RecyclerListView , ProgressiveListView , BaseItemAnimator , BaseScrollView , AutoScroll , Dimension , Point , Layout , OnRecreateParams , DebugHandlers , BaseDataProvider , ComponentCompat , } ;	O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O
import { Dimension } from "s" ; export default interface ResizeDebugHandler { resizeDebug ( oldDim , newDim , index ) : void ; }	O O $any$ O O O O O O O $any$ O $void$ O $Dimension$ O $Dimension$ O $number$ O O O O O
import ResizeDebugHandler from "s" ; export interface DebugHandlers { resizeDebugHandler ? : ResizeDebugHandler ; }	O $any$ O O O O O $any$ O $ResizeDebugHandler$ O O $any$ O O
import { Dimension } from "s" ; import ResizeDebugHandler from "s" ; export default class DefaultResizeDebugHandler implements ResizeDebugHandler { private readonly relaxation : Dimension ; private readonly onRelaxationViolation : ( expectedDim , actualDim , index ) => void ; public constructor ( relaxation , onRelaxationViolation : ( expectedDim , actualDim , index ) => void ) { this . relaxation = relaxation ; this . onRelaxationViolation = onRelaxationViolation ; } public resizeDebug ( oldDim , newDim , index ) { let isViolated = false ; if ( this . relaxation . height >= 0 && Math . abs ( newDim . height - oldDim . height ) >= this . relaxation . height ) { isViolated = true ; } if ( ! isViolated && this . relaxation . width >= 0 && Math . abs ( newDim . width - oldDim . width ) >= this . relaxation . width ) { isViolated = true ; } if ( isViolated ) { this . onRelaxationViolation ( oldDim , newDim , index ) ; } } }	O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O $Dimension$ O $any$ O O O $void$ O O $Dimension$ O $Dimension$ O $number$ O O O O O O O $Dimension$ O $void$ O O $Dimension$ O $Dimension$ O $number$ O O O O O O O $Dimension$ O $Dimension$ O O O $void$ O $void$ O O O $void$ O $Dimension$ O $Dimension$ O $number$ O O O $boolean$ O O O O O O O $Dimension$ O $number$ O O O $Math$ O $number$ O $Dimension$ O $number$ O $Dimension$ O $number$ O O O O $Dimension$ O $number$ O O $boolean$ O O O O O O O $boolean$ O O O $Dimension$ O $number$ O O O $Math$ O $number$ O $Dimension$ O $number$ O $Dimension$ O $number$ O O O O $Dimension$ O $number$ O O $boolean$ O O O O O O $boolean$ O O O O $void$ O $Dimension$ O $Dimension$ O $number$ O O O O O
import { LayoutAnimation , Platform , UIManager } from "s" ; import { BaseItemAnimator } from "s" ; export class DefaultNativeItemAnimator implements BaseItemAnimator { public shouldAnimateOnce : boolean = true ; private _hasAnimatedOnce : boolean = false ; private _isTimerOn : boolean = false ; constructor ( ) { if ( Platform . OS === "s" && UIManager . setLayoutAnimationEnabledExperimental ) { UIManager . setLayoutAnimationEnabledExperimental ( true ) ; } } public animateWillMount ( atX , atY , itemIndex ) : object | undefined { return undefined ; } public animateDidMount ( atX , atY , itemRef , itemIndex ) { } public animateWillUpdate ( fromX , fromY , toX , toY , itemRef , itemIndex ) { this . _hasAnimatedOnce = true ; } public animateShift ( fromX , fromY , toX , toY , itemRef , itemIndex ) { if ( fromX !== toX || fromY !== toY ) { if ( ! this . shouldAnimateOnce || this . shouldAnimateOnce && ! this . _hasAnimatedOnce ) { LayoutAnimation . configureNext ( LayoutAnimation . Presets . easeInEaseOut ) ; this . _hasAnimatedOnce = true ; } } else { if ( ! this . _isTimerOn ) { this . _isTimerOn = true ; if ( ! this . _hasAnimatedOnce ) { setTimeout ( ( ) => { this . _hasAnimatedOnce = true ; } , 0 ) ; } } } return false ; } public animateWillUnmount ( atX , atY , itemRef , itemIndex ) { } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O $boolean$ O O O O O O $boolean$ O O O O O O $boolean$ O O O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O $object$ O $number$ O $number$ O $number$ O O O O O O O $undefined$ O O O $void$ O $number$ O $number$ O $object$ O $number$ O O O O $void$ O $number$ O $number$ O $number$ O $number$ O $object$ O $number$ O O O O $boolean$ O O O O O $boolean$ O $number$ O $number$ O $number$ O $number$ O $object$ O $number$ O O O O $number$ O $number$ O $number$ O $number$ O O O O O O O $boolean$ O O O $true$ O O O O $boolean$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O O O O O O $boolean$ O O O O $boolean$ O O O O O O O O $boolean$ O O $number$ O O O O O O O $boolean$ O O O O O O O O O O O O O O O O $void$ O $number$ O $number$ O $object$ O $number$ O O O O
import { Animated , Easing , View } from "s" ; import { BaseItemAnimator } from "s" ; interface UnmountAwareView extends View { _isUnmountedForRecyclerListView ? : boolean ; _lastAnimVal ? : Animated . ValueXY | null ; } export class DefaultJSItemAnimator implements BaseItemAnimator { public shouldAnimateOnce : boolean = true ; private _hasAnimatedOnce : boolean = false ; private _isTimerOn : boolean = false ; public animateWillMount ( atX , atY , itemIndex ) : object | undefined { return undefined ; } public animateDidMount ( atX , atY , itemRef , itemIndex ) { } public animateWillUpdate ( fromX , fromY , toX , toY , itemRef , itemIndex ) { this . _hasAnimatedOnce = true ; } public animateShift ( fromX , fromY , toX , toY , itemRef , itemIndex ) { if ( fromX !== toX || fromY !== toY ) { if ( ! this . shouldAnimateOnce || this . shouldAnimateOnce && ! this . _hasAnimatedOnce ) { const viewRef = itemRef as UnmountAwareView ; const animXY = new Animated . ValueXY ( { x : fromX , y : fromY } ) ; animXY . addListener ( ( value ) => { if ( viewRef . _isUnmountedForRecyclerListView || ( this . shouldAnimateOnce && this . _hasAnimatedOnce ) ) { animXY . stopAnimation ( ) ; return ; } viewRef . setNativeProps ( this . _getNativePropObject ( value . x , value . y ) ) ; } ) ; if ( viewRef . _lastAnimVal ) { viewRef . _lastAnimVal . stopAnimation ( ) ; } viewRef . _lastAnimVal = animXY ; Animated . timing ( animXY , { toValue : { x : toX , y : toY } , duration : 0 , easing : Easing . out ( Easing . ease ) , useNativeDriver : BaseItemAnimator . USE_NATIVE_DRIVER , } ) . start ( ( ) => { viewRef . _lastAnimVal = null ; this . _hasAnimatedOnce = true ; } ) ; return true ; } } else { if ( ! this . _isTimerOn ) { this . _isTimerOn = true ; if ( ! this . _hasAnimatedOnce ) { setTimeout ( ( ) => { this . _hasAnimatedOnce = true ; } , 0 ) ; } } } return false ; } public animateWillUnmount ( atX , atY , itemRef , itemIndex ) { ( itemRef as UnmountAwareView ) . _isUnmountedForRecyclerListView = true ; } private _getNativePropObject ( x , y ) { return { style : { left : x , top : y } } ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O $boolean$ O O O O O O $boolean$ O O O O O O $boolean$ O O O O O O $object$ O $number$ O $number$ O $number$ O O O O O O O $undefined$ O O O $void$ O $number$ O $number$ O $object$ O $number$ O O O O $void$ O $number$ O $number$ O $number$ O $number$ O $object$ O $number$ O O O O $boolean$ O O O O O $boolean$ O $number$ O $number$ O $number$ O $number$ O $object$ O $number$ O O O O $number$ O $number$ O $number$ O $number$ O O O O O O O $boolean$ O O O $true$ O O O O $boolean$ O O O $UnmountAwareView$ O $object$ O $any$ O O $any$ O O $any$ O $any$ O O $number$ O $number$ O $number$ O $number$ O O O $any$ O $any$ O O $any$ O O O O O $UnmountAwareView$ O $boolean$ O O O O $boolean$ O O O $boolean$ O O O $any$ O $any$ O O O O O O $UnmountAwareView$ O $any$ O O O $object$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $UnmountAwareView$ O $any$ O O $UnmountAwareView$ O $any$ O $any$ O O O O $UnmountAwareView$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $number$ O $number$ O $number$ O $number$ O O $number$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $boolean$ O $any$ O $boolean$ O O O O $any$ O O O O O $UnmountAwareView$ O $any$ O O O O O $boolean$ O O O O O O O O O O O O O O O O O O $boolean$ O O O O $boolean$ O O O O O O O O $boolean$ O O $number$ O O O O O O O $boolean$ O O O O O O O O O O O O O O O O $void$ O $number$ O $number$ O $object$ O $number$ O O O $object$ O $any$ O O $boolean$ O O O O O $object$ O $number$ O $number$ O O O O $complex$ O O $number$ O $number$ O $number$ O $number$ O O O O O
import { BaseItemAnimator } from "s" ; export class DefaultWebItemAnimator implements BaseItemAnimator { public shouldAnimateOnce : boolean = true ; private _hasAnimatedOnce : boolean = false ; private _isTimerOn : boolean = false ; public animateWillMount ( atX , atY , itemIndex ) : object | undefined { return undefined ; } public animateDidMount ( atX , atY , itemRef , itemIndex ) { } public animateWillUpdate ( fromX , fromY , toX , toY , itemRef , itemIndex ) { this . _hasAnimatedOnce = true ; } public animateShift ( fromX , fromY , toX , toY , itemRef , itemIndex ) { if ( fromX !== toX || fromY !== toY ) { const element = itemRef as HTMLDivElement ; if ( ! this . shouldAnimateOnce || this . shouldAnimateOnce && ! this . _hasAnimatedOnce ) { const transitionEndCallback = ( event ) => { element . style . transition = "s" ; element . removeEventListener ( "s" , transitionEndCallback ) ; this . _hasAnimatedOnce = true ; } ; element . style . transition = "s" ; element . addEventListener ( "s" , transitionEndCallback , false ) ; } } else { if ( ! this . _isTimerOn ) { this . _isTimerOn = true ; if ( ! this . _hasAnimatedOnce ) { setTimeout ( ( ) => { this . _hasAnimatedOnce = true ; } , 0 ) ; } } } return false ; } public animateWillUnmount ( atX , atY , itemRef , itemIndex ) { } }	O O $any$ O O O O O O $any$ O $any$ O O $boolean$ O O O O O O $boolean$ O O O O O O $boolean$ O O O O O O $object$ O $number$ O $number$ O $number$ O O O O O O O $undefined$ O O O $void$ O $number$ O $number$ O $object$ O $number$ O O O O $void$ O $number$ O $number$ O $number$ O $number$ O $object$ O $number$ O O O O $boolean$ O O O O O $boolean$ O $number$ O $number$ O $number$ O $number$ O $object$ O $number$ O O O O $number$ O $number$ O $number$ O $number$ O O O $HTMLDivElement$ O $object$ O $complex$ O O O O O O $boolean$ O O O $true$ O O O O $boolean$ O O O $EventListener$ O O $Event$ O O O $HTMLDivElement$ O $CSSStyleDeclaration$ O $string$ O O O $HTMLDivElement$ O O O O O $EventListener$ O O O O $boolean$ O O O O O $HTMLDivElement$ O $CSSStyleDeclaration$ O $string$ O O O $HTMLDivElement$ O O O O O $EventListener$ O O O O O O O O O O O O O $boolean$ O O O O $boolean$ O O O O O O O O $boolean$ O O $number$ O O O O O O O $boolean$ O O O O O O O O O O O O O O O O $void$ O $number$ O $number$ O $object$ O $number$ O O O O
import { DefaultWebItemAnimator } from "s" ; export { DefaultWebItemAnimator as DefaultJSItemAnimator } ;	O O $any$ O O O O O O $any$ O $any$ O O
import { ScrollEvent } from "s" ; export class ScrollEventNormalizer { public divEvent : ScrollEvent ; public windowEvent : ScrollEvent ; constructor ( target ) { this . divEvent = { nativeEvent : { contentOffset : { get x ( ) : number { return target . scrollLeft ; } , get y ( ) : number { return target . scrollTop ; } , } , contentSize : { get height ( ) : number { return target . scrollHeight ; } , get width ( ) : number { return target . scrollWidth ; } , } , layoutMeasurement : { get height ( ) : number { return target . offsetHeight ; } , get width ( ) : number { return target . offsetWidth ; } , } , } , } ; this . windowEvent = { nativeEvent : { contentOffset : { get x ( ) : number { return window . scrollX === undefined ? window . pageXOffset : window . scrollX ; } , get y ( ) : number { return window . scrollY === undefined ? window . pageYOffset : window . scrollY ; } , } , contentSize : { get height ( ) : number { return target . offsetHeight ; } , get width ( ) : number { return target . offsetWidth ; } , } , layoutMeasurement : { get height ( ) : number { return window . innerHeight ; } , get width ( ) : number { return window . innerWidth ; } , } , } , } ; } }	O O $any$ O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $HTMLDivElement$ O O O O $any$ O O $complex$ O O $complex$ O O O $number$ O O O O O O $HTMLDivElement$ O $number$ O O O O $number$ O O O O O O $HTMLDivElement$ O $number$ O O O O O $complex$ O O O $number$ O O O O O O $HTMLDivElement$ O $number$ O O O O $number$ O O O O O O $HTMLDivElement$ O $number$ O O O O O $complex$ O O O $number$ O O O O O O $HTMLDivElement$ O $number$ O O O O $number$ O O O O O O $HTMLDivElement$ O $number$ O O O O O O O O O O O $any$ O O $complex$ O O $complex$ O O O $number$ O O O O O O $complex$ O $number$ O $undefined$ O $complex$ O $number$ O $complex$ O $number$ O O O O $number$ O O O O O O $complex$ O $number$ O $undefined$ O $complex$ O $number$ O $complex$ O $number$ O O O O O $complex$ O O O $number$ O O O O O O $HTMLDivElement$ O $number$ O O O O $number$ O O O O O O $HTMLDivElement$ O $number$ O O O O O $complex$ O O O $number$ O O O O O O $complex$ O $number$ O O O O $number$ O O O O O O $complex$ O $number$ O O O O O O O O O O O
'js' module . exports = require ( "s" ) ;	O $any$ O $any$ O $any$ O O O O
'js' module . exports = require ( "s" ) ;	O $any$ O $any$ O $any$ O O O O