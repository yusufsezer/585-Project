'js' 's' ; module . exports = { opts : { readme : 's' , package : 's' , template : 's' , recurse : true , verbose : true , destination : 's' } , plugins : [ 's' ] , source : { excludePattern : 's' , include : [ 's' ] , includePattern : 's' } , templates : { copyright : 's' , includeDate : false , sourceFiles : false , systemName : 's' , theme : 's' } , markdown : { idInHeadings : true } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; if ( process . env . NODE_ENV === 's' ) { require ( 's' ) . start ( ) ; } const express = require ( 's' ) ; const got = require ( 's' ) ; const app = express ( ) ; const DISCOVERY_URL = 's' ; app . get ( 's' , async ( req , res ) => { try { const { body } = await got ( DISCOVERY_URL , { json : true } ) ; const names = body . items . map ( ( item ) => item . name ) ; res . status ( 0 ) . send ( names . join ( 's' ) ) . end ( ) ; } catch ( err ) { console . error ( err ) ; res . status ( 0 ) . end ( ) ; } } ) ; const PORT = process . env . PORT || 0 ; app . listen ( PORT , ( ) => { console . log ( `template` ) ; console . log ( 's' ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; require ( 's' ) . start ( { projectId : 's' , keyFilename : 's' } ) ;	O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; const execa = require ( 's' ) ; describe ( 's' , ( ) => { it ( 's' , done => { const PORT = Math . floor ( ( Math . random ( ) * ( 0 - 0 ) ) ) + 0 ; const proc = execa ( 's' , [ 's' ] , { env : { PORT } } ) ; proc . stdout . on ( 's' , message => { message = message . toString ( 's' ) ; if ( "s" . test ( message ) ) { setTimeout ( ( ) => { proc . kill ( ) ; done ( ) ; } , 0 ) ; } } ) proc . stderr . on ( 's' , message => { done ( new Error ( message . toString ( 's' ) ) ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { mkdir , stat , readFile , writeFile } from 's' ; import * as glob from 's' ; import * as path from 's' ; import { promisify } from 's' ; import { ChildProcess , ForkOptions , fork , SpawnOptions , spawn } from 's' ; import * as once from 's' ; import * as tmp from 's' ; export const BUILD_DIRECTORY = 's' ; export const globP = promisify ( glob ) ; export const mkdirP = promisify ( mkdir ) ; export const readFileP = promisify ( readFile ) ; export const writeFileP = promisify ( writeFile ) ; export const statP = promisify ( stat ) ; export const tmpDirP = promisify ( tmp . dir ) as ( ) => Promise < string > ; export function nodule ( nodule ) { return path . relative ( BUILD_DIRECTORY , `template` ) ; } export function flatten < T > ( arr < Array < T > > ) < T > { return arr . reduce ( ( acc , e ) => acc . concat ( e ) , [ ] ) ; } export function existsP ( path ) < boolean > { return statP ( path ) . then ( ( ) => Promise . resolve ( true ) , ( ) => Promise . resolve ( false ) ) ; } function promisifyChildProcess ( childProcess ) < void > { return new Promise ( ( resolve , reject ) => { const exit = ( err ? ) => once ( ( ) => err ? reject ( err ) : resolve ( ) ) ( ) ; childProcess . on ( 's' , exit ) ; childProcess . on ( 's' , ( code ) => { if ( code === 0 ) { exit ( ) ; } else { exit ( new Error ( `template` ) ) ; } } ) ; } ) ; } export function spawnP ( command , args : string [ ] = [ ] , options = { } ) < void > { const stringifiedCommand = `template` ; console . log ( `template` ) ; return promisifyChildProcess ( spawn ( command , args , Object . assign ( { stdio : 's' , shell : true } , options ) ) ) ; } export function forkP ( moduleName , args : string [ ] = [ ] , options = { } ) < void > { const stringifiedCommand = `template` ; console . log ( `template` ) ; return promisifyChildProcess ( fork ( moduleName , args , Object . assign ( { stdio : 's' , execArgv : [ ] } , options ) ) ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $Array$ O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $ChildProcess$ O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O $SpawnOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O $ForkOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as cpy from 's' ; import * as path from 's' ; import { globP , spawnP , tmpDirP } from 's' ; function getNodeMajorVersion ( ) { return Number ( process . version . slice ( 0 ) . split ( 's' ) [ 0 ] ) ; } export async function checkInstall ( ) { const installDir = await tmpDirP ( ) ; console . log ( installDir ) ; await spawnP ( 's' , [ 's' ] ) ; const tgz = await globP ( `template` ) ; if ( tgz . length !== 0 ) { throw new Error ( `template` ) ; } await spawnP ( 's' , [ 's' , 's' ] , { cwd : installDir } ) ; const nodeTypesVersion = Math . min ( Math . max ( getNodeMajorVersion ( ) , 0 ) , 0 ) ; await spawnP ( 's' , [ 's' , 's' , `template` , tgz [ 0 ] ] , { cwd : installDir } ) ; await cpy ( 's' , installDir , { rename : 's' } ) ; await spawnP ( `template` , [ 's' , 's' , 's' ] , { cwd : installDir } ) ; console . log ( 's' ) ; await spawnP ( `template` , [ 's' , `template` ] , { cwd : installDir } ) ; console . log ( 's' ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' ; import { forkP } from 's' ; import * as ts from 's' ; import * as semver from 's' ; export interface CompileOptions { strict : boolean ; languageLevel : string ; } export async function compile ( options ) { let { strict , languageLevel } = options ; if ( languageLevel === 's' ) { languageLevel = semver . satisfies ( process . version , 's' ) ? 's' : 's' ; } await forkP ( `template` , [ 's' , strict ? 's' : 's' , 's' , languageLevel ] ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CompileOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { createCipheriv , createDecipheriv , randomBytes } from 's' ; import { createReadStream , createWriteStream } from 's' ; export interface KeyAndIV { key : string ; iv : string ; } export async function encryptCredentials ( filename ) < KeyAndIV > { const key = randomBytes ( 0 ) . toString ( 's' ) ; const iv = randomBytes ( 0 ) . toString ( 's' ) ; const decipher = createCipheriv ( 's' , Buffer . from ( key , 's' ) , Buffer . from ( iv , 's' ) ) ; const readStream = createReadStream ( filename ) ; const writeStream = createWriteStream ( `template` ) ; await new Promise ( ( resolve , reject ) => { readStream . on ( 's' , reject ) . pipe ( decipher ) . on ( 's' , reject ) . pipe ( writeStream ) . on ( 's' , reject ) . on ( 's' , resolve ) ; } ) ; return { key , iv } ; } export async function decryptCredentials ( { key , iv } , filename ) { const decipher = createDecipheriv ( 's' , Buffer . from ( key , 's' ) , Buffer . from ( iv , 's' ) ) ; const readStream = createReadStream ( `template` ) ; const writeStream = createWriteStream ( filename ) ; await new Promise ( ( resolve , reject ) => { readStream . on ( 's' , reject ) . pipe ( decipher ) . on ( 's' , reject ) . pipe ( writeStream ) . on ( 's' , reject ) . on ( 's' , resolve ) ; } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyAndIV$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { mkdirP , readFileP , spawnP , writeFileP } from 's' ; const TYPES_DIRECTORY = 's' ; async function mkdirSafeP ( dir ) { try { await mkdirP ( dir ) ; return true ; } catch ( e ) { if ( e . code !== 's' ) { throw new Error ( `template` ) ; } return false ; } } export async function getPluginTypes ( ) { await mkdirSafeP ( TYPES_DIRECTORY ) ; const indexTs = ( await readFileP ( `template` , 's' ) as string ) . split ( 's' ) ; for ( const line of indexTs ) { const matches = line . match ( "s" ) ; if ( ! matches ) { continue ; } const [ , packageName , name , version ] = matches ; const installDir = `template` ; if ( await mkdirSafeP ( installDir ) ) { await spawnP ( 's' , [ 's' , 's' ] , { cwd : installDir } ) ; await spawnP ( 's' , [ 's' , `template` ] , { cwd : installDir } ) ; await writeFileP ( `template` , `template` , 's' ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as cpy from 's' ; import * as path from 's' ; import { BUILD_DIRECTORY , statP , spawnP , readFileP , writeFileP , mkdirP } from 's' ; import { readdir } from 's' ; import { promisify } from 's' ; import * as semver from 's' ; const readdirP : ( path ) => Promise < string [ ] > = promisify ( readdir ) ; export async function initTestFixtures ( installPlugins ) { const fixtureDirectories = [ 's' ] ; for ( const fixtureDirectory of fixtureDirectories ) { const newLocation = `template` ; await cpy ( `template` , BUILD_DIRECTORY , { parents : true } ) ; } ; if ( ! installPlugins ) { return ; } const packageFixtures = JSON . parse ( await readFileP ( 's' , 's' ) as string ) ; await mkdirP ( 's' ) . catch ( ( e : { code ? : string } ) => { if ( e . code !== 's' ) { throw e ; } } ) ; for ( const packageName in packageFixtures ) { const packageDirectory = `template` ; let fixtureExists = true ; try { await statP ( packageDirectory ) ; } catch { fixtureExists = false ; } const packageFixture = packageFixtures [ packageName ] ; const supportedNodeVersions = ( packageFixture . engines && packageFixture . engines . node ) || 's' ; if ( semver . satisfies ( process . version , supportedNodeVersions ) ) { if ( ! fixtureExists ) { await mkdirP ( packageDirectory ) ; await writeFileP ( `template` , JSON . stringify ( Object . assign ( { name : packageName , version : 's' , main : 's' } , packageFixture ) , null , 0 ) ) ; const mainModule = packageFixture . _mainModule || Object . keys ( packageFixture . dependencies ) [ 0 ] ; await writeFileP ( `template` , `template` ) ; console . log ( `template` ) ; await spawnP ( 's' , [ 's' , 's' ] , { cwd : packageDirectory } ) ; } else { let reinstallGrpc = ! fixtureExists ; const extBinDirectory = `template` ; try { await statP ( extBinDirectory ) ; const files = await readdirP ( extBinDirectory ) ; const modulesVersions = files . map ( file => file . match ( "s" ) ) . filter ( x => x ) . map ( matches => matches ! [ 0 ] ) ; if ( ! modulesVersions . some ( version => version === process . versions . modules ) ) { reinstallGrpc = true ; } } catch { } if ( reinstallGrpc ) { console . log ( `template` ) ; const grpcPackageJson = JSON . parse ( await readFileP ( `template` , 's' ) as string ) ; await spawnP ( 's' , [ 's' , `template` ] , { cwd : packageDirectory } ) ; } else { console . log ( `template` ) ; } } } else { console . log ( `template` ) ; } } ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BUILD_DIRECTORY , nodule , forkP } from 's' ; import * as path from 's' ; export async function reportCoverage ( ) { await forkP ( nodule ( 's' ) , [ `template` ] , { cwd : BUILD_DIRECTORY } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' ; import { globP , forkP , BUILD_DIRECTORY } from 's' ; export interface Options { includeGlobs : string [ ] , excludeGlobs ? : string [ ] , rootDir : string , coverage ? : boolean , timeout ? : number } export async function runTests ( options ) { const { includeGlobs , excludeGlobs , rootDir , coverage , timeout } = options ; function nodule ( nodule ) { return path . relative ( rootDir , `template` ) ; } let testNum = 0 ; const excludedFiles = ( [ ] as string [ ] ) . concat ( ... await Promise . all ( ( excludeGlobs || [ ] ) . map ( glob => globP ( glob ) ) ) ) ; const includedFiles = ( [ ] as string [ ] ) . concat ( ... await Promise . all ( includeGlobs . map ( glob => globP ( glob ) ) ) ) ; const files = includedFiles . filter ( i => excludedFiles . indexOf ( i ) < 0 ) ; for ( const file of files ) { const moduleAndArgs = [ ... coverage ? [ nodule ( 's' ) , 's' , 's' , 's' , `template` , 's' , 's' , 's' , 's' , 's' , 's' , ] : [ ] , nodule ( 's' ) , 's' , 's' , path . relative ( rootDir , file ) , ... timeout ? [ 's' , `template` ] : [ 's' ] ] ; await forkP ( moduleAndArgs [ 0 ] , moduleAndArgs . slice ( 0 ) , { cwd : rootDir } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Options$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { forkP , globP } from 's' ; export async function testNonInterference ( ) { console . log ( 's' ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O
const [ , , ... steps ] = process . argv ; const { CIRCLE_PR_NUMBER , TRACE_TEST_EXCLUDE_INTEGRATION , TRACE_SYSTEM_TEST_ENCRYPTED_CREDENTIALS_KEY , TRACE_SYSTEM_TEST_ENCRYPTED_CREDENTIALS_IV } = process . env ; import { checkInstall } from 's' ; import { compile } from 's' ; import { encryptCredentials , decryptCredentials } from 's' ; import { getPluginTypes } from 's' ; import { initTestFixtures } from 's' ; import { reportCoverage } from 's' ; import { runTests } from 's' ; import { testNonInterference } from 's' ; import { BUILD_DIRECTORY , existsP , spawnP } from 's' ; const projectID = 's' ; const keyID = 's' ; const unitTestExcludeGlobs : string [ ] = TRACE_TEST_EXCLUDE_INTEGRATION ? [ `template` , `template` , `template` , `template` , `template` , `template` , `template` , `template` , `template` ] : [ ] ; async function run ( steps : string [ ] ) { for ( const step of steps ) { console . log ( `template` ) ; if ( step . indexOf ( 's' ) === 0 ) { const moduleAndArgs = step . split ( 's' ) ; await spawnP ( 's' , [ 's' , moduleAndArgs . slice ( 0 ) . join ( 's' ) ] ) ; continue ; } else if ( step . startsWith ( 's' ) ) { const [ , languageLevel , strict ] = step . split ( 's' ) ; await compile ( { strict : ! ! strict , languageLevel } ) ; continue ; } else { switch ( step ) { case 's' : await checkInstall ( ) ; break ; case 's' : const keyAndIV = await encryptCredentials ( `template` ) ; console . log ( [ `template` , `template` ] . join ( 's' ) ) ; break ; case 's' : const key = TRACE_SYSTEM_TEST_ENCRYPTED_CREDENTIALS_KEY ; const iv = TRACE_SYSTEM_TEST_ENCRYPTED_CREDENTIALS_IV ; if ( ! key || ! iv ) { console . log ( 's' ) ; break ; } await decryptCredentials ( { key , iv } , `template` ) ; break ; case 's' : await getPluginTypes ( ) ; break ; case 's' : await initTestFixtures ( ! TRACE_TEST_EXCLUDE_INTEGRATION ) ; break ; case 's' : await runTests ( { includeGlobs : [ `template` , `template` ] , excludeGlobs : unitTestExcludeGlobs , rootDir : BUILD_DIRECTORY , coverage : false , timeout : 0 } ) ; break ; case 's' : await runTests ( { includeGlobs : [ `template` , `template` ] , excludeGlobs : unitTestExcludeGlobs , rootDir : BUILD_DIRECTORY , coverage : true , timeout : 0 } ) ; break ; case 's' : if ( CIRCLE_PR_NUMBER ) { console . log ( 's' ) ; } else { await spawnP ( 's' , [ 's' ] , { cwd : 's' } ) ; await runTests ( { includeGlobs : [ `template` , ] , rootDir : 's' , coverage : false } ) ; } break ; case 's' : await reportCoverage ( ) ; break ; case 's' : await testNonInterference ( ) ; break ; default : console . log ( `template` ) ; break ; } } } } run ( steps ) . catch ( ( err ) => { console . error ( err ) ; process . exit ( 0 ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' ; export type Func < T = void > = ( ... args : any [ ] ) => T ; export interface CLS < Context extends { } > { isEnabled ( ) : boolean ; enable ( ) : void ; disable ( ) : void ; getContext ( ) : Context ; runWithContext < T > ( fn < T > , value ) : T ; bindWithCurrentContext < T > ( fn < T > ) : Func < T > ; patchEmitterToPropagateContext ( ee ) : void ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Func$ O O O O $Context$ O O O O O O O O O $Func$ O O O O O O O O O O O O $EventEmitter$ O O O O O
import * as asyncHooksModule from 's' ; import { EventEmitter } from 's' ; import * as shimmer from 's' ; import { CLS , Func } from 's' ; type AsyncHooksModule = typeof asyncHooksModule ; const EVENT_EMITTER_METHODS < keyof EventEmitter > = [ 's' , 's' , 's' , 's' , 's' , ] ; const WRAPPED = Symbol ( 's' ) ; type ContextWrapped < T > = T & { [ WRAPPED ] ? : boolean } ; export class AsyncHooksCLS < Context extends { } > implements CLS < Context > { private ah : AsyncHooksModule ; private contexts : { [ id ] : Context } = { } ; private hook : asyncHooksModule . AsyncHook ; private enabled = false ; constructor ( private readonly defaultContext ) { this . ah = require ( 's' ) as AsyncHooksModule ; this . hook = this . ah . createHook ( { init : ( id , type , triggerId , resource : { } ) => { if ( type === 's' ) { const currentId = this . ah . executionAsyncId ( ) ; if ( this . contexts [ currentId ] !== undefined ) { this . contexts [ id ] = this . contexts [ currentId ] ; } } else { if ( this . contexts [ triggerId ] !== undefined ) { this . contexts [ id ] = this . contexts [ triggerId ] ; } } } , destroy : ( id ) => { delete this . contexts [ id ] ; } , promiseResolve : ( id ) => { delete this . contexts [ id ] ; } , } ) ; } isEnabled ( ) { return this . enabled ; } enable ( ) { this . contexts = { } ; this . hook . enable ( ) ; this . enabled = true ; } disable ( ) { this . contexts = { } ; this . hook . disable ( ) ; this . enabled = false ; } getContext ( ) { return this . contexts [ this . ah . executionAsyncId ( ) ] || this . defaultContext ; } runWithContext < T > ( fn < T > , value ) : T { const id = this . ah . executionAsyncId ( ) ; const oldContext = this . contexts [ id ] ; this . contexts [ id ] = value ; try { return fn ( ) ; } finally { this . contexts [ id ] = oldContext ; } } bindWithCurrentContext < T > ( fn < T > ) < T > { if ( ( fn as ContextWrapped < Func < T > > ) [ WRAPPED ] ) { return fn ; } const boundContext = this . contexts [ this . ah . executionAsyncId ( ) ] ; if ( ! boundContext ) { return fn ; } const that = this ; const contextWrapper < Func < T > > = function ( this : { } ) { return that . runWithContext ( ( ) => fn . apply ( this , arguments ) as T , boundContext ) ; } ; contextWrapper [ WRAPPED ] = true ; Object . defineProperty ( contextWrapper , 's' , { enumerable : false , configurable : true , writable : false , value : fn . length , } ) ; return contextWrapper ; } patchEmitterToPropagateContext ( ee ) { const that = this ; EVENT_EMITTER_METHODS . forEach ( method => { if ( ee [ method ] ) { shimmer . wrap ( ee , method , oldMethod => { return function ( this : { } , event , cb < void > ) { return oldMethod . call ( this , event , that . bindWithCurrentContext ( cb ) ) ; } ; } ) ; } } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O $Context$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O $Context$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $Func$ O O O O $Context$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Func$ O O O O $Func$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ContextWrapped$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $EventEmitter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $Func$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as clsModule from 's' ; import { EventEmitter } from 's' ; import { CLS , Func } from 's' ; type CLSModule = typeof clsModule ; export class AsyncListenerCLS < Context extends { } > implements CLS < Context > { static readonly TRACE_NAMESPACE = 's' ; static readonly ROOT_CONTEXT_KEY = 's' ; private readonly cls : CLSModule ; private readonly defaultContext : Context ; constructor ( defaultContext ) { this . cls = require ( 's' ) ; this . defaultContext = defaultContext ; } isEnabled ( ) { return ! ! this . getNamespace ( ) ; } enable ( ) { this . cls . createNamespace ( AsyncListenerCLS . TRACE_NAMESPACE ) ; } disable ( ) { this . cls . destroyNamespace ( AsyncListenerCLS . TRACE_NAMESPACE ) ; } private getNamespace ( ) : clsModule . Namespace { return this . cls . getNamespace ( AsyncListenerCLS . TRACE_NAMESPACE ) ; } getContext ( ) { const result = this . getNamespace ( ) . get ( AsyncListenerCLS . ROOT_CONTEXT_KEY ) ; if ( result ) { return result ; } return this . defaultContext ; } runWithContext < T > ( fn < T > , value ) : T { const namespace = this . getNamespace ( ) ; return namespace . runAndReturn ( ( ) => { namespace . set ( AsyncListenerCLS . ROOT_CONTEXT_KEY , value ) ; return fn ( ) ; } ) ; } bindWithCurrentContext < T > ( fn < T > ) < T > { return this . getNamespace ( ) . bind ( fn ) as Func < T > ; } patchEmitterToPropagateContext ( ee ) { return this . getNamespace ( ) . bindEmitter ( ee ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Context$ O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Context$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Func$ O O O O $Context$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Func$ O O O O $Func$ O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $EventEmitter$ O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' ; import { CLS , Func } from 's' ; export class NullCLS < Context > implements CLS < Context > { private enabled = false ; constructor ( private readonly defaultContext ) { } isEnabled ( ) { return this . enabled ; } enable ( ) { this . enabled = true ; } disable ( ) { this . enabled = false ; } getContext ( ) { return this . defaultContext ; } runWithContext < T > ( fn < T > ) : T { return fn ( ) ; } bindWithCurrentContext < T > ( fn < T > ) < T > { return fn ; } patchEmitterToPropagateContext ( ee ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Context$ O O O $boolean$ O O O O O O O O O $void$ O O O O O O O O O O $void$ O O O O O O O O O O $Context$ O O O O O O O O O O O O O O $Func$ O O O O O O O O O O O O O $Func$ O O O O $Func$ O O O O O O O O O O O O $void$ O $EventEmitter$ O O O O
import { EventEmitter } from 's' ; import { CLS , Func } from 's' ; export class SingularCLS < Context > implements CLS < Context > { private enabled = false ; private currentContext : Context ; constructor ( private readonly defaultContext ) { this . currentContext = this . defaultContext ; } isEnabled ( ) { return this . enabled ; } enable ( ) { this . enabled = true ; } disable ( ) { this . enabled = false ; this . currentContext = this . defaultContext ; } getContext ( ) { return this . currentContext ; } runWithContext < T > ( fn < T > , value ) : T { this . currentContext = value ; return fn ( ) ; } bindWithCurrentContext < T > ( fn < T > ) < T > { return fn ; } patchEmitterToPropagateContext ( ee ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Context$ O O O O O O O O O O O $boolean$ O O O O O O O O O $void$ O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O $Context$ O O O O O O O O O O O O O O $Func$ O O O O $Context$ O O O O O O O O O O O O O O O O $Func$ O O O O $Func$ O O O O O O O O O O O O $void$ O $EventEmitter$ O O O O
export const Constants = { TRACE_CONTEXT_GRPC_METADATA_NAME : 's' , TRACE_CONTEXT_HEADER_NAME : 's' , TRACE_AGENT_REQUEST_HEADER : 's' , TRACE_OPTIONS_TRACE_ENABLED : 0 << 0 , TRACE_SERVICE_SPAN_NAME_LIMIT : 0 , TRACE_SERVICE_LABEL_KEY_LIMIT : 0 , TRACE_SERVICE_LABEL_VALUE_LIMIT : 0 * 0 - 0 , } ; export enum SpanType { UNCORRELATED = 's' , DISABLED = 's' , UNSAMPLED = 's' , ROOT = 's' , CHILD = 's' , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' ; const pluginDirectory = path . join ( path . resolve ( __dirname , 's' ) , 's' , 's' ) ; export type CLSMechanism = | 's' | 's' | 's' | 's' | 's' ; export type ContextHeaderBehavior = 's' | 's' | 's' ; export interface RequestDetails { timestamp : number ; url : string ; method : string ; traceContext : { traceId : string ; spanId : string ; options : number } | null ; options : { } ; } export interface TracePolicy { shouldTrace : ( requestDetails ) => boolean ; } export interface GetHeaderFunction { getHeader : ( key ) => string [ ] | string | undefined ; } export interface SetHeaderFunction { setHeader : ( key , value ) => void ; } export interface OpenCensusPropagation { extract : ( getHeader ) => { traceId : string ; spanId : string ; options ? : number ; } | null ; inject : ( setHeader , traceContext : { traceId : string ; spanId : string ; options ? : number ; } ) => void ; } export interface Config { logLevel ? : number ; disableUntracedModulesWarning ? : boolean ; enabled ? : boolean ; enhancedDatabaseReporting ? : boolean ; rootSpanNameOverride ? : string | ( ( name ) => string ) ; clsMechanism ? : CLSMechanism ; spansPerTraceSoftLimit ? : number ; spansPerTraceHardLimit ? : number ; maximumLabelValueSize ? : number ; plugins ? : { [ pluginName ] : string } ; stackTraceLimit ? : number ; ignoreUrls ? : Array < string | RegExp > ; ignoreMethods ? : string [ ] ; samplingRate ? : number ; contextHeaderBehavior ? : ContextHeaderBehavior ; tracePolicy ? : TracePolicy ; propagation ? : OpenCensusPropagation ; flushDelaySeconds ? : number ; bufferSize ? : number ; onUncaughtException ? : string ; projectId ? : string ; credentials ? : { client_email ? : string ; private_key ? : string } ; keyFilename ? : string ; serviceContext ? : { service ? : string ; version ? : string ; minorVersion ? : string ; } ; } export const defaultConfig = { logLevel : 0 , disableUntracedModulesWarning : false , enabled : true , enhancedDatabaseReporting : false , rootSpanNameOverride : ( name ) => name , clsMechanism : 's' as CLSMechanism , spansPerTraceSoftLimit : 0 , spansPerTraceHardLimit : 0 , maximumLabelValueSize : 0 , plugins : { bluebird : path . join ( pluginDirectory , 's' ) , connect : path . join ( pluginDirectory , 's' ) , express : path . join ( pluginDirectory , 's' ) , 's' : path . join ( pluginDirectory , 's' ) , grpc : path . join ( pluginDirectory , 's' ) , hapi : path . join ( pluginDirectory , 's' ) , 's' : path . join ( pluginDirectory , 's' ) , http : path . join ( pluginDirectory , 's' ) , 0 : path . join ( pluginDirectory , 's' ) , koa : path . join ( pluginDirectory , 's' ) , mongodb : path . join ( pluginDirectory , 's' ) , 's' : path . join ( pluginDirectory , 's' ) , mongoose : path . join ( pluginDirectory , 's' ) , mysql : path . join ( pluginDirectory , 's' ) , 0 : path . join ( pluginDirectory , 's' ) , pg : path . join ( pluginDirectory , 's' ) , redis : path . join ( pluginDirectory , 's' ) , restify : path . join ( pluginDirectory , 's' ) , } , stackTraceLimit : 0 , flushDelaySeconds : 0 , ignoreUrls : [ 's' ] , ignoreMethods : [ ] , samplingRate : 0 , contextHeaderBehavior : 's' , bufferSize : 0 , onUncaughtException : 's' , serviceContext : { } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RequestDetails$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O $GetHeaderFunction$ O O O O O O O O O O O O O O O O O O O O O O O $SetHeaderFunction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as consoleLogLevel from 's' ; import { defaultConfig } from 's' ; export type ConsoleLogLevel = 's' | 's' | 's' | 's' ; export type LogLevel = 's' | ConsoleLogLevel ; export const LEVELS < LogLevel > = [ 's' , 's' , 's' , 's' , 's' , ] ; export interface LoggerConfig { level : string | false ; tag : string ; } function logLevelToName ( level ? ) { if ( typeof level === 's' ) { level = Number ( level ) ; } if ( typeof level !== 's' ) { level = defaultConfig . logLevel ; } if ( level < 0 ) level = 0 ; if ( level >= LEVELS . length ) level = LEVELS . length - 0 ; return LEVELS [ level ] ; } export class Logger { private logger : consoleLogLevel . Logger | null ; constructor ( opts ? < LoggerConfig > ) { const levelName = opts && opts . level !== undefined ? opts . level : logLevelToName ( defaultConfig . logLevel ) ; if ( levelName === false || levelName === 's' ) { this . logger = null ; return ; } this . logger = consoleLogLevel ( { stderr : true , prefix : `template` , level : levelName as ConsoleLogLevel , } ) ; } error ( ... args < { } > ) { if ( this . logger ) { this . logger . error ( ... args ) ; } } warn ( ... args < { } > ) { if ( this . logger ) { this . logger . warn ( ... args ) ; } } debug ( ... args < { } > ) { if ( this . logger ) { this . logger . debug ( ... args ) ; } } info ( ... args < { } > ) { if ( this . logger ) { this . logger . info ( ... args ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ReadonlyArray$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogLevel$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O
export enum SpanKind { SPAN_KIND_UNSPECIFIED = 's' , RPC_SERVER = 's' , RPC_CLIENT = 's' , } export interface TraceSpan { labels : { [ key ] : string } ; startTime : string ; endTime : string ; kind : SpanKind ; name : string ; spanId : string ; parentSpanId ? : string ; } export interface Trace { projectId : string ; traceId : string ; spans : TraceSpan [ ] ; }	O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const TraceLabels = { HTTP_RESPONSE_CODE_LABEL_KEY : 's' , HTTP_URL_LABEL_KEY : 's' , HTTP_METHOD_LABEL_KEY : 's' , HTTP_RESPONSE_SIZE_LABEL_KEY : 's' , STACK_TRACE_DETAILS_KEY : 's' , ERROR_DETAILS_NAME : 's' , ERROR_DETAILS_MESSAGE : 's' , GAE_VERSION : 's' , GAE_MODULE_NAME : 's' , GAE_MODULE_VERSION : 's' , GCE_INSTANCE_ID : 's' , GCE_HOSTNAME : 's' , HTTP_SOURCE_IP : 's' , AGENT_DATA : 's' , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' ; import * as sourceMapSupport from 's' ; const { hexToDec , decToHex , } : { [ key ] : ( input ) => string } = require ( 's' ) ; export { hexToDec , decToHex } ; export const kSingleton = Symbol ( ) ; export interface StackFrame { class_name ? : string ; method_name ? : string ; file_name ? : string ; line_number ? : number ; column_number ? : number ; } export interface Constructor < T , ConfigType , LoggerType > { new ( config , logger ) : T ; prototype : T ; name : string ; } export const FORCE_NEW = Symbol ( 's' ) ; export type Forceable < T > = T & { [ FORCE_NEW ] ? : boolean } ; export interface Component { enable ( ) : void ; disable ( ) : void ; } export class Singleton < T , ConfigType , LoggerType > { private [ kSingleton ] : T | null = null ; constructor ( private implementation < T , ConfigType , LoggerType > ) { } create ( config < ConfigType > , logger ) : T { if ( ! this [ kSingleton ] || config [ FORCE_NEW ] ) { const s = this [ kSingleton ] as Partial < Component > ; if ( s && s . disable ) { s . disable ( ) ; } this [ kSingleton ] = new this . implementation ( config , logger ) ; return this [ kSingleton ] ! ; } else { throw new Error ( `template` ) ; } } get ( ) : T { if ( ! this [ kSingleton ] ) { throw new Error ( `template` ) ; } return this [ kSingleton ] ! ; } exists ( ) { return ! ! this [ kSingleton ] ; } } export function lastOf < T > ( defaultValue : T , ... otherValues < T | null | undefined > ) : T { for ( let i = otherValues . length - 0 ; i >= 0 ; i -- ) { if ( otherValues [ i ] !== null && otherValues [ i ] !== undefined && ( typeof otherValues [ i ] !== 's' || ! isNaN ( otherValues [ i ] as any ) ) ) { return otherValues [ i ] as T ; } } return defaultValue ; } export function truncate ( str , length ) { if ( Buffer . byteLength ( str , 's' ) <= length ) { return str ; } str = str . substr ( 0 , length - 0 ) ; while ( Buffer . byteLength ( str , 's' ) > length - 0 ) { str = str . substr ( 0 , str . length - 0 ) ; } return str + 's' ; } const moduleRegex = new RegExp ( [ 's' , 's' , 's' , 's' , 's' , 's' , ] . join ( path . sep ) ) ; export interface TraceContext { traceId : string ; spanId : string ; options ? : number ; } export function parseContextFromHeader ( str ) : TraceContext | null { if ( ! str ) { return null ; } const matches = str . match ( "s" ) ; if ( ! matches || matches . length !== 0 || matches [ 0 ] !== str || ( matches [ 0 ] && isNaN ( Number ( matches [ 0 ] ) ) ) ) { return null ; } return { traceId : matches [ 0 ] , spanId : matches [ 0 ] , options : isNaN ( Number ( matches [ 0 ] ) ) ? undefined : Number ( matches [ 0 ] ) , } ; } export function generateTraceContext ( traceContext ) { if ( ! traceContext ) { return 's' ; } let header = `template` ; if ( typeof traceContext . options !== 's' ) { header += `template` ; } return header ; } export function packageNameFromPath ( importPath ) { const matches = moduleRegex . exec ( importPath ) ; return matches && matches . length > 0 ? matches [ 0 ] : null ; } export function createStackTrace ( numFrames , skipFrames , constructorOpt ? ) : StackFrame [ ] { if ( numFrames === 0 ) { return [ ] ; } const origLimit = Error . stackTraceLimit ; Error . stackTraceLimit = numFrames + skipFrames ; const origPrepare = Error . prepareStackTrace ; Error . prepareStackTrace = ( error , structured : NodeJS . CallSite [ ] ) : NodeJS . CallSite [ ] => { return structured . map ( sourceMapSupport . wrapCallSite ) ; } ; const e : { stack ? : NodeJS . CallSite [ ] } = { } ; Error . captureStackTrace ( e , constructorOpt ) ; const stackFrames : StackFrame [ ] = [ ] ; if ( e . stack ) { e . stack . forEach ( ( callSite , i ) => { if ( i < skipFrames ) { return ; } const functionName = callSite . getFunctionName ( ) ; const methodName = callSite . getMethodName ( ) ; const name = methodName && functionName ? functionName + 's' + methodName + 's' : functionName || methodName || 's' ; const stackFrame = { method_name : name , file_name : callSite . getFileName ( ) || undefined , line_number : callSite . getLineNumber ( ) || undefined , column_number : callSite . getColumnNumber ( ) || undefined , } ; stackFrames . push ( stackFrame ) ; } ) ; } Error . stackTraceLimit = origLimit ; Error . prepareStackTrace = origPrepare ; return stackFrames ; } export function serializeTraceContext ( traceContext ) { const result = Buffer . alloc ( 0 , 0 ) ; result . write ( traceContext . traceId , 0 , 0 , 's' ) ; result . 0 ( 0 , 0 ) ; const 0 = `template` . slice ( - 0 ) ; result . write ( 0 , 0 , 0 , 's' ) ; result . 0 ( 0 , 0 ) ; result . 0 ( traceContext . options || 0 , 0 ) ; return result ; } export function deserializeTraceContext ( buffer ) : TraceContext | null { const result = { traceId : 's' , spanId : 's' } ; if ( buffer . length !== 0 ) { return null ; } if ( buffer . 0 ( 0 ) !== 0 || buffer . 0 ( 0 ) !== 0 || buffer . 0 ( 0 ) !== 0 || buffer . 0 ( 0 ) !== 0 ) { return null ; } result . traceId = buffer . slice ( 0 , 0 ) . toString ( 's' ) ; result . spanId = hexToDec ( buffer . slice ( 0 , 0 ) . toString ( 's' ) ) ; result . options = buffer . 0 ( 0 ) ; return result ; }	O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigType$ O $LoggerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Constructor$ O O O O O O O O O O O O $Forceable$ O O O O $LoggerType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $TraceContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StackFrame$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O $TraceContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O $TraceContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as gcpMetadata from 's' ; import { OutgoingHttpHeaders } from 's' ; import * as os from 's' ; import { Constants } from 's' ; import { Logger } from 's' ; import { SpanKind , Trace } from 's' ; import { TraceLabels } from 's' ; import { Singleton } from 's' ; import { DecorateRequestOptions , GoogleAuthOptions , Service , } from 's' ; const pjson = require ( 's' ) ; const NO_PROJECT_ID_TOKEN = 's' ; const onUncaughtExceptionValues = [ 's' , 's' , 's' ] ; const headers = { } ; headers [ Constants . TRACE_AGENT_REQUEST_HEADER ] = 0 ; const SCOPES : string [ ] = [ 's' ] ; const TRACE_API_ENDPOINT = 's' ; export interface TraceWriterConfig { authOptions : GoogleAuthOptions ; onUncaughtException : string ; bufferSize : number ; flushDelaySeconds : number ; stackTraceLimit : number ; maximumLabelValueSize : number ; serviceContext : { service ? : string ; version ? : string ; minorVersion ? : string } ; } export interface LabelObject { [ key ] : string ; } export class TraceBuffer { private traces : Trace [ ] = [ ] ; private numSpans = 0 ; add ( trace ) { this . traces . push ( trace ) ; this . numSpans += trace . spans . length ; } getNumSpans ( ) { return this . numSpans ; } drain ( ) : Trace [ ] { const result = this . traces ; this . traces = [ ] ; this . numSpans = 0 ; return result ; } } export class TraceWriter extends Service { protected buffer : TraceBuffer ; defaultLabels : LabelObject ; private unhandledException ? : ( ) => void ; isActive : boolean ; constructor ( private readonly config , private readonly logger ) { super ( { packageJson : pjson , projectIdRequired : false , apiEndpoint : TRACE_API_ENDPOINT , baseUrl : `template` , scopes : SCOPES , } , config . authOptions ) ; this . logger = logger ; this . buffer = new TraceBuffer ( ) ; this . defaultLabels = { } ; this . isActive = true ; if ( onUncaughtExceptionValues . indexOf ( config . onUncaughtException ) === - 0 ) { logger . error ( `template` ) ; throw new Error ( 's' ) ; } const onUncaughtException = config . onUncaughtException ; if ( onUncaughtException !== 's' ) { this . unhandledException = ( ) => { this . flushBuffer ( ) ; if ( onUncaughtException === 's' ) { setTimeout ( ( ) => { process . exit ( 0 ) ; } , 0 ) ; } } ; process . on ( 's' , this . unhandledException ) ; } } stop ( ) { this . isActive = false ; } getConfig ( ) { return this . config ; } async initialize ( ) < void > { const getProjectIdAndScheduleFlush = async ( ) => { try { await this . getProjectId ( ) ; } catch ( err ) { this . logger . error ( 's' , 's' , 's' , `template` ) ; throw err ; } this . scheduleFlush ( ) ; } ; const [ hostname , instanceId ] = await Promise . all ( [ this . getHostname ( ) , this . getInstanceId ( ) , getProjectIdAndScheduleFlush ( ) , ] ) ; const addDefaultLabel = ( key , value : string | number ) => { this . defaultLabels [ key ] = `template` ; } ; this . defaultLabels = { } ; addDefaultLabel ( TraceLabels . AGENT_DATA , `template` ) ; addDefaultLabel ( TraceLabels . GCE_HOSTNAME , hostname ) ; if ( instanceId ) { addDefaultLabel ( TraceLabels . GCE_INSTANCE_ID , instanceId ) ; } const moduleName = this . config . serviceContext . service || hostname ; addDefaultLabel ( TraceLabels . GAE_MODULE_NAME , moduleName ) ; const moduleVersion = this . config . serviceContext . version ; if ( moduleVersion ) { addDefaultLabel ( TraceLabels . GAE_MODULE_VERSION , moduleVersion ) ; const minorVersion = this . config . serviceContext . minorVersion ; if ( minorVersion ) { let versionLabel = 's' ; if ( moduleName !== 's' ) { versionLabel = moduleName + 's' ; } versionLabel += moduleVersion + 's' + minorVersion ; addDefaultLabel ( TraceLabels . GAE_VERSION , versionLabel ) ; } } Object . freeze ( this . defaultLabels ) ; } private async getHostname ( ) < string > { try { return await gcpMetadata . instance ( { property : 's' , headers } ) ; } catch ( err ) { if ( err . code !== 's' ) { this . logger . warn ( 's' , 's' , `template` ) ; } return os . hostname ( ) ; } } private async getInstanceId ( ) < number | null > { try { return await gcpMetadata . instance ( { property : 's' , headers } ) ; } catch ( err ) { if ( err . code !== 's' ) { this . logger . warn ( 's' , 's' , `template` ) ; } return null ; } } getProjectId ( ) { if ( this . projectId !== NO_PROJECT_ID_TOKEN ) { return Promise . resolve ( this . projectId ) ; } return super . getProjectId ( ) ; } writeTrace ( trace ) { const publishableSpans = trace . spans . filter ( span => ! ! span . endTime ) ; publishableSpans . forEach ( spanData => { if ( spanData . kind === SpanKind . RPC_SERVER ) { Object . assign ( spanData . labels , this . defaultLabels ) ; } } ) ; this . buffer . add ( { traceId : trace . traceId , projectId : trace . projectId , spans : publishableSpans , } ) ; this . logger . info ( `template` ) ; if ( this . buffer . getNumSpans ( ) >= this . config . bufferSize ) { this . logger . info ( 's' ) ; setImmediate ( ( ) => this . flushBuffer ( ) ) ; } } private scheduleFlush ( ) { this . logger . info ( 's' ) ; this . flushBuffer ( ) ; if ( this . isActive ) { global . setTimeout ( this . scheduleFlush . bind ( this ) , this . config . flushDelaySeconds * 0 ) . unref ( ) ; } } private flushBuffer ( ) { const flushedTraces = this . buffer . drain ( ) ; if ( flushedTraces . length === 0 ) { return ; } const afterProjectId = ( projectId ) => { flushedTraces . forEach ( trace => ( trace . projectId = projectId ) ) ; this . logger . debug ( 's' , flushedTraces ) ; this . publish ( JSON . stringify ( { traces : flushedTraces } ) ) ; } ; if ( this . projectId !== NO_PROJECT_ID_TOKEN ) { afterProjectId ( this . projectId ) ; } else { this . getProjectId ( ) . then ( afterProjectId , ( err ) => { this . logger . info ( 's' ) ; } ) ; } } protected publish ( json ) { const hostname = 's' ; const uri = `template` ; const options = { method : 's' , uri , body : json , headers , } ; this . logger . info ( 's' + uri ) ; this . request ( options , ( err , body ? , response ? ) => { const statusCode = response && response . statusCode ; if ( err ) { this . logger . error ( `template` ) ; } else { this . logger . info ( `template` ) ; } } ) ; } } export const traceWriter = new Singleton ( TraceWriter ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OutgoingHttpHeaders$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $Trace$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceWriterConfig$ O O O $Logger$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O $TraceWriterConfig$ O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Trace$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $DecorateRequestOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as crypto from 's' ; import * as util from 's' ; import { Constants , SpanType } from 's' ; import { RootSpan , Span , SpanOptions , TraceContext } from 's' ; import { SpanKind , Trace , TraceSpan } from 's' ; import { TraceLabels } from 's' ; import { traceWriter } from 's' ; import * as traceUtil from 's' ; const SPAN_ID_RANDOM_BYTES = 0 ; const spanIdBuffer = Buffer . alloc ( SPAN_ID_RANDOM_BYTES ) ; const randomFillSync = crypto . randomFillSync ; const randomBytes = crypto . randomBytes ; const spanRandomBuffer = randomFillSync ? ( ) => randomFillSync ( spanIdBuffer ) : ( ) => randomBytes ( SPAN_ID_RANDOM_BYTES ) ; function randomSpanId ( ) { return parseInt ( spanRandomBuffer ( ) . toString ( 's' ) , 0 ) . toString ( ) ; } export abstract class BaseSpanData implements Span { readonly span : TraceSpan ; abstract readonly type : SpanType ; constructor ( readonly trace , spanName , parentSpanId , skipFrames ) { this . span = { name : traceUtil . truncate ( spanName , Constants . TRACE_SERVICE_SPAN_NAME_LIMIT ) , startTime : new Date ( ) . toISOString ( ) , endTime : 's' , spanId : randomSpanId ( ) , kind : SpanKind . SPAN_KIND_UNSPECIFIED , parentSpanId , labels : { } , } ; this . trace . spans . push ( this . span ) ; const stackFrames = traceUtil . createStackTrace ( traceWriter . get ( ) . getConfig ( ) . stackTraceLimit , skipFrames , this . constructor ) ; if ( stackFrames . length > 0 ) { this . span . labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] = traceUtil . truncate ( JSON . stringify ( { stack_frame : stackFrames } ) , Constants . TRACE_SERVICE_LABEL_VALUE_LIMIT ) ; } } getTraceContext ( ) { return { traceId : this . trace . traceId . toString ( ) , spanId : this . span . spanId . toString ( ) , options : 0 , } ; } addLabel ( key , value ) { const k = traceUtil . truncate ( key , Constants . TRACE_SERVICE_LABEL_KEY_LIMIT ) ; const stringValue = typeof value === 's' ? value : util . inspect ( value ) ; const v = traceUtil . truncate ( stringValue , traceWriter . get ( ) . getConfig ( ) . maximumLabelValueSize ) ; this . span . labels [ k ] = v ; } endSpan ( timestamp ? ) { if ( ! ! this . span . endTime ) { return ; } timestamp = timestamp || new Date ( ) ; this . span . endTime = timestamp . toISOString ( ) ; } } export class RootSpanData extends BaseSpanData implements RootSpan { readonly type = SpanType . ROOT ; private children : ChildSpanData [ ] = [ ] ; constructor ( trace , spanName , parentSpanId , skipFrames ) { super ( trace , spanName , parentSpanId , skipFrames ) ; this . span . kind = SpanKind . RPC_SERVER ; } createChildSpan ( options ? ) { options = options || { name : 's' } ; const skipFrames = options . skipFrames ? options . skipFrames + 0 : 0 ; const child = new ChildSpanData ( this . trace , options . name , this . span . spanId , skipFrames ) ; this . children . push ( child ) ; return child ; } endSpan ( timestamp ? ) { if ( ! ! this . span . endTime ) { return ; } super . endSpan ( timestamp ) ; traceWriter . get ( ) . writeTrace ( this . trace ) ; this . children . forEach ( child => { if ( ! child . span . endTime ) { child . shouldSelfPublish = true ; } } ) ; this . children = [ ] ; } } export class ChildSpanData extends BaseSpanData { readonly type = SpanType . CHILD ; shouldSelfPublish = false ; constructor ( trace , spanName , parentSpanId , skipFrames ) { super ( trace , spanName , parentSpanId , skipFrames ) ; this . span . kind = SpanKind . RPC_CLIENT ; } endSpan ( timestamp ? ) { if ( ! ! this . span . endTime ) { return ; } super . endSpan ( timestamp ) ; if ( this . shouldSelfPublish ) { traceWriter . get ( ) . writeTrace ( { projectId : this . trace . projectId , traceId : this . trace . traceId , spans : [ this . span ] , } ) ; } } } function createPhantomSpanData < T extends SpanType > ( spanType : T ) : Span & { readonly type : T } { return Object . freeze ( Object . assign ( { getTraceContext ( ) { return null ; } , addLabel ( key , value ) { } , endSpan ( ) { } , } , { type : spanType } ) ) ; } class UntracedSpanData implements Span { readonly type = SpanType . UNSAMPLED ; protected readonly traceContext : TraceContext ; constructor ( traceId ) { this . traceContext = { traceId , spanId : randomSpanId ( ) , options : 0 , } ; } getTraceContext ( ) : traceUtil . TraceContext | null { return this . traceContext ; } addLabel ( ) { } endSpan ( ) { } } export class UntracedRootSpanData extends UntracedSpanData implements RootSpan { private child : Span | null = null ; createChildSpan ( ) { if ( ! this . child ) { this . child = new UntracedSpanData ( this . traceContext . traceId ) ; } return this . child ; } } export const UNCORRELATED_CHILD_SPAN = createPhantomSpanData ( SpanType . UNCORRELATED ) ; export const DISABLED_CHILD_SPAN = createPhantomSpanData ( SpanType . DISABLED ) ; export const UNCORRELATED_ROOT_SPAN = Object . freeze ( Object . assign ( { createChildSpan ( ) { return UNCORRELATED_CHILD_SPAN ; } , } , UNCORRELATED_CHILD_SPAN ) ) ; export const DISABLED_ROOT_SPAN = Object . freeze ( Object . assign ( { createChildSpan ( ) { return DISABLED_CHILD_SPAN ; } , } , DISABLED_CHILD_SPAN ) ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Trace$ O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Trace$ O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O $Span$ O O $SpanOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Trace$ O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $Date$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O $Span$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { RequestDetails , TracePolicy } from 's' ; import { Constants } from 's' ; import { TraceContext } from 's' ; export enum TraceContextHeaderBehavior { DEFAULT = 's' , REQUIRE = 's' , IGNORE = 's' , } interface TracePolicyPredicate < T > { shouldTrace : ( value : T ) => boolean ; } class Sampler implements TracePolicyPredicate < number > { private readonly traceWindow : number ; private nextTraceStart : number ; constructor ( samplesPerSecond ) { if ( samplesPerSecond > 0 ) { samplesPerSecond = 0 ; } this . traceWindow = 0 / samplesPerSecond ; this . nextTraceStart = Date . now ( ) ; } shouldTrace ( dateMillis ) { if ( dateMillis < this . nextTraceStart ) { return false ; } this . nextTraceStart = dateMillis + this . traceWindow ; return true ; } } class URLFilter implements TracePolicyPredicate < string > { constructor ( private readonly filterUrls < string | RegExp > ) { } shouldTrace ( url ) { return ! this . filterUrls . some ( candidate => { return ( ( typeof candidate === 's' && candidate === url ) || ! ! url . match ( candidate ) ) ; } ) ; } } class MethodsFilter implements TracePolicyPredicate < string > { constructor ( private readonly filterMethods : string [ ] ) { } shouldTrace ( method ) { return ! this . filterMethods . some ( candidate => { return candidate . toLowerCase ( ) === method . toLowerCase ( ) ; } ) ; } } class ContextHeaderFilter implements TracePolicyPredicate < Required < TraceContext > | null > { constructor ( private readonly contextHeaderBehavior ) { } shouldTrace ( header : Required < TraceContext > | null ) { switch ( this . contextHeaderBehavior ) { case TraceContextHeaderBehavior . IGNORE : { return true ; } case TraceContextHeaderBehavior . REQUIRE : { return ! ! ( header && header . options & Constants . TRACE_OPTIONS_TRACE_ENABLED ) ; } default : { return ! ! ( ! header || header . options & Constants . TRACE_OPTIONS_TRACE_ENABLED ) ; } } } } export interface TracePolicyConfig { samplingRate : number ; ignoreUrls : Array < string | RegExp > ; ignoreMethods : string [ ] ; contextHeaderBehavior : TraceContextHeaderBehavior ; } export class BuiltinTracePolicy implements TracePolicy { private readonly sampler : TracePolicyPredicate < number > ; private readonly urlFilter : TracePolicyPredicate < string > ; private readonly methodsFilter : TracePolicyPredicate < string > ; private readonly contextHeaderFilter : TracePolicyPredicate < Required < TraceContext > | null > ; constructor ( config ) { if ( config . samplingRate === 0 ) { this . sampler = { shouldTrace : ( ) => true } ; } else if ( config . samplingRate < 0 ) { this . sampler = { shouldTrace : ( ) => false } ; } else { this . sampler = new Sampler ( config . samplingRate ) ; } if ( config . ignoreUrls . length === 0 ) { this . urlFilter = { shouldTrace : ( ) => true } ; } else { this . urlFilter = new URLFilter ( config . ignoreUrls ) ; } if ( config . ignoreMethods . length === 0 ) { this . methodsFilter = { shouldTrace : ( ) => true } ; } else { this . methodsFilter = new MethodsFilter ( config . ignoreMethods ) ; } if ( config . contextHeaderBehavior === TraceContextHeaderBehavior . IGNORE ) { this . contextHeaderFilter = { shouldTrace : ( ) => true } ; } else { this . contextHeaderFilter = new ContextHeaderFilter ( config . contextHeaderBehavior ) ; } } shouldTrace ( options ) { return ( this . urlFilter . shouldTrace ( options . url ) && this . methodsFilter . shouldTrace ( options . method ) && this . contextHeaderFilter . shouldTrace ( options . traceContext ) && this . sampler . shouldTrace ( options . timestamp ) ) ; } } export function alwaysTrace ( ) { return new BuiltinTracePolicy ( { samplingRate : 0 , ignoreUrls : [ ] , ignoreMethods : [ ] , contextHeaderBehavior : TraceContextHeaderBehavior . DEFAULT , } ) ; } export function neverTrace ( ) { return new BuiltinTracePolicy ( { samplingRate : - 0 , ignoreUrls : [ ] , ignoreMethods : [ ] , contextHeaderBehavior : TraceContextHeaderBehavior . DEFAULT , } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceContextHeaderBehavior$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TracePolicyConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $RequestDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuiltinTracePolicy$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BuiltinTracePolicy$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' ; import * as uuid from 's' ; import { cls , RootContext } from 's' ; import { OpenCensusPropagation , TracePolicy } from 's' ; import { Constants , SpanType } from 's' ; import { Logger } from 's' ; import { Func , Propagation , RootSpan , RootSpanOptions , Span , SpanOptions , Tracer , } from 's' ; import { RootSpanData , UNCORRELATED_CHILD_SPAN , UNCORRELATED_ROOT_SPAN , DISABLED_CHILD_SPAN , DISABLED_ROOT_SPAN , UntracedRootSpanData , } from 's' ; import { TraceLabels } from 's' ; import { traceWriter } from 's' ; import { neverTrace } from 's' ; import * as util from 's' ; export interface StackdriverTracerConfig { enhancedDatabaseReporting : boolean ; rootSpanNameOverride : ( path ) => string ; spansPerTraceSoftLimit : number ; spansPerTraceHardLimit : number ; } export interface StackdriverTracerComponents { logger : Logger ; tracePolicy : TracePolicy ; propagation : OpenCensusPropagation ; } export class StackdriverTracer implements Tracer { readonly constants = Constants ; readonly labels = TraceLabels ; readonly spanTypes = SpanType ; readonly traceContextUtils = { encodeAsByteArray : util . serializeTraceContext , decodeFromByteArray : util . deserializeTraceContext , } ; readonly propagation : Propagation = { extract => { if ( ! this . enabled ) { return null ; } const result = this . headerPropagation ! . extract ( { getHeader : ( ... args ) => { const result = getHeader ( ... args ) ; if ( result === null ) { return ; } return result ; } , } ) ; if ( result ) { result . spanId = util . hexToDec ( result . spanId ) ; } return result ; } , inject : ( setHeader , value ) => { if ( ! this . enabled || ! value ) { return ; } value = Object . assign ( { } , value , { spanId : `template` . slice ( - 0 ) , } ) ; this . headerPropagation ! . inject ( { setHeader } , value ) ; } , } ; private enabled = false ; private pluginName : string ; private pluginNameToLog : string ; private logger : Logger | null = null ; private config : StackdriverTracerConfig | null = null ; private policy : TracePolicy | null = null ; private headerPropagation : OpenCensusPropagation | null = null ; constructor ( name ) { this . pluginName = name ; this . pluginNameToLog = this . pluginName ? this . pluginName : 's' ; this . disable ( ) ; } enable ( config , components ) { this . config = config ; this . logger = components . logger ; this . policy = components . tracePolicy ; this . headerPropagation = components . propagation ; this . enabled = true ; } disable ( ) { this . policy = neverTrace ( ) ; this . enabled = false ; } isActive ( ) { return this . enabled ; } enhancedDatabaseReportingEnabled ( ) { return ! ! this . config && this . config . enhancedDatabaseReporting ; } getConfig ( ) { if ( ! this . config ) { throw new Error ( 's' ) ; } return this . config ; } runInRootSpan < T > ( options , fn : ( span ) => T ) : T { if ( ! this . isActive ( ) ) { return fn ( DISABLED_ROOT_SPAN ) ; } options = options || { name : 's' } ; const rootSpan = cls . get ( ) . getContext ( ) ; if ( rootSpan . type === SpanType . ROOT && ! rootSpan . span . endTime ) { this . logger ! . warn ( `template` ) ; return fn ( UNCORRELATED_ROOT_SPAN ) ; } const canonicalizeTraceContext = ( traceContext ? : util . TraceContext | null ) => { if ( ! traceContext ) { return null ; } if ( traceContext . options !== undefined ) { return traceContext as Required < util . TraceContext > ; } return { traceId : traceContext . traceId , spanId : traceContext . spanId , options : 0 , } ; } ; const traceContext = canonicalizeTraceContext ( options . traceContext ) ; const shouldTrace = this . policy ! . shouldTrace ( { timestamp : Date . now ( ) , url : options . url || 's' , method : options . method || 's' , traceContext , options , } ) ; const traceId = traceContext ? traceContext . traceId : uuid . 0 ( ) . split ( 's' ) . join ( 's' ) ; let rootContext : RootSpan & RootContext ; if ( ! shouldTrace ) { rootContext = new UntracedRootSpanData ( traceId ) ; } else { rootContext = new RootSpanData ( { projectId : 's' , traceId , spans : [ ] , } , this . config ! . rootSpanNameOverride ( options . name ) , traceContext ? traceContext . spanId : 's' , options . skipFrames || 0 ) ; } return cls . get ( ) . runWithContext ( ( ) => { return fn ( rootContext ) ; } , rootContext ) ; } getCurrentRootSpan ( ) { if ( ! this . isActive ( ) ) { return DISABLED_ROOT_SPAN ; } return cls . get ( ) . getContext ( ) ; } getCurrentContextId ( ) : string | null { const traceContext = this . getCurrentRootSpan ( ) . getTraceContext ( ) ; return traceContext ? traceContext . traceId : null ; } getProjectId ( ) < string > { if ( traceWriter . exists ( ) && traceWriter . get ( ) . isActive ) { return traceWriter . get ( ) . getProjectId ( ) ; } else { return Promise . reject ( new Error ( 's' ) ) ; } } getWriterProjectId ( ) : string | null { if ( traceWriter . exists ( ) && traceWriter . get ( ) . isActive ) { return traceWriter . get ( ) . projectId ; } else { return null ; } } createChildSpan ( options ? ) { if ( ! this . isActive ( ) ) { return DISABLED_CHILD_SPAN ; } options = options || { name : 's' } ; const rootSpan = cls . get ( ) . getContext ( ) ; if ( rootSpan . type === SpanType . ROOT ) { if ( ! ! rootSpan . span . endTime ) { this . logger ! . warn ( `template` ) ; return UNCORRELATED_CHILD_SPAN ; } if ( rootSpan . trace . spans . length >= this . config ! . spansPerTraceHardLimit ) { this . logger ! . error ( `template` ) ; this . logger ! . error ( [ 's' , 's' , 's' , ] . join ( 's' ) ) ; return UNCORRELATED_CHILD_SPAN ; } if ( rootSpan . trace . spans . length === this . config ! . spansPerTraceSoftLimit ) { this . logger ! . error ( `template` ) ; this . logger ! . error ( [ 's' , 's' , 's' , ] . join ( 's' ) ) ; } const childContext = rootSpan . createChildSpan ( { name : options . name , skipFrames : options . skipFrames ? options . skipFrames + 0 : 0 , } ) ; this . logger ! . info ( `template` ) ; return childContext ; } else if ( rootSpan . type === SpanType . UNSAMPLED ) { return rootSpan . createChildSpan ( ) ; } else if ( rootSpan . type === SpanType . DISABLED ) { return DISABLED_CHILD_SPAN ; } else { this . logger ! . warn ( `template` ) ; return UNCORRELATED_CHILD_SPAN ; } } isRealSpan ( span ) { return span . type === SpanType . ROOT || span . type === SpanType . CHILD ; } getResponseTraceContext ( incomingTraceContext : util . TraceContext | null , isTraced ) { if ( ! this . isActive ( ) || ! incomingTraceContext ) { return null ; } return { traceId : incomingTraceContext . traceId , spanId : incomingTraceContext . spanId , options : ( incomingTraceContext . options || 0 ) & ( isTraced ? 0 : 0 ) , } ; } wrap < T > ( fn < T > ) < T > { if ( ! this . isActive ( ) ) { return fn ; } return cls . get ( ) . bindWithCurrentContext ( fn ) ; } wrapEmitter ( emitter ) { if ( ! this . isActive ( ) ) { return ; } cls . get ( ) . patchEmitterToPropagateContext ( emitter ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $getHeader$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StackdriverTracerConfig$ O $StackdriverTracerComponents$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O $StackdriverTracerConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RootSpanOptions$ O O O O $RootSpan$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RootSpan$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Span$ O O $SpanOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $Span$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Func$ O O O O $Func$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $EventEmitter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' ; import { Constants , SpanType } from 's' ; import { StackdriverTracerConfig } from 's' ; import { TraceLabels } from 's' ; import { TraceContext } from 's' ; export { TraceContext } ; export type Func < T > = ( ... args : any [ ] ) => T ; export interface TraceAgentExtension { _google_trace_patched : boolean ; } export interface Span { getTraceContext ( ) : TraceContext | null ; addLabel ( key , value ) : void ; readonly type : SpanType ; endSpan ( timestamp ? ) : void ; } export interface RootSpan extends Span { createChildSpan ( options ? ) : Span ; } export interface SpanOptions { name : string ; skipFrames ? : number ; } export interface RootSpanOptions extends SpanOptions { url ? : string ; method ? : string ; traceContext ? : TraceContext | null ; } export interface Tracer { enhancedDatabaseReportingEnabled ( ) : boolean ; getConfig ( ) : StackdriverTracerConfig ; runInRootSpan < T > ( options , fn : ( span ) => T ) : T ; getCurrentRootSpan ( ) : RootSpan ; getCurrentContextId ( ) : string | null ; getProjectId ( ) : Promise < string > ; getWriterProjectId ( ) : string | null ; createChildSpan ( options ? ) : Span ; isRealSpan ( span ) : boolean ; getResponseTraceContext ( incomingTraceContext : TraceContext | null , isTraced ) : TraceContext | null ; wrap < T > ( fn < T > ) : Func < T > ; wrapEmitter ( emitter ) : void ; readonly constants : typeof Constants ; readonly labels : typeof TraceLabels ; readonly spanTypes : typeof SpanType ; readonly traceContextUtils : { encodeAsByteArray : ( ctx ) => Buffer ; decodeFromByteArray : ( buf ) => TraceContext | null ; } ; readonly propagation : Propagation ; } export type GetHeaderFunction = ( key ) => string [ ] | string | null | undefined ; export type SetHeaderFunction = ( key , value ) => void ; export interface Propagation { extract : ( getHeader ) => TraceContext | null ; inject : ( setHeader , traceContext : TraceContext | null ) => void ; } export interface Monkeypatch < T > { file ? : string ; versions ? : string ; patch : ( module : T , agent ) => void ; unpatch ? : ( module : T ) => void ; } export interface Intercept < T > { file ? : string ; versions ? : string ; intercept : ( module : T , agent ) => T ; } export type Patch < T > = Monkeypatch < T > | Intercept < T > ; export type Plugin = Array < Patch < any > > ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O O $Date$ O O O O O O O O O O O O O O $SpanOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RootSpanOptions$ O O O O $RootSpan$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SpanOptions$ O O O O O O $Span$ O O O O O O O O O O O O $boolean$ O O O O O O O O O O O $Func$ O O O O O O O O O O O O $EventEmitter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceContext$ O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O $GetHeaderFunction$ O O O O O O O O O $SetHeaderFunction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Tracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Tracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' ; import * as semver from 's' ; import { AsyncHooksCLS } from 's' ; import { AsyncListenerCLS } from 's' ; import { CLS , Func } from 's' ; import { NullCLS } from 's' ; import { SingularCLS } from 's' ; import { SpanType } from 's' ; import { Logger } from 's' ; import { RootSpan } from 's' ; import { UNCORRELATED_ROOT_SPAN , DISABLED_ROOT_SPAN } from 's' ; import { Trace , TraceSpan } from 's' ; import { Singleton } from 's' ; const asyncHooksAvailable = semver . satisfies ( process . version , 's' ) ; export interface RealRootContext { readonly span : TraceSpan ; readonly trace : Trace ; readonly type : SpanType . ROOT ; } export interface PhantomRootContext { readonly type : SpanType . UNCORRELATED | SpanType . UNSAMPLED | SpanType . DISABLED ; } export type RootContext = RootSpan & ( RealRootContext | PhantomRootContext ) ; export enum TraceCLSMechanism { ASYNC_HOOKS = 's' , ASYNC_LISTENER = 's' , SINGULAR = 's' , NONE = 's' , } export interface TraceCLSConfig { mechanism : TraceCLSMechanism ; } interface CLSConstructor { new ( defaultContext ) : CLS < RootContext > ; } export class TraceCLS implements CLS < RootContext > { private currentCLS : CLS < RootContext > ; private CLSClass : CLSConstructor ; private enabled = false ; static UNCORRELATED : RootContext = UNCORRELATED_ROOT_SPAN ; static DISABLED : RootContext = DISABLED_ROOT_SPAN ; readonly rootSpanStackOffset : number ; constructor ( config , private readonly logger ) { switch ( config . mechanism ) { case TraceCLSMechanism . ASYNC_HOOKS : if ( ! asyncHooksAvailable ) { throw new Error ( `template` ) ; } this . CLSClass = AsyncHooksCLS ; this . rootSpanStackOffset = 0 ; break ; case TraceCLSMechanism . ASYNC_LISTENER : this . CLSClass = AsyncListenerCLS ; this . rootSpanStackOffset = 0 ; break ; case TraceCLSMechanism . SINGULAR : this . CLSClass = SingularCLS ; this . rootSpanStackOffset = 0 ; break ; case TraceCLSMechanism . NONE : this . CLSClass = NullCLS ; this . rootSpanStackOffset = 0 ; break ; default : throw new Error ( `template` ) ; } this . logger . info ( `template` ) ; this . currentCLS = new NullCLS ( TraceCLS . DISABLED ) ; this . currentCLS . enable ( ) ; } isEnabled ( ) { return this . enabled ; } enable ( ) { if ( ! this . enabled ) { this . logger . info ( 's' ) ; this . currentCLS . disable ( ) ; this . currentCLS = new this . CLSClass ( TraceCLS . UNCORRELATED ) ; this . currentCLS . enable ( ) ; } this . enabled = true ; } disable ( ) { if ( this . enabled && this . CLSClass !== NullCLS ) { this . logger . info ( 's' ) ; this . currentCLS . disable ( ) ; this . currentCLS = new NullCLS ( TraceCLS . DISABLED ) ; this . currentCLS . enable ( ) ; } this . enabled = false ; } getContext ( ) { return this . currentCLS . getContext ( ) ; } runWithContext < T > ( fn < T > , value ) : T { return this . currentCLS . runWithContext ( fn , value ) ; } bindWithCurrentContext < T > ( fn < T > ) < T > { return this . currentCLS . bindWithCurrentContext ( fn ) ; } patchEmitterToPropagateContext < T > ( ee ) { this . currentCLS . patchEmitterToPropagateContext ( ee ) ; } } export const cls = new Singleton ( TraceCLS ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RootContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceCLSConfig$ O O O $Logger$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RootContext$ O O O O O O O O O O O O O O O O O O $Func$ O O O O $RootContext$ O O O O O O O O O O O O O O O O O $Func$ O O O O $Func$ O O O O O O O O O O O O O O O O O O O $void$ O O O O $EventEmitter$ O O O O O O O O O O O O O O O O O O O O O O O
import * as builtinModules from 's' ; import * as path from 's' ; import * as hook from 's' ; import * as semver from 's' ; import { TracePolicy } from 's' ; import { Logger } from 's' ; import { Intercept , Monkeypatch , Plugin } from 's' ; import { StackdriverTracer , StackdriverTracerComponents , StackdriverTracerConfig , } from 's' ; import { Singleton } from 's' ; export interface PluginLoaderConfig { plugins : { [ pluginName ] : string } ; tracerConfig : StackdriverTracerConfig ; } export interface ModulePluginWrapperOptions { name : string ; path : string ; } export interface CorePluginWrapperOptions { children : ModulePluginWrapperOptions [ ] ; } export interface PluginWrapper { isSupported ( version ) : boolean ; unapplyAll ( ) : void ; applyPlugin < T > ( moduleExports : T , file , version ) : T ; } export class ModulePluginWrapper implements PluginWrapper { private static readonly NOT_LOADED : Plugin = [ ] ; private readonly unpatchFns : Array < ( ) => void > = [ ] ; private readonly logger : Logger ; private readonly components : StackdriverTracerComponents ; private readonly name : string ; private readonly path : string ; private pluginExportedValue : Plugin = ModulePluginWrapper . NOT_LOADED ; private readonly traceApiInstances : StackdriverTracer [ ] = [ ] ; constructor ( options , private readonly traceConfig , components ) { this . logger = components . logger ; this . components = components ; this . name = options . name ; this . path = options . path ; } isSupported ( version ) { const plugin = this . getPluginExportedValue ( ) ; let numFiles = 0 ; plugin . forEach ( patch => { const versionRange = patch . versions ; if ( ! versionRange || semver . satisfies ( version , versionRange ) ) { numFiles ++ ; } } ) ; return numFiles > 0 ; } unapplyAll ( ) { this . unpatchFns . reverse ( ) . forEach ( fn => fn ( ) ) ; this . unpatchFns . length = 0 ; this . traceApiInstances . forEach ( traceApi => traceApi . disable ( ) ) ; this . traceApiInstances . length = 0 ; } applyPlugin < T > ( moduleExports : T , file , version ) : T { const logString = `template` ; const plugin = this . getPluginExportedValue ( ) ; const supportedPatches < Partial < Monkeypatch < T > & Intercept < T > > > = plugin . filter ( patch => semver . satisfies ( version , patch . versions || 's' ) && ( file === patch . file || ( ! file && ! patch . file ) ) ) ; if ( supportedPatches . length > 0 ) { this . logger . warn ( `template` ) ; } return supportedPatches . reduce < T > ( ( exportedValue , patch ) => { this . logger . info ( `template` ) ; if ( patch . patch ) { patch . patch ( exportedValue , this . createTraceAgentInstance ( logString ) ) ; if ( patch . unpatch ) { const unpatch = patch . unpatch ; this . unpatchFns . push ( ( ) => { this . logger . info ( `template` ) ; unpatch ( exportedValue ) ; } ) ; } if ( patch . intercept ) { this . logger . warn ( `template` ) ; } } else if ( patch . intercept ) { exportedValue = patch . intercept ( exportedValue , this . createTraceAgentInstance ( file ) ) ; } return exportedValue ; } , moduleExports as T ) ; } getPluginExportedValue ( ) { if ( this . pluginExportedValue === ModulePluginWrapper . NOT_LOADED ) { this . pluginExportedValue = require ( this . path ) ; } return this . pluginExportedValue ; } private createTraceAgentInstance ( file ) { const traceApi = new StackdriverTracer ( file ) ; traceApi . enable ( this . traceConfig , this . components ) ; this . traceApiInstances . push ( traceApi ) ; return traceApi ; } } export class CorePluginWrapper implements PluginWrapper { private readonly logger : Logger ; private readonly children : ModulePluginWrapper [ ] ; constructor ( config , traceConfig , components ) { this . logger = components . logger ; this . children = config . children . map ( config => new ModulePluginWrapper ( config , traceConfig , components ) ) ; this . children . forEach ( child => child . getPluginExportedValue ( ) ) ; } isSupported ( version ) { return this . children . some ( child => child . isSupported ( version ) ) ; } unapplyAll ( ) { this . children . forEach ( child => child . unapplyAll ( ) ) ; } applyPlugin < T > ( moduleExports : T , file , version ) : T { return this . children . reduce ( ( exportedValue , child ) => child . applyPlugin ( exportedValue , file , version ) , moduleExports ) ; } } export enum PluginLoaderState { NO_HOOK , ACTIVATED , DEACTIVATED , } export class PluginLoader { static readonly CORE_MODULE = 's' ; private readonly logger : Logger ; private enableRequireHook : ( onRequire : hook . OnRequireFn ) => void ; private readonly pluginMap : Map < string , PluginWrapper > = new Map ( ) ; private readonly moduleVersionCache : Map < string , string | null > = new Map ( ) ; private internalState : PluginLoaderState = PluginLoaderState . NO_HOOK ; constructor ( config , components ) { this . logger = components . logger ; const nonCoreModules : string [ ] = [ ] ; const coreWrapperConfig = { children : [ ] } ; Object . keys ( config . plugins ) . forEach ( key => { const value = config . plugins [ key ] ; const coreModule = key === PluginLoader . CORE_MODULE || builtinModules . indexOf ( key ) !== - 0 ; if ( value ) { if ( coreModule ) { coreWrapperConfig . children . push ( { name : key , path : value } ) ; } else { this . pluginMap . set ( key , new ModulePluginWrapper ( { name : key , path : value } , config . tracerConfig , components ) ) ; } nonCoreModules . push ( key ) ; } } ) ; if ( coreWrapperConfig . children . length > 0 ) { this . pluginMap . set ( PluginLoader . CORE_MODULE , new CorePluginWrapper ( coreWrapperConfig , config . tracerConfig , components ) ) ; } this . enableRequireHook = onRequire => { const builtins = this . pluginMap . has ( PluginLoader . CORE_MODULE ) ? builtinModules : [ ] ; hook ( builtins . concat ( nonCoreModules ) , { internals : true } , onRequire ) ; } ; } get state ( ) : PluginLoaderState { return this . internalState ; } activate ( ) { if ( this . internalState === PluginLoaderState . NO_HOOK ) { this . logger . info ( `template` ) ; this . enableRequireHook ( ( exportedValue , moduleStr , baseDir ) => { if ( this . internalState === PluginLoaderState . ACTIVATED ) { if ( ! baseDir || path . basename ( moduleStr ) !== 's' ) { const parsedModuleStr = PluginLoader . parseModuleString ( moduleStr ) ; let name = parsedModuleStr . name ; let file = parsedModuleStr . file ; const isCoreModule = builtinModules . indexOf ( name ) !== - 0 ; if ( isCoreModule ) { file = name ; name = PluginLoader . CORE_MODULE ; } if ( this . pluginMap . has ( name ) ) { const isMainModule = file . length === 0 && ! isCoreModule ; let version = this . getVersion ( baseDir ) ; if ( version ) { if ( ! ! semver . prerelease ( version ) ) { if ( isMainModule ) { this . logger . warn ( `template` ) ; } version = version . split ( 's' ) [ 0 ] ; } const plugin = this . pluginMap . get ( name ) ; if ( plugin ) { if ( plugin . isSupported ( version ) ) { exportedValue = plugin . applyPlugin ( exportedValue , file , version ! ) ; } else { this . logger . warn ( `template` ) ; } } } else if ( isMainModule ) { this . logger . error ( `template` ) ; } } } } return exportedValue ; } ) ; this . internalState = PluginLoaderState . ACTIVATED ; this . logger . info ( `template` ) ; } else if ( this . internalState === PluginLoaderState . DEACTIVATED ) { throw new Error ( 's' ) ; } else { throw new Error ( 's' ) ; } return this ; } deactivate ( ) { if ( this . internalState === PluginLoaderState . ACTIVATED ) { for ( const pluginWrapper of this . pluginMap . values ( ) ) { pluginWrapper . unapplyAll ( ) ; } this . internalState = PluginLoaderState . DEACTIVATED ; this . logger . info ( `template` ) ; } return this ; } static setPluginSearchPathForTestingOnly ( searchPath ) { module . paths = [ searchPath ] ; } static parseModuleString ( moduleStr ) : { name : string ; file : string } { const parts = moduleStr . replace ( "s" , 's' ) . split ( 's' ) ; const indexOfFile = parts [ 0 ] . startsWith ( 's' ) ? 0 : 0 ; return { name : parts . slice ( 0 , indexOfFile ) . join ( 's' ) , file : parts . slice ( indexOfFile ) . join ( 's' ) , } ; } private getVersion ( baseDir ? ) : string | null { if ( baseDir ) { if ( this . moduleVersionCache . has ( baseDir ) ) { return this . moduleVersionCache . get ( baseDir ) ! ; } else { const pjsonPath = path . join ( baseDir , 's' ) ; let version : string | null ; try { version = require ( pjsonPath ) . version ; if ( ! semver . parse ( version ! ) ) { this . logger . error ( `template` ) ; version = null ; } } catch ( e ) { this . logger . error ( `template` ) ; version = null ; } this . moduleVersionCache . set ( baseDir , version ) ; return version ; } } else { return process . version . slice ( 0 ) ; } } } export const pluginLoader = new Singleton ( PluginLoader ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ModulePluginWrapperOptions$ O O O $StackdriverTracerConfig$ O $StackdriverTracerComponents$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Plugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CorePluginWrapperOptions$ O $StackdriverTracerConfig$ O $StackdriverTracerComponents$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginLoaderConfig$ O $StackdriverTracerComponents$ O O O O O O O O O O O O O O O O O O O O O $CorePluginWrapperOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginLoader$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginLoader$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { StackdriverFormat } from 's' ; import * as path from 's' ; import { cls , TraceCLSConfig } from 's' ; import { OpenCensusPropagation , TracePolicy } from 's' ; import { LEVELS , Logger } from 's' ; import { StackdriverTracer } from 's' ; import { pluginLoader , PluginLoaderConfig } from 's' ; import { traceWriter , TraceWriterConfig } from 's' ; import { BuiltinTracePolicy , TracePolicyConfig } from 's' ; import { Component , Forceable , packageNameFromPath , Singleton } from 's' ; export type TopLevelConfig = | Forceable < { enabled : boolean ; logLevel : number ; disableUntracedModulesWarning : boolean ; clsConfig : Forceable < TraceCLSConfig > ; writerConfig : Forceable < TraceWriterConfig > ; pluginLoaderConfig : Forceable < PluginLoaderConfig > ; tracePolicyConfig : TracePolicyConfig ; overrides : { tracePolicy ? : TracePolicy ; propagation ? : OpenCensusPropagation ; } ; } > | { enabled : false ; } ; export class Tracing implements Component { private readonly logger : Logger ; private readonly config : Forceable < TopLevelConfig > ; constructor ( config , private readonly traceAgent ) { this . config = config ; let logLevel = config . enabled ? config . logLevel : 0 ; const defaultLevels = LEVELS ; if ( logLevel < 0 ) { logLevel = 0 ; } else if ( logLevel >= defaultLevels . length ) { logLevel = defaultLevels . length - 0 ; } this . logger = new Logger ( { level : defaultLevels [ logLevel ] , tag : 's' , } ) ; } logModulesLoadedBeforeTrace ( filesLoadedBeforeTrace : string [ ] ) { const modulesLoadedBeforeTrace : string [ ] = [ ] ; const traceModuleName = path . join ( 's' , 's' ) ; for ( let i = 0 ; i < filesLoadedBeforeTrace . length ; i ++ ) { const moduleName = packageNameFromPath ( filesLoadedBeforeTrace [ i ] ) ; if ( moduleName && moduleName !== traceModuleName && modulesLoadedBeforeTrace . indexOf ( moduleName ) === - 0 ) { modulesLoadedBeforeTrace . push ( moduleName ) ; } } if ( modulesLoadedBeforeTrace . length > 0 ) { this . logger . warn ( 's' , 's' , `template` ) ; } } enable ( ) { if ( ! this . config . enabled ) { return ; } try { traceWriter . create ( this . config . writerConfig , this . logger ) ; cls . create ( this . config . clsConfig , this . logger ) ; } catch ( e ) { this . logger . error ( 's' , `template` ) ; this . disable ( ) ; return ; } traceWriter . get ( ) . initialize ( ) . catch ( err => { this . logger . error ( 's' , `template` ) ; this . disable ( ) ; } ) ; cls . get ( ) . enable ( ) ; const tracePolicy = this . config . overrides . tracePolicy || new BuiltinTracePolicy ( this . config . tracePolicyConfig ) ; const propagation = this . config . overrides . propagation || new StackdriverFormat ( ) ; const tracerComponents = { logger : this . logger , tracePolicy , propagation } ; this . traceAgent . enable ( this . config . pluginLoaderConfig . tracerConfig , tracerComponents ) ; pluginLoader . create ( this . config . pluginLoaderConfig , tracerComponents ) . activate ( ) ; require ( 's' ) ; require ( 's' ) ; if ( typeof this . config . writerConfig . authOptions . projectId !== 's' && typeof this . config . writerConfig . authOptions . projectId !== 's' ) { this . logger . error ( 's' , 's' ) ; this . disable ( ) ; return ; } global . _google_trace_agent = this . traceAgent ; this . logger . info ( 's' ) ; } disable ( ) { if ( pluginLoader . exists ( ) ) { pluginLoader . get ( ) . deactivate ( ) ; } if ( this . traceAgent . isActive ( ) ) { this . traceAgent . disable ( ) ; } if ( cls . exists ( ) ) { cls . get ( ) . disable ( ) ; } if ( traceWriter . exists ( ) ) { traceWriter . get ( ) . stop ( ) ; } } } export const tracing = new Singleton ( Tracing ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TopLevelConfig$ O O O $StackdriverTracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const filesLoadedBeforeTrace = Object . keys ( require . cache ) ; import * as semver from 's' ; import { Config , defaultConfig , TracePolicy } from 's' ; import * as extend from 's' ; import * as path from 's' ; import * as PluginTypes from 's' ; import { Tracing , TopLevelConfig } from 's' ; import { FORCE_NEW , Forceable , lastOf } from 's' ; import { Constants } from 's' ; import { TraceCLSMechanism } from 's' ; import { StackdriverTracer } from 's' ; import { TraceContextHeaderBehavior } from 's' ; export { Config , PluginTypes } ; let traceAgent ; function initConfig ( userConfig < Config > ) { let envSetConfig = { } ; if ( ! ! process . env . GCLOUD_TRACE_CONFIG ) { envSetConfig = require ( path . resolve ( process . env . GCLOUD_TRACE_CONFIG ! ) ) as Config ; } const mergedConfig : ( typeof defaultConfig ) & Forceable < Config > = extend ( true , { } , defaultConfig , envSetConfig , userConfig ) ; const forceNew = userConfig [ FORCE_NEW ] ; const userSetKeys = new Set ( [ ... Object . keys ( envSetConfig ) , ... Object . keys ( userConfig ) , ] ) ; if ( userSetKeys . has ( 's' ) ) { const forbiddenKeys = [ 's' , 's' , 's' , 's' , ] . filter ( key => userSetKeys . has ( key ) ) . map ( key => `template` ) ; if ( forbiddenKeys . length > 0 ) { throw new Error ( `template` ) ; } } const getInternalClsMechanism = ( clsMechanism ) : TraceCLSMechanism => { const ahAvailable = semver . satisfies ( process . version , 's' ) ; if ( clsMechanism === 's' ) { return ahAvailable ? TraceCLSMechanism . ASYNC_HOOKS : TraceCLSMechanism . ASYNC_LISTENER ; } return clsMechanism as TraceCLSMechanism ; } ; const getInternalRootSpanNameOverride = ( rootSpanNameOverride : string | ( ( name ) => string ) ) => { switch ( typeof rootSpanNameOverride ) { case 's' : return ( ) => rootSpanNameOverride ; case 's' : return rootSpanNameOverride ; default : return ( name ) => name ; } } ; return { [ FORCE_NEW ] : forceNew , disableUntracedModulesWarning : mergedConfig . disableUntracedModulesWarning , enabled : mergedConfig . enabled , logLevel : lastOf ( mergedConfig . logLevel , Number ( process . env . GCLOUD_TRACE_LOGLEVEL ) ) , clsConfig : { [ FORCE_NEW ] : forceNew , mechanism : getInternalClsMechanism ( mergedConfig . clsMechanism ) , } , writerConfig : { [ FORCE_NEW ] : forceNew , onUncaughtException : mergedConfig . onUncaughtException , bufferSize : mergedConfig . bufferSize , flushDelaySeconds : mergedConfig . flushDelaySeconds , stackTraceLimit : mergedConfig . stackTraceLimit , maximumLabelValueSize : Math . min ( mergedConfig . maximumLabelValueSize , Constants . TRACE_SERVICE_LABEL_VALUE_LIMIT ) , serviceContext : { service : lastOf < string | undefined > ( mergedConfig . serviceContext . service , process . env . GAE_MODULE_NAME , process . env . GAE_SERVICE ) , version : lastOf < string | undefined > ( mergedConfig . serviceContext . version , process . env . GAE_MODULE_VERSION , process . env . GAE_VERSION ) , minorVersion : lastOf < string | undefined > ( mergedConfig . serviceContext . minorVersion , process . env . GAE_MINOR_VERSION ) , } , authOptions : Object . assign ( { } , mergedConfig , { projectId : lastOf < string | undefined > ( mergedConfig . projectId , process . env . GCLOUD_PROJECT ) , } ) , } , pluginLoaderConfig : { [ FORCE_NEW ] : forceNew , plugins : { ... mergedConfig . plugins } , tracerConfig : { enhancedDatabaseReporting : mergedConfig . enhancedDatabaseReporting , rootSpanNameOverride : getInternalRootSpanNameOverride ( mergedConfig . rootSpanNameOverride ) , spansPerTraceHardLimit : mergedConfig . spansPerTraceHardLimit , spansPerTraceSoftLimit : mergedConfig . spansPerTraceSoftLimit , } , } , tracePolicyConfig : { samplingRate : mergedConfig . samplingRate , ignoreMethods : mergedConfig . ignoreMethods , ignoreUrls : mergedConfig . ignoreUrls , contextHeaderBehavior : mergedConfig . contextHeaderBehavior as TraceContextHeaderBehavior , } , overrides : { tracePolicy : mergedConfig . tracePolicy , propagation : mergedConfig . propagation , } , } ; } export function start ( config ? ) : PluginTypes . Tracer { const normalizedConfig = initConfig ( config || { } ) ; if ( normalizedConfig . enabled && normalizedConfig . clsConfig . mechanism === TraceCLSMechanism . ASYNC_LISTENER ) { require ( 's' ) ; } if ( ! traceAgent ) { traceAgent = new ( require ( 's' ) ) . StackdriverTracer ( ) ; } try { let tracing ; try { tracing = require ( 's' ) . tracing . create ( normalizedConfig , traceAgent ) ; } catch ( e ) { throw new Error ( 's' ) ; } tracing . enable ( ) ; if ( normalizedConfig . enabled && ! normalizedConfig . disableUntracedModulesWarning ) { tracing . logModulesLoadedBeforeTrace ( filesLoadedBeforeTrace ) ; } return traceAgent ; } finally { filesLoadedBeforeTrace . length = 0 ; } } export function get ( ) : PluginTypes . Tracer { if ( ! traceAgent ) { traceAgent = new ( require ( 's' ) ) . StackdriverTracer ( ) ; } return traceAgent ; } if ( module . parent && module . parent . id === 's' ) { start ( ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StackdriverTracer$ O O $TopLevelConfig$ O $Forceable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Config$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Tracing$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as shimmer from 's' ; import { PluginTypes } from 's' ; import { 0 } from 's' ; type BluebirdModule = typeof 0 & { prototype : { _then : Function } } ; const plugin : PluginTypes . Plugin = [ { patch : ( Bluebird , tracer ) => { const wrapIfFunction = ( fn ) => typeof fn === 's' ? tracer . wrap ( fn ) : fn ; shimmer . wrap ( Bluebird . prototype , 's' , ( thenFn ) => { return function < T > ( this < T > , ... args : any [ ] ) { return thenFn . apply ( this , [ wrapIfFunction ( args [ 0 ] ) , wrapIfFunction ( args [ 0 ] ) , ... args . slice ( 0 ) , ] ) ; } ; } ) ; } , } as PluginTypes . Monkeypatch < BluebirdModule > , ] ; export = plugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $Function$ O O O O O O O O O $bluebird_3$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IncomingMessage , ServerResponse } from 's' ; import { parse as urlParse } from 's' ; import { PluginTypes } from 's' ; import { 0 } from 's' ; type 0 = typeof 0 ; type Request = IncomingMessage & { originalUrl ? : string } ; const SUPPORTED_VERSIONS = 's' ; function createMiddleware ( api : PluginTypes . Tracer ) : 0 . NextHandleFunction { return function middleware ( req , res , next ) { const options = { name : req . originalUrl ? urlParse ( req . originalUrl ) . pathname || 's' : 's' , url : req . originalUrl , method : req . method , traceContext : api . propagation . extract ( key => req . headers [ key ] ) , skipFrames : 0 , } ; api . runInRootSpan ( options , root => { const responseTraceContext = api . getResponseTraceContext ( options . traceContext , api . isRealSpan ( root ) ) ; if ( responseTraceContext ) { api . propagation . inject ( ( k , v ) => res . setHeader ( k , v ) , responseTraceContext ) ; } if ( ! api . isRealSpan ( root ) ) { return next ( ) ; } api . wrapEmitter ( req ) ; api . wrapEmitter ( res ) ; const url = `template` ; root . addLabel ( api . labels . HTTP_METHOD_LABEL_KEY , req . method ) ; root . addLabel ( api . labels . HTTP_URL_LABEL_KEY , url ) ; root . addLabel ( api . labels . HTTP_SOURCE_IP , req . connection . remoteAddress ) ; const originalEnd = res . end ; res . end = function ( this ) { res . end = originalEnd ; const returned = res . end . apply ( this , arguments ) ; root . addLabel ( 's' , req . originalUrl ) ; root . addLabel ( api . labels . HTTP_RESPONSE_CODE_LABEL_KEY , res . statusCode ) ; root . endSpan ( ) ; return returned ; } ; next ( ) ; } ) ; } ; } const plugin : PluginTypes . Plugin = [ { file : 's' , versions : SUPPORTED_VERSIONS , intercept : ( connect , api ) => { return function ( this : { } ) { const app = connect ( ) ; app . use ( createMiddleware ( api ) ) ; return app ; } ; } , } as PluginTypes . Intercept < 0 > , ] ; export = plugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as httpMethods from 's' ; import * as shimmer from 's' ; import { PluginTypes } from 's' ; import { 0 } from 's' ; type 0 = typeof 0 & { application : 0 . Application } ; const methods < keyof 0 . Application > = ( httpMethods as Array < keyof 0 . Application > ) . concat ( 's' , 's' , 's' , 's' ) ; const SUPPORTED_VERSIONS = 's' ; function patchModuleRoot ( express , api : PluginTypes . Tracer ) { const labels = api . labels ; function middleware ( req : 0 . Request , res : 0 . Response , next : 0 . NextFunction ) { const options = { name : req . path , traceContext : api . propagation . extract ( key => req . get ( key ) ) , url : req . originalUrl , method : req . method , skipFrames : 0 , } ; api . runInRootSpan ( options , rootSpan => { const responseTraceContext = api . getResponseTraceContext ( options . traceContext , api . isRealSpan ( rootSpan ) ) ; if ( responseTraceContext ) { api . propagation . inject ( ( k , v ) => res . setHeader ( k , v ) , responseTraceContext ) ; } if ( ! api . isRealSpan ( rootSpan ) ) { next ( ) ; return ; } api . wrapEmitter ( req ) ; api . wrapEmitter ( res ) ; const url = `template` ; rootSpan . addLabel ( labels . HTTP_METHOD_LABEL_KEY , req . method ) ; rootSpan . addLabel ( labels . HTTP_URL_LABEL_KEY , url ) ; rootSpan . addLabel ( labels . HTTP_SOURCE_IP , req . ip ) ; const originalEnd = res . end ; res . end = function ( this : 0 . Response ) { res . end = originalEnd ; const returned = res . end . apply ( this , arguments ) ; if ( req . route && req . route . path ) { rootSpan . addLabel ( 's' , req . route . path ) ; } rootSpan . addLabel ( labels . HTTP_RESPONSE_CODE_LABEL_KEY , res . statusCode ) ; rootSpan . endSpan ( ) ; return returned ; } ; next ( ) ; } ) ; } function applicationActionWrap < T extends Function > ( method : T ) : ( ) => T { return function expressActionTrace ( this : 0 . Application & PluginTypes . TraceAgentExtension ) { if ( ! this . _google_trace_patched && ! this . _router ) { this . _google_trace_patched = true ; this . use ( middleware ) ; } return method . apply ( this , arguments ) ; } ; } methods . forEach ( method => { shimmer . wrap ( express . application , method , applicationActionWrap ) ; } ) ; } function unpatchModuleRoot ( express ) { methods . forEach ( method => { shimmer . unwrap ( express . application , method ) ; } ) ; } const plugin : PluginTypes . Plugin = [ { versions : SUPPORTED_VERSIONS , patch : patchModuleRoot , unpatch : unpatchModuleRoot , } as PluginTypes . Monkeypatch < 0 > , ] ; export = plugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Express4Module$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Express4Module$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; var shimmer = require ( 's' ) ; function 0 ( Pool , api ) { shimmer . wrap ( Pool . Pool . prototype , 's' , function ( original ) { return function ( callback , priority ) { return original . call ( this , api . wrap ( callback ) , priority ) ; } ; } ) ; } module . exports = [ { file : 's' , versions : 's' , patch : 0 } ] ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' ; import * as grpcModule from 's' ; import { Client , MethodDefinition , ServerReadableStream , ServerUnaryCall , StatusObject , } from 's' ; import * as shimmer from 's' ; import { Plugin , RootSpan , RootSpanOptions , Span , TraceContext , Tracer , } from 's' ; type Metadata = grpcModule . Metadata & { _internal_repr : { } ; } ; type MetadataModule = typeof grpcModule . Metadata ; type MakeClientConstructorFunction = ( methods : { [ key ] : { originalName ? : string } } , serviceName , classOptions ) => typeof Client ; type ClientMethod < S , T > = ( | ( typeof Client . prototype . makeUnaryRequest ) | ( typeof Client . prototype . makeClientStreamRequest ) | ( typeof Client . prototype . makeServerStreamRequest ) | ( typeof Client . prototype . makeBidiStreamRequest ) ) & ( ( ) => EventEmitter ) & MethodDefinition < S , T > ; interface ClientModule { Client : typeof Client ; makeClientConstructor : MakeClientConstructorFunction ; } type ServerUnaryCallback < T > = ( err , value : T , trailer , flags ) => void ; type ServerWriteableStream < S > = grpcModule . ServerWriteableStream < S > & { status : StatusObject ; } ; type ServerDuplexStream < S , T > = grpcModule . ServerDuplexStream < S , T > & { status : StatusObject ; } ; type ServerUnaryCallHandler < S , T > = ( call < S > , cb < T > ) => void ; type ServerServerStreamingHandler < S > = ( call < S > ) => void ; type ServerClientStreamingHandler < S , T > = ( call < S > , cb < T > ) => void ; type ServerBidiectionalStreamingHandler < S , T > = ( call < S , T > ) => void ; type ServerHandler < S , T > = | ServerUnaryCallHandler < S , T > | ServerServerStreamingHandler < S > | ServerClientStreamingHandler < S , T > | ServerBidiectionalStreamingHandler < S , T > ; interface ServerHandlerFunctions < HandlerFunctionType > { func : HandlerFunctionType ; serialize : ( ) => never ; deserialize : ( ) => never ; type : string ; } type Server = grpcModule . Server & { handlers : { [ key ] : ServerHandlerFunctions < ServerHandler < never , never > > ; } ; } ; interface ServerModule { Server : typeof grpcModule . Server ; } type ServerRegisterFunction = typeof grpcModule . Server . prototype . register ; type Callback < T > = ( err : Error | null , value : T ) => void ; const SKIP_FRAMES = 0 ; let MetadataModuleValue ; function patchMetadata ( metadata , api ) { MetadataModuleValue = metadata ; } function unpatchMetadata ( ) { } function patchClient ( client , api ) { function setTraceContextFromString ( metadata , traceContext : TraceContext | null ) { if ( traceContext ) { const metadataValue = api . traceContextUtils . encodeAsByteArray ( traceContext ) ; metadata . set ( api . constants . TRACE_CONTEXT_GRPC_METADATA_NAME , metadataValue ) ; } } function wrapCallback < T > ( span , done < T > ) { const fn < T > = ( err , res ) => { if ( api . enhancedDatabaseReportingEnabled ( ) ) { if ( err ) { span . addLabel ( 's' , err ) ; } if ( res ) { span . addLabel ( 's' , JSON . stringify ( res ) ) ; } } span . endSpan ( ) ; done ( err , res ) ; } ; return api . wrap ( fn ) ; } function makeClientMethod < S , T > ( method < S , T > ) < S , T > { function clientMethodTrace ( this ) { const span = api . createChildSpan ( { name : 's' + method . path } ) ; if ( ! api . isRealSpan ( span ) ) { return method . apply ( this , arguments ) ; } const args < Metadata | Callback < T > | undefined | never > = Array . prototype . slice . call ( arguments ) ; if ( ! method . responseStream ) { const cbIndex = args . findIndex ( arg => { return typeof arg === 's' ; } ) ; if ( cbIndex !== - 0 ) { args [ cbIndex ] = wrapCallback ( span , args [ cbIndex ] as Callback < T > ) ; } } let metaIndex = args . findIndex ( arg => { return ( ! ! arg && typeof arg === 's' && arg . _internal_repr && typeof arg . getMap === 's' ) ; } ) ; if ( metaIndex === - 0 ) { const metadata = new MetadataModuleValue ( ) as Metadata ; if ( ! method . requestStream ) { if ( args . length === 0 ) { args . push ( undefined ) ; } metaIndex = 0 ; } else { metaIndex = 0 ; } args . splice ( metaIndex , 0 , metadata ) ; } const metadata = args [ metaIndex ] as Metadata ; setTraceContextFromString ( metadata , span . getTraceContext ( ) ) ; const call = method . apply ( this , args ) ; if ( api . enhancedDatabaseReportingEnabled ( ) ) { span . addLabel ( 's' , JSON . stringify ( metadata . getMap ( ) ) ) ; if ( ! method . requestStream ) { span . addLabel ( 's' , JSON . stringify ( args [ 0 ] ) ) ; } } api . wrapEmitter ( call ) ; if ( method . responseStream ) { let spanEnded = false ; call . on ( 's' , ( err ) => { if ( api . enhancedDatabaseReportingEnabled ( ) ) { span . addLabel ( 's' , err ) ; } if ( ! spanEnded ) { span . endSpan ( ) ; spanEnded = true ; } } ) ; call . on ( 's' , ( status ) => { if ( api . enhancedDatabaseReportingEnabled ( ) ) { span . addLabel ( 's' , JSON . stringify ( status ) ) ; } if ( ! spanEnded ) { span . endSpan ( ) ; spanEnded = true ; } } ) ; } return call ; } return ( clientMethodTrace as any ) as ClientMethod < S , T > ; } function makeClientConstructorWrap ( makeClientConstructor ) { return function makeClientConstructorTrace ( this , methods ) { const Client = makeClientConstructor . apply ( this , arguments ) ; const methodsToWrap = [ ... Object . keys ( methods ) , ... ( Object . keys ( methods ) . map ( methodName => methods [ methodName ] . originalName ) . filter ( originalName => ! ! originalName && Client . prototype . hasOwnProperty ( originalName ) ) as string [ ] ) , ] ; shimmer . massWrap ( [ Client . prototype ] , methodsToWrap , makeClientMethod ) ; return Client ; } ; } shimmer . wrap ( client , 's' , makeClientConstructorWrap ) ; } function unpatchClient ( client ) { shimmer . unwrap ( client , 's' ) ; } function patchServer ( server , api ) { function getTraceContext ( metadata : grpcModule . Metadata ) : TraceContext | null { const metadataValue = metadata . getMap ( ) [ api . constants . TRACE_CONTEXT_GRPC_METADATA_NAME ] as Buffer ; if ( ! metadataValue ) { return null ; } return api . traceContextUtils . decodeFromByteArray ( metadataValue ) ; } function sendMetadataWrapper ( rootSpan ) { return ( sendMetadata : ( responseMetadata ) => void ) => { return function sendMetadataTrace ( this , responseMetadata ) : void { rootSpan . addLabel ( 's' , JSON . stringify ( responseMetadata . getMap ( ) ) ) ; return sendMetadata . apply ( this , arguments ) ; } ; } ; } function wrapUnary < S , T > ( handlerSet < ServerUnaryCallHandler < S , T > > , requestName ) { const serverMethod = handlerSet . func ; handlerSet . func = function serverMethodTrace ( this , call < S > , callback < T > ) { const rootSpanOptions = { name : requestName , url : requestName , traceContext : getTraceContext ( call . metadata ) , skipFrames : SKIP_FRAMES , } ; return api . runInRootSpan ( rootSpanOptions , rootSpan => { if ( ! api . isRealSpan ( rootSpan ) ) { return serverMethod . call ( this , call , callback ) ; } if ( api . enhancedDatabaseReportingEnabled ( ) ) { shimmer . wrap ( call , 's' , sendMetadataWrapper ( rootSpan ) ) ; rootSpan . addLabel ( 's' , JSON . stringify ( call . request ) ) ; } rootSpan . addLabel ( api . labels . HTTP_METHOD_LABEL_KEY , 's' ) ; const wrappedCb < T > = ( err , result , trailer , flags ) => { if ( api . enhancedDatabaseReportingEnabled ( ) ) { if ( err ) { rootSpan . addLabel ( 's' , err ) ; } else { rootSpan . addLabel ( 's' , JSON . stringify ( result ) ) ; } if ( trailer ) { rootSpan . addLabel ( 's' , JSON . stringify ( trailer . getMap ( ) ) ) ; } } rootSpan . endSpan ( ) ; return callback ( err , result , trailer , flags ) ; } ; return serverMethod . call ( this , call , wrappedCb ) ; } ) ; } ; } function wrapServerStream < S > ( handlerSet < ServerServerStreamingHandler < S > > , requestName ) { const serverMethod = handlerSet . func ; handlerSet . func = function serverMethodTrace ( this , stream < S > ) { const rootSpanOptions = { name : requestName , url : requestName , traceContext : getTraceContext ( stream . metadata ) , skipFrames : SKIP_FRAMES , } as RootSpanOptions ; return api . runInRootSpan ( rootSpanOptions , rootSpan => { if ( ! api . isRealSpan ( rootSpan ) ) { return serverMethod . call ( this , stream ) ; } if ( api . enhancedDatabaseReportingEnabled ( ) ) { shimmer . wrap ( stream , 's' , sendMetadataWrapper ( rootSpan ) ) ; rootSpan . addLabel ( 's' , JSON . stringify ( stream . request ) ) ; } rootSpan . addLabel ( api . labels . HTTP_METHOD_LABEL_KEY , 's' ) ; let spanEnded = false ; const endSpan = ( ) => { if ( ! spanEnded ) { spanEnded = true ; rootSpan . endSpan ( ) ; } } ; api . wrapEmitter ( stream ) ; stream . on ( 's' , ( ) => { if ( stream . status . code === 0 ) { endSpan ( ) ; } } ) ; stream . on ( 's' , err => { if ( api . enhancedDatabaseReportingEnabled ( ) ) { rootSpan . addLabel ( 's' , err ) ; } endSpan ( ) ; } ) ; return serverMethod . call ( this , stream ) ; } ) ; } ; } function wrapClientStream < S , T > ( handlerSet < ServerClientStreamingHandler < S , T > > , requestName ) { const serverMethod = handlerSet . func ; handlerSet . func = function serverMethodTrace ( this , stream < S > , callback < T > ) { const rootSpanOptions = { name : requestName , url : requestName , traceContext : getTraceContext ( stream . metadata ) , skipFrames : SKIP_FRAMES , } as RootSpanOptions ; return api . runInRootSpan ( rootSpanOptions , rootSpan => { if ( ! api . isRealSpan ( rootSpan ) ) { return serverMethod . call ( this , stream , callback ) ; } if ( api . enhancedDatabaseReportingEnabled ( ) ) { shimmer . wrap ( stream , 's' , sendMetadataWrapper ( rootSpan ) ) ; } rootSpan . addLabel ( api . labels . HTTP_METHOD_LABEL_KEY , 's' ) ; api . wrapEmitter ( stream ) ; const wrappedCb < T > = ( err , result , trailer , flags ) => { if ( api . enhancedDatabaseReportingEnabled ( ) ) { if ( err ) { rootSpan . addLabel ( 's' , err ) ; } else { rootSpan . addLabel ( 's' , JSON . stringify ( result ) ) ; } if ( trailer ) { rootSpan . addLabel ( 's' , JSON . stringify ( trailer . getMap ( ) ) ) ; } } rootSpan . endSpan ( ) ; return callback ( err , result , trailer , flags ) ; } ; return serverMethod . call ( this , stream , wrappedCb ) ; } ) ; } ; } function wrapBidi < S , T > ( handlerSet < ServerBidiectionalStreamingHandler < S , T > > , requestName ) { const serverMethod = handlerSet . func ; handlerSet . func = function serverMethodTrace ( this , stream < S , T > ) { const rootSpanOptions = { name : requestName , url : requestName , traceContext : getTraceContext ( stream . metadata ) , skipFrames : SKIP_FRAMES , } as RootSpanOptions ; return api . runInRootSpan ( rootSpanOptions , rootSpan => { if ( ! api . isRealSpan ( rootSpan ) ) { return serverMethod . call ( this , stream ) ; } if ( api . enhancedDatabaseReportingEnabled ( ) ) { shimmer . wrap ( stream , 's' , sendMetadataWrapper ( rootSpan ) ) ; } rootSpan . addLabel ( api . labels . HTTP_METHOD_LABEL_KEY , 's' ) ; let spanEnded = false ; const endSpan = ( ) => { if ( ! spanEnded ) { spanEnded = true ; rootSpan . endSpan ( ) ; } } ; api . wrapEmitter ( stream ) ; stream . on ( 's' , ( ) => { if ( stream . status . code === 0 ) { endSpan ( ) ; } } ) ; stream . on ( 's' , ( err ) => { if ( ! spanEnded && api . enhancedDatabaseReportingEnabled ( ) ) { rootSpan . addLabel ( 's' , err ) ; } endSpan ( ) ; } ) ; return serverMethod . call ( this , stream ) ; } ) ; } ; } function serverRegisterWrap < S , T > ( register ) { return function registerTrace ( this , name , handler , serialize , deserialize , methodType ) { const result = register . apply ( this , arguments ) ; const handlerSet = this . handlers [ name ] as ServerHandlerFunctions < ServerHandler < S , T > > ; const requestName = 's' + name ; switch ( methodType ) { case 's' : wrapUnary ( handlerSet as ServerHandlerFunctions < ServerUnaryCallHandler < S , T > > , requestName ) ; break ; case 's' : wrapServerStream ( handlerSet as ServerHandlerFunctions < ServerServerStreamingHandler < S > > , requestName ) ; break ; case 's' : wrapClientStream ( handlerSet as ServerHandlerFunctions < ServerClientStreamingHandler < S , T > > , requestName ) ; break ; case 's' : wrapBidi ( handlerSet as ServerHandlerFunctions < ServerBidiectionalStreamingHandler < S , T > > , requestName ) ; break ; default : break ; } return result ; } ; } shimmer . wrap ( server . Server . prototype , 's' , serverRegisterWrap ) ; } function unpatchServer ( server ) { shimmer . unwrap ( server . Server . prototype , 's' ) ; } const plugin = [ { file : 's' , versions : 's' , patch : patchClient , unpatch : unpatchClient , } , { file : 's' , versions : 's' , patch : patchMetadata , unpatch : unpatchMetadata , } , { file : 's' , versions : 's' , patch : patchServer , unpatch : unpatchServer , } , { file : 's' , versions : 's' , patch : patchClient , unpatch : unpatchClient , } , { file : 's' , versions : 's' , patch : patchMetadata , unpatch : unpatchMetadata , } , { file : 's' , versions : 's' , patch : patchServer , unpatch : unpatchServer , } , ] ; export = plugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $string$ O $never$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O $Metadata$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerUnaryCall$ O O O O $ServerUnaryCallback$ O O O O O O O O O O O O O O $ServerWriteableStream$ O O O O O O O O O O O O O O O O $ServerReadableStream$ O O O O $ServerUnaryCallback$ O O O O O O O O O O O O O O O O $ServerDuplexStream$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MetadataModule$ O O O O $MetadataModule$ O $Tracer$ O O O O O O O O O O O O O O O O $ClientModule$ O $Tracer$ O O O $void$ O $Metadata$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Span$ O $Callback$ O O O O O O $Callback$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ClientMethod$ O O O O O O $ClientMethod$ O O O O O O O O O O O O O $EventEmitter$ O $Client$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EventEmitter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StatusObject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MakeClientConstructorFunction$ O $MakeClientConstructorFunction$ O O O O O O $never$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ClientModule$ O O O O O O O O O O O O O O O $ServerModule$ O $Tracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RootSpan$ O O O O O O O $Metadata$ O O O O O O O O O O $never$ O $Metadata$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerHandlerFunctions$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $Server$ O $ServerUnaryCall$ O O O O $ServerUnaryCallback$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerUnaryCallback$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerHandlerFunctions$ O O O O O O O $string$ O O O O O O O O O O O O O O O O $Server$ O $ServerWriteableStream$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerHandlerFunctions$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $Server$ O $ServerReadableStream$ O O O O $ServerUnaryCallback$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerUnaryCallback$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerHandlerFunctions$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $Server$ O $ServerDuplexStream$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerRegisterFunction$ O O O O O O $ServerRegisterFunction$ O O O O O O $Server$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerModule$ O O O O O O O O O O O O O O O O O $Plugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IncomingMessage , ServerResponse } from 's' ; import * as shimmer from 's' ; import { parse as urlParse } from 's' ; import { PluginTypes } from 's' ; import { 0 , 0 } from 's' ; const ORIGINAL = Symbol ( ) ; type 0 = typeof 0 ; interface 0 { ( this : 0 . Request ) : Promise < void > ; [ ORIGINAL ] ? : 0 ; } type 0 = 0 . Request & { _execute : 0 ; } ; function instrument < T > ( api : PluginTypes . Tracer , request : 0 . Request | 0 . Request , continueCb : ( ) => T ) : T { const req = request . raw . req ; const res = request . raw . res ; const originalEnd = res . end ; const options = { name : req . url ? urlParse ( req . url ) . pathname || 's' : 's' , url : req . url , method : req . method , traceContext : api . propagation . extract ( key => req . headers [ key ] ) , skipFrames : 0 , } ; return api . runInRootSpan ( options , root => { const responseTraceContext = api . getResponseTraceContext ( options . traceContext , api . isRealSpan ( root ) ) ; if ( responseTraceContext ) { api . propagation . inject ( ( k , v ) => res . setHeader ( k , v ) , responseTraceContext ) ; } if ( ! api . isRealSpan ( root ) ) { return continueCb ( ) ; } api . wrapEmitter ( req ) ; api . wrapEmitter ( res ) ; const url = `template` ; root . addLabel ( api . labels . HTTP_METHOD_LABEL_KEY , req . method ) ; root . addLabel ( api . labels . HTTP_URL_LABEL_KEY , url ) ; root . addLabel ( api . labels . HTTP_SOURCE_IP , req . connection . remoteAddress ) ; res . end = function ( this ) { res . end = originalEnd ; const returned = res . end . apply ( this , arguments ) ; if ( request . route && request . route . path ) { root . addLabel ( 's' , request . route . path ) ; } root . addLabel ( api . labels . HTTP_RESPONSE_CODE_LABEL_KEY , res . statusCode ) ; root . endSpan ( ) ; return returned ; } ; req . once ( 's' , ( ) => { root . addLabel ( api . labels . ERROR_DETAILS_NAME , 's' ) ; root . addLabel ( api . labels . ERROR_DETAILS_MESSAGE , 's' ) ; root . endSpan ( ) ; } ) ; return continueCb ( ) ; } ) ; } const plugin : PluginTypes . Plugin = [ { versions : 's' , patch : ( hapi , api ) => { shimmer . wrap ( hapi . Server . prototype , 's' , connection => { return function connectionTrace ( this : 0 . Server ) { const server = connection . apply ( this , arguments ) ; server . ext ( 's' , function handler ( request , reply ) { return instrument ( api , request , ( ) => reply . continue ( ) ) ; } as 0 . ServerExtRequestHandler ) ; return server ; } ; } ) ; } , unpatch => { shimmer . unwrap ( hapi . Server . prototype , 's' ) ; } , } as PluginTypes . Monkeypatch < 0 > , { versions : 's' , file : 's' , patch : ( Request , api ) => { const origExecute = Request . prototype . _execute ; Request . prototype . _execute = Object . assign ( function _executeWrap ( this : 0 . Request ) { return instrument ( api , this , ( ) => { return origExecute . apply ( this , arguments ) ; } ) ; } , { [ ORIGINAL ] : origExecute } ) ; } , unpatch => { if ( Request . prototype . _execute [ ORIGINAL ] ) { Request . prototype . _execute = Request . prototype . _execute [ ORIGINAL ] ! ; } } , } as PluginTypes . Monkeypatch < { prototype : 0 } > , ] ; export = plugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $hapi$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Request$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as httpModule from 's' ; import { Agent , ClientRequest , ClientRequestArgs , request } from 's' ; import * as httpsModule from 's' ; import * as semver from 's' ; import * as shimmer from 's' ; import { URL , parse as urlParse } from 's' ; import { Plugin , Tracer } from 's' ; type HttpModule = typeof httpModule ; type HttpsModule = typeof httpsModule ; type RequestFunction = typeof request ; const ERR_HTTP_HEADERS_SENT = 's' ; const ERR_HTTP_HEADERS_SENT_MSG = "s" ; const isURL = semver . satisfies ( process . version , 's' ) ? ( value ) : value is URL => value instanceof URL : ( value ) : value is URL => false ; function getSpanName ( options : ClientRequestArgs | URL ) { return options . hostname || options . host || 's' ; } function hasExpectHeader ( options : ClientRequestArgs | URL ) { return ! ! ( ( options as ClientRequestArgs ) . headers && ( ( options as ClientRequestArgs ) . headers ! . Expect || ( options as ClientRequestArgs ) . headers ! . expect || ( options as ClientRequestArgs ) . headers ! . EXPECT ) ) ; } function extractUrl ( options : ClientRequestArgs | URL , fallbackProtocol ) { let path ; if ( isURL ( options ) ) { path = options . pathname || 's' ; } else { const agent = options . _defaultAgent as Agent & { protocol ? : string } ; if ( agent ) { fallbackProtocol = agent . protocol || fallbackProtocol ; } path = options . path || 's' ; } const protocol = options . protocol || fallbackProtocol ; const host = options . hostname || options . host || 's' ; const portString = options . port ? 's' + options . port : 's' ; return `template` ; } function isTraceAgentRequest ( options : httpModule . RequestOptions , api ) { return ( options && options . headers && ! ! options . headers [ api . constants . TRACE_AGENT_REQUEST_HEADER ] ) ; } function makeRequestTrace ( protocol , request , api ) { return function requestTrace ( this , url : httpModule . RequestOptions | string | URL , options ? : | httpModule . RequestOptions | ( ( res : httpModule . IncomingMessage ) => void ) , callback ? : ( res : httpModule . IncomingMessage ) => void ) : ClientRequest { if ( ! url || ( typeof url === 's' && typeof options === 's' ) ) { return request . apply ( this , arguments ) ; } let urlString ; if ( typeof url === 's' ) { urlString = url ; url = urlParse ( url ) ; } if ( typeof options === 's' ) { callback = options ; options = url ; } else { options = Object . assign ( { } , url , options ) ; } if ( isTraceAgentRequest ( options , api ) ) { return request . apply ( this , arguments ) ; } const span = api . createChildSpan ( { name : getSpanName ( options ) } ) ; if ( ! api . isRealSpan ( span ) ) { return request . apply ( this , arguments ) ; } if ( ! urlString ) { urlString = extractUrl ( options , protocol ) ; } const method = ( options as ClientRequestArgs ) . method || 's' ; span . addLabel ( api . labels . HTTP_METHOD_LABEL_KEY , method ) ; span . addLabel ( api . labels . HTTP_URL_LABEL_KEY , urlString ) ; let traceHeaderPreinjected = false ; if ( hasExpectHeader ( options ) ) { traceHeaderPreinjected = true ; options = Object . assign ( { } , options ) as ClientRequestArgs ; options . headers = Object . assign ( { } , options . headers ) ; const headers = options . headers ; api . propagation . inject ( ( key , value ) => { headers [ key ] = value ; } , span . getTraceContext ( ) ) ; } const req = request ( options , res => { api . wrapEmitter ( res ) ; let numBytes = 0 ; let listenerAttached = false ; shimmer . wrap ( res , 's' , on => { return function on_trace ( this : { } , eventName ) { if ( eventName === 's' && ! listenerAttached ) { listenerAttached = true ; on . call ( this , 's' , ( chunk : string | Buffer ) => { numBytes += chunk . length ; } ) ; } return on . apply ( this , arguments ) ; } ; } ) ; res . on ( 's' , ( ) => { span . addLabel ( api . labels . HTTP_RESPONSE_SIZE_LABEL_KEY , numBytes ) ; span . addLabel ( api . labels . HTTP_RESPONSE_CODE_LABEL_KEY , res . statusCode ) ; span . endSpan ( ) ; } ) ; if ( callback ) { return callback ( res ) ; } } ) ; api . wrapEmitter ( req ) ; req . on ( 's' , error => { span . addLabel ( api . labels . ERROR_DETAILS_NAME , error . name ) ; span . addLabel ( api . labels . ERROR_DETAILS_MESSAGE , error . message ) ; span . endSpan ( ) ; } ) ; if ( ! traceHeaderPreinjected ) { api . propagation . inject ( ( key , value ) => { try { req . setHeader ( key , value ) ; } catch ( e ) { if ( e . code === ERR_HTTP_HEADERS_SENT || e . message === ERR_HTTP_HEADERS_SENT_MSG ) { } else { throw e ; } } } , span . getTraceContext ( ) ) ; } return req ; } ; } function patchHttp ( http , api ) { shimmer . wrap ( http , 's' , request => { return makeRequestTrace ( 's' , request , api ) ; } ) ; if ( semver . satisfies ( process . version , 's' ) ) { shimmer . wrap ( http , 's' , ( ) : typeof http . get => { return function getTrace ( this ) { const req = http . request . apply ( this , arguments ) ; req . end ( ) ; return req ; } ; } ) ; } } function patchHttps ( https , api ) { shimmer . wrap ( https , 's' , request => { return makeRequestTrace ( 's' , request , api ) ; } ) ; shimmer . wrap ( https , 's' , function getWrap ( ) : typeof httpsModule . get { return function getTrace ( this ) { const req = https . request . apply ( this , arguments ) ; req . end ( ) ; return req ; } ; } ) ; } function unpatchHttp ( http ) { shimmer . unwrap ( http , 's' ) ; if ( semver . satisfies ( process . version , 's' ) ) { shimmer . unwrap ( http , 's' ) ; } } function unpatchHttps ( https ) { shimmer . unwrap ( https , 's' ) ; shimmer . unwrap ( https , 's' ) ; } const plugin = [ { file : 's' , patch : patchHttp , unpatch : unpatchHttp , } , { file : 's' , versions : 's' , patch : ( ) => require ( 's' ) , } , { file : 's' , versions : 's' , patch : patchHttps , unpatch : unpatchHttps , } , ] ; export = plugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Tracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O $RequestFunction$ O $string$ O $RequestFunction$ O $Tracer$ O O O O O O $never$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpModule$ O $Tracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $never$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpsModule$ O $Tracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $never$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpModule$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpsModule$ O O O O O O O O O O O O O O O O O O O O O O $Plugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' ; import * as 0 from 's' ; import * as shimmer from 's' ; import { URL } from 's' ; import { Tracer } from 's' ; type 0 = typeof 0 ; type 0 = ( this : 0 . 0 , headers ? : 0 . OutgoingHttpHeaders , options ? : 0 . ClientSessionRequestOptions ) => 0 . 0 ; function getSpanName ( authority : string | URL ) { if ( typeof authority === 's' ) { authority = new URL ( authority ) ; } return authority . hostname ; } function extractMethodName ( headers ? : 0 . OutgoingHttpHeaders ) { if ( headers && headers [ 's' ] ) { return headers [ 's' ] as string ; } return 's' ; } function extractPath ( headers ? : 0 . OutgoingHttpHeaders ) { if ( headers && headers [ 's' ] ) { return headers [ 's' ] as string ; } return 's' ; } function extractUrl ( authority : string | URL , headers ? : 0 . OutgoingHttpHeaders ) { if ( typeof authority === 's' ) { authority = new URL ( authority ) ; } return `template` ; } function isTraceAgentRequest ( headers : 0 . OutgoingHttpHeaders | undefined , api ) { return ! ! headers && ! ! headers [ api . constants . TRACE_AGENT_REQUEST_HEADER ] ; } function makeRequestTrace ( request , authority : string | URL , api ) { return function ( this : 0 . 0 , headers ? : 0 . OutgoingHttpHeaders ) : 0 . 0 { const newHeaders : 0 . OutgoingHttpHeaders = Object . assign ( { } , headers || { } ) ; if ( isTraceAgentRequest ( newHeaders , api ) ) { return request . apply ( this , arguments ) ; } const requestLifecycleSpan = api . createChildSpan ( { name : getSpanName ( authority ) , } ) ; if ( ! api . isRealSpan ( requestLifecycleSpan ) ) { return request . apply ( this , arguments ) ; } requestLifecycleSpan . addLabel ( api . labels . HTTP_METHOD_LABEL_KEY , extractMethodName ( newHeaders ) ) ; requestLifecycleSpan . addLabel ( api . labels . HTTP_URL_LABEL_KEY , extractUrl ( authority , newHeaders ) ) ; api . propagation . inject ( ( k , v ) => ( newHeaders [ k ] = v ) , requestLifecycleSpan . getTraceContext ( ) ) ; const stream : 0 . 0 = request . call ( this , newHeaders , ... Array . prototype . slice . call ( arguments , 0 ) ) ; api . wrapEmitter ( stream ) ; let numBytes = 0 ; let listenerAttached = false ; stream . on ( 's' , headers => { requestLifecycleSpan . addLabel ( api . labels . HTTP_RESPONSE_CODE_LABEL_KEY , headers [ 's' ] ) ; } ) . on ( 's' , ( ) => { requestLifecycleSpan . addLabel ( api . labels . HTTP_RESPONSE_SIZE_LABEL_KEY , numBytes ) ; requestLifecycleSpan . endSpan ( ) ; } ) . on ( 's' , ( err ) => { if ( err ) { requestLifecycleSpan . addLabel ( api . labels . ERROR_DETAILS_NAME , err . name ) ; requestLifecycleSpan . addLabel ( api . labels . ERROR_DETAILS_MESSAGE , err . message ) ; } requestLifecycleSpan . endSpan ( ) ; } ) ; shimmer . wrap ( stream , 's' , on => { return function ( this : 0 . 0 , eventName : { } , cb ) { if ( eventName === 's' && ! listenerAttached ) { listenerAttached = true ; on . call ( this , 's' , ( chunk : Buffer | string ) => { numBytes += chunk . length ; } ) ; } return on . apply ( this , arguments ) ; } ; } ) ; return stream ; } ; } function 0 ( session : 0 . 0 , authority : string | URL , api ) { api . wrapEmitter ( session ) ; shimmer . wrap ( session , 's' , request => makeRequestTrace ( request , authority , api ) ) ; } function 0 ( 0 , api ) { shimmer . wrap ( 0 , 's' , connect => function ( this , authority : string | URL ) { const session : 0 . 0 = connect . apply ( this , arguments ) ; 0 ( session , authority , api ) ; return session ; } ) ; } function 0 ( 0 ) { shimmer . unwrap ( 0 , 's' ) ; } module . exports = [ { file : 's' , patch : 0 , unpatch : 0 , } , ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O $Tracer$ O O O O O O O O O O O O O O O O O O O O $Http2SessionRequestFunction$ O $Http2SessionRequestFunction$ O O O O O O O $Tracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O $Tracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $Http2Module$ O $Tracer$ O O O O O O O O O O O O O O $Http2Module$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Http2Module$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IncomingMessage , ServerResponse } from 's' ; import * as shimmer from 's' ; import { parse as urlParse } from 's' ; import { PluginTypes } from 's' ; import { 0 , 0 } from 's' ; type 0 = typeof 0 ; type 0 = typeof 0 ; type KoaContext = ( 0 . Context | 0 . Context ) & { routePath ? : string | RegExp ; } ; interface KoaModule < T > { readonly prototype : { use : ( m : T ) => any } ; } type CreateMiddlewareFn < T > = ( api : PluginTypes . Tracer ) => T ; type GetNextFn < T > = ( propagateContext ) => T ; function startSpanForRequest < T > ( api : PluginTypes . Tracer , ctx , getNext < T > ) : T { const req = ctx . req ; const res = ctx . res ; const originalEnd = res . end ; const options = { name : req . url ? urlParse ( req . url ) . pathname || 's' : 's' , url : req . url , method : req . method , traceContext : api . propagation . extract ( key => req . headers [ key ] ) , skipFrames : 0 , } ; return api . runInRootSpan ( options , root => { const responseTraceContext = api . getResponseTraceContext ( options . traceContext , api . isRealSpan ( root ) ) ; if ( responseTraceContext ) { api . propagation . inject ( ( k , v ) => res . setHeader ( k , v ) , responseTraceContext ) ; } if ( ! api . isRealSpan ( root ) ) { return getNext ( false ) ; } api . wrapEmitter ( req ) ; api . wrapEmitter ( res ) ; const url = `template` ; root . addLabel ( api . labels . HTTP_METHOD_LABEL_KEY , req . method ) ; root . addLabel ( api . labels . HTTP_URL_LABEL_KEY , url ) ; root . addLabel ( api . labels . HTTP_SOURCE_IP , ctx . request . ip ) ; res . end = function ( this ) { res . end = originalEnd ; const returned = res . end . apply ( this , arguments ) ; if ( ctx . routePath ) { root . addLabel ( 's' , ctx . routePath ) ; } root . addLabel ( api . labels . HTTP_RESPONSE_CODE_LABEL_KEY , res . statusCode ) ; root . endSpan ( ) ; return returned ; } ; req . once ( 's' , ( ) => { root . addLabel ( api . labels . ERROR_DETAILS_NAME , 's' ) ; root . addLabel ( api . labels . ERROR_DETAILS_MESSAGE , 's' ) ; root . endSpan ( ) ; } ) ; return getNext ( true ) ; } ) ; } function createMiddleware ( api : PluginTypes . Tracer ) : 0 . Middleware { return function * middleware ( this : 0 . Context , next < { } > ) { next = startSpanForRequest ( api , this , ( propagateContext ) => { if ( propagateContext ) { next . next = api . wrap ( next . next as any ) ; } return next ; } ) ; yield next ; } ; } function 0 ( api : PluginTypes . Tracer ) : 0 . Middleware { return function middleware ( ctx , next ) { next = startSpanForRequest ( api , ctx , ( propagateContext ) => propagateContext ? api . wrap ( next ) : next ) ; return next ( ) ; } ; } function patchUse < T > ( koa < T > , api : PluginTypes . Tracer , createMiddlewareFunction < T > ) { shimmer . wrap ( koa . prototype , 's' , use => { return function useTrace ( this : typeof koa . prototype & PluginTypes . TraceAgentExtension ) : typeof koa . prototype { if ( ! this . _google_trace_patched ) { this . _google_trace_patched = true ; this . use ( createMiddlewareFunction ( api ) ) ; } return use . apply ( this , arguments ) ; } ; } ) ; } const plugin : PluginTypes . Plugin = [ { file : 's' , versions : 's' , patch : ( koa , api ) => { patchUse ( koa , api , createMiddleware ) ; } , unpatch => { shimmer . unwrap ( koa . prototype , 's' ) ; } , } as PluginTypes . Monkeypatch < 0 > , { file : 's' , versions : 's' , patch : ( koa , api ) => { patchUse ( koa , api , 0 ) ; } , unpatch => { shimmer . unwrap ( koa . prototype , 's' ) ; } , } as PluginTypes . Monkeypatch < 0 > , ] ; export = plugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O $KoaContext$ O $GetNextFn$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IterableIterator$ O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KoaModule$ O O O O O O O O O O $CreateMiddlewareFn$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $koa$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $koa$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; var shimmer = require ( 's' ) ; var SUPPORTED_VERSIONS = 's' ; function createNextWrap ( api ) { return function nextWrap ( next ) { return function next_trace ( cb ) { var span = api . createChildSpan ( { name : 's' } ) ; if ( ! api . isRealSpan ( span ) ) { return next . apply ( this , arguments ) ; } span . addLabel ( 's' , this . ns ) ; if ( api . enhancedDatabaseReportingEnabled ( ) ) { span . addLabel ( 's' , JSON . stringify ( this . cmd ) ) ; } return next . call ( this , wrapCallback ( api , span , cb ) ) ; } ; } ; } function wrapWithLabel ( api , label ) { return function ( original ) { return function mongo_operation_trace ( ns , ops , options , callback ) { var span = api . createChildSpan ( { name : label } ) ; if ( ! api . isRealSpan ( span ) ) { return original . apply ( this , arguments ) ; } span . addLabel ( 's' , ns ) ; if ( api . enhancedDatabaseReportingEnabled ( ) ) { span . addLabel ( 's' , JSON . stringify ( ops ) ) ; } if ( typeof options === 's' ) { return original . call ( this , ns , ops , wrapCallback ( api , span , options ) ) ; } else { return original . call ( this , ns , ops , options , wrapCallback ( api , span , callback ) ) ; } } ; } ; } function wrapCallback ( api , span , done ) { var fn = function ( err , res ) { if ( api . enhancedDatabaseReportingEnabled ( ) ) { if ( err ) { span . addLabel ( 's' , err ) ; } if ( res ) { var result = res . result ? res . result : res ; span . addLabel ( 's' , result ) ; } } span . endSpan ( ) ; if ( done ) { done ( err , res ) ; } } ; return api . wrap ( fn ) ; } function createOnceWrap ( api ) { return function onceWrap ( once ) { return function once_trace ( event , cb ) { return once . call ( this , event , api . wrap ( cb ) ) ; } ; } ; } module . exports = [ { file : 's' , versions : SUPPORTED_VERSIONS , patch : function ( pool , api ) { shimmer . wrap ( pool . prototype , 's' , createOnceWrap ( api ) ) ; } , unpatch : function ( pool ) { shimmer . unwrap ( pool . prototype , 's' ) ; } } , { file : 's' , versions : SUPPORTED_VERSIONS , patch : function ( mongo , api ) { shimmer . wrap ( mongo . Server . prototype , 's' , wrapWithLabel ( api , 's' ) ) ; shimmer . wrap ( mongo . Server . prototype , 's' , wrapWithLabel ( api , 's' ) ) ; shimmer . wrap ( mongo . Server . prototype , 's' , wrapWithLabel ( api , 's' ) ) ; shimmer . wrap ( mongo . Server . prototype , 's' , wrapWithLabel ( api , 's' ) ) ; shimmer . wrap ( mongo . Cursor . prototype , 's' , createNextWrap ( api ) ) ; } , unpatch : function ( mongo ) { shimmer . unwrap ( mongo . Server . prototype , 's' ) ; shimmer . unwrap ( mongo . Server . prototype , 's' ) ; shimmer . unwrap ( mongo . Server . prototype , 's' ) ; shimmer . unwrap ( mongo . Server . prototype , 's' ) ; shimmer . unwrap ( mongo . Cursor . prototype , 's' ) ; } } ] ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; var shimmer = require ( 's' ) ; var SUPPORTED_VERSIONS = 's' ; function createNextWrap ( api ) { return function nextWrap ( next ) { return function next_trace ( cb ) { var span = api . createChildSpan ( { name : 's' } ) ; if ( ! api . isRealSpan ( span ) ) { return next . apply ( this , arguments ) ; } span . addLabel ( 's' , this . ns ) ; if ( api . enhancedDatabaseReportingEnabled ( ) ) { span . addLabel ( 's' , JSON . stringify ( this . cmd ) ) ; } return next . call ( this , wrapCallback ( api , span , cb ) ) ; } ; } ; } function wrapWithLabel ( api , label ) { return function ( original ) { return function mongo_operation_trace ( ns , ops , options , callback ) { var span = api . createChildSpan ( { name : label } ) ; if ( ! api . isRealSpan ( span ) ) { return original . apply ( this , arguments ) ; } span . addLabel ( 's' , ns ) ; if ( api . enhancedDatabaseReportingEnabled ( ) ) { span . addLabel ( 's' , JSON . stringify ( ops ) ) ; } if ( typeof options === 's' ) { return original . call ( this , ns , ops , wrapCallback ( api , span , options ) ) ; } else { return original . call ( this , ns , ops , options , wrapCallback ( api , span , callback ) ) ; } } ; } ; } function wrapCallback ( api , span , done ) { var fn = function ( err , res ) { if ( api . enhancedDatabaseReportingEnabled ( ) ) { if ( err ) { span . addLabel ( 's' , err ) ; } if ( res ) { var result = res . result ? res . result : res ; span . addLabel ( 's' , result ) ; } } span . endSpan ( ) ; if ( done ) { done ( err , res ) ; } } ; return api . wrap ( fn ) ; } function createOnceWrap ( api ) { return function onceWrap ( once ) { return function once_trace ( event , cb ) { return once . call ( this , event , api . wrap ( cb ) ) ; } ; } ; } module . exports = [ { file : 's' , versions : SUPPORTED_VERSIONS , patch : function ( pool , api ) { shimmer . wrap ( pool . prototype , 's' , createOnceWrap ( api ) ) ; } , unpatch : function ( pool ) { shimmer . unwrap ( pool . prototype , 's' ) ; } } , { file : 's' , versions : SUPPORTED_VERSIONS , patch : function ( mongo , api ) { shimmer . wrap ( mongo . Server . prototype , 's' , wrapWithLabel ( api , 's' ) ) ; shimmer . wrap ( mongo . Server . prototype , 's' , wrapWithLabel ( api , 's' ) ) ; shimmer . wrap ( mongo . Server . prototype , 's' , wrapWithLabel ( api , 's' ) ) ; shimmer . wrap ( mongo . Server . prototype , 's' , wrapWithLabel ( api , 's' ) ) ; shimmer . wrap ( mongo . Cursor . prototype , 's' , createNextWrap ( api ) ) ; } , unpatch : function ( mongo ) { shimmer . unwrap ( mongo . Server . prototype , 's' ) ; shimmer . unwrap ( mongo . Server . prototype , 's' ) ; shimmer . unwrap ( mongo . Server . prototype , 's' ) ; shimmer . unwrap ( mongo . Server . prototype , 's' ) ; shimmer . unwrap ( mongo . Cursor . prototype , 's' ) ; } } ] ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as mongooseTypes from 's' ; import { PluginTypes } from 's' ; const plugin : PluginTypes . Plugin = [ { versions : 's' , file : 's' , intercept : ( Query : typeof mongooseTypes . Query , api ) => { return new Proxy ( Query , { apply ( target , thisArg , args ) { const result = target . apply ( thisArg , args ) ; thisArg . exec = api . wrap ( thisArg . exec ) ; return result ; } } ) ; } } ] ; export = plugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; var shimmer = require ( 's' ) ; var SUPPORTED_VERSIONS = 's' ; function createCreateQueryWrap ( api ) { return function createQueryWrap ( createQuery ) { return function createQuery_trace ( sql , values , cb ) { var span = api . createChildSpan ( { name : 's' } ) ; var query = createQuery . apply ( this , arguments ) ; if ( ! api . isRealSpan ( span ) ) { return query ; } if ( api . enhancedDatabaseReportingEnabled ( ) ) { span . addLabel ( 's' , query . sql ) ; if ( query . values ) { span . addLabel ( 's' , query . values ) ; } } api . wrapEmitter ( query ) ; if ( query . _callback ) { query . _callback = wrapCallback ( api , span , query . _callback ) ; } else { query . on ( 's' , function ( ) { span . endSpan ( ) ; } ) ; } return query ; } ; } ; } function wrapCallback ( api , span , done ) { var fn = function ( err , res ) { if ( api . enhancedDatabaseReportingEnabled ( ) ) { if ( err ) { span . addLabel ( 's' , err ) ; } if ( res ) { span . addLabel ( 's' , res ) ; } } span . endSpan ( ) ; if ( done ) { done ( err , res ) ; } } ; return api . wrap ( fn ) ; } function createWrapGetConnection ( api ) { return function wrapGetConnection ( getConnection ) { return function getConnection_trace ( cb ) { return getConnection . call ( this , api . wrap ( cb ) ) ; } ; } ; } module . exports = [ { file : 's' , versions : SUPPORTED_VERSIONS , patch : function ( Connection , api ) { shimmer . wrap ( Connection , 's' , createCreateQueryWrap ( api ) ) ; } , unpatch : function ( Connection ) { shimmer . unwrap ( Connection , 's' ) ; } } , { file : 's' , versions : SUPPORTED_VERSIONS , patch : function ( Pool , api ) { shimmer . wrap ( Pool . prototype , 's' , createWrapGetConnection ( api ) ) ; } , unpatch : function ( Pool ) { shimmer . unwrap ( Pool . prototype , 's' ) ; } } ] ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; var shimmer = require ( 's' ) ; var SUPPORTED_VERSIONS = 's' ; function createCreateQueryWrap ( api ) { return function createQueryWrap ( createQuery ) { return function createQuery_trace ( sql , values , cb , config ) { var span = api . createChildSpan ( { name : 's' } ) ; var query = createQuery . apply ( this , arguments ) ; if ( ! api . isRealSpan ( span ) ) { return query ; } if ( api . enhancedDatabaseReportingEnabled ( ) ) { span . addLabel ( 's' , query . sql ) ; if ( query . values ) { span . addLabel ( 's' , query . values ) ; } } api . wrapEmitter ( query ) ; if ( query . onResult ) { query . onResult = wrapCallback ( api , span , query . onResult ) ; } else { query . on ( 's' , function ( ) { span . endSpan ( ) ; } ) ; } return query ; } ; } ; } function wrapCallback ( api , span , done ) { var fn = function ( err , res ) { if ( api . enhancedDatabaseReportingEnabled ( ) ) { if ( err ) { span . addLabel ( 's' , err ) ; } if ( res ) { span . addLabel ( 's' , res ) ; } } span . endSpan ( ) ; if ( done ) { done ( err , res ) ; } } ; return api . wrap ( fn ) ; } function createWrapGetConnection ( api ) { return function wrapGetConnection ( getConnection ) { return function getConnection_trace ( cb ) { return getConnection . call ( this , api . wrap ( cb ) ) ; } ; } ; } module . exports = [ { file : 's' , versions : SUPPORTED_VERSIONS , patch : function ( Connection , api ) { shimmer . wrap ( Connection , 's' , createCreateQueryWrap ( api ) ) ; } , unpatch : function ( Connection ) { shimmer . unwrap ( Connection , 's' ) ; } } , { file : 's' , versions : SUPPORTED_VERSIONS , patch : function ( 0 , api ) { shimmer . wrap ( 0 . Pool . prototype , 's' , createWrapGetConnection ( api ) ) ; } , unpatch : function ( 0 ) { shimmer . unwrap ( 0 . Pool . prototype , 's' ) ; } } ] ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' ; import * as shimmer from 's' ; import { Patch , Plugin , Span , Tracer } from 's' ; import { 0 , 0 } from 's' ; type ClientQueryArguments = | [ Submittable & 0 . QueryConfig ] | [ string ] | [ string , { } ] ; type 0 = | ( 0 . QueryConfig & ( { submit : Function } & EventEmitter ) | 0 . Query ) | Promise < 0 . QueryResult > ; type Callback < T > = ( err : Error | null , res ? : T ) => void ; const noOp = ( ) => { } ; function populateLabelsFromInputs ( span , args ) { const queryObj = args [ 0 ] ; if ( typeof queryObj === 's' ) { if ( queryObj . text ) { span . addLabel ( 's' , queryObj . text ) ; } if ( queryObj . values ) { span . addLabel ( 's' , queryObj . values ) ; } } else if ( typeof queryObj === 's' ) { span . addLabel ( 's' , queryObj ) ; if ( args . length >= 0 && typeof args [ 0 ] !== 's' ) { span . addLabel ( 's' , args [ 0 ] ) ; } } } function populateLabelsFromOutputs ( span , err : Error | null , res ? : 0 . QueryResult ) { if ( err ) { span . addLabel ( 's' , err ) ; } if ( res ) { span . addLabel ( 's' , res . rowCount ) ; span . addLabel ( 's' , res . oid ) ; span . addLabel ( 's' , res . rows ) ; span . addLabel ( 's' , res . fields ) ; } } interface Submittable { handleReadyForQuery : ( ) => void ; handleError : ( ) => void ; _result ? : 0 . QueryResult ; } class PostgresPatchUtility { readonly maybePopulateLabelsFromInputs : typeof populateLabelsFromInputs ; readonly maybePopulateLabelsFromOutputs : typeof populateLabelsFromOutputs ; constructor ( private readonly tracer ) { this . maybePopulateLabelsFromInputs = tracer . enhancedDatabaseReportingEnabled ( ) ? populateLabelsFromInputs : noOp ; this . maybePopulateLabelsFromOutputs = tracer . enhancedDatabaseReportingEnabled ( ) ? populateLabelsFromOutputs : noOp ; } patchSubmittable ( pgQuery , span ) { let spanEnded = false ; const { maybePopulateLabelsFromOutputs } = this ; if ( pgQuery . handleError ) { shimmer . wrap ( pgQuery , 's' , origCallback => { return this . tracer . wrap ( function ( this , ... args : any [ ] ) : void { if ( ! spanEnded ) { const err = args [ 0 ] ; maybePopulateLabelsFromOutputs ( span , err ) ; span . endSpan ( ) ; spanEnded = true ; } if ( origCallback ) { origCallback . apply ( this , args ) ; } } ) ; } ) ; } if ( pgQuery . handleReadyForQuery ) { shimmer . wrap ( pgQuery , 's' , origCallback => { return this . tracer . wrap ( function ( this , ... args : any [ ] ) : void { if ( ! spanEnded ) { maybePopulateLabelsFromOutputs ( span , null , this . _result ) ; span . endSpan ( ) ; spanEnded = true ; } if ( origCallback ) { origCallback . apply ( this , args ) ; } } ) ; } ) ; } return pgQuery ; } patchCallback ( callback < 0 . QueryResult > , span ) < 0 . QueryResult > { return this . tracer . wrap ( ( err : Error | null , res ? : 0 . QueryResult ) => { this . maybePopulateLabelsFromOutputs ( span , err , res ) ; span . endSpan ( ) ; callback ( err , res ) ; } ) ; } patchPromise ( promise < 0 . QueryResult > , span ) < 0 . QueryResult > { return ( promise = promise . then ( res => { this . maybePopulateLabelsFromOutputs ( span , null , res ) ; span . endSpan ( ) ; return res ; } , err => { this . maybePopulateLabelsFromOutputs ( span , err ) ; span . endSpan ( ) ; throw err ; } ) ) ; } } const plugin = [ { file : 's' , versions : 's' , patch : ( Client , api ) => { const pgPatch = new PostgresPatchUtility ( api ) ; shimmer . wrap ( Client . prototype , 's' , query => { return function query_trace ( this : 0 . Client , ... args ) { if ( args . length >= 0 ) { const span = api . createChildSpan ( { name : 's' } ) ; if ( ! api . isRealSpan ( span ) ) { return query . apply ( this , args ) ; } pgPatch . maybePopulateLabelsFromInputs ( span , args ) ; if ( typeof args [ 0 ] === 's' ) { pgPatch . patchSubmittable ( args [ 0 ] , span ) ; return query . apply ( this , args ) ; } else { return pgPatch . patchSubmittable ( query . apply ( this , args ) as Submittable , span ) ; } } else { return query . apply ( this , args ) ; } } ; } ) ; } , unpatch ( Client ) { shimmer . unwrap ( Client . prototype , 's' ) ; } , } as Patch < typeof 0 . Client > , { file : 's' , versions : 's' , patch : ( Client , api ) => { const pgPatch = new PostgresPatchUtility ( api ) ; shimmer . wrap ( Client . prototype , 's' , query => { return function query_trace ( this : 0 . Client ) { const span = api . createChildSpan ( { name : 's' } ) ; if ( ! api . isRealSpan ( span ) ) { return query . apply ( this , arguments ) ; } let pgQuery ; const argLength = arguments . length ; if ( argLength >= 0 ) { const args = Array . prototype . slice . call ( arguments , 0 ) ; pgPatch . maybePopulateLabelsFromInputs ( span , args ) ; const callback = args [ args . length - 0 ] ; if ( typeof callback === 's' ) { args [ args . length - 0 ] = pgPatch . patchCallback ( callback as Callback < 0 . QueryResult > , span ) ; } else if ( typeof args [ 0 ] === 's' ) { pgPatch . patchSubmittable ( args [ 0 ] as Submittable , span ) ; } pgQuery = query . apply ( this , args ) ; } else { pgQuery = query . apply ( this , arguments ) ; } if ( pgQuery ) { if ( pgQuery instanceof EventEmitter ) { api . wrapEmitter ( pgQuery ) ; } else if ( typeof pgQuery . then === 's' ) { pgPatch . patchPromise ( pgQuery , span ) ; } } return pgQuery ; } ; } ) ; } , unpatch ( Client ) { shimmer . unwrap ( Client . prototype , 's' ) ; } , } as Patch < typeof 0 . Client > , ] ; export = plugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Span$ O $ClientQueryArguments$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Span$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Tracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Submittable$ O $Submittable$ O $Span$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Submittable$ O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Submittable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Callback$ O $Callback$ O O O O O O $Span$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $Promise$ O O O O O O $Span$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Plugin$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ClientQueryArguments$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PG7QueryReturnValue$ O O O O O O O O O O O O O O O O $ClientQueryArguments$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; var shimmer = require ( 's' ) ; function createCreateClientWrap ( api ) { return function createClientWrap ( createClient ) { return function createClientTrace ( ) { var client = createClient . apply ( this , arguments ) ; api . wrapEmitter ( client ) ; return client ; } ; } ; } function createCreateStreamWrap ( api ) { return function createStreamWrap ( create_stream ) { return function create_stream_trace ( ) { if ( ! this . stream ) { Object . defineProperty ( this , 's' , { get : function ( ) { return this . _google_trace_stream ; } , set : function ( val ) { api . wrapEmitter ( val ) ; this . _google_trace_stream = val ; } } ) ; } return create_stream . apply ( this , arguments ) ; } ; } ; } function createStreamListenersWrap ( api ) { return function streamListenersWrap ( install_stream_listeners ) { return function install_stream_listeners_trace ( ) { api . wrapEmitter ( this . stream ) ; return install_stream_listeners . apply ( this , arguments ) ; } ; } ; } function setupSpan ( api , cmd , args , skipped_frames ) { var span = api . createChildSpan ( { name : 's' + cmd , skipFrames : skipped_frames + 0 } ) ; span . addLabel ( 's' , cmd ) ; if ( api . enhancedDatabaseReportingEnabled ( ) ) { span . addLabel ( 's' , JSON . stringify ( args ) ) ; } return span ; } function startSpanFromArguments ( api , cmd , args , cb , send_command ) { if ( ! cmd || ! args || typeof cmd !== 's' || ! Array . isArray ( args ) || ( cb && typeof cb !== 's' ) ) { return send_command ( cmd , args , cb ) ; } if ( ! cb ) { if ( typeof args [ args . length - 0 ] === 's' || typeof args [ args . length - 0 ] === 's' ) { cb = args . pop ( ) ; } } var span = setupSpan ( api , cmd , args , 0 ) ; if ( ! api . isRealSpan ( span ) ) { return send_command ( cmd , args , cb ) ; } return send_command ( cmd , args , wrapCallback ( api , span , cb ) ) ; } function createInternalSendCommandWrap ( api ) { return function internalSendCommandWrap ( internal_send_command ) { return function internal_send_command_trace ( cmd , args , cb ) { if ( arguments . length === 0 && typeof cmd === 's' ) { var span = setupSpan ( api , cmd . command , cmd . args , 0 ) ; if ( ! api . isRealSpan ( span ) ) { return internal_send_command . call ( this , cmd ) ; } cmd . callback = wrapCallback ( api , span , cmd . callback ) ; return internal_send_command . call ( this , cmd ) ; } return startSpanFromArguments ( api , cmd , args , cb , internal_send_command . bind ( this ) ) ; } ; } ; } function createSendCommandWrap ( api ) { return function sendCommandWrap ( send_command ) { return function send_command_trace ( cmd , args , cb ) { return startSpanFromArguments ( api , cmd , args , cb , send_command . bind ( this ) ) ; } ; } ; } function wrapCallback ( api , span , done ) { var fn = function ( err , res ) { if ( api . enhancedDatabaseReportingEnabled ( ) ) { if ( err ) { span . addLabel ( 's' , err ) ; } if ( res ) { span . addLabel ( 's' , res ) ; } } span . endSpan ( ) ; if ( done ) { done ( err , res ) ; } } ; return api . wrap ( fn ) ; } function wrapInternalSendCommand ( redis , api ) { shimmer . wrap ( redis . RedisClient . prototype , 's' , createInternalSendCommandWrap ( api ) ) ; } function unwrapInternalSendCommand ( redis ) { shimmer . unwrap ( redis . RedisClient . prototype , 's' ) ; } function wrapCreateClient ( redis , api ) { shimmer . wrap ( redis , 's' , createCreateClientWrap ( api ) ) ; } function unwrapCreateClient ( redis ) { shimmer . unwrap ( redis , 's' ) ; } function wrapCreateStream ( redis , api ) { shimmer . wrap ( redis . RedisClient . prototype , 's' , createCreateStreamWrap ( api ) ) ; } function unwrapCreateStream ( redis ) { shimmer . unwrap ( redis . RedisClient . prototype , 's' ) ; } function wrapSendCommand ( redis , api ) { shimmer . wrap ( redis . RedisClient . prototype , 's' , createSendCommandWrap ( api ) ) ; } function unwrapSendCommand ( redis ) { shimmer . unwrap ( redis . RedisClient . prototype , 's' ) ; } function wrapInstallStreamListeners ( redis , api ) { shimmer . wrap ( redis . RedisClient . prototype , 's' , createStreamListenersWrap ( api ) ) ; } function unwrapInstallStreamListeners ( redis ) { shimmer . unwrap ( redis . RedisClient . prototype , 's' ) ; } module . exports = [ { file : 's' , versions : 's' , patch : function ( redis , api ) { wrapCreateStream ( redis , api ) ; wrapInternalSendCommand ( redis , api ) ; wrapCreateClient ( redis , api ) ; } , unpatch : function ( redis ) { unwrapCreateStream ( redis ) ; unwrapInternalSendCommand ( redis ) ; unwrapCreateClient ( redis ) ; } } , { file : 's' , versions : 's' , patch : function ( redis , api ) { wrapSendCommand ( redis , api ) ; wrapCreateStream ( redis , api ) ; wrapCreateClient ( redis , api ) ; } , unpatch : function ( redis ) { unwrapSendCommand ( redis ) ; unwrapCreateStream ( redis ) ; unwrapCreateClient ( redis ) ; } } , { file : 's' , versions : 's' , patch : function ( redis , api ) { wrapSendCommand ( redis , api ) ; wrapInstallStreamListeners ( redis , api ) ; wrapCreateClient ( redis , api ) ; } , unpatch : function ( redis ) { unwrapSendCommand ( redis ) ; unwrapInstallStreamListeners ( redis ) ; unwrapCreateClient ( redis ) ; } } ] ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ServerResponse } from 's' ; import * as shimmer from 's' ; import { parse as urlParse } from 's' ; import { PluginTypes } from 's' ; import { 0 } from 's' ; type 0 = typeof 0 ; type Request = 0 . Request & { route ? : { path : string | RegExp } } ; type Response = 0 . Response ; type Next = 0 . Next ; type CreateServerFn = ( options ? : 0 . ServerOptions ) => 0 . Server ; const SUPPORTED_VERSIONS = 's' ; function unpatchRestify ( restify ) { shimmer . unwrap ( restify , 's' ) ; } function patchRestify ( restify , api : PluginTypes . Tracer ) { shimmer . wrap ( restify , 's' , createServerWrap ) ; function createServerWrap ( createServer ) { return function createServerTrace ( this : { } ) { const server = createServer . apply ( this , arguments ) as 0 . Server ; server . use ( middleware ) ; return server ; } ; } function middleware ( req , res , next ) { const options = { name : req . path ( ) , url : req . url , method : req . method , traceContext : api . propagation . extract ( key => req . header ( key ) ) , skipFrames : 0 , } ; api . runInRootSpan ( options , rootSpan => { const responseTraceContext = api . getResponseTraceContext ( options . traceContext , api . isRealSpan ( rootSpan ) ) ; if ( responseTraceContext ) { api . propagation . inject ( ( k , v ) => res . setHeader ( k , v ) , responseTraceContext ) ; } if ( ! api . isRealSpan ( rootSpan ) ) { return next ( ) ; } api . wrapEmitter ( req ) ; api . wrapEmitter ( res ) ; const fullUrl = `template` ; rootSpan . addLabel ( api . labels . HTTP_METHOD_LABEL_KEY , req . method ) ; rootSpan . addLabel ( api . labels . HTTP_URL_LABEL_KEY , fullUrl ) ; rootSpan . addLabel ( api . labels . HTTP_SOURCE_IP , req . connection . remoteAddress ) ; const originalEnd = res . end ; res . end = function ( this ) { res . end = originalEnd ; const returned = res . end . apply ( this , arguments ) ; if ( req . route && req . route . path ) { rootSpan . addLabel ( 's' , req . route . path ) ; } rootSpan . addLabel ( api . labels . HTTP_RESPONSE_CODE_LABEL_KEY , res . statusCode ) ; rootSpan . endSpan ( ) ; return returned ; } ; next ( ) ; } ) ; } } const plugin : PluginTypes . Plugin = [ { versions : SUPPORTED_VERSIONS , patch : patchRestify , unpatch : unpatchRestify , } as PluginTypes . Monkeypatch < 0 > , ] ; export = plugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Restify5$ O O O O O O O O O O O O O O O $Restify5$ O O O O O O O O O O O O O O O O O O O O $CreateServerFn$ O $CreateServerFn$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $Request$ O $Response$ O $Next$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ServerResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; if ( ! process . env . GCLOUD_PROJECT || ! process . env . GOOGLE_APPLICATION_CREDENTIALS ) { console . error ( 's' + 's' + 's' ) ; process . exit ( 0 ) ; } const WRITE_CONSISTENCY_DELAY_MS = 0 * 0 ; const projectId = process . env . GCLOUD_PROJECT ; const keyFilename = process . env . GOOGLE_APPLICATION_CREDENTIALS ; const EXPECTED_ENDPOINT = 's' ; const tracer = require ( 's' ) . start ( { projectId : projectId , keyFilename : keyFilename , flushDelaySeconds : 0 } ) ; require ( 's' ) ( ) ; const assert = require ( 's' ) ; const googleAuth = require ( 's' ) ; const got = require ( 's' ) ; const queryString = require ( 's' ) ; const uuid = require ( 's' ) ; const semver = require ( 's' ) ; const { Datastore } = require ( 's' ) ; const usingAsyncHooks = semver . satisfies ( process . version , 's' ) ; console . log ( `template` ) ; function makeAuthorizedGot ( auth ) { function authorize ( options ) { return new Promise ( ( resolve , reject ) => { auth . authorizeRequest ( options , ( err , authorizedOptions ) => { if ( err ) { return reject ( err ) ; } return resolve ( authorizedOptions ) ; } ) ; } ) ; } return ( url , options ) => { return authorize ( options ) . then ( ( authorizedOptions ) => { return got ( url , authorizedOptions ) ; } ) ; } ; } function listTraces ( testPath ) { const BASE_URI = `template` ; const auth = googleAuth ( { keyFilename : keyFilename , scopes : [ 's' ] } ) ; const agot = makeAuthorizedGot ( auth ) ; const query = queryString . stringify ( { filter : `template` } ) ; const uri = `template` ; return agot ( uri , { json : true } ) . catch ( ( err ) => { console . error ( err ) ; } ) . then ( ( response ) => { const body = response . body ; const promises = body . traces . map ( ( trace ) => { const uri = `template` ; return agot ( uri , { json : true } ) ; } ) ; return Promise . all ( promises ) . then ( ( responses ) => { return responses . map ( response => response . body ) ; } ) ; } ) ; } describe ( 's' , ( ) => { it ( 's' , ( done ) => { const testPath = `template` ; const express = require ( 's' ) ; const datastore = new Datastore ( { projectId : projectId , keyFilename : keyFilename , } ) ; const app = express ( ) ; app . get ( testPath , ( req , res ) => { const query = datastore . createQuery ( 's' ) . order ( 's' ) ; datastore . runQuery ( query ) . then ( ( results ) => { console . log ( 's' , results ) ; res . status ( 0 ) . send ( 's' ) ; } ) ; } ) ; const server = app . listen ( 0 , ( ) => { console . log ( 's' ) ; got . stream ( `template` ) . pipe ( process . stdout ) ; setTimeout ( ( ) => { listTraces ( testPath ) . then ( verifyTraces ) ; } , WRITE_CONSISTENCY_DELAY_MS ) ; } ) ; function verifyTraces ( traces ) { assert . strictEqual ( traces . length , 0 , 's' ) ; const trace = traces [ 0 ] ; assert . ok ( trace . spans . length >= 0 , 's' ) ; const parent = trace . spans [ 0 ] ; const child = trace . spans . find ( span => { const urlLabelValue = span . labels [ tracer . labels . HTTP_URL_LABEL_KEY ] ; return span . name === `template` || ( urlLabelValue && urlLabelValue . endsWith ( EXPECTED_ENDPOINT ) ) ; } ) ; assert . strictEqual ( parent . name , testPath , 's' ) ; assert . ok ( child ) ; assert . strictEqual ( child . parentSpanId , parent . spanId ) ; server . close ( ) ; done ( ) ; } } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = 0 ;	O O O O O O O
'js' module . exports = 0 ;	O O O O O O O
'js' const base = require ( 's' ) ; const exp = require ( 's' ) ; module . exports = Number ( `template` ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = require ( 's' ) ;	O O O O O O O O O O
'js' module . exports = "s" ;	O O O O O O O
'js' module . exports = require ( 's' ) ;	O O O O O O O O O O
'js' module . exports = "s" ;	O O O O O O O
'js' module . exports = require ( 's' ) ;	O O O O O O O O O O
'js' module . exports = `template` ;	O O O O O O O
'js' module . exports = 0 ;	O O O O O O O
'js' module . exports = require ( 's' ) . version ;	O O O O O O O O O O O O
'js' module . exports = { version : "s" } ;	O O O O O O O O O O O
'js' const ORIGINAL = Symbol ( ) ; module . exports = [ { file : 's' , patch : ( url ) => { url . format = Object . assign ( ( ) => 's' , { [ ORIGINAL ] : url . format } ) ; } , unpatch : ( url ) => { if ( url . format [ ORIGINAL ] ) { url . format = url . format [ ORIGINAL ] ; } } } , { file : 's' , unpatch : ( ) => { } } , { file : 's' , patch : ( ) => { } , intercept : ( ) => { } } , { file : 's' , patch : ( ) => { } } , { file : 's' , patch : ( ) => { } } ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = [ { file : 's' , intercept : ( value ) => { return 0 * value ; } } ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = [ { file : 's' , versions : 's' , intercept : ( myVersion ) => { if ( typeof myVersion === 's' ) { throw new Error ( `template` ) ; } return `template` ; } } , { file : 's' , versions : 's' , intercept : ( myVersion ) => { if ( typeof myVersion === 's' ) { throw new Error ( `template` ) ; } return `template` ; } } ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = [ { versions : 's' , patch : ( myVersion ) => { if ( typeof myVersion !== 's' ) { throw new Error ( `template` ) ; } myVersion . version = 's' ; } } ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = [ { patch : ( smallNumber ) => { smallNumber . value ++ ; } , unpatch : ( smallNumber ) => { smallNumber . value -- ; } } ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { value : 0 } ;	O O O O O O O O O O O
'js' 's' ; var assert = require ( 's' ) ; var agent = require ( 's' ) ; assert ( agent . get ( ) . isActive ( ) ) ; console . log ( 's' ) ; process . exit ( 0 ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' "s" ; exports . __esModule = true ; exports . applyGeneric = function ( fn ) { return fn ( ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O
export const applyGeneric = < T > ( fn : ( ) => T ) : T => fn ( ) ;	O O O O O O O O O O O O O O O O O O O O O O
'js' "s" ; exports . __esModule = true ; exports . applyGeneric = function ( fn ) { return fn ( ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O
export const applyGeneric = < T > ( fn : ( ) => T ) : T => fn ( ) ;	O O O O O O O O O O O O O O O O O O O O O O
'js' "s" ; exports . __esModule = true ; exports . applyGeneric = function ( fn ) { return fn ( ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O
'js' "s" ; exports . __esModule = true ; exports . applyGeneric = function ( fn ) { return fn ( ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; process . env . GCLOUD_TRACE_LOGLEVEL = 0 ; require ( 's' ) ; require ( 's' ) . start ( ) ; process . exit ( 0 ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; module . exports = { logLevel : 0 , stackTraceLimit : 0 , flushDelaySeconds : 0 } ;	O O O O O O O O O O O O O O O O O O O O O
import * as trace from 's' ;	O O O O O O O
import { LEVELS , Logger , LoggerConfig } from 's' ; const PASS_THROUGH_LOG_LEVEL = Number ( process . env . GCLOUD_TEST_LOG_LEVEL || 0 ) ; const OriginalLogger = Logger ; type LoggerFunction < R > = ( message , ... args : any [ ] ) => R ; export class TestLogger extends Logger { private logs : { [ k in keyof Logger ] : string [ ] } = { error : [ ] , warn : [ ] , info : [ ] , debug : [ ] , } ; private innerLogger = new OriginalLogger ( { level : LEVELS [ PASS_THROUGH_LOG_LEVEL ] , } ) ; constructor ( options ? < LoggerConfig > ) { super ( Object . assign ( { tag : 's' } , options ) ) ; } private makeLoggerFn ( logLevel : keyof Logger ) < this > { const that = this ; return function ( this ) { const args = Array . prototype . slice . call ( arguments , 0 ) ; that . logs [ logLevel ] . push ( args . join ( 's' ) ) ; that . innerLogger [ logLevel ] . apply ( this , args ) ; return that ; } ; } error = this . makeLoggerFn ( 's' ) ; warn = this . makeLoggerFn ( 's' ) ; info = this . makeLoggerFn ( 's' ) ; debug = this . makeLoggerFn ( 's' ) ; getLogs ( logLevel : keyof Logger ) : string [ ] { return this . logs [ logLevel ] ; } getNumLogsWith ( logLevel : keyof Logger , strOrReg : string | RegExp ) { if ( typeof strOrReg === 's' ) { return this . logs [ logLevel ] . filter ( line => line . includes ( strOrReg ) ) . length ; } else { return this . logs [ logLevel ] . filter ( line => line . match ( strOrReg ) ) . length ; } } clearLogs ( ) { ( Object . keys ( this . logs ) as Array < keyof Logger > ) . forEach ( logLevel => ( this . logs [ logLevel ] . length = 0 ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O O O O O O O O O O O O O O O O O O O O $LoggerFunction$ O O O O O O O O O O O O O O O O O O $null$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export = { host : 's' , user : 's' , password : 's' , database : 's' } ;	O O O O O O O O O O O O O O O O O O O O
import { HOST_ADDRESS } from 's' ; import * as nock from 's' ; const accept = ( ) => true ; export function 0 < T extends { } = { } > ( validator ? : ( body : T ) => boolean ) : nock . Scope { validator = validator || accept ; return nock ( "s" ) . post ( "s" , validator ) . once ( ) . reply ( 0 , { refresh_token : 's' , access_token : 's' , expiry_date : new Date ( 0 , 0 , 0 ) , } ) ; } export function projectId ( status : number | ( ( ) => string ) , reply ? : ( ) => string ) { if ( typeof status === 's' ) { reply = status ; status = 0 ; } return nock ( HOST_ADDRESS ) . get ( 's' ) . once ( ) . reply ( status , reply , { 's' : 's' } ) ; } export function instanceId ( status : number | ( ( ) => string ) , reply ? : ( ) => string ) { if ( typeof status === 's' ) { reply = status ; status = 0 ; } return nock ( HOST_ADDRESS ) . get ( 's' ) . once ( ) . reply ( status , reply , { 's' : 's' } ) ; } export function hostname ( status : number | ( ( ) => string ) , reply ? : ( ) => string ) { if ( typeof status === 's' ) { reply = status ; status = 0 ; } return nock ( HOST_ADDRESS ) . get ( 's' ) . once ( ) . reply ( status , reply , { 's' : 's' } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; var assert = require ( 's' ) ; var cp = require ( 's' ) ; var glob = require ( 's' ) ; var path = require ( 's' ) ; var tmp = require ( 's' ) ; var expressVersion = 's' ; var express_dir = tmp . dirSync ( ) . name ; cp . execFileSync ( 's' , [ 's' , 's' , expressVersion , 's' , 's' , 's' , express_dir ] ) ; var test_glob = path . join ( express_dir , 's' , 's' ) ; var error ; process . chdir ( express_dir ) ; console . log ( 's' ) ; cp . execFileSync ( 's' , [ 's' , 's' , 's' ] ) ; console . log ( 's' ) ; cp . execFileSync ( 's' , [ 's' ] , { stdio : 's' } ) ; cp . execFileSync ( 's' , [ 's' ] ) ; cp . execFileSync ( 's' , [ 's' , 's' + expressVersion ] ) ; console . log ( 's' ) ; glob ( test_glob , function ( err , files ) { error = error || err ; for ( var i = 0 ; i < files . length ; i ++ ) { cp . execFileSync ( 's' , [ 's' , 's' , files [ i ] ] ) ; } console . log ( 's' ) ; var results = cp . spawnSync ( 's' , [ 's' , path . join ( __dirname , 's' ) , test_glob ] ) ; console . log ( results . output [ 0 ] . toString ( ) || results . output [ 0 ] . toString ( ) ) ; error = error || results . status ; console . log ( 's' ) ; assert ( ! error , error ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; var assert = require ( 's' ) ; var cp = require ( 's' ) ; var fs = require ( 's' ) ; var glob = require ( 's' ) ; var path = require ( 's' ) ; var tmp = require ( 's' ) ; var node_dir = tmp . dirSync ( ) . name ; cp . execFileSync ( 's' , [ 's' , 's' , process . version , 's' , 's' , 's' , node_dir ] ) ; fs . mkdirSync ( path . join ( node_dir , 's' , 's' ) ) ; console . log ( 's' ) ; var testCommonPath = [ path . join ( node_dir , 's' , 's' , 's' ) , path . join ( node_dir , 's' , 's' ) ] . find ( function ( candidatePath ) { return fs . existsSync ( candidatePath ) ; } ) ; if ( ! testCommonPath ) { console . error ( 's' ) ; process . exit ( 0 ) ; } cp . execFileSync ( 's' , [ 's' , 's' + 's' , testCommonPath ] ) ; var test_glob = path . join ( node_dir , 's' , 's' , 's' ) ; console . log ( 's' ) ; var gcloud_require = 's' + path . join ( __dirname , 's' ) + 's' + 's' + path . join ( __dirname , 's' ) + 's' + path . join ( __dirname , 's' ) + 's' + 's' + path . join ( __dirname , 's' ) + 's' ; glob ( test_glob , function ( err , files ) { var errors = 0 ; var testCount ; for ( testCount = 0 ; testCount < files . length ; testCount ++ ) { if ( files [ testCount ] . indexOf ( 's' ) !== - 0 || files [ testCount ] . indexOf ( 's' ) !== - 0 || files [ testCount ] . indexOf ( 's' ) !== - 0 || files [ testCount ] . indexOf ( 's' ) !== - 0 || files [ testCount ] . indexOf ( 's' ) !== - 0 ) { console . log ( 's' + files [ testCount ] ) ; continue ; } const contents = fs . readFileSync ( files [ testCount ] , 's' ) ; const matches = contents . match ( "s" ) ; const flags = matches ? matches [ 0 ] : 's' ; cp . execFileSync ( 's' , [ 's' , 's' + 's' + gcloud_require + 's' , files [ testCount ] ] ) ; if ( cp . spawnSync ( 's' , [ 's' , gcloud_require , files [ testCount ] ] ) . status ) { cp . execSync ( 's' + gcloud_require + 's' + files [ testCount ] + 's' + files [ testCount ] + 's' + 's' + files [ testCount ] + 's' + 's' + files [ testCount ] ) ; } var results = cp . spawnSync ( 's' , [ flags , files [ testCount ] ] ) ; if ( results . status ) { console . log ( 's' + files [ testCount ] ) ; errors ++ ; console . log ( results . stderr . toString ( ) ) ; } else { console . log ( 's' + files [ testCount ] ) ; } } console . log ( 's' + testCount ) ; console . log ( 's' + errors ) ; assert ( ! errors ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; var assert = require ( 's' ) ; var cp = require ( 's' ) ; var glob = require ( 's' ) ; var path = require ( 's' ) ; var tmp = require ( 's' ) ; var branchVersion = 's' ; var restifyVersion = branchVersion ; var restify_dir = tmp . dirSync ( ) . name ; cp . execFileSync ( 's' , [ 's' , 's' , branchVersion , 's' , 's' , 's' , restify_dir ] ) ; var test_glob = path . join ( restify_dir , 's' , 's' ) ; process . chdir ( restify_dir ) ; console . log ( 's' ) ; cp . execFileSync ( 's' , [ 's' , 's' , 's' ] ) ; console . log ( 's' ) ; cp . execFileSync ( 's' , [ 's' ] ) ; cp . execFileSync ( 's' , [ 's' , 's' + restifyVersion ] ) ; console . log ( 's' ) ; var gcloud_require = 's' + path . join ( __dirname , 's' , 's' ) + 's' ; glob ( test_glob , function ( err , files ) { for ( var i = 0 ; i < files . length ; i ++ ) { if ( i === 0 ) { cp . execFileSync ( 's' , [ 's' , 's' + 's' + gcloud_require + 's' , files [ i ] ] ) ; if ( cp . spawnSync ( 's' , [ 's' , gcloud_require , files [ i ] ] ) . status ) { cp . execSync ( 's' + gcloud_require + 's' + files [ i ] + 's' + files [ i ] + 's' + 's' + files [ i ] + 's' + 's' + files [ i ] ) ; } } cp . execFileSync ( 's' , [ 's' , 's' , files [ i ] ] ) ; } console . log ( 's' ) ; var results = cp . spawnSync ( 's' , [ 's' ] ) ; var output = results . output [ 0 ] . toString ( ) || results . output [ 0 ] . toString ( ) ; console . log ( output ) ; assert ( output . indexOf ( 's' ) === - 0 ) ; assert ( output . indexOf ( 's' ) !== - 0 ) ; console . log ( 's' ) ; assert ( ! results . status , results . status ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; var shimmer = require ( 's' ) ; var util = require ( 's' ) ; shimmer . wrap ( util , 's' , function ( ) { return function ( ) { return 's' ; } ; } ) ; require ( 's' ) . start ( { projectId : 's' , logLevel : 0 , samplingRate : 0 } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as rax from 's' ; import * as shimmer from 's' ; import { AxiosRequestConfig } from 's' ; shimmer . wrap ( rax , 's' , attach => { return ( arg ) => { if ( arg ) { shimmer . wrap ( arg , 's' , request => { return ( config ) => { delete config [ 's' ] ; return request ( config ) ; } } ) ; } return attach ( arg ) ; } } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AxiosRequestConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export = { user : 's' , password : 's' , database : 's' } ;	O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as fs from 's' ; import * as semver from 's' ; import { cls } from 's' ; import { OpenCensusPropagation } from 's' ; import { SpanType } from 's' ; import { Span } from 's' ; import { ChildSpanData , RootSpanData } from 's' ; import { TraceSpan } from 's' ; import { StackdriverTracerConfig } from 's' ; export const DEFAULT_SPAN_DURATION = 0 ; export const ASSERT_SPAN_TIME_TOLERANCE_MS = 0 ; export const SERVER_KEY = fs . readFileSync ( `template` ) ; export const SERVER_CERT = fs . readFileSync ( `template` ) ; export class NoPropagation implements OpenCensusPropagation { extract ( ) { return null ; } inject ( ) { } } export function getBaseConfig ( ) { return { enhancedDatabaseReporting : false , rootSpanNameOverride : ( name ) => name , spansPerTraceSoftLimit : Infinity , spansPerTraceHardLimit : Infinity , } ; } export function isServerSpan ( span ) { return span . kind === 's' && ! span . name . startsWith ( 's' ) ; } export function wait ( ms ) { return new Promise ( resolve => setTimeout ( resolve , ms ) ) ; } export function getDuration ( span ) { return Date . parse ( span . endTime ) - Date . parse ( span . startTime ) ; } export function assertSpanDuration ( span , bounds : [ number , number ? ] ) { const spanDuration = getDuration ( span ) ; const lowerBound = bounds [ 0 ] ; const upperBound = bounds [ 0 ] !== undefined ? bounds [ 0 ] : bounds [ 0 ] ; assert . ok ( spanDuration >= lowerBound - ASSERT_SPAN_TIME_TOLERANCE_MS && spanDuration <= upperBound + ASSERT_SPAN_TIME_TOLERANCE_MS , `template` ) ; } export function asRootSpanData ( arg ) { assert . strictEqual ( arg . type , SpanType . ROOT ) ; return arg as RootSpanData ; } export function asChildSpanData ( arg ) { assert . strictEqual ( arg . type , SpanType . CHILD ) ; return arg as ChildSpanData ; } export function hasContext ( ) { return cls . get ( ) . getContext ( ) . type !== SpanType . UNCORRELATED ; } export function plan ( done : Mocha . Done , num ) : Mocha . Done { return ( err ? ) => { if ( err ) { num = 0 ; setImmediate ( done , err ) ; } else { num -- ; if ( num === 0 ) { setImmediate ( done ) ; } else if ( num < 0 ) { throw new Error ( 's' ) ; } } } ; } interface PluginFixtures { [ fixture ] : { dependencies : { [ moduleName ] : string } ; engines ? : { node ? : string } ; _mainModule ? : string ; } ; } interface FixtureHelper < T > { version : string ; parsedVersion : { major : number ; minor : number ; patch : number } ; require : ( ) => T ; skip : ( it : Mocha . TestFunction , versionRange ) => Mocha . PendingTestFunction ; } function getFixturesForModule < T > ( moduleName ) < FixtureHelper < T > > { const pluginFixtures = require ( 's' ) ; const keys = Object . keys ( pluginFixtures ) ; return keys . filter ( key => { const value = pluginFixtures [ key ] ; let mainModule ; if ( value . _mainModule ) { mainModule = value . _mainModule ; } else { const dependencies = Object . keys ( value . dependencies ) ; if ( dependencies . length === 0 ) { return ; } mainModule = dependencies [ 0 ] ; } const moduleNameMatches = mainModule === moduleName ; const versionCompatible = ! value . engines || ! value . engines . node || semver . satisfies ( process . version , value . engines . node ) ; return moduleNameMatches && versionCompatible ; } ) . map ( key => { const version = require ( `template` ) . version as string ; const parsedVersion = semver . parse ( version ) ! ; const getModule : ( ) => T = ( ) => require ( `template` ) ; const skip = ( it : Mocha . TestFunction , versionRange ) => { return semver . satisfies ( version , versionRange ) ? it . skip : it ; } ; return { version , parsedVersion , require : getModule , skip } ; } ) ; } export function describeInterop < T > ( moduleName , describeFn : ( fixture < T > ) => void ) { const fixtures = getFixturesForModule < T > ( moduleName ) ; for ( const fixture of fixtures ) { describe ( `template` , ( ) => describeFn ( fixture ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StackdriverTracerConfig$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $TraceSpan$ O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O $TraceSpan$ O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceSpan$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RootSpanData$ O $Span$ O O O O O O O O O O O O O O O O O O O O O O O $ChildSpanData$ O $Span$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O $Array$ O O O O $string$ O O O O O O O O O $PluginFixtures$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O $string$ O O O O $FixtureHelper$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import 's' ; import { 0 as stackdriverPropagation } from 's' ; import { cls , TraceCLS } from 's' ; import { StackdriverTracer } from 's' ; import { traceWriter } from 's' ; import { SpanType } from 's' ; import { TestLogger } from 's' ; import { getBaseConfig } from 's' ; import { alwaysTrace } from 's' ; var semver = require ( 's' ) ; var trace = require ( 's' ) ; if ( semver . satisfies ( process . version , 's' ) ) { var oldIt = global . it ; global . it = Object . assign ( function it ( title , fn ) { if ( ! fn ) { return oldIt . call ( this , title ) ; } function wrappedFn ( ) { if ( cls . exists ( ) ) { return cls . get ( ) . runWithContext ( ( ) => fn . apply ( this , arguments ) , TraceCLS . UNCORRELATED ) ; } else { return fn . apply ( this , arguments ) ; } } ; Object . defineProperty ( wrappedFn , 's' , { enumerable : false , configurable : true , writable : false , value : fn . length } ) ; return oldIt . call ( this , title , wrappedFn ) ; } , oldIt ) ; } var assert = require ( 's' ) ; var fs = require ( 's' ) ; var path = require ( 's' ) ; var { teenyRequest : request } = require ( 's' ) ; var shimmer = require ( 's' ) ; var testTraceAgent ; shimmer . wrap ( trace , 's' , function ( original ) { return function ( ) { var result = original . apply ( this , arguments ) ; testTraceAgent = new StackdriverTracer ( 's' ) ; testTraceAgent . enable ( getBaseConfig ( ) , { tracePolicy : alwaysTrace ( ) , logger : new TestLogger ( ) , propagation : stackdriverPropagation } ) ; return result ; } ; } ) ; var SERVER_PORT = 0 ; function replaceFunction ( target , prop , fn ) { var old = target [ prop ] ; target [ prop ] = fn ; return old ; } function replaceWarnLogger ( fn ) { var agent = trace . get ( ) ; return replaceFunction ( agent . logger , 's' , fn ) ; } function cleanTraces ( ) { traceWriter . get ( ) [ 's' ] . drain ( ) ; } function getTraces ( ) { return traceWriter . get ( ) [ 's' ] [ 's' ] ; } function getMatchingSpan ( predicate ) { var spans = getMatchingSpans ( predicate ) ; assert . strictEqual ( spans . length , 0 , 's' ) ; return spans [ 0 ] ; } function getMatchingSpans ( predicate ) { var list : any [ ] = [ ] ; getTraces ( ) . forEach ( function ( trace ) { trace . spans . forEach ( function ( span ) { if ( predicate ( span ) ) { list . push ( span ) ; } } ) ; } ) ; return list ; } function runInTransaction ( fn ) { testTraceAgent . runInRootSpan ( { name : 's' } , function ( span ) { return fn ( function ( ) { assert . strictEqual ( span . type , SpanType . ROOT ) ; span . endSpan ( ) ; } ) ; } ) ; } function createChildSpan ( cb , duration ) { var span = testTraceAgent . createChildSpan ( { name : 's' } ) ; assert . ok ( span ) ; var t = setTimeout ( function ( ) { assert . strictEqual ( span . type , SpanType . CHILD ) ; span . endSpan ( ) ; if ( cb ) { cb ( ) ; } } , duration ) ; return function ( ) { assert . strictEqual ( span . type , SpanType . CHILD ) ; span . endSpan ( ) ; clearTimeout ( t ) ; } ; } function installNoopTraceWriter ( ) { traceWriter . get ( ) . writeTrace = function ( ) { } ; } function avoidTraceWriterAuth ( ) { traceWriter . get ( ) . request = request ; } function hasContext ( ) { return cls . get ( ) . getContext ( ) . type !== SpanType . UNCORRELATED ; } module . exports = { cleanTraces : cleanTraces , getMatchingSpan : getMatchingSpan , getMatchingSpans : getMatchingSpans , createChildSpan : createChildSpan , getTraces : getTraces , runInTransaction : runInTransaction , replaceFunction : replaceFunction , replaceWarnLogger : replaceWarnLogger , hasContext : hasContext , installNoopTraceWriter : installNoopTraceWriter , avoidTraceWriterAuth : avoidTraceWriterAuth , serverPort : SERVER_PORT , } ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StackdriverTracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as shimmer from 's' ; import * as trace from 's' ; import { Config , PluginTypes } from 's' ; import { cls , TraceCLS , TraceCLSMechanism } from 's' ; import * as logger from 's' ; import { Trace , TraceSpan } from 's' ; import { PluginLoader , pluginLoader } from 's' ; import { TraceWriter , traceWriter , TraceWriterConfig } from 's' ; import { tracing , Tracing } from 's' ; import { FORCE_NEW } from 's' ; import * as testLogger from 's' ; export { Config , PluginTypes } ; const traces : Trace [ ] = [ ] ; const spans : TraceSpan [ ] = [ ] ; let capturedLogger : testLogger . TestLogger | null = null ; export class TestCLS extends TraceCLS { constructor ( config : { } , logger : logger . Logger ) { super ( { mechanism : TraceCLSMechanism . NONE } , logger ) ; } } export class TestLogger extends testLogger . TestLogger { constructor ( options ? < logger . LoggerConfig > ) { super ( options ) ; capturedLogger = this ; } } export class TestTraceWriter extends TraceWriter { constructor ( config , logger : logger . Logger ) { super ( config , logger ) ; this . getConfig ( ) . authOptions . projectId = 's' ; } async initialize ( ) < void > { } writeTrace ( trace ) { traces . push ( trace ) ; trace . spans . forEach ( span => { spans . push ( span ) ; } ) ; } } export class TestPluginLoader extends PluginLoader { activate ( ) { return this ; } deactivate ( ) { return this ; } } export class TestTracing extends Tracing { } setCLSForTest ( TestCLS ) ; setLoggerForTest ( TestLogger ) ; setTraceWriterForTest ( TestTraceWriter ) ; setPluginLoaderForTest ( TestPluginLoader ) ; setTracingForTest ( TestTracing ) ; export type Predicate < T > = ( value : T ) => boolean ; export function start ( projectConfig ? ) : PluginTypes . Tracer { capturedLogger = null ; const agent = trace . start ( Object . assign ( { samplingRate : 0 , logLevel : 0 , [ FORCE_NEW ] : true } , projectConfig ) ) ; return agent ; } export function get ( ) : PluginTypes . Tracer { return trace . get ( ) ; } export function setLoggerForTest ( impl ? : typeof logger . Logger ) { if ( logger . Logger . __wrapped ) { shimmer . unwrap ( logger , 's' ) ; } if ( impl ) { const wrap = ( ) => shimmer . wrap ( logger , 's' , ( ) => impl ) ; wrap ( ) ; } } export function setCLSForTest ( impl ? : typeof TraceCLS ) { cls [ 's' ] = impl || TraceCLS ; } export function setTraceWriterForTest ( impl ? : typeof TraceWriter ) { traceWriter [ 's' ] = impl || TraceWriter ; } export function setPluginLoaderForTest ( impl ? : typeof PluginLoader ) { pluginLoader [ 's' ] = impl || PluginLoader ; } export function setTracingForTest ( impl ? : typeof Tracing ) { tracing [ 's' ] = impl || Tracing ; } export function getLogger ( ) : testLogger . TestLogger { assert . ok ( capturedLogger ) ; return capturedLogger ! ; } export function getTraces ( predicate ? < Trace > ) : Trace [ ] { if ( ! predicate ) { predicate = ( ) => true ; } return traces . filter ( predicate ) ; } export function getOneTrace ( predicate ? < Trace > ) { const traces = getTraces ( predicate ) ; assert . strictEqual ( traces . length , 0 ) ; return traces [ 0 ] ; } export function getSpans ( predicate ? < TraceSpan > ) : TraceSpan [ ] { if ( ! predicate ) { predicate = ( ) => true ; } return spans . filter ( predicate ) ; } export function getOneSpan ( predicate ? < TraceSpan > ) { const spans = getSpans ( predicate ) ; assert . strictEqual ( spans . length , 0 ) ; return spans [ 0 ] ; } export function clearTraceData ( ) { traces . length = 0 ; spans . length = 0 ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceWriterConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O $void$ O $Trace$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginLoader$ O O O O O O O $PluginLoader$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Config$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Predicate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Trace$ O O $Predicate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Predicate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceSpan$ O O $Predicate$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O
's' ; var common = require ( 's' ) ; var assert = require ( 's' ) ; var http = require ( 's' ) ; var server ; describe ( 's' , function ( ) { var agent ; var oldWarn ; var mongoose ; var express ; before ( function ( ) { agent = require ( 's' ) . start ( { projectId : 's' } ) ; express = require ( 's' ) ; mongoose = require ( 's' ) ; oldWarn = common . replaceWarnLogger ( function ( error ) { assert ( error . indexOf ( 's' ) === - 0 , error ) ; } ) ; } ) ; it ( 's' , function ( done ) { var app = express ( ) ; app . get ( 's' , function ( req , res ) { mongoose . connect ( 's' , function ( err ) { assert ( ! err , 's' ) ; mongoose . connection . close ( function ( err ) { assert ( ! err ) ; res . sendStatus ( 0 ) ; } ) ; } ) ; } ) ; server = app . listen ( common . serverPort , function ( ) { http . get ( { port : common . serverPort } , function ( res ) { server . close ( ) ; common . cleanTraces ( ) ; common . replaceWarnLogger ( oldWarn ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; var assert = require ( 's' ) ; var common = require ( 's' ) ; describe ( 's' , function ( ) { var agent ; var 0 ; var 0 ; before ( function ( ) { agent = require ( 's' ) . start ( { projectId : 's' , enhancedDatabaseReporting : true , samplingRate : 0 } ) ; 0 = require ( 's' ) . createClient ( ) ; 0 . on ( 's' , function ( err ) { assert ( false , 's' + err ) ; } ) ; 0 = require ( 's' ) . createClient ( ) ; 0 . on ( 's' , function ( err ) { assert ( false , 's' + err ) ; } ) ; } ) ; after ( function ( done ) { 0 . quit ( function ( ) { 0 . quit ( function ( ) { done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { 0 . get ( 's' , function ( err , n ) { 0 . get ( 's' , function ( err , n ) { endTransaction ( ) ; var spans = common . getMatchingSpans ( redisPredicate . bind ( null , 's' ) ) ; assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . labels . arguments , 's' ) ; assert . strictEqual ( spans [ 0 ] . labels . command , 's' ) ; assert . strictEqual ( spans [ 0 ] . labels . arguments , 's' ) ; assert . strictEqual ( spans [ 0 ] . labels . command , 's' ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; function redisPredicate ( id , span ) { return span . name . length >= id . length && span . name . substr ( 0 , id . length ) === id ; } export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { FORCE_NEW } from 's' ; var assert = require ( 's' ) ; var common = require ( 's' ) ; var semver = require ( 's' ) ; describe ( 's' , function ( ) { var ROOT_SPAN = 's' ; var 0 = 's' ; var 0 = 's' ; var api ; var genericPool ; before ( function ( ) { api = require ( 's' ) . start ( { projectId : 's' , samplingRate : 0 , [ FORCE_NEW ] : true } ) ; genericPool = require ( 's' ) ; } ) ; after ( function ( ) { common . cleanTraces ( ) ; } ) ; it ( 's' , function ( done ) { var config = { name : 's' , create : function ( callback ) { callback ( function ( ) { var childSpan = api . createChildSpan ( { name : 0 } ) ; assert . ok ( childSpan ) ; childSpan . endSpan ( ) ; } ) ; } , destroy : function ( fn ) { } } ; var pool = new genericPool . Pool ( config ) ; api . runInRootSpan ( { name : ROOT_SPAN } , function ( span ) { pool . acquire ( function ( err , fn ) { assert . ifError ( err ) ; var childSpan = api . createChildSpan ( { name : 0 } ) ; assert . ok ( childSpan ) ; fn ( ) ; childSpan . endSpan ( ) ; span . endSpan ( ) ; var spans = common . getTraces ( api ) [ 0 ] . spans ; assert . ok ( spans ) ; assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . name , ROOT_SPAN ) ; assert . strictEqual ( spans [ 0 ] . name , 0 ) ; assert . strictEqual ( spans [ 0 ] . name , 0 ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; describe ( 's' , function ( ) { var agent ; var genericPool ; if ( semver . satisfies ( process . version , 's' ) ) { console . log ( 's' + process . version + 's' ) ; return ; } before ( function ( ) { agent = require ( 's' ) . start ( { projectId : 's' , samplingRate : 0 , [ FORCE_NEW ] : true } ) ; genericPool = require ( 's' ) ; } ) ; after ( function ( ) { common . cleanTraces ( ) ; } ) ; it ( 's' , function ( ) { var ROOT_SPAN = 's' ; var 0 = 's' ; var 0 = 's' ; var 0 = 's' ; var factory = { create : function ( ) { return new Promise ( function ( resolve , reject ) { resolve ( function ( input ) { assert . strictEqual ( input , 's' ) ; var childSpan = agent . createChildSpan ( { name : 0 } ) ; assert . ok ( childSpan ) ; childSpan . endSpan ( ) ; } ) ; } ) ; } , destroy : function ( fn ) { return new Promise ( function ( resolve ) { resolve ( ) ; } ) ; } } ; var opts = { max : 0 , min : 0 } ; var pool = genericPool . createPool ( factory , opts ) ; var promise ; agent . runInRootSpan ( { name : ROOT_SPAN } , function ( rootSpan ) { promise = pool . acquire ( ) . then ( function ( fn ) { var childSpan = agent . createChildSpan ( { name : 0 } ) ; assert . ok ( childSpan ) ; fn ( 's' ) ; childSpan . endSpan ( ) ; } ) . then ( function ( ) { var childSpan = agent . createChildSpan ( { name : 0 } ) ; assert . ok ( childSpan ) ; childSpan . endSpan ( ) ; rootSpan . endSpan ( ) ; var spans = common . getTraces ( ) [ 0 ] . spans ; assert . ok ( spans ) ; assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . name , ROOT_SPAN ) ; assert . strictEqual ( spans [ 0 ] . name , 0 ) ; assert . strictEqual ( spans [ 0 ] . name , 0 ) ; assert . strictEqual ( spans [ 0 ] . name , 0 ) ; } ) ; } ) ; return promise ; } ) ; } ) ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as testTraceModule from 's' ; import { describeInterop } from 's' ; interface ApiCallSettings { merge : ( ) => { otherArgs : { } ; } ; } type Callback < T > = ( err : Error | null , res ? : T ) => void ; type InnerApiCall < I , O > = ( request : I , metadata : { } , options : { } , callback < O > ) => void ; type OuterApiCall < I , O > = ( request : I , options : { timeout : number } , callback < O > ) => void ; interface GaxModule { createApiCall : < I , O > ( funcWithAuth < InnerApiCall < I , O > > , settings ) => OuterApiCall < I , O > ; } describeInterop < GaxModule > ( 's' , fixture => { let googleGax ; before ( ( ) => { testTraceModule . setCLSForTest ( ) ; testTraceModule . setPluginLoaderForTest ( ) ; testTraceModule . start ( ) ; googleGax = fixture . require ( ) ; } ) ; after ( ( ) => { testTraceModule . setCLSForTest ( testTraceModule . TestCLS ) ; testTraceModule . setPluginLoaderForTest ( testTraceModule . TestPluginLoader ) ; } ) ; it ( `template` , done => { const authPromise = Promise . resolve ( ( ( args , metadata , opts , cb ) => { testTraceModule . get ( ) . createChildSpan ( { name : 's' } ) . endSpan ( ) ; setImmediate ( ( ) => cb ( null , { } ) ) ; } ) as InnerApiCall < { } , { } > ) ; const apiCall = googleGax . createApiCall ( authPromise , { merge : ( ) => ( { otherArgs : { } } ) , } ) ; testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , root => { apiCall ( { } , { timeout : 0 } , err => { assert . ifError ( err ) ; testTraceModule . get ( ) . createChildSpan ( { name : 's' } ) . endSpan ( ) ; root . endSpan ( ) ; const correctTrace = testTraceModule . getOneTrace ( t => t . spans . some ( span => span . name === 's' ) ) ; assert . strictEqual ( correctTrace . spans . length , 0 ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Callback$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Callback$ O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O $ApiCallSettings$ O O O O O O O O O O O O O O O O O O O O O $GaxModule$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { cls } from 's' ; import { Constants } from 's' ; import { TraceLabels } from 's' ; import * as TracingPolicy from 's' ; import * as util from 's' ; import * as assert from 's' ; import { asRootSpanData , describeInterop , DEFAULT_SPAN_DURATION , assertSpanDuration } from 's' ; import { Span } from 's' ; import { FORCE_NEW } from 's' ; var shimmer = require ( 's' ) ; var common = require ( 's' ) ; var protoFile = __dirname + 's' ; var grpcPort = 0 ; var SEND_METADATA = 0 ; var EMIT_ERROR = 0 ; var metadataRegExp = "s" ; var checkMetadata ; const COMMON_TRACE_ID = 's' ; function checkServerMetadata ( metadata ) { if ( checkMetadata ) { var traceContext = metadata . getMap ( ) [ Constants . TRACE_CONTEXT_GRPC_METADATA_NAME ] ; var parsedContext = util . deserializeTraceContext ( traceContext ) ; assert . ok ( parsedContext ) ; var root = asRootSpanData ( cls . get ( ) . getContext ( ) as Span ) ; assert . strictEqual ( parsedContext ! . traceId , COMMON_TRACE_ID ) ; assert . strictEqual ( root . trace . traceId , COMMON_TRACE_ID ) ; assert . strictEqual ( root . span . parentSpanId , parsedContext ! . spanId ) ; } } function startServer ( proto , grpc , agent , metadata , trailing_metadata ) { var _server = new grpc . Server ( ) ; _server . addProtoService ( proto . Tester . service , { testUnary : function ( call , cb ) { checkServerMetadata ( call . metadata ) ; if ( call . request . n === EMIT_ERROR ) { common . createChildSpan ( function ( ) { cb ( new Error ( 's' ) ) ; } , DEFAULT_SPAN_DURATION ) ; } else if ( call . request . n === SEND_METADATA ) { call . sendMetadata ( metadata ) ; setTimeout ( function ( ) { cb ( null , { n : call . request . n } , trailing_metadata ) ; } , DEFAULT_SPAN_DURATION ) ; } else { common . createChildSpan ( function ( ) { cb ( null , { n : call . request . n } ) ; } , DEFAULT_SPAN_DURATION ) ; } } , testClientStream : function ( call , cb ) { checkServerMetadata ( call . metadata ) ; var sum = 0 ; var triggerCb = function ( ) { cb ( null , { n : sum } ) ; } ; var stopChildSpan ; call . on ( 's' , function ( data ) { if ( ! stopChildSpan ) { stopChildSpan = common . createChildSpan ( function ( ) { triggerCb ( ) ; } , DEFAULT_SPAN_DURATION ) ; } sum += data . n ; } ) ; call . on ( 's' , function ( ) { if ( sum === EMIT_ERROR ) { triggerCb = function ( ) { if ( stopChildSpan ) { stopChildSpan ( ) ; } cb ( new Error ( 's' ) ) ; } ; } else if ( sum === SEND_METADATA ) { call . sendMetadata ( metadata ) ; triggerCb = function ( ) { cb ( null , { n : sum } , trailing_metadata ) ; } ; } } ) ; } , testServerStream : function ( stream ) { checkServerMetadata ( stream . metadata ) ; if ( stream . request . n === EMIT_ERROR ) { common . createChildSpan ( function ( ) { stream . emit ( 's' , new Error ( 's' ) ) ; } , DEFAULT_SPAN_DURATION ) ; } else { if ( stream . request . n === SEND_METADATA ) { stream . sendMetadata ( metadata ) ; } for ( var i = 0 ; i < 0 ; ++ i ) { stream . write ( { n : i } ) ; } common . createChildSpan ( function ( ) { stream . end ( ) ; } , DEFAULT_SPAN_DURATION ) ; } } , testBidiStream : function ( stream ) { checkServerMetadata ( stream . metadata ) ; var sum = 0 ; var stopChildSpan ; var t = setTimeout ( function ( ) { stream . end ( ) ; } , DEFAULT_SPAN_DURATION ) ; stream . on ( 's' , function ( data ) { if ( ! stopChildSpan ) { stopChildSpan = common . createChildSpan ( null , DEFAULT_SPAN_DURATION ) ; } sum += data . n ; stream . write ( { n : data . n } ) ; } ) ; stream . on ( 's' , function ( ) { stopChildSpan ( ) ; if ( sum === EMIT_ERROR ) { clearTimeout ( t ) ; setTimeout ( function ( ) { if ( stopChildSpan ) { stopChildSpan ( ) ; } stream . emit ( 's' , new Error ( 's' ) ) ; } , DEFAULT_SPAN_DURATION ) ; } else if ( sum === SEND_METADATA ) { stream . sendMetadata ( metadata ) ; } } ) ; } } ) ; _server . bind ( 's' + grpcPort , grpc . ServerCredentials . createInsecure ( ) ) ; _server . start ( ) ; return _server ; } function createClient ( proto , grpc ) { return new proto . Tester ( 's' + grpcPort , grpc . credentials . createInsecure ( ) ) ; } function callUnary ( client , grpc , metadata , cb ) { var args = [ { n : 0 } , function ( err , result ) { assert . ifError ( err ) ; assert . strictEqual ( result . n , 0 ) ; cb ( ) ; } ] ; if ( Object . keys ( metadata ) . length > 0 ) { var m = new grpc . Metadata ( ) ; for ( var key in metadata ) { m . add ( key , metadata [ key ] ) ; } args . splice ( 0 , 0 , m ) ; } client . testUnary . apply ( client , args ) ; } function callClientStream ( client , grpc , metadata , cb ) { var args = [ function ( err , result ) { assert . ifError ( err ) ; assert . strictEqual ( result . n , 0 ) ; cb ( ) ; } ] ; if ( Object . keys ( metadata ) . length > 0 ) { var m = new grpc . Metadata ( ) ; for ( var key in metadata ) { m . add ( key , metadata [ key ] ) ; } args . unshift ( m ) ; } var stream = client . testClientStream . apply ( client , args ) ; for ( var i = 0 ; i < 0 ; ++ i ) { stream . write ( { n : i } ) ; } stream . end ( ) ; } function callServerStream ( client , grpc , metadata , cb ) { var args = [ { n : 0 } ] ; if ( Object . keys ( metadata ) . length > 0 ) { var m = new grpc . Metadata ( ) ; for ( var key in metadata ) { m . add ( key , metadata [ key ] ) ; } args . push ( m ) ; } var stream = client . testServerStream . apply ( client , args ) ; var sum = 0 ; stream . on ( 's' , function ( data ) { sum += data . n ; } ) ; stream . on ( 's' , function ( status ) { assert . strictEqual ( status . code , grpc . status . OK ) ; assert . strictEqual ( sum , 0 ) ; cb ( ) ; } ) ; } function callBidi ( client , grpc , metadata , cb ) { var args : any [ ] = [ ] ; if ( Object . keys ( metadata ) . length > 0 ) { var m = new grpc . Metadata ( ) ; for ( var key in metadata ) { m . add ( key , metadata [ key ] ) ; } args . push ( m ) ; } var stream = client . testBidiStream . apply ( client , args ) ; var sum = 0 ; stream . on ( 's' , function ( data ) { sum += data . n ; } ) ; for ( var i = 0 ; i < 0 ; ++ i ) { stream . write ( { n : i } ) ; } stream . end ( ) ; stream . on ( 's' , function ( status ) { assert . strictEqual ( status . code , grpc . status . OK ) ; assert . strictEqual ( sum , 0 ) ; cb ( ) ; } ) ; } describeInterop ( 's' , fixture => { var agent ; var grpc ; var metadata ; var server ; var client ; var shouldTraceArgs : any [ ] = [ ] ; before ( function ( ) { shimmer . wrap ( TracingPolicy . BuiltinTracePolicy . prototype , 's' , function ( original ) { return function ( options ) { shouldTraceArgs . push ( options ) ; return original . apply ( this , arguments ) ; } ; } ) ; agent = require ( 's' ) . start ( { projectId : 's' , samplingRate : 0 , enhancedDatabaseReporting : true , [ FORCE_NEW ] : true } ) ; grpc = fixture . require ( ) ; var oldRegister = grpc . Server . prototype . register ; grpc . Server . prototype . register = function register ( n , h , s , d , m ) { var result = oldRegister . call ( this , n , h , s , d , m ) ; var oldFunc = this . handlers [ n ] . func ; this . handlers [ n ] . func = function ( ) { return oldFunc . apply ( this , arguments ) ; } ; return result ; } ; metadata = new grpc . Metadata ( ) ; metadata . set ( 's' , 's' ) ; var trailing_metadata = new grpc . Metadata ( ) ; trailing_metadata . set ( 's' , 's' ) ; var proto = grpc . load ( protoFile ) . nodetest ; server = startServer ( proto , grpc , agent , metadata , trailing_metadata ) ; client = createClient ( proto , grpc ) ; } ) ; after ( function ( ) { server . forceShutdown ( ) ; } ) ; afterEach ( function ( ) { shouldTraceArgs = [ ] ; common . cleanTraces ( ) ; checkMetadata = false ; } ) ; it ( 's' , function ( done ) { var start = Date . now ( ) ; common . runInTransaction ( function ( endTransaction ) { callUnary ( client , grpc , { } , function ( ) { endTransaction ( ) ; var assertTraceProperties = function ( predicate ) { var trace = common . getMatchingSpan ( predicate ) ; assert ( trace ) ; assertSpanDuration ( common . getMatchingSpan ( predicate ) , [ DEFAULT_SPAN_DURATION , Date . now ( ) - start ] ) ; assert . strictEqual ( trace . labels . argument , 's' ) ; assert . strictEqual ( trace . labels . result , 's' ) ; } ; assertTraceProperties ( grpcClientPredicate ) ; assertTraceProperties ( grpcServerOuterPredicate ) ; assert ( common . getMatchingSpan ( grpcServerInnerPredicate ) ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var start = Date . now ( ) ; common . runInTransaction ( function ( endTransaction ) { callClientStream ( client , grpc , { } , function ( ) { endTransaction ( ) ; var assertTraceProperties = function ( predicate ) { var trace = common . getMatchingSpan ( predicate ) ; assert ( trace ) ; assertSpanDuration ( common . getMatchingSpan ( predicate ) , [ DEFAULT_SPAN_DURATION , Date . now ( ) - start ] ) ; assert . strictEqual ( trace . labels . result , 's' ) ; } ; assertTraceProperties ( grpcClientPredicate ) ; assertTraceProperties ( grpcServerOuterPredicate ) ; assert ( common . getMatchingSpan ( grpcServerInnerPredicate ) ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var start = Date . now ( ) ; common . runInTransaction ( function ( endTransaction ) { callServerStream ( client , grpc , { } , function ( ) { endTransaction ( ) ; var assertTraceProperties = function ( predicate ) { var trace = common . getMatchingSpan ( predicate ) ; assert ( trace ) ; assertSpanDuration ( common . getMatchingSpan ( predicate ) , [ DEFAULT_SPAN_DURATION , Date . now ( ) - start ] ) ; assert . strictEqual ( trace . labels . argument , 's' ) ; return trace ; } ; var clientTrace = assertTraceProperties ( grpcClientPredicate ) ; assert . strictEqual ( clientTrace . labels . status , 's' ) ; assertTraceProperties ( grpcServerOuterPredicate ) ; assert ( common . getMatchingSpan ( grpcServerInnerPredicate ) ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var start = Date . now ( ) ; common . runInTransaction ( function ( endTransaction ) { callBidi ( client , grpc , { } , function ( ) { endTransaction ( ) ; var assertTraceProperties = function ( predicate ) { var trace = common . getMatchingSpan ( predicate ) ; assert ( trace ) ; assertSpanDuration ( common . getMatchingSpan ( predicate ) , [ DEFAULT_SPAN_DURATION , Date . now ( ) - start ] ) ; return trace ; } ; var clientTrace = assertTraceProperties ( grpcClientPredicate ) ; assert . strictEqual ( clientTrace . labels . status , 's' ) ; assertTraceProperties ( grpcServerOuterPredicate ) ; assert ( common . getMatchingSpan ( grpcServerInnerPredicate ) ) ; done ( ) ; } ) ; } ) ; } ) ; fixture . skip ( it , 's' ) ( 's' , ( done ) => { common . runInTransaction ( ( endTransaction ) => { client . TestUnary ( { n : 0 } , ( err , result ) => { assert . ifError ( err ) ; assert . strictEqual ( result . n , 0 ) ; endTransaction ( ) ; var assertTraceProperties = function ( predicate ) { var trace = common . getMatchingSpan ( predicate ) ; assert . ok ( trace ) ; assert . strictEqual ( trace . labels . argument , 's' ) ; assert . strictEqual ( trace . labels . result , 's' ) ; } ; assertTraceProperties ( grpcClientPredicate ) ; assertTraceProperties ( grpcServerOuterPredicate ) ; assert . ok ( common . getMatchingSpan ( grpcServerInnerPredicate ) ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { callUnary ( client , grpc , { } , function ( ) { assert . ok ( common . hasContext ( ) ) ; endTransaction ( ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { callUnary ( client , grpc , { } , function ( ) { assert . strictEqual ( common . getMatchingSpans ( grpcClientPredicate ) . length , 0 ) ; done ( ) ; } ) ; } ) ; it ( 's' , function ( done ) { var next = function ( ) { assert . strictEqual ( shouldTraceArgs . length , 0 , 's' + shouldTraceArgs . length + 's' ) ; var prefix = 's' ; assert . strictEqual ( shouldTraceArgs [ 0 ] . url , prefix + 's' ) ; assert . strictEqual ( shouldTraceArgs [ 0 ] . url , prefix + 's' ) ; assert . strictEqual ( shouldTraceArgs [ 0 ] . url , prefix + 's' ) ; assert . strictEqual ( shouldTraceArgs [ 0 ] . url , prefix + 's' ) ; done ( ) ; } ; next = callUnary . bind ( null , client , grpc , { } , next ) ; next = callClientStream . bind ( null , client , grpc , { } , next ) ; next = callServerStream . bind ( null , client , grpc , { } , next ) ; next = callBidi . bind ( null , client , grpc , { } , next ) ; next ( ) ; } ) ; it ( 's' , function ( done ) { function makeLink ( fn , meta , next ) { return function ( ) { agent . runInRootSpan ( { name : 's' , traceContext : { traceId : COMMON_TRACE_ID , spanId : 's' , options : 0 } } , function ( span ) { assert . strictEqual ( span . type , agent . spanTypes . ROOT ) ; fn ( client , grpc , meta , function ( ) { span . endSpan ( ) ; next ( ) ; } ) ; } ) ; } ; } checkMetadata = true ; var next ; var metadata = { a : 's' } ; next = function ( ) { checkMetadata = false ; done ( ) ; } ; next = makeLink ( callUnary , { } , next ) ; next = makeLink ( callClientStream , { } , next ) ; next = makeLink ( callServerStream , { } , next ) ; next = makeLink ( callBidi , { } , next ) ; next = makeLink ( callUnary , metadata , next ) ; next = makeLink ( callClientStream , metadata , next ) ; next = makeLink ( callServerStream , metadata , next ) ; next = makeLink ( callBidi , metadata , next ) ; next ( ) ; } ) ; it ( 's' , function ( done ) { this . timeout ( 0 ) ; var next = done ; var queueCallTogether = function ( first , second ) { var prevNext = next ; next = function ( ) { var startFirst , startSecond , endFirst ; common . runInTransaction ( function ( endTransaction ) { var num = 0 ; common . cleanTraces ( ) ; var callback = function ( ) { if ( num === 0 ) { endFirst = Date . now ( ) ; } if ( ++ num === 0 ) { endTransaction ( ) ; var spans = common . getMatchingSpans ( grpcServerOuterPredicate ) ; assert ( spans . length === 0 ) ; assert ( spans [ 0 ] . spanId !== spans [ 0 ] . spanId ) ; assert ( spans [ 0 ] . startTime !== spans [ 0 ] . startTime ) ; assertSpanDuration ( spans [ 0 ] , [ DEFAULT_SPAN_DURATION , endFirst - startFirst ] ) ; assertSpanDuration ( spans [ 0 ] , [ DEFAULT_SPAN_DURATION , Date . now ( ) - startSecond ] ) ; setImmediate ( prevNext ) ; } } ; startFirst = Date . now ( ) ; first ( callback ) ; setTimeout ( function ( ) { startSecond = Date . now ( ) ; second ( callback ) ; } , DEFAULT_SPAN_DURATION / 0 ) ; } ) ; } ; } ; var methods = [ callUnary . bind ( null , client , grpc , { } ) , callClientStream . bind ( null , client , grpc , { } ) , callServerStream . bind ( null , client , grpc , { } ) , callBidi . bind ( null , client , grpc , { } ) ] ; for ( var m of methods ) { for ( var n of methods ) { queueCallTogether ( m , n ) ; } } next ( ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { client . testUnary ( { n : 0 } , function ( err , result ) { endTransaction ( ) ; assert . ifError ( err ) ; assert . strictEqual ( result . n , 0 ) ; function getMethodName ( predicate ) { var trace = common . getMatchingSpan ( predicate ) ; var labels = trace . labels ; var stack = JSON . parse ( labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ) ; return stack . stack_frame [ 0 ] . method_name ; } assert . notStrictEqual ( - 0 , getMethodName ( grpcClientPredicate ) . indexOf ( 's' ) ) ; assert . notStrictEqual ( - 0 , getMethodName ( grpcServerOuterPredicate ) . indexOf ( 's' ) ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { client . testUnary ( { n : EMIT_ERROR } , function ( err , result ) { endTransaction ( ) ; assert ( err ) ; var assertTraceProperties = function ( predicate ) { var trace = common . getMatchingSpan ( predicate ) ; assert . ok ( trace ) ; assert . strictEqual ( trace . labels . argument , 's' + EMIT_ERROR + 's' ) ; assert . ok ( trace . labels . error . indexOf ( 's' ) !== - 0 ) ; } ; assertTraceProperties ( grpcClientPredicate ) ; assertTraceProperties ( grpcServerOuterPredicate ) ; assert ( common . getMatchingSpan ( grpcServerInnerPredicate ) ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { var stream = client . testClientStream ( function ( err , result ) { endTransaction ( ) ; assert ( err ) ; var assertTraceProperties = function ( predicate ) { var trace = common . getMatchingSpan ( predicate ) ; assert . ok ( trace ) ; assert . ok ( trace . labels . error . indexOf ( 's' ) !== - 0 ) ; } ; assertTraceProperties ( grpcClientPredicate ) ; assertTraceProperties ( grpcServerOuterPredicate ) ; assert ( common . getMatchingSpan ( grpcServerInnerPredicate ) ) ; done ( ) ; } ) ; stream . write ( { n : EMIT_ERROR } ) ; stream . end ( ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { var stream = client . testServerStream ( { n : EMIT_ERROR } , metadata ) ; stream . on ( 's' , function ( data ) { } ) ; stream . on ( 's' , function ( err ) { endTransaction ( ) ; var assertTraceProperties = function ( predicate ) { var trace = common . getMatchingSpan ( predicate ) ; assert . ok ( trace ) ; assert . ok ( trace . labels . error . indexOf ( 's' ) !== - 0 ) ; } ; assertTraceProperties ( grpcClientPredicate ) ; assertTraceProperties ( grpcServerOuterPredicate ) ; assert ( common . getMatchingSpan ( grpcServerInnerPredicate ) ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { var stream = client . testBidiStream ( metadata ) ; stream . on ( 's' , function ( data ) { } ) ; stream . write ( { n : EMIT_ERROR } ) ; stream . end ( ) ; stream . on ( 's' , function ( err ) { endTransaction ( ) ; var assertTraceProperties = function ( predicate ) { var trace = common . getMatchingSpan ( predicate ) ; assert . ok ( trace ) ; assert . ok ( trace . labels . error . indexOf ( 's' ) !== - 0 ) ; } ; assertTraceProperties ( grpcClientPredicate ) ; assertTraceProperties ( grpcServerOuterPredicate ) ; assert ( common . getMatchingSpan ( grpcServerInnerPredicate ) ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var start = Date . now ( ) ; common . runInTransaction ( function ( endTransaction ) { var stream = client . testServerStream ( { n : SEND_METADATA } , metadata ) ; stream . on ( 's' , function ( data ) { } ) ; stream . on ( 's' , function ( status ) { endTransaction ( ) ; assert . strictEqual ( status . code , grpc . status . OK ) ; var assertTraceProperties = function ( predicate ) { var trace = common . getMatchingSpan ( predicate ) ; assert ( trace ) ; assertSpanDuration ( common . getMatchingSpan ( predicate ) , [ DEFAULT_SPAN_DURATION , Date . now ( ) - start ] ) ; assert . ok ( metadataRegExp . test ( trace . labels . metadata ) ) ; } ; assertTraceProperties ( grpcClientPredicate ) ; assertTraceProperties ( grpcServerOuterPredicate ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var start = Date . now ( ) ; common . runInTransaction ( function ( endTransaction ) { var stream = client . testBidiStream ( metadata ) ; stream . on ( 's' , function ( data ) { } ) ; stream . write ( { n : SEND_METADATA } ) ; stream . end ( ) ; stream . on ( 's' , function ( status ) { endTransaction ( ) ; assert . strictEqual ( status . code , grpc . status . OK ) ; var assertTraceProperties = function ( predicate ) { var trace = common . getMatchingSpan ( predicate ) ; assert ( trace ) ; assertSpanDuration ( common . getMatchingSpan ( predicate ) , [ DEFAULT_SPAN_DURATION , Date . now ( ) - start ] ) ; assert . ok ( metadataRegExp . test ( trace . labels . metadata ) ) ; } ; assertTraceProperties ( grpcClientPredicate ) ; assertTraceProperties ( grpcServerOuterPredicate ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; function grpcClientPredicate ( span ) { return span . kind === 's' && span . name . indexOf ( 's' ) === 0 ; } function grpcServerOuterPredicate ( span ) { return span . kind === 's' && span . name . indexOf ( 's' ) === 0 ; } function grpcServerInnerPredicate ( span ) { return span . kind === 's' && span . name === 's' ; } export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { IncomingHttpHeaders } from 's' ; export interface WebFrameworkResponse { statusCode : number ; message : string ; } export type WebFrameworkAddHandlerOptions = { path : string ; } & ( | { hasResponse : false ; blocking : boolean ; fn : ( incomingHeaders ) => Promise < void > ; } | { hasResponse : true ; fn : ( incomingHeaders ) => Promise < WebFrameworkResponse > ; } ) ; export type WebFrameworkHandlerFunction = ( incomingHeaders ) => Promise < void | WebFrameworkResponse > ; export interface WebFramework { addHandler ( options ) : void ; listen ( port ) : number | Promise < number > ; shutdown ( ) : void ; } export interface WebFrameworkConstructor { new ( ) : WebFramework ; versionRange : string ; commonName : string ; expectedTopStackFrame : string ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $IncomingHttpHeaders$ O O O O O O O O O O O O O O O O O $IncomingHttpHeaders$ O O O O O O O O O O O O O O O $IncomingHttpHeaders$ O O O O O O O O O O O O O O O $WebFrameworkAddHandlerOptions$ O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as http from 's' ; import { AddressInfo } from 's' ; import { 0 } from 's' ; import { WebFramework , WebFrameworkAddHandlerOptions , WebFrameworkResponse , } from 's' ; export class 0 implements WebFramework { static commonName = 's' ; static expectedTopStackFrame = 's' ; static versionRange = 's' ; app : 0 . Application ; server : http . Server | null = null ; constructor ( ) { const express = require ( 's' ) as typeof 0 ; this . app = express ( ) ; } addHandler ( options ) { if ( ! options . hasResponse && ! options . blocking ) { throw new Error ( `template` ) ; } this . app . get ( options . path , async ( req , res , next ) => { let response : WebFrameworkResponse | void ; try { response = await options . fn ( req . headers ) ; } catch ( e ) { next ( e ) ; return ; } if ( response ) { res . status ( response . statusCode ) ; res . send ( response . message ) ; } else { next ( ) ; } } ) ; } listen ( port ) { this . app . use ( ( err , req : { } , res : 0 . Response , next : { } ) => { if ( err ) { res . sendStatus ( 0 ) ; } } ) ; if ( this . server ) { throw new Error ( 's' ) ; } this . server = this . app . listen ( port ) ; return ( this . server ! . address ( ) as AddressInfo ) . port ; } shutdown ( ) { if ( ! this . server ) { throw new Error ( 's' ) ; } this . server . close ( ) ; this . server = null ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $WebFrameworkAddHandlerOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { AddressInfo } from 's' ; import * as fs from 's' ; import * as path from 's' ; import { 0 } from 's' ; import * as httpModule from 's' ; import * as httpsModule from 's' ; export class 0 extends 0 { static key = fs . readFileSync ( path . join ( __dirname , 's' , 's' , 's' ) ) ; static cert = fs . readFileSync ( path . join ( __dirname , 's' , 's' , 's' ) ) ; private https : typeof httpsModule ; constructor ( ) { super ( ) ; this . https = require ( 's' ) ; } listen ( port ) { this . server = ( this . https . createServer ( { key : 0 . key , cert : 0 . cert } , this . app ) as { } ) as httpModule . Server ; this . server . listen ( port ) ; return ( this . server . address ( ) as AddressInfo ) . port ; } shutdown ( ) { this . server ! . close ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import { EventEmitter } from 's' ; import * as httpModule from 's' ; import * as httpsModule from 's' ; import * as stream from 's' ; import { URL } from 's' ; import * as semver from 's' ; import { Constants } from 's' ; import { SpanKind , TraceSpan } from 's' ; import { parseContextFromHeader , TraceContext } from 's' ; import * as testTraceModule from 's' ; import { assertSpanDuration , DEFAULT_SPAN_DURATION } from 's' ; import { 0 } from 's' ; import { 0 } from 's' ; type HttpRequest = ( url : string | httpModule . RequestOptions | httpsModule . RequestOptions | URL , options ? : | httpModule . RequestOptions | httpsModule . RequestOptions | ( ( res : httpModule . IncomingMessage ) => void ) , callback ? : ( res : httpModule . IncomingMessage ) => void ) => httpModule . ClientRequest ; class WaitForResponse { private resolve ! : ( value ) => void ; private reject ! : ( err ) => void ; readonly done : Promise < string > ; handleResponse = ( res : httpModule . IncomingMessage ) => { let data = 's' ; res . on ( 's' , d => ( data += d ) ) ; res . on ( 's' , this . reject ) ; res . on ( 's' , ( ) => this . resolve ( data ) ) ; } ; constructor ( ) { this . done = new Promise ( ( resolve , reject ) => { this . resolve = resolve ; this . reject = reject ; } ) ; } handleDone ( ) { this . resolve ( 's' ) ; } } const wait = ( ms ) => new Promise ( resolve => setTimeout ( resolve , ms ) ) ; const servers = { http : 0 , https : 0 , } ; for ( const nodule of Object . keys ( servers ) as Array < keyof typeof servers > ) { const ServerFramework = servers [ nodule ] ; describe ( `template` , ( ) => { let http : { get : HttpRequest ; request : HttpRequest } ; before ( ( ) => { testTraceModule . setCLSForTest ( ) ; testTraceModule . setPluginLoaderForTest ( ) ; testTraceModule . start ( { plugins : { express : 's' , } , } ) ; http = require ( nodule ) ; } ) ; afterEach ( ( ) => { testTraceModule . clearTraceData ( ) ; } ) ; describe ( 's' , ( ) => { let server ; let port ; const testCases = [ { description : 's' , fn : async ( ) => { const waitForResponse = new WaitForResponse ( ) ; http . get ( { port , rejectUnauthorized : false } , waitForResponse . handleResponse ) ; await waitForResponse . done ; } , } , { description : 's' , fn : async ( ) => { const waitForResponse = new WaitForResponse ( ) ; http . get ( 's' , { protocol : `template` , hostname : 's' , port , rejectUnauthorized : false , } , waitForResponse . handleResponse ) ; await waitForResponse . done ; } , versions : 's' , } , { description : 's' , fn : async ( ) => { const waitForResponse = new WaitForResponse ( ) ; const req = http . get ( { port , rejectUnauthorized : false } ) ; req . on ( 's' , waitForResponse . handleResponse ) ; await waitForResponse . done ; } , } , { description : 's' , fn : async ( ) => { const waitForResponse = new WaitForResponse ( ) ; http . get ( { port , rejectUnauthorized : false } , res => { let result = 's' ; const writable = new stream . Writable ( ) ; writable . _write = ( chunk , encoding , next ) => { result += chunk ; next ( ) ; } ; writable . on ( 's' , ( ) => { waitForResponse . handleDone ( ) ; } ) ; setImmediate ( ( ) => { res . pipe ( writable ) ; } ) ; } ) ; await waitForResponse . done ; } , } , { description : 's' , fn : async ( ) => { const waitForResponse = new WaitForResponse ( ) ; const req = http . request ( { port , rejectUnauthorized : false } , waitForResponse . handleResponse ) ; req . end ( ) ; await waitForResponse . done ; } , } , { description : 's' , fn : async ( ) => { server . server ! . timeout = DEFAULT_SPAN_DURATION / 0 ; const waitForResponse = new WaitForResponse ( ) ; const req = http . get ( { port , rejectUnauthorized : false } ) ; req . on ( 's' , ( ) => { waitForResponse . handleDone ( ) ; } ) ; await waitForResponse . done ; } , } , ... [ 's' , 's' , 's' , 's' ] . map ( key => ( { description : `template` , fn : async ( ) => { const waitForResponse = new WaitForResponse ( ) ; http . get ( { port , rejectUnauthorized : false , headers : { [ key ] : 's' } , } , waitForResponse . handleResponse ) ; await waitForResponse . done ; } , } ) ) , ] ; beforeEach ( async ( ) => { server = new ServerFramework ( ) ; server . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => { await wait ( DEFAULT_SPAN_DURATION ) ; return { statusCode : 0 , message : 's' } ; } , } ) ; port = server . listen ( 0 ) ; } ) ; afterEach ( ( ) => { server . shutdown ( ) ; } ) ; for ( const testCase of testCases ) { const maybeIt = ! testCase . versions || semver . satisfies ( process . version , testCase . versions ) ? it : it . skip ; maybeIt ( `template` , async ( ) => { let recordedTime = 0 ; await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async rootSpan => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( rootSpan ) ) ; recordedTime = Date . now ( ) ; await testCase . fn ( ) ; recordedTime = Date . now ( ) - recordedTime ; rootSpan . endSpan ( ) ; } ) ; const clientSpan = testTraceModule . getOneSpan ( span => span . kind === 's' ) ; assertSpanDuration ( clientSpan , [ recordedTime ] ) ; } ) ; } } ) ; const maybeIt = nodule === 's' ? it : it . skip ; maybeIt ( 's' , async ( ) => { const server = new ServerFramework ( ) ; server . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => { return { statusCode : 0 , message : 's' } ; } , } ) ; const port = server . listen ( 0 ) ; try { await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async rootSpan => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( rootSpan ) ) ; const waitForResponse = new WaitForResponse ( ) ; http . get ( `template` , waitForResponse . handleResponse ) ; await waitForResponse . done ; rootSpan . endSpan ( ) ; } ) ; assert . doesNotThrow ( ( ) => testTraceModule . getOneSpan ( span => span . kind === 's' ) ) ; } finally { server . shutdown ( ) ; } } ) ; it ( 's' , async ( ) => { const server = new ServerFramework ( ) ; let serverCapturedTraceContext : TraceContext | null = null ; server . addHandler ( { path : 's' , hasResponse : true , fn : async headers => { const traceContext = headers [ Constants . TRACE_CONTEXT_HEADER_NAME ] ; assert . ok ( traceContext && typeof traceContext === 's' ) ; serverCapturedTraceContext = parseContextFromHeader ( traceContext as string ) ; return { statusCode : 0 , message : 's' } ; } , } ) ; const port = server . listen ( 0 ) ; try { await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async rootSpan => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( rootSpan ) ) ; const waitForResponse = new WaitForResponse ( ) ; http . get ( { port , rejectUnauthorized : false } , waitForResponse . handleResponse ) ; await waitForResponse . done ; rootSpan . endSpan ( ) ; } ) ; } finally { server . shutdown ( ) ; } const clientTrace = testTraceModule . getOneTrace ( ) ; assert . strictEqual ( clientTrace . spans . length , 0 ) ; assert . strictEqual ( clientTrace . spans [ 0 ] . kind , SpanKind . RPC_CLIENT ) ; const httpSpan = clientTrace . spans [ 0 ] ; assert . ok ( serverCapturedTraceContext ) ; assert . strictEqual ( serverCapturedTraceContext ! . traceId , clientTrace . traceId ) ; assert . strictEqual ( serverCapturedTraceContext ! . spanId , httpSpan . spanId ) ; } ) ; it ( 's' , async ( ) => { const server = new ServerFramework ( ) ; server . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => { return { statusCode : 0 , message : 's' } ; } , } ) ; const port = server . listen ( 0 ) ; try { await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async rootSpan => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( rootSpan ) ) ; const waitForResponse = new WaitForResponse ( ) ; http . get ( { port , rejectUnauthorized : false } , waitForResponse . handleResponse ) ; await waitForResponse . done ; const afterHttpSpan = testTraceModule . get ( ) . createChildSpan ( { name : 's' } ) ; assert . ok ( testTraceModule . get ( ) . isRealSpan ( afterHttpSpan ) ) ; afterHttpSpan . endSpan ( ) ; rootSpan . endSpan ( ) ; } ) ; } finally { server . shutdown ( ) ; } } ) ; it ( 's' , async ( ) => { const server = new ServerFramework ( ) ; server . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => { return { statusCode : 0 , message : 's' } ; } , } ) ; const port = server . listen ( 0 ) ; try { await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async rootSpan => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( rootSpan ) ) ; const waitForResponse = new WaitForResponse ( ) ; const headers : httpModule . OutgoingHttpHeaders = { } ; headers [ testTraceModule . get ( ) . constants . TRACE_AGENT_REQUEST_HEADER ] = 's' ; http . get ( { port , rejectUnauthorized : false , headers } , waitForResponse . handleResponse ) ; await waitForResponse . done ; rootSpan . endSpan ( ) ; } ) ; assert . strictEqual ( testTraceModule . getSpans ( span => span . kind === 's' ) . length , 0 ) ; } finally { server . shutdown ( ) ; } } ) ; it ( 's' , ( ) => { return new Promise ( resolve => testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , rootSpan => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( rootSpan ) ) ; const req = ( http . get as ( arg ? : { } ) => EventEmitter ) ( ) ; req . on ( 's' , resolve ) ; req . on ( 's' , resolve ) ; rootSpan . endSpan ( ) ; } ) ) ; } ) ; it ( 's' , async ( ) => { const server = new ServerFramework ( ) ; let statusCode = 0 ; server . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => { await wait ( DEFAULT_SPAN_DURATION ) ; return { statusCode : statusCode ++ , message : 's' } ; } , } ) ; const port = server . listen ( 0 ) ; try { await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async rootSpan => { await Promise . all ( [ 0 , 0 , 0 , 0 , 0 ] . map ( async i => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( rootSpan ) ) ; const waitForResponse = new WaitForResponse ( ) ; http . get ( { port , rejectUnauthorized : false } , waitForResponse . handleResponse ) ; await waitForResponse . done ; } ) ) ; rootSpan . endSpan ( ) ; } ) ; assert . strictEqual ( testTraceModule . getSpans ( span => span . kind === 's' ) . map ( span => Number ( span . labels [ testTraceModule . get ( ) . labels . HTTP_RESPONSE_CODE_LABEL_KEY ] ) ) . reduce ( ( a , b ) => a + b , 0 ) , 0 ) ; } finally { server . shutdown ( ) ; } } ) ; describe ( 's' , ( ) => { const ERROR_DETAILS_NAME = testTraceModule . get ( ) . labels . ERROR_DETAILS_NAME ; const ERROR_DETAILS_MESSAGE = testTraceModule . get ( ) . labels . ERROR_DETAILS_MESSAGE ; let port ; let successSpan ; let errorSpan ; before ( async ( ) => { const server = new ServerFramework ( ) ; server . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => { await wait ( DEFAULT_SPAN_DURATION ) ; return { statusCode : 0 , message : 's' } ; } , } ) ; port = server . listen ( 0 ) ; await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async rootSpan => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( rootSpan ) ) ; let waitForResponse = new WaitForResponse ( ) ; http . get ( { port , rejectUnauthorized : false , path : 's' } , waitForResponse . handleResponse ) ; await waitForResponse . done ; server . server ! . timeout = DEFAULT_SPAN_DURATION / 0 ; waitForResponse = new WaitForResponse ( ) ; http . get ( { port , rejectUnauthorized : false } ) . on ( 's' , ( ) => { waitForResponse . handleDone ( ) ; } ) ; await waitForResponse . done ; rootSpan . endSpan ( ) ; } ) ; successSpan = testTraceModule . getOneSpan ( span => span . kind === 's' && ! span . labels [ ERROR_DETAILS_NAME ] ) ; errorSpan = testTraceModule . getOneSpan ( span => span . kind === 's' && ! ! span . labels [ ERROR_DETAILS_NAME ] ) ; server . shutdown ( ) ; } ) ; it ( 's' , ( ) => { assert . strictEqual ( successSpan . name , 's' ) ; } ) ; it ( 's' , ( ) => { assert . strictEqual ( successSpan . labels [ testTraceModule . get ( ) . labels . HTTP_URL_LABEL_KEY ] , `template` ) ; } ) ; it ( 's' , ( ) => { assert . strictEqual ( errorSpan . labels [ ERROR_DETAILS_NAME ] , 's' ) ; assert . strictEqual ( errorSpan . labels [ ERROR_DETAILS_MESSAGE ] , 's' ) ; } ) ; } ) ; } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Express4$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $TraceSpan$ O O $TraceSpan$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as 0 from 's' ; import * as semver from 's' ; import * as stream from 's' ; import { Constants , SpanType } from 's' ; import { TraceLabels } from 's' ; import * as traceTestModule from 's' ; import { assertSpanDuration , DEFAULT_SPAN_DURATION , hasContext , SERVER_CERT , SERVER_KEY , } from 's' ; const serverRes = 's' ; const serverPort = 0 ; const 0 = semver . satisfies ( process . version , 's' ) ? describe . skip : describe ; 0 ( 's' , ( ) => { let 0 : typeof 0 ; before ( ( ) => { traceTestModule . setPluginLoaderForTest ( ) ; traceTestModule . setCLSForTest ( ) ; traceTestModule . start ( ) ; 0 = require ( 's' ) ; } ) ; after ( ( ) => { traceTestModule . setPluginLoaderForTest ( traceTestModule . TestPluginLoader ) ; traceTestModule . setCLSForTest ( traceTestModule . TestCLS ) ; } ) ; afterEach ( ( ) => { traceTestModule . clearTraceData ( ) ; } ) ; describe ( 's' , ( ) => { let server : 0 . 0 ; before ( ( ) => { server = 0 . createServer ( ) ; server . on ( 's' , s => { setTimeout ( ( ) => { s . respond ( { 's' : 0 } ) ; s . end ( serverRes ) ; } , DEFAULT_SPAN_DURATION ) ; } ) ; } ) ; afterEach ( done => { if ( server . listening ) { server . close ( done ) ; } else { done ( ) ; } } ) ; it ( 's' , ( ) => { assert . strictEqual ( 0 . connect [ 's' ] , true ) ; } ) ; it ( 's' , done => { server . listen ( serverPort , ( ) => { traceTestModule . get ( ) . runInRootSpan ( { name : 's' } , rootSpan => { assert . ok ( rootSpan . type === SpanType . ROOT ) ; const start = Date . now ( ) ; const session = 0 . connect ( `template` ) ; const s = session . request ( { 's' : 's' } ) ; s . setEncoding ( 's' ) ; let result = 's' ; s . on ( 's' , ( data ) => { result += data ; } ) . on ( 's' , ( ) => { rootSpan . endSpan ( ) ; assert . strictEqual ( result , serverRes ) ; assertSpanDuration ( traceTestModule . getOneSpan ( span => span . name !== 's' ) , [ DEFAULT_SPAN_DURATION , Date . now ( ) - start ] ) ; session . destroy ( ) ; done ( ) ; } ) ; s . end ( ) ; } ) ; } ) ; } ) ; it ( 's' , done => { server . listen ( serverPort , ( ) => { traceTestModule . get ( ) . runInRootSpan ( { name : 's' } , rootSpan => { assert . ok ( rootSpan . type === SpanType . ROOT ) ; const session = 0 . connect ( `template` ) ; const s = session . request ( { 's' : 's' } ) ; s . on ( 's' , ( ) => { assert . ok ( hasContext ( ) ) ; } ) . on ( 's' , ( ) => { assert . ok ( hasContext ( ) ) ; rootSpan . endSpan ( ) ; session . destroy ( ) ; done ( ) ; } ) ; s . end ( ) ; } ) ; } ) ; } ) ; it ( 's' , done => { server . listen ( serverPort , ( ) => { traceTestModule . get ( ) . runInRootSpan ( { name : 's' } , rootSpan => { assert . ok ( rootSpan . type === SpanType . ROOT ) ; const session = 0 . connect ( `template` ) ; const headers : 0 . OutgoingHttpHeaders = { 's' : 's' } ; headers [ Constants . TRACE_AGENT_REQUEST_HEADER ] = 's' ; const s = session . request ( headers ) ; s . end ( ) ; setTimeout ( ( ) => { rootSpan . endSpan ( ) ; const traces = traceTestModule . getTraces ( ) ; assert . strictEqual ( traces . length , 0 ) ; assert . strictEqual ( traces [ 0 ] . spans . length , 0 ) ; assert . strictEqual ( traces [ 0 ] . spans [ 0 ] . name , 's' ) ; session . destroy ( ) ; done ( ) ; } , DEFAULT_SPAN_DURATION * 0 ) ; } ) ; } ) ; } ) ; it ( 's' , done => { server . listen ( serverPort , ( ) => { traceTestModule . get ( ) . runInRootSpan ( { name : 's' } , rootSpan => { assert . ok ( rootSpan . type === SpanType . ROOT ) ; const session = 0 . connect ( `template` ) ; const s = session . request ( ) ; s . setEncoding ( 's' ) ; s . on ( 's' , ( data ) => { } ) . on ( 's' , ( ) => { rootSpan . endSpan ( ) ; const traces = traceTestModule . getTraces ( ) ; assert . strictEqual ( traces . length , 0 ) ; assert . strictEqual ( traces [ 0 ] . spans [ 0 ] . labels [ 's' ] , 's' ) ; assert . strictEqual ( traces [ 0 ] . spans [ 0 ] . labels [ 's' ] , `template` ) ; session . destroy ( ) ; done ( ) ; } ) ; s . end ( ) ; } ) ; } ) ; } ) ; it ( 's' , done => { server . listen ( serverPort , ( ) => { traceTestModule . get ( ) . runInRootSpan ( { name : 's' } , rootSpan => { assert . ok ( rootSpan . type === SpanType . ROOT ) ; const start = Date . now ( ) ; const session = 0 . connect ( `template` ) ; const s = session . request ( { 's' : 's' } ) ; let result = 's' ; const writable = new stream . Writable ( ) ; writable . _write = ( chunk , encoding , next ) => { result += chunk ; next ( ) ; } ; writable . on ( 's' , ( ) => { rootSpan . endSpan ( ) ; assert . strictEqual ( result , serverRes ) ; assertSpanDuration ( traceTestModule . getOneSpan ( span => span . name !== 's' ) , [ DEFAULT_SPAN_DURATION , Date . now ( ) - start ] ) ; session . destroy ( ) ; done ( ) ; } ) ; setImmediate ( ( ) => { s . pipe ( writable ) ; } ) ; s . end ( ) ; } ) ; } ) ; } ) ; it ( 's' , done => { server . listen ( serverPort , ( ) => { traceTestModule . get ( ) . runInRootSpan ( { name : 's' } , rootSpan => { assert . ok ( rootSpan . type === SpanType . ROOT ) ; const session = 0 . connect ( `template` ) ; const s = session . request ( { 's' : 's' } ) ; s . on ( 's' , ( ) => { } ) ; s . end ( ) ; setTimeout ( ( ) => { rootSpan . endSpan ( ) ; const traces = traceTestModule . getTraces ( ) ; assert . strictEqual ( traces . length , 0 ) ; assert . strictEqual ( traces [ 0 ] . spans [ 0 ] . name , 's' ) ; session . destroy ( ) ; done ( ) ; } , DEFAULT_SPAN_DURATION * 0 ) ; } ) ; } ) ; } ) ; it ( 's' , done => { server . listen ( serverPort , ( ) => { traceTestModule . get ( ) . runInRootSpan ( { name : 's' } , rootSpan => { assert . ok ( rootSpan . type === SpanType . ROOT ) ; const session = 0 . connect ( `template` ) ; const s = session . request ( { 's' : 's' } ) ; s . on ( 's' , ( ) => { } ) ; s . end ( ) ; setTimeout ( ( ) => { rootSpan . endSpan ( ) ; const traces = traceTestModule . getTraces ( ) ; assert . strictEqual ( traces . length , 0 ) ; assert . strictEqual ( traces [ 0 ] . spans [ 0 ] . labels [ 's' ] , `template` ) ; session . destroy ( ) ; done ( ) ; } , DEFAULT_SPAN_DURATION * 0 ) ; } ) ; } ) ; } ) ; it ( 's' , done => { const server : 0 . 0 = 0 . createServer ( ) ; server . on ( 's' , ( s : 0 . 0 & ( { rstWithInternalError : ( ) => void } ) ) => { s . on ( 's' , ( ) => { } ) ; setTimeout ( ( ) => { if ( semver . satisfies ( process . version , 's' ) ) { s . close ( 0 . constants . 0 ) ; } else { s . rstWithInternalError ( ) ; } } , DEFAULT_SPAN_DURATION / 0 ) ; } ) ; server . listen ( serverPort , ( ) => { traceTestModule . get ( ) . runInRootSpan ( { name : 's' } , rootSpan => { assert . ok ( rootSpan . type === SpanType . ROOT ) ; const start = Date . now ( ) ; const session = 0 . connect ( `template` ) ; const s = session . request ( { 's' : 's' } ) ; s . on ( 's' , ( ) => { rootSpan . endSpan ( ) ; const span = traceTestModule . getOneSpan ( span => span . name !== 's' ) ; assertSpanDuration ( span , [ DEFAULT_SPAN_DURATION / 0 , Date . now ( ) - start , ] ) ; if ( semver . satisfies ( process . version , 's' ) ) { assert . strictEqual ( span . labels [ TraceLabels . ERROR_DETAILS_NAME ] , 's' ) ; } else { assert . strictEqual ( span . labels [ TraceLabels . ERROR_DETAILS_NAME ] , 's' ) ; } if ( semver . satisfies ( process . version , 's' ) ) { assert . strictEqual ( span . labels [ TraceLabels . ERROR_DETAILS_MESSAGE ] , 's' ) ; } else { assert . strictEqual ( span . labels [ TraceLabels . ERROR_DETAILS_MESSAGE ] , 's' ) ; } session . destroy ( ) ; server . close ( ) ; done ( ) ; } ) ; s . end ( ) ; } ) ; } ) ; } ) ; it ( 's' , done => { server . listen ( serverPort , ( ) => { traceTestModule . get ( ) . runInRootSpan ( { name : 's' } , rootSpan => { assert . ok ( rootSpan . type === SpanType . ROOT ) ; const start = Date . now ( ) ; const session = 0 . connect ( `template` ) ; const s : 0 . 0 = session . request ( { 's' : 's' , } ) ; s . setEncoding ( 's' ) ; s . on ( 's' , ( ) => { let result = 's' ; s . on ( 's' , data => { result += data ; } ) . on ( 's' , ( ) => { rootSpan . endSpan ( ) ; assert . strictEqual ( result , serverRes ) ; assertSpanDuration ( traceTestModule . getOneSpan ( span => span . name !== 's' ) , [ DEFAULT_SPAN_DURATION , Date . now ( ) - start ] ) ; session . destroy ( ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { this . timeout ( 0 ) ; let count = 0 ; const slowServer : 0 . 0 = 0 . createServer ( ) ; slowServer . on ( 's' , s => { setTimeout ( ( ) => { s . respond ( { 's' : count ++ } ) ; s . end ( ) ; } , 0 ) ; } ) ; slowServer . listen ( serverPort , ( ) => { traceTestModule . get ( ) . runInRootSpan ( { name : 's' } , rootSpan => { assert . ok ( rootSpan . type === SpanType . ROOT ) ; let completed = 0 ; for ( let i = 0 ; i < 0 ; i ++ ) { const session = 0 . connect ( `template` ) ; const s = session . request ( { 's' : 's' } ) ; s . on ( 's' , ( ) => { } ) . on ( 's' , ( ) => { if ( ++ completed === 0 ) { rootSpan . endSpan ( ) ; const spans = traceTestModule . getSpans ( span => span . name !== 's' ) ; assert . strictEqual ( spans . length , 0 ) ; const statusCodes : number [ ] = [ ] ; for ( let j = 0 ; j < spans . length ; j ++ ) { const code = Number ( spans [ j ] . labels [ TraceLabels . HTTP_RESPONSE_CODE_LABEL_KEY ] ) ; assert . strictEqual ( statusCodes . indexOf ( code ) , - 0 ) ; statusCodes . push ( code ) ; } assert . strictEqual ( statusCodes . reduce ( ( a , b ) => a + b ) , 0 ) ; slowServer . close ( ) ; done ( ) ; } session . destroy ( ) ; } ) ; s . end ( ) ; } } ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , done => { const options : 0 . SecureServerOptions = { key : SERVER_KEY , cert : SERVER_CERT , } ; const secureServer : 0 . 0 = 0 . createSecureServer ( options ) ; secureServer . on ( 's' , s => { setTimeout ( ( ) => { s . respond ( { 's' : 0 } ) ; s . end ( serverRes ) ; } , DEFAULT_SPAN_DURATION ) ; } ) ; secureServer . listen ( serverPort , ( ) => { traceTestModule . get ( ) . runInRootSpan ( { name : 's' } , rootSpan => { assert . ok ( rootSpan . type === SpanType . ROOT ) ; const start = Date . now ( ) ; const session = 0 . connect ( `template` , { rejectUnauthorized : false , } ) ; const s = session . request ( { 's' : 's' } ) ; s . setEncoding ( 's' ) ; let result = 's' ; s . on ( 's' , ( data ) => { result += data ; } ) . on ( 's' , ( ) => { rootSpan . endSpan ( ) ; assert . strictEqual ( result , serverRes ) ; assertSpanDuration ( traceTestModule . getOneSpan ( span => span . name !== 's' ) , [ DEFAULT_SPAN_DURATION , Date . now ( ) - start ] ) ; session . destroy ( ) ; secureServer . close ( ) ; done ( ) ; } ) ; s . end ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as knexTypes from 's' ; import { Tracer } from 's' ; import { TraceLabels } from 's' ; import * as traceTestModule from 's' ; import { describeInterop , hasContext , wait } from 's' ; const TABLE_NAME = 's' ; const obj = { k : 0 , v : 's' , } ; describeInterop < typeof knexTypes > ( 's' , fixture => { const { version , parsedVersion } = fixture ; let knex ; let tracer ; before ( ( ) => { traceTestModule . setCLSForTest ( ) ; traceTestModule . setPluginLoaderForTest ( ) ; tracer = traceTestModule . start ( { enhancedDatabaseReporting : true } ) ; knex = fixture . require ( ) ( { client : 's' , connection : require ( 's' ) , } ) ; return knex . schema . dropTable ( TABLE_NAME ) . catch ( ( ) => { } ) ; } ) ; after ( ( ) => { knex . destroy ( ) ; traceTestModule . setCLSForTest ( traceTestModule . TestCLS ) ; traceTestModule . setPluginLoaderForTest ( traceTestModule . TestPluginLoader ) ; } ) ; beforeEach ( ( ) => { return knex . schema . createTable ( TABLE_NAME , table => { table . integer ( 's' ) ; table . string ( 's' , 0 ) ; } ) . then ( result => { assert . ok ( result ) ; return knex . insert ( obj ) . into ( TABLE_NAME ) . then ( result => { assert . ok ( result ) ; traceTestModule . clearTraceData ( ) ; } ) ; } ) ; } ) ; afterEach ( ( ) => { return knex . schema . dropTable ( TABLE_NAME ) . then ( result => { assert . ok ( result ) ; traceTestModule . clearTraceData ( ) ; } ) ; } ) ; it ( 's' + version , ( ) => { return tracer . runInRootSpan ( { name : 's' } , rootSpan => { return knex ( TABLE_NAME ) . select ( ) . then ( res => { rootSpan . endSpan ( ) ; assert ( res ) ; assert . strictEqual ( res . length , 0 ) ; assert . strictEqual ( res [ 0 ] . k , 0 ) ; assert . strictEqual ( res [ 0 ] . v , 's' ) ; const spans = traceTestModule . getSpans ( span => { return span . name === 's' ; } ) ; if ( parsedVersion . minor === 0 ) { assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; } else { assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; } } ) ; } ) ; } ) ; it ( 's' + version , ( ) => { return tracer . runInRootSpan ( { name : 's' } , rootSpan => { return knex . select ( ) . from ( TABLE_NAME ) . then ( res => { assert . ok ( hasContext ( ) ) ; rootSpan . endSpan ( ) ; } ) ; } ) ; } ) ; it ( 's' + version , ( ) => { return tracer . runInRootSpan ( { name : 's' } , rootSpan => { return knex . select ( ) . from ( TABLE_NAME ) . then ( res => { rootSpan . endSpan ( ) ; const spans = traceTestModule . getSpans ( span => { return span . name === 's' ; } ) ; const labels = spans [ 0 ] . labels ; const stackTrace = JSON . parse ( labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ) ; assert ( stackTrace . stack_frame [ 0 ] . method_name . indexOf ( 's' ) !== - 0 ) ; } ) ; } ) ; } ) ; it ( 's' + version , ( ) => { return tracer . runInRootSpan ( { name : 's' } , rootSpan => { return knex . select ( ) . from ( TABLE_NAME ) . on ( 's' , ( response , obj , builder ) => { const row = response [ 0 ] ; assert . ok ( row ) ; assert . strictEqual ( row . k , 0 ) ; assert . strictEqual ( row . v , 's' ) ; } ) . on ( 's' , ( err , obj ) => { assert . ifError ( err ) ; } ) . then ( res => { rootSpan . endSpan ( ) ; const spans = traceTestModule . getSpans ( span => { return span . name === 's' ; } ) ; if ( parsedVersion . minor === 0 ) { assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; } else { assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; } } ) ; } ) ; } ) ; it ( 's' + version , ( ) => { return tracer . runInRootSpan ( { name : 's' } , rootSpan => { return knex . select ( ) . from ( TABLE_NAME ) . then ( async result => { await wait ( 0 ) ; rootSpan . endSpan ( ) ; const spans = traceTestModule . getSpans ( span => { return span . name === 's' ; } ) ; if ( parsedVersion . minor === 0 ) { assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; } else { assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; } } ) ; } ) ; } ) ; it ( 's' + version , ( ) => { const 0 = { k : 0 , v : 's' } ; return tracer . runInRootSpan ( { name : 's' } , rootSpan => { return knex . transaction ( trx => { knex . insert ( 0 ) . into ( TABLE_NAME ) . transacting ( trx ) . then ( res => { return trx . select ( ) . from ( TABLE_NAME ) . then ( res => { assert . strictEqual ( res . length , 0 ) ; assert . strictEqual ( res [ 0 ] . k , 0 ) ; assert . strictEqual ( res [ 0 ] . v , 's' ) ; assert . strictEqual ( res [ 0 ] . k , 0 ) ; assert . strictEqual ( res [ 0 ] . v , 's' ) ; } ) . catch ( err => { assert . ifError ( err ) ; } ) ; } ) . then ( ( ) => { trx . rollback ( new Error ( 's' ) ) ; } ) . catch ( err => { assert . ifError ( err ) ; } ) ; } ) . catch ( err => { assert . ok ( err ) ; assert . strictEqual ( err . message , 's' ) ; return knex . select ( ) . from ( TABLE_NAME ) . then ( res => { rootSpan . endSpan ( ) ; assert . strictEqual ( res . length , 0 ) ; assert . strictEqual ( res [ 0 ] . k , 0 ) ; assert . strictEqual ( res [ 0 ] . v , 's' ) ; const spans = traceTestModule . getSpans ( span => { return span . name === 's' ; } ) ; let expectedCmds ; if ( parsedVersion . minor === 0 || parsedVersion . minor >= 0 ) { expectedCmds = [ "s" , 's' , 's' , "s" , 's' , ] ; } else { expectedCmds = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , ] ; } assert . strictEqual ( expectedCmds . length , spans . length ) ; for ( let i = 0 ; i < spans . length ; i ++ ) { if ( expectedCmds [ i ] instanceof RegExp ) { assert . ok ( ! ! spans [ i ] . labels . sql . match ( expectedCmds [ i ] ) ) ; } else { assert . strictEqual ( spans [ i ] . labels . sql , expectedCmds [ i ] ) ; } } } ) ; } ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $knexTypes$ O O $Tracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { TraceLabels } from 's' ; var common = require ( 's' ) ; var assert = require ( 's' ) ; var RESULT_SIZE = 0 ; var versions = { 0 : 's' , 0 : 's' , 0 : 's' , } ; describe ( 's' , function ( ) { before ( function ( ) { require ( 's' ) . start ( { projectId : 's' , samplingRate : 0 , enhancedDatabaseReporting : true , databaseResultReportingSize : RESULT_SIZE } ) ; } ) ; Object . keys ( versions ) . forEach ( function ( version ) { describe ( version , function ( ) { var mongodb ; var server ; before ( function ( ) { mongodb = require ( versions [ version ] ) ; } ) ; beforeEach ( function ( done ) { server = new mongodb . Server ( { host : 's' , port : 0 } ) ; var sim = { 0 : 's' , 0 : true , 0 : 0 } ; server . on ( 's' , function ( _server ) { server . insert ( 's' , [ sim ] , function ( err , res ) { assert . ifError ( err ) ; assert . strictEqual ( res . result . n , 0 ) ; done ( ) ; } ) ; } ) ; server . connect ( ) ; } ) ; afterEach ( function ( done ) { common . cleanTraces ( ) ; server . command ( 's' , { dropDatabase : 0 } , function ( err , res ) { assert . ifError ( err ) ; assert . strictEqual ( res . result . dropped , 's' ) ; server . destroy ( ) ; done ( ) ; } ) ; } ) ; it ( 's' , function ( done ) { var data = { 0 : 's' , 0 : false , 0 : 0 } ; common . runInTransaction ( function ( endTransaction ) { server . insert ( 's' , [ data ] , function ( err , res ) { endTransaction ( ) ; assert . ifError ( err ) ; assert . strictEqual ( res . result . n , 0 ) ; var trace = common . getMatchingSpan ( mongoPredicate . bind ( null , 's' ) ) ; assert ( trace ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { server . update ( 's' , [ { q : { 0 : 's' } , u : { 's' : { 0 : false } } } ] , function ( err , res ) { endTransaction ( ) ; assert . ifError ( err ) ; assert . strictEqual ( res . result . n , 0 ) ; var trace = common . getMatchingSpan ( mongoPredicate . bind ( null , 's' ) ) ; assert ( trace ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { server . update ( 's' , [ { q : { 0 : 's' } , u : { 's' : { 0 : false } } } ] , function ( err , res ) { assert . ok ( common . hasContext ( ) ) ; endTransaction ( ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { server . cursor ( 's' , { find : 's' , query : { 0 : 's' } } ) . next ( function ( err , doc ) { endTransaction ( ) ; assert . ifError ( err ) ; assert . strictEqual ( doc . 0 , 0 ) ; var trace = common . getMatchingSpan ( mongoPredicate . bind ( null , 's' ) ) ; assert ( trace ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { server . remove ( 's' , [ { q : { 0 : 's' } , limit : 0 } ] , function ( err , res ) { endTransaction ( ) ; assert . ifError ( err ) ; assert . strictEqual ( res . result . n , 0 ) ; var trace = common . getMatchingSpan ( mongoPredicate . bind ( null , 's' ) ) ; assert ( trace ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { server . command ( 's' , { ismaster : true } , function ( err , res ) { endTransaction ( ) ; assert . ifError ( err ) ; var trace = common . getMatchingSpan ( mongoPredicate . bind ( null , 's' ) ) ; assert ( trace ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { server . cursor ( 's' , { find : 's' , query : { 0 : 's' } } ) . next ( function ( err , doc ) { assert . ifError ( err ) ; assert . strictEqual ( doc . 0 , 0 ) ; assert . strictEqual ( common . getTraces ( ) . length , 0 ) ; done ( ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { server . cursor ( 's' , { find : 's' , query : { 0 : 's' } } ) . next ( function ( err , doc ) { endTransaction ( ) ; assert . ifError ( err ) ; assert . strictEqual ( doc . 0 , 0 ) ; var trace = common . getMatchingSpan ( mongoPredicate . bind ( null , 's' ) ) ; var labels = trace . labels ; var stack = JSON . parse ( labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ) ; assert . notStrictEqual ( - 0 , stack . stack_frame [ 0 ] . method_name . indexOf ( 's' ) ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } ) ; function mongoPredicate ( id , span ) { return span . name . length >= 0 && span . name . substr ( 0 , 0 ) === id ; } export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as mongooseTypes from 's' ; import * as traceTestModule from 's' ; import { describeInterop } from 's' ; interface TestDocType { 0 : string ; 0 : boolean ; 0 : number ; } describeInterop < typeof mongooseTypes > ( 's' , fixture => { let mongoose : typeof mongooseTypes ; let Simple : mongooseTypes . Model < mongooseTypes . Document & TestDocType > ; async function insertTestData ( doc ) { const data = new Simple ( doc ) ; const tracer = traceTestModule . get ( ) ; await tracer . runInRootSpan ( { name : 's' } , async span => { assert . ok ( tracer . isRealSpan ( span ) ) ; await data . save ( ) ; span . endSpan ( ) ; } ) ; } before ( async ( ) => { traceTestModule . setCLSForTest ( ) ; traceTestModule . setPluginLoaderForTest ( ) ; traceTestModule . start ( ) ; mongoose = fixture . require ( ) ; await mongoose . connect ( 's' ) ; const { Schema } = mongoose ; const simpleSchema = new Schema ( { 0 : String , 0 : Boolean , 0 : Number } ) ; Simple = mongoose . model ( 's' , simpleSchema ) ; } ) ; after ( async ( ) => { traceTestModule . setCLSForTest ( traceTestModule . TestCLS ) ; traceTestModule . setPluginLoaderForTest ( traceTestModule . TestPluginLoader ) ; await mongoose . connection . db . dropDatabase ( ) ; await mongoose . disconnect ( ) ; } ) ; afterEach ( ( ) => { traceTestModule . clearTraceData ( ) ; } ) ; it ( 's' , async ( ) => { await insertTestData ( { 0 : 's' , 0 : false , 0 : 0 } ) ; const trace = traceTestModule . getOneTrace ( trace => trace . spans . some ( span => span . name === 's' ) ) ; assert . strictEqual ( trace . spans . length , 0 ) ; assert . strictEqual ( trace . spans [ 0 ] . name , 's' ) ; } ) ; it ( 's' , async ( ) => { await insertTestData ( { 0 : 's' , 0 : false , 0 : 0 } ) ; const tracer = traceTestModule . get ( ) ; await tracer . runInRootSpan ( { name : 's' } , async span => { assert . ok ( tracer . isRealSpan ( span ) ) ; await Simple . findOne ( { 0 : 's' } ) ; span . endSpan ( ) ; } ) ; const trace = traceTestModule . getOneTrace ( trace => trace . spans . some ( span => span . name === 's' ) ) ; assert . strictEqual ( trace . spans . length , 0 ) ; assert . strictEqual ( trace . spans [ 0 ] . name , 's' ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TestDocType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { TraceLabels } from 's' ; var common = require ( 's' ) ; var assert = require ( 's' ) ; describe ( 's' , function ( ) { var agent ; var Simple ; before ( function ( ) { agent = require ( 's' ) . start ( { projectId : 's' , samplingRate : 0 } ) ; } ) ; const versions = [ 0 , 0 ] ; for ( const version of versions ) { describe ( `template` , ( ) => { let mongoose ; before ( ( ) => { mongoose = require ( `template` ) ; mongoose . Promise = global . Promise ; var Schema = mongoose . Schema ; var simpleSchema = new Schema ( { 0 : String , 0 : Boolean , 0 : Number } ) ; Simple = mongoose . model ( 's' , simpleSchema ) ; } ) ; beforeEach ( function ( done ) { var sim = new Simple ( { 0 : 's' , 0 : true , 0 : 0 } ) ; mongoose . connect ( 's' , function ( err ) { assert ( ! err , 's' ) ; sim . save ( function ( err ) { assert ( ! err ) ; common . cleanTraces ( ) ; done ( ) ; } ) ; } ) ; } ) ; afterEach ( function ( done ) { mongoose . connection . db . dropDatabase ( function ( err ) { assert ( ! err ) ; mongoose . connection . close ( function ( err ) { assert ( ! err ) ; common . cleanTraces ( ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var data = new Simple ( { 0 : 's' , 0 : false , 0 : 0 } ) ; common . runInTransaction ( function ( endTransaction ) { data . save ( function ( err ) { endTransaction ( ) ; assert ( ! err ) ; var trace = common . getMatchingSpan ( mongoPredicate . bind ( null , 's' ) ) ; assert ( trace ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { Simple . findOne ( { 0 : 's' } , function ( err , res ) { assert ( ! err ) ; res . 0 = false ; res . save ( function ( err ) { endTransaction ( ) ; assert ( ! err ) ; var trace = common . getMatchingSpan ( mongoPredicate . bind ( null , 's' ) ) ; assert ( trace ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { Simple . findOne ( { 0 : 's' } , function ( err , res ) { endTransaction ( ) ; assert ( ! err ) ; var trace = common . getMatchingSpan ( mongoPredicate . bind ( null , 's' ) ) ; assert ( trace ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { Simple . remove ( { 0 : 's' } , function ( err , res ) { endTransaction ( ) ; assert ( ! err ) ; var trace = common . getMatchingSpan ( mongoPredicate . bind ( null , 's' ) ) ; assert ( trace ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { Simple . findOne ( { 0 : 's' } , function ( err , res ) { assert ( ! err ) ; assert ( res ) ; done ( ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { Simple . findOne ( { 0 : 's' } , function ( err , res ) { endTransaction ( ) ; assert ( ! err ) ; var trace = common . getMatchingSpan ( mongoPredicate . bind ( null , 's' ) ) ; var labels = trace . labels ; var stackTrace = JSON . parse ( labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ) ; assert ( stackTrace . stack_frame [ 0 ] . method_name . indexOf ( 's' ) !== - 0 ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } } ) ; function mongoPredicate ( id , span ) { return span . name . length >= 0 && span . name . substr ( 0 , 0 ) === id ; } export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { TraceLabels } from 's' ; var common = require ( 's' ) ; var assert = require ( 's' ) ; var RESULT_SIZE = 0 ; var obj = { k : 0 , v : 's' } ; var agent = require ( 's' ) . start ( { projectId : 's' , enhancedDatabaseReporting : true , databaseResultReportingSize : RESULT_SIZE } ) ; var fixtures = [ "s" , "s" ] fixtures . forEach ( function ( fixture ) { describe ( 's' + fixture , function ( ) { var connection ; var mysql ; var pool ; before ( function ( ) { mysql = require ( 's' + fixture ) ; pool = mysql . createPool ( require ( 's' ) ) ; } ) ; after ( function ( ) { pool . end ( ) ; } ) ; beforeEach ( function ( done ) { pool . getConnection ( function ( err , conn ) { assert ( ! err , 's' ) ; conn . query ( 's' , function ( err ) { assert ( ! err , err ) ; conn . query ( 's' , obj , function ( err , res ) { connection = conn ; assert ( ! err ) ; assert . strictEqual ( res . affectedRows , 0 ) ; common . cleanTraces ( ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; afterEach ( function ( done ) { connection . query ( 's' , function ( err ) { assert ( ! err ) ; connection . release ( ) ; common . cleanTraces ( ) ; done ( ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { connection . query ( 's' , function ( err , res ) { endRootSpan ( ) ; assert ( ! err ) ; assert . strictEqual ( res . length , 0 ) ; assert . strictEqual ( res [ 0 ] . k , 0 ) ; assert . strictEqual ( res [ 0 ] . v , 's' ) ; var spans = common . getMatchingSpans ( function ( span ) { return span . name === 's' ; } ) ; assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { connection . query ( 's' , function ( err , res ) { assert . ok ( common . hasContext ( ) ) ; endRootSpan ( ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { connection . query ( 's' , function ( err , res ) { endRootSpan ( ) ; assert ( ! err ) ; var spans = common . getMatchingSpans ( function ( span ) { return span . name === 's' ; } ) ; var labels = spans [ 0 ] . labels ; var stackTrace = JSON . parse ( labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ) ; assert ( stackTrace . stack_frame [ 0 ] . method_name . indexOf ( 's' ) !== - 0 ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { var query = connection . query ( 's' ) ; query . on ( 's' , function ( row ) { assert . strictEqual ( row . k , 0 ) ; assert . strictEqual ( row . v , 's' ) ; } ) ; query . on ( 's' , function ( ) { endRootSpan ( ) ; var spans = common . getMatchingSpans ( function ( span ) { return span . name === 's' ; } ) ; assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { connection . query ( 's' ) ; setTimeout ( function ( ) { endRootSpan ( ) ; var spans = common . getMatchingSpans ( function ( span ) { return span . name === 's' ; } ) ; assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; done ( ) ; } , 0 ) ; } ) ; } ) ; it ( 's' , function ( done ) { var 0 = { k : 0 , v : 's' } ; common . runInTransaction ( function ( endRootSpan ) { connection . beginTransaction ( function ( err ) { assert ( ! err ) ; connection . query ( 's' , 0 , function ( err , res ) { assert ( ! err ) ; connection . query ( 's' , function ( err , res ) { assert ( ! err ) ; assert . strictEqual ( res . length , 0 ) ; assert . strictEqual ( res [ 0 ] . k , 0 ) ; assert . strictEqual ( res [ 0 ] . v , 's' ) ; assert . strictEqual ( res [ 0 ] . k , 0 ) ; assert . strictEqual ( res [ 0 ] . v , 's' ) ; connection . rollback ( function ( err ) { assert ( ! err ) ; connection . query ( 's' , function ( err , res ) { assert ( ! err ) ; connection . commit ( function ( err ) { endRootSpan ( ) ; assert ( ! err ) ; assert . strictEqual ( res . length , 0 ) ; assert . strictEqual ( res [ 0 ] . k , 0 ) ; assert . strictEqual ( res [ 0 ] . v , 's' ) ; var spans = common . getMatchingSpans ( function ( span ) { return span . name === 's' ; } ) ; var expectedCmds = [ 's' , 's' , 's' , 's' , 's' , 's' ] ; assert . strictEqual ( expectedCmds . length , spans . length ) ; for ( var i = 0 ; i < spans . length ; i ++ ) { assert . strictEqual ( spans [ i ] . labels . sql , expectedCmds [ i ] ) ; } done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } ) ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fetchTypes from 's' ; import * as testTraceModule from 's' ; import * as assert from 's' ; import { describeInterop } from 's' ; import { 0 } from 's' ; import { 0 } from 's' ; import { Agent } from 's' ; import { SpanKind } from 's' ; const servers = { http : 0 , https : 0 , } ; describeInterop < typeof fetchTypes & typeof fetchTypes . default > ( 's' , fixture => { before ( ( ) => { testTraceModule . setPluginLoaderForTest ( ) ; testTraceModule . setCLSForTest ( ) ; } ) ; after ( ( ) => { testTraceModule . setPluginLoaderForTest ( testTraceModule . TestPluginLoader ) ; testTraceModule . setCLSForTest ( testTraceModule . TestCLS ) ; } ) ; beforeEach ( ( ) => { testTraceModule . clearTraceData ( ) ; } ) ; for ( const protocol of Object . keys ( servers ) as Array < keyof typeof servers > ) { it ( `template` , async ( ) => { const server = new servers [ protocol ] ( ) ; fixture . require ( ) ; const tracer = testTraceModule . start ( ) ; const fetch = fixture . require ( ) ; server . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => ( { statusCode : 0 , message : 's' } ) , } ) ; const port = server . listen ( 0 ) ; let agent : Agent | undefined ; if ( protocol === 's' ) { agent = new Agent ( { rejectUnauthorized : false , } ) ; } try { await tracer . runInRootSpan ( { name : 's' } , async span => { assert . ok ( tracer . isRealSpan ( span ) ) ; const response = await fetch ( `template` , { agent , } ) ; assert . strictEqual ( await response . text ( ) , 's' ) ; span . endSpan ( ) ; } ) ; const traces = testTraceModule . getOneTrace ( trace => trace . spans . some ( span => span . name === 's' ) ) ; assert . ok ( traces . spans . some ( span => span . kind === SpanKind . RPC_CLIENT ) ) ; } finally { server . shutdown ( ) ; } } ) ; } } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { TraceLabels } from 's' ; import { FORCE_NEW } from 's' ; var common = require ( 's' ) ; var assert = require ( 's' ) ; var pgVersions = [ 's' , 's' ] ; pgVersions . forEach ( pgVersion => { describe ( `template` , function ( ) { var pg ; var traceApi ; var pool ; var client ; var releaseClient ; before ( function ( ) { traceApi = require ( 's' ) . start ( { projectId : 's' , samplingRate : 0 , enhancedDatabaseReporting : true , [ FORCE_NEW ] : true } ) ; pg = require ( `template` ) ; pool = new pg . Pool ( require ( 's' ) ) ; } ) ; beforeEach ( function ( done ) { pool . connect ( function ( err , c , release ) { client = c ; releaseClient = release ; assert ( ! err ) ; client . query ( 's' , [ ] , function ( err , res ) { assert ( ! err || err . code == 's' ) ; client . query ( 's' , [ ] , function ( err , res ) { assert ( ! err ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; afterEach ( ( ) => { releaseClient ( ) ; common . cleanTraces ( ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { client . query ( 's' , [ 's' , 's' ] , function ( err , res ) { endRootSpan ( ) ; assert ( ! err ) ; var span = common . getMatchingSpan ( function ( span ) { return span . name === 's' ; } ) ; assert . strictEqual ( span . labels . query , 's' ) ; assert . strictEqual ( span . labels . values , 's' ) ; assert . strictEqual ( span . labels . row_count , 's' ) ; assert . strictEqual ( span . labels . oid , 's' ) ; assert . strictEqual ( span . labels . rows , 's' ) ; assert . strictEqual ( span . labels . fields , 's' ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { client . query ( 's' , [ 's' , 's' ] ) . then ( ( res ) => { endRootSpan ( ) ; var span = common . getMatchingSpan ( function ( span ) { return span . name === 's' ; } ) ; assert . strictEqual ( span . labels . query , 's' ) ; assert . strictEqual ( span . labels . values , 's' ) ; assert . strictEqual ( span . labels . row_count , 's' ) ; assert . strictEqual ( span . labels . oid , 's' ) ; assert . strictEqual ( span . labels . rows , 's' ) ; assert . strictEqual ( span . labels . fields , 's' ) ; done ( ) ; } , ( err ) => { assert . fail ( 's' ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { client . query ( 's' , [ 's' , 's' ] , function ( err , res ) { assert . ok ( common . hasContext ( ) ) ; endRootSpan ( ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { client . query ( 's' , [ 's' , 's' ] ) . then ( ( res ) => { assert . ok ( common . hasContext ( ) ) ; endRootSpan ( ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { client . query ( 's' , [ 0 ] , function ( err , res ) { endRootSpan ( ) ; assert ( ! err ) ; var span = common . getMatchingSpan ( function ( span ) { return span . name === 's' ; } ) ; var labels = span . labels ; var stackTrace = JSON . parse ( labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ) ; assert ( stackTrace . stack_frame [ 0 ] . method_name . indexOf ( 's' ) !== - 0 ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { var query = client . query ( new pg . Query ( 's' , [ 0 ] ) ) ; query . on ( 's' , function ( row ) { assert . strictEqual ( row . number , 0 ) ; } ) ; query . on ( 's' , function ( ) { endRootSpan ( ) ; var span = common . getMatchingSpan ( function ( span ) { return span . name === 's' ; } ) ; assert . strictEqual ( span . labels . query , 's' ) ; assert . strictEqual ( span . labels . values , 's' ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { client . query ( { submit : ( connection ) => { connection . emit ( 's' ) ; } , handleReadyForQuery : ( ) => { endRootSpan ( ) ; common . getMatchingSpan ( function ( span ) { return span . name === 's' ; } ) ; done ( ) ; } } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endRootSpan ) { client . query ( 's' , [ 0 ] ) ; setTimeout ( function ( ) { endRootSpan ( ) ; var span = common . getMatchingSpan ( function ( span ) { return span . name === 's' ; } ) ; assert . strictEqual ( span . labels . query , 's' ) ; assert . strictEqual ( span . labels . values , 's' ) ; done ( ) ; } , 0 ) ; } ) ; } ) ; } ) ; } ) ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { TraceLabels } from 's' ; import { describeInterop } from 's' ; var common = require ( 's' ) ; var RESULT_SIZE = 0 ; var assert = require ( 's' ) ; describe ( 's' , function ( ) { var agent ; before ( function ( ) { agent = require ( 's' ) . start ( { projectId : 's' , samplingRate : 0 , enhancedDatabaseReporting : true , databaseResultReportingSize : RESULT_SIZE } ) ; } ) ; var client ; describeInterop ( 's' , function ( fixture ) { var redis ; before ( function ( ) { redis = fixture . require ( ) ; } ) ; beforeEach ( function ( done ) { client = redis . createClient ( ) ; client . on ( 's' , function ( err ) { assert ( false , 's' + err ) ; } ) ; client . set ( 's' , 0 , function ( ) { common . cleanTraces ( ) ; done ( ) ; } ) ; } ) ; afterEach ( function ( done ) { client . quit ( function ( ) { common . cleanTraces ( ) ; done ( ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { client . get ( 's' , function ( err , n ) { endTransaction ( ) ; assert . strictEqual ( Number ( n ) , 0 ) ; var trace = common . getMatchingSpan ( redisPredicate . bind ( null , 's' ) ) ; assert ( trace ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { client . get ( 's' , function ( err , n ) { assert . ok ( common . hasContext ( ) ) ; endTransaction ( ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { client . set ( 's' , 's' , function ( err ) { endTransaction ( ) ; var trace = common . getMatchingSpan ( redisPredicate . bind ( null , 's' ) ) ; assert ( trace ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { client . hset ( 's' , 's' , function ( err ) { endTransaction ( ) ; var trace = common . getMatchingSpan ( redisPredicate . bind ( null , 's' ) ) ; assert ( trace ) ; done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { common . runInTransaction ( function ( endTransaction ) { client . hset ( 's' , 's' , function ( err ) { endTransaction ( ) ; var trace = common . getMatchingSpan ( redisPredicate . bind ( null , 's' ) ) ; var labels = trace . labels ; var stackTrace = JSON . parse ( labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ) ; assert ( stackTrace . stack_frame [ 0 ] . method_name . indexOf ( 's' ) !== - 0 ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; function redisPredicate ( id , span ) { return span . name . length >= id . length && span . name . substr ( 0 , id . length ) === id ; } export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as http from 's' ; import * as traceTestModule from 's' ; import { pluginLoader , PluginLoaderState } from 's' ; import { TraceWriter } from 's' ; import { StackdriverTracer } from 's' ; describe ( 's' , ( ) => { class InitErrorTraceWriter extends TraceWriter { getProjectId ( ) { return Promise . reject ( new Error ( 's' ) ) ; } } before ( ( done ) => { traceTestModule . setPluginLoaderForTest ( ) ; traceTestModule . setTraceWriterForTest ( InitErrorTraceWriter ) ; traceTestModule . start ( ) ; setImmediate ( ( ) => { assert . ok ( ! ( traceTestModule . get ( ) as StackdriverTracer ) . isActive ( ) ) ; done ( ) ; } ) ; } ) ; after ( ( ) => { traceTestModule . setPluginLoaderForTest ( traceTestModule . TestPluginLoader ) ; traceTestModule . setTraceWriterForTest ( traceTestModule . TestTraceWriter ) ; } ) ; it ( 's' , ( ) => { assert . notStrictEqual ( pluginLoader . get ( ) ! . state , PluginLoaderState . ACTIVATED ) ; } ) ; describe ( 's' , function ( ) { it ( 's' , function ( done ) { var app = require ( 's' ) ( ) ; app . get ( 's' , function ( req , res ) { res . send ( 's' ) ; } ) ; var server = app . listen ( 0 , function ( ) { http . get ( 's' , function ( res ) { var result = 's' ; res . on ( 's' , function ( data ) { result += data ; } ) ; res . on ( 's' , function ( ) { assert . strictEqual ( 's' , result ) ; server . close ( ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; describe ( 's' , function ( ) { it ( 's' , function ( done ) { var hapi = require ( 's' ) ; var server = new hapi . Server ( ) ; server . connection ( { port : 0 } ) ; server . route ( { method : 's' , path : 's' , handler : function ( req , reply ) { reply ( 's' ) ; } } ) ; server . start ( function ( ) { http . get ( 's' , function ( res ) { var result = 's' ; res . on ( 's' , function ( data ) { result += data ; } ) ; res . on ( 's' , function ( ) { assert . strictEqual ( 's' , result ) ; server . stop ( ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; describe ( 's' , function ( ) { it ( 's' , function ( done ) { var restify = require ( 's' ) ; var server = restify . createServer ( ) ; server . get ( 's' , function ( req , res , next ) { res . writeHead ( 0 , { 's' : 's' } ) ; res . write ( 's' ) ; res . end ( ) ; return next ( ) ; } ) ; server . listen ( 0 , function ( ) { http . get ( 's' , function ( res ) { var result = 's' ; res . on ( 's' , function ( data ) { result += data ; } ) ; res . on ( 's' , function ( ) { assert . strictEqual ( 's' , result ) ; server . close ( ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as asyncHooksModule from 's' ; import * as semver from 's' ; import { AsyncHooksCLS } from 's' ; type AsyncHooksModule = typeof asyncHooksModule ; const TEST_ASYNC_RESOURCE = 's' ; const maybeSkip = ( describe : Mocha . SuiteFunction ) => semver . satisfies ( process . version , 's' ) ? describe : describe . skip ; maybeSkip ( describe ) ( 's' , ( ) => { let asyncHooks ; let AsyncResource : typeof asyncHooksModule . AsyncResource ; let cls < string > ; before ( ( ) => { asyncHooks = require ( 's' ) as AsyncHooksModule ; AsyncResource = class extends asyncHooks . AsyncResource { runInAsyncScope < This , Result > ( fn : ( this , ... args : any [ ] ) => Result , thisArg ? ) { if ( super . runInAsyncScope ) { return super . runInAsyncScope . apply ( this , arguments ) ; } else { ( this as any ) . emitBefore ( ) ; try { return fn . apply ( thisArg , Array . prototype . slice . apply ( arguments ) . slice ( 0 ) ) ; } finally { ( this as any ) . emitAfter ( ) ; } } } } ; } ) ; beforeEach ( ( ) => { cls = new AsyncHooksCLS ( 's' ) ; cls . enable ( ) ; } ) ; it ( 's' , ( ) => { let numPromiseInitHookInvocations = 0 ; const expected < Promise < void > > = [ ] ; const hook = asyncHooks . createHook ( { init : ( uid , type , tid , resource : { promise : Promise < void > } ) => { if ( type === 's' ) { numPromiseInitHookInvocations ++ ; } } , } ) . enable ( ) ; expected . push ( Promise . resolve ( ) ) ; expected . push ( expected [ 0 ] . then ( ( ) => { } ) ) ; assert . deepStrictEqual ( numPromiseInitHookInvocations , expected . length ) ; hook . disable ( ) ; } ) ; it ( 's' , ( ) => { return cls . runWithContext ( async ( ) => { await Promise . resolve ( ) ; assert . strictEqual ( cls . getContext ( ) , 's' ) ; await Promise . resolve ( ) ; assert . strictEqual ( cls . getContext ( ) , 's' ) ; } , 's' ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { let res ! : asyncHooksModule . AsyncResource ; await cls . runWithContext ( async ( ) => { res = new AsyncResource ( TEST_ASYNC_RESOURCE ) ; } , 's' ) ; res . runInAsyncScope ( ( ) => { assert . strictEqual ( cls . getContext ( ) , 's' ) ; } ) ; } ) ; it ( 's' , async ( ) => { let triggerId ! ; let res ! : asyncHooksModule . AsyncResource ; await cls . runWithContext ( async ( ) => { triggerId = new AsyncResource ( TEST_ASYNC_RESOURCE ) . asyncId ( ) ; } , 's' ) ; await cls . runWithContext ( async ( ) => { res = new AsyncResource ( TEST_ASYNC_RESOURCE , triggerId ) ; } , 's' ) ; res . runInAsyncScope ( ( ) => { assert . strictEqual ( cls . getContext ( ) , 's' ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { const createdPromiseIDs : number [ ] = [ ] ; let hook : asyncHooksModule . AsyncHook ; before ( ( ) => { hook = asyncHooks . createHook ( { init : ( uid , type ) => { if ( type === 's' ) { createdPromiseIDs . push ( uid ) ; } } , } ) . enable ( ) ; } ) ; after ( ( ) => { hook . disable ( ) ; } ) ; const testCases < { description : string ; skip ? : boolean ; fn : ( ) => { } ; } > = [ { description : 's' , fn : async ( ) => { } } , { description : 's' , fn : async ( ) => { throw new Error ( ) ; } , } , { description : 's' , fn : async ( ) => { await new Promise ( reject => setImmediate ( reject ) ) ; } , } , { description : 's' , fn : async ( ) => { await 0 ; await new Promise ( resolve => resolve ( ) ) ; await new Promise ( resolve => setImmediate ( resolve ) ) ; } , } , { description : 's' , fn : async ( ) => { await ( async ( ) => { await Promise . resolve ( ) ; } ) ( ) ; } , } , { description : 's' , fn : ( ) => Promise . resolve ( ) , } , { description : 's' , fn : ( ) => Promise . reject ( ) , } , { description : 's' , skip : true , fn : async ( ... args : number [ ] ) => args , } , ] ; for ( const testCase of testCases ) { const skipIfTestSpecifies = ! ! testCase . skip ? it . skip : it ; skipIfTestSpecifies ( `template` , async ( ) => { createdPromiseIDs . length = 0 ; try { await cls . runWithContext ( testCase . fn , 's' ) ; } catch ( e ) { } finally { const stalePromiseIDs = createdPromiseIDs . filter ( id => { const a = new AsyncResource ( 's' , id ) ; const result = a . runInAsyncScope ( ( ) => { return cls . getContext ( ) === 's' ; } ) ; a . emitDestroy ( ) ; return result ; } ) ; assert . strictEqual ( stalePromiseIDs . length , 0 ) ; } } ) ; } } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AsyncHooksModule$ O O O O O O O O O O $AsyncHooksCLS$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $Result$ O O O O O O O O O $This$ O O O O O O O O O O O O $This$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import { EventEmitter } from 's' ; import * as semver from 's' ; import { inspect } from 's' ; import { TraceCLS , TraceCLSConfig , TraceCLSMechanism } from 's' ; import { AsyncHooksCLS } from 's' ; import { AsyncListenerCLS } from 's' ; import { CLS } from 's' ; import { NullCLS } from 's' ; import { SingularCLS } from 's' ; import { SpanType } from 's' ; import { createStackTrace , FORCE_NEW } from 's' ; import { TestLogger } from 's' ; import { plan } from 's' ; interface CLSConstructor { new ( defaultValue ) : CLS < string > ; } describe ( 's' , ( ) => { const asyncAwaitSupported = semver . satisfies ( process . version , 's' ) ; describe ( 's' , ( ) => { const clazz = NullCLS ; let instance < string > ; beforeEach ( ( ) => { instance = new clazz ( 's' ) ; instance . enable ( ) ; } ) ; afterEach ( ( ) => { instance . disable ( ) ; } ) ; it ( 's' , ( ) => { assert . strictEqual ( instance . getContext ( ) , 's' ) ; assert . strictEqual ( instance . getContext ( ) , 's' ) ; const result = instance . runWithContext ( ( ) => { assert . strictEqual ( instance . getContext ( ) , 's' ) ; return instance . getContext ( ) ; } , 's' ) ; assert . strictEqual ( result , 's' ) ; const boundFn = instance . runWithContext ( ( ) => { return instance . bindWithCurrentContext ( ( ) => { assert . strictEqual ( instance . getContext ( ) , 's' ) ; return instance . getContext ( ) ; } ) ; } , 's' ) ; assert . strictEqual ( boundFn ( ) , 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { const testCases : CLSConstructor [ ] = asyncAwaitSupported ? [ AsyncHooksCLS , AsyncListenerCLS ] : [ AsyncListenerCLS ] ; for ( const testCase of testCases ) { describe ( `template` , ( ) => { let c ! < string > ; beforeEach ( ( ) => { c = new testCase ( 's' ) ; c . enable ( ) ; } ) ; afterEach ( ( ) => { c . disable ( ) ; } ) ; it ( 's' , ( ) => { assert . ok ( c . isEnabled ( ) ) ; assert . strictEqual ( c . getContext ( ) , 's' ) ; } ) ; it ( 's' , ( ) => { const result = c . runWithContext ( ( ) => { assert . strictEqual ( c . getContext ( ) , 's' ) ; return 's' ; } , 's' ) ; assert . strictEqual ( result , 's' ) ; } ) ; it ( 's' , done => { const progress = plan ( done , 0 ) ; c . runWithContext ( ( ) => { process . nextTick ( ( ) => { assert . strictEqual ( c . getContext ( ) , 's' ) ; process . nextTick ( ( ) => { assert . strictEqual ( c . getContext ( ) , 's' ) ; progress ( ) ; } ) ; } ) ; setImmediate ( ( ) => { assert . strictEqual ( c . getContext ( ) , 's' ) ; progress ( ) ; } , 0 ) ; setTimeout ( ( ) => { assert . strictEqual ( c . getContext ( ) , 's' ) ; progress ( ) ; } , 0 ) ; } , 's' ) ; c . runWithContext ( ( ) => { } , 's' ) ; } ) ; it ( 's' , ( ) => { let runLater = ( ) => { assert . strictEqual ( c . getContext ( ) , 's' ) ; } ; c . runWithContext ( ( ) => { runLater = c . bindWithCurrentContext ( runLater ) ; } , 's' ) ; c . runWithContext ( ( ) => { assert . strictEqual ( c . getContext ( ) , 's' ) ; runLater ( ) ; assert . strictEqual ( c . getContext ( ) , 's' ) ; } , 's' ) ; c . runWithContext ( ( ) => { runLater = c . bindWithCurrentContext ( runLater ) ; } , 's' ) ; runLater ( ) ; } ) ; it ( 's' , ( ) => { try { c . runWithContext ( ( ) => { throw new Error ( ) ; } , 's' ) ; } catch ( e ) { assert . strictEqual ( c . getContext ( ) , 's' ) ; } } ) ; it ( 's' , ( ) => { let runLater = ( ) => { throw new Error ( ) ; } ; c . runWithContext ( ( ) => { runLater = c . bindWithCurrentContext ( runLater ) ; } , 's' ) ; try { runLater ( ) ; } catch ( e ) { assert . strictEqual ( c . getContext ( ) , 's' ) ; } } ) ; it ( 's' , ( ) => { const ee = new EventEmitter ( ) ; assert . strictEqual ( c . getContext ( ) , 's' ) ; c . runWithContext ( ( ) => { c . patchEmitterToPropagateContext ( ee ) ; ee . on ( 's' , ( ) => { assert . strictEqual ( c . getContext ( ) , 's' ) ; } ) ; } , 's' ) ; c . runWithContext ( ( ) => { ee . on ( 's' , ( ) => { assert . strictEqual ( c . getContext ( ) , 's' ) ; } ) ; ee . emit ( 's' ) ; assert . strictEqual ( c . getContext ( ) , 's' ) ; } , 's' ) ; ee . on ( 's' , ( ) => { assert . strictEqual ( c . getContext ( ) , 's' ) ; } ) ; ee . emit ( 's' ) ; ee . emit ( 's' ) ; } ) ; it ( 's' , done => { c . runWithContext ( ( ) => { c . runWithContext ( ( ) => { setImmediate ( ( ) => { assert . strictEqual ( c . getContext ( ) , 's' ) ; done ( ) ; } ) ; } , 's' ) ; assert . strictEqual ( c . getContext ( ) , 's' ) ; } , 's' ) ; } ) ; it ( 's' , ( ) => { return c . runWithContext ( ( ) => { return Promise . resolve ( ) . then ( ( ) => { assert . strictEqual ( c . getContext ( ) , 's' ) ; } ) ; } , 's' ) ; } ) ; } ) ; } describe ( 's' , ( ) => { it ( 's' , async ( ) => { const cls = new SingularCLS ( 's' ) ; cls . enable ( ) ; cls . runWithContext ( ( ) => { } , 's' ) ; await Promise . resolve ( ) ; assert . strictEqual ( cls . getContext ( ) , 's' ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { const validTestCases < { config : TraceCLSConfig ; expectedDefaultType : SpanType ; } > = [ { config : { mechanism : TraceCLSMechanism . ASYNC_LISTENER } , expectedDefaultType : SpanType . UNCORRELATED , } , { config : { mechanism : TraceCLSMechanism . SINGULAR } , expectedDefaultType : SpanType . UNCORRELATED , } , { config : { mechanism : TraceCLSMechanism . NONE } , expectedDefaultType : SpanType . UNCORRELATED , } , ] ; if ( asyncAwaitSupported ) { validTestCases . push ( { config : { mechanism : TraceCLSMechanism . ASYNC_HOOKS } , expectedDefaultType : SpanType . UNCORRELATED , } ) ; } for ( const testCase of validTestCases ) { describe ( `template` , ( ) => { const logger = new TestLogger ( ) ; let c ; beforeEach ( ( ) => { try { c = new TraceCLS ( testCase . config , logger ) ; c . enable ( ) ; } catch { c = { disable : ( ) => { } } as TraceCLS ; } } ) ; afterEach ( ( ) => { c . disable ( ) ; logger . clearLogs ( ) ; } ) ; it ( `template` , ( ) => { c . disable ( ) ; assert . ok ( ! c . isEnabled ( ) ) ; assert . ok ( c . getContext ( ) . type , SpanType . UNSAMPLED ) ; assert . ok ( c . runWithContext ( ( ) => 's' , TraceCLS . UNCORRELATED ) , 's' ) ; const fn = ( ) => { } ; assert . strictEqual ( c . bindWithCurrentContext ( fn ) , fn ) ; c . patchEmitterToPropagateContext ( new EventEmitter ( ) ) ; } ) ; it ( 's' , ( ) => { assert . ok ( c . isEnabled ( ) ) ; assert . strictEqual ( c . getContext ( ) . type , testCase . expectedDefaultType ) ; } ) ; it ( 's' , ( ) => { assert . strictEqual ( logger . getNumLogsWith ( 's' , `template` ) , 0 ) ; } ) ; it ( 's' , ( ) => { function myFunction ( ) { c . runWithContext ( ( ) => { const frames = createStackTrace ( 0 , c . rootSpanStackOffset ) ; assert . strictEqual ( frames [ 0 ] . method_name , 's' ) ; } , TraceCLS . UNCORRELATED ) ; } myFunction ( ) ; } ) ; } ) ; } const invalidTestCases : TraceCLSConfig [ ] = asyncAwaitSupported ? [ { mechanism : 's' } as any , ] : [ { mechanism : 's' } as any , { mechanism : 's' } , ] ; for ( const testCase of invalidTestCases ) { describe ( `template` , ( ) => { const logger = new TestLogger ( ) ; it ( 's' , ( ) => { assert . throws ( ( ) => new TraceCLS ( testCase , logger ) ) ; } ) ; } ) ; } } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CLS$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CLS$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceCLS$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { Constants } from 's' ; import { traceWriter } from 's' ; import { FORCE_NEW } from 's' ; var assert = require ( 's' ) ; var trace = require ( 's' ) ; describe ( 's' , function ( ) { it ( 's' , function ( ) { trace . start ( { [ FORCE_NEW ] : true , maximumLabelValueSize : 0 } ) ; var valueMax = traceWriter . get ( ) . getConfig ( ) . maximumLabelValueSize ; assert . strictEqual ( valueMax , Constants . TRACE_SERVICE_LABEL_VALUE_LIMIT ) ; } ) ; it ( 's' , function ( ) { trace . start ( { [ FORCE_NEW ] : true , maximumLabelValueSize : 0 } ) ; var valueMax = traceWriter . get ( ) . getConfig ( ) . maximumLabelValueSize ; assert . strictEqual ( valueMax , 0 ) ; } ) ; } ) ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import { defaultConfig } from 's' ; import { StackdriverTracerComponents } from 's' ; import { PluginLoader , PluginLoaderConfig } from 's' ; import * as testTraceModule from 's' ; function assertPluginPath ( plugins : { [ pluginName ] : string } , pluginName ) { if ( pluginName === 's' ) { pluginName = 's' ; } assert . ok ( plugins [ pluginName ] . includes ( `template` ) ) ; } describe ( 's' , ( ) => { const instrumentedModules = Object . keys ( defaultConfig . plugins ) ; let plugins : { [ pluginName ] : string } | null ; class ConfigTestPluginLoader extends PluginLoader { constructor ( config , components ) { super ( config , components ) ; plugins = config . plugins ; } } before ( ( ) => { testTraceModule . setPluginLoaderForTest ( ConfigTestPluginLoader ) ; } ) ; after ( ( ) => { testTraceModule . setPluginLoaderForTest ( testTraceModule . TestPluginLoader ) ; } ) ; afterEach ( ( ) => { plugins = null ; } ) ; it ( 's' , ( ) => { testTraceModule . start ( ) ; assert . ok ( plugins ) ; assert . strictEqual ( JSON . stringify ( Object . keys ( plugins ! ) ) , JSON . stringify ( instrumentedModules ) ) ; instrumentedModules . forEach ( e => assertPluginPath ( plugins ! , e ) ) ; } ) ; it ( 's' , ( ) => { testTraceModule . start ( { plugins : { } } ) ; assert . ok ( plugins ) ; assert . strictEqual ( JSON . stringify ( Object . keys ( plugins ! ) ) , JSON . stringify ( instrumentedModules ) ) ; instrumentedModules . forEach ( e => assertPluginPath ( plugins ! , e ) ) ; } ) ; it ( 's' , ( ) => { testTraceModule . start ( { plugins : false as { } } ) ; assert . deepStrictEqual ( plugins , { } ) ; } ) ; it ( 's' , ( ) => { testTraceModule . start ( { plugins : { express : 's' } } ) ; assert . ok ( plugins ) ; assert . strictEqual ( JSON . stringify ( Object . keys ( plugins ! ) ) , JSON . stringify ( instrumentedModules ) ) ; instrumentedModules . filter ( e => e !== 's' ) . forEach ( e => assertPluginPath ( plugins ! , e ) ) ; assert . strictEqual ( plugins ! . express , 's' ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $PluginLoaderConfig$ O $StackdriverTracerComponents$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as path from 's' ; import { Trace } from 's' ; import { StackdriverTracer } from 's' ; import { TraceWriter } from 's' ; import { TopLevelConfig , Tracing } from 's' ; import * as traceTestModule from 's' ; describe ( 's' , ( ) => { let capturedConfig : TopLevelConfig | null = null ; class CaptureConfigTracing extends Tracing { constructor ( config ) { super ( config , new StackdriverTracer ( 's' ) ) ; capturedConfig = config ; } } class NoopTraceWriter extends TraceWriter { async initialize ( ) < void > { } writeTrace ( trace ) { } } function getCapturedConfig ( ) { assert . ok ( capturedConfig ! ) ; assert . ok ( capturedConfig ! . enabled ) ; if ( capturedConfig && capturedConfig . enabled ) { return capturedConfig ; } else { throw new Error ( 's' ) ; } } before ( ( ) => { traceTestModule . setTraceWriterForTest ( NoopTraceWriter ) ; traceTestModule . setTracingForTest ( CaptureConfigTracing ) ; } ) ; afterEach ( ( ) => { capturedConfig = null ; } ) ; after ( ( ) => { traceTestModule . setTraceWriterForTest ( traceTestModule . TestTraceWriter ) ; traceTestModule . setTracingForTest ( traceTestModule . TestTracing ) ; } ) ; describe ( 's' , ( ) => { before ( ( ) => { process . env . GCLOUD_TRACE_CONFIG = path . resolve ( __dirname , 's' , 's' , 's' , 's' ) ; process . env . GCLOUD_TRACE_LOGLEVEL = 's' ; } ) ; after ( ( ) => { delete process . env . GCLOUD_TRACE_CONFIG ; delete process . env . GCLOUD_TRACE_LOGLEVEL ; } ) ; it ( 's' , ( ) => { traceTestModule . start ( { logLevel : 0 , stackTraceLimit : 0 } ) ; const config = getCapturedConfig ( ) ; assert . strictEqual ( config . logLevel , 0 ) ; assert . strictEqual ( config . writerConfig . stackTraceLimit , 0 ) ; assert . strictEqual ( config . writerConfig . flushDelaySeconds , 0 ) ; } ) ; } ) ; describe ( 's' , ( ) => { before ( ( ) => { process . env . GCLOUD_PROJECT = 's' ; } ) ; after ( ( ) => { delete process . env . GCLOUD_PROJECT ; } ) ; it ( 's' , ( ) => { traceTestModule . start ( ) ; const config = getCapturedConfig ( ) ; assert . strictEqual ( config . writerConfig . authOptions . projectId , 's' ) ; } ) ; it ( 's' , ( ) => { traceTestModule . start ( { projectId : 's' } ) ; const config = getCapturedConfig ( ) ; assert . strictEqual ( config . writerConfig . authOptions . projectId , 's' ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TopLevelConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O $void$ O $Trace$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as semver from 's' ; import * as util from 's' ; import { TraceCLSConfig , TraceCLSMechanism } from 's' ; import * as testTraceModule from 's' ; import { TopLevelConfig } from 's' ; import { StackdriverTracer } from 's' ; import { Logger } from 's' ; import { TraceWriterConfig } from 's' ; describe ( 's' , ( ) => { const useAH = semver . satisfies ( process . version , 's' ) ; const autoMechanism = useAH ? TraceCLSMechanism . ASYNC_HOOKS : TraceCLSMechanism . ASYNC_LISTENER ; let capturedConfig : TraceCLSConfig | null ; class CaptureConfigTestCLS extends testTraceModule . TestCLS { constructor ( config , logger ) { super ( config , logger ) ; capturedConfig = config ; } } beforeEach ( ( ) => { capturedConfig = null ; } ) ; before ( ( ) => { testTraceModule . setCLSForTest ( CaptureConfigTestCLS ) ; } ) ; after ( ( ) => { testTraceModule . setCLSForTest ( testTraceModule . TestCLS ) ; } ) ; const testCases < { tracingConfig : testTraceModule . Config , contextPropagationConfig : TraceCLSConfig } > = [ { tracingConfig : { clsMechanism : 's' } , contextPropagationConfig : { mechanism : 's' } } , { tracingConfig : { clsMechanism : 's' } , contextPropagationConfig : { mechanism : autoMechanism } } , { tracingConfig : { } , contextPropagationConfig : { mechanism : autoMechanism } } , { tracingConfig : { clsMechanism : 's' } , contextPropagationConfig : { mechanism : 's' } } , { tracingConfig : { clsMechanism : 's' as any } , contextPropagationConfig : { mechanism : 's' as any } } ] ; for ( const testCase of testCases ) { it ( `template` , ( ) => { testTraceModule . start ( testCase . tracingConfig ) ; assert . ok ( capturedConfig ) ; assert . strictEqual ( capturedConfig ! . mechanism , testCase . contextPropagationConfig . mechanism ) ; } ) ; } } ) ; describe ( 's' , ( ) => { let capturedConfig : TopLevelConfig | null ; const getCapturedTracerConfig = ( ) => { assert . ok ( capturedConfig ) ; const config = capturedConfig ! ; if ( config . enabled ) { return config . pluginLoaderConfig . tracerConfig ; } else { assert . fail ( 's' ) ; throw new Error ( ) ; } } ; class CaptureConfigTestTracing extends testTraceModule . TestTracing { constructor ( config , traceAgent ) { super ( config , traceAgent ) ; capturedConfig = config ; } } beforeEach ( ( ) => { capturedConfig = null ; } ) ; before ( ( ) => { testTraceModule . setTracingForTest ( CaptureConfigTestTracing ) ; } ) ; after ( ( ) => { testTraceModule . setTracingForTest ( testTraceModule . TestTracing ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { testTraceModule . start ( { rootSpanNameOverride : 's' } ) ; const config = getCapturedTracerConfig ( ) ; assert . strictEqual ( typeof config . rootSpanNameOverride , 's' ) ; assert . strictEqual ( config . rootSpanNameOverride ( 's' ) , 's' ) ; } ) ; it ( 's' , ( ) => { testTraceModule . start ( { rootSpanNameOverride : 0 as any } ) ; const config = getCapturedTracerConfig ( ) ; assert . strictEqual ( typeof config . rootSpanNameOverride , 's' ) ; assert . strictEqual ( config . rootSpanNameOverride ( 's' ) , 's' ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { assert . throws ( ( ) => testTraceModule . start ( { samplingRate : 0 , tracePolicy : { shouldTrace : ( ) => true } } ) ) ; } ) ; } ) ; describe ( 's' , ( ) => { let capturedConfig : TraceWriterConfig | null ; class CaptureConfigTestWriter extends testTraceModule . TestTraceWriter { constructor ( config , logger ) { super ( config , logger ) ; capturedConfig = config ; } } beforeEach ( ( ) => { capturedConfig = null ; } ) ; before ( ( ) => { testTraceModule . setTraceWriterForTest ( CaptureConfigTestWriter ) ; } ) ; after ( ( ) => { testTraceModule . setTraceWriterForTest ( testTraceModule . TestTraceWriter ) ; } ) ; it ( 's' , ( ) => { const credentials = { private_key : 's' } ; testTraceModule . start ( { keyFilename : 's' , credentials } ) ; assert . ok ( capturedConfig ) ; assert . strictEqual ( capturedConfig ! . authOptions . keyFilename , 's' ) ; assert . deepStrictEqual ( capturedConfig ! . authOptions . credentials , credentials ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceCLSConfig$ O $Logger$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TopLevelConfig$ O $StackdriverTracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceWriterConfig$ O $Logger$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as trace from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const traceApi = trace . start ( ) ; traceApi . runInRootSpan ( { name : 's' , url : 's' } , rootSpan => { assert . strictEqual ( rootSpan . type , traceApi . spanTypes . UNSAMPLED ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as shimmer from 's' ; import * as logger from 's' ; import { TestLogger } from 's' ; import * as traceTestModule from 's' ; describe ( 's' , ( ) => { let logLevel : string | null = null ; class CaptureLogLevelTestLogger extends TestLogger { constructor ( opts : { level : string | false } ) { super ( opts ) ; if ( opts . level === false ) { throw new Error ( 's' ) ; } logLevel = opts . level ; } } before ( ( ) => { process . env . GCLOUD_TRACE_LOGLEVEL = 's' ; shimmer . wrap ( logger , 's' , ( ) => CaptureLogLevelTestLogger ) ; } ) ; after ( ( ) => { delete process . env . GCLOUD_TRACE_LOGLEVEL ; shimmer . unwrap ( logger , 's' ) ; } ) ; afterEach ( ( ) => { logLevel = null ; } ) ; it ( 's' , ( ) => { traceTestModule . start ( ) ; assert . strictEqual ( logLevel , logger . LEVELS [ 0 ] ) ; } ) ; it ( 's' , ( ) => { traceTestModule . start ( { logLevel : 0 } ) ; assert . strictEqual ( logLevel , logger . LEVELS [ 0 ] ) ; } ) ; it ( 's' , ( ) => { process . env . GCLOUD_TRACE_LOGLEVEL = 's' ; traceTestModule . start ( ) ; assert . strictEqual ( logLevel , logger . LEVELS [ 0 ] ) ; process . env . GCLOUD_TRACE_LOGLEVEL = 's' ; traceTestModule . start ( ) ; assert . strictEqual ( logLevel , logger . LEVELS [ 0 ] ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as protoLoader from 's' ; import * as grpcModule from 's' ; import { Tester , TesterClient } from 's' ; import * as traceTestModule from 's' ; import { describeInterop } from 's' ; type Grpc = typeof grpcModule ; const PORT = 0 ; describeInterop < Grpc > ( 's' , fixture => { let grpc ; let testerService : protoLoader . ServiceDefinition ; before ( async ( ) => { traceTestModule . setPluginLoaderForTest ( ) ; traceTestModule . setCLSForTest ( ) ; traceTestModule . start ( ) ; grpc = fixture . require ( ) ; const proto = await protoLoader . load ( `template` ) ; testerService = proto [ 's' ] as protoLoader . ServiceDefinition ; } ) ; afterEach ( ( ) => { traceTestModule . clearTraceData ( ) ; } ) ; after ( ( ) => { traceTestModule . setPluginLoaderForTest ( traceTestModule . TestPluginLoader ) ; traceTestModule . setCLSForTest ( traceTestModule . TestCLS ) ; } ) ; describe ( 's' , ( ) => { let server : grpcModule . Server ; let client ; before ( ( ) => { server = new grpc . Server ( ) ; server . addService < Tester > ( testerService , { testUnary : async ( call , callback ) => { callback ( null , { n : 0 } ) ; } , testClientStream : async ( call , callback ) => { callback ( null , { n : 0 } ) ; } , testServerStream : async call => { call . write ( { n : 0 } ) ; call . end ( ) ; } , testBidiStream : async call => { call . write ( { n : 0 } ) ; call . end ( ) ; } , } ) ; server . bind ( `template` , grpc . ServerCredentials . createInsecure ( ) ) ; server . start ( ) ; const TesterClient = grpc . makeGenericClientConstructor ( testerService , 's' , { } ) ; client = new TesterClient ( `template` , grpc . credentials . createInsecure ( ) ) as TesterClient ; } ) ; after ( ( ) => { server . forceShutdown ( ) ; } ) ; it ( 's' , async ( ) => { const tracer = traceTestModule . get ( ) ; await tracer . runInRootSpan ( { name : 's' } , async span => { await new Promise ( ( resolve , reject ) => client . TestUnary ( { n : 0 } , ( err , res ) => err ? reject ( err ) : resolve ( ) ) ) ; span . endSpan ( ) ; } ) ; traceTestModule . getOneSpan ( span => span . name === 's' && span . kind === 's' ) ; } ) ; it ( 's' , async ( ) => { const tracer = traceTestModule . get ( ) ; await tracer . runInRootSpan ( { name : 's' } , async span => { await new Promise ( ( resolve , reject ) => client . TestClientStream ( ( err , res ) => ( err ? reject ( err ) : resolve ( ) ) ) . end ( ) ) ; span . endSpan ( ) ; } ) ; traceTestModule . getOneSpan ( span => span . name === 's' && span . kind === 's' ) ; } ) ; it ( 's' , async ( ) => { const tracer = traceTestModule . get ( ) ; await tracer . runInRootSpan ( { name : 's' } , async span => { await new Promise ( ( resolve , reject ) => client . TestServerStream ( { n : 0 } ) . on ( 's' , reject ) . on ( 's' , ( ) => { } ) . on ( 's' , resolve ) ) ; span . endSpan ( ) ; } ) ; traceTestModule . getOneSpan ( span => span . name === 's' && span . kind === 's' ) ; } ) ; it ( 's' , async ( ) => { const tracer = traceTestModule . get ( ) ; await tracer . runInRootSpan ( { name : 's' } , async span => { await new Promise ( ( resolve , reject ) => client . TestBidiStream ( ) . on ( 's' , reject ) . on ( 's' , ( ) => { } ) . on ( 's' , resolve ) ) ; span . endSpan ( ) ; } ) ; traceTestModule . getOneSpan ( span => span . name === 's' && span . kind === 's' ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Grpc$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TesterClient$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { describeInterop } from 's' ; var agent = require ( 's' ) . start ( { projectId : 's' , samplingRate : 0 , ignoreUrls : [ 's' ] } ) ; var common = require ( 's' ) ; var assert = require ( 's' ) ; var express = require ( 's' ) ; var http = require ( 's' ) ; var grpcPort = 0 ; var protoFile = __dirname + 's' ; var client , grpcServer , server ; function makeHttpRequester ( callback , expectedReqs ) { var pendingHttpReqs = expectedReqs ; return function ( ) { http . get ( `template` , function ( httpRes ) { httpRes . on ( 's' , function ( ) { } ) ; httpRes . on ( 's' , function ( ) { if ( -- pendingHttpReqs === 0 ) { callback ( ) ; } } ) ; } ) ; } ; } function requestAndSendHTTPStatus ( res , expectedReqs ) { return makeHttpRequester ( function ( ) { res . sendStatus ( 0 ) ; } , expectedReqs ) ; } describeInterop ( 's' , fixture => { describe ( 's' , ( ) => { var grpc ; var httpLogCount ; before ( function ( done ) { grpc = fixture . require ( ) ; common . replaceWarnLogger ( function ( msg ) { if ( msg . indexOf ( 's' ) !== - 0 ) { httpLogCount ++ ; } } ) ; var proto = grpc . load ( protoFile ) . nodetest ; var app = express ( ) ; app . get ( 's' , function ( req , res ) { res . sendStatus ( 0 ) ; } ) ; app . get ( 's' , function ( req , res ) { var httpRequester = requestAndSendHTTPStatus ( res , 0 ) ; client . testUnary ( { n : 0 } , httpRequester ) ; } ) ; app . get ( 's' , function ( req , res ) { var httpRequester = requestAndSendHTTPStatus ( res , 0 ) ; var stream = client . testClientStream ( httpRequester ) ; for ( var i = 0 ; i < 0 ; ++ i ) { stream . write ( { n : i } ) ; } stream . end ( ) ; } ) ; app . get ( 's' , function ( req , res ) { var httpRequester = requestAndSendHTTPStatus ( res , 0 ) ; var stream = client . testServerStream ( { n : 0 } ) ; stream . on ( 's' , httpRequester ) ; stream . on ( 's' , httpRequester ) ; } ) ; app . get ( 's' , function ( req , res ) { var httpRequester = requestAndSendHTTPStatus ( res , 0 ) ; var stream = client . testBidiStream ( ) ; stream . on ( 's' , httpRequester ) ; stream . on ( 's' , httpRequester ) ; for ( var i = 0 ; i < 0 ; ++ i ) { stream . write ( { n : i } ) ; } stream . end ( ) ; } ) ; client = new proto . Tester ( 's' + grpcPort , grpc . credentials . createInsecure ( ) ) ; server = app . listen ( common . serverPort , function ( ) { grpcServer = new grpc . Server ( ) ; grpcServer . addProtoService ( proto . Tester . service , { testUnary : function ( call , cb ) { var httpRequester = makeHttpRequester ( function ( ) { cb ( null , { n : call . request . n } ) ; } , 0 ) ; httpRequester ( ) ; } , testClientStream : function ( call , cb ) { var httpRequester = makeHttpRequester ( function ( ) { cb ( null , { n : 0 } ) ; } , 0 ) ; call . on ( 's' , httpRequester ) ; call . on ( 's' , httpRequester ) ; } , testServerStream : function ( stream ) { var httpRequester = makeHttpRequester ( function ( ) { stream . end ( ) ; } , 0 ) ; for ( var i = 0 ; i < 0 ; ++ i ) { stream . write ( { n : i } ) ; } httpRequester ( ) ; } , testBidiStream : function ( stream ) { var httpRequester = makeHttpRequester ( function ( ) { stream . end ( ) ; } , 0 ) ; stream . on ( 's' , function ( data ) { stream . write ( { n : data . n } ) ; httpRequester ( ) ; } ) ; stream . on ( 's' , httpRequester ) ; } } ) ; grpcServer . bind ( 's' + grpcPort , grpc . ServerCredentials . createInsecure ( ) ) ; grpcServer . start ( ) ; done ( ) ; } ) ; } ) ; beforeEach ( function ( ) { httpLogCount = 0 ; } ) ; after ( function ( ) { grpcServer . forceShutdown ( ) ; server . close ( ) ; } ) ; afterEach ( function ( ) { assert . strictEqual ( httpLogCount , 0 ) ; common . cleanTraces ( ) ; } ) ; it ( 's' , function ( done ) { http . get ( { port : common . serverPort , path : 's' } , function ( res ) { assert . strictEqual ( common . getTraces ( ) . length , 0 ) ; assert . strictEqual ( common . getTraces ( ) [ 0 ] . spans . length , 0 ) ; assert . strictEqual ( common . getTraces ( ) [ 0 ] . spans [ 0 ] . kind , 's' ) ; assert . strictEqual ( common . getTraces ( ) [ 0 ] . spans . length , 0 ) ; done ( ) ; } ) ; } ) ; it ( 's' , function ( done ) { http . get ( { port : common . serverPort , path : 's' } , function ( res ) { assert . strictEqual ( common . getTraces ( ) . length , 0 ) ; assert . strictEqual ( common . getTraces ( ) [ 0 ] . spans . length , 0 ) ; assert . strictEqual ( common . getTraces ( ) [ 0 ] . spans [ 0 ] . kind , 's' ) ; assert . strictEqual ( common . getTraces ( ) [ 0 ] . spans . length , 0 ) ; done ( ) ; } ) ; } ) ; it ( 's' , function ( done ) { http . get ( { port : common . serverPort , path : 's' } , function ( res ) { assert . strictEqual ( common . getTraces ( ) . length , 0 ) ; assert . strictEqual ( common . getTraces ( ) [ 0 ] . spans . length , 0 ) ; assert . strictEqual ( common . getTraces ( ) [ 0 ] . spans [ 0 ] . kind , 's' ) ; assert . strictEqual ( common . getTraces ( ) [ 0 ] . spans . length , 0 ) ; done ( ) ; } ) ; } ) ; it ( 's' , function ( done ) { http . get ( { port : common . serverPort , path : 's' } , function ( res ) { assert . strictEqual ( common . getTraces ( ) . length , 0 ) ; assert . strictEqual ( common . getTraces ( ) [ 0 ] . spans . length , 0 ) ; assert . strictEqual ( common . getTraces ( ) [ 0 ] . spans [ 0 ] . kind , 's' ) ; assert . strictEqual ( common . getTraces ( ) [ 0 ] . spans . length , 0 ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import 's' ; import { StackdriverTracer } from 's' ; import { SpanType } from 's' ; import { FORCE_NEW } from 's' ; var assert = require ( 's' ) ; var trace = require ( 's' ) ; var disabledAgent = trace . get ( ) ; describe ( 's' , function ( ) { it ( 's' , async function ( ) { assert . ok ( ! disabledAgent . isActive ( ) ) ; let ranInRootSpan = false ; disabledAgent . runInRootSpan ( { name : 's' } , ( span ) => { assert . strictEqual ( span . type , SpanType . DISABLED ) ; ranInRootSpan = true ; } ) ; assert . ok ( ranInRootSpan ) ; assert . strictEqual ( disabledAgent . enhancedDatabaseReportingEnabled ( ) , false ) ; assert . strictEqual ( disabledAgent . getCurrentContextId ( ) , null ) ; assert . strictEqual ( disabledAgent . getWriterProjectId ( ) , null ) ; assert . strictEqual ( disabledAgent . getCurrentRootSpan ( ) . type , SpanType . DISABLED ) ; await disabledAgent . getProjectId ( ) . then ( ( ) => Promise . reject ( new Error ( ) ) , ( ) => Promise . resolve ( ) ) ; assert . strictEqual ( disabledAgent . createChildSpan ( { name : 's' } ) . type , SpanType . DISABLED ) ; assert . strictEqual ( disabledAgent . getResponseTraceContext ( { traceId : 's' , spanId : 's' } , false ) , null ) ; const fn = ( ) => { } ; assert . strictEqual ( disabledAgent . wrap ( fn ) , fn ) ; } ) ; describe ( 's' , function ( ) { var agent ; before ( function ( ) { agent = trace . start ( { projectId : 's' , [ FORCE_NEW ] : true } ) ; } ) ; it ( 's' , function ( ) { assert . strictEqual ( agent , trace . get ( ) ) ; } ) ; it ( 's' , function ( ) { assert . throws ( trace . start , Error ) ; } ) ; it ( 's' , function ( ) { assert . strictEqual ( global . _google_trace_agent , agent ) ; } ) ; } ) ; } ) ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StackdriverTracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { FORCE_NEW } from 's' ; delete process . env . GCLOUD_PROJECT ; var assert = require ( 's' ) ; describe ( 's' , function ( ) { it ( 's' , function ( ) { var agent = require ( 's' ) . start ( { projectId : { test : false } , enabled : true , logLevel : 0 , [ FORCE_NEW ] : true } ) ; assert ( ! agent . isActive ( ) ) ; } ) ; } ) ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as shimmer from 's' ; import * as log from 's' ; import { TestLogger } from 's' ; import * as testTraceModule from 's' ; const UNTRACED_LOGS_WARNING = "s" ; describe ( 's' , ( ) => { let logger : CaptureTestLogger | null = null ; class CaptureTestLogger extends TestLogger { constructor ( ) { super ( ) ; logger = this ; } } before ( ( ) => { shimmer . wrap ( log , 's' , ( ) => CaptureTestLogger ) ; } ) ; after ( ( ) => { shimmer . unwrap ( log , 's' ) ; } ) ; afterEach ( ( ) => { logger = null ; } ) ; it ( 's' , ( ) => { testTraceModule . start ( ) ; assert . ok ( logger ) ; assert . strictEqual ( logger ! . getNumLogsWith ( 's' , UNTRACED_LOGS_WARNING ) , 0 ) ; } ) ; it ( 's' , ( ) => { testTraceModule . start ( { disableUntracedModulesWarning : true } ) ; assert . ok ( logger ) ; assert . strictEqual ( logger ! . getNumLogsWith ( 's' , UNTRACED_LOGS_WARNING ) , 0 ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; var common = require ( 's' ) ; var assert = require ( 's' ) ; var http = require ( 's' ) ; var semver = require ( 's' ) ; if ( semver . satisfies ( process . version , 's' ) ) { describe ( 's' , function ( ) { var agent ; var Hapi ; before ( function ( ) { agent = require ( 's' ) . start ( { projectId : 's' , samplingRate : 0 , enhancedDatabaseReporting : true } ) ; Hapi = require ( 's' ) ; } ) ; it ( 's' , function ( done ) { var server = new Hapi . Server ( ) ; server . connection ( { port : common . serverPort } ) ; server . register ( { register : require ( 's' ) , options : require ( 's' ) } , function ( err ) { assert ( ! err ) ; server . route ( { method : 's' , path : 's' , handler : function ( request , reply ) { request . app . db . query ( 's' , function ( err , res ) { return reply ( 's' ) ; } ) ; } } ) ; server . start ( function ( err ) { assert ( ! err ) ; http . get ( { port : common . serverPort } , function ( res ) { var result = 's' ; res . on ( 's' , function ( data ) { result += data ; } ) ; res . on ( 's' , function ( ) { var spans = common . getMatchingSpans ( function ( span ) { return span . name === 's' ; } ) ; assert . strictEqual ( spans . length , 0 ) ; assert . strictEqual ( spans [ 0 ] . labels . sql , 's' ) ; server . stop ( done ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { FORCE_NEW } from 's' ; import { HOST_ADDRESS } from 's' ; var assert = require ( 's' ) ; var nock = require ( 's' ) ; var newWarn = function ( error ) { if ( error . indexOf ( 's' ) !== - 0 ) { assert ( false , error ) ; } } ; var common = require ( 's' ) ; nock . disableNetConnect ( ) ; describe ( 's' , function ( ) { it ( 's' , function ( done ) { var scope = nock ( HOST_ADDRESS ) . get ( 's' ) . reply ( 0 ) . get ( 's' ) . reply ( 0 ) ; require ( 's' ) . start ( { [ FORCE_NEW ] : true } ) ; require ( 's' ) ; var oldWarn = common . replaceWarnLogger ( newWarn ) ; setTimeout ( function ( ) { common . replaceWarnLogger ( oldWarn ) ; scope . done ( ) ; done ( ) ; } , 0 ) ; } ) ; it ( 's' , function ( done ) { var metadataScope = nock ( HOST_ADDRESS ) . get ( 's' ) . reply ( 0 ) . get ( 's' ) . reply ( 0 ) ; var apiScope = nock ( 's' ) . patch ( 's' ) . reply ( 0 ) ; delete process . env . GCLOUD_PROJECT ; require ( 's' ) . start ( { projectId : 's' , bufferSize : 0 , [ FORCE_NEW ] : true } ) ; common . avoidTraceWriterAuth ( ) ; require ( 's' ) ; var oldWarn = common . replaceWarnLogger ( newWarn ) ; common . runInTransaction ( function ( end ) { end ( ) ; setTimeout ( function ( ) { assert . strictEqual ( common . getTraces ( ) . length , 0 ) ; common . replaceWarnLogger ( oldWarn ) ; metadataScope . done ( ) ; apiScope . done ( ) ; done ( ) ; } , 0 ) ; } ) ; } ) ; } ) ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import * as path from 's' ; import { OpenCensusPropagation } from 's' ; import { PluginLoader , PluginLoaderState , PluginWrapper , } from 's' ; import { alwaysTrace } from 's' ; import { TestLogger } from 's' ; import { getBaseConfig , NoPropagation } from 's' ; export interface SimplePluginLoaderConfig { plugins : { [ pluginName ] : string } ; } const SEARCH_PATH = `template` ; const PROCESS_VERSION = process . version . slice ( 0 ) ; const clearRequireCache = ( ) => { Object . keys ( require . cache ) . forEach ( key => delete require . cache [ key ] ) ; } ; describe ( 's' , ( ) => { let logger ; const makePluginLoader = ( config ) => { return new PluginLoader ( Object . assign ( { tracerConfig : getBaseConfig ( ) } , config ) , { tracePolicy : alwaysTrace ( ) , logger , propagation : new NoPropagation ( ) } ) ; } ; before ( ( ) => { module . paths . push ( SEARCH_PATH ) ; PluginLoader . setPluginSearchPathForTestingOnly ( SEARCH_PATH ) ; logger = new TestLogger ( ) ; } ) ; afterEach ( ( ) => { logger . clearLogs ( ) ; clearRequireCache ( ) ; } ) ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { const pluginLoader = makePluginLoader ( { plugins : { } } ) ; assert . strictEqual ( pluginLoader . state , PluginLoaderState . NO_HOOK ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let requireHookCalled = false ; const pluginLoader = makePluginLoader ( { plugins : { } } ) ; pluginLoader [ 's' ] = ( ) => ( requireHookCalled = true ) ; pluginLoader . activate ( ) ; assert . strictEqual ( pluginLoader . state , PluginLoaderState . ACTIVATED ) ; assert . ok ( requireHookCalled ) ; } ) ; it ( 's' , ( ) => { let requireHookCalled = false ; const pluginLoader = makePluginLoader ( { plugins : { } } ) . activate ( ) ; assert . strictEqual ( pluginLoader . state , PluginLoaderState . ACTIVATED ) ; pluginLoader [ 's' ] = ( ) => ( requireHookCalled = true ) ; assert . throws ( ( ) => pluginLoader . activate ( ) ) ; assert . ok ( ! requireHookCalled ) ; } ) ; it ( 's' , ( ) => { let requireHookCalled = false ; const pluginLoader = makePluginLoader ( { plugins : { } } ) . activate ( ) . deactivate ( ) ; assert . strictEqual ( pluginLoader . state , PluginLoaderState . DEACTIVATED ) ; pluginLoader [ 's' ] = ( ) => ( requireHookCalled = true ) ; assert . throws ( ( ) => pluginLoader . activate ( ) ) ; assert . ok ( ! requireHookCalled ) ; } ) ; } ) ; describe ( 's' , ( ) => { class TestPluginWrapper implements PluginWrapper { unapplyCalled = false ; isSupported ( version ) { return false ; } unapplyAll ( ) { this . unapplyCalled = true ; } applyPlugin < T > ( moduleExports : T , file , version ) : T { return moduleExports ; } } it ( 's' , ( ) => { const pluginLoader = makePluginLoader ( { plugins : { } } ) . activate ( ) ; assert . strictEqual ( pluginLoader . state , PluginLoaderState . ACTIVATED ) ; const plugin = new TestPluginWrapper ( ) ; pluginLoader [ 's' ] . set ( 's' , plugin ) ; pluginLoader . deactivate ( ) ; assert . strictEqual ( pluginLoader . state , PluginLoaderState . DEACTIVATED ) ; assert . ok ( plugin . unapplyCalled ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { const p = PluginLoader . parseModuleString ; const sep = path . sep ; assert . deepStrictEqual ( p ( 's' ) , { name : 's' , file : 's' } ) ; assert . deepStrictEqual ( p ( 's' ) , { name : 's' , file : 's' } ) ; assert . deepStrictEqual ( p ( 's' ) , { name : 's' , file : 's' } ) ; assert . deepStrictEqual ( p ( `template` ) , { name : 's' , file : 's' } ) ; assert . deepStrictEqual ( p ( `template` ) , { name : 's' , file : 's' } ) ; assert . deepStrictEqual ( p ( 's' ) , { name : 's' , file : 's' } ) ; assert . deepStrictEqual ( p ( 's' ) , { name : 's' , file : 's' } ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { assert . strictEqual ( require ( 's' ) . value , 0 ) ; assert . strictEqual ( require ( 's' ) , 0 ) ; assert . strictEqual ( require ( 's' ) , 's' ) ; assert . strictEqual ( require ( 's' ) , 's' ) ; assert . strictEqual ( require ( 's' ) , 's' ) ; assert . strictEqual ( require ( 's' ) , 's' ) ; } ) ; it ( `template` , ( ) => { const loader = makePluginLoader ( { plugins : { 's' : 's' } , } ) ; assert . strictEqual ( require ( 's' ) . value , 0 ) ; loader . deactivate ( ) ; } ) ; it ( `template` , ( ) => { const loader = makePluginLoader ( { plugins : { } } ) . activate ( ) ; assert . strictEqual ( require ( 's' ) . value , 0 ) ; loader . deactivate ( ) ; } ) ; it ( 's' , ( ) => { const loader = makePluginLoader ( { plugins : { 's' : 's' } , } ) . activate ( ) ; assert . strictEqual ( require ( 's' ) . value , 0 ) ; assert . strictEqual ( require ( 's' ) . value , 0 ) ; assert . strictEqual ( logger . getNumLogsWith ( 's' , 's' ) , 0 ) ; loader . deactivate ( ) ; } ) ; it ( 's' , ( ) => { const loader = makePluginLoader ( { plugins : { 's' : `template` } , } ) . activate ( ) ; assert . strictEqual ( require ( 's' ) . value , 0 ) ; assert . strictEqual ( logger . getNumLogsWith ( 's' , 's' ) , 0 ) ; loader . deactivate ( ) ; } ) ; it ( 's' , ( ) => { const loader = makePluginLoader ( { plugins : { 's' : 's' } , } ) . activate ( ) ; require ( 's' ) ; loader . deactivate ( ) ; assert . strictEqual ( require ( 's' ) . value , 0 ) ; assert . strictEqual ( logger . getNumLogsWith ( 's' , 's' ) , 0 ) ; } ) ; it ( 's' , ( ) => { const loader = makePluginLoader ( { plugins : { 's' : 's' } , } ) . activate ( ) ; assert . strictEqual ( require ( 's' ) , 0 ) ; loader . deactivate ( ) ; } ) ; [ 's' , 's' , 's' ] . forEach ( key => { it ( `template` , ( ) => { const loader = makePluginLoader ( { plugins : { [ key ] : 's' } , } ) . activate ( ) ; const input = { protocol : 's' , host : 's' } ; assert . strictEqual ( require ( 's' ) . format ( input ) , 's' ) ; loader . deactivate ( ) ; assert . strictEqual ( require ( 's' ) . format ( input ) , 's' ) ; assert . strictEqual ( logger . getNumLogsWith ( 's' , `template` ) , 0 ) ; } ) ; } ) ; it ( `template` , ( ) => { const loader = makePluginLoader ( { plugins : { 's' : 's' } , } ) . activate ( ) ; assert . strictEqual ( require ( 's' ) . value , 0 ) ; loader . deactivate ( ) ; } ) ; it ( 's' , ( ) => { const loader = makePluginLoader ( { plugins : { 's' : 's' } , } ) . activate ( ) ; assert . strictEqual ( require ( 's' ) , 's' ) ; assert . strictEqual ( require ( 's' ) , 's' ) ; assert . strictEqual ( require ( 's' ) , 's' ) ; assert . strictEqual ( logger . getNumLogsWith ( 's' , 's' ) , 0 ) ; loader . deactivate ( ) ; } ) ; it ( 's' , ( ) => { const loader = makePluginLoader ( { plugins : { 's' : 's' } , } ) . activate ( ) ; assert . strictEqual ( require ( 's' ) , 's' ) ; assert . strictEqual ( logger . getNumLogsWith ( 's' , 's' ) , 0 ) ; loader . deactivate ( ) ; } ) ; it ( 's' , ( ) => { const loader = makePluginLoader ( { plugins : { 's' : 's' } , } ) . activate ( ) ; let threw = false ; try { require ( 's' ) ; } catch ( e ) { threw = true ; } assert . ok ( threw ) ; loader . deactivate ( ) ; } ) ; it ( 's' , ( ) => { const loader = makePluginLoader ( { plugins : { 's' : 's' } , } ) . activate ( ) ; require ( 's' ) ; require ( 's' ) ; require ( 's' ) ; assert . strictEqual ( logger . getNumLogsWith ( 's' , `template` ) , 0 ) ; assert . strictEqual ( logger . getNumLogsWith ( 's' , `template` ) , 0 ) ; assert . strictEqual ( logger . getNumLogsWith ( 's' , `template` ) , 0 ) ; loader . deactivate ( ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TestLogger$ O O O O O $SimplePluginLoaderConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O $void$ O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; var assert = require ( 's' ) ; var write ; describe ( 's' , function ( ) { var agent ; var savedProject ; before ( function ( ) { savedProject = process . env . GCLOUD_PROJECT ; delete process . env . GCLOUD_PROJECT ; agent = require ( 's' ) . start ( ) ; } ) ; after ( function ( ) { process . env . GCLOUD_PROJECT = savedProject ; } ) ; describe ( 's' , function ( ) { before ( function ( ) { write = process . stderr . write ; process . stderr . write = function ( c , e ? , cb ? ) { if ( cb ) { cb ( ) ; } return true ; } ; } ) ; after ( function ( ) { process . stderr . write = write ; } ) ; it ( 's' , function ( done ) { var mongoose = require ( 's' ) ; var Simple = mongoose . model ( 's' , new mongoose . Schema ( { 0 : String , 0 : Boolean , 0 : Number } ) ) ; mongoose . connect ( 's' , function ( err ) { assert ( ! err , 's' ) ; Simple . find ( { } , function ( err , results ) { mongoose . connection . close ( function ( err ) { done ( ) ; } ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var redis = require ( 's' ) ; var client = redis . createClient ( ) ; client . set ( 's' , 0 , function ( ) { client . quit ( function ( ) { done ( ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var http = require ( 's' ) ; var express = require ( 's' ) ; var app = express ( ) ; var server ; app . get ( 's' , function ( req , res ) { res . send ( 's' ) ; server . close ( ) ; done ( ) ; } ) ; server = app . listen ( 0 , function ( ) { http . get ( { port : 0 } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var http = require ( 's' ) ; var restify = require ( 's' ) ; var server = restify . createServer ( ) ; server . get ( 's' , function ( req , res , next ) { res . writeHead ( 0 , { 's' : 's' } ) ; res . write ( 's' ) ; res . end ( ) ; server . close ( ) ; done ( ) ; } ) ; server . listen ( 0 , function ( ) { http . get ( { port : 0 } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var http = require ( 's' ) ; var hapi = require ( 's' ) ; var server = new hapi . Server ( ) ; server . connection ( { port : 0 } ) ; server . route ( { method : 's' , path : 's' , handler : function ( req , reply ) { reply ( 's' ) ; server . stop ( ) ; done ( ) ; } } ) ; server . start ( function ( ) { http . get ( { port : 0 } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var req = require ( 's' ) . get ( { port : 0 } ) ; req . on ( 's' , function ( ) { done ( ) ; } ) ; } ) ; var mysql_implementations = [ 's' , 's' ] ; mysql_implementations . forEach ( function ( impl ) { it ( impl , function ( done ) { var mysql = require ( 's' + impl ) ; var pool = mysql . createPool ( require ( 's' ) ) ; pool . getConnection ( function ( err , conn ) { assert ( ! err , 's' ) ; conn . query ( 's' , function ( err , result ) { conn . release ( ) ; pool . end ( ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } ) ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; var common = require ( 's' ) ; var assert = require ( 's' ) ; var http = require ( 's' ) ; describe ( 's' , function ( ) { var untracedHttpSpanCount = 0 ; var oldWarn ; var agent ; before ( function ( ) { agent = require ( 's' ) . start ( { projectId : 's' , samplingRate : 0 , ignoreUrls : [ 's' ] } ) ; } ) ; beforeEach ( function ( ) { oldWarn = common . replaceWarnLogger ( function ( msg ) { if ( msg . indexOf ( 's' ) !== - 0 ) { untracedHttpSpanCount ++ ; } } ) ; } ) ; afterEach ( function ( ) { common . replaceWarnLogger ( oldWarn ) ; untracedHttpSpanCount = 0 ; } ) ; it ( 's' , function ( done ) { var mongoose = require ( 's' ) ; var express = require ( 's' ) ; var app = express ( ) ; app . get ( 's' , function ( req , res ) { mongoose . connect ( 's' , function ( err ) { assert ( ! err , 's' ) ; mongoose . connection . close ( function ( err ) { assert ( ! err ) ; res . sendStatus ( 0 ) ; } ) ; } ) ; } ) ; var server = app . listen ( common . serverPort , function ( ) { http . get ( { port : common . serverPort } , function ( res ) { http . get ( { port : common . serverPort } , function ( res ) { server . close ( ) ; common . cleanTraces ( ) ; assert . strictEqual ( untracedHttpSpanCount , 0 ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var redis = require ( 's' ) ; var express = require ( 's' ) ; var app = express ( ) ; app . get ( 's' , function ( req , res ) { var client = redis . createClient ( ) ; client . quit ( function ( ) { res . sendStatus ( 0 ) ; } ) ; } ) ; var server = app . listen ( common . serverPort + 0 , function ( ) { http . get ( { port : common . serverPort + 0 } , function ( res ) { http . get ( { port : common . serverPort + 0 } , function ( res ) { server . close ( ) ; common . cleanTraces ( ) ; assert . strictEqual ( untracedHttpSpanCount , 0 ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; it ( 's' , function ( done ) { var express = require ( 's' ) ; var app = express ( ) ; app . get ( 's' , ( req , res ) => { res . sendStatus ( 0 ) ; } ) ; app . get ( 's' , function ( req , res ) { http . get ( `template` , function ( ) { res . sendStatus ( 0 ) ; } ) ; } ) ; var server = app . listen ( common . serverPort + 0 , function ( ) { http . get ( { port : common . serverPort + 0 } , function ( res ) { http . get ( { port : common . serverPort + 0 } , function ( res ) { server . close ( ) ; common . cleanTraces ( ) ; assert . strictEqual ( untracedHttpSpanCount , 0 ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; var mysql_implementations = [ 's' , 's' ] ; mysql_implementations . forEach ( function ( impl ) { it ( impl + 's' , function ( done ) { var mysql = require ( 's' + impl ) ; var express = require ( 's' ) ; var pool = mysql . createPool ( require ( 's' ) ) ; var app = express ( ) ; app . get ( 's' , ( req , res ) => { res . sendStatus ( 0 ) ; } ) ; app . get ( 's' , function ( req , res ) { http . get ( `template` , function ( ) { pool . getConnection ( function ( err , conn ) { conn . query ( 's' , function ( err ) { res . sendStatus ( 0 ) ; } ) ; } ) ; } ) ; } ) ; var server = app . listen ( common . serverPort + 0 , function ( ) { http . get ( { port : common . serverPort + 0 } , function ( res ) { http . get ( { port : common . serverPort + 0 } , function ( res ) { pool . end ( ) ; server . close ( ) ; common . cleanTraces ( ) ; assert . strictEqual ( untracedHttpSpanCount , 0 ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; } ) ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as semver from 's' ; import { execSync } from 's' ; import * as assert from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { console . log ( process . cwd ( ) ) ; const output = execSync ( 's' ) ; assert . ok ( output . toString ( ) . match ( "s" ) ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import { Constants , SpanType } from 's' ; import { BaseSpanData , ChildSpanData , RootSpanData } from 's' ; import { Trace } from 's' ; import { TraceLabels } from 's' ; import { traceWriter , TraceWriter , TraceWriterConfig } from 's' ; import { TestLogger } from 's' ; import * as traceAgentModule from 's' ; import { wait } from 's' ; describe ( 's' , ( ) => { class CaptureSpanTraceWriter extends TraceWriter { writeTrace ( trace ) { assert . strictEqual ( capturedTrace , null ) ; capturedTrace = trace ; } } let capturedTrace : Trace | null ; let trace ; before ( ( ) => { traceAgentModule . setTraceWriterForTest ( CaptureSpanTraceWriter ) ; traceWriter . create ( { onUncaughtException : 's' , maximumLabelValueSize : 0 , stackTraceLimit : 0 , } as TraceWriterConfig , new TestLogger ( ) ) ; } ) ; after ( ( ) => { traceAgentModule . setTraceWriterForTest ( traceAgentModule . TestTraceWriter ) ; } ) ; beforeEach ( ( ) => { trace = { projectId : 's' , traceId : 's' , spans : [ ] } ; capturedTrace = null ; } ) ; describe ( 's' , ( ) => { class CommonSpanData extends ChildSpanData { } it ( 's' , ( ) => { const spanData = new CommonSpanData ( trace , 's' , 's' , 0 ) ; assert . strictEqual ( spanData . trace , trace ) ; } ) ; it ( 's' , ( ) => { const spanData = new CommonSpanData ( trace , 's' , 's' , 0 ) ; assert . strictEqual ( spanData . span . name , 's' ) ; assert . strictEqual ( spanData . span . parentSpanId , 's' ) ; assert . ok ( spanData . span . spanId . match ( "s" ) ) ; } ) ; it ( 's' , ( ) => { const numSpans = 0 ; const spanIds < string > = new Set ( ) ; for ( let i = 0 ; i < numSpans ; i ++ ) { const spanData = new CommonSpanData ( trace , 's' , 's' , 0 ) ; spanIds . add ( spanData . span . spanId ) ; } assert . strictEqual ( spanIds . size , numSpans ) ; } ) ; it ( 's' , async ( ) => { const startLowerBound = Date . now ( ) ; const spanData = new CommonSpanData ( trace , 's' , 's' , 0 ) ; const startUpperBound = Date . now ( ) ; await wait ( 0 ) ; const endLowerBound = Date . now ( ) ; spanData . endSpan ( ) ; const endUpperBound = Date . now ( ) ; const actualStart = new Date ( spanData . span . startTime ) . getTime ( ) ; const actualEnd = new Date ( spanData . span . endTime ) . getTime ( ) ; const expectedTimes = [ startLowerBound , actualStart , startUpperBound , endLowerBound , actualEnd , endUpperBound , ] ; assert . ok ( spanData . span . startTime ) ; assert . ok ( spanData . span . endTime ) ; const ascending = ( a , b ) => a - b ; assert . deepStrictEqual ( expectedTimes . slice ( ) . sort ( ascending ) , expectedTimes ) ; } ) ; it ( 's' , ( ) => { const spanData = new CommonSpanData ( trace , 's' , 's' , 0 ) ; const startTime = new Date ( spanData . span . startTime ) . getTime ( ) ; spanData . endSpan ( new Date ( startTime + 0 ) ) ; const endTime = new Date ( spanData . span . endTime ) . getTime ( ) ; assert . strictEqual ( endTime - startTime , 0 ) ; } ) ; it ( 's' , ( ) => { const name = 's' . repeat ( 0 ) ; const spanData = new CommonSpanData ( trace , name , 's' , 0 ) ; assert . strictEqual ( spanData . span . name , `template` ) ; } ) ; it ( 's' , ( ) => { const spanData = new CommonSpanData ( trace , 's' , 's' , 0 ) ; spanData . addLabel ( 's' , 's' ) ; spanData . addLabel ( 's' , 0 ) ; spanData . addLabel ( 's' , { a : true } ) ; spanData . addLabel ( 's' , Symbol ( 's' ) ) ; delete spanData . span . labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ; assert . deepStrictEqual ( spanData . span . labels , { id : 's' , key : 's' , obj : 's' , sym : 's' , } ) ; } ) ; it ( 's' , ( ) => { const spanData = new CommonSpanData ( trace , 's' , 's' , 0 ) ; const longKey = 's' . repeat ( 0 ) ; spanData . addLabel ( longKey , 's' ) ; delete spanData . span . labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ; assert . deepStrictEqual ( spanData . span . labels , { [ `template` ] : 's' , } ) ; } ) ; it ( 's' , ( ) => { const spanData = new CommonSpanData ( trace , 's' , 's' , 0 ) ; const longVal = 's' ; spanData . addLabel ( 's' , longVal ) ; delete spanData . span . labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ; assert . deepStrictEqual ( spanData . span . labels , { longKey : `template` , } ) ; } ) ; it ( 's' , ( ) => { const spanData = new CommonSpanData ( trace , 's' , 's' , 0 ) ; assert . deepStrictEqual ( spanData . getTraceContext ( ) , { traceId : spanData . trace . traceId , spanId : spanData . span . spanId , options : 0 , } ) ; } ) ; it ( 's' , ( ) => { function myFunction ( ) { const spanData = new CommonSpanData ( trace , 's' , 's' , 0 ) ; const stack = spanData . span . labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ; assert . ok ( stack ) ; const frames = JSON . parse ( stack ) ; assert . ok ( frames && frames . stack_frame ) ; assert . ok ( Array . isArray ( frames . stack_frame ) ) ; assert . strictEqual ( frames . stack_frame . length , traceWriter . get ( ) . getConfig ( ) . stackTraceLimit ) ; assert . strictEqual ( frames . stack_frame [ 0 ] . method_name , 's' ) ; } myFunction ( ) ; } ) ; describe ( 's' , ( ) => { const sourceMapTypes = [ 's' , 's' , 's' , ] ; const getSourceMapTestStackFrame = ( spanData ) => { const stack = spanData . span . labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ; assert . ok ( stack ) ; const frames = JSON . parse ( stack ) ; assert . ok ( frames && frames . stack_frame ) ; assert . ok ( Array . isArray ( frames . stack_frame ) ) ; const stackFrame = frames . stack_frame [ 0 ] ; return stackFrame ; } ; for ( const sourceMapType of sourceMapTypes ) { it ( `template` , ( ) => { const { applyGeneric , } = require ( `template` ) as { applyGeneric : < T > ( fn : ( ) => T ) => T ; } ; const spanData = applyGeneric ( ( ) => new CommonSpanData ( trace , 's' , 's' , 0 ) ) ; const stackFrame = getSourceMapTestStackFrame ( spanData ) ; assert . ok ( stackFrame . file_name . endsWith ( `template` ) ) ; assert . strictEqual ( stackFrame . line_number , 0 ) ; assert . strictEqual ( stackFrame . column_number , 0 ) ; } ) ; } it ( `template` , ( ) => { const { applyGeneric , } = require ( `template` ) as { applyGeneric : < T > ( fn : ( ) => T ) => T ; } ; const spanData = applyGeneric ( ( ) => new CommonSpanData ( trace , 's' , 's' , 0 ) ) ; const stackFrame = getSourceMapTestStackFrame ( spanData ) ; assert . ok ( stackFrame . file_name . endsWith ( 's' ) ) ; assert . strictEqual ( stackFrame . line_number , 0 ) ; assert . strictEqual ( stackFrame . column_number , 0 ) ; } ) ; } ) ; it ( `template` , ( ) => { const spanData = new CommonSpanData ( trace , 's' , 's' , 0 ) ; spanData . endSpan ( ) ; assert . ok ( ! capturedTrace ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const rootSpanData = new RootSpanData ( trace , 's' , 's' , 0 ) ; const childSpanData = rootSpanData . createChildSpan ( { name : 's' , } ) as ChildSpanData ; assert . strictEqual ( childSpanData . span . parentSpanId , rootSpanData . span . spanId ) ; } ) ; it ( 's' , ( ) => { const rootSpanData = new RootSpanData ( trace , 's' , 's' , 0 ) ; rootSpanData . endSpan ( ) ; assert . strictEqual ( capturedTrace , rootSpanData . trace ) ; } ) ; it ( `template` , ( ) => { const rootSpanData = new RootSpanData ( trace , 's' , 's' , 0 ) ; rootSpanData . endSpan ( ) ; assert . strictEqual ( capturedTrace , rootSpanData . trace ) ; capturedTrace = null ; rootSpanData . endSpan ( ) ; assert . ok ( ! capturedTrace ) ; } ) ; it ( 's' , ( ) => { const rootSpanData = new RootSpanData ( trace , 's' , 's' , 0 ) ; const firstChildSpanData = rootSpanData . createChildSpan ( { name : 's' , } ) as ChildSpanData ; const secondChildSpanData = rootSpanData . createChildSpan ( { name : 's' , } ) as ChildSpanData ; firstChildSpanData . endSpan ( ) ; rootSpanData . endSpan ( ) ; assert . ok ( capturedTrace ) ; const firstTrace = capturedTrace ! ; capturedTrace = null ; secondChildSpanData . endSpan ( ) ; assert . ok ( capturedTrace ) ; assert . strictEqual ( firstTrace . traceId , capturedTrace ! . traceId ) ; assert . strictEqual ( capturedTrace ! . spans . length , 0 ) ; assert . strictEqual ( capturedTrace ! . spans [ 0 ] , secondChildSpanData . span ) ; capturedTrace = null ; firstChildSpanData . endSpan ( ) ; secondChildSpanData . endSpan ( ) ; assert . ok ( ! capturedTrace ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Trace$ O O O O O O O O O O O O O O O O O O O O O O O O O $Trace$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Set$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CommonSpanData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import { SpanType } from 's' ; import { Tracer } from 's' ; import * as testTraceModule from 's' ; import { asChildSpanData , asRootSpanData } from 's' ; const identity = < T > ( x : T ) => x ; describe ( 's' , ( ) => { let traceApi ; before ( ( ) => { testTraceModule . setCLSForTest ( ) ; } ) ; after ( ( ) => { testTraceModule . setCLSForTest ( testTraceModule . TestCLS ) ; } ) ; beforeEach ( ( ) => { traceApi = testTraceModule . start ( { clsMechanism : 's' } ) ; } ) ; afterEach ( ( ) => { testTraceModule . clearTraceData ( ) ; } ) ; it ( 's' , ( ) => { traceApi . runInRootSpan ( { name : 's' } , 0 => { assert . strictEqual ( 0 . type , SpanType . ROOT ) ; traceApi . runInRootSpan ( { name : 's' } , 0 => { assert . strictEqual ( 0 . type , SpanType . ROOT ) ; assert . notStrictEqual ( asRootSpanData ( 0 ) . trace . traceId , asRootSpanData ( 0 ) . trace . traceId ) ; 0 . endSpan ( ) ; } ) ; 0 . endSpan ( ) ; } ) ; } ) ; it ( 's' , ( ) => { const root = asRootSpanData ( traceApi . runInRootSpan ( { name : 's' } , identity ) ) ; const child = asChildSpanData ( root . createChildSpan ( { name : 's' } ) ) ; assert . strictEqual ( child . span . parentSpanId , root . span . spanId ) ; assert . strictEqual ( child . trace . traceId , root . trace . traceId ) ; child . endSpan ( ) ; root . endSpan ( ) ; } ) ; it ( 's' , ( ) => { const root = asRootSpanData ( traceApi . runInRootSpan ( { name : 's' } , identity ) ) ; const child = traceApi . createChildSpan ( { name : 's' } ) ; assert . strictEqual ( child . type , SpanType . UNCORRELATED ) ; child . endSpan ( ) ; root . endSpan ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Tracer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import { cls , TraceCLS , TraceCLSMechanism } from 's' ; import { defaultConfig , GetHeaderFunction as HeaderGetter , OpenCensusPropagation , RequestDetails , SetHeaderFunction as HeaderSetter , TracePolicy , } from 's' ; import { SpanType } from 's' ; import { StackdriverTracer , StackdriverTracerComponents , StackdriverTracerConfig , } from 's' ; import { traceWriter } from 's' ; import { alwaysTrace , neverTrace } from 's' ; import { FORCE_NEW , TraceContext } from 's' ; import { TestLogger } from 's' ; import * as testTraceModule from 's' ; import { getBaseConfig , NoPropagation } from 's' ; describe ( 's' , ( ) => { const logger = new TestLogger ( ) ; function createTraceAgent ( config ? < StackdriverTracerConfig > , components ? < StackdriverTracerComponents > ) { const result = new StackdriverTracer ( 's' ) ; result . enable ( Object . assign ( getBaseConfig ( ) , config ) , Object . assign ( { tracePolicy : alwaysTrace ( ) , logger , propagation : new NoPropagation ( ) , } , components ) ) ; return result ; } before ( ( ) => { testTraceModule . setCLSForTest ( TraceCLS ) ; cls . create ( { mechanism : TraceCLSMechanism . ASYNC_LISTENER } , logger ) . enable ( ) ; return traceWriter . create ( Object . assign ( { [ FORCE_NEW ] : true , authOptions : { projectId : 's' } } , defaultConfig ) , logger ) . initialize ( ) ; } ) ; after ( ( ) => { testTraceModule . setCLSForTest ( testTraceModule . TestCLS ) ; } ) ; it ( 's' , ( ) => { const traceAPI = createTraceAgent ( ) ; assert . ok ( traceAPI . isActive ( ) ) ; traceAPI . disable ( ) ; assert . ok ( ! traceAPI . isActive ( ) , 's' ) ; } ) ; describe ( 's' , ( ) => { afterEach ( ( ) => { testTraceModule . clearTraceData ( ) ; } ) ; it ( 's' , ( ) => { const traceAPI = createTraceAgent ( ) ; traceAPI . runInRootSpan ( { name : 's' } , rootSpan => { const childSpan = traceAPI . createChildSpan ( { name : 's' } ) ; childSpan . addLabel ( 's' , 's' ) ; childSpan . endSpan ( ) ; rootSpan . endSpan ( ) ; } ) ; const rootSpanData = testTraceModule . getOneSpan ( span => span . name === 's' ) ; const childSpanData = testTraceModule . getOneSpan ( span => span . name === 's' ) ; assert . strictEqual ( childSpanData . parentSpanId , rootSpanData . spanId ) ; assert . strictEqual ( childSpanData . labels . key , 's' ) ; } ) ; it ( 's' , ( ) => { const traceAPI = createTraceAgent ( ) ; traceAPI . runInRootSpan ( { name : 's' } , rootSpan => { const childSpan = rootSpan . createChildSpan ( { name : 's' } ) ; childSpan . addLabel ( 's' , 's' ) ; childSpan . endSpan ( ) ; rootSpan . endSpan ( ) ; } ) ; const rootSpanData = testTraceModule . getOneSpan ( span => span . name === 's' ) ; const childSpanData = testTraceModule . getOneSpan ( span => span . name === 's' ) ; assert . strictEqual ( childSpanData . parentSpanId , rootSpanData . spanId ) ; assert . strictEqual ( childSpanData . labels . key , 's' ) ; } ) ; it ( 's' , ( ) => { const traceAPI = createTraceAgent ( ) ; const result = traceAPI . runInRootSpan ( { name : 's' } , rootSpan => { rootSpan . addLabel ( 's' , 's' ) ; rootSpan . endSpan ( ) ; return 's' ; } ) ; assert . strictEqual ( result , 's' ) ; const rootSpanData = testTraceModule . getOneSpan ( span => span . name === 's' ) ; assert . strictEqual ( rootSpanData . labels . key , 's' ) ; } ) ; it ( 's' , ( ) => { const traceAPI = createTraceAgent ( ) ; traceAPI . runInRootSpan ( { name : 's' } , rootSpan => { rootSpan . endSpan ( ) ; } ) ; traceAPI . runInRootSpan ( { name : 's' } , rootSpan => { rootSpan . endSpan ( ) ; } ) ; assert . strictEqual ( testTraceModule . getTraces ( ) . length , 0 ) ; } ) ; it ( 's' , ( ) => { const traceAPI = createTraceAgent ( ) ; traceAPI . runInRootSpan ( { name : 's' } , rootSpan => { traceAPI . runInRootSpan ( { name : 's' } , notRootSpan => { assert . strictEqual ( notRootSpan . type , SpanType . UNCORRELATED ) ; notRootSpan . endSpan ( ) ; } ) ; rootSpan . endSpan ( ) ; } ) ; assert . strictEqual ( testTraceModule . getTraces ( ) . length , 0 ) ; } ) ; it ( 's' , ( ) => { const traceAPI = createTraceAgent ( ) ; assert . strictEqual ( traceAPI . getCurrentRootSpan ( ) . type , SpanType . UNCORRELATED ) ; traceAPI . runInRootSpan ( { name : 's' } , rootSpan => { assert . strictEqual ( traceAPI . getCurrentRootSpan ( ) , rootSpan ) ; rootSpan . endSpan ( ) ; } ) ; } ) ; it ( 's' , ( ) => { const tracer = createTraceAgent ( { spansPerTraceSoftLimit : 0 , spansPerTraceHardLimit : 0 , } ) ; tracer . runInRootSpan ( { name : 's' } , rootSpan => { for ( let i = 0 ; i < 0 ; i ++ ) { tracer . createChildSpan ( { name : `template` } ) . endSpan ( ) ; } assert . strictEqual ( logger . getNumLogsWith ( 's' , 's' ) , 0 ) ; for ( let i = 0 ; i < 0 ; i ++ ) { tracer . createChildSpan ( { name : `template` } ) . endSpan ( ) ; } const child = tracer . createChildSpan ( { name : `template` } ) ; assert . ok ( ! tracer . isRealSpan ( child ) ) ; assert . strictEqual ( logger . getNumLogsWith ( 's' , 's' ) , 0 ) ; rootSpan . endSpan ( ) ; } ) ; } ) ; it ( 's' , ( ) => { const traceAPI = createTraceAgent ( ) ; assert . strictEqual ( traceAPI . getCurrentContextId ( ) , null ) ; } ) ; it ( 's' , ( ) => { const traceAPI = createTraceAgent ( ) ; traceAPI . runInRootSpan ( { name : 's' } , rootSpan => { const id = traceAPI . getCurrentContextId ( ) ; assert . ok ( rootSpan . getTraceContext ( ) ) ; assert . strictEqual ( id , rootSpan . getTraceContext ( ) ! . traceId ) ; rootSpan . endSpan ( ) ; testTraceModule . getOneTrace ( trace => trace . traceId === id ) ; } ) ; } ) ; it ( 's' , ( ) => { const traceAPI = createTraceAgent ( { } , { tracePolicy : neverTrace ( ) } ) ; traceAPI . runInRootSpan ( { name : 's' } , rootSpan => { assert . strictEqual ( rootSpan . type , SpanType . UNSAMPLED ) ; assert . notStrictEqual ( traceAPI . getCurrentContextId ( ) , null ) ; assert . ok ( rootSpan . getTraceContext ( ) ) ; assert . strictEqual ( traceAPI . getCurrentContextId ( ) , rootSpan . getTraceContext ( ) ! . traceId ) ; assert . ok ( rootSpan . createChildSpan ( ) . getTraceContext ( ) ) ; assert . ok ( traceAPI . createChildSpan ( ) . getTraceContext ( ) ) ; } ) ; } ) ; it ( 's' , async ( ) => { const traceApi = createTraceAgent ( ) ; assert . strictEqual ( await traceApi . getProjectId ( ) , 's' ) ; } ) ; it ( 's' , ( ) => { const traceApi = createTraceAgent ( ) ; assert . strictEqual ( traceApi . getWriterProjectId ( ) , 's' ) ; } ) ; it ( 's' , ( ) => { class CaptureOptionsTracePolicy { capturedShouldTraceParam : RequestDetails | null = null ; shouldTrace ( options ) { this . capturedShouldTraceParam = options ; return false ; } } const tracePolicy = new CaptureOptionsTracePolicy ( ) ; const traceAPI = createTraceAgent ( { } , { tracePolicy } ) ; { const rootSpanOptions = { name : 's' , url : 's' , method : 's' , traceContext : { traceId : 's' , spanId : 's' , options : 0 } , } ; const beforeRootSpan = Date . now ( ) ; traceAPI . runInRootSpan ( rootSpanOptions , rootSpan => { assert . strictEqual ( rootSpan . type , SpanType . UNSAMPLED ) ; rootSpan . endSpan ( ) ; } ) ; const afterRootSpan = Date . now ( ) ; assert . ok ( tracePolicy . capturedShouldTraceParam ) ; const shouldTraceParam = tracePolicy . capturedShouldTraceParam ! ; assert . strictEqual ( shouldTraceParam . url , 's' ) ; assert . strictEqual ( shouldTraceParam . method , 's' ) ; assert . ok ( shouldTraceParam . timestamp >= beforeRootSpan ) ; assert . ok ( shouldTraceParam . timestamp <= afterRootSpan ) ; assert . ok ( shouldTraceParam . timestamp <= afterRootSpan ) ; assert . deepStrictEqual ( shouldTraceParam . traceContext , rootSpanOptions . traceContext ) ; assert . strictEqual ( shouldTraceParam . options , rootSpanOptions ) ; } tracePolicy . capturedShouldTraceParam = null ; { const rootSpanOptions = { name : 's' } ; traceAPI . runInRootSpan ( rootSpanOptions , rootSpan => { assert . strictEqual ( rootSpan . type , SpanType . UNSAMPLED ) ; rootSpan . endSpan ( ) ; } ) ; assert . ok ( tracePolicy . capturedShouldTraceParam ) ; const shouldTraceParam = tracePolicy . capturedShouldTraceParam ! ; assert . strictEqual ( shouldTraceParam . url , 's' ) ; assert . strictEqual ( shouldTraceParam . method , 's' ) ; assert . strictEqual ( shouldTraceParam . traceContext , null ) ; assert . strictEqual ( shouldTraceParam . options , rootSpanOptions ) ; } } ) ; it ( 's' , ( ) => { class TestPropagation implements OpenCensusPropagation { extract ( { getHeader } ) { return { traceId : getHeader ( 's' ) as string , spanId : 's' , options : 0 } ; } inject ( { setHeader } , traceContext ) { setHeader ( traceContext . traceId , 's' ) ; } } const propagation = new TestPropagation ( ) ; const tracer = createTraceAgent ( { } , { propagation } ) ; const result = tracer . propagation . extract ( s => `template` ) ; assert . deepStrictEqual ( result , { traceId : 's' , spanId : 's' , options : 0 , } ) ; let setHeaderCalled = false ; tracer . propagation . inject ( ( key , value ) => { assert . strictEqual ( key , 's' ) ; assert . strictEqual ( value , 's' ) ; setHeaderCalled = true ; } , { traceId : 's' , spanId : 's' , options : 0 } ) ; assert . ok ( setHeaderCalled ) ; } ) ; it ( 's' , ( ) => { [ true , false ] . forEach ( enhancedDatabaseReporting => { const traceAPI = createTraceAgent ( { enhancedDatabaseReporting , } ) ; assert . strictEqual ( traceAPI . enhancedDatabaseReportingEnabled ( ) , enhancedDatabaseReporting ) ; } ) ; } ) ; it ( 's' , ( ) => { { createTraceAgent ( ) . runInRootSpan ( { name : 's' , traceContext : { traceId : 's' , spanId : 's' , options : 0 } , } , rootSpan => { rootSpan . endSpan ( ) ; } ) ; const foundTrace = testTraceModule . getOneTrace ( trace => trace . traceId === 's' ) ; assert . strictEqual ( foundTrace . spans . length , 0 ) ; assert . strictEqual ( foundTrace . spans [ 0 ] . name , 's' ) ; assert . strictEqual ( foundTrace . spans [ 0 ] . parentSpanId , 's' ) ; } { createTraceAgent ( ) . runInRootSpan ( { name : 's' } , rootSpan => { rootSpan . endSpan ( ) ; } ) ; const foundTrace = testTraceModule . getOneTrace ( trace => trace . traceId !== 's' ) ; assert . strictEqual ( foundTrace . spans . length , 0 ) ; assert . strictEqual ( foundTrace . spans [ 0 ] . name , 's' ) ; assert . notStrictEqual ( foundTrace . spans [ 0 ] . parentSpanId , 's' ) ; } } ) ; it ( 's' , ( ) => { createTraceAgent ( { enhancedDatabaseReporting : false } ) . runInRootSpan ( { name : 's' , traceContext : { traceId : 's' , spanId : 's' } } , rootSpan => { rootSpan . endSpan ( ) ; } ) ; const foundTrace = testTraceModule . getOneTrace ( trace => trace . traceId === 's' ) ; assert . strictEqual ( foundTrace . spans . length , 0 ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const fakeTraceId = 's' ; const traceApi = createTraceAgent ( ) ; const tracedContext = { traceId : fakeTraceId , spanId : 's' , options : 0 } ; const untracedContext = { traceId : fakeTraceId , spanId : 's' , options : 0 , } ; const unspecifiedContext = { traceId : fakeTraceId , spanId : 's' } ; assert . deepStrictEqual ( traceApi . getResponseTraceContext ( tracedContext , true ) , tracedContext ) ; assert . deepStrictEqual ( traceApi . getResponseTraceContext ( tracedContext , false ) , untracedContext ) ; assert . deepStrictEqual ( traceApi . getResponseTraceContext ( untracedContext , true ) , untracedContext ) ; assert . deepStrictEqual ( traceApi . getResponseTraceContext ( untracedContext , false ) , untracedContext ) ; assert . deepStrictEqual ( traceApi . getResponseTraceContext ( unspecifiedContext , true ) , untracedContext ) ; assert . deepStrictEqual ( traceApi . getResponseTraceContext ( unspecifiedContext , false ) , untracedContext ) ; } ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $StackdriverTracer$ O O $Partial$ O O O O O $Partial$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RequestDetails$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HeaderGetter$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $HeaderSetter$ O $TraceContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import axiosModule from 's' ; import * as cluster from 's' ; import { Server } from 's' ; import { AddressInfo } from 's' ; import * as cls from 's' ; import { 0 as expressModule } from 's' ; import * as testTraceModule from 's' ; import { assertSpanDuration , DEFAULT_SPAN_DURATION , isServerSpan , wait , } from 's' ; describe ( 's' , ( ) => { let axios : typeof axiosModule ; let express : typeof expressModule ; before ( ( ) => { testTraceModule . setCLSForTest ( ) ; testTraceModule . setPluginLoaderForTest ( ) ; testTraceModule . start ( ) ; express = require ( 's' ) ; axios = require ( 's' ) ; } ) ; after ( ( ) => { testTraceModule . setCLSForTest ( testTraceModule . TestCLS ) ; testTraceModule . setPluginLoaderForTest ( testTraceModule . TestPluginLoader ) ; } ) ; it ( 's' , async ( ) => { if ( cluster . isMaster ) { await new Promise ( resolve => { const worker = cluster . fork ( ) ; worker . on ( 's' , code => { assert . strictEqual ( code , 0 ) ; console . log ( 's' ) ; resolve ( ) ; } ) ; } ) ; } else { const app = express ( ) ; app . get ( 's' , async ( req , res ) => { await wait ( DEFAULT_SPAN_DURATION ) ; res . send ( 's' ) ; } ) ; const server = await new Promise < Server > ( resolve => { const server = app . listen ( 0 , ( ) => resolve ( server ) ) ; } ) ; const port = ( server . address ( ) as AddressInfo ) . port ; let recordedTime = Date . now ( ) ; await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async span => { assert . ok ( span ) ; await axios . get ( `template` ) ; span ! . endSpan ( ) ; } ) ; recordedTime = Date . now ( ) - recordedTime ; const serverSpan = testTraceModule . getOneSpan ( isServerSpan ) ; assertSpanDuration ( serverSpan , [ DEFAULT_SPAN_DURATION , recordedTime ] ) ; cluster . worker . disconnect ( ) ; server . close ( ) ; } } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' ; import { 0 } from 's' ; import { WebFramework , WebFrameworkAddHandlerOptions } from 's' ; const TAIL_WORK = Symbol ( 's' ) ; interface AppState { [ TAIL_WORK ] ? : Array < Promise < void > > ; } class Hapi extends EventEmitter implements WebFramework { server : 0 . Server ; routes = new Map < string , WebFrameworkAddHandlerOptions [ ] > ( ) ; registering = Promise . resolve ( ) ; constructor ( path ) { super ( ) ; const hapi = require ( path ) as typeof 0 ; this . server = new hapi . Server ( ) ; this . server . events . on ( 's' , ( request : 0 . Request ) => { Promise . all ( ( request . app as AppState ) [ TAIL_WORK ] || [ ] ) . then ( ( ) => this . emit ( 's' ) , ( err ) => this . emit ( 's' , err ) ) ; } ) ; } addHandler ( options ) { let shouldRegister = false ; if ( ! this . routes . has ( options . path ) ) { this . routes . set ( options . path , [ options ] ) ; shouldRegister = true ; } else { this . routes . get ( options . path ) ! . push ( options ) ; } if ( shouldRegister ) { this . registering = this . registering . then ( ( ) => this . server . register ( { plugin : { name : options . path , register : async ( server , registerOpts ) => { server . route ( { method : 's' , path : options . path , handler : async ( request , h ) => { let result ; for ( const localOptions of this . routes . get ( options . path ) ! ) { if ( localOptions . hasResponse || localOptions . blocking ) { result = await localOptions . fn ( request . raw . req . headers ) ; if ( result ) { return result ; } } else { const appState = request . app ; if ( ! appState [ TAIL_WORK ] ) { appState [ TAIL_WORK ] = [ ] ; } appState [ TAIL_WORK ] ! . push ( localOptions . fn ( request . raw . req . headers ) ) ; } } return h . continue ; } , } ) ; } , } , } ) ) ; } } async listen ( port ) < number > { await this . registering ; this . server . settings . port = port ; await this . server . start ( ) ; return Number ( this . server . info ! . port ) ; } shutdown ( ) { this . server . stop ( ) ; } } const makeHapiClass = ( version ) => class extends Hapi { static commonName = `template` ; static expectedTopStackFrame = 's' ; static versionRange = 's' ; constructor ( ) { super ( `template` ) ; } } ; export const 0 = makeHapiClass ( 0 ) ; export const 0 = makeHapiClass ( 0 ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O $void$ O $WebFrameworkAddHandlerOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AppState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { EventEmitter } from 's' ; import { 0 } from 's' ; import { WebFramework , WebFrameworkAddHandlerOptions , WebFrameworkResponse , } from 's' ; export class Hapi extends EventEmitter implements WebFramework { server : 0 . Server ; queuedHandlers : Array < ( ) => void > = [ ] ; constructor ( path ) { super ( ) ; const hapi = require ( path ) as typeof 0 ; this . server = new hapi . Server ( ) ; this . server . on ( 's' , ( ) => this . emit ( 's' ) ) ; } addHandler ( options ) { this . queuedHandlers . push ( ( ) => { if ( options . hasResponse ) { this . server . route ( { method : 's' , path : options . path , handler : async ( request , reply ) => { let response ; try { response = await options . fn ( request . raw . req . headers ) ; } catch ( e ) { reply ( e ) ; return ; } reply ( response . message ) . statusCode = response . statusCode ; } , } ) ; } else { if ( options . blocking ) { this . server . ext ( 's' , async ( request , reply ) => { try { await options . fn ( request . raw . req . headers ) ; } catch ( e ) { reply ( e ) ; return ; } reply . continue ( ) ; } ) ; } else { this . server . ext ( 's' , ( request , reply ) => { const tail = request . tail ( ) ; options . fn ( request . raw . req . headers ) . then ( tail , tail ) ; reply . continue ( ) ; } ) ; } } } ) ; } async listen ( port ) < number > { this . server . connection ( { host : 's' , port } ) ; this . queuedHandlers . forEach ( fn => fn ( ) ) ; this . queuedHandlers = [ ] ; await new Promise ( ( resolve , reject ) => this . server . start ( err => { if ( err ) { reject ( err ) ; } else { resolve ( ) ; } } ) ) ; return Number ( this . server . info ! . port ) ; } shutdown ( ) { this . server . stop ( ) ; } } const makeHapiClass = ( version ) => class extends Hapi { static commonName = `template` ; static expectedTopStackFrame = 's' ; static versionRange = 's' ; constructor ( ) { super ( `template` ) ; } } ; export const 0 = makeHapiClass ( 0 ) ; export const 0 = makeHapiClass ( 0 ) ; export const 0 = makeHapiClass ( 0 ) ; export const 0 = makeHapiClass ( 0 ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $WebFrameworkAddHandlerOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $WebFrameworkResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import axiosModule from 's' ; import * as semver from 's' ; import * as testTraceModule from 's' ; import { assertSpanDuration , wait } from 's' ; import { 0 } from 's' ; import { 0 , 0 , 0 , 0 } from 's' ; const FRAMEWORKS = [ 0 , 0 , 0 , 0 , 0 ] ; describe ( 's' , ( ) => { let axios : typeof axiosModule ; before ( ( ) => { testTraceModule . setCLSForTest ( ) ; testTraceModule . setPluginLoaderForTest ( ) ; testTraceModule . start ( ) ; axios = require ( 's' ) ; } ) ; after ( ( ) => { testTraceModule . setCLSForTest ( testTraceModule . TestCLS ) ; testTraceModule . setPluginLoaderForTest ( testTraceModule . TestPluginLoader ) ; } ) ; FRAMEWORKS . forEach ( webFrameworkConstructor => { const commonName = webFrameworkConstructor . commonName ; const versionRange = webFrameworkConstructor . versionRange ; const skip = ! semver . satisfies ( process . version , versionRange ) ; ( skip ? describe . skip : describe ) ( `template` , ( ) => { it ( 's' , async ( ) => { const framework = new webFrameworkConstructor ( ) ; try { framework . addHandler ( { path : 's' , hasResponse : false , blocking : false , fn : async ( ) => { const child = testTraceModule . get ( ) . createChildSpan ( { name : 's' } ) ; await wait ( 0 ) ; child . endSpan ( ) ; } , } ) ; framework . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => ( { statusCode : 0 , message : 's' , } ) , } ) ; const tailCallMade = new Promise ( resolve => framework . once ( 's' , resolve ) ) ; const port = await framework . listen ( 0 ) ; await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async span => { await axios . get ( `template` ) ; span . endSpan ( ) ; } ) ; const childSpanBeforeEnd = testTraceModule . getOneSpan ( span => span . name === 's' ) ; assert . ok ( ! childSpanBeforeEnd . endTime ) ; testTraceModule . clearTraceData ( ) ; await tailCallMade ; const childSpanAfterEnd = testTraceModule . getOneSpan ( span => span . name === 's' ) ; assert . strictEqual ( childSpanAfterEnd . spanId , childSpanBeforeEnd . spanId ) ; assertSpanDuration ( childSpanAfterEnd , [ 0 , Infinity ] ) ; } finally { framework . shutdown ( ) ; testTraceModule . clearTraceData ( ) ; } } ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; var common = require ( 's' ) ; var assert = require ( 's' ) ; var http = require ( 's' ) ; describe ( 's' , function ( ) { var agent ; var express ; before ( function ( ) { agent = require ( 's' ) . start ( { projectId : 's' , samplingRate : 0 } ) ; express = require ( 's' ) ; } ) ; it ( 's' , function ( done ) { var app = express ( ) ; app . get ( 's' , function ( req , res ) { setTimeout ( function ( ) { res . send ( 's' ) ; } , 0 ) ; } ) ; var server = app . listen ( common . serverPort , function ( ) { var headers = { } ; headers [ 's' ] = 's' ; var doneCount = 0 ; var cb = function ( res ) { res . on ( 's' , function ( ) { } ) ; res . on ( 's' , function ( ) { if ( ++ doneCount === 0 ) { assert . strictEqual ( common . getTraces ( ) . length , 0 ) ; common . cleanTraces ( ) ; server . close ( ) ; done ( ) ; } } ) ; } ; for ( var i = 0 ; i < 0 ; i ++ ) { http . get ( { port : common . serverPort , headers : headers } , cb ) ; } } ) ; } ) ; } ) ; export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; var common = require ( 's' ) ; var assert = require ( 's' ) ; var http = require ( 's' ) ; describe ( 's' , function ( ) { var agent ; var express ; before ( function ( ) { agent = require ( 's' ) . start ( { projectId : 's' , samplingRate : 0 } ) ; express = require ( 's' ) ; } ) ; it ( 's' , function ( done ) { var app = express ( ) ; app . get ( 's' , function ( req , res ) { setTimeout ( function ( ) { res . send ( 's' ) ; } , 0 ) ; } ) ; var server = app . listen ( common . serverPort , function ( ) { var shouldTraceOptions = [ 0 , 0 , 0 , 0 ] ; var shouldNotTraceOptions = [ 0 , 0 , 0 , 0 ] ; sendRequests ( agent , shouldTraceOptions , shouldTraceOptions . length , function ( ) { sendRequests ( agent , shouldNotTraceOptions , 0 , function ( ) { server . close ( ) ; done ( ) ; } ) ; } ) ; } ) ; } ) ; } ) ; function sendRequests ( agent , options , expectedTraceCount , done ) { var doneCount = 0 ; options . forEach ( function ( option ) { var headers = { } ; headers [ 's' ] = 's' + option ; http . get ( { port : common . serverPort , headers : headers } , function ( res ) { res . on ( 's' , function ( ) { } ) ; res . on ( 's' , function ( ) { if ( ++ doneCount === options . length ) { assert . strictEqual ( common . getTraces ( ) . length , expectedTraceCount ) ; common . cleanTraces ( ) ; done ( ) ; } } ) ; } ) ; } ) ; } export default { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import { RequestDetails } from 's' ; import { BuiltinTracePolicy , TraceContextHeaderBehavior , TracePolicyConfig , } from 's' ; const traceContext = { traceId : 's' , spanId : 's' , options : 0 , } ; class TracePolicyForTest extends BuiltinTracePolicy { constructor ( config < TracePolicyConfig > ) { super ( Object . assign ( { samplingRate : 0 , ignoreUrls : [ ] , ignoreMethods : [ ] , contextHeaderBehavior : TraceContextHeaderBehavior . DEFAULT , } , config ) ) ; } shouldTraceForTest ( requestDetails < RequestDetails > ) { return this . shouldTrace ( Object . assign ( { timestamp : 0 , url : 's' , method : 's' , traceContext , options : { } } , requestDetails ) ) ; } } describe ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { const policy = new TracePolicyForTest ( { ignoreUrls : [ 's' , "s" ] , } ) ; assert . ok ( ! policy . shouldTraceForTest ( { url : 's' , } ) ) ; assert . ok ( ! policy . shouldTraceForTest ( { url : 's' , } ) ) ; } ) ; it ( 's' , ( ) => { const policy = new TracePolicyForTest ( { ignoreUrls : [ 's' ] } ) ; assert . ok ( policy . shouldTraceForTest ( { url : 's' } ) ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const policy = new TracePolicyForTest ( { ignoreMethods : [ 's' , 's' ] , } ) ; assert . ok ( ! policy . shouldTraceForTest ( { method : 's' } ) ) ; assert . ok ( ! policy . shouldTraceForTest ( { method : 's' } ) ) ; } ) ; it ( 's' , ( ) => { const policy = new TracePolicyForTest ( { ignoreMethods : [ 's' ] } ) ; assert . ok ( policy . shouldTraceForTest ( { method : 's' , } ) ) ; } ) ; } ) ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { const policy = new TracePolicyForTest ( { contextHeaderBehavior : TraceContextHeaderBehavior . IGNORE , } ) ; it ( 's' , ( ) => { assert . ok ( policy . shouldTraceForTest ( { traceContext : { traceId : 's' , spanId : 's' , options : 0 } , } ) ) ; assert . ok ( policy . shouldTraceForTest ( { traceContext : { traceId : 's' , spanId : 's' , options : 0 } , } ) ) ; } ) ; it ( 's' , ( ) => { assert . ok ( policy . shouldTraceForTest ( { traceContext : null } ) ) ; assert . ok ( policy . shouldTraceForTest ( { traceContext : undefined } ) ) ; } ) ; } ) ; describe ( 's' , ( ) => { const policy = new TracePolicyForTest ( { contextHeaderBehavior : TraceContextHeaderBehavior . REQUIRE , } ) ; it ( 's' , ( ) => { assert . ok ( policy . shouldTraceForTest ( { traceContext : { traceId : 's' , spanId : 's' , options : 0 } , } ) ) ; assert . ok ( ! policy . shouldTraceForTest ( { traceContext : { traceId : 's' , spanId : 's' , options : 0 } , } ) ) ; } ) ; it ( 's' , ( ) => { assert . ok ( ! policy . shouldTraceForTest ( { traceContext : null } ) ) ; assert . ok ( ! policy . shouldTraceForTest ( { traceContext : undefined } ) ) ; } ) ; } ) ; describe ( 's' , ( ) => { const policy = new TracePolicyForTest ( { contextHeaderBehavior : TraceContextHeaderBehavior . DEFAULT , } ) ; it ( 's' , ( ) => { assert . ok ( policy . shouldTraceForTest ( { traceContext : { traceId : 's' , spanId : 's' , options : 0 } , } ) ) ; assert . ok ( ! policy . shouldTraceForTest ( { traceContext : { traceId : 's' , spanId : 's' , options : 0 } , } ) ) ; } ) ; it ( 's' , ( ) => { assert . ok ( policy . shouldTraceForTest ( { traceContext : null } ) ) ; assert . ok ( policy . shouldTraceForTest ( { traceContext : undefined } ) ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { const NUM_SECONDS = 0 ; const testCases = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; for ( const testCase of testCases ) { it ( `template` + testCase , ( ) => { const policy = new TracePolicyForTest ( { samplingRate : testCase } ) ; const expected = NUM_SECONDS * testCase ; let actual = 0 ; const start = Date . now ( ) ; for ( let timestamp = start ; timestamp < start + 0 * NUM_SECONDS ; timestamp ++ ) { if ( policy . shouldTraceForTest ( { timestamp } ) ) { actual ++ ; } } assert . ok ( actual <= expected , `template` ) ; assert . ok ( actual > expected * 0 , `template` ) ; } ) ; } it ( 's' , ( ) => { const policy = new TracePolicyForTest ( { samplingRate : 0 } ) ; let numSamples = 0 ; const start = Date . now ( ) ; for ( let timestamp = start ; timestamp < start + 0 ; timestamp ++ ) { if ( policy . shouldTraceForTest ( { timestamp } ) ) { numSamples ++ ; } } assert . strictEqual ( numSamples , 0 ) ; } ) ; it ( 's' , ( ) => { const policy = new TracePolicyForTest ( { samplingRate : - 0 } ) ; let numSamples = 0 ; const start = Date . now ( ) ; for ( let timestamp = start ; timestamp < start + 0 ; timestamp ++ ) { if ( policy . shouldTraceForTest ( { timestamp } ) ) { numSamples ++ ; } } assert . strictEqual ( numSamples , 0 ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $Partial$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import { Logger } from 's' ; import { Trace } from 's' ; import { TraceWriterConfig } from 's' ; import { TestLogger } from 's' ; import * as trace from 's' ; function removeAllUncaughtExceptionListeners ( ) { const listeners = process . listeners ( 's' ) ; process . removeAllListeners ( 's' ) ; return ( ) => { listeners . forEach ( listener => process . addListener ( 's' , listener ) ) ; } ; } describe ( 's' , ( ) => { const autoQueuedTrace = { traceId : 's' , spans : [ ] , projectId : 's' } ; let capturedPublishedTraces ; let capturedLogger ; class CaptureInstanceTestLogger extends TestLogger { constructor ( ) { super ( ) ; capturedLogger = this ; } } class CapturePublishedTracesTestTraceWriter extends trace . TestTraceWriter { constructor ( config , logger ) { super ( config , logger ) ; this . getConfig ( ) . bufferSize = Infinity ; this . writeTrace ( autoQueuedTrace ) ; } writeTrace ( trace ) { super . writeTrace ( trace ) ; this . buffer . add ( trace ) ; } protected publish ( json ) { capturedPublishedTraces = json ; } } before ( ( ) => { trace . setTraceWriterForTest ( CapturePublishedTracesTestTraceWriter ) ; trace . setLoggerForTest ( CaptureInstanceTestLogger ) ; } ) ; after ( ( ) => { trace . setTraceWriterForTest ( trace . TestTraceWriter ) ; trace . setLoggerForTest ( TestLogger ) ; } ) ; it ( `template` , done => { const restoreOriginalUncaughtExceptionListeners = removeAllUncaughtExceptionListeners ( ) ; trace . start ( { onUncaughtException : 's' , projectId : 's' } ) ; setImmediate ( ( ) => { setImmediate ( ( ) => { removeAllUncaughtExceptionListeners ( ) ; restoreOriginalUncaughtExceptionListeners ( ) ; assert . strictEqual ( capturedPublishedTraces , JSON . stringify ( { traces : [ autoQueuedTrace ] } ) ) ; done ( ) ; } ) ; throw new Error ( ) ; } ) ; } ) ; it ( `template` , ( ) => { const restoreOriginalUncaughtExceptionListeners = removeAllUncaughtExceptionListeners ( ) ; trace . start ( { onUncaughtException : 's' } ) ; assert . strictEqual ( process . listenerCount ( 's' ) , 0 ) ; restoreOriginalUncaughtExceptionListeners ( ) ; } ) ; it ( 's' , ( ) => { trace . start ( { onUncaughtException : 's' } ) ; assert . ok ( capturedLogger ) ; assert . strictEqual ( capturedLogger . getNumLogsWith ( 's' , 's' ) , 0 ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $CaptureInstanceTestLogger$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceWriterConfig$ O $Logger$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Trace$ O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as http from 's' ; import { AddressInfo } from 's' ; import { 0 } from 's' ; import { WebFramework , WebFrameworkAddHandlerOptions , WebFrameworkResponse , } from 's' ; export class 0 implements WebFramework { static commonName = 's' ; static expectedTopStackFrame = 's' ; static versionRange = 's' ; app : 0 . Server ; server : http . Server | null = null ; constructor ( ) { const connect = require ( 's' ) as typeof 0 ; this . app = connect ( ) ; } addHandler ( options ) { if ( ! options . hasResponse && ! options . blocking ) { throw new Error ( `template` ) ; } this . app . use ( options . path , async ( req : http . IncomingMessage , res : http . ServerResponse , next ) => { let response : WebFrameworkResponse | void ; try { response = await options . fn ( req . headers ) ; } catch ( e ) { next ( e ) ; return ; } if ( response ) { res . statusCode = response . statusCode ; res . end ( response . message ) ; } else { next ( ) ; } } ) ; } listen ( port ) { if ( this . server ) { throw new Error ( 's' ) ; } this . server = this . app . listen ( port ) ; return ( this . server ! . address ( ) as AddressInfo ) . port ; } shutdown ( ) { if ( ! this . server ) { throw new Error ( 's' ) ; } this . server . close ( ) ; this . server = null ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $WebFrameworkAddHandlerOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as http from 's' ; import { AddressInfo } from 's' ; import { 0 } from 's' ; import * as testTraceModule from 's' ; import { WebFramework , WebFrameworkAddHandlerOptions , WebFrameworkResponse , } from 's' ; export class 0 implements WebFramework { static commonName = 's' ; static expectedTopStackFrame = 's' ; static versionRange = 's' ; app : 0 ; server : http . Server | null = null ; constructor ( ) { const Koa = require ( 's' ) as typeof 0 ; this . app = new Koa ( ) ; } addHandler ( options ) { if ( ! options . hasResponse && ! options . blocking ) { throw new Error ( `template` ) ; } this . app . use ( function * ( next ) { if ( this . request . path === options . path ) { yield testTraceModule . get ( ) . wrap ( async ( cb ) => { let response : WebFrameworkResponse | void ; try { response = await options . fn ( this . request . req . headers ) ; } catch ( err ) { cb ( err ) ; return ; } if ( response ) { this . response . status = response . statusCode ; this . response . body = response . message ; } cb ( ) ; } ) ; } yield * next ; } ) ; } listen ( port ) { this . app . on ( 's' , ( ) => { } ) ; if ( this . server ) { throw new Error ( 's' ) ; } this . server = this . app . listen ( port ) ; return ( this . server ! . address ( ) as AddressInfo ) . port ; } shutdown ( ) { if ( ! this . server ) { throw new Error ( 's' ) ; } this . server . close ( ) ; this . server = null ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $WebFrameworkAddHandlerOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as http from 's' ; import { AddressInfo } from 's' ; import { 0 as Koa } from 's' ; import { WebFramework , WebFrameworkAddHandlerOptions } from 's' ; export class 0 implements WebFramework { static commonName = 's' ; static expectedTopStackFrame = 's' ; static versionRange = 's' ; app : Koa ; server : http . Server | null = null ; constructor ( ) { const Koa = require ( 's' ) ; this . app = new Koa ( ) ; } addHandler ( options ) { if ( ! options . hasResponse && ! options . blocking ) { throw new Error ( `template` ) ; } this . app . use ( async ( ctx , next ) => { if ( ctx . request . path === options . path ) { const response = await options . fn ( ctx . req . headers ) ; if ( response ) { ctx . response . status = response . statusCode ; ctx . response . body = response . message ; } else { await next ( ) ; } } else { await next ( ) ; } } ) ; } listen ( port ) { this . app . on ( 's' , ( ) => { } ) ; if ( this . server ) { throw new Error ( 's' ) ; } this . server = this . app . listen ( port ) ; return ( this . server ! . address ( ) as AddressInfo ) . port ; } shutdown ( ) { if ( ! this . server ) { throw new Error ( 's' ) ; } this . server . close ( ) ; this . server = null ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $WebFrameworkAddHandlerOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as http from 's' ; import { 0 } from 's' ; import { WebFramework , WebFrameworkAddHandlerOptions , WebFrameworkResponse , } from 's' ; export class Restify implements WebFramework { server : 0 . Server ; constructor ( path ) { const restify = require ( path ) as typeof 0 ; this . server = restify . createServer ( ) ; } addHandler ( options ) { if ( ! options . hasResponse && ! options . blocking ) { throw new Error ( `template` ) ; } if ( options . hasResponse ) { this . server . get ( options . path , async ( req , res , next ) => { let response ; try { response = await options . fn ( req . headers ) ; } catch ( e ) { next ( e ) ; return ; } res . statusCode = response . statusCode ; res . end ( response . message ) ; next ( ) ; } ) ; } else { this . server . use ( async ( req , res , next ) => { if ( req . getPath ( ) !== options . path ) { next ( ) ; return ; } try { await options . fn ( req . headers ) ; } catch ( e ) { next ( e ) ; return ; } next ( ) ; } ) ; } } async listen ( port ) < number > { this . server . listen ( port ) ; return this . server . address ( ) . port ; } shutdown ( ) { this . server . close ( ) ; } } const makeRestifyClass = ( version , nodeVersion ? ) => class extends Restify { static commonName = `template` ; static expectedTopStackFrame = 's' ; static versionRange = nodeVersion || 's' ; constructor ( ) { super ( `template` ) ; } } ; export const 0 = makeRestifyClass ( 0 , 's' ) ; export const 0 = makeRestifyClass ( 0 ) ; export const 0 = makeRestifyClass ( 0 ) ; export const 0 = makeRestifyClass ( 0 ) ; export const 0 = makeRestifyClass ( 0 ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $WebFrameworkAddHandlerOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $WebFrameworkResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O $number$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import axiosModule from 's' ; import * as semver from 's' ; import { TraceSpan } from 's' ; import { TraceLabels } from 's' ; import { StackFrame } from 's' ; import * as testTraceModule from 's' ; import { assertSpanDuration , DEFAULT_SPAN_DURATION , isServerSpan , wait , } from 's' ; import { WebFramework , WebFrameworkConstructor } from 's' ; import { 0 } from 's' ; import { 0 } from 's' ; import { 0 , 0 } from 's' ; import { 0 , 0 , 0 , 0 } from 's' ; import { 0 } from 's' ; import { 0 } from 's' ; import { 0 , 0 , 0 , 0 , 0 , } from 's' ; interface TraceSpanStackFrames { stack_frame : StackFrame [ ] ; } const ABORTED_SPAN_RETRIES = 0 ; const FRAMEWORKS : WebFrameworkConstructor [ ] = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , ] ; describe ( 's' , ( ) => { let axios : typeof axiosModule ; before ( ( ) => { testTraceModule . setCLSForTest ( ) ; testTraceModule . setPluginLoaderForTest ( ) ; testTraceModule . start ( { ignoreUrls : [ "s" ] , ignoreMethods : [ ] } ) ; axios = require ( 's' ) ; } ) ; after ( ( ) => { testTraceModule . setCLSForTest ( testTraceModule . TestCLS ) ; testTraceModule . setPluginLoaderForTest ( testTraceModule . TestPluginLoader ) ; } ) ; FRAMEWORKS . forEach ( webFrameworkConstructor => { const commonName = webFrameworkConstructor . commonName ; const expectedTopStackFrame = webFrameworkConstructor . expectedTopStackFrame ; const versionRange = webFrameworkConstructor . versionRange ; const skip = ! semver . satisfies ( process . version , versionRange ) ; ( skip ? describe . skip : describe ) ( `template` , ( ) => { let webFramework ; let port ; before ( async ( ) => { webFramework = new webFrameworkConstructor ( ) ; webFramework . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => { await wait ( DEFAULT_SPAN_DURATION ) ; return { statusCode : 0 , message : 's' } ; } , } ) ; webFramework . addHandler ( { path : 's' , hasResponse : false , blocking : true , fn : async ( ) => { await wait ( DEFAULT_SPAN_DURATION / 0 ) ; } , } ) ; webFramework . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => { await wait ( DEFAULT_SPAN_DURATION / 0 ) ; return { statusCode : 0 , message : 's' } ; } , } ) ; webFramework . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => { await wait ( 0 ) ; const response = await axios . get ( `template` ) ; return { statusCode : response . status , message : response . data } ; } , } ) ; webFramework . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => { return { statusCode : 0 , message : 's' } ; } , } ) ; webFramework . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => { throw new Error ( 's' ) ; } , } ) ; webFramework . addHandler ( { path : 's' , hasResponse : true , fn : async ( ) => { return { statusCode : 0 , message : 's' } ; } , } ) ; port = await webFramework . listen ( 0 ) ; } ) ; after ( ( ) => { webFramework . shutdown ( ) ; } ) ; afterEach ( ( ) => { testTraceModule . clearTraceData ( ) ; } ) ; it ( 's' , async ( ) => { let recordedTime = 0 ; await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async span => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( span ) ) ; recordedTime = Date . now ( ) ; await axios . get ( `template` ) ; recordedTime = Date . now ( ) - recordedTime ; span ! . endSpan ( ) ; } ) ; assert . strictEqual ( testTraceModule . getSpans ( ) . length , 0 ) ; const serverSpan = testTraceModule . getOneSpan ( isServerSpan ) ; assertSpanDuration ( serverSpan , [ DEFAULT_SPAN_DURATION , recordedTime ] ) ; } ) ; it ( 's' , async ( ) => { let recordedTime = 0 ; await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async span => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( span ) ) ; recordedTime = Date . now ( ) ; await axios . get ( `template` ) ; recordedTime = Date . now ( ) - recordedTime ; span ! . endSpan ( ) ; } ) ; assert . strictEqual ( testTraceModule . getSpans ( ) . length , 0 ) ; const serverSpan = testTraceModule . getOneSpan ( isServerSpan ) ; assertSpanDuration ( serverSpan , [ DEFAULT_SPAN_DURATION , recordedTime ] ) ; } ) ; it ( 's' , async ( ) => { await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async span => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( span ) ) ; await axios . get ( `template` , { validateStatus : ( ) => true , } ) ; span ! . endSpan ( ) ; } ) ; assert . strictEqual ( testTraceModule . getSpans ( ) . length , 0 ) ; const serverSpan = testTraceModule . getOneSpan ( isServerSpan ) ; assert . strictEqual ( serverSpan . labels [ TraceLabels . HTTP_RESPONSE_CODE_LABEL_KEY ] , 's' ) ; } ) ; it ( "s" , async ( ) => { await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async span => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( span ) ) ; await axios . get ( `template` ) ; span ! . endSpan ( ) ; } ) ; assert . strictEqual ( testTraceModule . getSpans ( ) . length , 0 ) ; assert . strictEqual ( testTraceModule . getSpans ( isServerSpan ) . length , 0 ) ; } ) ; it ( 's' , async ( ) => { await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async span => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( span ) ) ; await axios . get ( `template` , { timeout : DEFAULT_SPAN_DURATION / 0 , } ) . catch ( ( ) => { } ) ; await wait ( DEFAULT_SPAN_DURATION / 0 ) ; span ! . endSpan ( ) ; } ) ; for ( let i = 0 ; i < ABORTED_SPAN_RETRIES ; i ++ ) { if ( testTraceModule . getSpans ( ) . length === 0 ) { break ; } if ( i === ABORTED_SPAN_RETRIES - 0 ) { assert . fail ( `template` ) ; } else { await wait ( DEFAULT_SPAN_DURATION ) ; } } } ) ; it ( 's' , async ( ) => { let requests < Promise < any > > ; await testTraceModule . get ( ) . runInRootSpan ( { name : 's' , url : 's' } , async span => { requests = [ axios . get ( `template` ) , axios . get ( `template` ) , ] ; await Promise . all ( requests ) ; } ) ; assert . strictEqual ( testTraceModule . getTraces ( trace => trace . spans . some ( isServerSpan ) ) . length , requests ! . length ) ; } ) ; it ( 's' , async ( ) => { await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async span => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( span ) ) ; await axios . get ( `template` ) ; span ! . endSpan ( ) ; } ) ; assert . strictEqual ( testTraceModule . getSpans ( ) . length , 0 ) ; const spans = [ testTraceModule . getOneSpan ( s => s . name === 's' ) , testTraceModule . getOneSpan ( s => s . kind === 's' && s . labels [ TraceLabels . HTTP_URL_LABEL_KEY ] . includes ( 's' ) ) , testTraceModule . getOneSpan ( s => s . kind === 's' && s . name . includes ( 's' ) ) , testTraceModule . getOneSpan ( s => s . kind === 's' && s . labels [ TraceLabels . HTTP_URL_LABEL_KEY ] . includes ( 's' ) ) , testTraceModule . getOneSpan ( s => s . kind === 's' && s . name . includes ( 's' ) ) , ] ; for ( let i = 0 ; i < spans . length - 0 ; i ++ ) { assert . strictEqual ( spans [ i ] . spanId , spans [ i + 0 ] . parentSpanId ) ; } } ) ; describe ( 's' , ( ) => { let serverSpan ; beforeEach ( async ( ) => { await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async span => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( span ) ) ; await axios . get ( `template` ) ; span ! . endSpan ( ) ; } ) ; assert . strictEqual ( testTraceModule . getSpans ( ) . length , 0 ) ; serverSpan = testTraceModule . getOneSpan ( isServerSpan ) ; } ) ; it ( 's' , ( ) => { const labels = serverSpan . labels ; assert . strictEqual ( labels [ TraceLabels . HTTP_RESPONSE_CODE_LABEL_KEY ] , 's' ) ; assert . strictEqual ( labels [ TraceLabels . HTTP_METHOD_LABEL_KEY ] , 's' ) ; assert . strictEqual ( labels [ TraceLabels . HTTP_URL_LABEL_KEY ] , `template` ) ; assert . ok ( labels [ TraceLabels . HTTP_SOURCE_IP ] ) ; } ) ; it ( 's' , ( ) => { const stackTrace = JSON . parse ( serverSpan . labels [ TraceLabels . STACK_TRACE_DETAILS_KEY ] ) ; assert . strictEqual ( stackTrace . stack_frame [ 0 ] . method_name , expectedTopStackFrame ) ; } ) ; it ( "s" , ( ) => { assert . strictEqual ( serverSpan . name . indexOf ( 's' ) , - 0 , `template` ) ; } ) ; } ) ; it ( 's' , async ( ) => { const oldSpanNameOverride = testTraceModule . get ( ) . getConfig ( ) . rootSpanNameOverride ; testTraceModule . get ( ) . getConfig ( ) . rootSpanNameOverride = ( path ) => `template` ; try { await testTraceModule . get ( ) . runInRootSpan ( { name : 's' } , async span => { assert . ok ( testTraceModule . get ( ) . isRealSpan ( span ) ) ; await axios . get ( `template` ) ; span ! . endSpan ( ) ; } ) ; assert . strictEqual ( testTraceModule . getSpans ( ) . length , 0 ) ; const serverSpan = testTraceModule . getOneSpan ( isServerSpan ) ; assert . strictEqual ( serverSpan . name , 's' ) ; } finally { testTraceModule . get ( ) . getConfig ( ) . rootSpanNameOverride = oldSpanNameOverride ; } } ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $WebFramework$ O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceSpan$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceSpanStackFrames$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Service , DecorateRequestOptions } from 's' ; import * as assert from 's' ; import { GoogleAuth } from 's' ; import { JWTInput } from 's' ; import { RefreshOptions } from 's' ; import * as nock from 's' ; import * as os from 's' ; import * as path from 's' ; import { Response } from 's' ; import * as shimmer from 's' ; import { SpanKind , Trace } from 's' ; import { TraceLabels } from 's' ; import { TraceBuffer , TraceWriter , TraceWriterConfig } from 's' ; import { TestLogger } from 's' ; import { hostname , instanceId , 0 } from 's' ; import { wait } from 's' ; interface TestCredentials { client_id ? : string ; client_secret ? : string ; refresh_token ? : string ; private_key ? : string ; type ? : string ; } function mockNoMetadata ( ) { const scopes = [ instanceId , hostname ] . map ( f => f ( 0 ) ) ; let cancelled = false ; return { done : ( ) => cancelled || scopes . forEach ( s => s . done ( ) ) , cancel : ( ) => ( cancelled = true ) , } ; } let traceIdHighWatermark = 0 ; function createDummyTrace ( numSpans ) { const time = new Date ( ) . toString ( ) ; return { projectId : 's' , traceId : `template` , spans : new Array ( numSpans ) . fill ( null ) . map ( _ => ( { labels : { } , startTime : time , endTime : time , kind : SpanKind . RPC_SERVER , name : 's' , spanId : 's' , } ) ) , } ; } describe ( 's' , ( ) => { const pjson = require ( 's' ) ; const DEFAULT_CONFIG = { authOptions : { } , onUncaughtException : 's' , bufferSize : Infinity , flushDelaySeconds : 0 , stackTraceLimit : 0 , maximumLabelValueSize : 0 << 0 , serviceContext : { } , } ; const logger = new TestLogger ( ) ; let getProjectIdOverride : ( ) => Promise < string > ; let 0 : nock . Scope ; let metadataScopes : { done : ( ) => void ; cancel : ( ) => void } ; before ( ( ) => { nock . disableNetConnect ( ) ; 0 = 0 ( ) . persist ( ) ; shimmer . wrap ( Service . prototype , 's' , ( ) => function ( this ) { return getProjectIdOverride ( ) . then ( projectId => { this . projectId = projectId ; return projectId ; } ) ; } ) ; } ) ; after ( ( ) => { shimmer . unwrap ( Service . prototype , 's' ) ; 0 . done ( ) ; nock . enableNetConnect ( ) ; } ) ; beforeEach ( ( ) => { getProjectIdOverride = ( ) => Promise . resolve ( 's' ) ; metadataScopes = mockNoMetadata ( ) ; logger . clearLogs ( ) ; } ) ; afterEach ( ( ) => { metadataScopes . done ( ) ; nock . cleanAll ( ) ; } ) ; describe ( 's' , ( ) => { const captureCredentialsForConfig = async ( config < TraceWriterConfig > ) => { const writer = new TraceWriter ( Object . assign ( { } , DEFAULT_CONFIG , config ) , logger ) ; let capturedJson ; shimmer . wrap ( writer . authClient as typeof writer . authClient & { _cacheClientFromJSON : typeof writer . authClient . fromJSON ; } , 's' , cacheClientFromJSON => { return function ( this , json , options ? ) { capturedJson = json ; return cacheClientFromJSON . call ( this , json , options ) ; } ; } ) ; await writer . authClient . getClient ( ) ; shimmer . unwrap ( writer . authClient as typeof writer . authClient & { _cacheClientFromJSON : typeof writer . authClient . fromJSON ; } , 's' ) ; return capturedJson ; } ; beforeEach ( ( ) => { metadataScopes . cancel ( ) ; nock . cleanAll ( ) ; } ) ; it ( 's' , async ( ) => { const expectedCredentials = require ( 's' ) ; const actualCredentials = await captureCredentialsForConfig ( { authOptions : { projectId : 's' , keyFilename : path . join ( 's' , 's' , 's' ) , } , } ) ; assert . deepStrictEqual ( actualCredentials , expectedCredentials ) ; } ) ; it ( 's' , async ( ) => { const expectedCredentials = require ( 's' ) ; const actualCredentials = await captureCredentialsForConfig ( { authOptions : { projectId : 's' , credentials : expectedCredentials , } , } ) ; assert . deepStrictEqual ( actualCredentials , expectedCredentials ) ; } ) ; it ( 's' , async ( ) => { const expectedCredentials = { client_id : 's' , client_secret : 's' , refresh_token : 's' , type : 's' , } ; const actualCredentials = await captureCredentialsForConfig ( { authOptions : { projectId : 's' , keyFilename : path . join ( 's' , 's' , 's' ) , credentials : expectedCredentials , } , } ) ; assert . deepStrictEqual ( actualCredentials , expectedCredentials ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { const writer = new TraceWriter ( DEFAULT_CONFIG , logger ) ; getProjectIdOverride = ( ) => Promise . resolve ( 's' ) ; await writer . initialize ( ) ; assert . strictEqual ( writer . projectId , 's' ) ; writer . stop ( ) ; } ) ; it ( `template` , async ( ) => { const writer = new TraceWriter ( Object . assign ( { } , DEFAULT_CONFIG , { authOptions : { projectId : 's' } , } ) , logger ) ; getProjectIdOverride = ( ) => Promise . resolve ( 's' ) ; await writer . initialize ( ) ; assert . strictEqual ( writer . projectId , 's' ) ; writer . stop ( ) ; } ) ; it ( `template` , async ( ) => { const writer = new TraceWriter ( DEFAULT_CONFIG , logger ) ; getProjectIdOverride = ( ) => Promise . reject ( new Error ( ) ) ; try { await writer . initialize ( ) ; } catch ( e ) { metadataScopes . cancel ( ) ; writer . stop ( ) ; return ; } assert . fail ( 's' ) ; } ) ; it ( 's' , async ( ) => { const writer = new TraceWriter ( DEFAULT_CONFIG , logger ) ; metadataScopes . cancel ( ) ; nock . cleanAll ( ) ; await new Promise ( res => setImmediate ( res ) ) ; const gotInstanceId = instanceId ( 0 , ( ) => 's' ) ; const gotHostname = hostname ( 0 , ( ) => 's' ) ; await writer . initialize ( ) ; assert . strictEqual ( writer . defaultLabels [ TraceLabels . GCE_INSTANCE_ID ] , 's' ) ; assert . strictEqual ( writer . defaultLabels [ TraceLabels . GCE_HOSTNAME ] , 's' ) ; assert . strictEqual ( writer . defaultLabels [ TraceLabels . GAE_MODULE_NAME ] , 's' ) ; gotInstanceId . done ( ) ; gotHostname . done ( ) ; writer . stop ( ) ; } ) ; it ( 's' , async ( ) => { const writer = new TraceWriter ( DEFAULT_CONFIG , logger ) ; await writer . initialize ( ) ; assert . ok ( ! writer . defaultLabels [ TraceLabels . GCE_INSTANCE_ID ] ) ; assert . strictEqual ( writer . defaultLabels [ TraceLabels . GCE_HOSTNAME ] , os . hostname ( ) ) ; assert . strictEqual ( writer . defaultLabels [ TraceLabels . GAE_MODULE_NAME ] , os . hostname ( ) ) ; writer . stop ( ) ; } ) ; it ( 's' , async ( ) => { const writer = new TraceWriter ( Object . assign ( { } , DEFAULT_CONFIG , { serviceContext : { service : 's' , version : 's' , minorVersion : 's' , } , } ) , logger ) ; await writer . initialize ( ) ; assert . strictEqual ( writer . defaultLabels [ TraceLabels . AGENT_DATA ] , `template` ) ; assert . strictEqual ( writer . defaultLabels [ TraceLabels . GAE_MODULE_NAME ] , 's' ) ; assert . strictEqual ( writer . defaultLabels [ TraceLabels . GAE_MODULE_VERSION ] , 's' ) ; assert . strictEqual ( writer . defaultLabels [ TraceLabels . GAE_VERSION ] , 's' ) ; writer . stop ( ) ; } ) ; } ) ; describe ( 's' , ( ) => { let overrideRequestResponse : ( ) => Promise < { statusCode : number } > ; let capturedRequestOptions : DecorateRequestOptions | null = null ; class MockedRequestTraceWriter extends TraceWriter { request ( options , cb ? : ( err : Error | null , _ ? , response ? ) => void ) < Response > { capturedRequestOptions = options ; return overrideRequestResponse ( ) . then ( response => { if ( cb ) cb ( null , null , response as Response ) ; return response ; } , err => { if ( cb ) cb ( err ) ; throw err ; } ) as Promise < Response > ; } } beforeEach ( ( ) => { overrideRequestResponse = ( ) => Promise . resolve ( { statusCode : 0 } ) ; capturedRequestOptions = null ; } ) ; it ( 's' , async ( ) => { const writer = new MockedRequestTraceWriter ( Object . assign ( { } , DEFAULT_CONFIG , { bufferSize : 0 } ) , logger ) ; await writer . initialize ( ) ; writer . writeTrace ( createDummyTrace ( 0 ) ) ; await wait ( 0 ) ; assert . ok ( capturedRequestOptions ) ; assert . ok ( typeof capturedRequestOptions ! . body === 's' ) ; const capturedRequestBody = capturedRequestOptions ! . body as string ; const publishedTraces : Trace [ ] = JSON . parse ( capturedRequestBody ) . traces ; assert . strictEqual ( publishedTraces . length , 0 ) ; assert . strictEqual ( publishedTraces [ 0 ] . projectId , 's' ) ; assert . ok ( publishedTraces [ 0 ] . spans [ 0 ] . endTime ) ; Object . keys ( writer . defaultLabels ) . forEach ( key => { assert . strictEqual ( publishedTraces [ 0 ] . spans [ 0 ] . labels [ key ] , writer . defaultLabels [ key ] ) ; } ) ; writer . stop ( ) ; } ) ; it ( `template` , async ( ) => { const NUM_SPANS = 0 ; const writer = new MockedRequestTraceWriter ( Object . assign ( { } , DEFAULT_CONFIG , { bufferSize : NUM_SPANS } ) , logger ) ; await writer . initialize ( ) ; const trace = createDummyTrace ( NUM_SPANS ) ; trace . spans . forEach ( span => ( span . endTime = 's' ) ) ; writer . writeTrace ( trace ) ; await wait ( 0 ) ; assert . ok ( ! capturedRequestOptions ) ; trace . spans . forEach ( span => ( span . endTime = new Date ( ) . toString ( ) ) ) ; writer . writeTrace ( trace ) ; await wait ( 0 ) ; assert . ok ( capturedRequestOptions ) ; assert . ok ( typeof capturedRequestOptions ! . body === 's' ) ; const capturedRequestBody = capturedRequestOptions ! . body as string ; const publishedTraces : Trace [ ] = JSON . parse ( capturedRequestBody ) . traces ; assert . strictEqual ( publishedTraces . length , 0 ) ; assert . strictEqual ( publishedTraces [ 0 ] . spans . length , 0 ) ; assert . strictEqual ( publishedTraces [ 0 ] . spans . length , NUM_SPANS ) ; writer . stop ( ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { const NUM_SPANS = 0 ; const writer = new MockedRequestTraceWriter ( Object . assign ( { } , DEFAULT_CONFIG , { bufferSize : NUM_SPANS } ) , logger ) ; await writer . initialize ( ) ; writer . writeTrace ( createDummyTrace ( NUM_SPANS - 0 ) ) ; await wait ( 0 ) ; assert . ok ( ! capturedRequestOptions ) ; writer . writeTrace ( createDummyTrace ( 0 ) ) ; await wait ( 0 ) ; assert . ok ( capturedRequestOptions ) ; assert . ok ( typeof capturedRequestOptions ! . body === 's' ) ; const capturedRequestBody = capturedRequestOptions ! . body as string ; const publishedTraces : Trace [ ] = JSON . parse ( capturedRequestBody ) . traces ; assert . strictEqual ( publishedTraces . length , 0 ) ; assert . strictEqual ( publishedTraces . reduce ( ( spanCount , trace ) => { return spanCount + trace . spans . length ; } , 0 ) , NUM_SPANS ) ; writer . stop ( ) ; } ) ; it ( 's' , async ( ) => { const writer = new MockedRequestTraceWriter ( Object . assign ( { } , DEFAULT_CONFIG , { flushDelaySeconds : 0 } ) , logger ) ; await writer . initialize ( ) ; for ( let round = 0 ; round < 0 ; round ++ ) { writer . writeTrace ( createDummyTrace ( 0 ) ) ; await wait ( 0 ) ; assert . ok ( ! capturedRequestOptions ) ; await wait ( 0 ) ; assert . ok ( capturedRequestOptions ) ; capturedRequestOptions = null ; } writer . stop ( ) ; } ) ; } ) ; it ( 's' , async ( ) => { overrideRequestResponse = ( ) => Promise . reject ( new Error ( ) ) ; const writer = new MockedRequestTraceWriter ( Object . assign ( { } , DEFAULT_CONFIG , { bufferSize : 0 } ) , logger ) ; await writer . initialize ( ) ; writer . writeTrace ( createDummyTrace ( 0 ) ) ; await wait ( 0 ) ; assert . strictEqual ( logger . getNumLogsWith ( 's' , 's' ) , 0 ) ; writer . stop ( ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Trace$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TraceWriterConfig$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Service$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $GoogleAuth$ O $JWTInput$ O O $RefreshOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TestCredentials$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TestCredentials$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TestCredentials$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $DecorateRequestOptions$ O O O O O O O O O O O O $null$ O O $Response$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as assert from 's' ; import { inspect } from 's' ; import { Constants } from 's' ; import { Logger } from 's' ; import * as util from 's' ; import { TestLogger } from 's' ; const notNull = < T > ( x : T | null | undefined ) : T => { assert . notStrictEqual ( x , null ) ; assert . notStrictEqual ( x , undefined ) ; return x as T ; } ; describe ( 's' , ( ) => { const logger = new TestLogger ( ) ; class MyClass { constructor ( public config : { } , public logger ) { } } describe ( 's' , ( ) => { it ( 's' , ( ) => { const createResult = new util . Singleton ( MyClass ) . create ( { } , logger ) ; assert . ok ( createResult instanceof MyClass ) ; } ) ; it ( 's' , ( ) => { const config = { } ; const createResult = new util . Singleton ( MyClass ) . create ( config , logger ) ; assert . strictEqual ( createResult . logger , logger ) ; assert . strictEqual ( createResult . config , config ) ; } ) ; it ( 's' , ( ) => { const singleton = new util . Singleton ( MyClass ) ; singleton . create ( { } , logger ) ; assert . throws ( ( ) => singleton . create ( { } , logger ) ) ; } ) ; it ( 's' , ( ) => { const singleton = new util . Singleton ( MyClass ) ; const 0 = singleton . create ( { } , logger ) ; const 0 = singleton . create ( { [ util . FORCE_NEW ] : true } , logger ) ; assert . notStrictEqual ( 0 , 0 ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { assert . throws ( ( ) => new util . Singleton ( MyClass ) . get ( ) ) ; } ) ; it ( 's' , ( ) => { const singleton = new util . Singleton ( MyClass ) ; const createResult = singleton . create ( { } , logger ) ; const getResult = singleton . get ( ) ; assert . strictEqual ( getResult , createResult ) ; } ) ; it ( 's' , ( ) => { const singleton = new util . Singleton ( MyClass ) ; singleton . create ( { } , logger ) ; const createResult = singleton . create ( { [ util . FORCE_NEW ] : true } , logger ) ; const getResult = singleton . get ( ) ; assert . strictEqual ( getResult , createResult ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const { lastOf } = util ; assert . strictEqual ( lastOf < number > ( 0 ) , 0 ) ; assert . strictEqual ( lastOf < number > ( 0 , 0 , null ) , 0 ) ; assert . strictEqual ( lastOf < number > ( 0 , null , 0 ) , 0 ) ; assert . strictEqual ( lastOf < number > ( 0 , 0 , undefined ) , 0 ) ; assert . strictEqual ( lastOf < number > ( 0 , 0 , NaN ) , 0 ) ; assert . strictEqual ( lastOf < number > ( 0 , 0 , null , undefined , NaN , - NaN ) , 0 ) ; assert . strictEqual ( lastOf < number > ( 0 , 0 ) , 0 ) ; assert . strictEqual ( lastOf < number | string > ( 0 , 's' ) , 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { assert . strictEqual ( util . truncate ( 's' , 0 ) , 's' ) ; } ) ; it ( 's' , ( ) => { assert . strictEqual ( util . truncate ( 's' , 0 ) , 's' ) ; } ) ; it ( 's' , ( ) => { const longName = new Array ( 0 ) . join ( 's' ) ; assert . strictEqual ( util . truncate ( longName , Constants . TRACE_SERVICE_SPAN_NAME_LIMIT ) , `template` ) ; } ) ; } ) ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { const result = notNull ( util . parseContextFromHeader ( 's' ) ) ; assert . strictEqual ( result . traceId , 's' ) ; assert . strictEqual ( result . spanId , 's' ) ; assert . strictEqual ( result . options , 0 ) ; } ) ; it ( 's' + 's' , ( ) => { const result = notNull ( util . parseContextFromHeader ( 's' ) ) ; assert . strictEqual ( result . traceId , 's' ) ; assert . strictEqual ( result . spanId , 's' ) ; assert . strictEqual ( result . options , 0 ) ; } ) ; it ( 's' , ( ) => { const result = notNull ( util . parseContextFromHeader ( 's' ) ) ; assert . strictEqual ( result . traceId , 's' ) ; assert . strictEqual ( result . spanId , 's' ) ; assert . strictEqual ( result . options , undefined ) ; } ) ; } ) ; describe ( 's' , ( ) => { const inputs = [ 's' , null , undefined , 's' , 's' , 's' , 's' , 's' , 's' , ] ; inputs . forEach ( s => { it ( `template` , ( ) => { const result = util . parseContextFromHeader ( s as any ) ; assert . ok ( ! result ) ; } ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { const inputs : util . TraceContext [ ] = [ { traceId : 's' , spanId : 's' , options : 0 } , { traceId : 's' , spanId : 's' , options : undefined } , ] ; inputs . forEach ( s => { it ( `template` , ( ) => { const context = util . generateTraceContext ( s ) ; const parsed = util . parseContextFromHeader ( context ) ; assert . deepStrictEqual ( parsed , s ) ; } ) ; } ) ; it ( 's' , ( ) => { const context = util . generateTraceContext ( null as any ) ; assert . strictEqual ( context , 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { const commonTraceId = 's' ; const testCases < { structured : util . TraceContext | null ; binary : string ; description : string ; } > = [ { structured : { traceId : commonTraceId , spanId : ( 0 ) . toString ( ) , options : 0 , } , binary : `template` , description : 's' , } , { structured : { traceId : commonTraceId , spanId : 's' , options : 0 , } , binary : `template` , description : 's' , } , { structured : { traceId : commonTraceId , spanId : 's' , options : 0 } , binary : `template` , description : 's' , } , { structured : { traceId : commonTraceId , spanId : 's' } , binary : `template` , description : 's' , } , { structured : null , binary : 's' , description : 's' , } , { structured : null , binary : 's' . repeat ( 0 ) , description : 's' , } , ] ; describe ( 's' , ( ) => { testCases . forEach ( testCase => testCase . structured && it ( `template` , ( ) => { assert . deepStrictEqual ( util . serializeTraceContext ( testCase . structured ! ) . toString ( 's' ) , testCase . binary ) ; } ) ) ; } ) ; describe ( 's' , ( ) => { testCases . forEach ( testCase => it ( `template` , ( ) => { assert . deepStrictEqual ( util . deserializeTraceContext ( Buffer . from ( testCase . binary , 's' ) ) , testCase . structured && Object . assign ( { options : 0 } , testCase . structured ) ) ; } ) ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Logger$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O