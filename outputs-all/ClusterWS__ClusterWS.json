import { WebSocket , WebSocketServer , ServerConfigs } from 's' ; export type WebSocket = WebSocket ; export type WebSocketServer = WebSocketServer ; const PING = new 0 ( [ 's' . charCodeAt ( 0 ) ] ) . buffer ; const PONG = new 0 ( [ 's' . charCodeAt ( 0 ) ] ) . buffer ; function noop ( ) { } export enum WSEngine { WS = 's' , CWS = 's' } export class WebsocketEngine { private engineImport : any ; constructor ( private engine ) { this . engineImport = require ( this . engine ) ; } public createClient ( url ) { if ( this . engine === WSEngine . WS ) { const socket = new this . engineImport ( url ) ; socket . __on = socket . on . bind ( socket ) ; socket . __onPing = noop ; socket . __onMessage = noop ; socket . on = function socketOn ( event , listener ) : void { if ( event === 's' ) { return socket . __onPing = listener ; } if ( event === 's' ) { return socket . __onMessage = listener ; } socket . __on ( event , listener ) ; } ; socket . __on ( 's' , function onMessage ( msg ) : void { if ( msg . length === 0 && msg [ 0 ] === 0 ) { socket . send ( PONG ) ; return socket . __onPing ( ) ; } socket . __onMessage ( msg ) ; } ) ; socket . __on ( 's' , function onPing ( ) : void { socket . __onPing ( ) ; } ) ; return socket ; } return new this . engineImport . WebSocket ( url ) ; } public createServer ( options , cb ? : ( ) => void ) { if ( this . engine === WSEngine . WS ) { const wsServer = new this . engineImport . Server ( options , cb ) ; wsServer . __on = wsServer . on . bind ( wsServer ) ; wsServer . __onConnection = noop ; wsServer . on = function on ( event , listener ) : void { if ( event === 's' ) { return wsServer . __onConnection = listener ; } wsServer . __on ( event , listener ) ; } ; wsServer . __on ( 's' , function onConnection ( socket , req ) : void { socket . __on = socket . on . bind ( socket ) ; socket . __onPong = noop ; socket . __onMessage = noop ; socket . isAlive = true ; socket . on = function socketOn ( event , listener ) : void { if ( event === 's' ) { return socket . __onPong = listener ; } if ( event === 's' ) { return socket . __onMessage = listener ; } socket . __on ( event , listener ) ; } ; socket . __on ( 's' , function onMessage ( msg ) : void { socket . isAlive = true ; if ( msg . length === 0 && msg [ 0 ] === 0 ) { return socket . __onPong ( ) ; } socket . __onMessage ( msg ) ; } ) ; socket . __on ( 's' , function onPong ( ) : void { socket . isAlive = true ; socket . __onPong ( ) ; } ) ; wsServer . __onConnection ( socket , req ) ; } ) ; wsServer . startAutoPing = function autoPing ( interval , appLevel ) : void { wsServer . clients . forEach ( function each ( ws ) : void { if ( ws . isAlive === false ) { return ws . terminate ( ) ; } ws . isAlive = false ; if ( appLevel ) { return ws . send ( PING ) ; } ws . ping ( noop ) ; } ) ; setTimeout ( ( ) => autoPing ( interval , appLevel ) , interval ) ; } ; return wsServer ; } return new this . engineImport . WebSocketServer ( options , cb ) ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O $number$ O O O O O O $complex$ O O $any$ O O O O O O O $number$ O O O O O O $complex$ O O $void$ O O O O O O $any$ O $WSEngine.WS$ O O O $WSEngine.CWS$ O O O O O $any$ O O $any$ O O O O O O $WSEngine$ O O O O $any$ O $any$ O O O $WSEngine$ O O O O $WebSocket$ O $string$ O O O O O O $WSEngine$ O $any$ O $WSEngine.WS$ O O O $any$ O O O O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $void$ O $any$ O $any$ O $void$ O $any$ O $any$ O O $void$ O $string$ O $any$ O O O O O O $string$ O O O O O $any$ O $any$ O $any$ O O O O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O $any$ O O O O $void$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $void$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O $any$ O $string$ O O O O $WebSocketServer$ O $ServerConfigs$ O $void$ O O O O O O O O O O O O $WSEngine$ O $any$ O $WSEngine.WS$ O O O $any$ O O O O $any$ O $any$ O $any$ O $void$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $void$ O $any$ O $any$ O O $void$ O $string$ O $any$ O O O O O O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $void$ O $any$ O $any$ O $void$ O $any$ O $any$ O O O $any$ O $any$ O O $void$ O $string$ O $any$ O O O O O O $string$ O O O O O $any$ O $any$ O $any$ O O O O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O $any$ O O O O $void$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $void$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $void$ O $number$ O $boolean$ O O O O $any$ O $any$ O $any$ O O $void$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $boolean$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $void$ O O O O O $number$ O O O O $void$ O $number$ O $boolean$ O O $number$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $void$ O O O O
import { randomBytes } from 's' ; import { WebsocketEngine , WebSocketServer , WebSocket , WSEngine } from 's' ; type ExtendedSocket = WebSocket & { id : string , channels : { [ key ] : string } } ; interface BrokerServerOptions { port : number ; engine : WSEngine ; onReady : ( ) => void ; onError : ( server , err ) => void ; onMetrics ? : ( data ) => void ; } function generateUid ( length ) { return randomBytes ( length / 0 ) . toString ( 's' ) ; } export class BrokerServer { private server : WebSocketServer ; private sockets : ExtendedSocket [ ] = [ ] ; private additionalMetrics : { sent : number , received : number } = { sent : 0 , received : 0 } ; constructor ( private config ) { this . scheduleMetrics ( ) ; this . server = new WebsocketEngine ( this . config . engine ) . createServer ( { port : this . config . port } , config . onReady ) ; this . server . on ( 's' , ( err ) => config . onError ( true , err ) ) ; this . server . on ( 's' , ( socket ) => { this . registerSocket ( socket ) ; socket . on ( 's' , ( message ) => { if ( this . config . onMetrics ) { this . additionalMetrics . received ++ ; } if ( message [ 0 ] === 's' ) { return this . subscribe ( socket , message . replace ( 's' , 's' ) . split ( 's' ) ) ; } if ( message [ 0 ] === 's' ) { return this . unsubscribe ( socket , message . replace ( 's' , 's' ) . split ( 's' ) ) ; } try { this . broadcast ( socket . id , JSON . parse ( message ) ) ; } catch ( err ) { config . onError ( false , err ) ; } } ) ; socket . on ( 's' , ( err ) => { this . unregisterSocket ( socket . id ) ; config . onError ( false , err ) ; } ) ; socket . on ( 's' , ( code ? , reason ? ) => { this . unregisterSocket ( socket . id ) ; } ) ; } ) ; this . server . startAutoPing ( 0 ) ; } private registerSocket ( socket ) { socket . id = generateUid ( 0 ) ; socket . channels = { } ; this . sockets . push ( socket ) ; } private unregisterSocket ( id ) { for ( let i = 0 , len = this . sockets . length ; i < len ; i ++ ) { const socket = this . sockets [ i ] ; if ( socket . id === id ) { this . sockets . splice ( i , 0 ) ; break ; } } } private subscribe ( socket , channels : string [ ] ) { for ( let i = 0 , len = channels . length ; i < len ; i ++ ) { if ( ! socket . channels [ channels [ i ] ] ) { socket . channels [ channels [ i ] ] = 's' ; } } } private unsubscribe ( socket , channels : string [ ] ) { for ( let i = 0 , len = channels . length ; i < len ; i ++ ) { delete socket . channels [ channels [ i ] ] ; } } private broadcast ( id , data ) { for ( let i = 0 , len = this . sockets . length ; i < len ; i ++ ) { const socket = this . sockets [ i ] ; if ( socket . id !== id ) { let empty = true ; const preparedMessage = { } ; for ( const key in data ) { if ( ! socket . channels [ key ] ) { continue ; } empty = false ; preparedMessage [ key ] = data [ key ] ; } if ( ! empty ) { if ( this . config . onMetrics ) { this . additionalMetrics . sent ++ ; } socket . send ( JSON . stringify ( preparedMessage ) ) ; } } } } private scheduleMetrics ( ) { if ( this . config . onMetrics ) { let numberOfChannels = 0 ; for ( let i = 0 , len = this . sockets . length ; i < len ; i ++ ) { numberOfChannels += Object . keys ( this . sockets [ i ] . channels ) . length ; } const metrics = { pid : process . pid , timestamp : parseInt ( `template` , 0 ) , numberOfChannels , connectedSockets : this . sockets . length , receivedPerSecond : this . additionalMetrics . received / 0 , sentPerSecond : this . additionalMetrics . sent / 0 } ; this . additionalMetrics . received = 0 ; this . additionalMetrics . sent = 0 ; this . config . onMetrics ( metrics ) ; setTimeout ( ( ) => this . scheduleMetrics ( ) , 0 ) ; } } }	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $string$ O O O $complex$ O O O $string$ O O O O O O O $any$ O $number$ O O O $WSEngine$ O $any$ O $void$ O O O O O O $void$ O O $boolean$ O $Error$ O O O O $void$ O O O $any$ O O O O O O $string$ O $number$ O O O $any$ O $number$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any[]$ O $any$ O O O O O O O $complex$ O O $number$ O O O $number$ O O O O O $number$ O O O $number$ O O O O O O O $BrokerServerOptions$ O O O O $void$ O O O O O $any$ O O $any$ O O O $BrokerServerOptions$ O $WSEngine$ O O $any$ O O $number$ O O O $BrokerServerOptions$ O $number$ O O $BrokerServerOptions$ O $void$ O O O O $any$ O $any$ O O O O $Error$ O O $BrokerServerOptions$ O $void$ O O O $Error$ O O O O O $any$ O $any$ O O O O $ExtendedSocket$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O O $string$ O O O O O O O $BrokerServerOptions$ O $void$ O O O O $complex$ O $number$ O O O O O $string$ O O O O O O O O O O $void$ O $any$ O $string$ O $complex$ O O O O O O $complex$ O O O O O O O O $string$ O O O O O O O O O O $void$ O $any$ O $string$ O $complex$ O O O O O O $complex$ O O O O O O O O O O $void$ O $any$ O $any$ O $JSON$ O $any$ O $string$ O O O O O O $any$ O O $BrokerServerOptions$ O $void$ O O O $any$ O O O O O O $any$ O $any$ O O O O $Error$ O O O O O $void$ O $any$ O $any$ O O $BrokerServerOptions$ O $void$ O O O $Error$ O O O O O $any$ O $any$ O O O O $number$ $number$ O $string$ $string$ O O O O O $void$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O $void$ O $ExtendedSocket$ O O $any$ O $any$ O $string$ O O O O $any$ O $any$ O O O O O O $any[]$ O $number$ O $any$ O O O O $void$ O $string$ O O O O O $number$ O O O $number$ O O O $any[]$ O $number$ O $number$ O $number$ O $number$ O O O O $ExtendedSocket$ O O O $any[]$ O $number$ O O O O $any$ O $any$ O $string$ O O O O $any[]$ O $complex$ O $number$ O O O O O O O O O O $void$ O $ExtendedSocket$ O $string[]$ O O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O $number$ O $number$ O O O O O O $any$ O $any$ O $string[]$ O $number$ O O O O $any$ O $any$ O $string[]$ O $number$ O O O O O O O O O $void$ O $ExtendedSocket$ O $string[]$ O O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O $number$ O $number$ O O O O $any$ O $any$ O $string[]$ O $number$ O O O O O O $void$ O $string$ O $object$ O O O O O $number$ O O O $number$ O O O $any[]$ O $number$ O $number$ O $number$ O $number$ O O O O $ExtendedSocket$ O O O $any[]$ O $number$ O O O O $any$ O $any$ O $string$ O O O $boolean$ O O O O $object$ O O O O O O O $string$ O $object$ O O O O O $any$ O $any$ O $string$ O O O O O O $boolean$ O O O $object$ O $string$ O O $object$ O $string$ O O O O O O $boolean$ O O O O O O $BrokerServerOptions$ O $void$ O O O O $complex$ O $number$ O O O $any$ O $any$ O $JSON$ O $complex$ O $object$ O O O O O O O O $void$ O O O O O O O $BrokerServerOptions$ O $void$ O O O $number$ O O O O O O $number$ O O O $number$ O O O $any[]$ O $number$ O $number$ O $number$ O $number$ O O O $number$ O $ObjectConstructor$ O $complex$ O O O $any[]$ O $number$ O O $any$ O O $number$ O O O $any$ O O $any$ O $any$ O $any$ O $number$ O $number$ O O O O O O $number$ O $number$ O O O $any[]$ O $number$ O $number$ O O O $complex$ O $number$ O O O $number$ O O O $complex$ O $number$ O O O O O O $complex$ O $number$ O O O O O $complex$ O $number$ O O O O O $BrokerServerOptions$ O $void$ O $any$ O O $number$ O O O O O O $void$ O O O O O O O O O
import { WebsocketEngine , WebSocket , WSEngine } from 's' ; function noop ( ) { } interface BrokerClientOptions { url : string ; engine : WSEngine ; onMessage ? : ( message ) => void ; onRegister ? : ( ) => void ; onUnregister ? : ( err ? ) => void ; } export class BrokerClient { private socket : WebSocket ; private inReconnect : boolean ; constructor ( private config ) { this . connect ( ) ; } public send ( message ) { this . socket . send ( message ) ; } private connect ( ) { this . socket = new WebsocketEngine ( this . config . engine ) . createClient ( this . config . url ) ; this . socket . on ( 's' , this . config . onRegister || noop ) ; this . socket . on ( 's' , this . config . onMessage || noop ) ; this . socket . on ( 's' , ( err ) => { this . reconnect ( ) ; } ) ; this . socket . on ( 's' , ( code ? , reason ? ) => { this . reconnect ( ) ; } ) ; this . socket . on ( 's' , ( ) => { } ) ; } private reconnect ( ) { if ( ! this . inReconnect ) { this . inReconnect = true ; if ( this . config . onUnregister ) { this . config . onUnregister ( ) ; } setTimeout ( ( ) => { this . inReconnect = false ; this . connect ( ) ; } , 0 ) ; } } }	O O $any$ O $any$ O $any$ O O O O O $void$ O O O O O $any$ O $string$ O O O $WSEngine$ O $any$ O $void$ O O O $string$ O O O O $void$ O O O O O O O $void$ O O O $Error$ $Error$ O O O O O O O $any$ O O $any$ O $any$ O O $boolean$ O O O O O O $BrokerClientOptions$ O O O O $void$ O O O O O $void$ O $string$ O O O O $any$ O $any$ O $string$ O O O O $void$ O O O O O $any$ O O $any$ O O O $BrokerClientOptions$ O $WSEngine$ O O $any$ O O O $BrokerClientOptions$ O $string$ O O O O $any$ O $any$ O O O O O $BrokerClientOptions$ O $void$ O $void$ O O O O $any$ O $any$ O O O O O $BrokerClientOptions$ O $void$ O $void$ O O O O $any$ O $any$ O O O O $Error$ O O O O O $void$ O O O O O O O O $any$ O $any$ O O O O $number$ $number$ O $string$ $string$ O O O O O $void$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O $void$ O O O O O O O O $boolean$ O O O O $boolean$ O O O O O O O $BrokerClientOptions$ O $void$ O O O O $BrokerClientOptions$ O $void$ O O O O $number$ O O O O O O O $boolean$ O O O O O $void$ O O O O O O O O O O O
import { WSEngine } from 's' ; import { BrokerServer } from 's' ; import { BrokerClient } from 's' ; if ( process . argv [ 0 ] === 's' ) { let iter = 0 ; let received = 0 ; let largestTimeDelay = 0 ; const client = new BrokerClient ( { url : 's' , engine : WSEngine . WS , onRegister : ( ) : void => { console . log ( 's' ) ; client . send ( 's' ) ; for ( let i = 0 ; i < 0 ; i ++ ) { client . send ( 's' + i ) ; } setInterval ( ( ) => { let message = { } ; for ( let i = iter ; i < 0 + iter ; i ++ ) { message [ 's' + i ] = [ 's' , 's' , 's' , 's' , 's' ] ; } iter += 0 ; if ( iter > 0 ) { iter = 0 ; } message . timestamp = new Date ( ) . getTime ( ) ; client . send ( JSON . stringify ( message ) ) ; } , 0 ) ; } , onUnregister : ( ) : void => { console . log ( 's' ) ; } , onMessage : ( message ) : void => { let parsed = JSON . parse ( message ) ; let diff = new Date ( ) . getTime ( ) - parsed . timestamp ; if ( diff > largestTimeDelay ) { largestTimeDelay = diff ; } received ++ ; } } ) ; setInterval ( ( ) => { console . log ( 's' , received ) ; console . log ( 's' , largestTimeDelay + 's' ) ; received = 0 ; largestTimeDelay = 0 ; } , 0 ) ; } else { new BrokerServer ( { port : 0 , engine : WSEngine . WS , onMetrics : ( data ) : void => { console . log ( data ) ; } , onError : ( isServer , err ) : void => { if ( isServer ) { return console . log ( `template` ) ; } console . log ( `template` ) ; } , onReady : ( ) : void => { console . log ( 's' ) ; } } ) ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O $number$ O O O O $number$ O O O O $number$ O O O O $BrokerClient$ O O $any$ O O $string$ O O O $WSEngine.WS$ O $any$ O $WSEngine.WS$ O $void$ O O O O O O O $Console$ O $void$ O O O O $BrokerClient$ O $void$ O O O O O O O $number$ O O O $number$ O O O $number$ O O O $BrokerClient$ O $void$ O O O $number$ O O O $number$ O O O O O O $any$ O O O O O O O $number$ O $number$ O $number$ O O O $number$ O $number$ O O O $any$ O O O $number$ O O O O O O O O O O O O O O O $number$ O O O O O $number$ O O O O $number$ O O O O $any$ O $any$ O O $DateConstructor$ O O O $number$ O O O $BrokerClient$ O $void$ O $JSON$ O $complex$ O $any$ O O O O O O O O O O $void$ O O O O O O O $Console$ O $void$ O O O O O O $void$ O O $string$ O O O O O O $any$ O $JSON$ O $any$ O $string$ O O O $number$ O O $DateConstructor$ O O O $number$ O O O $any$ O $any$ O O O $number$ O $number$ O O $number$ O $number$ O O $number$ O O O O O O $number$ O O O O O $Console$ O $void$ O O O $number$ O O $Console$ O $void$ O O O $number$ O O O O $number$ O O O $number$ O O O O O O O O O O O O $any$ O O $number$ O O O $WSEngine.WS$ O $any$ O $WSEngine.WS$ O $void$ O O $any$ O O O O O $Console$ O $void$ O $any$ O O O O $void$ O O $boolean$ O $Error$ O O O O O O O $boolean$ O O O $Console$ O $void$ O O O O O $Console$ O $void$ O O O O O O $void$ O O O O O O O $Console$ O $void$ O O O O O O O O O
import { expect } from 's' ; import { BrokerServer } from 's' ; import { BrokerClient } from 's' ; import { WSEngine } from 's' ; describe ( 's' , ( ) => { before ( ( done ) => { this . wsServer = new BrokerServer ( { port : 0 , engine : WSEngine . CWS , onReady : ( ) : void => { done ( ) ; } , onError : ( _ , error ) : void => { console . log ( 's' , error ) ; } } ) ; } ) ; it ( 's' , ( done ) => { this . client = new BrokerClient ( { url : 's' , engine : WSEngine . CWS , onRegister : ( ) : void => { expect ( this . wsServer . sockets . length ) . to . be . eql ( 0 ) ; done ( ) ; } } ) ; } ) ; it ( 's' , ( done ) => { this . client . reconnect = ( ) : void => { setTimeout ( ( ) => { expect ( this . wsServer . sockets . length ) . to . be . eql ( 0 ) ; done ( ) ; } , 0 ) ; } ; this . client . socket . close ( ) ; } ) ; it ( 's' , ( done ) => { let triggered = 0 ; this . client = new BrokerClient ( { url : 's' , engine : WSEngine . CWS , onRegister : ( ) : void => { triggered ++ ; if ( triggered === 0 ) { expect ( this . wsServer . sockets . length ) . to . be . eql ( 0 ) ; return done ( ) ; } this . client . socket . close ( ) ; } , onUnregister : ( ) : void => { triggered ++ ; } } ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O O O O O $any$ O O $any$ O O $number$ O O O $WSEngine.CWS$ O $any$ O $WSEngine.CWS$ O $void$ O O O O O O O $any$ O O O O O $void$ O O $boolean$ O $Error$ O O O O O $Console$ O $void$ O O O $Error$ O O O O O O O O O $any$ O O O O $any$ O O O O O $any$ O O $any$ O O $string$ O O O $WSEngine.CWS$ O $any$ O $WSEngine.CWS$ O $void$ O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O O O O O $number$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O O O $number$ O O O O O $any$ O O $any$ O O $string$ O O O $WSEngine.CWS$ O $any$ O $WSEngine.CWS$ O $void$ O O O O O O O $number$ O O O O $number$ O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $void$ O O O O O O O $number$ O O O O O O O O O O O O
type Listener = ( messages : { [ key ] : any [ ] } ) => void ; interface PubSubEngineOptions { sync : boolean ; flushInterval : number ; onChannelCreated : ( channel ) => void ; onChannelDestroyed : ( channel ) => void ; } function noop ( ) { } function findIndexOf ( arr : string [ ] , value ) { for ( let i = 0 , len = arr . length ; i < len ; i ++ ) { if ( arr [ i ] === value ) { return i ; } } return - 0 ; } function isObjectEmpty ( object : { [ key ] : any } ) { if ( object . hasOwnProperty ( 's' ) ) { if ( object . len <= 0 ) { return true ; } return false ; } for ( const key in object ) { if ( object . hasOwnProperty ( key ) ) { return false ; } } return true ; } export class PubSubEngine { public static GLOBAL_USER : string = 's' ; private options : PubSubEngineOptions ; private usersLink : { [ key ] : { listener : Listener , channels : string [ ] } } = { } ; private channelsUsers : { [ key ] : { len : number , [ key ] : string | number } } = { } ; private channelsBatches : { [ key ] : Array < [ string | null , any ] > } = { } ; private boundFlush : ( ) => void ; private flushTimeout : NodeJS . Timeout ; constructor ( options < PubSubEngineOptions > = { } ) { this . options = { sync : false , flushInterval : 0 , onChannelCreated : noop , onChannelDestroyed : noop , ... options } ; this . boundFlush = this . flush . bind ( this ) ; } public publish ( channel , message , user = null ) { const channelBatch : Array < [ string | null , any ] > | undefined = this . channelsBatches [ channel ] ; if ( channelBatch ) { channelBatch . push ( [ user , message ] ) ; } else { this . channelsBatches [ channel ] = [ [ user , message ] ] ; } if ( this . options . sync ) { return this . flush ( ) ; } if ( ! this . flushTimeout ) { this . flushTimeout = setTimeout ( this . boundFlush , this . options . flushInterval ) ; } } public register ( userId , listener ) { this . usersLink [ userId ] = { listener , channels : [ ] } ; } public subscribe ( userId , channels : string [ ] ) { const userInfo : { listener : Listener , channels : string [ ] } | undefined = this . usersLink [ userId ] ; if ( userInfo ) { for ( let i = 0 , len = channels . length ; i < len ; i ++ ) { const channel = channels [ i ] ; let channelUsersObject : { len : number , [ key ] : string | number } | undefined = this . channelsUsers [ channel ] ; if ( ! channelUsersObject ) { channelUsersObject = this . channelsUsers [ channel ] = { len : 0 , } ; this . options . onChannelCreated ( channel ) ; } if ( ! channelUsersObject [ userId ] ) { userInfo . channels . push ( channel ) ; channelUsersObject . len ++ ; channelUsersObject [ userId ] = 's' ; } } } } public unregister ( userId ) { const userInfo : { listener : Listener , channels : string [ ] } | undefined = this . usersLink [ userId ] ; if ( userInfo ) { this . unsubscribe ( userId , [ ... userInfo . channels ] ) ; delete this . usersLink [ userId ] ; } } public unsubscribe ( userId , channels : string [ ] ) { const userInfo : { listener : Listener , channels : string [ ] } | undefined = this . usersLink [ userId ] ; if ( userInfo ) { for ( let i = 0 , len = channels . length ; i < len ; i ++ ) { const channel = channels [ i ] ; const channelUsersObject : { len : number , [ key ] : string | number } | undefined = this . channelsUsers [ channel ] ; if ( channelUsersObject && channelUsersObject [ userId ] ) { channelUsersObject . len -- ; delete channelUsersObject [ userId ] ; userInfo . channels . splice ( findIndexOf ( userInfo . channels , channel ) , 0 ) ; if ( isObjectEmpty ( channelUsersObject ) ) { delete this . channelsUsers [ channel ] ; this . options . onChannelDestroyed ( channel ) ; } } } } } public getStats ( ) { return { numberOfUsers : Object . keys ( this . usersLink ) . length , numberOfChannels : Object . keys ( this . channelsUsers ) . length , } ; } private flush ( ) { const messagesToPublish = { } ; for ( const channel in this . channelsBatches ) { const messages : any [ ] = this . channelsBatches [ channel ] || [ ] ; for ( const userId in this . channelsUsers [ channel ] || { } ) { const userMessages : any [ ] = this . extractUserMessages ( userId , messages ) ; if ( userMessages . length ) { if ( ! messagesToPublish [ userId ] ) { messagesToPublish [ userId ] = { } ; } messagesToPublish [ userId ] [ channel ] = userMessages ; } } const startUserMessages : any [ ] = this . extractUserMessages ( PubSubEngine . GLOBAL_USER , messages ) ; if ( startUserMessages . length ) { if ( ! messagesToPublish [ PubSubEngine . GLOBAL_USER ] ) { messagesToPublish [ PubSubEngine . GLOBAL_USER ] = { } ; } messagesToPublish [ PubSubEngine . GLOBAL_USER ] [ channel ] = startUserMessages ; } } this . channelsBatches = { } ; this . flushTimeout = null ; for ( const userId in messagesToPublish ) { const user : { listener : Listener , channels : string [ ] } | undefined = this . usersLink [ userId ] ; if ( user ) { user . listener ( messagesToPublish [ userId ] ) ; } } } private extractUserMessages ( userId , messages : any [ ] ) : any [ ] { const messagesForUserInChannel : any [ ] = [ ] ; for ( let i = 0 , len = messages . length ; i < len ; i ++ ) { const message : any [ ] = messages [ i ] ; if ( message [ 0 ] !== userId ) { messagesForUserInChannel . push ( message [ 0 ] ) ; } } return messagesForUserInChannel ; } }	O $any$ O O $complex$ O O O $string$ O O O O O O O O O O O $any$ O $boolean$ O O O $number$ O O O $void$ O O $string$ O O O O $void$ O O $string$ O O O O O O $void$ O O O O O $number$ O $string[]$ O O O O O $string$ O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O $number$ O $number$ O O O O O $string[]$ O $number$ O O $string$ O O O $number$ O O O O O O O O O $boolean$ O $complex$ O O O $string$ O O O O O O O O $complex$ O $boolean$ O O O O O O O $complex$ O $any$ O O O O O O O O O O O O O O O $string$ O $complex$ O O O O $complex$ O $boolean$ O $string$ O O O O O O O O O O O O O O $any$ O O O $string$ O O O O O O $PubSubEngineOptions$ O $any$ O O $complex$ O O O $string$ O O O $Listener$ O $any$ O $string[]$ O O O O O O O O O O O $complex$ O O O $string$ O O O $number$ O O O O $string$ O O O O O O O O O O O O $complex$ O O O $string$ O O $ArrayConstructor$ O O O O O O O O O O O O O O O $void$ O O O O O O O $any$ O $any$ O $any$ O O O $Partial$ O $any$ O O O O O O O O $PubSubEngineOptions$ O O $false$ O O O $number$ O O O $void$ O $void$ O $void$ O $void$ O O $Partial<PubSubEngineOptions>$ O O O O $void$ O O O $void$ O $any$ O O O O O O $void$ O $string$ O $any$ O $string$ O O O O O $complex$ O $ArrayConstructor$ O O O O O O O O O O O O O O $complex$ O $string$ O O O O $complex$ O O $complex$ O $number$ O O $string$ O $any$ O O O O O O O O $complex$ O $string$ O O O O $string$ O $any$ O O O O O O O O $PubSubEngineOptions$ O $boolean$ O O O O O $void$ O O O O O O O O O $any$ O O O O $any$ O $number$ O O O $void$ O O O $PubSubEngineOptions$ O $number$ O O O O O $void$ O $string$ O $Listener$ O O O O $complex$ O $string$ O O O $Listener$ O $undefined[]$ O O O O O O O $void$ O $string$ O $string[]$ O O O O O O O $complex$ O O $Listener$ O $any$ O $string[]$ O O O O O O O O O O $complex$ O $string$ O O O O $complex$ O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O $complex$ O O $number$ O O O O $string$ O O O O O O O O O O O $complex$ O $string$ O O O O O $complex$ O O $complex$ O O O $complex$ O $string$ O O O $number$ O O O O O O O $PubSubEngineOptions$ O $void$ O $string$ O O O O O O $complex$ O $string$ O O O $complex$ O $string[]$ O $number$ O $string$ O O $complex$ O $number$ O O $complex$ O $string$ O O O O O O O O O $void$ O $string$ O O O $complex$ O O $Listener$ O $any$ O $string[]$ O O O O O O O O O O $complex$ O $string$ O O O O $complex$ O O O O $void$ O $string$ O O O $complex$ O $string[]$ O O O O O O $complex$ O $string$ O O O O O $void$ O $string$ O $string[]$ O O O O O O O $complex$ O O $Listener$ O $any$ O $string[]$ O O O O O O O O O O $complex$ O $string$ O O O O $complex$ O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O $complex$ O O $number$ O O O O $string$ O O O O O O O O O O O $complex$ O $string$ O O O O $complex$ O $complex$ O $string$ O O O $complex$ O $number$ O O O $complex$ O $string$ O O $complex$ O $string[]$ O $complex$ O $number$ O $complex$ O $string[]$ O $string$ O O O O O O O $boolean$ O $complex$ O O O O O O $complex$ O $string$ O O O O $PubSubEngineOptions$ O $void$ O $string$ O O O O O O O O $any$ O O O O O $number$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O $number$ O $number$ O $ObjectConstructor$ O $complex$ O O O $complex$ O O $number$ O O O O O $void$ O O O O $any$ O O O O O O O $string$ O O O $complex$ O O O $any[]$ O O O O O O O $complex$ O $string$ O O O O O O O O $string$ O O O $complex$ O $string$ O O O O O O O $any[]$ O O O O O O O $any[]$ O $string$ O $any[]$ O O O O $any[]$ O $number$ O O O O O $any$ O $string$ O O O $any$ O $string$ O O O O O O $any$ O $string$ O O $string$ O O $any[]$ O O O O $any[]$ O O O O O O O $any[]$ O $any$ O $string$ O $any[]$ O O O O $any[]$ O $number$ O O O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $string$ O O $string$ O O $any[]$ O O O O O $complex$ O O O O O O $any$ O O O O O O $string$ O $any$ O O O $complex$ O O $Listener$ O $any$ O $string[]$ O O O O O O O O O O $complex$ O $string$ O O O O $complex$ O O $complex$ O $Listener$ O $any$ O $string$ O O O O O O O $any[]$ O $string$ O $any[]$ O O O O O O O O O O O $any[]$ O O O O O O O O O O O $number$ O O O $number$ O $any[]$ O $number$ O $number$ O $number$ O $number$ O O O O $any[]$ O O O O O $any[]$ O $number$ O O O O $any[]$ O O O O $string$ O O $any[]$ O $number$ O $any[]$ O O O O O O O O $any[]$ O O O
import { expect } from 's' ; import { PubSubEngine } from 's' ; describe ( 's' , ( ) => { before ( ( ) => { this . pubSub = new PubSubEngine ( ) ; } ) ; it ( 's' , ( ) => { const registerUser = 's' ; this . pubSub . register ( registerUser , ( ) => { } ) ; expect ( ( this . pubSub as any ) . usersLink ) . to . contain . keys ( registerUser ) ; } ) ; it ( 's' , ( ) => { const registerUser = 's' ; const subscribeChannel = 's' ; this . pubSub . subscribe ( registerUser , [ subscribeChannel ] ) ; expect ( ( this . pubSub as any ) . usersLink [ registerUser ] . channels ) . to . contain ( subscribeChannel ) ; expect ( ( this . pubSub as any ) . channelsUsers ) . to . contain . keys ( subscribeChannel ) ; expect ( ( this . pubSub as any ) . channelsUsers [ subscribeChannel ] ) . to . contain . keys ( registerUser ) ; expect ( ( this . pubSub as any ) . channelsUsers [ subscribeChannel ] . len ) . to . be . eq ( 0 ) ; } ) ; it ( 's' , ( ) => { const registerUser = 's' ; const unSubscribeChannel = 's' ; this . pubSub . unsubscribe ( registerUser , [ unSubscribeChannel ] ) ; expect ( ( this . pubSub as any ) . usersLink [ registerUser ] . channels ) . to . not . contain ( unSubscribeChannel ) ; expect ( ( this . pubSub as any ) . channelsUsers ) . to . not . contain . keys ( unSubscribeChannel ) ; } ) ; it ( 's' , ( ) => { const registerUser = 's' ; const subscribeChannel = 's' ; this . pubSub . subscribe ( registerUser , [ subscribeChannel ] ) ; this . pubSub . unregister ( registerUser ) ; expect ( ( this . pubSub as any ) . usersLink ) . to . not . contain . keys ( registerUser ) ; expect ( ( this . pubSub as any ) . channelsUsers ) . to . not . contain . keys ( subscribeChannel ) ; } ) ; } ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { this . pubSub = new PubSubEngine ( ) ; } ) ; it ( 's' , ( done ) => { const registerUser = 's' ; const messageToPublish = 's' ; const channel = 's' ; this . pubSub . register ( registerUser , ( msg ) => { expect ( msg ) . to . contain . keys ( channel ) ; expect ( msg [ channel ] [ 0 ] ) . to . be . eq ( messageToPublish ) ; done ( ) ; } ) ; this . pubSub . subscribe ( registerUser , [ channel ] ) ; this . pubSub . publish ( channel , messageToPublish ) ; } ) ; it ( 's' , ( done ) => { const registerUser = 's' ; const 0 = 's' ; const messageToPublish = 's' ; const channel = 's' ; let exec = 0 ; this . pubSub . register ( registerUser , ( msg ) => { expect ( msg ) . to . contain . keys ( channel ) ; expect ( msg [ channel ] [ 0 ] ) . to . be . eq ( messageToPublish ) ; exec ++ ; if ( exec > 0 ) { done ( ) ; } } ) ; this . pubSub . register ( 0 , ( msg ) => { expect ( msg ) . to . contain . keys ( channel ) ; expect ( msg [ channel ] [ 0 ] ) . to . be . eq ( messageToPublish ) ; exec ++ ; if ( exec > 0 ) { done ( ) ; } } ) ; this . pubSub . subscribe ( registerUser , [ channel ] ) ; this . pubSub . subscribe ( 0 , [ channel ] ) ; this . pubSub . publish ( channel , messageToPublish ) ; } ) ; it ( 's' , ( done ) => { const messageToPublish = 's' ; const channel = 's' ; this . pubSub . register ( PubSubEngine . GLOBAL_USER , ( msg ) => { expect ( msg ) . to . contain . keys ( channel ) ; expect ( msg [ channel ] [ 0 ] ) . to . be . eq ( messageToPublish ) ; done ( ) ; } ) ; this . pubSub . publish ( channel , messageToPublish ) ; } ) ; it ( 's' , ( done ) => { const registerUser = 's' ; const messageToPublish = 's' ; const channel = 's' ; this . pubSub . register ( registerUser , ( msg ) => { done ( `template` ) ; } ) ; this . pubSub . subscribe ( registerUser , [ channel ] ) ; this . pubSub . unsubscribe ( registerUser , [ channel ] ) ; this . pubSub . publish ( channel , messageToPublish ) ; setTimeout ( ( ) => done ( ) , 0 ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $string$ O O O O O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O $string$ O O O O $string$ O O O O O $any$ O $any$ O $string$ O O $string$ O O O $any$ O O O O $any$ O O O O $any$ O $string$ O O $any$ O O $any$ O $any$ O $string$ O O $any$ O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O $any$ O O O O $any$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O $any$ O O O O $any$ O $string$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $string$ O O O O $string$ O O O O O $any$ O $any$ O $string$ O O $string$ O O O $any$ O O O O $any$ O O O O $any$ O $string$ O O $any$ O O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O $string$ O O O O $string$ O O O O O $any$ O $any$ O $string$ O O $string$ O O O O O $any$ O $any$ O $string$ O O $any$ O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O $any$ O O O O O O $any$ O O O O $any$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O O $any$ O $any$ O $string$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O O O O O $any$ O $any$ O $string$ O O $string$ O O O O O $any$ O $any$ O $string$ O $string$ O O O O O $any$ O O O O $any$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O $number$ O O O O O $any$ O $any$ O $string$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $string$ O O $number$ O O O O $number$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $string$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $string$ O O $number$ O O O O $number$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $string$ O O $string$ O O O O O $any$ O $any$ O $string$ O O $string$ O O O O O $any$ O $any$ O $string$ O $string$ O O O O O $any$ O O O O $any$ O O O O $string$ O O O O $string$ O O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O O O O O $any$ O $any$ O $string$ O $string$ O O O O O $any$ O O O O $any$ O O O O $string$ O O O O $string$ O O O O $string$ O O O O O $any$ O $any$ O $string$ O O $any$ O O O $any$ O O O O O O O O O $any$ O $any$ O $string$ O O $string$ O O O O O $any$ O $any$ O $string$ O O $string$ O O O O O $any$ O $any$ O $string$ O $string$ O O $number$ O O O O $any$ O O O O O O O O O O O O