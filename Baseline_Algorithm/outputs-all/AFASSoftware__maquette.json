'js' var wd = require ( 's' ) ; var finalhandler = require ( 's' ) ; var http = require ( 's' ) ; var serveStatic = require ( 's' ) ; var childProcess = require ( 's' ) ; var doubleClickScript = 's' + 's' + 's' ; var serve = serveStatic ( 's' , { } ) ; var server = http . createServer ( function ( req , res ) { var done = finalhandler ( req , res ) ; serve ( req , res , done ) ; } ) ; console . log ( 's' ) ; server . listen ( 0 ) ; wd . configureHttp ( { timeout : 0 , retryDelay : 0 , retries : 0 } ) ; var webdriverProcess = undefined ; var createBrowser = function ( ) { var browser = wd . promiseChainRemote ( 's' ) ; if ( process . env . VERBOSE || true ) { browser . on ( 's' , function ( info ) { console . log ( info . cyan ) ; } ) ; browser . on ( 's' , function ( meth , path , data ) { console . log ( 's' + meth . yellow , path . grey , data || 's' ) ; } ) ; } var initBrowser = function ( ) { return browser . init ( ) . setAsyncScriptTimeout ( 0 ) . then ( function ( ) { return browser ; } ) ; } ; return new Promise ( function ( resolve , reject ) { console . log ( 's' ) ; var chromedriverBinPath = require ( 's' ) . path ; console . log ( 's' + chromedriverBinPath ) ; webdriverProcess = childProcess . spawn ( chromedriverBinPath , [ ] , { } ) ; var resolved = false ; webdriverProcess . on ( 's' , function ( code ) { webdriverProcess = undefined ; if ( ! resolved ) { console . log ( 's' + code ) ; } else { reject ( 's' + code ) } } ) ; webdriverProcess . stdout . on ( 's' , function ( data ) { console . log ( 's' + data . toString ( ) ) ; if ( ! resolved ) { resolved = true ; resolve ( initBrowser ( ) . catch ( function ( err ) { webdriverProcess . kill ( ) ; throw err ; } ) ) ; } } ) ; webdriverProcess . stderr . on ( 's' , function ( data ) { console . log ( 's' + data ) ; } ) ; } ) ; } ; var quitBrowser = function ( browser , allPassed ) { if ( browser ) { browser = browser . quit ( ) ; if ( webdriverProcess ) { browser . then ( function ( ) { console . log ( 's' ) ; webdriverProcess . kill ( ) ; } ) ; } if ( server ) { server . close ( ) ; } } return browser ; } ; var setup = { rootUrl : 's' , server : server , browserCapabilities : { browserName : 's' } , sauce : false , createBrowser : createBrowser , quitBrowser : quitBrowser } ; module . exports = setup ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $string$ O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $Console$ O $void$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $number$ O O O $number$ O O O $number$ O O O O O O $any$ O $undefined$ O O $Promise<any>$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O $Console$ O $void$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $Console$ O $void$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O O $any$ O O O O O O O O $PromiseConstructor$ O O O $void$ O $void$ O O $Console$ O $void$ O O O O O $any$ O $any$ O O O O $any$ O $Console$ O $void$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $boolean$ O O O $any$ O $any$ O O O O O $any$ O O $any$ O $undefined$ O O O O $boolean$ O O $Console$ O $void$ O O O $any$ O O O O O $void$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $Console$ O $void$ O O O $any$ O $any$ O O O O O O O $boolean$ O O $boolean$ O O O $void$ O $any$ O O O $any$ O O O $any$ O O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $Console$ O $void$ O O O $any$ O O O O O O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $Console$ O $void$ O O O O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O $complex$ O O $string$ O O O $any$ O $any$ O $complex$ O O $string$ O O O O $boolean$ O O O $Promise<any>$ O $Promise<any>$ O $any$ O $any$ O O $complex$ O $complex$ O $complex$ O
'js' var expect = require ( "s" ) . expect ; var doubleClickScript = 's' + 's' + 's' ; module . exports = function ( browser , chain ) { chain = chain . waitForElementByCss ( 's' ) ; var getItemInputField = function ( ) { return chain . waitForElementByCss ( 's' ) ; } ; var getItemTexts = function ( ) { var lastPromise ; return browser . elementsByCss ( "s" ) . then ( function ( labels ) { return Promise . all ( labels . map ( function ( label ) { lastPromise = lastPromise ? lastPromise . then ( function ( ) { return label . text ( ) ; } ) : label . text ( ) ; return lastPromise ; } ) ) ; } ) ; } ; var waitForAnimationFrame = function ( ) { chain = chain . safeExecuteAsync ( "s" ) ; return page ; } ; var page = { waitForAnimationFrame : waitForAnimationFrame , assertFocussedElementId : function ( expectedId ) { var condition = "s" + expectedId + "s" ; return browser . waitForConditionInBrowser ( condition , 0 ) ; } , enterItem : function ( itemText ) { chain = getItemInputField ( ) . sendKeys ( itemText ) ; waitForAnimationFrame ( ) ; chain = getItemInputField ( ) . sendKeys ( 's' ) ; waitForAnimationFrame ( ) ; return page ; } , assertItems : function ( itemTexts ) { waitForAnimationFrame ( ) ; chain = chain . then ( function ( ) { return getItemTexts ( ) . then ( function ( foundTexts ) { expect ( foundTexts . length ) . to . equal ( itemTexts . length ) ; for ( var i = 0 ; i < itemTexts . length ; i ++ ) { expect ( foundTexts [ i ] ) . to . equal ( itemTexts [ i ] ) ; } } ) ; } ) ; return page ; } , assertMainSectionIsHidden : function ( ) { chain = chain . elementsByCss ( "s" ) . then ( function ( elements ) { expect ( elements . length ) . to . equal ( 0 ) ; } ) ; return page ; } , assertFooterIsHidden : function ( ) { chain = chain . elementsByCss ( "s" ) . then ( function ( elements ) { expect ( elements . length ) . to . equal ( 0 ) ; } ) ; return page ; } , assertMainSectionIsVisible : function ( ) { chain = chain . elementsByCss ( "s" ) . then ( function ( elements ) { expect ( elements . length ) . to . equal ( 0 ) ; } ) ; return page ; } , assertFooterIsVisible : function ( ) { chain = chain . elementsByCss ( "s" ) . then ( function ( elements ) { expect ( elements . length ) . to . equal ( 0 ) ; } ) ; return page ; } , assertItemInputFieldText : function ( text ) { chain = getItemInputField ( ) . getAttribute ( "s" ) . should . become ( text ) ; return page ; } , clickMarkAllCompletedCheckBox : function ( ) { chain = chain . elementByCss ( "s" ) . click ( ) ; return page ; } , assertItemsToBeCompleted : function ( completeds ) { var lastPromise ; chain = chain . elementsByCss ( "s" ) . then ( function ( items ) { return Promise . all ( items . map ( function ( item ) { lastPromise = lastPromise ? lastPromise . then ( function ( ) { return item . getAttribute ( "s" ) } ) : item . getAttribute ( "s" ) ; return lastPromise ; } ) ) . then ( function ( classes ) { expect ( classes . length ) . to . equal ( completeds . length ) ; return classes . map ( function ( cssClass , index ) { var completed = ! ! cssClass && ( cssClass . indexOf ( "s" ) !== - 0 ) ; expect ( completed ) . to . equal ( completeds [ index ] ) ; } ) ; } ) ; } ) ; return page ; } , assertCompleteAllIsChecked : function ( ) { chain = chain . elementByCss ( "s" ) . isSelected ( ) . should . become ( true ) ; return page ; } , assertCompleteAllIsClear : function ( ) { chain = chain . elementByCss ( "s" ) . isSelected ( ) . should . become ( false ) ; return page ; } , toggleItemAtIndex : function ( index ) { chain = chain . elementsByCss ( "s" ) . then ( function ( items ) { expect ( items . length ) . to . be . above ( index ) ; return items [ index ] . click ( ) ; } ) ; return page ; } , doubleClickItemAtIndex : function ( index ) { chain = chain . elementsByCss ( "s" ) . then ( function ( labels ) { expect ( labels . length ) . to . be . above ( index ) ; return browser . execute ( doubleClickScript , [ index ] ) ; } ) ; return page ; } , editItem : function ( text ) { chain = chain . safeExecute ( "s" ) ; chain = chain . elementByCss ( "s" ) . sendKeys ( text ) ; return page ; } , assertItemToggleIsHidden : function ( index ) { chain = chain . elementsByCss ( "s" ) . then ( function ( items ) { return items [ index ] . elementsByCss ( "s" ) . should . eventually . be . length ( 0 ) ; } ) ; return page ; } , assertItemLabelIsHidden : function ( index ) { chain = chain . elementsByCss ( "s" ) . then ( function ( items ) { return items [ index ] . elementsByCss ( "s" ) . should . eventually . be . length ( 0 ) ; } ) ; return page ; } , assertItemCountText : function ( text ) { chain = chain . elementByCss ( "s" ) . text ( ) . should . become ( text ) ; return page ; } , assertClearCompleteButtonText : function ( text ) { chain = chain . elementByCss ( "s" ) . text ( ) . should . become ( text ) ; return page ; } , clickClearCompleteButton : function ( ) { chain = chain . elementByCss ( "s" ) . click ( ) ; return page ; } , assertClearCompleteButtonIsVisible : function ( ) { chain = chain . elementsByCss ( "s" ) . should . eventually . be . length ( 0 ) ; return page ; } , assertClearCompleteButtonIsHidden : function ( ) { chain = chain . elementsByCss ( "s" ) . should . eventually . be . length ( 0 ) ; return page ; } , filterByAllItems : function ( ) { chain = chain . elementsByCss ( "s" ) . then ( function ( links ) { return links [ 0 ] . click ( ) ; } ) ; return page ; } , filterByActiveItems : function ( ) { chain = chain . elementsByCss ( "s" ) . then ( function ( links ) { return links [ 0 ] . click ( ) ; } ) ; return page ; } , filterByCompletedItems : function ( ) { chain = chain . elementsByCss ( "s" ) . then ( function ( links ) { return links [ 0 ] . click ( ) ; } ) ; return page ; } , assertFilterAtIndexIsSelected : function ( index ) { chain = chain . elementsByCss ( "s" ) . then ( function ( links ) { return links [ index ] . getAttribute ( "s" ) ; } ) . should . become ( "s" ) ; return page ; } , back : function ( ) { chain = chain . back ( ) ; return page ; } , then : function ( onFulfilled , onRejected ) { chain = chain . then ( onFulfilled , onRejected ) ; return page ; } } ; return page ; } ;	O O $any$ O $any$ O O O O $any$ O O $string$ O O O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $PromiseConstructor$ O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O $any$ O O O $any$ O O O $string$ O O O $any$ O O O O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O $any$ O $any$ O $number$ O O O $any$ O $any$ O $any$ O $number$ O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O $PromiseConstructor$ O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $complex$ O O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O O O $complex$ O $U[]$ O O O $any$ O $number$ O O O $boolean$ O O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $boolean$ O O $any$ O $any$ O $any$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $string$ O O $any$ O O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O O $any$ O O O O O O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O
'js' 's' ; var wd = require ( 's' ) ; var keys = wd . SPECIAL_KEYS ; require ( 's' ) ; var chai = require ( "s" ) ; var chaiAsPromised = require ( "s" ) ; var createTodoPage = require ( "s" ) ; var setup = require ( "s" ) ; chai . use ( chaiAsPromised ) ; chai . should ( ) ; chaiAsPromised . transferPromiseness = wd . transferPromiseness ; describe ( 's' , function ( ) { var browser ; var page ; var allPassed = true ; var pageLoaded = false ; before ( function ( ) { browser = null ; return setup . createBrowser ( ) . then ( function ( createdBrowser ) { browser = createdBrowser ; page = createTodoPage ( browser , browser . get ( setup . rootUrl + "s" ) ) ; return page ; } ) ; } ) ; beforeEach ( function ( ) { pageLoaded = true ; return browser . get ( setup . rootUrl + "s" ) . then ( function ( ) { pageLoaded = true ; } ) ; } ) ; afterEach ( function ( ) { allPassed = allPassed && ( this . currentTest . state === 's' ) ; if ( pageLoaded ) { pageLoaded = false ; return browser . safeExecute ( 's' ) ; } } ) ; after ( function ( ) { if ( browser ) { return setup . quitBrowser ( browser , allPassed ) ; } } ) ; var TODO_ITEM_ONE = 's' ; var TODO_ITEM_TWO = 's' ; var TODO_ITEM_THREE = 's' ; var createStandardItems = function ( ) { return page . enterItem ( TODO_ITEM_ONE ) . enterItem ( TODO_ITEM_TWO ) . enterItem ( TODO_ITEM_THREE ) ; } ; describe ( 's' , function ( ) { it ( 's' , function ( ) { return page . assertFocussedElementId ( "s" ) ; } ) ; } ) ; describe ( 's' , function ( ) { it ( 's' , function ( ) { return page . assertItems ( [ ] ) . assertMainSectionIsHidden ( ) . assertFooterIsHidden ( ) ; } ) ; } ) ; describe ( 's' , function ( ) { it ( 's' , function ( ) { return page . enterItem ( TODO_ITEM_ONE ) . assertItems ( [ TODO_ITEM_ONE ] ) . enterItem ( TODO_ITEM_TWO ) . assertItems ( [ TODO_ITEM_ONE , TODO_ITEM_TWO ] ) ; } ) ; it ( 's' , function ( ) { return page . enterItem ( TODO_ITEM_ONE ) . assertItemInputFieldText ( 's' ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . assertItems ( [ TODO_ITEM_ONE , TODO_ITEM_TWO , TODO_ITEM_THREE ] ) ; } ) ; it ( 's' , function ( ) { return page . enterItem ( 's' + TODO_ITEM_ONE + 's' ) . assertItems ( [ TODO_ITEM_ONE ] ) ; } ) ; it ( 's' , function ( ) { return page . enterItem ( TODO_ITEM_ONE ) . waitForAnimationFrame ( ) . assertMainSectionIsVisible ( ) . assertFooterIsVisible ( ) ; } ) ; } ) ; describe ( 's' , function ( ) { it ( 's' , function ( ) { createStandardItems ( ) ; return page . clickMarkAllCompletedCheckBox ( ) . waitForAnimationFrame ( ) . assertItemsToBeCompleted ( [ true , true , true ] ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . clickMarkAllCompletedCheckBox ( ) . waitForAnimationFrame ( ) . clickMarkAllCompletedCheckBox ( ) . waitForAnimationFrame ( ) . assertItemsToBeCompleted ( [ false , false , false ] ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . clickMarkAllCompletedCheckBox ( ) . waitForAnimationFrame ( ) . assertCompleteAllIsChecked ( ) . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . assertCompleteAllIsClear ( ) . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . assertCompleteAllIsChecked ( ) ; } ) ; } ) ; describe ( 's' , function ( ) { it ( 's' , function ( ) { return page . enterItem ( TODO_ITEM_ONE ) . enterItem ( TODO_ITEM_TWO ) . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . assertItemsToBeCompleted ( [ true , false ] ) . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . assertItemsToBeCompleted ( [ true , true ] ) ; } ) ; it ( 's' , function ( ) { return page . enterItem ( TODO_ITEM_ONE ) . enterItem ( TODO_ITEM_TWO ) . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . assertItemsToBeCompleted ( [ true , false ] ) . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . assertItemsToBeCompleted ( [ false , false ] ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . doubleClickItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . editItem ( 's' + keys . Enter ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_ONE , 's' , TODO_ITEM_THREE ] ) ; } ) ; } ) ; describe ( 's' , function ( ) { it ( 's' , function ( ) { keys . Enter . should . equal ( 's' ) ; createStandardItems ( ) ; return page . doubleClickItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . assertItemToggleIsHidden ( 0 ) . assertItemLabelIsHidden ( 0 ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . doubleClickItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . editItem ( 's' + keys . Enter ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_ONE , 's' , TODO_ITEM_THREE ] ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . doubleClickItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . editItem ( 's' ) . waitForAnimationFrame ( ) . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_ONE , 's' , TODO_ITEM_THREE ] ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . doubleClickItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . editItem ( 's' + keys . Enter ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_ONE , 's' , TODO_ITEM_THREE ] ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . doubleClickItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . editItem ( "s" ) . editItem ( keys . Enter ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_ONE , TODO_ITEM_THREE ] ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . doubleClickItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . editItem ( 's' + keys . Escape ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_ONE , TODO_ITEM_TWO , TODO_ITEM_THREE ] ) ; } ) ; } ) ; describe ( 's' , function ( ) { it ( 's' , function ( ) { return page . enterItem ( TODO_ITEM_ONE ) . assertItemCountText ( 's' ) . enterItem ( TODO_ITEM_TWO ) . assertItemCountText ( 's' ) ; } ) ; } ) ; describe ( 's' , function ( ) { it ( 's' , function ( ) { createStandardItems ( ) ; return page . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . assertClearCompleteButtonText ( 's' ) . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . assertClearCompleteButtonText ( 's' ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . clickClearCompleteButton ( ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_ONE , TODO_ITEM_THREE ] ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . assertClearCompleteButtonIsVisible ( ) . clickClearCompleteButton ( ) . waitForAnimationFrame ( ) . assertClearCompleteButtonIsHidden ( ) ; } ) ; } ) ; describe ( 's' , function ( ) { it ( 's' , function ( ) { createStandardItems ( ) ; return page . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . filterByActiveItems ( ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_ONE , TODO_ITEM_THREE ] ) ; } ) ; it ( 's' , function ( ) { if ( setup . browserCapabilities . browserName === "s" ) { console . log ( "s" ) ; return ; } createStandardItems ( ) ; return page . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . filterByActiveItems ( ) . waitForAnimationFrame ( ) . filterByCompletedItems ( ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_TWO ] ) . back ( ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_ONE , TODO_ITEM_THREE ] ) . back ( ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_ONE , TODO_ITEM_TWO , TODO_ITEM_THREE ] ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . filterByCompletedItems ( ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_TWO ] ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . toggleItemAtIndex ( 0 ) . waitForAnimationFrame ( ) . filterByActiveItems ( ) . waitForAnimationFrame ( ) . filterByCompletedItems ( ) . waitForAnimationFrame ( ) . filterByAllItems ( ) . waitForAnimationFrame ( ) . assertItems ( [ TODO_ITEM_ONE , TODO_ITEM_TWO , TODO_ITEM_THREE ] ) ; } ) ; it ( 's' , function ( ) { createStandardItems ( ) ; return page . assertFilterAtIndexIsSelected ( 0 ) . filterByActiveItems ( ) . waitForAnimationFrame ( ) . assertFilterAtIndexIsSelected ( 0 ) . filterByCompletedItems ( ) . waitForAnimationFrame ( ) . assertFilterAtIndexIsSelected ( 0 ) ; } ) ; } ) ; } ) ;	O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $complex$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O $any$ O O $boolean$ O O O O $boolean$ O O O $any$ O O O O O $any$ O O O O $complex$ O $Promise<any>$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $complex$ O $string$ O O O O O O O O O O O O O O $any$ O O O O O $boolean$ O O O O $any$ O $any$ O $complex$ O $string$ O O O O $any$ O O O O O $boolean$ O O O O O O O O O $any$ O O O O O $boolean$ O $boolean$ O O O O $any$ O $any$ O O O O O O $boolean$ O O $boolean$ O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O $complex$ O $any$ O $any$ O $boolean$ O O O O O O O $string$ O O O O $string$ O O O O $string$ O O O O $any$ O O O O O O $any$ O $any$ O $string$ O O $any$ O $string$ O O $any$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $string$ O O $any$ O O $string$ O O O $any$ O $string$ O O $any$ O O $string$ O $string$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O $string$ O $string$ O $string$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $string$ O O O O $any$ O O $string$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $string$ O O $any$ O O O $any$ O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O $any$ O O O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O O $any$ O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $string$ O O $any$ O $string$ O O $any$ O O O O $any$ O O O $any$ O O O O O O O O $any$ O O O O $any$ O O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $string$ O O $any$ O $string$ O O $any$ O O O O $any$ O O O $any$ O O O O O O O O $any$ O O O O $any$ O O O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O O $any$ O O O $any$ O O O O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O $string$ O $string$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O O $string$ O $string$ O $string$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $string$ O O $any$ O O O O $any$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O $string$ O $string$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O $string$ O $string$ O O O O O O $any$ O O O O O O O O O $complex$ O $complex$ O $string$ O O O O $Console$ O $void$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O $string$ O O O $any$ O O O $any$ O O O $any$ O O $string$ O $string$ O O O $any$ O O O $any$ O O O $any$ O O $string$ O $string$ O $string$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O $string$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O $string$ O $string$ O $string$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O O O O O O O O O O O
export interface ProjectorService { scheduleRender ( ) : void ; renderNow ( ) : void ; } export interface Projector extends ProjectorService { append ( parentNode , renderFunction : ( ) => VNode ) : void ; insertBefore ( beforeNode , renderFunction : ( ) => VNode ) : void ; merge ( domNode , renderFunction : ( ) => VNode ) : void ; replace ( domNode , renderFunction : ( ) => VNode ) : void ; resume ( ) : void ; detach ( renderFunction : ( ) => VNode ) : Projection ; stop ( ) : void ; } export interface VNode { readonly vnodeSelector : string ; readonly properties : VNodeProperties | undefined ; readonly children : VNode [ ] | undefined ; readonly text : string | undefined ; domNode : Node | null ; } export interface VNodeProperties { enterAnimation ? : ( ( element , properties ? ) => void ) ; exitAnimation ? ( element , removeElement : ( ) => void , properties ? ) : void ; updateAnimation ? ( element , properties ? , previousProperties ? ) : void ; afterCreate ? ( element , projectionOptions , vnodeSelector , properties , children : VNode [ ] | undefined ) : void ; afterUpdate ? ( element , projectionOptions , vnodeSelector , properties , children : VNode [ ] | undefined ) : void ; afterRemoved ? ( element ) : void ; readonly bind ? : object ; readonly key ? : Object ; readonly classes ? : { [ index ] : boolean | null | undefined } ; readonly styles ? : Partial < CSSStyleDeclaration > ; ontouchcancel ? ( ev ) : boolean | void ; ontouchend ? ( ev ) : boolean | void ; ontouchmove ? ( ev ) : boolean | void ; ontouchstart ? ( ev ) : boolean | void ; readonly action ? : string ; readonly encoding ? : string ; readonly enctype ? : string ; readonly method ? : string ; readonly name ? : string ; readonly target ? : string ; readonly href ? : string ; readonly rel ? : string ; onblur ? ( ev ) : boolean | void ; onchange ? ( ev ) : boolean | void ; onclick ? ( ev ) : boolean | void ; ondblclick ? ( ev ) : boolean | void ; ondrag ? ( ev ) : boolean | void ; ondragend ? ( ev ) : boolean | void ; ondragenter ? ( ev ) : boolean | void ; ondragleave ? ( ev ) : boolean | void ; ondragover ? ( ev ) : boolean | void ; ondragstart ? ( ev ) : boolean | void ; ondrop ? ( ev ) : boolean | void ; onfocus ? ( ev ) : boolean | void ; oninput ? ( ev ) : boolean | void ; onkeydown ? ( ev ) : boolean | void ; onkeypress ? ( ev ) : boolean | void ; onkeyup ? ( ev ) : boolean | void ; onload ? ( ev ) : boolean | void ; onmousedown ? ( ev ) : boolean | void ; onmouseenter ? ( ev ) : boolean | void ; onmouseleave ? ( ev ) : boolean | void ; onmousemove ? ( ev ) : boolean | void ; onmouseout ? ( ev ) : boolean | void ; onmouseover ? ( ev ) : boolean | void ; onmouseup ? ( ev ) : boolean | void ; onmousewheel ? ( ev : WheelEvent | MouseWheelEvent ) : boolean | void ; onscroll ? ( ev ) : boolean | void ; onsubmit ? ( ev ) : boolean | void ; readonly spellcheck ? : boolean ; readonly tabIndex ? : number ; readonly disabled ? : boolean ; readonly title ? : string ; readonly accessKey ? : string ; readonly class ? : string ; readonly id ? : string ; readonly draggable ? : boolean ; readonly type ? : string ; readonly autocomplete ? : string ; readonly checked ? : boolean ; readonly placeholder ? : string ; readonly readOnly ? : boolean ; readonly src ? : string ; readonly value ? : string ; readonly alt ? : string ; readonly srcset ? : string ; readonly innerHTML ? : string ; readonly className ? : never | 's' ; readonly [ index ] : any ; } export interface VNodeChildren extends Array < VNodeChild > { } export type VNodeChild = string | VNode | VNodeChildren | false | null | undefined ; export interface Projection { readonly domNode : Element ; update ( updatedVnode ) : void ; getLastRender ( ) : VNode ; } export type EventHandlerInterceptor = ( propertyName , eventHandler , domNode , properties ) => Function | undefined ; export type PerformanceLoggerEvent = 's' | 's' | 's' | 's' | 's' | 's' ; export type ProjectorPerformanceLogger = ( eventType , trigger : Event | undefined ) => void ; export interface ProjectorOptions { performanceLogger ? : ProjectorPerformanceLogger ; styleApplyer ? ( domNode , styleName , value ) : void ; } export interface ProjectionOptions extends ProjectorOptions { readonly namespace ? : string ; eventHandlerInterceptor ? : EventHandlerInterceptor ; } export interface Mapping < Source , Target > { results : Target [ ] ; map ( newSources : Source [ ] ) : void ; } export interface CalculationCache < Result > { invalidate ( ) : void ; result ( inputs : Object [ ] , calculation : ( ) => Result ) : Result ; } export interface Component { renderMaquette ( ) : VNode | null | undefined ; } export interface MaquetteComponent { render ( ) : VNode | null | undefined ; } export interface Dom { create ( vnode , projectionOptions ? ) : Projection ; append ( parentNode , vnode , projectionOptions ? ) : Projection ; insertBefore ( beforeNode , vnode , projectionOptions ? ) : Projection ; merge ( element , vnode , projectionOptions ? ) : Projection ; replace ( element , vnode , projectionOptions ? ) : Projection ; }	O O $any$ O $void$ O O O O O $void$ O O O O O O O O $any$ O $any$ O $void$ O $Element$ O $VNode$ O O O O $any$ O O O O $void$ O $Element$ O $VNode$ O O O O $any$ O O O O $void$ O $Element$ O $VNode$ O O O O $any$ O O O O $void$ O $Element$ O $VNode$ O O O O $any$ O O O O $void$ O O O O O $Projection$ O $VNode$ O O O O $any$ O O $any$ O $void$ O O O O O O O O $any$ O O $string$ O O O O $VNodeProperties$ O $any$ O O O O $VNode[]$ O $any$ O O O O O O $string$ O O O O O $Node$ O O O O O O O O $any$ O $void$ O O O O $Element$ O $VNodeProperties$ $VNodeProperties$ O O O O O $void$ O O $Element$ O $void$ O O O O O O $VNodeProperties$ $VNodeProperties$ O O O O $void$ O O $Element$ O $VNodeProperties$ $VNodeProperties$ O $VNodeProperties$ $VNodeProperties$ O O O O $void$ O O $Element$ O $ProjectionOptions$ O $string$ O $VNodeProperties$ O $VNode[]$ O $any$ O O O O O O O O $void$ O O $Element$ O $ProjectionOptions$ O $string$ O $VNodeProperties$ O $VNode[]$ O $any$ O O O O O O O O $void$ O O $Element$ O O O O O $object$ O O O O O $Object$ O O $ObjectConstructor$ O O $complex$ O O O O $string$ O O O O O O O O O O $Partial<CSSStyleDeclaration>$ O O $any$ O $complex$ O O $complex$ O O $TouchEvent$ O O O O O O $complex$ O O $TouchEvent$ O O O O O O $complex$ O O $TouchEvent$ O O O O O O $complex$ O O $TouchEvent$ O O O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O $complex$ O O $FocusEvent$ O O O O O O $complex$ O O $Event$ O O O O O O $complex$ O O $MouseEvent$ O O O O O O $complex$ O O $MouseEvent$ O O O O O O $complex$ O O $DragEvent$ O O O O O O $complex$ O O $DragEvent$ O O O O O O $complex$ O O $DragEvent$ O O O O O O $complex$ O O $DragEvent$ O O O O O O $complex$ O O $DragEvent$ O O O O O O $complex$ O O $DragEvent$ O O O O O O $complex$ O O $DragEvent$ O O O O O O $complex$ O O $FocusEvent$ O O O O O O $complex$ O O $Event$ O O O O O O $complex$ O O $KeyboardEvent$ O O O O O O $complex$ O O $KeyboardEvent$ O O O O O O $complex$ O O $KeyboardEvent$ O O O O O O $complex$ O O $Event$ O O O O O O $complex$ O O $MouseEvent$ O O O O O O $complex$ O O $MouseEvent$ O O O O O O $complex$ O O $MouseEvent$ O O O O O O $complex$ O O $MouseEvent$ O O O O O O $complex$ O O $MouseEvent$ O O O O O O $complex$ O O $MouseEvent$ O O O O O O $complex$ O O $MouseEvent$ O O O O O O $complex$ O O $WheelEvent$ O $complex$ O $any$ O O O O O O $complex$ O O $UIEvent$ O O O O O O $complex$ O O $Event$ O O O O O O O $boolean$ O O O O O $number$ O O O O O $boolean$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $boolean$ O O O O O $string$ O O O O O $string$ O O O O O $boolean$ O O O O O $string$ O O O O O $boolean$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O O O O O O O O $string$ O O O O O O O $any$ O $ArrayConstructor$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O O $Element$ O $complex$ O $void$ O $VNode$ O O O O $VNode$ O O O $any$ O O O O $any$ O O $string$ O $Function$ O $Node$ O $VNodeProperties$ O O $FunctionConstructor$ O O O O O $any$ O O O O O O O O O O O O O O O $any$ O O $PerformanceLoggerEvent$ O $Event$ O $complex$ O O O O O O O O $any$ O $ProjectorPerformanceLogger$ O O $any$ O $void$ O O $HTMLElement$ O $string$ O $string$ O O O O O O O $any$ O $any$ O O $string$ O O O O $EventHandlerInterceptor$ O O $any$ O O O O $any$ O $any$ O $any$ O O $Target[]$ O $any$ O O O $void$ O $Source[]$ O $any$ O O O O O O O O O $any$ O $any$ O O $void$ O O O O O $Result$ O $Object[]$ O $ObjectConstructor$ O O O $Result$ O O O O $any$ O O $any$ O O O O $any$ O $VNode$ O O O $any$ O O O O O O O O $any$ O $VNode$ O O O $any$ O O O O O O O O $any$ O $Projection$ O $VNode$ O $ProjectionOptions$ $ProjectionOptions$ O O $any$ O $Projection$ O $Element$ O $VNode$ O $ProjectionOptions$ $ProjectionOptions$ O O $any$ O $Projection$ O $Element$ O $VNode$ O $ProjectionOptions$ $ProjectionOptions$ O O $any$ O $Projection$ O $Element$ O $VNode$ O $ProjectionOptions$ $ProjectionOptions$ O O $any$ O $Projection$ O $Element$ O $VNode$ O $ProjectionOptions$ $ProjectionOptions$ O O $any$ O O
import { VNode , VNodeChild , VNodeProperties } from 's' ; let toTextVNode = ( data ) : VNode => { return { vnodeSelector : 's' , properties : undefined , children : undefined , text : data . toString ( ) , domNode : null } ; } ; let appendChildren = ( parentSelector , insertions : VNodeChild [ ] , main : VNode [ ] ) => { for ( let i = 0 , length = insertions . length ; i < length ; i ++ ) { let item = insertions [ i ] ; if ( Array . isArray ( item ) ) { appendChildren ( parentSelector , item , main ) ; } else { if ( item !== null && item !== undefined && item !== false ) { if ( typeof item === 's' ) { item = toTextVNode ( item ) ; } main . push ( item ) ; } } } } ; export function h ( selector , properties ? , children ? : VNodeChild [ ] | null ) ; export function h ( selector , children : VNodeChild [ ] ) ; export function h ( selector , properties ? , children ? : VNodeChild [ ] | null ) { if ( Array . isArray ( properties ) ) { children = properties ; properties = undefined ; } else if ( ( properties && ( typeof properties === 's' || properties . hasOwnProperty ( 's' ) ) ) || ( children && ( typeof children === 's' || children . hasOwnProperty ( 's' ) ) ) ) { throw new Error ( 's' ) ; } let text : string | undefined ; let flattenedChildren : VNode [ ] | undefined ; if ( children && children . length === 0 && typeof children [ 0 ] === 's' ) { text = children [ 0 ] as string ; } else if ( children ) { flattenedChildren = [ ] ; appendChildren ( selector , children , flattenedChildren ) ; if ( flattenedChildren . length === 0 ) { flattenedChildren = undefined ; } } return { vnodeSelector : selector , properties : properties , children : flattenedChildren , text : ( text === 's' ) ? undefined : text , domNode : null } ; }	O O $any$ O $any$ O $any$ O O O O O $VNode$ O O $string$ O O $any$ O O O O $string$ O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $string$ O $string$ O $string$ O O O $null$ O O O O O O O $void$ O O $string$ O $VNodeChild[]$ O $any$ O O O $VNode[]$ O $any$ O O O O O O O O $number$ O O O $number$ O $VNodeChild[]$ O $number$ O $number$ O $number$ O $number$ O O O O $VNodeChild$ O $VNodeChild[]$ O $number$ O O O O $ArrayConstructor$ O $complex$ O $VNodeChild$ O O O $void$ O $string$ O $VNodeChildren$ O $VNode[]$ O O O O O O O $complex$ O O O $complex$ O $undefined$ O $complex$ O O O O O O O $complex$ O O O O $VNodeChild$ O $VNode$ O $string$ O O O $VNode[]$ O $number$ O $VNode$ O O O O O O O O O $VNode$ O $string$ O $VNodeProperties$ $VNodeProperties$ O $VNodeChild[]$ O O $any$ O O O O O O O O $VNode$ O $string$ O $VNodeChild[]$ O $any$ O O O O O O $VNode$ O $string$ O $VNodeProperties$ $VNodeProperties$ O $VNodeChild[]$ O O $any$ O O O O O O O O $ArrayConstructor$ O $complex$ O $VNodeProperties$ O O O $VNodeChild[]$ O $any[]$ O $VNodeProperties$ O $undefined$ O O O O O O $VNodeProperties$ O O O $VNodeProperties$ O O O $VNodeProperties$ O $boolean$ O O O O O O O $VNodeChild[]$ O O O $VNodeChild[]$ O O O $VNodeChild[]$ O $boolean$ O O O O O O O O O $ErrorConstructor$ O O O O O O $string$ O O O O O O $VNode[]$ O $any$ O O O O O O O $VNodeChild[]$ O $VNodeChild[]$ O $number$ O O O O $VNodeChild[]$ O O O O O O O $string$ O $VNodeChild[]$ O O O O O O O O O O $VNodeChild[]$ O O $VNode[]$ O O O O $void$ O $string$ O $VNodeChild[]$ O $VNode[]$ O O O O $VNode[]$ O $number$ O O O O $VNode[]$ O $undefined$ O O O O O $string$ O $string$ O $VNodeProperties$ O $VNodeProperties$ O $VNode[]$ O $VNode[]$ O $string$ O O $string$ O O O O $undefined$ O $string$ O $null$ O O O O O
import { Mapping } from 's' ; export let createMapping = < Source , Target > ( getSourceKey : ( source ) => ( string | number ) , createResult : ( source , index ) => Target , updateResult : ( source , target , index ) => void ) : Mapping < Source , Target > => { let keys = [ ] as Object [ ] ; let results = [ ] as Target [ ] ; return { results : results , map : ( newSources : Source [ ] ) => { let newKeys = newSources . map ( getSourceKey ) ; let oldTargets = results . slice ( ) ; let oldIndex = 0 ; for ( let i = 0 ; i < newSources . length ; i ++ ) { let source = newSources [ i ] ; let sourceKey = newKeys [ i ] ; if ( sourceKey === keys [ oldIndex ] ) { results [ i ] = oldTargets [ oldIndex ] ; updateResult ( source , oldTargets [ oldIndex ] , i ) ; oldIndex ++ ; } else { let found = false ; for ( let j = 0 ; j < keys . length + 0 ; j ++ ) { let searchIndex = ( oldIndex + j ) % keys . length ; if ( keys [ searchIndex ] === sourceKey ) { results [ i ] = oldTargets [ searchIndex ] ; updateResult ( newSources [ i ] , oldTargets [ searchIndex ] , i ) ; oldIndex = searchIndex + 0 ; found = true ; break ; } } if ( ! found ) { results [ i ] = createResult ( source , i ) ; } } } results . length = newSources . length ; keys = newKeys ; } } ; } ;	O O $any$ O O O O O O $Mapping<...>$ O O $any$ O $any$ O O $complex$ O O $Source$ O O O O O O O O $Target$ O O $Source$ O $number$ O O $any$ O $void$ O O $Source$ O $Target$ O $number$ O O O O O $any$ O $any$ O $any$ O O O O $Object[]$ O O O O $ObjectConstructor$ O O O O $Target[]$ O O O O $any$ O O O O O $Target[]$ O $Target[]$ O $void$ O O $Source[]$ O $any$ O O O O O O $complex$ O $Source[]$ O $U[]$ O $complex$ O O O $Target[]$ O $Target[]$ O $Target[]$ O O O O $number$ O O O O O O $number$ O O O $number$ O $Source[]$ O $number$ O $number$ O O O O $Source$ O $Source[]$ O $number$ O O O $complex$ O $complex$ O $number$ O O O O $complex$ O $Object[]$ O $number$ O O O $Target[]$ O $number$ O O $Target[]$ O $number$ O O $void$ O $Source$ O $Target[]$ O $number$ O O $number$ O O $number$ O O O O O O $boolean$ O O O O O O $number$ O O O $number$ O $Object[]$ O $number$ O O O $number$ O O O O $number$ O O $number$ O $number$ O O $Object[]$ O $number$ O O O $Object[]$ O $number$ O O $complex$ O O $Target[]$ O $number$ O O $Target[]$ O $number$ O O $void$ O $Source[]$ O $number$ O O $Target[]$ O $number$ O O $number$ O O $number$ O $number$ O O O $boolean$ O O O O O O O O O O $boolean$ O O $Target[]$ O $number$ O O $Target$ O $Source$ O $number$ O O O O O $Target[]$ O $number$ O $Source[]$ O $number$ O $Object[]$ O $complex$ O O O O O O
import { Projection , ProjectionOptions , VNode , VNodeProperties } from 's' ; const 0 = 's' ; const NAMESPACE_SVG = `template` ; const NAMESPACE_XLINK = `template` ; let emptyArray = < VNode [ ] > [ ] ; export let extend = < T > ( base : T , overrides ) : T => { let result = { } as any ; Object . keys ( base ) . forEach ( ( key ) => { result [ key ] = ( base as any ) [ key ] ; } ) ; if ( overrides ) { Object . keys ( overrides ) . forEach ( ( key ) => { result [ key ] = overrides [ key ] ; } ) ; } return result ; } ; let same = ( 0 , 0 ) => { if ( 0 . vnodeSelector !== 0 . vnodeSelector ) { return false ; } if ( 0 . properties && 0 . properties ) { if ( 0 . properties . key !== 0 . properties . key ) { return false ; } return 0 . properties . bind === 0 . properties . bind ; } return ! 0 . properties && ! 0 . properties ; } ; let checkStyleValue = ( styleValue ) => { if ( typeof styleValue !== 's' ) { throw new Error ( 's' ) ; } } ; let findIndexOfChild = ( children : VNode [ ] , sameAs , start ) => { if ( sameAs . vnodeSelector !== 's' ) { for ( let i = start ; i < children . length ; i ++ ) { if ( same ( children [ i ] , sameAs ) ) { return i ; } } } return - 0 ; } ; let checkDistinguishable = ( childNodes : VNode [ ] , indexToCheck , parentVNode , operation ) => { let childNode = childNodes [ indexToCheck ] ; if ( childNode . vnodeSelector === 's' ) { return ; } let properties = childNode . properties ; let key = properties ? ( properties . key === undefined ? properties . bind : properties . key ) : undefined ; if ( ! key ) { for ( let i = 0 ; i < childNodes . length ; i ++ ) { if ( i !== indexToCheck ) { let node = childNodes [ i ] ; if ( same ( node , childNode ) ) { throw new Error ( `template` ) ; } } } } } ; let nodeAdded = ( vNode ) => { if ( vNode . properties ) { let enterAnimation = vNode . properties . enterAnimation ; if ( enterAnimation ) { enterAnimation ( vNode . domNode as Element , vNode . properties ) ; } } } ; let removedNodes : VNode [ ] = [ ] ; let requestedIdleCallback = false ; let visitRemovedNode = ( node ) => { ( node . children || [ ] ) . forEach ( visitRemovedNode ) ; if ( node . properties && node . properties . afterRemoved ) { node . properties . afterRemoved . apply ( node . properties . bind || node . properties , [ < Element > node . domNode ] ) ; } } ; let processPendingNodeRemovals = ( ) : void => { requestedIdleCallback = false ; removedNodes . forEach ( visitRemovedNode ) ; removedNodes . length = 0 ; } ; let scheduleNodeRemoval = ( vNode ) : void => { removedNodes . push ( vNode ) ; if ( ! requestedIdleCallback ) { requestedIdleCallback = true ; if ( typeof window !== 's' && 's' in window ) { window . requestIdleCallback ( processPendingNodeRemovals , { timeout : 0 } ) ; } else { setTimeout ( processPendingNodeRemovals , 0 ) ; } } } ; let nodeToRemove = ( vNode ) => { let domNode = vNode . domNode ! ; if ( vNode . properties ) { let exitAnimation = vNode . properties . exitAnimation ; if ( exitAnimation ) { ( domNode as HTMLElement ) . style . pointerEvents = 's' ; let removeDomNode = ( ) => { if ( domNode . parentNode ) { domNode . parentNode . removeChild ( domNode ) ; scheduleNodeRemoval ( vNode ) ; } } ; exitAnimation ( domNode as Element , removeDomNode , vNode . properties ) ; return ; } } if ( domNode . parentNode ) { domNode . parentNode . removeChild ( domNode ) ; scheduleNodeRemoval ( vNode ) ; } } ; let setProperties = ( domNode , properties : VNodeProperties | undefined , projectionOptions ) => { if ( ! properties ) { return ; } let eventHandlerInterceptor = projectionOptions . eventHandlerInterceptor ; let propNames = Object . keys ( properties ) ; let propCount = propNames . length ; for ( let i = 0 ; i < propCount ; i ++ ) { let propName = propNames [ i ] ; let propValue = properties [ propName ] ; if ( propName === 's' ) { throw new Error ( 's' ) ; } else if ( propName === 's' ) { toggleClasses ( domNode as HTMLElement , propValue as string , true ) ; } else if ( propName === 's' ) { let classNames = Object . keys ( propValue ) ; let classNameCount = classNames . length ; for ( let j = 0 ; j < classNameCount ; j ++ ) { let className = classNames [ j ] ; if ( propValue [ className ] ) { ( domNode as Element ) . classList . add ( className ) ; } } } else if ( propName === 's' ) { let styleNames = Object . keys ( propValue ) ; let styleCount = styleNames . length ; for ( let j = 0 ; j < styleCount ; j ++ ) { let styleName = styleNames [ j ] ; let styleValue = propValue [ styleName ] ; if ( styleValue ) { checkStyleValue ( styleValue ) ; projectionOptions . styleApplyer ! ( < HTMLElement > domNode , styleName , styleValue ) ; } } } else if ( propName !== 's' && propValue !== null && propValue !== undefined ) { let type = typeof propValue ; if ( type === 's' ) { if ( propName . lastIndexOf ( 's' , 0 ) === 0 ) { if ( eventHandlerInterceptor ) { propValue = eventHandlerInterceptor ( propName , propValue , domNode , properties ) ; } if ( propName === 's' ) { ( function ( ) { let oldPropValue = propValue ; propValue = function ( this , evt ) { oldPropValue . apply ( this , [ evt ] ) ; ( evt . target as any ) [ 's' ] = ( evt . target as HTMLInputElement ) . value ; } ; } ( ) ) ; } ( domNode as any ) [ propName ] = propValue ; } } else if ( projectionOptions . namespace === NAMESPACE_SVG ) { if ( propName === 's' ) { ( domNode as Element ) . setAttributeNS ( NAMESPACE_XLINK , propName , propValue ) ; } else { ( domNode as Element ) . setAttribute ( propName , propValue ) ; } } else if ( type === 's' && propName !== 's' && propName !== 's' ) { ( domNode as Element ) . setAttribute ( propName , propValue ) ; } else { ( domNode as any ) [ propName ] = propValue ; } } } } ; let addChildren = ( domNode , children : VNode [ ] | undefined , projectionOptions ) => { if ( ! children ) { return ; } for ( let child of children ) { createDom ( child , domNode , undefined , projectionOptions ) ; } } ; export let initPropertiesAndChildren = ( domNode , vnode , projectionOptions ) => { addChildren ( domNode , vnode . children , projectionOptions ) ; if ( vnode . text ) { domNode . textContent = vnode . text ; } setProperties ( domNode , vnode . properties , projectionOptions ) ; if ( vnode . properties && vnode . properties . afterCreate ) { vnode . properties . afterCreate . apply ( vnode . properties . bind || vnode . properties , [ domNode as Element , projectionOptions , vnode . vnodeSelector , vnode . properties , vnode . children ] ) ; } } ; export let createDom = ( vnode , parentNode , insertBefore : Node | null | undefined , projectionOptions ) : void => { let domNode : Node | undefined ; let start = 0 ; let vnodeSelector = vnode . vnodeSelector ; let doc = parentNode . ownerDocument ! ; if ( vnodeSelector === 's' ) { domNode = vnode . domNode = doc . createTextNode ( vnode . text ! ) ; if ( insertBefore !== undefined ) { parentNode . insertBefore ( domNode , insertBefore ) ; } else { parentNode . appendChild ( domNode ) ; } } else { for ( let i = 0 ; i <= vnodeSelector . length ; ++ i ) { let c = vnodeSelector . charAt ( i ) ; if ( i === vnodeSelector . length || c === 's' || c === 's' ) { let type = vnodeSelector . charAt ( start - 0 ) ; let found = vnodeSelector . slice ( start , i ) ; if ( type === 's' ) { ( domNode ! as HTMLElement ) . classList . add ( found ) ; } else if ( type === 's' ) { ( domNode ! as Element ) . id = found ; } else { if ( found === 's' ) { projectionOptions = extend ( projectionOptions , { namespace : NAMESPACE_SVG } ) ; } if ( projectionOptions . namespace !== undefined ) { domNode = vnode . domNode = doc . createElementNS ( projectionOptions . namespace , found ) ; } else { domNode = vnode . domNode = ( vnode . domNode || doc . createElement ( found ) ) ; if ( found === 's' && vnode . properties && vnode . properties . type !== undefined ) { ( domNode as Element ) . setAttribute ( 's' , vnode . properties . type ) ; } } if ( insertBefore !== undefined ) { parentNode . insertBefore ( domNode , insertBefore ) ; } else if ( domNode . parentNode !== parentNode ) { parentNode . appendChild ( domNode ) ; } } start = i + 0 ; } } initPropertiesAndChildren ( domNode ! , vnode , projectionOptions ) ; } } ; let updateDom : ( previous , vnode , projectionOptions ) => boolean ; let toggleClasses = ( domNode , classes : string | null | undefined , on ) => { if ( ! classes ) { return ; } classes . split ( 's' ) . forEach ( classToToggle => { if ( classToToggle ) { domNode . classList . toggle ( classToToggle , on ) ; } } ) ; } ; let updateProperties = ( domNode , previousProperties : VNodeProperties | undefined , properties : VNodeProperties | undefined , projectionOptions ) => { if ( ! properties ) { return ; } let propertiesUpdated = false ; let propNames = Object . keys ( properties ) ; let propCount = propNames . length ; for ( let i = 0 ; i < propCount ; i ++ ) { let propName = propNames [ i ] ; let propValue = properties [ propName ] ; let previousValue = previousProperties ! [ propName ] ; if ( propName === 's' ) { if ( previousValue !== propValue ) { toggleClasses ( domNode as HTMLElement , previousValue , false ) ; toggleClasses ( domNode as HTMLElement , propValue , true ) ; } } else if ( propName === 's' ) { let classList = ( domNode as Element ) . classList ; let classNames = Object . keys ( propValue ) ; let classNameCount = classNames . length ; for ( let j = 0 ; j < classNameCount ; j ++ ) { let className = classNames [ j ] ; let on = ! ! propValue [ className ] ; let previousOn = ! ! previousValue [ className ] ; if ( on === previousOn ) { continue ; } propertiesUpdated = true ; if ( on ) { classList . add ( className ) ; } else { classList . remove ( className ) ; } } } else if ( propName === 's' ) { let styleNames = Object . keys ( propValue ) ; let styleCount = styleNames . length ; for ( let j = 0 ; j < styleCount ; j ++ ) { let styleName = styleNames [ j ] ; let newStyleValue = propValue [ styleName ] ; let oldStyleValue = previousValue [ styleName ] ; if ( newStyleValue === oldStyleValue ) { continue ; } propertiesUpdated = true ; if ( newStyleValue ) { checkStyleValue ( newStyleValue ) ; projectionOptions . styleApplyer ! ( domNode as HTMLElement , styleName , newStyleValue ) ; } else { projectionOptions . styleApplyer ! ( domNode as HTMLElement , styleName , 's' ) ; } } } else { if ( ! propValue && typeof previousValue === 's' ) { propValue = 's' ; } if ( propName === 's' ) { let domValue = ( domNode as any ) [ propName ] ; if ( domValue !== propValue && ( ( domNode as any ) [ 's' ] ? domValue === ( domNode as any ) [ 's' ] : propValue !== previousValue ) ) { ( domNode as any ) [ propName ] = propValue ; ( domNode as any ) [ 's' ] = undefined ; } if ( propValue !== previousValue ) { propertiesUpdated = true ; } } else if ( propValue !== previousValue ) { let type = typeof propValue ; if ( type !== 's' || ! projectionOptions . eventHandlerInterceptor ) { if ( projectionOptions . namespace === NAMESPACE_SVG ) { if ( propName === 's' ) { ( domNode as Element ) . setAttributeNS ( NAMESPACE_XLINK , propName , propValue ) ; } else { ( domNode as Element ) . setAttribute ( propName , propValue ) ; } } else if ( type === 's' && propName !== 's' ) { if ( propName === 's' && propValue === 's' ) { ( domNode as any ) . removeAttribute ( propName ) ; } else { ( domNode as Element ) . setAttribute ( propName , propValue ) ; } } else if ( ( domNode as any ) [ propName ] !== propValue ) { ( domNode as any ) [ propName ] = propValue ; } propertiesUpdated = true ; } } } } return propertiesUpdated ; } ; let updateChildren = ( vnode , domNode , oldChildren : VNode [ ] | undefined , newChildren : VNode [ ] | undefined , projectionOptions ) => { if ( oldChildren === newChildren ) { return false ; } oldChildren = oldChildren || emptyArray ; newChildren = newChildren || emptyArray ; let oldChildrenLength = oldChildren . length ; let newChildrenLength = newChildren . length ; let oldIndex = 0 ; let newIndex = 0 ; let i ; let textUpdated = false ; while ( newIndex < newChildrenLength ) { let oldChild = ( oldIndex < oldChildrenLength ) ? oldChildren [ oldIndex ] : undefined ; let newChild = newChildren [ newIndex ] ; if ( oldChild !== undefined && same ( oldChild , newChild ) ) { textUpdated = updateDom ( oldChild , newChild , projectionOptions ) || textUpdated ; oldIndex ++ ; } else { let findOldIndex = findIndexOfChild ( oldChildren , newChild , oldIndex + 0 ) ; if ( findOldIndex >= 0 ) { for ( i = oldIndex ; i < findOldIndex ; i ++ ) { nodeToRemove ( oldChildren [ i ] ) ; checkDistinguishable ( oldChildren , i , vnode , 's' ) ; } textUpdated = updateDom ( oldChildren [ findOldIndex ] , newChild , projectionOptions ) || textUpdated ; oldIndex = findOldIndex + 0 ; } else { createDom ( newChild , domNode , ( oldIndex < oldChildrenLength ) ? oldChildren [ oldIndex ] . domNode : undefined , projectionOptions ) ; nodeAdded ( newChild ) ; checkDistinguishable ( newChildren , newIndex , vnode , 's' ) ; } } newIndex ++ ; } if ( oldChildrenLength > oldIndex ) { for ( i = oldIndex ; i < oldChildrenLength ; i ++ ) { nodeToRemove ( oldChildren [ i ] ) ; checkDistinguishable ( oldChildren , i , vnode , 's' ) ; } } return textUpdated ; } ; updateDom = ( previous , vnode , projectionOptions ) => { let domNode = previous . domNode ! ; let textUpdated = false ; if ( previous === vnode ) { return false ; } let updated = false ; if ( vnode . vnodeSelector === 's' ) { if ( vnode . text !== previous . text ) { let newTextNode = domNode . ownerDocument ! . createTextNode ( vnode . text ! ) ; domNode . parentNode ! . replaceChild ( newTextNode , domNode ) ; vnode . domNode = newTextNode ; textUpdated = true ; return textUpdated ; } vnode . domNode = domNode ; } else { if ( vnode . vnodeSelector . lastIndexOf ( 's' , 0 ) === 0 ) { projectionOptions = extend ( projectionOptions , { namespace : NAMESPACE_SVG } ) ; } if ( previous . text !== vnode . text ) { updated = true ; if ( vnode . text === undefined ) { domNode . removeChild ( domNode . firstChild ! ) ; } else { domNode . textContent = vnode . text ; } } vnode . domNode = domNode ; updated = updateChildren ( vnode , domNode , previous . children , vnode . children , projectionOptions ) || updated ; updated = updateProperties ( domNode , previous . properties , vnode . properties , projectionOptions ) || updated ; if ( vnode . properties && vnode . properties . afterUpdate ) { vnode . properties . afterUpdate . apply ( vnode . properties . bind || vnode . properties , [ < Element > domNode , projectionOptions , vnode . vnodeSelector , vnode . properties , vnode . children ] ) ; } } if ( updated && vnode . properties && vnode . properties . updateAnimation ) { vnode . properties . updateAnimation ( < Element > domNode , vnode . properties , previous . properties ) ; } return textUpdated ; } ; export let createProjection = ( vnode , projectionOptions ) : Projection => { return { getLastRender : ( ) => vnode , update : ( updatedVnode ) => { if ( vnode . vnodeSelector !== updatedVnode . vnodeSelector ) { throw new Error ( 's' ) ; } let previousVNode = vnode ; vnode = updatedVnode ; updateDom ( previousVNode , updatedVnode , projectionOptions ) ; } , domNode : < Element > vnode . domNode } ; } ;	O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $string$ O O O O $string$ O O O O $VNode[]$ O O $any$ O O O O O O O O $T$ O O $any$ O O $T$ O $any$ O $any$ O O $any$ O O O $any$ O O O O O O $ObjectConstructor$ O $complex$ O $T$ O O $void$ O O $string$ O O O $any$ O $string$ O O O $T$ O O O O $string$ O O O O O O O $any$ O O $ObjectConstructor$ O $complex$ O $any$ O O $void$ O O $string$ O O O $any$ O $string$ O O $any$ O $string$ O O O O O O O $any$ O O O O O O O $VNode$ O $VNode$ O O O O O $VNode$ O $string$ O $VNode$ O $string$ O O O O O O O O $VNode$ O $VNodeProperties$ O $VNode$ O $VNodeProperties$ O O O O $VNode$ O $VNodeProperties$ O $Object$ O $VNode$ O $VNodeProperties$ O $Object$ O O O O O O O $VNode$ O $VNodeProperties$ O $object$ O $VNode$ O $VNodeProperties$ O $object$ O O O O $VNode$ O $VNodeProperties$ O O $VNode$ O $VNodeProperties$ O O O O $void$ O O $Object$ O O O O O O $Object$ O O O O O O $ErrorConstructor$ O O O O O O O O $number$ O O $VNode[]$ O $any$ O O O $VNode$ O $number$ O O O O O $VNode$ O $string$ O O O O O O O $number$ O $number$ O $number$ O $VNode[]$ O $number$ O $number$ O O O O O O O $VNode[]$ O $number$ O O $VNode$ O O O O $number$ O O O O O O O O O O O $void$ O O $VNode[]$ O $any$ O O O $number$ O $VNode$ O $string$ O O O O $VNode$ O $VNode[]$ O $number$ O O O O $VNode$ O $string$ O O O O O O O O $VNodeProperties$ O $VNode$ O $VNodeProperties$ O O $object$ O $VNodeProperties$ O O $VNodeProperties$ O $Object$ O $undefined$ O $VNodeProperties$ O $object$ O $VNodeProperties$ O $Object$ O O $undefined$ O O O O $object$ O O O O O $number$ O O O $number$ O $VNode[]$ O $number$ O $number$ O O O O O $number$ O $number$ O O O $VNode$ O $VNode[]$ O $number$ O O O O O O $VNode$ O $VNode$ O O O O O $ErrorConstructor$ O O O O O O O O O O O $void$ O O $VNode$ O O O O O $VNode$ O $VNodeProperties$ O O O $void$ O $VNode$ O $VNodeProperties$ O $void$ O O O $void$ O O $void$ O $VNode$ O $Node$ O $complex$ O $VNode$ O $VNodeProperties$ O O O O O O O $VNode[]$ O $any$ O O O O O O O $boolean$ O O O O $void$ O O $VNode$ O O O O $VNode$ O $VNode[]$ O O O O O $void$ O $void$ O O O O $VNode$ O $VNodeProperties$ O $VNode$ O $VNodeProperties$ O $void$ O O $VNode$ O $VNodeProperties$ O $void$ O $any$ O $VNode$ O $VNodeProperties$ O $object$ O $VNode$ O $VNodeProperties$ O O O $complex$ O $VNode$ O $Node$ O O O O O O O $void$ O O O O O O O $boolean$ O O O $VNode[]$ O $void$ O $void$ O O $VNode[]$ O $number$ O O O O O O $void$ O O $VNode$ O O O O O $VNode[]$ O $number$ O $VNode$ O O O O O $boolean$ O O $boolean$ O O O O O O $complex$ O O O O O $complex$ O O $complex$ O $number$ O $void$ O O $number$ O O O O O O O O $number$ O $void$ O O O O O O O O O $void$ O O $VNode$ O O O O $Node$ O $VNode$ O $Node$ O O O O $VNode$ O $VNodeProperties$ O O O $void$ O $VNode$ O $VNodeProperties$ O $void$ O O O $void$ O O O $Node$ O $complex$ O O $CSSStyleDeclaration$ O $string$ O O O O $void$ O O O O O O O $Node$ O $complex$ O O $Node$ O $complex$ O $T$ O $Node$ O O $void$ O $VNode$ O O O O O $void$ O $Node$ O $complex$ O $void$ O $VNode$ O $VNodeProperties$ O O O O O O O O $Node$ O $complex$ O O $Node$ O $complex$ O $T$ O $Node$ O O $void$ O $VNode$ O O O O O O $void$ O O $Node$ O $VNodeProperties$ O $any$ O O O $ProjectionOptions$ O O O O O O $VNodeProperties$ O O O O O O $EventHandlerInterceptor$ O $ProjectionOptions$ O $EventHandlerInterceptor$ O O $string[]$ O $ObjectConstructor$ O $complex$ O $VNodeProperties$ O O O $number$ O $string[]$ O $number$ O O O O $number$ O O O $number$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O $any$ O $VNodeProperties$ O $string$ O O O O $string$ O O O O O O $ErrorConstructor$ O O O O O O O O $string$ O O O O $void$ O $Node$ O $complex$ O $any$ O O O O O O O O O O $string$ O O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $any$ O O O $number$ O $string[]$ O $number$ O O O O $number$ O O O $number$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O O $any$ O $string$ O O O O $Node$ O $complex$ O O $DOMTokenList$ O $void$ O $string$ O O O O O O O O $string$ O O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $any$ O O O $number$ O $string[]$ O $number$ O O O O $number$ O O O $number$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O $any$ O $any$ O $string$ O O O O $any$ O O $void$ O $any$ O O $ProjectionOptions$ O $void$ O O O $complex$ O $Node$ O $string$ O $any$ O O O O O O O O $string$ O O O $any$ O O O $any$ O $undefined$ O O O O O O $any$ O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O $EventHandlerInterceptor$ O O $any$ O $EventHandlerInterceptor$ O $string$ O $any$ O $Node$ O $VNodeProperties$ O O O O O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O O O $HTMLElement$ O $Event$ O O $any$ O $any$ O O O O $Event$ O O O O $Event$ O $EventTarget$ O O O O O O O O $Event$ O $EventTarget$ O $complex$ O O $string$ O O O O O O O O O O $Node$ O O O O $string$ O O $any$ O O O O O O $ProjectionOptions$ O $string$ O $string$ O O O O $string$ O O O O O $Node$ O $complex$ O O $void$ O $string$ O O O $any$ O O O O O O $Node$ O $complex$ O O $void$ O $string$ O $any$ O O O O O O O O O O O $string$ O O O $string$ O O O O O $Node$ O $complex$ O O $void$ O $string$ O $any$ O O O O O O $Node$ O O O O $string$ O O $any$ O O O O O O O $void$ O O $Node$ O $VNode[]$ O $any$ O O O O O $ProjectionOptions$ O O O O O O $VNode[]$ O O O O O O O O $VNode$ O $VNode[]$ O O $void$ O $VNode$ O $Node$ O $undefined$ O $ProjectionOptions$ O O O O O O O $void$ O O $Node$ O $VNode$ O $ProjectionOptions$ O O O $void$ O $Node$ O $VNode$ O $VNode[]$ O $ProjectionOptions$ O O O O $VNode$ O $string$ O O $Node$ O $string$ O $VNode$ O $string$ O O $void$ O $Node$ O $VNode$ O $VNodeProperties$ O $ProjectionOptions$ O O O O $VNode$ O $VNodeProperties$ O $VNode$ O $VNodeProperties$ O $void$ O O $VNode$ O $VNodeProperties$ O $void$ O $any$ O $VNode$ O $VNodeProperties$ O $object$ O $VNode$ O $VNodeProperties$ O O $Node$ O $complex$ O $ProjectionOptions$ O $VNode$ O $string$ O $VNode$ O $VNodeProperties$ O $VNode$ O $VNode[]$ O O O O O O O O $void$ O O $VNode$ O $Node$ O $Node$ O O O O O O O $ProjectionOptions$ O O O O O O $Node$ O O O O O O $number$ O O O O $string$ O $VNode$ O $string$ O O $Document$ O $Node$ O $Document$ O O O O $string$ O O O O $Node$ O $VNode$ O $Node$ O $Document$ O $Text$ O $VNode$ O $string$ O O O O O $Node$ O $undefined$ O O $Node$ O $T$ O $Node$ O $Node$ O O O O O $Node$ O $T$ O $Node$ O O O O O O O O O $number$ O O O $number$ O $string$ O $number$ O O $number$ O O O $string$ O $string$ O $string$ O $number$ O O O O $number$ O $string$ O $number$ O $string$ O O O $string$ O O O O O $string$ O $string$ O $string$ O $number$ O O O O O $string$ O $string$ O $string$ O $number$ O $number$ O O O O $string$ O O O O O $Node$ O O $complex$ O O $DOMTokenList$ O $void$ O $string$ O O O O O O $string$ O O O O O $Node$ O O $complex$ O O $string$ O $string$ O O O O O O $string$ O O O O $ProjectionOptions$ O $T$ O $ProjectionOptions$ O O $string$ O $string$ O O O O O O $ProjectionOptions$ O $string$ O $undefined$ O O $Node$ O $VNode$ O $Node$ O $Document$ O O O $ProjectionOptions$ O $string$ O $string$ O O O O O $Node$ O $VNode$ O $Node$ O O $VNode$ O $Node$ O $Document$ O O O $string$ O O O O O $string$ O O O $VNode$ O $VNodeProperties$ O $VNode$ O $VNodeProperties$ O $string$ O $undefined$ O O O $Node$ O $complex$ O O $void$ O O O $VNode$ O $VNodeProperties$ O $string$ O O O O O O $Node$ O $undefined$ O O $Node$ O $T$ O $Node$ O $Node$ O O O O O O $Node$ O $complex$ O $Node$ O O $Node$ O $T$ O $Node$ O O O O $number$ O $number$ O O O O O $void$ O $Node$ O O $VNode$ O $ProjectionOptions$ O O O O O O $boolean$ O O $VNode$ O $VNode$ O $ProjectionOptions$ O O O O O $void$ O O $HTMLElement$ O $string$ O O O O O O O $boolean$ O O O O O O $string$ O O O O O $string$ O $complex$ O O O O $void$ O $string$ O O O O $string$ O O $HTMLElement$ O $DOMTokenList$ O $boolean$ O $string$ O $boolean$ O O O O O O O O O $boolean$ O O $Node$ O $VNodeProperties$ O $any$ O O O $VNodeProperties$ O $any$ O O O $ProjectionOptions$ O O O O O O $VNodeProperties$ O O O O O O $boolean$ O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $VNodeProperties$ O O O $number$ O $string[]$ O $number$ O O O O $number$ O O O $number$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O $any$ O $VNodeProperties$ O $string$ O O O $any$ O $VNodeProperties$ O O $string$ O O O O $string$ O O O O O O $any$ O $any$ O O $void$ O $Node$ O $complex$ O $any$ O O O O $void$ O $Node$ O $complex$ O $any$ O O O O O O O O O $string$ O O O O O $DOMTokenList$ O O $Node$ O $complex$ O O $DOMTokenList$ O O $string[]$ O $ObjectConstructor$ O $complex$ O $any$ O O O $number$ O $string[]$ O $number$ O O O O $number$ O O O $number$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O $boolean$ O O O $any$ O $string$ O O O $boolean$ O O O $any$ O $string$ O O O O $boolean$ O $boolean$ O O O O O $boolean$ O O O O O $boolean$ O O $DOMTokenList$ O $void$ O $string$ O O O O O $DOMTokenList$ O $void$ O $string$ O O O O O O O O $string$ O O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $any$ O O O $number$ O $string[]$ O $number$ O O O O $number$ O O O $number$ O $number$ O $number$ O O O O $string$ O $string[]$ O $number$ O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O $string$ O O O O $any$ O $any$ O O O O O $boolean$ O O O O O $any$ O O $void$ O $any$ O O $ProjectionOptions$ O $void$ O O $Node$ O $complex$ O $string$ O $any$ O O O O O $ProjectionOptions$ O $void$ O O $Node$ O $complex$ O $string$ O O O O O O O O O O O O $any$ O O $any$ O O O O $any$ O O O O O O $string$ O O O O O $any$ O O $Node$ O O O O O O O O O $any$ O $any$ O O O $Node$ O O O O O O O $any$ O O $Node$ O O O O O O O $any$ O $any$ O O O O $Node$ O O O O O O O $any$ O O $Node$ O O O O O O O $undefined$ O O O O $any$ O $any$ O O $boolean$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $ProjectionOptions$ O $EventHandlerInterceptor$ O O O O $ProjectionOptions$ O $string$ O $string$ O O O O $string$ O O O O O $Node$ O $complex$ O O $void$ O $string$ O O O $any$ O O O O O O $Node$ O $complex$ O O $void$ O $string$ O $any$ O O O O O O O O O O O $string$ O O O O O O $string$ O O O $any$ O O O O O $Node$ O O O O $any$ O O O O O O O O $Node$ O $complex$ O O $void$ O $string$ O $any$ O O O O O O O O $Node$ O O O O $string$ O O $any$ O O O $Node$ O O O O $string$ O O $any$ O O $boolean$ O O O O O O O O $boolean$ O O O O $boolean$ O O $VNode$ O $Node$ O $VNode[]$ O $any$ O O O O O $VNode[]$ O $any$ O O O O O $ProjectionOptions$ O O O O O $VNode[]$ O $VNode[]$ O O O O O O $VNode[]$ O $VNode[]$ O $VNode[]$ O $VNode[]$ O $VNode[]$ O $VNode[]$ O O $number$ O $VNode[]$ O $number$ O O $number$ O $VNode[]$ O $number$ O O $number$ O O O O $number$ O O O O $number$ O O $boolean$ O O O O O $number$ O $number$ O O O $VNode$ O O $number$ O $number$ O O $VNode[]$ O $number$ O O $undefined$ O O $VNode$ O $VNode[]$ O $number$ O O O O $VNode$ O $undefined$ O O O $VNode$ O $VNode$ O O O $boolean$ O $boolean$ O $VNode$ O $VNode$ O $ProjectionOptions$ O O $boolean$ O $number$ O O O O O O $number$ O $number$ O $VNode[]$ O $VNode$ O $number$ O O O O O O $number$ O O O O O O $number$ O $number$ O $number$ O $number$ O $number$ O O O $void$ O $VNode[]$ O $number$ O O O $void$ O $VNode[]$ O $number$ O $VNode$ O O O O O $boolean$ O $boolean$ O $VNode[]$ O $number$ O O $VNode$ O $ProjectionOptions$ O O $boolean$ O $number$ O $number$ O O O O O O $void$ O $VNode$ O $Node$ O O $number$ O $number$ O O $VNode[]$ O $number$ O O $Node$ O $undefined$ O $ProjectionOptions$ O O $void$ O $VNode$ O O $void$ O $VNode[]$ O $number$ O $VNode$ O O O O O O $number$ O O O O O $number$ O $number$ O O O O $number$ O $number$ O $number$ O $number$ O $number$ O O O $void$ O $VNode[]$ O $number$ O O O $void$ O $VNode[]$ O $number$ O $VNode$ O O O O O O O $boolean$ O O O $boolean$ O O $VNode$ O $VNode$ O $ProjectionOptions$ O O O O $Node$ O $VNode$ O $Node$ O O O $boolean$ O O O O O $VNode$ O $VNode$ O O O O O O O $boolean$ O O O O O $VNode$ O $string$ O O O O O O $VNode$ O $string$ O $VNode$ O $string$ O O O $Text$ O $Node$ O $Document$ O O $Text$ O $VNode$ O $string$ O O O $Node$ O $complex$ O O $T$ O $Text$ O $Node$ O O $VNode$ O $Node$ O $Text$ O $boolean$ O O O O $true$ O O $VNode$ O $Node$ O $Node$ O O O O O O $VNode$ O $string$ O $number$ O O O O O O O O O $ProjectionOptions$ O $T$ O $ProjectionOptions$ O O $string$ O $string$ O O O O O O $VNode$ O $string$ O $VNode$ O $string$ O O $boolean$ O O O O O $VNode$ O $string$ O $undefined$ O O $Node$ O $T$ O $Node$ O $ChildNode$ O O O O O O $Node$ O $string$ O $VNode$ O $string$ O O O $VNode$ O $Node$ O $Node$ O $boolean$ O $boolean$ O $VNode$ O $Node$ O $VNode$ O $VNode[]$ O $VNode$ O $VNode[]$ O $ProjectionOptions$ O O $boolean$ O $boolean$ O $boolean$ O $Node$ O $VNode$ O $VNodeProperties$ O $VNode$ O $VNodeProperties$ O $ProjectionOptions$ O O $boolean$ O O O $VNode$ O $VNodeProperties$ O $VNode$ O $VNodeProperties$ O $void$ O O $VNode$ O $VNodeProperties$ O $void$ O $any$ O $VNode$ O $VNodeProperties$ O $object$ O $VNode$ O $VNodeProperties$ O O O $complex$ O $Node$ O $ProjectionOptions$ O $VNode$ O $string$ O $VNode$ O $VNodeProperties$ O $VNode$ O $VNode[]$ O O O O O O O $boolean$ O $VNode$ O $VNodeProperties$ O $VNode$ O $VNodeProperties$ O $void$ O O $VNode$ O $VNodeProperties$ O $void$ O O $complex$ O $Node$ O $VNode$ O $VNodeProperties$ O $VNode$ O $VNodeProperties$ O O O O $false$ O O O O O $Projection$ O O $VNode$ O $ProjectionOptions$ O O $any$ O O O O $VNode$ O O O O $VNode$ O $void$ O O $VNode$ O O O O O $VNode$ O $string$ O $VNode$ O $string$ O O O O $ErrorConstructor$ O O O O O O $VNode$ O $VNode$ O $VNode$ O $VNode$ O $boolean$ O $VNode$ O $VNode$ O $ProjectionOptions$ O O O O $Element$ O O $complex$ O $VNode$ O $Node$ O O O O
import { Projection , ProjectionOptions , VNode } from 's' ; import { createDom , createProjection , extend , initPropertiesAndChildren } from 's' ; const DEFAULT_PROJECTION_OPTIONS = { namespace : undefined , performanceLogger : ( ) => undefined , eventHandlerInterceptor : undefined , styleApplyer : ( domNode , styleName , value ) => { ( domNode . style as any ) [ styleName ] = value ; } } ; export let applyDefaultProjectionOptions = ( projectorOptions ? ) => { return extend ( DEFAULT_PROJECTION_OPTIONS , projectorOptions ) ; } ; export let dom = { create : ( vnode , projectionOptions ? ) : Projection => { projectionOptions = applyDefaultProjectionOptions ( projectionOptions ) ; createDom ( vnode , document . createElement ( 's' ) , undefined , projectionOptions ) ; return createProjection ( vnode , projectionOptions ) ; } , append : ( parentNode , vnode , projectionOptions ? ) : Projection => { projectionOptions = applyDefaultProjectionOptions ( projectionOptions ) ; createDom ( vnode , parentNode , undefined , projectionOptions ) ; return createProjection ( vnode , projectionOptions ) ; } , insertBefore : ( beforeNode , vnode , projectionOptions ? ) : Projection => { projectionOptions = applyDefaultProjectionOptions ( projectionOptions ) ; createDom ( vnode , beforeNode . parentNode ! , beforeNode , projectionOptions ) ; return createProjection ( vnode , projectionOptions ) ; } , merge : ( element , vnode , projectionOptions ? ) : Projection => { projectionOptions = applyDefaultProjectionOptions ( projectionOptions ) ; vnode . domNode = element ; initPropertiesAndChildren ( element , vnode , projectionOptions ) ; return createProjection ( vnode , projectionOptions ) ; } , replace : ( element , vnode , projectionOptions ? ) : Projection => { projectionOptions = applyDefaultProjectionOptions ( projectionOptions ) ; createDom ( vnode , element . parentNode ! , element , projectionOptions ) ; element . parentNode ! . removeChild ( element ) ; return createProjection ( vnode , projectionOptions ) ; } } ;	O O $any$ O $any$ O $any$ O O O O O O $void$ O $Projection$ O $T$ O $void$ O O O O O $ProjectionOptions$ O O $undefined$ O $undefined$ O $any$ O O O O $undefined$ O $undefined$ O $undefined$ O $void$ O O $HTMLElement$ O $string$ O $string$ O O O O $HTMLElement$ O $CSSStyleDeclaration$ O O O O $string$ O O $string$ O O O O O O $ProjectionOptions$ O O $ProjectionOptions$ $ProjectionOptions$ O O O O $T$ O $ProjectionOptions$ O $ProjectionOptions$ O O O O O O $complex$ O O $Projection$ O O $VNode$ O $ProjectionOptions$ $ProjectionOptions$ O O $any$ O O $ProjectionOptions$ O $ProjectionOptions$ O $ProjectionOptions$ O O $void$ O $VNode$ O $Document$ O O O O O O $undefined$ O $ProjectionOptions$ O O O $Projection$ O $VNode$ O $ProjectionOptions$ O O O O $Projection$ O O $Element$ O $VNode$ O $ProjectionOptions$ $ProjectionOptions$ O O $any$ O O $ProjectionOptions$ O $ProjectionOptions$ O $ProjectionOptions$ O O $void$ O $VNode$ O $Element$ O $undefined$ O $ProjectionOptions$ O O O $Projection$ O $VNode$ O $ProjectionOptions$ O O O O $Projection$ O O $Element$ O $VNode$ O $ProjectionOptions$ $ProjectionOptions$ O O $any$ O O $ProjectionOptions$ O $ProjectionOptions$ O $ProjectionOptions$ O O $void$ O $VNode$ O $Element$ O $complex$ O O $Element$ O $ProjectionOptions$ O O O $Projection$ O $VNode$ O $ProjectionOptions$ O O O O $Projection$ O O $Element$ O $VNode$ O $ProjectionOptions$ $ProjectionOptions$ O O $any$ O O $ProjectionOptions$ O $ProjectionOptions$ O $ProjectionOptions$ O O $VNode$ O $Node$ O $Element$ O $void$ O $Element$ O $VNode$ O $ProjectionOptions$ O O O $Projection$ O $VNode$ O $ProjectionOptions$ O O O O $Projection$ O O $Element$ O $VNode$ O $ProjectionOptions$ $ProjectionOptions$ O O $any$ O O $ProjectionOptions$ O $ProjectionOptions$ O $ProjectionOptions$ O O $void$ O $VNode$ O $Element$ O $complex$ O O $Element$ O $ProjectionOptions$ O O $Element$ O $complex$ O O $T$ O $Element$ O O O $Projection$ O $VNode$ O $ProjectionOptions$ O O O O O
import { MaquetteComponent , VNode } from 's' ; import { h } from 's' ; import { createMapping } from 's' ; import { dom } from 's' ; const version = 's' ; let createTableCell = ( text ) : MaquetteComponent => { let handleClick = ( evt ) => { console . log ( 's' , { text } ) ; } ; return { render : ( ) => { return h ( 's' , { key : text , onclick : handleClick } , [ text ] ) ; } } ; } ; interface TableRow extends MaquetteComponent { update ( state ) : void ; } let createTableRow = ( state ) : TableRow => { let firstCell = createTableCell ( `template` ) ; let mapping = createMapping < string , MaquetteComponent > ( text => text , createTableCell , ( ) => undefined ) ; mapping . map ( state . props ) ; return { update : ( newState ) => { mapping . map ( newState . props ) ; } , render : ( ) => { return h ( 's' , { 's' : `template` , key : state . id , classes : { active : state . active } } , [ firstCell . render ( ) , mapping . results . map ( cell => cell . render ( ) ) ] ) ; } } ; } ; interface Table extends MaquetteComponent { update ( state ) : void ; } let createTable = ( state ) : Table => { let mapping = createMapping < TableItemState , TableRow > ( itemState => itemState . id , createTableRow , ( source , target ) => target . update ( source ) ) ; mapping . map ( state . items ) ; return { update : ( newState ) => { state = newState ; mapping . map ( newState . items ) ; } , render : ( ) => { return h ( 's' , [ h ( 's' , mapping . results . map ( row => row . render ( ) ) ) ] ) ; } } ; } ; let renderAnimBox = ( state ) : VNode => { const time = state . time ; return h ( 's' , { 's' : `template` , styles : { background : `template` , borderRadius : `template` } } ) ; } ; let renderAnim = ( state ) : VNode => { const items = state . items ; return h ( 's' , items . map ( item => renderAnimBox ( item ) ) ) ; } ; let renderTreeLeaf = ( state ) : VNode => { return h ( 's' , { key : state . id } , [ `template` ] ) ; } ; let renderTreeNode = ( state ) : VNode => { return h ( 's' , { key : state . id } , state . children . map ( child => { if ( child . container ) { return renderTreeNode ( child ) ; } else { return renderTreeLeaf ( child ) ; } } ) ) ; } ; let renderTree = ( state ) : VNode => { return h ( 's' , [ renderTreeNode ( state . root ) ] ) ; } ; let createMain = ( state : AppState | null ) => { let table : Table | undefined ; let updateTable = ( ) => { if ( ! state || state . location !== 's' ) { table = undefined ; } else { if ( table ) { table . update ( state . table ) ; } else { table = createTable ( state . table ) ; } } } ; updateTable ( ) ; return { update : ( newState ) => { state = newState ; updateTable ( ) ; } , render : ( ) => { let children : ( VNode | null | undefined ) [ ] | undefined ; if ( state ) { switch ( state . location ) { case 's' : children = [ table ! . render ( ) ] ; break ; case 's' : children = [ renderAnim ( state . anim ) ] ; break ; default : children = [ renderTree ( state . tree ) ] ; break ; } } return h ( 's' , children ) ; } } ; } ; document . title = version ; uibench . init ( 's' , version ) ; let main = createMain ( null ) ; document . addEventListener ( 's' , ( ) => { const container = document . querySelector ( 's' ) ! ; let projection = dom . append ( container , main . render ( ) , { } ) ; uibench . run ( ( state ) => { main . update ( state ) ; projection . update ( main . render ( ) ) ; } , ( samples ) => { projection . domNode . remove ( ) ; dom . append ( container , h ( 's' , [ JSON . stringify ( samples , undefined , 0 ) ] ) ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $complex$ O O O O O O $Mapping<...>$ O O O O O O $complex$ O O O O O O O O O O $MaquetteComponent$ O O $string$ O O $any$ O O O $void$ O O $MouseEvent$ O O O $Console$ O $void$ O O O O $string$ O O O O O O O $VNode$ O O O O O O $complex$ O O O O $string$ O $string$ O $void$ O $void$ O O O $string$ O O O O O O O O O $any$ O $any$ O $void$ O $TableItemState$ O O O O O O $TableRow$ O O $TableItemState$ O O $any$ O O O $MaquetteComponent$ O $MaquetteComponent$ O O O O O $complex$ O $Mapping<...>$ O O O $any$ O O $string$ O $string$ O $MaquetteComponent$ O O O O $undefined$ O O $complex$ O $void$ O $TableItemState$ O $string[]$ O O O O $void$ O O $TableItemState$ O O O $complex$ O $void$ O $TableItemState$ O $string[]$ O O O O $VNode$ O O O O O O $complex$ O O O O O O O O $number$ O $TableItemState$ O $number$ O $complex$ O O $boolean$ O $TableItemState$ O $boolean$ O O O O $MaquetteComponent$ O $VNode$ O O O $complex$ O $MaquetteComponent[]$ O $U[]$ O $MaquetteComponent$ O $MaquetteComponent$ O $VNode$ O O O O O O O O O O O O $any$ O $any$ O $void$ O $TableState$ O O O O O O $Table$ O O $TableState$ O O $any$ O O O $complex$ O $Mapping<...>$ O $any$ O $any$ O O $TableItemState$ O $TableItemState$ O $number$ O $TableRow$ O O $TableItemState$ O $TableRow$ O O $TableRow$ O $void$ O $TableItemState$ O O O $complex$ O $void$ O $TableState$ O $TableItemState[]$ O O O O $void$ O O $TableState$ O O O $TableState$ O $TableState$ O $complex$ O $void$ O $TableState$ O $TableItemState[]$ O O O O $VNode$ O O O O O O $complex$ O O O O $complex$ O O O $complex$ O $TableRow[]$ O $U[]$ O $TableRow$ O $TableRow$ O $VNode$ O O O O O O O O O O O O O $VNode$ O O $AnimBoxState$ O O $any$ O O O $number$ O $AnimBoxState$ O $number$ O O $complex$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O O $VNode$ O O $AnimState$ O O $any$ O O O $AnimBoxState[]$ O $AnimState$ O $AnimBoxState[]$ O O $complex$ O O O $AnimBoxState[]$ O $U[]$ O $AnimBoxState$ O $VNode$ O $AnimBoxState$ O O O O O O O $VNode$ O O $TreeNodeState$ O O $any$ O O O $complex$ O O O O $number$ O $TreeNodeState$ O $number$ O O O O O O O O O O $VNode$ O O $TreeNodeState$ O O $any$ O O O $complex$ O O O O $number$ O $TreeNodeState$ O $number$ O O $TreeNodeState$ O $TreeNodeState[]$ O $U[]$ O $TreeNodeState$ O O O O $TreeNodeState$ O $boolean$ O O O $VNode$ O $TreeNodeState$ O O O O O O $VNode$ O $TreeNodeState$ O O O O O O O O O O $VNode$ O O $TreeState$ O O $any$ O O O $complex$ O O O O $VNode$ O $TreeState$ O $TreeNodeState$ O O O O O O O $complex$ O O $AppState$ O $any$ O O O O O O $Table$ O $any$ O O O O $void$ O O O O O O O O $AppState$ O $AppState$ O $string$ O O O O $Table$ O $undefined$ O O O O O O $Table$ O O $Table$ O $void$ O $AppState$ O $TableState$ O O O O O $Table$ O $Table$ O $AppState$ O $TableState$ O O O O O O $void$ O O O O O $void$ O O $AppState$ O O O $AppState$ O $AppState$ O $void$ O O O O O $VNode$ O O O O O O $VNode[]$ O O $any$ O O O O O O O O O O O O $AppState$ O O O O $AppState$ O $string$ O O O O O $VNode[]$ O O $Table$ O O $VNode$ O O O O O O O O O $VNode[]$ O O $VNode$ O $AppState$ O $AnimState$ O O O O O O O $VNode[]$ O O $VNode$ O $AppState$ O $TreeState$ O O O O O O O O $complex$ O O O $VNode[]$ O O O O O O O $Document$ O $string$ O O O $UIBench$ O $void$ O O O O O O O $complex$ O $complex$ O O O O $Document$ O O O O O O O O O O $Element$ O $Document$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $Element$ O $complex$ O $VNode$ O O O O O O O $UIBench$ O $void$ O O $AppState$ O O O $complex$ O $void$ O $AppState$ O O $Projection$ O $void$ O $complex$ O $VNode$ O O O O O O O $any$ O O O $Projection$ O $Element$ O $void$ O O O $complex$ O $Projection$ O $Element$ O $complex$ O O O O $JSON$ O $complex$ O $any$ O $undefined$ O O O O O O O O O O O O O
'js' ( function ( ) { var h = maquette . h ; var newTodoText = "s" ; var todos = [ createTodoComponent ( "s" ) ] ; var handleNewTodoInput = function ( evt ) { newTodoText = evt . target . value ; } ; var handleNewTodoButtonClick = function ( evt ) { evt . preventDefault ( ) ; if ( newTodoText ) { todos . splice ( 0 , 0 , createTodoComponent ( newTodoText ) ) ; newTodoText = "s" ; } } ; var enhanceNewTodoText = function ( ) { return h ( "s" , { value : newTodoText , oninput : handleNewTodoInput } ) ; } ; var enhanceNewTodoButton = function ( ) { return h ( "s" , { type : "s" , onclick : handleNewTodoButtonClick } ) ; } ; var enhanceTodoList = function ( ) { return h ( "s" , [ todos . map ( function ( todo ) { return h ( "s" , { key : todo } , [ todo . render ( ) ] ) ; } ) ] ) ; } ; document . addEventListener ( 's' , function ( ) { var projector = maquette . createProjector ( ) ; projector . merge ( document . getElementById ( "s" ) , enhanceNewTodoText ) ; projector . merge ( document . getElementById ( "s" ) , enhanceNewTodoButton ) ; projector . replace ( document . getElementById ( "s" ) , enhanceTodoList ) ; projector . evaluateHyperscript ( document . body , { todos : todos } ) ; } ) ; } ) ( ) ;	O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O O $any[]$ O O $any$ O O O O O O $void$ O O O $any$ O O $string$ O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O O $any$ O $any$ O O O O O $string$ O O $any[]$ O $complex$ O O O O O $any$ O $string$ O O O $string$ O O O O O O O $any$ O O O O O O $any$ O O O O $string$ O $string$ O $void$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O $string$ O O O $void$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O $any[]$ O $U[]$ O O O $any$ O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O O O O $Document$ O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $Document$ O $HTMLElement$ O O O O $any$ O O $any$ O $any$ O $Document$ O $HTMLElement$ O O O O $any$ O O $any$ O $any$ O $Document$ O $HTMLElement$ O O O O $any$ O O $any$ O $any$ O $Document$ O $HTMLElement$ O O $any[]$ O $any[]$ O O O O O O O O O O O
'js' window . createTodoComponent = function ( message ) { var h = maquette . h ; var completed = false ; var handleCompletedClick = function ( evt ) { evt . preventDefault ( ) ; completed = ! completed ; } ; return { isCompleted : function ( ) { return completed ; } , render : function ( ) { return h ( "s" , [ h ( "s" , [ message ] ) , h ( "s" , { type : "s" , checked : completed , onclick : handleCompletedClick } ) ] ) ; } } ; } ;	O $complex$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O $boolean$ O O O O $void$ O O O $any$ O O $any$ O $any$ O O O $boolean$ O O $boolean$ O O O O O $boolean$ O O O O O O $boolean$ O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O O O $string$ O O O $boolean$ O $boolean$ O $void$ O $void$ O O O O O O O O O O
import { EventHandlerInterceptor , ProjectorPerformanceLogger , Projection , ProjectionOptions , ProjectorOptions , VNode , VNodeProperties , Projector } from 's' ; import { applyDefaultProjectionOptions , dom } from 's' ; let createParentNodePath = ( node , rootNode ) => { let parentNodePath : Node [ ] = [ ] ; while ( node !== rootNode ) { parentNodePath . push ( node ) ; node = node . parentNode ! ; } return parentNodePath ; } ; let find : < T > ( items : T [ ] , predicate : ( item : T ) => boolean ) => T | undefined ; if ( Array . prototype . find ) { find = ( items , predicate ) => items . find ( predicate ) ; } else { find = ( items , predicate ) => items . filter ( predicate ) [ 0 ] ; } let findVNodeByParentNodePath = ( vnode , parentNodePath : Node [ ] ) : VNode | undefined => { let result : VNode | undefined = vnode ; parentNodePath . forEach ( node => { result = ( result && result . children ) ? find ( result . children , child => child . domNode === node ) : undefined ; } ) ; return result ; } ; let createEventHandlerInterceptor = ( projector , getProjection : ( ) => Projection | undefined , performanceLogger ) : EventHandlerInterceptor => { let modifiedEventHandler = function ( this , evt ) { performanceLogger ( 's' , evt ) ; let projection = getProjection ( ) ! ; let parentNodePath = createParentNodePath ( evt . currentTarget as Element , projection . domNode ) ; parentNodePath . reverse ( ) ; let matchingVNode = findVNodeByParentNodePath ( projection . getLastRender ( ) , parentNodePath ) ; projector . scheduleRender ( ) ; let result ; if ( matchingVNode ) { result = matchingVNode . properties ! [ `template` ] . apply ( matchingVNode . properties ! . bind || this , arguments ) ; } performanceLogger ( 's' , evt ) ; return result ; } ; return ( propertyName , eventHandler , domNode , properties ) => modifiedEventHandler ; } ; export let createProjector = ( projectorOptions ? ) : Projector => { let projector ; let projectionOptions = applyDefaultProjectionOptions ( projectorOptions ) ; let performanceLogger = projectionOptions . performanceLogger ! ; let renderCompleted = true ; let scheduled : number | undefined ; let stopped = false ; let projections = [ ] as Projection [ ] ; let renderFunctions = [ ] as ( ( ) => VNode ) [ ] ; let addProjection = ( domFunction : ( node , vnode , projectionOptions ) => Projection , node , renderFunction : ( ) => VNode ) : void => { let projection : Projection | undefined ; let getProjection = ( ) => projection ; projectionOptions . eventHandlerInterceptor = createEventHandlerInterceptor ( projector , getProjection , performanceLogger ) ; projection = domFunction ( node , renderFunction ( ) , projectionOptions ) ; projections . push ( projection ) ; renderFunctions . push ( renderFunction ) ; } ; let doRender = ( ) => { scheduled = undefined ; if ( ! renderCompleted ) { return ; } renderCompleted = false ; performanceLogger ( 's' , undefined ) ; for ( let i = 0 ; i < projections . length ; i ++ ) { let updatedVnode = renderFunctions [ i ] ( ) ; performanceLogger ( 's' , undefined ) ; projections [ i ] . update ( updatedVnode ) ; performanceLogger ( 's' , undefined ) ; } performanceLogger ( 's' , undefined ) ; renderCompleted = true ; } ; projector = { renderNow : doRender , scheduleRender : ( ) => { if ( ! scheduled && ! stopped ) { scheduled = requestAnimationFrame ( doRender ) ; } } , stop : ( ) => { if ( scheduled ) { cancelAnimationFrame ( scheduled ) ; scheduled = undefined ; } stopped = true ; } , resume : ( ) => { stopped = false ; renderCompleted = true ; projector . scheduleRender ( ) ; } , append : ( parentNode , renderFunction ) => { addProjection ( dom . append , parentNode , renderFunction ) ; } , insertBefore : ( beforeNode , renderFunction ) => { addProjection ( dom . insertBefore , beforeNode , renderFunction ) ; } , merge : ( domNode , renderFunction ) => { addProjection ( dom . merge , domNode , renderFunction ) ; } , replace : ( domNode , renderFunction ) => { addProjection ( dom . replace , domNode , renderFunction ) ; } , detach : ( renderFunction ) => { for ( let i = 0 ; i < renderFunctions . length ; i ++ ) { if ( renderFunctions [ i ] === renderFunction ) { renderFunctions . splice ( i , 0 ) ; return projections . splice ( i , 0 ) [ 0 ] ; } } throw new Error ( 's' ) ; } } ; return projector ; } ;	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $ProjectionOptions$ O $complex$ O O O O O $Node[]$ O O $Node$ O $Element$ O O O O $Node[]$ O O O O O O O O O O $Node$ O $Element$ O O $Node[]$ O $number$ O $Node$ O O $Node$ O $Node$ O $complex$ O O O O $Node[]$ O O O O $T$ O O $any$ O O $T[]$ O $any$ O O O $boolean$ O O $T$ O $any$ O O O O O $any$ O O O O O $ArrayConstructor$ O $any[]$ O $complex$ O O $T$ O O $T[]$ O $boolean$ O O $T[]$ O $complex$ O $boolean$ O O O O O $T$ O O $T[]$ O $boolean$ O O $T[]$ O $complex$ O $boolean$ O O O O O O O $VNode$ O O $VNode$ O $Node[]$ O O O O O O $any$ O O O O O $VNode$ O $any$ O O O $VNode$ O $Node[]$ O $void$ O $Node$ O O $VNode$ O O $VNode$ O $VNode$ O $VNode[]$ O O $T$ O $VNode$ O $VNode[]$ O $VNode$ O $VNode$ O $Node$ O $Node$ O O $undefined$ O O O O O $VNode$ O O O O $EventHandlerInterceptor$ O O $Projector$ O $Projection$ O O O O $any$ O O O $ProjectorPerformanceLogger$ O O $any$ O O O $any$ O O O $Node$ O $Event$ O O $ProjectorPerformanceLogger$ O O O $Event$ O O O $Projection$ O $Projection$ O O O O O $Node[]$ O $Node[]$ O $Event$ O $EventTarget$ O $complex$ O $Projection$ O $Element$ O O $Node[]$ O $Node[]$ O O O O $VNode$ O $VNode$ O $Projection$ O $VNode$ O O O $Node[]$ O O $Projector$ O $void$ O O O O $any$ O O O $VNode$ O O $any$ O $VNode$ O $VNodeProperties$ O O O O O $any$ O $VNode$ O $VNodeProperties$ O O $object$ O O O $IArguments$ O O O $ProjectorPerformanceLogger$ O O O $Event$ O O O $any$ O O O O O $string$ O $Function$ O $Node$ O $VNodeProperties$ O O $any$ O O O O O $Projector$ O O $ProjectorOptions$ $ProjectorOptions$ O O $any$ O O O $Projector$ O O $ProjectionOptions$ O $ProjectionOptions$ O $ProjectorOptions$ O O O $ProjectorPerformanceLogger$ O $ProjectionOptions$ O $ProjectorPerformanceLogger$ O O O $boolean$ O O O O $number$ O O O O O O $boolean$ O O O O $Projection[]$ O O O O $any$ O O O O $VNode)[]$ O O O O O O O O $any$ O O O O O $void$ O O $Projection$ O O $Element$ O $VNode$ O $ProjectionOptions$ O O $any$ O $Element$ O $VNode$ O O O O $any$ O O O O O O $Projection$ O $any$ O O O O $Projection$ O O O O $Projection$ O $ProjectionOptions$ O $EventHandlerInterceptor$ O $EventHandlerInterceptor$ O $Projector$ O $Projection$ O $ProjectorPerformanceLogger$ O O $Projection$ O $Projection$ O $Element$ O $VNode$ O O O $ProjectionOptions$ O O $Projection[]$ O $number$ O $Projection$ O O $VNode)[]$ O $number$ O $VNode$ O O O O O $void$ O O O O O $number$ O $undefined$ O O O O $boolean$ O O O O O $boolean$ O O O $ProjectorPerformanceLogger$ O O O $undefined$ O O O O O $number$ O O O $number$ O $Projection[]$ O $number$ O $number$ O O O O $VNode$ O $VNode)[]$ O $number$ O O O O $ProjectorPerformanceLogger$ O O O $undefined$ O O $Projection[]$ O $number$ O O $void$ O $VNode$ O O $ProjectorPerformanceLogger$ O O O $undefined$ O O O $ProjectorPerformanceLogger$ O O O $undefined$ O O $boolean$ O O O O O $Projector$ O O $void$ O $void$ O $void$ O O O O O O O O $number$ O O $boolean$ O O $number$ O $number$ O $void$ O O O O O $void$ O O O O O O O $number$ O O $void$ O $number$ O O $number$ O $undefined$ O O $boolean$ O O O O O $void$ O O O O O $boolean$ O O O $boolean$ O O O $Projector$ O $void$ O O O O O $void$ O O $Element$ O $VNode$ O O O $void$ O $complex$ O $Projection$ O $Element$ O $VNode$ O O O O $void$ O O $Element$ O $VNode$ O O O $void$ O $complex$ O $Projection$ O $Element$ O $VNode$ O O O O $void$ O O $Element$ O $VNode$ O O O $void$ O $complex$ O $Projection$ O $Element$ O $VNode$ O O O O $void$ O O $Element$ O $VNode$ O O O $void$ O $complex$ O $Projection$ O $Element$ O $VNode$ O O O O $Projection$ O O $VNode$ O O O O O O $number$ O O O $number$ O $VNode)[]$ O $number$ O $number$ O O O O O $VNode)[]$ O $number$ O O $VNode$ O O $VNode)[]$ O $complex$ O $number$ O O O O O $Projection[]$ O $complex$ O $number$ O O O O O O O O O O O $ErrorConstructor$ O O O O O O O O $Projector$ O O O
import { PerformanceLoggerEvent , ProjectorPerformanceLogger } from 's' ; export let windowPerformanceProjectorLogger ; if ( window . performance && window . performance . measure ) { let performance = window . performance ; let lastMark : PerformanceLoggerEvent | undefined ; windowPerformanceProjectorLogger = ( eventType , trigger : Event | undefined ) => { performance . mark ( eventType ) ; switch ( eventType ) { case 's' : performance . measure ( 's' , 's' , 's' ) ; break ; case 's' : performance . measure ( 's' , 's' , 's' ) ; break ; case 's' : performance . measure ( 's' , lastMark , 's' ) ; break ; case 's' : performance . measure ( 's' , 's' , 's' ) ; break ; } lastMark = eventType ; } ; } else { windowPerformanceProjectorLogger = ( ) => undefined ; }	O O $any$ O $any$ O O O O O O $ProjectorPerformanceLogger$ O O O $complex$ O $Performance$ O $complex$ O $Performance$ O $void$ O O O $Performance$ O $complex$ O $Performance$ O O $PerformanceLoggerEvent$ O $any$ O O O $ProjectorPerformanceLogger$ O O $PerformanceLoggerEvent$ O $Event$ O $complex$ O O O O O $Performance$ O $void$ O $PerformanceLoggerEvent$ O O O O $PerformanceLoggerEvent$ O O O O O $Performance$ O $void$ O O O O O O O O O O O O O $Performance$ O $void$ O O O O O O O O O O O O O $Performance$ O $void$ O O O $PerformanceLoggerEvent$ O O O O O O O O O $Performance$ O $void$ O O O O O O O O O O O $PerformanceLoggerEvent$ O $PerformanceLoggerEvent$ O O O O O O $ProjectorPerformanceLogger$ O O O O $undefined$ O O
import { h } from 's' ; import { createProjector } from 's' ; import { windowPerformanceProjectorLogger } from 's' ; document . addEventListener ( 's' , ( ) => { let name = 's' ; let nameInput = ( evt ) => { name = ( evt . target as HTMLInputElement ) . value ; } ; let render = ( ) => { return h ( 's' , [ h ( 's' , [ h ( 's' , [ 's' ] ) , h ( 's' , { type : 's' , autofocus : true , value : name , oninput : nameInput } ) ] ) , name ? [ h ( 's' , [ `template` ] ) ] : [ ] ] ) ; } ; createProjector ( { performanceLogger : windowPerformanceProjectorLogger } ) . merge ( document . body , render ) ; } ) ;	O O $complex$ O O O O O O $Projector$ O O O O O O $ProjectorPerformanceLogger$ O O O O $Document$ O O O O O O O O O O $string$ O O O O $void$ O O $Event$ O O O $string$ O O $Event$ O $EventTarget$ O $complex$ O O $string$ O O O O $VNode$ O O O O O O $complex$ O O O O $complex$ O O O O $complex$ O O O O O O O O $complex$ O O O O $string$ O O O $boolean$ O O O $string$ O $string$ O $void$ O $void$ O O O O O $string$ O O $complex$ O O O O O O O O O O O O O O O O $Projector$ O O $ProjectorPerformanceLogger$ O $ProjectorPerformanceLogger$ O O O $void$ O $Document$ O $HTMLElement$ O $VNode$ O O O O O
'js' ( function ( window ) { 's' ; var maquette = window . maquette ; var model = new window . model ( new window . store ( "s" ) ) ; var router = window . createRouter ( model ) ; document . addEventListener ( 's' , function ( ) { var projector = maquette . createProjector ( ) ; projector . merge ( document . getElementsByTagName ( "s" ) [ 0 ] , router . render ) ; window . onhashchange = function ( evt ) { projector . scheduleRender ( ) ; } ; } ) ; } ) ( window ) ;	O O O O $complex$ O O O O O $any$ O $complex$ O $any$ O O $any$ O O $complex$ O $any$ O O $complex$ O $any$ O O O O O O $any$ O $complex$ O $any$ O $any$ O O $Document$ O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $Document$ O O O O O O O O O $any$ O $any$ O O $complex$ O $any)$ O O O $any$ O O $any$ O $any$ O O O O O O O O O O O $complex$ O O
'js' window . createTodoComponent = function ( todoList , id , title ) { 's' ; var h = window . maquette . h ; var ENTER_KEY = 0 ; var ESC_KEY = 0 ; var renderCache = window . maquette . createCache ( ) ; var editingTitle = null ; var acceptEdit = function ( ) { todoComponent . title = editingTitle . trim ( ) ; if ( ! todoComponent . title ) { todoList . editTodo ( null ) ; todoList . removeTodo ( todoComponent ) ; } else { todoList . todoTitleUpdated ( todoComponent ) ; todoList . editTodo ( null ) ; editingTitle = null ; } } ; var focusEdit = function ( domNode ) { if ( window . setImmediate ) { window . setImmediate ( function ( ) { domNode . focus ( ) ; domNode . selectionStart = 0 ; domNode . selectionEnd = domNode . value . length ; } ) ; } else { domNode . focus ( ) ; domNode . selectionStart = 0 ; domNode . selectionEnd = domNode . value . length ; } } ; var handleDestroyClick = function ( evt ) { evt . preventDefault ( ) ; todoList . removeTodo ( todoComponent ) ; } ; var handleToggleClick = function ( evt ) { evt . preventDefault ( ) ; todoComponent . completed = ! todoComponent . completed ; todoList . todoCompletedUpdated ( todoComponent , todoComponent . completed ) ; } ; var handleLabelDoubleClick = function ( evt ) { editingTitle = todoComponent . title ; todoList . editTodo ( todoComponent ) ; evt . preventDefault ( ) ; } ; var handleEditInput = function ( evt ) { editingTitle = evt . target . value ; } ; var handleEditKeyUp = function ( evt ) { if ( evt . keyCode == ENTER_KEY ) { acceptEdit ( ) ; } if ( evt . keyCode == ESC_KEY ) { todoList . editTodo ( null ) ; editingTitle = null ; } } ; var handleEditBlur = function ( evt ) { if ( todoList . editingTodo === todoComponent ) { acceptEdit ( ) ; } } ; var todoComponent = { id : id , title : title , completed : false , render : function ( ) { var editing = todoList . editingTodo === todoComponent ; return renderCache . result ( [ todoComponent . completed , todoComponent . title , editing ] , function ( ) { return h ( "s" , { key : todoComponent , classes : { completed : todoComponent . completed , editing : editing } } , editing ? [ h ( "s" , { value : editingTitle , oninput : handleEditInput , onkeyup : handleEditKeyUp , onblur : handleEditBlur , afterCreate : focusEdit } ) ] : [ h ( "s" , [ h ( "s" , { type : "s" , checked : todoComponent . completed , onclick : handleToggleClick } ) , h ( "s" , { ondblclick : handleLabelDoubleClick } , [ todoComponent . title ] ) , h ( "s" , { onclick : handleDestroyClick } ) ] ) ] ) ; } ) ; } } ; return todoComponent ; } ;	O $complex$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $complex$ O $any$ O $any$ O O $number$ O O O O $number$ O O O O $any$ O $complex$ O $any$ O $any$ O O O O $any$ O O O O $void$ O O O O O $complex$ O $any$ O $any$ O $any$ O O O O O O $complex$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $complex$ O O O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O O O $any$ O O O O O O O $void$ O O O $any$ O O O O $complex$ O $any$ O O $complex$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $void$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O O O O $void$ O O O $any$ O O $any$ O $any$ O O O $complex$ O $boolean$ O O $complex$ O $boolean$ O $any$ O $any$ O $complex$ O $complex$ O $boolean$ O O O O O $void$ O O O $any$ O O $any$ O $complex$ O $any$ O $any$ O $any$ O $complex$ O O $any$ O $any$ O O O O O O $void$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O O O O $any$ O $any$ O $number$ O O $void$ O O O O O O $any$ O $any$ O $number$ O O $any$ O $any$ O O O O $any$ O O O O O O O $void$ O O O $any$ O O O O $any$ O $any$ O $complex$ O O $void$ O O O O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O $any$ O O O O O O $boolean$ O $any$ O $any$ O $complex$ O O $any$ O $any$ O O $complex$ O $boolean$ O $complex$ O $any$ O $boolean$ O O O O O O O $any$ O O O O $complex$ O $complex$ O $complex$ O O $boolean$ O $complex$ O $boolean$ O $boolean$ O $boolean$ O O O $boolean$ O O $any$ O O O O $any$ O $any$ O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O O O O O $any$ O O O O $any$ O O O O $string$ O O O $boolean$ O $complex$ O $boolean$ O $void$ O $void$ O O O $any$ O O O O $void$ O $void$ O O O $complex$ O $any$ O O O $any$ O O O O $void$ O $void$ O O O O O O O O O O O O O O $complex$ O O O
'js' window . createListComponent = function ( mode , model ) { 's' ; var h = window . maquette . h ; var checkedAll = true ; var completedCount = 0 ; var itemsLeft = 0 ; var newTodoTitle = "s" ; var todos = [ ] ; var addTodo = function ( ) { var title = newTodoTitle . trim ( ) ; if ( title ) { model . create ( newTodoTitle , function ( results ) { var todo = createTodoComponent ( listComponent , results [ 0 ] . id , results [ 0 ] . title ) ; todos . push ( todo ) ; itemsLeft ++ ; checkedAll = false ; } ) ; } } ; var visibleInMode = function ( todo ) { switch ( mode ) { case "s" : return todo . completed === true ; case "s" : return todo . completed !== true ; default : return true ; } } ; var focus = function ( element ) { element . focus ( ) ; } ; var handleNewTodoKeypress = function ( evt ) { newTodoTitle = evt . target . value ; if ( evt . keyCode === 0 ) { addTodo ( ) ; newTodoTitle = "s" ; evt . preventDefault ( ) ; } else if ( evt . keyCode === 0 ) { newTodoTitle = "s" ; evt . preventDefault ( ) ; } } ; var handleNewTodoInput = function ( evt ) { newTodoTitle = evt . target . value ; } ; var handleToggleAllClick = function ( evt ) { evt . preventDefault ( ) ; checkedAll = ! checkedAll ; todos . forEach ( function ( todo ) { if ( todo . completed !== checkedAll ) { todo . completed = checkedAll ; model . update ( todo . id , { title : todo . title , completed : checkedAll } ) ; } } ) ; if ( checkedAll ) { itemsLeft = 0 ; completedCount = todos . length ; } else { itemsLeft = todos . length ; completedCount = 0 ; } } ; var handleClearCompletedClick = function ( evt ) { for ( var i = todos . length - 0 ; i >= 0 ; i -- ) { if ( todos [ i ] . completed ) { listComponent . removeTodo ( todos [ i ] ) ; } } } ; var listComponent = { mode : mode , editingTodo : undefined , removeTodo : function ( todo ) { model . remove ( todo . id , function ( ) { todos . splice ( todos . indexOf ( todo ) , 0 ) ; if ( todo . completed ) { completedCount -- ; } else { itemsLeft -- ; checkedAll = completedCount === todos . length ; } } ) ; } , editTodo : function ( todo ) { listComponent . editingTodo = todo ; } , todoCompletedUpdated : function ( todo , completed ) { if ( completed ) { completedCount ++ ; checkedAll = completedCount === todos . length ; itemsLeft -- ; } else { completedCount -- ; checkedAll = false ; itemsLeft ++ ; } model . update ( todo . id , { title : todo . title , completed : completed } ) ; } , todoTitleUpdated : function ( todo ) { model . update ( todo . id , { title : todo . title , completed : todo . completed } ) ; } , render : function ( ) { var anyTodos = todos . length > 0 ; return h ( "s" , { key : listComponent } , [ h ( "s" , [ h ( "s" , [ "s" ] ) , h ( "s" , { autofocus : true , placeholder : "s" , onkeypress : handleNewTodoKeypress , oninput : handleNewTodoInput , value : newTodoTitle , afterCreate : focus } ) ] ) , anyTodos ? [ h ( "s" , { key : mode } , [ h ( "s" , { type : "s" , checked : checkedAll , onclick : handleToggleAllClick } ) , h ( "s" , { "s" : "s" } , [ "s" ] ) , h ( "s" , todos . filter ( visibleInMode ) . map ( function ( todo ) { return todo . render ( ) ; } ) ) ] ) , h ( "s" , [ h ( "s" , { } , [ h ( "s" , [ 's' + itemsLeft ] ) , itemsLeft === 0 ? "s" : "s" ] ) , h ( "s" , { } , [ h ( "s" , { key : "s" } , [ h ( "s" , { classes : { selected : mode === "s" } , href : "s" } , [ "s" ] ) ] ) , h ( "s" , { key : "s" } , [ h ( "s" , { classes : { selected : mode === "s" } , href : "s" } , [ "s" ] ) ] ) , h ( "s" , { key : "s" } , [ h ( "s" , { classes : { selected : mode === "s" } , href : "s" } , [ "s" ] ) ] ) ] ) , completedCount > 0 ? h ( "s" , { onclick : handleClearCompletedClick } , [ "s" + completedCount + "s" ] ) : null ] ) ] : null ] ) ; } } ; model . read ( function ( data ) { data . forEach ( function ( dataItem ) { var todo = createTodoComponent ( listComponent , dataItem . id , dataItem . title ) ; todos . push ( todo ) ; if ( dataItem . completed ) { todo . completed = true ; completedCount ++ ; } else { itemsLeft ++ ; checkedAll = false ; } } ) ; } ) ; return listComponent ; } ;	O $complex$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $complex$ O $any$ O $any$ O O $boolean$ O O O O $number$ O O O O $number$ O O O O $string$ O O O O $any[]$ O O O O O $void$ O O O O O O $string$ O $string$ O $string$ O O O O O $string$ O O $any$ O $any$ O $string$ O O O $any$ O O O $any$ O $any$ O $complex$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any[]$ O $number$ O $any$ O O $number$ O O $boolean$ O O O O O O O O O O $boolean$ O O O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O O O $void$ O O O $any$ O O $any$ O $any$ O O O O O O $void$ O O O $any$ O O $string$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O O O $string$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $string$ O O O $any$ O $any$ O O O O O O O $void$ O O O $any$ O O $string$ O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O O $any$ O $any$ O O O $boolean$ O O $boolean$ O $any[]$ O $void$ O O O $any$ O O O O $any$ O $any$ O $boolean$ O O $any$ O $any$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $boolean$ O $boolean$ O O O O O O O O O $boolean$ O O $number$ O O O $number$ O $any[]$ O $number$ O O O O $number$ O $any[]$ O $number$ O $number$ O O O O O O O $void$ O O O $any$ O O O O O $number$ O $any[]$ O $number$ O O O $number$ O O O $number$ O O O O O $any[]$ O $number$ O O $any$ O O $complex$ O $void$ O $any[]$ O $number$ O O O O O O O O $complex$ O O $any$ O $any$ O $undefined$ O $undefined$ O $void$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any[]$ O $complex$ O $any[]$ O $number$ O $any$ O O O O O O O $any$ O $any$ O O $number$ O O O O O $number$ O O $boolean$ O $number$ O $any[]$ O $number$ O O O O O O O $void$ O O O $any$ O O $complex$ O $any$ O $any$ O O O $void$ O O O $any$ O $any$ O O O O $any$ O O $number$ O O $boolean$ O $number$ O $any[]$ O $number$ O $number$ O O O O O $number$ O O $boolean$ O O O $number$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $void$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $boolean$ O $any[]$ O $number$ O O O O $any$ O O O O $complex$ O $complex$ O O O $any$ O O O O $any$ O O O O O O O O $any$ O O O O $boolean$ O O O $string$ O O O $void$ O $void$ O $void$ O $void$ O $string$ O $string$ O $void$ O $void$ O O O O O $boolean$ O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O $string$ O O O $boolean$ O $boolean$ O $void$ O $void$ O O O $any$ O O O O O O O O O O O O O O $any$ O O O $any[]$ O $complex$ O $boolean$ O O $U[]$ O O O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O $number$ O O O $number$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O $string$ O O O O O $any$ O O O O $complex$ O O $boolean$ O $any$ O O O O $string$ O O O O O O O O O O O $any$ O O O O $string$ O O O O O $any$ O O O O $complex$ O O $boolean$ O $any$ O O O O $string$ O O O O O O O O O O O $any$ O O O O $string$ O O O O O $any$ O O O O $complex$ O O $boolean$ O $any$ O O O O $string$ O O O O O O O O O O O O O $number$ O O O $any$ O O O O $void$ O $void$ O O O O O $number$ O O O O O O O O O O O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $number$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $number$ O O O O O $number$ O O $boolean$ O O O O O O O O O O O $complex$ O O O
'js' window . createRouter = function ( model ) { 's' ; var h = window . maquette . h ; var currentHash = null ; var currentPage = null ; var todoRouter = { render : function ( ) { var hash = document . location . hash ; if ( hash !== currentHash ) { switch ( hash ) { case "s" : currentPage = createListComponent ( "s" , model ) ; break ; case "s" : currentPage = createListComponent ( "s" , model ) ; break ; default : currentPage = createListComponent ( "s" , model ) ; } currentHash = hash ; } return h ( "s" , [ currentPage . render ( ) ] ) ; } } ; return todoRouter ; } ;	O $complex$ O $any$ O O O $any$ O O O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O $complex$ O O $any$ O O O O O O $string$ O $Document$ O $Location$ O $string$ O O O $string$ O $any$ O O O O $string$ O O O O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $string$ O O O $any$ O O O O $any$ O $any$ O O O O O O O O O $complex$ O O O
'js' ( function ( window ) { 's' ; window . model = function ( storage ) { return { create : function ( title , callback ) { title = title || 's' ; callback = callback || function ( ) { } ; var newItem = { title : title . trim ( ) , completed : false } ; storage . save ( newItem , callback ) ; } , read : function ( query , callback ) { var queryType = typeof query ; callback = callback || function ( ) { } ; if ( queryType === 's' ) { callback = query ; storage . findAll ( callback ) ; } else if ( queryType === 's' || queryType === 's' ) { query = parseInt ( query , 0 ) ; storage . find ( { id : query } , callback ) ; } else { storage . find ( query , callback ) ; } } , update : function ( id , data , callback ) { storage . save ( data , callback , id ) ; } , remove : function ( id , callback ) { storage . remove ( id , callback ) ; } , removeAll : function ( callback ) { storage . drop ( callback ) ; } , getCount : function ( callback ) { var todos = { active : 0 , completed : 0 , total : 0 } ; storage . findAll ( function ( data ) { data . forEach ( function ( todo ) { if ( todo . completed ) { todos . completed ++ ; } else { todos . active ++ ; } todos . total ++ ; } ) ; callback ( todos ) ; } ) ; } } ; } ; } ) ( window ) ;	O O O O $complex$ O O O O $complex$ O $any$ O O O $any$ O O O O $void$ O O O $string$ O $Function$ O O $string$ O $string$ O O O $Function$ O $Function$ O O O O O O O O $complex$ O O $string$ O $string$ O $string$ O O O $boolean$ O O O O $any$ O $any$ O $complex$ O $Function$ O O O O $void$ O O O $any$ O $Function$ O O O O O O $any$ O $Function$ O $Function$ O O O O O O O O O O O O O O $Function$ O $any$ O $any$ O $any$ O $Function$ O O O O O O O O O O O O O O O $any$ O $number$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $Function$ O O O O O $any$ O $any$ O $any$ O $Function$ O O O O O $void$ O O O $number$ O $any$ O $Function$ O O $any$ O $any$ O $any$ O $Function$ O $number$ O O O O $void$ O O O $number$ O $Function$ O O $any$ O $any$ O $number$ O $Function$ O O O O $void$ O O O $Function$ O O $any$ O $any$ O $Function$ O O O O $void$ O O O $any$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O $complex$ O $number$ O O O O O $complex$ O $number$ O O O $complex$ O $number$ O O O O O $any$ O $complex$ O O O O O O O O O O O O O $complex$ O O
'js' ( function ( window ) { 's' ; window . store = function ( name ) { var data ; if ( ! localStorage [ name ] ) { data = { todos : [ ] } ; localStorage [ name ] = JSON . stringify ( data ) ; } else { data = JSON . parse ( localStorage [ name ] ) ; } var flushTimeout = null ; var flush = function ( ) { if ( ! flushTimeout ) { flushTimeout = setTimeout ( function ( ) { flushTimeout = null ; localStorage [ name ] = JSON . stringify ( data ) ; } ) ; } } ; return { find : function ( query , callback ) { if ( ! callback ) { return ; } var todos = data . todos ; callback . call ( undefined , todos . filter ( function ( todo ) { for ( var q in query ) { if ( query [ q ] !== todo [ q ] ) { return false ; } } return true ; } ) ) ; } , findAll : function ( callback ) { callback = callback || function ( ) { } ; callback . call ( undefined , data . todos ) ; } , save : function ( updateData , callback , id ) { var todos = data . todos ; callback = callback || function ( ) { } ; if ( id ) { for ( var i = 0 ; i < todos . length ; i ++ ) { if ( todos [ i ] . id === id ) { for ( var key in updateData ) { todos [ i ] [ key ] = updateData [ key ] ; } break ; } } flush ( ) ; callback . call ( undefined , data . todos ) ; } else { updateData . id = new Date ( ) . getTime ( ) ; todos . push ( updateData ) ; flush ( ) ; callback . call ( undefined , [ updateData ] ) ; } } , remove : function ( id , callback ) { var todos = data . todos ; for ( var i = 0 ; i < todos . length ; i ++ ) { if ( todos [ i ] . id == id ) { todos . splice ( i , 0 ) ; break ; } } flush ( ) ; callback . call ( undefined , data . todos ) ; } , drop : function ( callback ) { data = { todos : [ ] } ; flush ( ) ; callback . call ( undefined , data . todos ) ; } } ; } ; } ) ( window ) ;	O O O O $complex$ O O O O $complex$ O $any$ O O O $string$ O O O $any$ O O O O $Storage$ O $string$ O O O $any$ O O $undefined[]$ O O O O O $Storage$ O $string$ O O $JSON$ O $complex$ O $complex$ O O O O O $any$ O $JSON$ O $any$ O $Storage$ O $string$ O O O O O $any$ O O O O $void$ O O O O O O O O $any$ O O $any$ O $number$ O O O O O $any$ O O O $Storage$ O $string$ O O $JSON$ O $complex$ O $any$ O O O O O O O O O O $void$ O O O $any$ O $Function$ O O O O O $Function$ O O O O O O $any$ O $any$ O $any$ O $Function$ O $any$ O $undefined$ O $any$ O $any$ O O O $any$ O O O O O $string$ O $any$ O O O O $any$ O $string$ O O $any$ O $string$ O O O O O O O O O O O O O O O O O $void$ O O O $Function$ O O $Function$ O $Function$ O O O O O O O $Function$ O $any$ O $undefined$ O $any$ O $any$ O O O O $void$ O O O $any$ O $Function$ O $number$ O O O $any$ O $any$ O $any$ O $Function$ O $Function$ O O O O O O O O O $number$ O O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O $any$ O $number$ O O $any$ O $number$ O O O O O $string$ O $any$ O O $any$ O $number$ O O $string$ O O $any$ O $string$ O O O O O O O $void$ O O O $Function$ O $any$ O $undefined$ O $any$ O $any$ O O O O O $any$ O $any$ O O $DateConstructor$ O O O $number$ O O O $any$ O $any$ O $any$ O O $void$ O O O $Function$ O $any$ O $undefined$ O O $any$ O O O O O O $void$ O O O $number$ O $Function$ O O O $any$ O $any$ O $any$ O O O O $number$ O O O $number$ O $any$ O $any$ O $number$ O O O O O $any$ O $number$ O O $any$ O $number$ O O $any$ O $any$ O $number$ O O O O O O O O $void$ O O O $Function$ O $any$ O $undefined$ O $any$ O $any$ O O O O $void$ O O O $Function$ O O $any$ O O $undefined[]$ O O O O O $void$ O O O $Function$ O $any$ O $undefined$ O $complex$ O $undefined[]$ O O O O O O O O O O $complex$ O O
'js' let { h } = require ( "s" ) ; var yourName = 's' ; function handleNameInput ( evt ) { yourName = evt . target . value ; } function render ( ) { return h ( 's' , [ h ( 's' , { type : 's' , placeholder : 's' , value : yourName , oninput : handleNameInput } ) , h ( 's' , [ 's' + ( yourName || 's' ) + 's' ] ) ] ) ; } let { createTestProjector } = require ( "s" ) ; let testProjector = createTestProjector ( render ) ; let output = testProjector . query ( 's' ) ; output . textContent ;	O O O $any$ O O $any$ O O O O O $string$ O O O O $void$ O $any$ O O $string$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O O $any$ O O O O $string$ O O O $string$ O O O $string$ O $string$ O $void$ O $void$ O O O $any$ O O O O O O O $string$ O O O O O O O O O O O O O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O
'js' ( function ( global ) { "s" ; var object_defineProperty = true ; try { Object . defineProperty ( { } , "s" , { } ) ; } catch ( e ) { object_defineProperty = false ; } ( function ( ) { var lastTime = 0 ; var vendors = [ 's' , 's' ] ; for ( var x = 0 ; x < vendors . length && ! global . requestAnimationFrame ; ++ x ) { global . requestAnimationFrame = global [ vendors [ x ] + 's' ] ; global . cancelAnimationFrame = global [ vendors [ x ] + 's' ] || global [ vendors [ x ] + 's' ] ; } if ( ! global . requestAnimationFrame || "s" . test ( global . navigator . userAgent ) ) global . requestAnimationFrame = function ( callback , element ) { var currTime = new Date ( ) . getTime ( ) ; var timeToCall = Math . max ( 0 , 0 - ( currTime - lastTime ) ) ; var id = global . setTimeout ( function ( ) { callback ( currTime + timeToCall ) ; } , timeToCall ) ; lastTime = currTime + timeToCall ; return id ; } ; if ( ! global . cancelAnimationFrame ) global . cancelAnimationFrame = function ( id ) { clearTimeout ( id ) ; } ; } ( ) ) ; if ( ! Array . isArray ) { Array . isArray = function ( arg ) { return Object . prototype . toString . call ( arg ) === 's' ; } ; } if ( ! ( "s" in document . documentElement ) ) { ( function ( createElement ) { var onPropertyChange = function ( e ) { if ( e . propertyName === "s" ) { e . srcElement . innerText = e . srcElement . textContent ; } } ; document . createElement = function ( tagName ) { var element = createElement ( tagName ) ; element . textContent = "s" ; element . attachEvent ( "s" , onPropertyChange ) ; return element ; } ; } ) ( document . createElement ) ; } if ( ! ( "s" in document . documentElement ) ) { ( function ( join , splice , createElement ) { if ( object_defineProperty ) { var DOMEx = function ( type , message ) { this . name = type ; this . code = DOMException [ type ] ; this . message = message ; } ; var strTrim = String . prototype . trim || function ( ) { return this . replace ( "s" , "s" ) ; } ; var arrIndexOf = Array . prototype . indexOf || function ( item ) { var i = 0 ; var len = this . length ; for ( ; i < len ; i ++ ) { if ( i in this && this [ i ] === item ) { return i ; } } return - 0 ; } ; var checkTokenAndGetIndex = function ( classList , token ) { if ( token === "s" ) { throw new DOMEx ( "s" , "s" ) ; } if ( "s" . test ( token ) ) { throw new DOMEx ( "s" , "s" ) ; } return arrIndexOf . call ( classList , token ) ; } ; var classListObject = function ( elem ) { var trimmedClasses = strTrim . call ( elem . getAttribute ( "s" ) || "s" ) ; var classes = trimmedClasses ? trimmedClasses . split ( "s" ) : [ ] ; var i = 0 ; var len = classes . length ; for ( ; i < len ; i ++ ) { this . push ( classes [ i ] ) ; } this . _updateClassName = function ( ) { elem . setAttribute ( "s" , this . toString ( ) ) ; } ; } ; var classListProto = classListObject . prototype = [ ] ; classListProto . item = function ( i ) { return this [ i ] || null ; } ; classListProto . contains = function ( token ) { token += "s" ; return checkTokenAndGetIndex ( this , token ) !== - 0 ; } ; classListProto . add = function ( ) { var tokens = arguments ; var i = 0 ; var l = tokens . length ; var token ; var updated = false ; do { token = tokens [ i ] + "s" ; if ( checkTokenAndGetIndex ( this , token ) === - 0 ) { this . push ( token ) ; updated = true ; } } while ( ++ i < l ) ; if ( updated ) { this . _updateClassName ( ) ; } } ; classListProto . remove = function ( ) { var tokens = arguments ; var i = 0 ; var l = tokens . length ; var token ; var updated = false ; var index ; do { token = tokens [ i ] + "s" ; index = checkTokenAndGetIndex ( this , token ) ; while ( index !== - 0 ) { this . splice ( index , 0 ) ; updated = true ; index = checkTokenAndGetIndex ( this , token ) ; } } while ( ++ i < l ) ; if ( updated ) { this . _updateClassName ( ) ; } } ; classListProto . toggle = function ( token , force ) { token += "s" ; var result = this . contains ( token ) ; var method = result ? force !== true && "s" : force !== false && "s" ; if ( method ) { this [ method ] ( token ) ; } if ( force === true || force === false ) { return force ; } else { return ! result ; } } ; classListProto . toString = function ( ) { return this . join ( "s" ) ; } ; var classListGetter = function ( ) { return new classListObject ( this ) ; } ; Object . defineProperty ( global . Element . prototype , "s" , { get : classListGetter , enumerable : true , configurable : true } ) ; } else { var tokenize = function ( token ) { if ( "s" . test ( token ) ) { return String ( token ) ; } else { throw new Error ( 's' ) ; } } ; var toObject = function ( self ) { for ( var index = - 0 , object = { } , element ; element = self [ ++ index ] ; ) { object [ element ] = true ; } return object ; } ; var fromObject = function ( self , object ) { var array = [ ] , token ; for ( token in object ) { if ( object [ token ] ) { array . push ( token ) ; } } splice . apply ( self , [ 0 , self . length ] . concat ( array ) ) ; } ; document . createElement = function ( tagName ) { var element = createElement ( tagName ) ; var classList = [ ] ; element . classList = { add : function ( ) { for ( var object = toObject ( classList ) , index = 0 , token ; index in arguments ; ++ index ) { token = tokenize ( arguments [ index ] ) ; object [ token ] = true ; } fromObject ( classList , object ) ; element . className = join . call ( classList , 's' ) ; } , remove : function ( ) { for ( var object = toObject ( classList ) , index = 0 , token ; index in arguments ; ++ index ) { token = tokenize ( arguments [ index ] ) ; object [ token ] = false ; } fromObject ( classList , object ) ; element . className = join . call ( classList , 's' ) ; } } ; return element ; } ; } } ( Array . prototype . join , Array . prototype . splice , document . createElement ) ) ; } if ( ! Object . keys ) { Object . keys = ( function ( ) { 's' ; var hasOwnProperty = Object . prototype . hasOwnProperty , hasDontEnumBug = ! ( { toString : null } ) . propertyIsEnumerable ( 's' ) , dontEnums = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' ] , dontEnumsLength = dontEnums . length ; return function ( obj ) { if ( typeof obj !== 's' && ( typeof obj !== 's' || obj === null ) ) { throw new TypeError ( 's' ) ; } var result = [ ] , prop , i ; for ( prop in obj ) { if ( hasOwnProperty . call ( obj , prop ) ) { result . push ( prop ) ; } } if ( hasDontEnumBug ) { for ( i = 0 ; i < dontEnumsLength ; i ++ ) { if ( hasOwnProperty . call ( obj , dontEnums [ i ] ) ) { result . push ( dontEnums [ i ] ) ; } } } return result ; } ; } ( ) ) ; } if ( ! Array . prototype . forEach ) { Array . prototype . forEach = function ( callback , thisArg ) { var T , k ; if ( this == null ) { throw new TypeError ( 's' ) ; } var O = Object ( this ) ; var len = O . length >>> 0 ; if ( typeof callback !== "s" ) { throw new TypeError ( callback + 's' ) ; } if ( arguments . length > 0 ) { T = thisArg ; } k = 0 ; while ( k < len ) { var kValue ; if ( k in O ) { kValue = O [ k ] ; callback . call ( T , kValue , k , O ) ; } k ++ ; } } ; } if ( ! Array . prototype . map ) { Array . prototype . map = function ( callback , thisArg ) { var T , A , k ; if ( this == null ) { throw new TypeError ( 's' ) ; } var O = Object ( this ) ; var len = O . length >>> 0 ; if ( typeof callback !== 's' ) { throw new TypeError ( callback + 's' ) ; } if ( arguments . length > 0 ) { T = thisArg ; } A = new Array ( len ) ; k = 0 ; while ( k < len ) { var kValue , mappedValue ; if ( k in O ) { kValue = O [ k ] ; mappedValue = callback . call ( T , kValue , k , O ) ; A [ k ] = mappedValue ; } k ++ ; } return A ; } ; } if ( ! document . createElementNS ) { ( function ( createElement ) { document . createElementNS = function ( namespace , tagName ) { return createElement ( tagName ) ; } } ) ( document . createElement ) ; } } ) ( this ) ;	O O O O $any$ O O O O O $boolean$ O O O O O $ObjectConstructor$ O $any$ O O O O O O O O O O O O O $any$ O O $boolean$ O O O O O O O O O O $number$ O O O O $string[]$ O O O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O O $any$ O $number$ O O $number$ O O $any$ O $number$ O $any$ O $string[]$ O $number$ O O O O O $any$ O $void$ O $any$ O $string[]$ O $number$ O O O O O $any$ O $string[]$ O $number$ O O O O O O O O O $any$ O $number$ O O O $boolean$ O $any$ O $Navigator$ O $string$ O O $any$ O $number$ O O O $any$ O $any$ O O O $number$ O O $DateConstructor$ O O O $number$ O O O O $number$ O $Math$ O $number$ O O O O O O $number$ O $number$ O O O O $number$ O $any$ O $number$ O O O O O $any$ O $number$ O $number$ O O O O $number$ O O $number$ O $number$ O $number$ O O $number$ O O O O O O $any$ O $void$ O $any$ O $void$ O O O $number$ O O $void$ O $number$ O O O O O O O O O O O O $ArrayConstructor$ O $complex$ O O $ArrayConstructor$ O $complex$ O O O $any$ O O O $ObjectConstructor$ O $Object$ O $string$ O $any$ O $any$ O O O O O O O O O O O O O $Document$ O $HTMLElement$ O O O O O O O O O O $void$ O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $Document$ O O O O O $any$ O O O $any$ O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $void$ O O O $any$ O O O O O O $Document$ O O O O O O O O O O O $Document$ O $HTMLElement$ O O O O O O $string$ O $complex$ O O O O O O $boolean$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $StringConstructor$ O $String$ O $string$ O O O O O O O O $any$ O O O O O O O O O $number$ O $ArrayConstructor$ O $any[]$ O $number$ O O O $any$ O O O $number$ O O O O $any$ O O O $any$ O O O O $number$ O $any$ O $number$ O O O O O $number$ O O O O O $number$ O O $any$ O O O $number$ O O O O O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O O O O O O O O O O O $boolean$ O $any$ O O O O O $any$ O O O O O O O O $number$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $number$ O O O O $any$ O $any$ O $any$ O O O O $number$ O $any$ O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O $void$ O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any[]$ O $any$ O $any[]$ O O O O $any[]$ O $any$ O O O $any$ O O O O O $any$ O O O O O O $any[]$ O $any$ O O O $any$ O O $any$ O O O O $any$ O O O $any$ O O O O O O O $any[]$ O $any$ O O O O O O $IArguments$ O $IArguments$ O O $number$ O O O O $number$ O $IArguments$ O $number$ O O $any$ O O $boolean$ O O O O O $any$ O $IArguments$ O $number$ O O O O O O $any$ O O O $string$ O O O O O O O O $number$ O $string$ O O $boolean$ O O O O O O O O $number$ O $number$ O O O O $boolean$ O O O O $any$ O O O O O O $any[]$ O $any$ O O O O O O $IArguments$ O $IArguments$ O O $number$ O O O O $number$ O $IArguments$ O $number$ O O $any$ O O $boolean$ O O O O $any$ O O O $any$ O $IArguments$ O $number$ O O O O $any$ O $any$ O O O $string$ O O O O $any$ O O O O O O O $complex$ O $any$ O O O O $boolean$ O O O $any$ O $any$ O O O $string$ O O O O O O O $number$ O $number$ O O O O $boolean$ O O O O $any$ O O O O O O $any[]$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O O O $any$ O $any$ O O O $string$ O $any$ O $any$ O O O O O $any$ O O O O O O O $string$ O O O O $string$ O O $any$ O O O O O $any$ O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O $any[]$ O $string$ O O O O O O O O $string$ O O O O O O O $classListObject$ O O O O O O O $any$ O O O O O O $ObjectConstructor$ O $any$ O $any$ O $complex$ O $Element$ O O O O $classListObject$ O $classListObject$ O $true$ O O O $true$ O O O O O O O O O $string$ O O O $any$ O O O O O O $boolean$ O $any$ O O O O $StringConstructor$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O ${}$ O O O $any$ O O O O O $number$ O O O O ${}$ O O O O $any$ O $any$ O $any$ O O $number$ O O O O ${}$ O $any$ O O O O O O ${}$ O O O O $void$ O O O $any$ O $any$ O O O $any[]$ O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $string$ O O O $any[]$ O $number$ O $string$ O O O O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O O $complex$ O $string[]$ O O O O O $Document$ O O O O O $any$ O O O $any$ O O O $any$ O O O $any[]$ O O O O $any$ O $any$ O O $void$ O O O O O O O O ${}$ O ${}$ O $any[]$ O O $number$ O O O $any$ O $number$ O $IArguments$ O O $number$ O O $any$ O $string$ O $IArguments$ O $number$ O O O ${}$ O $string$ O O O O O $void$ O $any[]$ O ${}$ O O $any$ O $any$ O $string$ O $any$ O $any[]$ O O O O O O $void$ O O O O O O O O ${}$ O ${}$ O $any[]$ O O $number$ O O O $any$ O $number$ O $IArguments$ O O $number$ O O $any$ O $string$ O $IArguments$ O $number$ O O O ${}$ O $string$ O O O O O $void$ O $any[]$ O ${}$ O O $any$ O $any$ O $string$ O $any$ O $any[]$ O O O O O O O O $any$ O O O O O O $ArrayConstructor$ O $any[]$ O $string$ O $ArrayConstructor$ O $any[]$ O $complex$ O $Document$ O O O O O O O O O $ObjectConstructor$ O $complex$ O O $ObjectConstructor$ O $complex$ O O O O O O O O O $boolean$ O $ObjectConstructor$ O $Object$ O $boolean$ O $boolean$ O O O O $null$ O O O O O $boolean$ O O O O $string[]$ O O O O O O O O O O O O O O O O O $number$ O $string[]$ O $number$ O O O O $any$ O O O O O $any$ O O O O O $any$ O O O $any$ O O O O O O O $TypeErrorConstructor$ O O O O O O $any[]$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $boolean$ O $any$ O $any$ O $string$ O O O $any[]$ O $number$ O $string$ O O O O O O $boolean$ O O O O $any$ O O O $number$ O $number$ O $any$ O O O O O $boolean$ O $any$ O $any$ O $string[]$ O $number$ O O O O $any[]$ O $number$ O $string[]$ O $number$ O O O O O O O $string[]$ O O O O O O O O O O O O $ArrayConstructor$ O $any[]$ O $void$ O O $ArrayConstructor$ O $any[]$ O $void$ O O O $void$ O $any$ O O O $any$ O $any$ O O O O O O O O O O $TypeErrorConstructor$ O O O O O O $any$ O $ObjectConstructor$ O O O O O $number$ O $any$ O $any$ O O O O O O $void$ O O O O O O $TypeErrorConstructor$ O $never$ O O O O O O O $IArguments$ O $number$ O O O O $any$ O $any$ O O $any$ O O O O O $number$ O $number$ O O O $any$ O O O $number$ O $any$ O O $any$ O $any$ O $number$ O O $void$ O $any$ O $any$ O $any$ O $number$ O $any$ O O O $any$ O O O O O O O O O $ArrayConstructor$ O $any[]$ O $U[]$ O O $ArrayConstructor$ O $any[]$ O $U[]$ O O O $U$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O O $TypeErrorConstructor$ O O O O O O $any$ O $ObjectConstructor$ O O O O O $number$ O $any$ O $any$ O O O O O O $U$ O O O O O O $TypeErrorConstructor$ O $never$ O O O O O O O $IArguments$ O $number$ O O O O $any$ O $any$ O O $any$ O O $ArrayConstructor$ O $number$ O O $any$ O O O O O $number$ O $number$ O O O $any$ O $any$ O O O $number$ O $any$ O O $any$ O $any$ O $number$ O O $any$ O $U$ O $any$ O $any$ O $any$ O $number$ O $any$ O O $any[]$ O $number$ O O $any$ O O $any$ O O O O $any[]$ O O O O O O O $Document$ O O O O O O O O O O $Document$ O O O O O $any$ O $any$ O O O O O $any$ O O O O O O $Document$ O O O O O O O O O O O
'js' import pkg from 's' ; export default [ { input : 's' , output : { name : 's' , file : pkg . browser , format : 's' } , plugins : [ ] } , { input : 's' , output : { file : pkg . main , format : 's' } } , { input : 's' , output : { file : 's' , format : 's' } } , { input : 's' , output : { file : 's' , format : 's' } } ] ;	O O $any$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O O $undefined[]$ O O O O O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O O O O
import { CalculationCache } from 's' ; export let createCache = < Result > ( ) : CalculationCache < Result > => { let cachedInputs : Object [ ] | undefined ; let cachedOutcome : Result | undefined ; return { invalidate : ( ) => { cachedOutcome = undefined ; cachedInputs = undefined ; } , result : ( inputs : Object [ ] , calculation : ( ) => Result ) => { if ( cachedInputs ) { for ( let i = 0 ; i < inputs . length ; i ++ ) { if ( cachedInputs [ i ] !== inputs [ i ] ) { cachedOutcome = undefined ; } } } if ( ! cachedOutcome ) { cachedOutcome = calculation ( ) ; cachedInputs = inputs ; } return cachedOutcome ; } } ; } ;	O O $any$ O O O O O O $CalculationCache<Result>$ O O $any$ O O O O $any$ O $any$ O O O O $Object[]$ O $ObjectConstructor$ O O O O O O $Result$ O $any$ O O O O O $void$ O O O O O $Result$ O $undefined$ O $Object[]$ O $undefined$ O O O $Result$ O O $Object[]$ O $ObjectConstructor$ O O O $Result$ O O O O $any$ O O O O O $Object[]$ O O O O O $number$ O O O $number$ O $Object[]$ O $number$ O $number$ O O O O O $Object[]$ O $number$ O O $Object[]$ O $number$ O O O $Result$ O $undefined$ O O O O O O O $Result$ O O $Result$ O $Result$ O O O $Object[]$ O $Object[]$ O O O $Result$ O O O O O O
export * from 's' ; export { dom } from 's' ; export { h } from 's' ; export { createProjector } from 's' ; export { createCache } from 's' ; export { createMapping } from 's' ;	O O O O O O O $complex$ O O O O O O $complex$ O O O O O O $Projector$ O O O O O O $CalculationCache<Result>$ O O O O O O $Mapping<...>$ O O O O
import chai = require ( 's' ) ; import chaiAsPromised = require ( 's' ) ; chai . use ( chaiAsPromised ) ; let expect = chai . expect ; import sinon = require ( 's' ) ; import sinonChai = require ( 's' ) ; chai . use ( sinonChai ) ; require ( 's' ) ; export { chai , expect , sinon } ;	O $any$ O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O
import { expect , sinon } from 's' ; import { createCache } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let cache = createCache ( ) ; let calculate = sinon . stub ( ) . returns ( 's' ) ; let result = cache . result ( [ 0 ] , calculate ) ; expect ( calculate ) . to . be . calledOnce ; expect ( result ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let cache = createCache ( ) ; let calculate = sinon . stub ( ) . returns ( 's' ) ; cache . result ( [ 0 ] , calculate ) ; expect ( calculate ) . to . have . callCount ( 0 ) ; cache . result ( [ 0 ] , calculate ) ; expect ( calculate ) . to . have . callCount ( 0 ) ; cache . result ( [ 0 ] , calculate ) ; expect ( calculate ) . to . have . callCount ( 0 ) ; } ) ; it ( 's' , ( ) => { let cache = createCache ( ) ; let calculate = sinon . stub ( ) . returns ( 's' ) ; cache . result ( [ 0 ] , calculate ) ; cache . invalidate ( ) ; cache . result ( [ 0 ] , calculate ) ; expect ( calculate ) . to . have . callCount ( 0 ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $CalculationCache<Result>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $CalculationCache<unknown>$ O $CalculationCache<Result>$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $unknown$ O $CalculationCache<unknown>$ O $unknown$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $unknown$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $CalculationCache<unknown>$ O $CalculationCache<Result>$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $CalculationCache<unknown>$ O $unknown$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $CalculationCache<unknown>$ O $unknown$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $CalculationCache<unknown>$ O $unknown$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $CalculationCache<unknown>$ O $CalculationCache<Result>$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $CalculationCache<unknown>$ O $unknown$ O O O O O $any$ O O $CalculationCache<unknown>$ O $void$ O O O $CalculationCache<unknown>$ O $unknown$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O
import { expect , sinon } from 's' ; import { h , dom } from 's' ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { let afterCreate = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , { afterCreate } ) ) ; expect ( afterCreate ) . to . have . been . calledWith ( projection . domNode ) ; } ) ; it ( 's' , ( ) => { let afterCreate = sinon . spy ( ) ; let thisObject = sinon . spy ( ) ; dom . create ( h ( 's' , { afterCreate : afterCreate , bind : thisObject } ) ) ; expect ( afterCreate ) . to . be . calledOn ( thisObject ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let afterUpdate = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , { afterUpdate } ) ) ; projection . update ( h ( 's' , { afterUpdate } ) ) ; expect ( afterUpdate ) . to . have . been . calledWith ( projection . domNode ) ; } ) ; it ( 's' , ( ) => { let afterUpdate = sinon . spy ( ) ; let thisObject = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , { afterUpdate : afterUpdate , bind : thisObject } ) ) ; projection . update ( h ( 's' , { afterUpdate : afterUpdate , bind : thisObject } ) ) ; expect ( afterUpdate ) . to . be . calledOn ( thisObject ) ; } ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $complex$ O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $Projection$ O $Element$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $complex$ O $Projection$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $Projection$ O $Element$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O
import { expect , sinon } from 's' ; import { dom , h } from 's' ; import { SinonFakeTimers , SinonStub } from 's' ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { let requestIdleCallback ; let clock ; beforeEach ( ( ) => { requestIdleCallback = sinon . stub ( ) ; global . window = < any > { requestIdleCallback } ; clock = sinon . useFakeTimers ( ) ; } ) ; afterEach ( ( ) => { delete global . window ; clock . restore ( ) ; } ) ; it ( 's' , ( ) => { let 0 = sinon . spy ( ) ; let 0 = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , [ h ( 's' , { } , [ h ( 's' , { afterRemoved : 0 } , [ h ( 's' , { } , [ h ( 's' , { afterRemoved : 0 } , [ ] ) ] ) ] ) ] ) ] ) ) ; projection . update ( h ( 's' , [ ] ) ) ; expect ( requestIdleCallback ) . to . have . been . calledOnce ; requestIdleCallback . yield ( ) ; expect ( 0 ) . to . have . been . called ; expect ( 0 ) . to . have . been . called ; } ) ; it ( 's' , ( ) => { let 0 = sinon . spy ( ) ; let 0 = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , [ h ( 's' , { afterRemoved : 0 } ) , h ( 's' , { afterRemoved : 0 } ) ] ) ) ; projection . update ( h ( 's' , [ ] ) ) ; expect ( requestIdleCallback ) . to . have . been . calledOnce ; requestIdleCallback . yield ( ) ; expect ( 0 ) . to . have . been . called ; expect ( 0 ) . to . have . been . called ; } ) ; it ( 's' , ( ) => { delete ( global as any ) . window ; let afterRemoved = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , [ h ( 's' , { afterRemoved } ) ] ) ) ; projection . update ( h ( 's' , [ ] ) ) ; expect ( afterRemoved ) . to . not . have . been . called ; clock . tick ( 0 ) ; expect ( afterRemoved ) . to . have . been . called ; } ) ; it ( 's' , ( ) => { requestIdleCallback . yields ( ) ; let afterRemoved = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , [ h ( 's' , { afterRemoved } ) ] ) ) ; let domNode = projection . domNode . children [ 0 ] ; projection . update ( h ( 's' , [ ] ) ) ; expect ( afterRemoved ) . to . have . been . calledWith ( domNode ) ; } ) ; it ( 's' , ( ) => { requestIdleCallback . yields ( ) ; let afterRemoved = sinon . spy ( ) ; let thisObject = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , [ h ( 's' , { afterRemoved , bind : thisObject } ) ] ) ) ; projection . update ( h ( 's' , [ ] ) ) ; expect ( afterRemoved ) . to . have . been . calledOn ( thisObject ) ; } ) ; it ( 's' , ( ) => { requestIdleCallback . yields ( ) ; let afterRemoved = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , [ h ( 's' , { afterRemoved , exitAnimation : ( element , removeElement ) => removeElement ( ) } ) ] ) ) ; projection . update ( h ( 's' , [ ] ) ) ; expect ( afterRemoved ) . to . have . been . called ; } ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $complex$ O $complex$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $SinonStub$ O O $SinonFakeTimers$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O O O O $complex$ O O O O $any$ O $any$ O O O $complex$ O O O O O O O $complex$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O $Projection$ O $void$ O $complex$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $any$ O $any$ O O O $complex$ O O O O $any$ O $any$ O O O O O O $Projection$ O $void$ O $complex$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $any$ O O O O O O $Projection$ O $void$ O $complex$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $any$ O O O O O O O $Element$ O $Projection$ O $Element$ O $HTMLCollection$ O O O O $Projection$ O $void$ O $complex$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $Element$ O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $any$ O $any$ O $any$ O O O O O O $Projection$ O $void$ O $complex$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $any$ O $void$ O O $Element$ O $void$ O O $void$ O O O O O O O O $Projection$ O $void$ O $complex$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O
import { expect , sinon } from 's' ; import { dom , h } from 's' ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { let updateAnimation = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , { updateAnimation } , [ 's' ] ) ) ; projection . update ( h ( 's' , { updateAnimation } , [ 's' ] ) ) ; expect ( updateAnimation ) . to . have . been . calledOnce ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let updateAnimation = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , { updateAnimation } , [ 's' , h ( 's' ) , 's' ] ) ) ; projection . update ( h ( 's' , { updateAnimation } , [ 's' , h ( 's' ) , 's' ] ) ) ; expect ( updateAnimation ) . to . have . been . calledOnce ; updateAnimation . resetHistory ( ) ; projection . update ( h ( 's' , { updateAnimation } , [ 's' , h ( 's' ) , 's' ] ) ) ; expect ( updateAnimation ) . to . not . have . been . called ; } ) ; it ( 's' , ( ) => { let updateAnimation = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , { updateAnimation , href : 's' } ) ) ; projection . update ( h ( 's' , { updateAnimation , href : 's' } ) ) ; expect ( updateAnimation ) . to . have . been . calledWith ( projection . domNode , sinon . match ( { href : 's' } ) , sinon . match ( { href : 's' } ) ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let enterAnimation = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , [ ] ) ) ; projection . update ( h ( 's' , [ h ( 's' , { enterAnimation } ) ] ) ) ; expect ( enterAnimation ) . to . have . been . calledWith ( projection . domNode . childNodes [ 0 ] , sinon . match ( { } ) ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let exitAnimation = sinon . spy ( ) ; let projection = dom . create ( h ( 's' , [ h ( 's' , { exitAnimation } ) ] ) ) ; projection . update ( h ( 's' , [ ] ) ) ; expect ( exitAnimation ) . to . have . been . calledWithExactly ( projection . domNode . childNodes [ 0 ] , sinon . match ( { } ) , sinon . match ( { } ) ) ; expect ( projection . domNode . childNodes ) . to . have . length ( 0 ) ; exitAnimation . lastCall . callArg ( 0 ) ; expect ( projection . domNode . childNodes ) . to . be . empty ; exitAnimation . lastCall . callArg ( 0 ) ; } ) ; } ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $complex$ O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $any$ O O O O O O O O $Projection$ O $void$ O $complex$ O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $any$ O O O O O $complex$ O O O O O O O O O $Projection$ O $void$ O $complex$ O O O O $any$ O O O O O $complex$ O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $Projection$ O $void$ O $complex$ O O O O $any$ O O O O O $complex$ O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $any$ O $string$ O O O O O O $Projection$ O $void$ O $complex$ O O O O $any$ O $string$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $Projection$ O $Element$ O $any$ O $any$ O O $string$ O O O O O $any$ O $any$ O O $string$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $Projection$ O $Element$ O $NodeListOf<ChildNode>$ O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $any$ O O O O O O $Projection$ O $void$ O $complex$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $Projection$ O $Element$ O $NodeListOf<ChildNode>$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $Projection$ O $Element$ O $NodeListOf<ChildNode>$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $Projection$ O $Element$ O $NodeListOf<ChildNode>$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O
import { expect } from 's' ; import { dom , h } from 's' ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , { key : 0 } ) , h ( 's' , { key : 0 } ) , h ( 's' , { key : 0 } ) ] ) ) ; let div = projection . domNode as HTMLDivElement ; expect ( div . children . length ) . to . equal ( 0 ) ; let firstSpan = div . children [ 0 ] ; let lastSpan = div . children [ 0 ] ; projection . update ( h ( 's' , [ h ( 's' , { key : 0 } ) , h ( 's' , { key : 0 } ) ] ) ) ; expect ( div . children . length ) . to . equal ( 0 ) ; expect ( div . children [ 0 ] ) . to . equal ( firstSpan ) ; expect ( div . children [ 0 ] ) . to . equal ( lastSpan ) ; projection . update ( h ( 's' , [ h ( 's' , { key : 0 } ) ] ) ) ; expect ( div . children . length ) . to . equal ( 0 ) ; expect ( div . children [ 0 ] ) . to . equal ( lastSpan ) ; projection . update ( h ( 's' , [ ] ) ) ; expect ( div . children . length ) . to . equal ( 0 ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , { key : 0 } ) , h ( 's' , { key : 0 } ) ] ) ) ; let div = projection . domNode as HTMLDivElement ; expect ( div . children . length ) . to . equal ( 0 ) ; let firstSpan = div . children [ 0 ] ; let lastSpan = div . children [ 0 ] ; projection . update ( h ( 's' , [ h ( 's' , { key : 0 } ) , h ( 's' , { key : 0 } ) , h ( 's' , { key : 0 } ) , h ( 's' , { key : 0 } ) , h ( 's' , { key : 0 } ) ] ) ) ; expect ( div . children . length ) . to . equal ( 0 ) ; expect ( div . children [ 0 ] ) . to . equal ( firstSpan ) ; expect ( div . children [ 0 ] ) . to . equal ( lastSpan ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , { bind : { } } ) ] ) ) ; let div = projection . domNode as HTMLDivElement ; expect ( div . children . length ) . to . equal ( 0 ) ; projection . update ( h ( 's' , [ h ( 's' , { bind : { } } ) , h ( 's' , { bind : { } } ) ] ) ) ; expect ( div . children . length ) . to . equal ( 0 ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , { key : 's' } ) , h ( 's' , { key : 's' } ) ] ) ) ; let div = projection . domNode as HTMLDivElement ; expect ( div . children . length ) . to . equal ( 0 ) ; let firstSpan = div . children [ 0 ] ; let secondSpan = div . children [ 0 ] ; projection . update ( h ( 's' , [ h ( 's' , { key : 's' } ) , h ( 's' , { key : 's' } ) , h ( 's' , { key : 's' } ) ] ) ) ; expect ( div . childNodes . length ) . to . equal ( 0 ) ; expect ( div . childNodes [ 0 ] ) . to . equal ( firstSpan ) ; expect ( div . childNodes [ 0 ] ) . to . equal ( secondSpan ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , { key : false } ) , h ( 's' , < any > { key : null } ) , h ( 's' , { key : 's' } ) , h ( 's' , { } ) ] ) ) ; let div = projection . domNode as HTMLDivElement ; expect ( div . children . length ) . to . equal ( 0 ) ; let firstSpan = div . children [ 0 ] ; let secondSpan = div . children [ 0 ] ; let thirdSpan = div . children [ 0 ] ; let fourthSpan = div . children [ 0 ] ; projection . update ( h ( 's' , [ h ( 's' , { key : 0 } ) ] ) ) ; expect ( div . children . length ) . to . equal ( 0 ) ; let newSpan = div . childNodes [ 0 ] ; expect ( newSpan ) . not . to . equal ( firstSpan ) ; expect ( newSpan ) . not . to . equal ( secondSpan ) ; expect ( newSpan ) . not . to . equal ( thirdSpan ) ; expect ( newSpan ) . not . to . equal ( fourthSpan ) ; } ) ; it ( 's' , ( ) => { let showMore = false ; let render = ( ) => h ( 's' , [ h ( 's' ) , showMore && h ( 's' ) ] ) ; expect ( render ( ) . children ) . to . have . length ( 0 ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , { key : 's' } ) , h ( 's' , { key : 's' } ) , h ( 's' , { key : 's' } ) ] ) ) ; let div = projection . domNode as HTMLDivElement ; expect ( div . children . length ) . to . equal ( 0 ) ; let firstSpan = div . children [ 0 ] ; let thirdSpan = div . children [ 0 ] ; projection . update ( h ( 's' , [ h ( 's' , { key : 's' } ) , h ( 's' , { key : 's' } ) ] ) ) ; expect ( div . childNodes . length ) . to . equal ( 0 ) ; expect ( div . childNodes [ 0 ] ) . to . equal ( firstSpan ) ; expect ( div . childNodes [ 0 ] ) . to . equal ( thirdSpan ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , { key : 0 } ) , h ( 's' , { key : false } ) , h ( 's' , < any > { key : null } ) ] ) ) ; let div = projection . domNode as HTMLDivElement ; expect ( div . children . length ) . to . equal ( 0 ) ; let firstSpan = div . children [ 0 ] ; let thirdSpan = div . children [ 0 ] ; projection . update ( h ( 's' , [ h ( 's' , { key : 0 } ) , h ( 's' , < any > { key : null } ) ] ) ) ; expect ( div . childNodes . length ) . to . equal ( 0 ) ; expect ( div . childNodes [ 0 ] ) . to . equal ( firstSpan ) ; expect ( div . childNodes [ 0 ] ) . to . equal ( thirdSpan ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , { key : 's' } ) , h ( 's' , { key : 's' } ) ] ) ) ; let div = projection . domNode as HTMLDivElement ; expect ( div . children . length ) . to . equal ( 0 ) ; let firstSpan = div . children [ 0 ] ; let lastSpan = div . children [ 0 ] ; projection . update ( h ( 's' , [ h ( 's' , { key : 's' } ) , h ( 's' , { key : 's' } ) ] ) ) ; expect ( div . childNodes . length ) . to . equal ( 0 ) ; expect ( div . childNodes [ 0 ] ) . to . not . equal ( firstSpan ) ; expect ( div . childNodes [ 0 ] ) . to . equal ( lastSpan ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , { key : 0 } ) , h ( 's' , { key : 0 } ) ] ) ) ; let div = projection . domNode as HTMLDivElement ; expect ( div . children . length ) . to . equal ( 0 ) ; let firstSpan = div . children [ 0 ] ; let lastSpan = div . children [ 0 ] ; projection . update ( h ( 's' , [ h ( 's' , { key : 0 } ) , 's' , h ( 's' , { key : 0 } ) ] ) ) ; expect ( div . childNodes . length ) . to . equal ( 0 ) ; expect ( div . childNodes [ 0 ] ) . to . equal ( firstSpan ) ; expect ( div . childNodes [ 0 ] ) . to . equal ( lastSpan ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ 's' ] ) ) ; let span = projection . domNode as HTMLSpanElement ; expect ( span . childNodes . length ) . to . equal ( 0 ) ; projection . update ( h ( 's' , [ undefined ] ) ) ; expect ( span . childNodes . length ) . to . equal ( 0 ) ; projection . update ( h ( 's' , [ 's' ] ) ) ; expect ( span . childNodes . length ) . to . equal ( 0 ) ; projection . update ( h ( 's' , [ undefined ] ) ) ; expect ( span . childNodes . length ) . to . equal ( 0 ) ; projection . update ( h ( 's' , [ 's' ] ) ) ; expect ( span . childNodes . length ) . to . equal ( 0 ) ; projection . update ( h ( 's' , [ 's' ] ) ) ; expect ( span . childNodes . length ) . to . equal ( 0 ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , [ 's' ] ) , h ( 's' , [ 's' ] ) ] ) ) ; expect ( ( ) => { projection . update ( h ( 's' , [ h ( 's' , [ 's' ] ) , h ( 's' , [ 's' ] ) , h ( 's' , [ 's' ] ) ] ) ) ; } ) . to . throw ( ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , [ 's' ] ) , h ( 's' , [ 's' ] ) , h ( 's' , [ 's' ] ) ] ) ) ; expect ( ( ) => { projection . update ( h ( 's' , [ h ( 's' , [ 's' ] ) , h ( 's' , [ 's' ] ) ] ) ) ; } ) . to . throw ( ) ; } ) ; it ( 's' , ( ) => { let text = 's' ; let handleInput = ( evt ) => { text = ( evt . currentTarget as HTMLElement ) . innerHTML ; } ; let render = ( ) => h ( 's' , { contentEditable : true , oninput : handleInput , innerHTML : text } ) ; let projection = dom . create ( render ( ) ) ; projection . domNode . removeChild ( projection . domNode . firstChild ) ; handleInput ( < any > { currentTarget : projection . domNode } ) ; projection . update ( render ( ) ) ; projection . domNode . innerHTML = 's' ; handleInput ( < any > { currentTarget : projection . domNode } ) ; projection . update ( render ( ) ) ; expect ( projection . domNode . innerHTML ) . to . equal ( 's' ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , [ h ( 's' , { cx : 's' , cy : 's' , r : 's' , fill : 's' } ) , h ( 's' , { href : 's' } ) ] ) , h ( 's' ) ] ) ) ; let svg = projection . domNode . firstChild ; expect ( svg . namespaceURI ) . to . equal ( 's' ) ; let circle = svg . firstChild ; expect ( circle . namespaceURI ) . to . equal ( 's' ) ; let image = svg . lastChild as SVGElement ; expect ( image . attributes [ 0 ] . namespaceURI ) . to . equal ( 's' ) ; let span = projection . domNode . lastChild ; expect ( span . namespaceURI ) . to . equal ( 's' ) ; projection . update ( h ( 's' , [ h ( 's' , [ h ( 's' , { key : 's' , cx : 's' , cy : 's' , r : 's' , fill : 's' } ) , h ( 's' , { href : 's' } ) ] ) , h ( 's' ) ] ) ) ; let blueCircle = svg . firstChild ; expect ( blueCircle . namespaceURI ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ h ( 's' , [ h ( 's' , { cx : 0 , cy : 0 , r : 0 , fill : 's' } ) , h ( 's' , { width : 0 , height : 0 , x : 0 , y : 0 , fill : 's' } ) ] ) ] ) ) ; let svg = projection . domNode . firstChild ; let circle = svg . firstChild as SVGCircleElement ; expect ( circle . getAttribute ( 's' ) ) . to . equal ( 's' ) ; expect ( circle . getAttribute ( 's' ) ) . to . equal ( 's' ) ; let rect = svg . lastChild as SVGRectElement ; expect ( rect . getAttribute ( 's' ) ) . to . equal ( 's' ) ; expect ( rect . getAttribute ( 's' ) ) . to . equal ( 's' ) ; projection . update ( h ( 's' , [ h ( 's' , [ h ( 's' , { cx : 0 , cy : 0 , r : 0 , fill : 's' } ) , h ( 's' , { width : 0 , height : 0 , x : 0 , y : 0 , fill : 's' } ) ] ) ] ) ) ; expect ( circle . getAttribute ( 's' ) ) . to . equal ( 's' ) ; } ) ; } ) ; } ) ; } ) ;	O O $any$ O O O O O O $complex$ O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $number$ O O O O O $complex$ O O O O $number$ O O O O O $complex$ O O O O $number$ O O O O O O O O O $HTMLDivElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O $number$ O O O O O $complex$ O O O O $number$ O O O O O O O O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O $any$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $any$ O $any$ O $Element$ O O $any$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $any$ O $any$ O $Element$ O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O $number$ O O O O O O O O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O $any$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $any$ O $any$ O $Element$ O O $Projection$ O $void$ O $complex$ O O O O O O O O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $number$ O O O O O $complex$ O O O O $number$ O O O O O O O O O $HTMLDivElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O $number$ O O O O O $complex$ O O O O $number$ O O O O O $complex$ O O O O $number$ O O O O O $complex$ O O O O $number$ O O O O O $complex$ O O O O $number$ O O O O O O O O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O $any$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $any$ O $any$ O $Element$ O O $any$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $any$ O $any$ O $Element$ O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O ${}$ O O O O O O O O O O $HTMLDivElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O ${}$ O O O O O O $complex$ O O O O ${}$ O O O O O O O O O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O O O O O $HTMLDivElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O O O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O $number$ O O $any$ O $any$ O O O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O O O O O $any$ O $any$ O $Element$ O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O O O O O $any$ O $any$ O $Element$ O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $boolean$ O O O O O $complex$ O O O O O O O $null$ O O O O O $complex$ O O O O $string$ O O O O O $complex$ O O O O O O O O O O O $HTMLDivElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O $number$ O O O O O O O O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O O $ChildNode$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O O O O $any$ O $ChildNode$ O O $any$ O $any$ O $any$ O $Element$ O O $any$ O $ChildNode$ O O $any$ O $any$ O $any$ O $Element$ O O $any$ O $ChildNode$ O O $any$ O $any$ O $any$ O $Element$ O O $any$ O $ChildNode$ O O $any$ O $any$ O $any$ O $Element$ O O O O O $any$ O O O O O O O O $boolean$ O O O O $VNode$ O O O O $complex$ O O O O $complex$ O O O O $boolean$ O $complex$ O O O O O O $any$ O $VNode$ O O O $VNode[]$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O O O O O $HTMLDivElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O O O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O $number$ O O $any$ O $any$ O O O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O O O O O $any$ O $any$ O $Element$ O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O O O O O $any$ O $any$ O $Element$ O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $number$ O O O O O $complex$ O O O O $boolean$ O O O O O $complex$ O O O O O O O $null$ O O O O O O O O O $HTMLDivElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O $number$ O O O O O $complex$ O O O O O O O $null$ O O O O O O O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O $number$ O O $any$ O $any$ O O O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O O O O O $any$ O $any$ O $Element$ O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O O O O O $any$ O $any$ O $Element$ O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O O O O O $HTMLDivElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O O O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O $number$ O O $any$ O $any$ O O O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O O O O O $any$ O $any$ O $any$ O $Element$ O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O O O O O $any$ O $any$ O $Element$ O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $number$ O O O O O $complex$ O O O O $number$ O O O O O O O O O $HTMLDivElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLDivElement$ O $HTMLCollection$ O $number$ O O $any$ O $any$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O O $Element$ O $HTMLDivElement$ O $HTMLCollection$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O $number$ O O O O O O O $complex$ O O O O $number$ O O O O O O O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O $number$ O O $any$ O $any$ O O O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O O O O O $any$ O $any$ O $Element$ O O $any$ O $HTMLDivElement$ O $NodeListOf<ChildNode>$ O O O O O $any$ O $any$ O $Element$ O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O O O O O O O $HTMLSpanElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLSpanElement$ O $NodeListOf<ChildNode>$ O $number$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $undefined$ O O O O $any$ O $HTMLSpanElement$ O $NodeListOf<ChildNode>$ O $number$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O O O O O O $any$ O $HTMLSpanElement$ O $NodeListOf<ChildNode>$ O $number$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $undefined$ O O O O $any$ O $HTMLSpanElement$ O $NodeListOf<ChildNode>$ O $number$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O O O O O O $any$ O $HTMLSpanElement$ O $NodeListOf<ChildNode>$ O $number$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O O O O O O $any$ O $HTMLSpanElement$ O $NodeListOf<ChildNode>$ O $number$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O O O O O $complex$ O O O O O O O O O O O $any$ O O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O O O O O $complex$ O O O O O O O O $complex$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O O O O O $complex$ O O O O O O O O $complex$ O O O O O O O O O O O $any$ O O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O O O O O $complex$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $string$ O O O O $void$ O O $Event$ O O O $string$ O O $Event$ O $EventTarget$ O $complex$ O O $string$ O O O O $VNode$ O O O O $complex$ O O O O $boolean$ O O O $void$ O $void$ O $string$ O $string$ O O O O $Projection$ O $complex$ O $Projection$ O $VNode$ O O O O $Projection$ O $Element$ O $T$ O $Projection$ O $Element$ O $ChildNode$ O O $void$ O O O O O $Element$ O $Projection$ O $Element$ O O O $Projection$ O $void$ O $VNode$ O O O O $Projection$ O $Element$ O $string$ O O O $void$ O O O O O $Element$ O $Projection$ O $Element$ O O O $Projection$ O $void$ O $VNode$ O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $complex$ O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O O O $complex$ O O O O O O O O $ChildNode$ O $Projection$ O $Element$ O $ChildNode$ O $any$ O $ChildNode$ O $string$ O O $any$ O $any$ O O O O O $ChildNode$ O $ChildNode$ O $ChildNode$ O $any$ O $ChildNode$ O $string$ O O $any$ O $any$ O O O O O $SVGElement$ O $ChildNode$ O $ChildNode$ O $complex$ O $any$ O $SVGElement$ O $NamedNodeMap$ O O O O $string$ O O $any$ O $any$ O O O O O $ChildNode$ O $Projection$ O $Element$ O $ChildNode$ O $any$ O $ChildNode$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O $complex$ O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O O O $string$ O O O O O O O $complex$ O O O O O O O O $ChildNode$ O $ChildNode$ O $ChildNode$ O $any$ O $ChildNode$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O O O $complex$ O O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O O O $complex$ O O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O O O O O O O O O $ChildNode$ O $Projection$ O $Element$ O $ChildNode$ O O $SVGCircleElement$ O $ChildNode$ O $ChildNode$ O $complex$ O $any$ O $SVGCircleElement$ O $string$ O O O O O $any$ O $any$ O O O O $any$ O $SVGCircleElement$ O $string$ O O O O O $any$ O $any$ O O O O O $SVGRectElement$ O $ChildNode$ O $ChildNode$ O $complex$ O $any$ O $SVGRectElement$ O $string$ O O O O O $any$ O $any$ O O O O $any$ O $SVGRectElement$ O $string$ O O O O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O O O $complex$ O O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O O O $complex$ O O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O O O O O O O O $any$ O $SVGCircleElement$ O $string$ O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O
import { expect , sinon } from 's' ; import { dom , h } from 's' ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ 's' ] ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , [ 's' ] ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , [ 's' , h ( 's' , [ 's' ] ) ] ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , [ 's' ] ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , [ 's' ] ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , [ 's' , 's' , 's' ] ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , [ 's' , 's' ] ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , [ 's' , 's' , 's' ] ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection = dom . create ( h ( 's' ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection = dom . create ( h ( 's' ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection = dom . create ( h ( 's' ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection = dom . create ( h ( 's' ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection = dom . create ( h ( 's' ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' ) ) ; expect ( ( ) => { projection . update ( h ( 's' ) ) ; } ) . to . throw ( "s" ) ; } ) ; it ( 's' , ( ) => { const node = document . createElement ( 's' ) ; ( node as any ) . foo = 's' ; const childNode = document . createElement ( 's' ) ; ( childNode as any ) . bar = 's' ; node . appendChild ( childNode ) ; const spy = sinon . spy ( node , 's' ) ; const childVNode = h ( 's' , { id : 's' } ) ; childVNode . domNode = childNode ; const vnode = h ( 's' , { id : 's' } , [ childVNode ] ) ; vnode . domNode = node ; const projection = dom . create ( vnode ) ; const root = projection . domNode as any ; expect ( root . outerHTML ) . to . equal ( 's' ) ; expect ( root . foo ) . to . equal ( 's' ) ; expect ( root . children [ 0 ] . bar ) . to . equal ( 's' ) ; expect ( spy . called ) . to . be . false ; } ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $complex$ O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O O O $complex$ O O O O O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O O O O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O O O O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O O $any$ O O O O O $Projection$ O $void$ O $complex$ O O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $HTMLDivElement$ O $Document$ O O O O O O O $HTMLDivElement$ O O O O $any$ O O O O $HTMLSpanElement$ O $Document$ O O O O O O O $HTMLSpanElement$ O O O O $any$ O O O $HTMLDivElement$ O $T$ O $HTMLSpanElement$ O O O $any$ O $any$ O $any$ O $HTMLDivElement$ O O O O O $VNode$ O $complex$ O O O O $string$ O O O O O $VNode$ O $Node$ O $HTMLSpanElement$ O O $VNode$ O $complex$ O O O O $string$ O O O O O $VNode$ O O O $VNode$ O $Node$ O $HTMLDivElement$ O O $Projection$ O $complex$ O $Projection$ O $VNode$ O O O $any$ O $Projection$ O $Element$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O
import { expect , sinon } from 's' ; import { dom , h } from 's' ; let noopEventHandlerInterceptor = ( propertyName , functionPropertyArgument ) => { return function ( this ) { return functionPropertyArgument . apply ( this , arguments ) ; } ; } ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { classes : { a : true , b : false } } ) ) ; let div = projection . domNode as HTMLDivElement ; expect ( div . className ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { classes : { a : true , b : true } } ) ) ; expect ( div . className ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { classes : { a : false , b : true } } ) ) ; expect ( div . className ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { class : 's' } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { class : 's' } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { class : undefined } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { class : 's' } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { class : 's' } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { class : 's' } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { class : undefined } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { class : 's' } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { classes : { extra : true } , class : 's' } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { classes : { extra : true } , class : 's' } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { classes : { extra : false } , class : 's' } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { class : 's' } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { class : 's' } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { class : undefined } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { class : undefined } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { class : 's' } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( ( ) => { dom . create ( h ( 's' , { className : 's' } as any ) ) ; } ) . to . throw ( Error ) ; } ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { href : 's' } ) ) ; let link = projection . domNode as HTMLLinkElement ; expect ( link . getAttribute ( 's' ) ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { href : 's' } ) ) ; expect ( link . getAttribute ( 's' ) ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { href : undefined } ) ) ; expect ( link . getAttribute ( 's' ) ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { href : undefined } ) ) ; let link = projection . domNode as HTMLLinkElement ; expect ( link . getAttribute ( 's' ) ) . to . be . null ; projection . update ( h ( 's' , { href : 's' } ) ) ; expect ( link . getAttribute ( 's' ) ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { disabled : true } ) ) ; let link = projection . domNode as HTMLLinkElement ; expect ( link . disabled ) . to . equal ( true ) ; projection . update ( h ( 's' , < any > { disabled : null } ) ) ; expect ( link . disabled ) . to . be . null ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { href : 's' , tabIndex : 0 } ) ) ; let link = projection . domNode as HTMLLinkElement ; expect ( link . tabIndex ) . to . equal ( 0 ) ; projection . update ( h ( 's' , { href : 's' , tabIndex : 0 } ) ) ; expect ( link . tabIndex ) . to . equal ( 0 ) ; projection . update ( h ( 's' , { href : 's' , tabIndex : undefined } ) ) ; expect ( link . tabIndex ) . to . equal ( 0 ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { innerHTML : 's' } ) ) ; let paragraph = projection . domNode as HTMLElement ; expect ( paragraph . childNodes ) . to . have . length ( 0 ) ; expect ( paragraph . firstChild . textContent ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { innerHTML : 's' } ) ) ; expect ( paragraph . childNodes ) . to . have . length ( 0 ) ; expect ( paragraph . firstChild . textContent ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { scrollTop : 0 } ) ) ; let div = projection . domNode as HTMLDivElement ; Object . defineProperty ( div , 's' , { get : ( ) => 0 , set : sinon . stub ( ) . throws ( 's' ) } ) ; projection . update ( h ( 's' , { scrollTop : 0 } ) ) ; } ) ; it ( 's' , ( ) => { let parentNode = { appendChild : sinon . spy ( ( child ) => { expect ( child . getAttribute ( 's' ) ) . to . equal ( 's' ) ; } ) , ownerDocument : { createElement : sinon . spy ( ( tag ) => { return document . createElement ( tag ) ; } ) } } ; dom . append ( < any > parentNode , h ( 's' , { type : 's' } ) ) ; expect ( parentNode . appendChild ) . to . have . been . called ; expect ( parentNode . ownerDocument . createElement ) . to . have . been . called ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let typedKeys = 's' ; let handleInput = ( evt ) => { typedKeys = ( evt . target as HTMLInputElement ) . value . substr ( 0 , 0 ) ; } ; let renderFunction = ( ) => h ( 's' , { value : typedKeys , oninput : handleInput } ) ; let projection = dom . create ( renderFunction ( ) , { eventHandlerInterceptor : noopEventHandlerInterceptor } ) ; let inputElement = ( projection . domNode as HTMLInputElement ) ; expect ( inputElement . value ) . to . equal ( typedKeys ) ; inputElement . value = 's' ; inputElement . oninput ( { target : inputElement } as any ) ; expect ( typedKeys ) . to . equal ( 's' ) ; projection . update ( renderFunction ( ) ) ; expect ( inputElement . value ) . to . equal ( 's' ) ; inputElement . value = 's' ; inputElement . oninput ( { target : inputElement } as any ) ; expect ( typedKeys ) . to . equal ( 's' ) ; projection . update ( renderFunction ( ) ) ; expect ( inputElement . value ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let typedKeys = 's' ; let handleInput = ( evt ) => { typedKeys = ( evt . target as HTMLInputElement ) . value ; } ; let renderFunction = ( ) => h ( 's' , { value : typedKeys , oninput : handleInput } ) ; let projection = dom . create ( renderFunction ( ) , { eventHandlerInterceptor : noopEventHandlerInterceptor } ) ; let inputElement = ( projection . domNode as HTMLInputElement ) ; expect ( inputElement . value ) . to . equal ( typedKeys ) ; inputElement . value = 's' ; inputElement . oninput ( { target : inputElement } as any ) ; expect ( typedKeys ) . to . equal ( 's' ) ; projection . update ( renderFunction ( ) ) ; inputElement . value = 's' ; projection . update ( renderFunction ( ) ) ; expect ( typedKeys ) . to . equal ( 's' ) ; expect ( inputElement . value ) . to . equal ( 's' ) ; inputElement . oninput ( { target : inputElement } as any ) ; expect ( typedKeys ) . to . equal ( 's' ) ; projection . update ( renderFunction ( ) ) ; } ) ; } ) ; it ( 's' , ( ) => { let typedKeys = 's' ; let handleInput = ( evt ) => { typedKeys = ( evt . target as HTMLInputElement ) . value ; } ; let renderFunction = ( ) => h ( 's' , { value : typedKeys , oninput : handleInput } ) ; let projection = dom . create ( renderFunction ( ) , { eventHandlerInterceptor : noopEventHandlerInterceptor } ) ; let inputElement = ( projection . domNode as HTMLInputElement ) ; expect ( inputElement . value ) . to . equal ( typedKeys ) ; typedKeys = 's' ; projection . update ( renderFunction ( ) ) ; expect ( inputElement . value ) . to . equal ( typedKeys ) ; } ) ; it ( 's' , ( ) => { let typedKeys = 's' ; let handleInput = ( evt ) => { typedKeys = ( evt . target as HTMLInputElement ) . value ; } ; let renderFunction = ( ) => h ( 's' , { value : typedKeys , oninput : handleInput } ) ; let projection = dom . create ( renderFunction ( ) , { eventHandlerInterceptor : noopEventHandlerInterceptor } ) ; let inputElement = ( projection . domNode as HTMLInputElement ) ; expect ( inputElement . value ) . to . equal ( typedKeys ) ; inputElement . value = 's' ; projection . update ( renderFunction ( ) ) ; expect ( inputElement . value ) . not . to . equal ( typedKeys ) ; } ) ; it ( 's' , ( ) => { let model = 's' ; let handleInput = ( evt ) => { let element = evt . target as HTMLInputElement ; model = element . value ; if ( model . indexOf ( 's' ) > 0 ) { model = model . replace ( "s" , 's' ) ; element . value = model ; } } ; let renderFunction = ( ) => h ( 's' , { value : model , oninput : handleInput } ) ; let projection = dom . create ( renderFunction ( ) , { eventHandlerInterceptor : noopEventHandlerInterceptor } ) ; let inputElement = ( projection . domNode as HTMLInputElement ) ; expect ( inputElement . value ) . to . equal ( model ) ; inputElement . value = 's' ; inputElement . oninput ( { target : inputElement } as any as Event ) ; projection . update ( renderFunction ( ) ) ; inputElement . value = 's' ; inputElement . oninput ( { target : inputElement } as any as Event ) ; projection . update ( renderFunction ( ) ) ; expect ( inputElement . value ) . to . equal ( 's' ) ; model = 's' ; projection . update ( renderFunction ( ) ) ; expect ( inputElement . value ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let role : string | undefined = 's' ; let renderFunction = ( ) => h ( 's' , { role : role } ) ; let projection = dom . create ( renderFunction ( ) , { eventHandlerInterceptor : noopEventHandlerInterceptor } ) ; let element = projection . domNode ; expect ( element . attributes ) . to . have . property ( 's' ) ; expect ( element . getAttribute ( 's' ) ) . to . equal ( role ) ; role = undefined ; projection . update ( renderFunction ( ) ) ; expect ( element . attributes ) . to . not . have . property ( 's' ) ; } ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $complex$ O $complex$ O O O O O $any$ O O $string$ O $Function$ O O O O O O $Node$ O O O $Function$ O $any$ O O O $IArguments$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O $true$ O O O $false$ O O O O O O O O $HTMLDivElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLDivElement$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O $true$ O O O $true$ O O O O O O O $any$ O $HTMLDivElement$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O $false$ O O O $true$ O O O O O O O $any$ O $HTMLDivElement$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $string$ O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $string$ O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $undefined$ O $undefined$ O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $string$ O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $string$ O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $string$ O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $undefined$ O $undefined$ O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $string$ O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O $true$ O O O O $string$ O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O $true$ O O O O $string$ O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O $false$ O O O O $string$ O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $string$ O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $string$ O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $undefined$ O $undefined$ O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $undefined$ O $undefined$ O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $string$ O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O $complex$ O $Projection$ O $complex$ O O O O $string$ O O O O O O O O O O O $any$ O $any$ O $ErrorConstructor$ O O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $string$ O O O O O O O $HTMLLinkElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLLinkElement$ O $string$ O O O O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $string$ O O O O O O $any$ O $HTMLLinkElement$ O $string$ O O O O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $undefined$ O $undefined$ O O O O $any$ O $HTMLLinkElement$ O $string$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $undefined$ O $undefined$ O O O O O $HTMLLinkElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLLinkElement$ O $string$ O O O O O $any$ O $any$ O $any$ O $Projection$ O $void$ O $complex$ O O O O $string$ O O O O O O $any$ O $HTMLLinkElement$ O $string$ O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $true$ O O O O O O O $HTMLLinkElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLLinkElement$ O $boolean$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O O O O $null$ O O O O O O $any$ O $HTMLLinkElement$ O $boolean$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $string$ O O O $number$ O O O O O O O $HTMLLinkElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLLinkElement$ O $number$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $string$ O O O $number$ O O O O O O $any$ O $HTMLLinkElement$ O $number$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $string$ O O O $undefined$ O $undefined$ O O O O $any$ O $HTMLLinkElement$ O $number$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $string$ O O O O O O O $HTMLElement$ O $Projection$ O $Element$ O $complex$ O $any$ O $HTMLElement$ O $NodeListOf<ChildNode>$ O O $any$ O $any$ O $any$ O O O O $any$ O $HTMLElement$ O $ChildNode$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $string$ O O O O O O $any$ O $HTMLElement$ O $NodeListOf<ChildNode>$ O O $any$ O $any$ O $any$ O O O O $any$ O $HTMLElement$ O $ChildNode$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $number$ O O O O O O O $HTMLDivElement$ O $Projection$ O $Element$ O $complex$ O $ObjectConstructor$ O $any$ O $HTMLDivElement$ O O O O $number$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $Projection$ O $void$ O $complex$ O O O O $number$ O O O O O O O O O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O $HTMLElement$ O O O $any$ O $HTMLElement$ O $string$ O O O O O $any$ O $any$ O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O $string$ O O O O $Document$ O O O $string$ O O O O O O O $complex$ O $Projection$ O O O O $complex$ O $complex$ O O O O $string$ O O O O O O $any$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $string$ O O O O $void$ O O $Event$ O O O $string$ O O $Event$ O $EventTarget$ O $complex$ O O $string$ O $string$ O O O O O O O O O $VNode$ O O O O $complex$ O O O O $string$ O $string$ O $void$ O $void$ O O O O $Projection$ O $complex$ O $Projection$ O $VNode$ O O O O $any$ O $any$ O O O O $HTMLInputElement$ O O $Projection$ O $Element$ O $complex$ O O $any$ O $HTMLInputElement$ O $string$ O O $any$ O $any$ O $string$ O O $HTMLInputElement$ O $string$ O O O $HTMLInputElement$ O $any$ O O $HTMLInputElement$ O $HTMLInputElement$ O O O O O $any$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $VNode$ O O O O $any$ O $HTMLInputElement$ O $string$ O O $any$ O $any$ O O O O $HTMLInputElement$ O $string$ O O O $HTMLInputElement$ O $any$ O O $HTMLInputElement$ O $HTMLInputElement$ O O O O O $any$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $VNode$ O O O O $any$ O $HTMLInputElement$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $string$ O O O O $void$ O O $Event$ O O O $string$ O O $Event$ O $EventTarget$ O $complex$ O O $string$ O O O O $VNode$ O O O O $complex$ O O O O $string$ O $string$ O $void$ O $void$ O O O O $Projection$ O $complex$ O $Projection$ O $VNode$ O O O O $any$ O $any$ O O O O $HTMLInputElement$ O O $Projection$ O $Element$ O $complex$ O O $any$ O $HTMLInputElement$ O $string$ O O $any$ O $any$ O $string$ O O $HTMLInputElement$ O $string$ O O O $HTMLInputElement$ O $any$ O O $HTMLInputElement$ O $HTMLInputElement$ O O O O O $any$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $VNode$ O O O O $HTMLInputElement$ O $string$ O O O $Projection$ O $void$ O $VNode$ O O O O $any$ O $string$ O O $any$ O $any$ O O O O $any$ O $HTMLInputElement$ O $string$ O O $any$ O $any$ O O O O $HTMLInputElement$ O $any$ O O $HTMLInputElement$ O $HTMLInputElement$ O O O O O $any$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $VNode$ O O O O O O O O O O $any$ O O O O O O O O $string$ O O O O $void$ O O $Event$ O O O $string$ O O $Event$ O $EventTarget$ O $complex$ O O $string$ O O O O $VNode$ O O O O $complex$ O O O O $string$ O $string$ O $void$ O $void$ O O O O $Projection$ O $complex$ O $Projection$ O $VNode$ O O O O $any$ O $any$ O O O O $HTMLInputElement$ O O $Projection$ O $Element$ O $complex$ O O $any$ O $HTMLInputElement$ O $string$ O O $any$ O $any$ O $string$ O O $string$ O O O $Projection$ O $void$ O $VNode$ O O O O $any$ O $HTMLInputElement$ O $string$ O O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O $string$ O O O O $void$ O O $Event$ O O O $string$ O O $Event$ O $EventTarget$ O $complex$ O O $string$ O O O O $VNode$ O O O O $complex$ O O O O $string$ O $string$ O $void$ O $void$ O O O O $Projection$ O $complex$ O $Projection$ O $VNode$ O O O O $any$ O $any$ O O O O $HTMLInputElement$ O O $Projection$ O $Element$ O $complex$ O O $any$ O $HTMLInputElement$ O $string$ O O $any$ O $any$ O $string$ O O $HTMLInputElement$ O $string$ O O O $Projection$ O $void$ O $VNode$ O O O O $any$ O $HTMLInputElement$ O $string$ O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O $string$ O O O O $void$ O O $Event$ O O O O $HTMLInputElement$ O $Event$ O $EventTarget$ O $complex$ O $string$ O $HTMLInputElement$ O $string$ O O O $string$ O $number$ O O O O O O O $string$ O $string$ O $complex$ O O O O O O $HTMLInputElement$ O $string$ O $string$ O O O O O $VNode$ O O O O $complex$ O O O O $string$ O $string$ O $void$ O $void$ O O O O $Projection$ O $complex$ O $Projection$ O $VNode$ O O O O $any$ O $any$ O O O O $HTMLInputElement$ O O $Projection$ O $Element$ O $complex$ O O $any$ O $HTMLInputElement$ O $string$ O O $any$ O $any$ O $string$ O O $HTMLInputElement$ O $string$ O O O $HTMLInputElement$ O $any$ O O $HTMLInputElement$ O $HTMLInputElement$ O O O O $complex$ O O $Projection$ O $void$ O $VNode$ O O O O $HTMLInputElement$ O $string$ O O O $HTMLInputElement$ O $any$ O O $HTMLInputElement$ O $HTMLInputElement$ O O O O $complex$ O O $Projection$ O $void$ O $VNode$ O O O O $any$ O $HTMLInputElement$ O $string$ O O $any$ O $any$ O O O O $string$ O O O $Projection$ O $void$ O $VNode$ O O O O $any$ O $HTMLInputElement$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $string$ O O O O O O O O $VNode$ O O O O $complex$ O O O O $string$ O $string$ O O O O $Projection$ O $complex$ O $Projection$ O $VNode$ O O O O $any$ O $any$ O O O O $Element$ O $Projection$ O $Element$ O $any$ O $Element$ O $NamedNodeMap$ O O $any$ O $any$ O $any$ O O O O $any$ O $Element$ O $string$ O O O O O $any$ O $any$ O $string$ O O $string$ O $undefined$ O $Projection$ O $void$ O $VNode$ O O O O $any$ O $Element$ O $NamedNodeMap$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O
import { expect } from 's' ; import { dom , h } from 's' ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { try { dom . create ( h ( 's' , { styles : { height : 0 } as any } ) ) ; expect . fail ( ) ; } catch ( e ) { expect ( e . message . indexOf ( 's' ) >= 0 ) . to . be . true ; } } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { styles : { height : 's' } } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { styles : { height : 's' } } ) ) ; projection . update ( h ( 's' , { styles : { height : 's' } } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { styles : { height : 's' } } ) ) ; projection . update ( h ( 's' , { styles : { height : null } } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; it ( 's' , ( ) => { let projection = dom . create ( h ( 's' , { styles : { height : undefined } } ) ) ; projection . update ( h ( 's' , { styles : { height : 's' } } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { styles : { height : 's' } } ) ) ; } ) ; it ( 's' , ( ) => { let styleApplyer = ( domNode , styleName , value ) => { ( domNode as any ) . style [ `template` ] = value ; } ; let projection = dom . create ( h ( 's' , { styles : { height : 's' } } ) , { styleApplyer : styleApplyer } ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; projection . update ( h ( 's' , { styles : { height : 's' } } ) ) ; expect ( projection . domNode . outerHTML ) . to . equal ( 's' ) ; } ) ; } ) ; } ) ;	O O $any$ O O O O O O $complex$ O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $complex$ O $Projection$ O $complex$ O O O O $any$ O O $number$ O O O O O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O $string$ O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O $string$ O O O O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O $string$ O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O $string$ O O O O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O $null$ O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O $undefined$ O $undefined$ O O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O $string$ O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O $string$ O O O O O O O O O O $any$ O O O O O O O O $void$ O O $Element$ O $string$ O $string$ O O O O $Element$ O O O O $any$ O O O O $string$ O O O O $Projection$ O $complex$ O $Projection$ O $complex$ O O O O $complex$ O O $string$ O O O O O O O $void$ O $void$ O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $Projection$ O $void$ O $complex$ O O O O $complex$ O O $string$ O O O O O O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O O O O O O O O O O
import { expect } from 's' ; import { h , VNode } from 's' ; describe ( 's' , ( ) => { let toTextVNode = ( text ) : VNode => { return { vnodeSelector : 's' , properties : undefined , children : undefined , text : text , domNode : null } ; } ; it ( 's' , ( ) => { let vnode = h ( 's' , [ 's' , null , [ ] as string [ ] , [ null ] , [ 's' ] , [ h ( 's' ) ] , [ h ( 's' , [ 's' ] ) ] , [ [ [ [ 's' ] , null ] , 's' ] ] ] ) ; expect ( vnode . children ) . to . deep . equal ( [ toTextVNode ( 's' ) , toTextVNode ( 's' ) , h ( 's' ) , h ( 's' , [ 's' ] ) , toTextVNode ( 's' ) , toTextVNode ( 's' ) ] ) ; } ) ; it ( 's' , ( ) => { let vnode = h ( 's' , [ 's' , h ( 's' , [ [ 's' ] ] ) , h ( 's' , { src : 's' } ) , 's' , undefined , null , [ undefined , h ( 's' , [ 's' ] ) , h ( 's' , undefined , [ 's' ] ) , h ( 's' , undefined ) , h ( 's' , undefined , undefined ) , h ( 's' , [ undefined , undefined ] ) , h ( 's' , [ null , null ] ) , h ( 's' , [ null ] ) , h ( 's' , null ) , h ( 's' , { } , null ) ] ] ) ; expect ( vnode . children ) . to . deep . equal ( [ toTextVNode ( 's' ) , h ( 's' , [ 's' , undefined ] ) , h ( 's' , { src : 's' } ) , toTextVNode ( 's' ) , h ( 's' , [ 's' ] ) , h ( 's' , [ 's' ] , undefined ) , h ( 's' ) , h ( 's' ) , h ( 's' ) , h ( 's' ) , h ( 's' ) , h ( 's' , null ) , h ( 's' , { } ) ] ) ; } ) ; it ( 's' , ( ) => { expect ( h ( 's' , [ [ 's' ] ] ) ) . to . deep . equal ( { vnodeSelector : 's' , properties : undefined , text : undefined , children : [ toTextVNode ( 's' ) ] , domNode : null } ) ; } ) ; it ( 's' , ( ) => { expect ( ( ) => h ( 's' , h ( 's' ) ) ) . to . throw ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( ( ) => h ( 's' , { } , h ( 's' ) as any ) ) . to . throw ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( ( ) => h ( 's' , 's' as any ) ) . to . throw ( 's' ) ; expect ( ( ) => h ( 's' , { } as any , 's' as any ) ) . to . throw ( 's' ) ; } ) ; } ) ;	O O $any$ O O O O O O $complex$ O $any$ O O O O $any$ O O O O O O O O $VNode$ O O $string$ O O $any$ O O O O $string$ O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $string$ O $string$ O $null$ O O O O O O $any$ O O O O O O O O $VNode$ O $complex$ O O O O O O O O O O O O O O O O O O O O O O O O $complex$ O O O O O O $complex$ O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $VNode$ O $VNode[]$ O O $any$ O $any$ O $any$ O O $VNode$ O O O O $VNode$ O O O O $complex$ O O O O $complex$ O O O O O O O O $VNode$ O O O O $VNode$ O O O O O O O O O $any$ O O O O O O O O $VNode$ O $complex$ O O O O O O $complex$ O O O O O O O O O O $complex$ O O O O $string$ O O O O O O O $undefined$ O O O O $undefined$ O $complex$ O O O O O O O O $complex$ O O O $undefined$ O O O O O O $complex$ O O O $undefined$ O O $complex$ O O O $undefined$ O $undefined$ O O $complex$ O O O O $undefined$ O $undefined$ O O O $complex$ O O O O O O O O O O $complex$ O O O O O O O O $complex$ O O O O O O $complex$ O O O O O O O O O O O O $any$ O $VNode$ O $VNode[]$ O O $any$ O $any$ O $any$ O O $VNode$ O O O O $complex$ O O O O O O $undefined$ O O O $complex$ O O O O $string$ O O O O O $VNode$ O O O O $complex$ O O O O O O O O $complex$ O O O O O O O $undefined$ O O $complex$ O O O O $complex$ O O O O $complex$ O O O O $complex$ O O O O $complex$ O O O O $complex$ O O O O O O $complex$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O $complex$ O O O O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $VNode[]$ O O $VNode$ O O O O O $null$ O O O O O O O O $any$ O O O O O O O $any$ O O O O $complex$ O O O $complex$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $complex$ O O O O O O $complex$ O O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $complex$ O O O O O O O O O $any$ O $any$ O O O O $any$ O O O O $complex$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O
import { expect } from 's' ; import { createMapping } from 's' ; let addAllPermutations = ( results : number [ ] [ ] , result : number [ ] , unusedNumbers : number [ ] , numbersToAdd ) => { if ( numbersToAdd === 0 ) { results . push ( result ) ; } for ( let i = 0 ; i < unusedNumbers . length ; i ++ ) { let newResult = result . slice ( ) ; newResult . push ( unusedNumbers [ i ] ) ; let newUnusedNumbers = unusedNumbers . slice ( ) ; newUnusedNumbers . splice ( i , 0 ) ; addAllPermutations ( results , newResult , newUnusedNumbers , numbersToAdd - 0 ) ; } } ; let createPermutations = ( ) => { let results = [ ] as number [ ] [ ] ; for ( let length = 0 ; length <= 0 ; length ++ ) { let unusedNumbers = [ 0 , 0 , 0 , 0 ] ; let result = [ ] as number [ ] ; addAllPermutations ( results , result , unusedNumbers , length ) ; } return results ; } ; interface Target { source : number ; updateCount : number ; alreadyPresent ? : boolean ; } let createTarget = ( source ) => { return { source : source , updateCount : 0 , alreadyPresent : undefined as boolean | undefined } ; } ; let updateTarget = ( source , target ) => { expect ( source ) . to . equal ( target . source ) ; target . updateCount ++ ; } ; let checkInitialMapping = ( results : Target [ ] , sources : number [ ] ) => { results . forEach ( ( target , index ) => { expect ( target . source ) . to . equal ( sources [ index ] ) ; expect ( target . updateCount ) . to . equal ( 0 ) ; } ) ; } ; let checkNextMapping = ( results : Target [ ] , sources : number [ ] , previousSources : number [ ] ) => { results . forEach ( ( target , index ) => { expect ( target . source ) . to . equal ( sources [ index ] ) ; if ( previousSources . indexOf ( target . source ) >= 0 ) { expect ( target . alreadyPresent ) . to . be . true ; expect ( target . updateCount ) . to . equal ( 0 ) ; } else { expect ( target . alreadyPresent ) . to . be . undefined ; expect ( target . updateCount ) . to . equal ( 0 ) ; } } ) ; } ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let permutations = createPermutations ( ) ; for ( let permutationI of permutations ) { for ( let permutationJ of permutations ) { let mapping = createMapping ( key => key , createTarget , updateTarget ) ; mapping . map ( permutationI ) ; checkInitialMapping ( mapping . results , permutationI ) ; mapping . results . forEach ( target => { target . alreadyPresent = true ; } ) ; mapping . map ( permutationJ ) ; checkNextMapping ( mapping . results , permutationJ , permutationI ) ; } } } ) . timeout ( 0 ) ; } ) ;	O O $any$ O O O O O O $Mapping<...>$ O O O O O $void$ O O $number[][]$ O O O O O O O $number[]$ O O O O O $number[]$ O O O O O $number$ O O O O O $number$ O O O O $number[][]$ O $number$ O $number[]$ O O O O O O $number$ O O O $number$ O $number[]$ O $number$ O $number$ O O O O $number[]$ O $number[]$ O $number[]$ O O O $number[]$ O $number$ O $number[]$ O $number$ O O O O $number[]$ O $number[]$ O $number[]$ O O O $number[]$ O $complex$ O $number$ O O O O $void$ O $number[][]$ O $number[]$ O $number[]$ O $number$ O O O O O O O O $number[][]$ O O O O O O $number[][]$ O O O O O O O O O O O O O $number$ O O O $number$ O O O $number$ O O O O $number[]$ O O O O O O O O O O O O $number[]$ O O O O O O O O $void$ O $number[][]$ O $number[]$ O $number[]$ O $number$ O O O O $number[][]$ O O O O $any$ O $number$ O O O $number$ O O O $boolean$ O O O O O O $complex$ O O $number$ O O O O O $number$ O $number$ O $number$ O O O $boolean$ O $undefined$ O O O O O O O O O $void$ O O $number$ O $Target$ O O O $any$ O $number$ O O $any$ O $any$ O $Target$ O $number$ O O $Target$ O $number$ O O O O O $void$ O O $Target[]$ O $any$ O O O $number[]$ O O O O O O O $Target[]$ O $void$ O O $Target$ O $number$ O O O $any$ O $Target$ O $number$ O O $any$ O $any$ O $number[]$ O $number$ O O O $any$ O $Target$ O $number$ O O $any$ O $any$ O O O O O O O O O O $void$ O O $Target[]$ O $any$ O O O $number[]$ O O O O O $number[]$ O O O O O O O $Target[]$ O $void$ O O $Target$ O $number$ O O O $any$ O $Target$ O $number$ O O $any$ O $any$ O $number[]$ O $number$ O O O O O $number[]$ O $number$ O $Target$ O $number$ O O O O O $any$ O $Target$ O $boolean$ O O $any$ O $any$ O $any$ O $any$ O $Target$ O $number$ O O $any$ O $any$ O O O O O O O $any$ O $Target$ O $boolean$ O O $any$ O $any$ O $any$ O $any$ O $Target$ O $number$ O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $number[][]$ O $number[][]$ O O O O O O $number[]$ O $number[][]$ O O O O O $number[]$ O $number[][]$ O O O $complex$ O $Mapping<...>$ O $number$ O $number$ O $complex$ O $void$ O O $complex$ O $void$ O $number[]$ O O $void$ O $complex$ O $Target[]$ O $number[]$ O O $complex$ O $Target[]$ O $void$ O $Target$ O O $Target$ O $boolean$ O O O O O O $complex$ O $void$ O $number[]$ O O $void$ O $complex$ O $Target[]$ O $number[]$ O $number[]$ O O O O O O O $any$ O O O O O O O
import { expect , sinon } from 's' ; import { createProjector , h , MaquetteComponent , Projector } from 's' ; import * as path from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { global . requestAnimationFrame = sinon . stub ( ) . returns ( 0 ) ; global . cancelAnimationFrame = sinon . stub ( ) ; } ) ; afterEach ( ( ) => { delete global . requestAnimationFrame ; delete global . cancelAnimationFrame ; } ) ; it ( 's' , ( ) => { let parentElement = { appendChild : sinon . stub ( ) , insertBefore : sinon . stub ( ) , ownerDocument : { createElement : sinon . spy ( ( tag ) => { return document . createElement ( tag ) ; } ) } , removeChild : sinon . stub ( ) } ; let renderFunction = sinon . stub ( ) . returns ( h ( 's' , [ h ( 's' ) ] ) ) ; let projector = createProjector ( { } ) ; projector . append ( parentElement as any , renderFunction ) ; expect ( renderFunction ) . to . have . been . calledOnce ; expect ( parentElement . ownerDocument . createElement ) . to . have . been . calledOnce ; expect ( parentElement . appendChild ) . to . have . been . calledOnce ; expect ( parentElement . appendChild . lastCall . args [ 0 ] . tagName ) . to . equal ( 's' ) ; let siblingElement = { parentNode : parentElement } ; projector . insertBefore ( siblingElement as any , renderFunction ) ; expect ( renderFunction ) . to . have . been . calledTwice ; expect ( parentElement . insertBefore ) . to . have . been . calledOnce ; expect ( parentElement . insertBefore . lastCall . args [ 0 ] . tagName ) . to . equal ( 's' ) ; expect ( parentElement . insertBefore . lastCall . args [ 0 ] ) . to . equal ( siblingElement ) ; let cleanRenderFunction = sinon . stub ( ) . returns ( h ( 's' , [ h ( 's' ) ] ) ) ; let existingElement = { appendChild : sinon . stub ( ) , ownerDocument : { createElement : sinon . spy ( ( tag ) => { return document . createElement ( tag ) ; } ) } } ; projector . merge ( existingElement as any , cleanRenderFunction ) ; expect ( cleanRenderFunction ) . to . have . been . calledOnce ; expect ( existingElement . ownerDocument . createElement ) . to . have . been . calledOnce ; expect ( existingElement . appendChild ) . to . have . been . calledOnce ; expect ( existingElement . appendChild . lastCall . args [ 0 ] . tagName ) . to . equal ( 's' ) ; let oldElement = { parentNode : parentElement } ; projector . replace ( oldElement as any , renderFunction ) ; expect ( renderFunction ) . to . have . been . calledThrice ; expect ( parentElement . removeChild ) . to . have . been . calledOnce ; expect ( parentElement . removeChild . lastCall . args [ 0 ] ) . to . equal ( oldElement ) ; expect ( parentElement . insertBefore ) . to . have . been . calledTwice ; expect ( parentElement . insertBefore . lastCall . args [ 0 ] . tagName ) . to . equal ( 's' ) ; expect ( parentElement . insertBefore . lastCall . args [ 0 ] ) . to . equal ( oldElement ) ; projector . scheduleRender ( ) ; expect ( renderFunction ) . to . have . been . calledThrice ; expect ( global . requestAnimationFrame ) . to . have . been . calledOnce ; global . requestAnimationFrame . callArg ( 0 ) ; expect ( renderFunction ) . to . have . callCount ( 0 ) ; } ) ; it ( 's' , ( ) => { let projector = createProjector ( { } ) ; projector . scheduleRender ( ) ; expect ( global . requestAnimationFrame ) . to . have . been . calledOnce ; global . requestAnimationFrame . callArg ( 0 ) ; projector . stop ( ) ; projector . scheduleRender ( ) ; expect ( global . requestAnimationFrame ) . to . have . been . calledOnce ; projector . resume ( ) ; expect ( global . requestAnimationFrame ) . to . have . been . calledTwice ; global . requestAnimationFrame . callArg ( 0 ) ; projector . scheduleRender ( ) ; expect ( global . requestAnimationFrame ) . to . have . been . calledThrice ; projector . stop ( ) ; expect ( global . cancelAnimationFrame ) . to . have . been . calledOnce ; } ) ; it ( 's' , ( ) => { let projector = createProjector ( { } ) ; let parentElement = { appendChild : sinon . stub ( ) , ownerDocument : document } ; let renderFunction = sinon . stub ( ) . returns ( h ( 's' ) ) ; projector . append ( parentElement as any , renderFunction ) ; renderFunction . throws ( 's' ) ; projector . scheduleRender ( ) ; expect ( ( ) => { global . requestAnimationFrame . callArg ( 0 ) ; } ) . to . throw ( Error ) ; global . requestAnimationFrame . callArg ( 0 ) ; renderFunction . resetHistory ( ) ; projector . scheduleRender ( ) ; global . requestAnimationFrame . callArg ( 0 ) ; expect ( renderFunction ) . not . to . be . called ; global . requestAnimationFrame . resetHistory ( ) ; renderFunction . returns ( h ( 's' ) ) ; projector . resume ( ) ; global . requestAnimationFrame . callArg ( 0 ) ; expect ( renderFunction ) . to . be . calledOnce ; } ) ; it ( 's' , ( ) => { let projector = createProjector ( { } ) ; let parentElement = { appendChild : sinon . stub ( ) , ownerDocument : document } ; let handleClick = sinon . stub ( ) ; let renderFunction = ( ) => h ( 's' , { onclick : handleClick } ) ; projector . append ( parentElement as any , renderFunction ) ; let button = parentElement . appendChild . lastCall . args [ 0 ] as HTMLElement ; let evt = { currentTarget : button , type : 's' } as object as MouseEvent ; expect ( global . requestAnimationFrame ) . not . to . be . called ; button . onclick . apply ( button , [ evt ] ) ; expect ( global . requestAnimationFrame ) . to . be . calledOnce ; expect ( handleClick ) . to . be . calledOn ( button ) . calledWith ( evt ) ; } ) ; it ( 's' , ( ) => { let parentElement = { appendChild : sinon . stub ( ) , ownerDocument : document } ; let projector = createProjector ( { } ) ; let handleClick = sinon . stub ( ) ; let renderFunction = ( ) => h ( 's' , { onclick : handleClick } ) ; projector . append ( parentElement as any , renderFunction ) ; let button = parentElement . appendChild . lastCall . args [ 0 ] as HTMLElement ; let clickEvent = { currentTarget : button , type : 's' } ; button . onclick ( clickEvent as any ) ; expect ( handleClick ) . to . be . calledOn ( button ) . calledWithExactly ( clickEvent ) ; } ) ; describe ( 's' , ( ) => { class ButtonComponent implements MaquetteComponent { private text : string ; private clicked : ( sender ) => void ; constructor ( buttonText , buttonClicked : ( sender ) => void ) { this . text = buttonText ; this . clicked = buttonClicked ; } public render ( ) { return h ( 's' , { onclick : this . handleClick , bind : this } , [ this . text ] ) ; } private handleClick ( evt ) { this . clicked ( this ) ; } } it ( 's' , ( ) => { let clicked = sinon . stub ( ) ; let button = new ButtonComponent ( 's' , clicked ) ; let parentElement = { appendChild : sinon . stub ( ) , ownerDocument : document } ; let projector = createProjector ( { } ) ; projector . append ( parentElement as any , ( ) => button . render ( ) ) ; let buttonElement = parentElement . appendChild . lastCall . args [ 0 ] as HTMLElement ; let clickEvent = { currentTarget : buttonElement , type : 's' } ; buttonElement . onclick ( clickEvent as any ) ; expect ( clicked ) . to . be . calledWithExactly ( button ) ; } ) ; let allowsForEventHandlersToBeChanged = ( createProjectorImpl : ( arg ) => Projector ) => { let projector = createProjectorImpl ( { } ) ; let parentElement = { appendChild : sinon . stub ( ) , ownerDocument : document } ; let eventHandler = sinon . stub ( ) ; let renderFunction = ( ) => h ( 's' , [ h ( 's' , [ h ( 's' , { onclick : eventHandler } ) ] ) ] ) ; projector . append ( parentElement as any , renderFunction ) ; let div = parentElement . appendChild . lastCall . args [ 0 ] as HTMLElement ; let button = div . firstChild . firstChild as HTMLElement ; let evt = { currentTarget : button , type : 's' } as object as MouseEvent ; expect ( eventHandler ) . to . have . not . been . called ; button . onclick . apply ( button , [ evt ] ) ; expect ( eventHandler ) . to . have . been . calledOnce ; eventHandler = sinon . stub ( ) ; projector . renderNow ( ) ; button . onclick . apply ( button , [ evt ] ) ; expect ( eventHandler ) . to . have . been . calledOnce ; } ; it ( 's' , ( ) => allowsForEventHandlersToBeChanged ( createProjector ) ) ; it ( 's' , ( ) => { let apFind = Array . prototype . find ; try { delete Array . prototype . find ; delete require . cache [ path . normalize ( path . join ( __dirname , 's' ) ) ] ; let createProjectorImpl = require ( 's' ) . createProjector ; allowsForEventHandlersToBeChanged ( createProjectorImpl ) ; } finally { Array . prototype . find = apFind ; } } ) ; it ( 's' , ( ) => { let buttonVisible = true ; let buttonBlur = sinon . spy ( ) ; let eventHandler = ( ) => { buttonVisible = false ; } ; let renderFunction = ( ) => h ( 's' , [ buttonVisible ? [ h ( 's' , { onblur : buttonBlur , onclick : eventHandler } ) ] : [ ] ] ) ; let projector = createProjector ( { } ) ; let parentElement = document . createElement ( 's' ) ; projector . append ( parentElement , renderFunction ) ; let div = parentElement . firstChild as HTMLElement ; let button = div . firstChild as HTMLButtonElement ; button . onclick ( { currentTarget : button , type : 's' } as any ) ; expect ( buttonVisible ) . to . be . false ; projector . renderNow ( ) ; let buttonBeforeBeingDetached = { onblur : button . onblur as Function , parentNode : div } ; buttonBeforeBeingDetached . onblur ( { currentTarget : buttonBeforeBeingDetached , type : 's' } as any ) ; expect ( buttonBlur ) . to . not . have . been . called ; } ) ; } ) ; it ( 's' , ( ) => { let parentElement = { appendChild : sinon . stub ( ) , ownerDocument : document } ; let projector = createProjector ( { } ) ; let renderFunction = ( ) => h ( 's' ) ; let 0 = ( ) => h ( 's' ) ; projector . append ( parentElement as any , renderFunction ) ; projector . append ( parentElement as any , 0 ) ; let projection = projector . detach ( renderFunction ) ; expect ( projection . domNode . id ) . to . equal ( 's' ) ; expect ( ( ) => { projector . detach ( renderFunction ) ; } ) . to . throw ( ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $Projector$ O $complex$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O O $string$ O O O O $Document$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $complex$ O O O O $complex$ O O O O O O O O $Projector$ O $Projector$ O O O O O $Projector$ O $void$ O $complex$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O O $complex$ O O $complex$ O $complex$ O O $Projector$ O $void$ O $complex$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O $complex$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $complex$ O O O $any$ O $any$ O $any$ O O O $any$ O $complex$ O O O O $complex$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O O $string$ O O O O $Document$ O O O $string$ O O O O O O O $Projector$ O $void$ O $complex$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O O $complex$ O O $complex$ O $complex$ O O $Projector$ O $void$ O $complex$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $complex$ O O $any$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O $complex$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $complex$ O O $Projector$ O $void$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $Projector$ O $Projector$ O O O O O $Projector$ O $void$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $Projector$ O $void$ O O O $Projector$ O $void$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $Projector$ O $void$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $Projector$ O $void$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $Projector$ O $void$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $Projector$ O $Projector$ O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $Document$ O $Document$ O O O $any$ O $any$ O $any$ O O O $any$ O $complex$ O O O O O $Projector$ O $void$ O $complex$ O O O $any$ O O $any$ O $any$ O O O O $Projector$ O $void$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $ErrorConstructor$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $Projector$ O $void$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O O O O $Projector$ O $void$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $Projector$ O $Projector$ O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $Document$ O $Document$ O O O $any$ O $any$ O $any$ O O O O $VNode$ O O O O $complex$ O O O O $any$ O $any$ O O O $Projector$ O $void$ O $complex$ O O O $VNode$ O O O $HTMLElement$ O $complex$ O $any$ O $any$ O $any$ O O O O $complex$ O O $MouseEvent$ O O $HTMLElement$ O $HTMLElement$ O $string$ O O O O O O $complex$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $HTMLElement$ O $any$ O $any$ O $HTMLElement$ O O $MouseEvent$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $HTMLElement$ O O $any$ O $MouseEvent$ O O O O O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $Document$ O $Document$ O O O $Projector$ O $Projector$ O O O O O O $any$ O $any$ O $any$ O O O O $VNode$ O O O O $complex$ O O O O $any$ O $any$ O O O $Projector$ O $void$ O $complex$ O O O $VNode$ O O O $HTMLElement$ O $complex$ O $any$ O $any$ O $any$ O O O O $complex$ O O $complex$ O O $HTMLElement$ O $HTMLElement$ O $string$ O O O O $HTMLElement$ O $any$ O $complex$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $HTMLElement$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O O $void$ O O $ButtonComponent$ O O O O O O $string$ O $void$ O O $ButtonComponent$ O O O O O O O $string$ O $string$ O O O $void$ O $void$ O O O $VNode$ O O O O $complex$ O O O O $void$ O O O $void$ O $this$ O O O O O O O $string$ O O O O O $void$ O $MouseEvent$ O O O O $void$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $ButtonComponent$ O O $any$ O O O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O O O $Document$ O $Document$ O O O $Projector$ O $Projector$ O O O O O $Projector$ O $void$ O $complex$ O O O O O O $ButtonComponent$ O $VNode$ O O O O O $HTMLElement$ O $complex$ O $any$ O $any$ O $any$ O O O O $complex$ O O $complex$ O O $HTMLElement$ O $HTMLElement$ O $string$ O O O O $HTMLElement$ O $any$ O $complex$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $ButtonComponent$ O O O O O O $void$ O O $Projector$ O O $any$ O O $any$ O O O O $Projector$ O $Projector$ O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $Document$ O $Document$ O O O $any$ O $any$ O $any$ O O O O $VNode$ O O O O $complex$ O O O O $complex$ O O O O $complex$ O O O O $any$ O $any$ O O O O O O O $Projector$ O $void$ O $complex$ O O O $VNode$ O O O $HTMLElement$ O $complex$ O $any$ O $any$ O $any$ O O O O $complex$ O O $HTMLElement$ O $HTMLElement$ O $ChildNode$ O $ChildNode$ O $complex$ O O $MouseEvent$ O O $HTMLElement$ O $HTMLElement$ O $string$ O O O O O O $complex$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $HTMLElement$ O $any$ O $any$ O $HTMLElement$ O O $MouseEvent$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $Projector$ O $void$ O O O $HTMLElement$ O $any$ O $any$ O $HTMLElement$ O O $MouseEvent$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O $void$ O $Projector$ O O O $any$ O O O O O O O O $complex$ O $ArrayConstructor$ O $any[]$ O $complex$ O O O O $ArrayConstructor$ O $any[]$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $void$ O $any$ O O O O O $ArrayConstructor$ O $any[]$ O $complex$ O $complex$ O O O O O $any$ O O O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $void$ O O O O O $boolean$ O O O O O O $VNode$ O O O O $complex$ O O O O $boolean$ O O $complex$ O O O O $any$ O $any$ O $void$ O $void$ O O O O O O O O O O $Projector$ O $Projector$ O O O O O O $HTMLElement$ O $Document$ O O O O O O $Projector$ O $void$ O $HTMLElement$ O $VNode$ O O O $HTMLElement$ O $HTMLElement$ O $ChildNode$ O $complex$ O O $HTMLButtonElement$ O $HTMLElement$ O $ChildNode$ O $complex$ O $HTMLButtonElement$ O $any$ O O $HTMLButtonElement$ O $HTMLButtonElement$ O $string$ O O O O O O O $any$ O $true$ O O $any$ O $any$ O $any$ O $Projector$ O $void$ O O O O $complex$ O O $Function$ O $HTMLButtonElement$ O $any$ O $FunctionConstructor$ O $HTMLElement$ O $HTMLElement$ O O $complex$ O $Function$ O O $complex$ O $complex$ O $string$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $Document$ O $Document$ O O O $Projector$ O $Projector$ O O O O O O $VNode$ O O O O $complex$ O O O O O $VNode$ O O O O $complex$ O O O O $Projector$ O $void$ O $complex$ O O O $VNode$ O O $Projector$ O $void$ O $complex$ O O O $VNode$ O O O $Projection$ O $Projector$ O $Projection$ O $VNode$ O O $any$ O $Projection$ O $Element$ O $string$ O O $any$ O $any$ O O O O $any$ O O O O O $Projector$ O $Projection$ O $VNode$ O O O O O $any$ O $any$ O O O O O O O O O
import { expect , sinon } from 's' ; import { SinonSpy } from 's' ; import * as path from 's' ; import { ProjectorPerformanceLogger } from 's' ; describe ( 's' , ( ) => { let window : { performance ? : { mark : SinonSpy ; measure ? : SinonSpy ; } } ; let clearCachedRequires = ( ) => { let sourceFile = path . normalize ( path . join ( __dirname , 's' ) ) ; delete require . cache [ sourceFile ] ; } ; beforeEach ( ( ) => { clearCachedRequires ( ) ; window = { performance : { mark : sinon . spy ( ) , measure : sinon . spy ( ) } } ; ( global as any ) . window = window ; } ) ; let getLogger : ( ) => ProjectorPerformanceLogger = ( ) => require ( 's' ) . windowPerformanceProjectorLogger ; afterEach ( ( ) => { delete ( global as any ) . window ; clearCachedRequires ( ) ; } ) ; it ( 's' , ( ) => { delete window . performance . measure ; let logger = getLogger ( ) ; let event = { } as any ; logger ( 's' , event ) ; logger ( 's' , event ) ; expect ( window . performance . mark ) . to . not . have . been . called ; } ) ; it ( 's' , ( ) => { let logger = getLogger ( ) ; let event = { } as any ; logger ( 's' , event ) ; logger ( 's' , event ) ; expect ( window . performance . measure ) . to . have . been . calledOnce ; } ) ; it ( 's' , ( ) => { let logger = getLogger ( ) ; logger ( 's' , undefined ) ; logger ( 's' , undefined ) ; logger ( 's' , undefined ) ; logger ( 's' , undefined ) ; logger ( 's' , undefined ) ; logger ( 's' , undefined ) ; let calls = window . performance . measure . getCalls ( ) . map ( call => call . args ) ; expect ( calls ) . to . deep . equal ( [ [ 's' , 's' , 's' ] , [ 's' , 's' , 's' ] , [ 's' , 's' , 's' ] , [ 's' , 's' , 's' ] , [ 's' , 's' , 's' ] ] ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O O O O $complex$ O O $complex$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $void$ O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $complex$ O O O O O $ProjectorPerformanceLogger$ O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $void$ O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O $any$ O O $ProjectorPerformanceLogger$ O $ProjectorPerformanceLogger$ O O O O $any$ O O O O O O $ProjectorPerformanceLogger$ O O O $any$ O O $ProjectorPerformanceLogger$ O O O $any$ O O $any$ O $complex$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $ProjectorPerformanceLogger$ O $ProjectorPerformanceLogger$ O O O O $any$ O O O O O O $ProjectorPerformanceLogger$ O O O $any$ O O $ProjectorPerformanceLogger$ O O O $any$ O O $any$ O $complex$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $ProjectorPerformanceLogger$ O $ProjectorPerformanceLogger$ O O O $ProjectorPerformanceLogger$ O O O $undefined$ O O $ProjectorPerformanceLogger$ O O O $undefined$ O O $ProjectorPerformanceLogger$ O O O $undefined$ O O $ProjectorPerformanceLogger$ O O O $undefined$ O O $ProjectorPerformanceLogger$ O O O $undefined$ O O $ProjectorPerformanceLogger$ O O O $undefined$ O O O $any$ O $complex$ O $complex$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' ; import * as zlib from 's' ; let input = fs . createReadStream ( `template` ) ; let stream = input . pipe ( zlib . createGzip ( ) ) ; let length = 0 ; stream . on ( 's' , chunk => { length += chunk . length ; } ) ; stream . on ( 's' , ( ) => { console . log ( 's' , length / 0 ) ; if ( length >= 0 * 0 ) { console . error ( 's' ) ; process . exit ( 0 ) ; } console . log ( 's' ) ; process . exit ( 0 ) ; } ) ;	O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $number$ O O O $any$ O $any$ O O O $any$ O O $number$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $Console$ O $void$ O O O $number$ O O O O O O $number$ O O O O O O $Console$ O $void$ O O O O $any$ O $any$ O O O O O $Console$ O $void$ O O O O $any$ O $any$ O O O O O O O
'js' var Metalsmith = require ( 's' ) ; var layouts = require ( 's' ) ; var markdown = require ( 's' ) ; var inPlace = require ( 's' ) ; var postcss = require ( 's' ) ; exports . init = ( args ) => { return Metalsmith ( __dirname ) . metadata ( { injectScript : args . injectScript || 's' , googleAnalyticsKey : 's' , maquetteVersion : require ( 's' ) . version , liveEditors : false , liveEditorsVelocity : false , liveEditorsCss : false , workbench : false } ) . source ( 's' ) . destination ( 's' ) . clean ( true ) . use ( inPlace ( { engineOptions : { root : __dirname } } ) ) . use ( markdown ( ) ) . use ( layouts ( { engine : 's' , directory : 's' , engineOptions : { root : __dirname } } ) ) . use ( postcss ( { plugins : { 's' : { } } } ) ) ; } ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O O O O $any$ O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O $complex$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $string$ O O O $string$ O O O $complex$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O O O O O O O O O O O O
'js' const init = require ( 's' ) . init ; init ( { } ) . build ( function ( err ) { if ( err ) { throw err ; } } ) ;	O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O $any$ O O O $any$ O O O O O
'js' const watch = require ( 's' ) ; const serve = require ( 's' ) ; const init = require ( 's' ) . init ; init ( { injectScript : 's' } ) . use ( serve ( { port : 0 } ) ) . use ( watch ( { paths : { "s" : true , "s" : "s" , "s" : "s" , "s" : "s" } , livereload : 0 } ) ) . build ( function ( err ) { if ( err ) { throw err ; } console . log ( 's' ) } ) ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $string$ O O O O O $any$ O $any$ O O $number$ O O O O O O $any$ O $any$ O O $complex$ O O O O O O O O O O O O O O O O O O O $number$ O O O O O O $any$ O O O $any$ O O O O $any$ O O O $any$ O O $Console$ O $void$ O O O O O O
'js' ( function ( ) { var h = maquette . h ; var transformFunctionNames = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' ] ; window . createRemoteRow = function ( remote , initialTransformFunctionName , initialValue ) { var transformFunctionName = initialTransformFunctionName ; var value = initialValue || 's' ; for ( var i = 0 ; ! transformFunctionName && i < transformFunctionNames . length ; i ++ ) { if ( ! remote . hasTransform ( transformFunctionNames [ i ] ) ) { transformFunctionName = transformFunctionNames [ i ] ; } } var getValueSuffix = function ( ) { if ( transformFunctionName === 's' || transformFunctionName === 's' ) { return 's' ; } else if ( transformFunctionName === 's' || transformFunctionName === 's' ) { return 's' ; } else { return 's' ; } } ; var handleTransformChange = function ( evt ) { transformFunctionName = evt . target . value ; } ; var handleValueInput = function ( evt ) { value = evt . target . value ; } ; var remoteRow = { getTransform : function ( ) { return transformFunctionName ; } , getSaucerStyle : function ( ) { if ( value ) { return transformFunctionName + 's' + value + getValueSuffix ( ) + 's' ; } else { return 's' ; } } , render : function ( ) { return h ( 's' , { key : remoteRow } , [ h ( 's' , { value : transformFunctionName , onchange : handleTransformChange } , [ transformFunctionNames . map ( function ( name ) { return h ( 's' , { key : name , value : name } , [ name ] ) ; } ) ] ) , h ( 's' , { value : value , oninput : handleValueInput } ) , getValueSuffix ( ) ] ) ; } } ; return remoteRow ; } ; } ( ) ) ;	O O O O O O O $any$ O $any$ O $any$ O O $string[]$ O O O O O O O O O O O O O O O O O $complex$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $number$ O O O O $any$ O $number$ O $string[]$ O $number$ O $number$ O O O O O O $any$ O $any$ O $string[]$ O $number$ O O O O $any$ O $string[]$ O $number$ O O O O O $complex$ O O O O O O O $any$ O O O $any$ O O O O O O O O O O O $any$ O O O $any$ O O O O O O O O O O O O O O O O O $void$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $complex$ O O $any$ O O O O O O $any$ O O O $string$ O O O O O O O $any$ O O O $any$ O O O $any$ O $complex$ O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O $complex$ O $complex$ O O O $any$ O O O O $any$ O $any$ O $void$ O $void$ O O O $string[]$ O $U[]$ O O O $string$ O O O $any$ O O O O $string$ O $string$ O $string$ O $string$ O O O $string$ O O O O O O O O $any$ O O O O $any$ O $any$ O $void$ O $void$ O O O $complex$ O O O O O O O O O $complex$ O O O O O O O O
'js' ( function ( ) { var h = maquette . h ; window . createRemote = function ( ) { var rowComponents = [ ] ; var handleAddClick = function ( evt ) { evt . preventDefault ( ) ; } ; var remote = { getSaucerStyle : function ( ) { return rowComponents . map ( function ( f ) { return f . getSaucerStyle ( ) ; } ) . join ( 's' ) ; } , hasTransform : function ( transform ) { return rowComponents . some ( function ( f ) { return f . getTransform ( ) === transform ; } ) ; } , render : function ( ) { return h ( 's' , { } , [ rowComponents . map ( function ( f ) { return f . render ( ) ; } ) , rowComponents . some ( function ( row ) { return ! row . getSaucerStyle ( ) ; } ) || rowComponents . length == 0 ? [ ] : [ h ( 's' , { onclick : handleAddClick } , [ 's' ] ) ] ] ) ; } } ; rowComponents . push ( createRemoteRow ( remote , 's' , 's' ) ) ; return remote ; } ; } ( ) ) ;	O O O O O O O $any$ O $any$ O $any$ O $complex$ O $any$ O O O O O O $any[]$ O O O O O $void$ O O O $any$ O O $any$ O $any$ O O O O O O $complex$ O O $string$ O O O O O O $any[]$ O $U[]$ O O O $any$ O O O $any$ O $any$ O O O O O O $string$ O O O O O O $boolean$ O O O $any$ O O O $any[]$ O $boolean$ O O O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any[]$ O $U[]$ O O O $any$ O O O $any$ O $any$ O O O O O O $any[]$ O $boolean$ O O O $any$ O O O O $any$ O $any$ O O O O O O $any[]$ O $number$ O O O O O O O $any$ O O O O $void$ O $void$ O O O O O O O O O O O O O $any[]$ O $number$ O $any$ O $complex$ O O O O O O O O $complex$ O O O O O O O O
'js' var h = maquette . h ; var projector = maquette . createProjector ( ) ; var remote = createRemote ( ) ; function render ( ) { return h ( 's' , [ remote . render ( ) , h ( 's' , { style : 's' + remote . getSaucerStyle ( ) } ) ] ) ; } document . addEventListener ( 's' , function ( ) { projector . append ( document . body , render ) ; } ) ;	O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $complex$ O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O $string$ O O O $any$ O $any$ O O O O O O O O $Document$ O O O O O O O O O $any$ O $any$ O $Document$ O $HTMLElement$ O $complex$ O O O O O
'js' var h = maquette . h ; var projector = maquette . createProjector ( ) ; function render ( ) { return h ( 's' , [ ] ) ; } document . addEventListener ( 's' , function ( ) { projector . append ( document . body , render ) ; } ) ;	O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $complex$ O O O O $any$ O O O O O O O O $Document$ O O O O O O O O O $any$ O $any$ O $Document$ O $HTMLElement$ O $complex$ O O O O O
'js' var h = maquette . h ; var projector = maquette . createProjector ( ) ; var rotation = 0 ; var x = - 0 ; var y = 0 ; var startDate = new Date ( ) . getTime ( ) ; function handleRotationInput ( evt ) { rotation = evt . target . value ; } function tick ( ) { var moment = ( new Date ( ) . getTime ( ) - startDate ) / 0 ; x = Math . round ( 0 * Math . sin ( moment ) ) ; y = Math . round ( 0 * Math . cos ( moment ) ) ; requestAnimationFrame ( tick ) ; } function render ( ) { return h ( 's' , [ h ( 's' , { } , [ h ( 's' , [ 's' , h ( 's' , { type : 's' , min : 's' , max : 's' , value : rotation , oninput : handleRotationInput , onchange : handleRotationInput } ) ] ) ] ) , h ( 's' , [ h ( 's' , { style : 's' + x + 's' + y + 's' + rotation + 's' } ) ] ) ] ) ; } document . addEventListener ( 's' , function ( ) { projector . append ( document . body , render ) ; tick ( ) ; } ) ;	O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $number$ O O O O $number$ O O O O O $number$ O O O O $number$ O O $DateConstructor$ O O O $number$ O O O O $complex$ O $any$ O O $number$ O $any$ O $any$ O $any$ O O O $void$ O O O O $number$ O O O $DateConstructor$ O O O $number$ O O O $number$ O O O O $number$ O $Math$ O $number$ O O O $Math$ O $number$ O $number$ O O O $number$ O $Math$ O $number$ O O O $Math$ O $number$ O $number$ O O O $number$ O $void$ O O O O $complex$ O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O $string$ O O O $string$ O O O $string$ O O O $number$ O $number$ O $complex$ O $complex$ O $complex$ O $complex$ O O O O O O O $any$ O O O O $any$ O O O O $string$ O O O $number$ O O O $number$ O O O $number$ O O O O O O O O O O $Document$ O O O O O O O O O $any$ O $any$ O $Document$ O $HTMLElement$ O $complex$ O O $void$ O O O O O O
'js' var h = maquette . h ; var projector = maquette . createProjector ( ) ; var rotation = 0 ; var rotationVisible = true ; var stealth = false ; function handleRotationInput ( evt ) { rotation = evt . target . value ; } function handleStealthChange ( evt ) { evt . preventDefault ( ) ; stealth = ! stealth ; } function handleRemoveClick ( evt ) { rotationVisible = false ; } function slideUp ( element , removeElement ) { Velocity . animate ( element , 's' , 0 , 's' , removeElement ) ; } function render ( ) { return h ( 's' , [ h ( 's' , { } , [ rotationVisible ? [ h ( 's' , { exitAnimation : slideUp } , [ 's' , h ( 's' , { type : 's' , value : rotation , oninput : handleRotationInput } ) , 's' ] ) ] : [ ] , h ( 's' , { exitAnimation : slideUp } , [ 's' , h ( 's' , { type : 's' , checked : stealth , onchange : handleStealthChange } ) ] ) , rotationVisible ? [ h ( 's' , { onclick : handleRemoveClick } , [ 's' ] ) ] : [ ] ] ) , h ( 's' , { style : 's' + rotation + 's' , classes : { stealth : stealth } } ) ] ) ; } document . addEventListener ( 's' , function ( ) { projector . append ( document . body , render ) ; } ) ;	O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $number$ O O O O $boolean$ O O O O $boolean$ O O O O $complex$ O $any$ O O $number$ O $any$ O $any$ O $any$ O O O $void$ O $any$ O O $any$ O $any$ O O O $boolean$ O O $boolean$ O O O $void$ O $any$ O O $boolean$ O O O O O $void$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $complex$ O O O O $any$ O O O O $any$ O O O O O O O $boolean$ O O $any$ O O O O $void$ O $void$ O O O O O $any$ O O O O $string$ O O O $number$ O $number$ O $complex$ O $complex$ O O O O O O O O O O O $any$ O O O O $void$ O $void$ O O O O O $any$ O O O O $string$ O O O $boolean$ O $boolean$ O $void$ O $void$ O O O O O $boolean$ O O $any$ O O O O $void$ O $void$ O O O O O O O O O O O O O $any$ O O O O $string$ O O O $number$ O O O $complex$ O O $boolean$ O $boolean$ O O O O O O O $Document$ O O O O O O O O O $any$ O $any$ O $Document$ O $HTMLElement$ O $complex$ O O O O O
'js' var h = maquette . h ; var projector = maquette . createProjector ( ) ; var rotation = 0 ; function handleRotationInput ( evt ) { rotation = evt . target . value ; } function render ( ) { return h ( 's' , [ h ( 's' , { } , [ h ( 's' , [ 's' , h ( 's' , { type : 's' } ) , 's' ] ) ] ) , h ( 's' , { style : 's' + rotation + 's' } ) ] ) ; } document . addEventListener ( 's' , function ( ) { projector . append ( document . body , render ) ; } ) ;	O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $number$ O O O O $complex$ O $any$ O O $number$ O $any$ O $any$ O $any$ O O O $complex$ O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O $string$ O O O O O O O O O O O $any$ O O O O $string$ O O O $number$ O O O O O O O O $Document$ O O O O O O O O O $any$ O $any$ O $Document$ O $HTMLElement$ O $complex$ O O O O O
'js' var h = maquette . h ; var projector = maquette . createProjector ( ) ; var rotation = 0 ; function render ( ) { return h ( 's' , [ h ( 's' , { } ) ] ) ; } document . addEventListener ( 's' , function ( ) { projector . append ( document . body , render ) ; } ) ;	O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $number$ O O O O $complex$ O O O O $any$ O O O O $any$ O O O O O O O O O O $Document$ O O O O O O O O O $any$ O $any$ O $Document$ O $HTMLElement$ O $complex$ O O O O O
'js' var h = maquette . h ; var projector = maquette . createProjector ( ) ; var stealth = true ; function render ( ) { return h ( 's' , [ h ( 's' , { } ) ] ) ; } document . addEventListener ( 's' , function ( ) { projector . append ( document . body , render ) ; } ) ;	O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O $complex$ O O O O $any$ O O O O $any$ O O O O O O O O O O $Document$ O O O O O O O O O $any$ O $any$ O $Document$ O $HTMLElement$ O $complex$ O O O O O
'js' window . createMarkupMatcher = function ( projector , desiredMarkup ) { var h = maquette . h ; var markupMatchedPrefix = "s" ; var markupWrong = "s" ; var markupMissing = desiredMarkup ; var markupMatchedSuffix = "s" ; var achieved = false ; var lastMarkup = "s" ; return { title : "s" , isAchieved : function ( ) { return achieved ; } , onSceneUpdate : function ( contentWindow ) { if ( achieved ) { return ; } var markup = "s" ; if ( ! contentWindow . document . body . querySelector ( "s" ) ) { markup = contentWindow . document . body . innerHTML ; } if ( markup !== lastMarkup ) { lastMarkup = markup ; var matchedUntil = 0 ; var checkChar = desiredMarkup . charAt ( 0 ) ; var used = 0 ; var i ; for ( i = 0 ; i < markup . length ; i ++ ) { if ( markup . charAt ( i ) === "s" ) continue ; if ( checkChar === markup . charAt ( i ) ) { do { matchedUntil ++ ; checkChar = desiredMarkup . charAt ( matchedUntil ) ; } while ( checkChar === "s" || checkChar === "s" ) ; } else { used = i - 0 ; break ; } } markupWrong = "s" ; var lastMatchedUntil = desiredMarkup . length - 0 ; checkChar = desiredMarkup . charAt ( lastMatchedUntil ) ; if ( matchedUntil < desiredMarkup . length - 0 ) { for ( i = markup . length - 0 ; i > used ; i -- ) { if ( markup . charAt ( i ) === "s" ) continue ; if ( checkChar === markup . charAt ( i ) ) { do { lastMatchedUntil -- ; checkChar = desiredMarkup . charAt ( lastMatchedUntil ) ; } while ( checkChar === "s" || checkChar === "s" ) ; } else { markupWrong = markup . substr ( used + 0 , i - used ) ; break ; } } } if ( markupWrong === "s" && desiredMarkup . charAt ( matchedUntil - 0 ) === "s" && checkChar === "s" ) { matchedUntil -- ; lastMatchedUntil -- ; } markupMatchedPrefix = desiredMarkup . substr ( 0 , matchedUntil ) ; markupMissing = desiredMarkup . substr ( matchedUntil , lastMatchedUntil + 0 - matchedUntil ) ; markupMatchedSuffix = desiredMarkup . substr ( lastMatchedUntil + 0 ) ; achieved = ( markupWrong === "s" && markupMissing === "s" ) ; } } , render : function ( ) { return [ h ( "s" , [ "s" ] ) , h ( "s" , [ h ( "s" , [ h ( "s" , { key : "s" } , [ markupMatchedPrefix ] ) , h ( "s" , [ markupWrong ] ) , h ( "s" , [ markupMissing ] ) , h ( "s" , { key : "s" } , [ markupMatchedSuffix ] ) ] ) ] ) ] ; } } ; } ;	O $complex$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $string$ O O O O $string$ O O O O $any$ O $any$ O O $string$ O O O O $boolean$ O O O O $string$ O O O O O $string$ O O O $boolean$ O O O O O O $boolean$ O O O $void$ O O O $any$ O O O O $boolean$ O O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $string$ O O $string$ O $string$ O O $number$ O O O O $any$ O $any$ O $any$ O O O O O $number$ O O O O $any$ O O O $any$ O O O $number$ O $string$ O $number$ O $any$ O O O O O $string$ O $string$ O $number$ O O O O O O O O $any$ O $string$ O $string$ O $number$ O O O O O $number$ O O $any$ O $any$ O $any$ O $number$ O O O O O $any$ O O O $any$ O O O O O O O $number$ O $number$ O O O O O O O $string$ O O O O $number$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $number$ O O O O $number$ O $any$ O $any$ O O O O O O $any$ O $string$ O $number$ O O O $number$ O $number$ O $any$ O O O O O $string$ O $string$ O $number$ O O O O O O O O $any$ O $string$ O $string$ O $number$ O O O O O $number$ O O $any$ O $any$ O $any$ O $number$ O O O O O $any$ O O O $any$ O O O O O O O $string$ O $string$ O $string$ O $number$ O O O $number$ O $number$ O O O O O O O O O $string$ O O O $any$ O $any$ O $number$ O O O O O O $any$ O O O O $number$ O O $number$ O O O $string$ O $any$ O $any$ O O O $number$ O O $any$ O $any$ O $any$ O $number$ O $number$ O O O $number$ O O $string$ O $any$ O $any$ O $number$ O O O O $boolean$ O O $string$ O O O $any$ O O O O O O O $any[]$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $string$ O O O O O $string$ O O O $any$ O O O O $string$ O O O $any$ O O O O $any$ O O O $any$ O O O O $string$ O O O O O $string$ O O O O O O O O O O O O O
'js' ( function ( ) { var h = maquette . h ; var currentpage = document . location . pathname ; currentpage = currentpage . substr ( currentpage . lastIndexOf ( 's' ) + 0 ) ; var tableOfContent = [ { id : 's' , title : 's' , pages : [ 's' ] } , { id : 's' , title : 's' , pages : [ 's' , 's' ] } , { id : 's' , title : 's' , pages : [ 's' , 's' , ] } , { id : 's' , title : 's' , pages : [ 's' , 's' ] } , { id : 's' , title : 's' , pages : [ 's' , 's' ] } , { id : 's' , title : 's' , pages : [ 's' , 's' ] } , { id : 's' , title : 's' , pages : [ 's' ] } , { id : 's' , title : 's' , hidden : true , pages : [ 's' , 's' , 's' ] } ] ; var pages = [ ] ; var pageLevelIds = [ ] ; tableOfContent . forEach ( function ( entry ) { entry . pages . forEach ( function ( page ) { pages . push ( page ) ; pageLevelIds . push ( entry . id ) ; } ) ; } ) ; var levelsAchieved ; var isLevelAchieved = function ( levelName ) { if ( ! levelsAchieved ) { levelsAchieved = [ ] ; try { levelsAchieved = JSON . parse ( localStorage . levelsAchieved ) ; } catch ( e ) { } } return levelsAchieved . indexOf ( levelName ) !== - 0 ; } ; var setLevelAchieved = function ( levelName ) { if ( ! isLevelAchieved ( levelName ) ) { levelsAchieved . push ( levelName ) ; localStorage . levelsAchieved = JSON . stringify ( levelsAchieved ) ; } } ; window . createTableOfContent = function ( ) { return { render : function ( ) { var levelCount = 0 ; return h ( 's' , [ h ( 's' , [ 's' ] ) , h ( 's' , [ tableOfContent . map ( function ( level ) { levelCount ++ ; var link = level . pages [ 0 ] ; if ( level . hidden && level . pages . indexOf ( currentpage ) === - 0 ) { if ( ! isLevelAchieved ( level . id ) ) { return ; } } var achieved = isLevelAchieved ( level . id ) ; return h ( 's' , { classes : { active : link === currentpage } } , [ h ( 's' , { href : link , classes : { achieved : achieved } } , [ h ( 's' , [ 's' + levelCount + 's' ] ) , h ( 's' , [ level . title ] ) ] ) ] ) ; } ) ] ) ] ) ; } } ; } ; var lockPath = 's' ; var tocDisappearsAnimation = function ( element , removeElement ) { window . Velocity . animate ( element , { translateX : [ - 0 , 's' , 0 ] } , 0 , removeElement ) ; } ; var tocAppearsAnimation = function ( element ) { element . style . transform = 's' ; window . Velocity . animate ( element , { translateX : [ 0 , 's' , - 0 ] } , 0 ) ; } ; window . createNavigationBar = function ( projector , showMenuButton , getUnlocked ) { var menu ; var showMenu = false ; var toggleMenu = function ( ) { if ( ! menu ) { menu = window . createTableOfContent ( ) ; } showMenu = ! showMenu ; } var progress = createProcessBar ( ) ; var navigation = createNavigationButtons ( projector , getUnlocked ) ; return { render : function ( ) { return h ( 's' , [ showMenu ? [ h ( 's' , { enterAnimation : tocAppearsAnimation , exitAnimation : tocDisappearsAnimation } , [ menu . render ( ) ] ) ] : [ ] , h ( 's' , [ showMenuButton ? [ h ( 's' , { type : 's' , id : 's' } ) , h ( 's' , { for : 's' , onclick : toggleMenu } , [ h ( 's' ) ] ) ] : [ ] ] ) , h ( 's' , [ progress . render ( ) ] ) , h ( 's' , [ navigation . render ( ) ] ) ] ) ; } } ; } ; var createProcessBar = function ( projector ) { return { render : function ( ) { return h ( 's' , [ tableOfContent . map ( function ( level ) { if ( level . hidden ) { return ; } var achieved = isLevelAchieved ( level . id ) ; var link = achieved ? level . pages [ 0 ] : undefined ; return h ( 's' , { href : link , title : level . title , classes : { achieved : achieved , active : level . pages [ 0 ] === currentpage || level . pages [ 0 ] === currentpage } } ) ; } ) ] ) } } } ; var createNavigationButtons = function ( projector , getUnlocked ) { var pageIndex = pages . indexOf ( currentpage ) ; if ( pageIndex === - 0 ) { throw new Error ( 's' + currentpage ) ; } var unlocked = ! getUnlocked || ! ! isLevelAchieved ( pageLevelIds [ pageIndex ] ) ; var removeLockAnimation = function ( element , removeElement ) { window . Velocity . animate ( element , { opacity : [ 0 , 's' , 0 ] , scale : [ 0 , 's' , 0 ] } , 0 , removeElement ) ; } ; var navigation = { render : function ( ) { if ( ! unlocked ) { unlocked = getUnlocked ( ) ; if ( unlocked ) { setLevelAchieved ( pageLevelIds [ pageIndex ] ) ; } projector . scheduleRender ( ) ; } var locked = ! unlocked ; return [ pageIndex > 0 ? [ h ( 's' , { href : pages [ pageIndex - 0 ] } , [ 's' ] ) ] : [ ] , pageIndex < pages . length - 0 ? [ h ( 's' , { classes : { locked : locked , unlocked : unlocked } , href : pages [ pageIndex + 0 ] } , [ locked ? [ h ( 's' , { viewBox : 's' , exitAnimation : removeLockAnimation } , [ h ( 's' , { d : lockPath } ) ] ) ] : [ ] , 's' ] ) ] : [ ] ] ; } } ; return navigation ; } ; window . createNavigation = createNavigationButtons ; } ( ) ) ;	O O O O O O O $any$ O $any$ O $any$ O O $string$ O $Document$ O $Location$ O $string$ O $string$ O $string$ O $string$ O $string$ O $number$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O $string$ O O O $string$ O O O $boolean$ O O O $string[]$ O O O O O O O O O O O O $any[]$ O O O O O $any[]$ O O O O $complex$ O $void$ O O O $complex$ O O $complex$ O $string[]$ O $void$ O O O $string$ O O $any[]$ O $number$ O $string$ O O $any[]$ O $number$ O $complex$ O $string$ O O O O O O O O O $any$ O O $boolean$ O O O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O $JSON$ O $any$ O $Storage$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $void$ O O O $any$ O O O O O $boolean$ O $any$ O O O $any$ O $any$ O $any$ O O $Storage$ O $any$ O $JSON$ O $complex$ O $any$ O O O O O $complex$ O $any$ O O O O O O O $any$ O O O O O O $number$ O O O O $any$ O O O O $any$ O O O O O O O O $any$ O O O O $complex$ O $U[]$ O O O $complex$ O O $number$ O O O $string$ O $complex$ O $string[]$ O O O O O O $complex$ O $boolean$ O $complex$ O $string[]$ O $number$ O $string$ O O O O O O O O O $boolean$ O $complex$ O $string$ O O O O O O O O $boolean$ O $boolean$ O $complex$ O $string$ O O O $any$ O O O O $complex$ O O $boolean$ O $string$ O $string$ O O O O $any$ O O O O $string$ O $string$ O $complex$ O O $boolean$ O $boolean$ O O O O $any$ O O O O O O $number$ O O O O O $any$ O O O O $complex$ O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O $void$ O O O $any$ O $any$ O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O O O O O O O O O O $any$ O O O O O $void$ O O O $any$ O O $any$ O $any$ O $any$ O O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O O O O O O O O O O O O O $complex$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O $boolean$ O O O O $void$ O O O O O O O O $any$ O O $any$ O $complex$ O $any$ O O O O $boolean$ O O $boolean$ O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O O O O $boolean$ O O $any$ O O O O $void$ O $void$ O $void$ O $void$ O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O O O O $string$ O O O $void$ O $void$ O O O $any$ O O O O O O O O O O O O $any$ O O O O $complex$ O $any$ O O O O O $any$ O O O O $complex$ O $any[][]$ O O O O O O O O O O O O O $complex$ O O O $any$ O O O O $any$ O O O O O O $any$ O O O O $complex$ O $U[]$ O O O $complex$ O O O O $complex$ O $boolean$ O O O O O O $boolean$ O $boolean$ O $complex$ O $string$ O O O $string$ O $boolean$ O $complex$ O $string[]$ O O O O $undefined$ O O $any$ O O O O $string$ O $string$ O $string$ O $complex$ O $string$ O $complex$ O O $boolean$ O $boolean$ O $boolean$ O $complex$ O $string[]$ O O O O $string$ O $complex$ O $string[]$ O O O O $string$ O O O O O O O O O O O O O $complex$ O O O $any$ O $any$ O O O $number$ O $any[]$ O $number$ O $string$ O O O O $number$ O O O O O O O $ErrorConstructor$ O O O $string$ O O O O $boolean$ O O $any$ O O O $boolean$ O $any[]$ O $number$ O O O O $void$ O O O $any$ O $any$ O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O O O O O O O O O $complex$ O O O O O O O O O O O O $any$ O O O O O $complex$ O O $any[][]$ O O O O O O O O $boolean$ O O $boolean$ O $any$ O O O O O $boolean$ O O $void$ O $any[]$ O $number$ O O O O $any$ O $any$ O O O O O $boolean$ O O $boolean$ O O O $number$ O O O O $any$ O O O O $any$ O $any[]$ O $number$ O O O O O O O O O O O O O O $number$ O $any[]$ O $number$ O O O O $any$ O O O O $complex$ O O $boolean$ O $boolean$ O $boolean$ O $boolean$ O O $any$ O $any[]$ O $number$ O O O O O O $boolean$ O O $any$ O O O O $string$ O O O $void$ O $void$ O O O $any$ O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O $complex$ O O O $complex$ O $any$ O $complex$ O O O O O O