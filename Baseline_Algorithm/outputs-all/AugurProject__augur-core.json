export const abi = require ( 's' ) ;	O O $any$ O $any$ O O O O
import BN = require ( 's' ) ; type NetworkOptions = { isProduction : boolean ; http : string ; ws ? : string ; ipc ? : string ; privateKey ? : string ; gasPrice : BN ; } type Networks = { [ networkName ] : NetworkOptions ; } const networks = { ropsten : { isProduction : false , http : "s" , privateKey : process . env . ROPSTEN_PRIVATE_KEY , gasPrice : new BN ( 0 * 0 ) } , kovan : { isProduction : false , http : "s" , privateKey : process . env . KOVAN_PRIVATE_KEY , gasPrice : new BN ( 0 ) } , rinkeby : { isProduction : false , http : "s" , ws : "s" , privateKey : process . env . RINKEBY_PRIVATE_KEY , gasPrice : new BN ( 0 * 0 ) } , clique : { isProduction : false , http : "s" , privateKey : process . env . CLIQUE_PRIVATE_KEY || "s" , gasPrice : new BN ( 0 ) } , aura : { isProduction : false , http : "s" , privateKey : process . env . AURA_PRIVATE_KEY || "s" , gasPrice : new BN ( 0 ) } , environment : { isProduction : process . env . PRODUCTION === "s" || false , http : process . env . ETHEREUM_HTTP || "s" , ws : process . env . ETHEREUM_WS || "s" , ipc : process . env . ETHEREUM_IPC , privateKey : process . env . ETHEREUM_PRIVATE_KEY || "s" , gasPrice : ( ( typeof process . env . ETHEREUM_GAS_PRICE_IN_NANOETH === "s" ) ? new BN ( 0 ) : new BN ( process . env . ETHEREUM_GAS_PRICE_IN_NANOETH ! ) ) . mul ( new BN ( 0 ) ) } , testrpc : { isProduction : false , http : "s" , gasPrice : new BN ( 0 ) } } export class NetworkConfiguration { public readonly networkName : string ; public readonly http : string ; public readonly ws ? : string ; public readonly ipc ? : string ; public readonly privateKey ? : string ; public readonly gasPrice : BN ; public readonly isProduction : boolean ; public constructor ( networkName , http , ws : string | undefined , ipc : string | undefined , gasPrice , privateKey : string | undefined , isProduction ) { this . networkName = networkName ; this . http = http ; this . ws = ws ; this . ipc = ipc ; this . gasPrice = gasPrice ; this . privateKey = privateKey ; this . isProduction = isProduction ; } public static create ( networkName = "s" , validatePrivateKey = true ) { const network = networks [ networkName ] ; if ( network === undefined || network === null ) throw new Error ( `template` ) ; if ( validatePrivateKey && ( network . privateKey === undefined || network . privateKey === null ) ) throw new Error ( `template` ) ; return new NetworkConfiguration ( networkName , network . http , network . ws , network . ipc , network . gasPrice , network . privateKey , network . isProduction ) ; } }	O $any$ O O O O O O O $any$ O O $boolean$ O O O $string$ O O O $string$ O O O O $string$ O O O O $string$ O O O O $BN$ O $any$ O O O $any$ O O O $string$ O O $any$ O O O $Networks$ O O $complex$ O O $false$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $BN$ O O $any$ O O O O O O O $complex$ O O $false$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $BN$ O O $any$ O O O O O $complex$ O O $false$ O O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $BN$ O O $any$ O O O O O O O $complex$ O O $false$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O $BN$ O O $any$ O O O O O $complex$ O O $false$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O $BN$ O O $any$ O O O O O $complex$ O O $boolean$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $BN$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $BN$ O O $any$ O O O O O O $complex$ O O $false$ O O O $string$ O O O $BN$ O O $any$ O O O O O O O $any$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O $string$ O O O O O O $string$ O O O O O O $BN$ O $any$ O O O $boolean$ O O O O O O $string$ O $string$ O $string$ O O O O O $string$ O O O O O $BN$ O $string$ O O O O O $boolean$ O O O O $string$ O $string$ O O O $string$ O $string$ O O O $string$ O $string$ O O O $string$ O $string$ O O O $BN$ O $BN$ O O O $string$ O $string$ O O O $boolean$ O $boolean$ O O O O $NetworkConfiguration$ O $string$ O O O $boolean$ O O O O O $NetworkOptions$ O $Networks$ O $string$ O O O O $NetworkOptions$ O $undefined$ O $NetworkOptions$ O O O O O $ErrorConstructor$ O O O O O O $boolean$ O O $NetworkOptions$ O $string$ O $undefined$ O $NetworkOptions$ O $string$ O O O O O O $ErrorConstructor$ O O O O O O $any$ O $string$ O $NetworkOptions$ O $string$ O $NetworkOptions$ O $string$ O $NetworkOptions$ O $string$ O $NetworkOptions$ O $BN$ O $NetworkOptions$ O $string$ O $NetworkOptions$ O $boolean$ O O O O
export function 0 ( stringToEncode ) { return `template` ; } export async function sleep ( milliseconds ) < void > { return new Promise < void > ( resolve => setTimeout ( resolve , milliseconds ) ) ; } export async function resolveAll ( promises < Promise < any > > ) { let firstError : Error | null = null ; for ( let promise of promises ) { try { await promise ; } catch ( e ) { firstError = firstError || e ; } } if ( firstError !== null ) throw firstError ; }	O O $string$ O $string$ O O O O O O O O O $Promise$ O $number$ O O O O O O O $PromiseConstructor$ O O O O $void$ O $number$ O $void$ O $number$ O O O O O O O $Promise<void>$ O $Iterable$ O $PromiseConstructor$ O O O O O O O $Error$ O $ErrorConstructor$ O O O O O O O O $Promise<any>$ O $Iterable<Promise<any>>$ O O O O O $Promise<any>$ O O O O $any$ O O $Error$ O $Error$ O $any$ O O O O O $Error$ O O O O $Error$ O O
import EthjsHttpProvider = require ( 's' ) ; import EthjsQuery = require ( 's' ) ; import BN = require ( 's' ) ; import { TransactionReceipt } from 's' ; import { NetworkConfiguration } from 's' ; import { sleep } from 's' ; export class Connector { public readonly ethjsQuery : EthjsQuery ; public readonly gasPrice : BN ; constructor ( configuration ) { const ethjsHttpProvider = new EthjsHttpProvider ( configuration . http ) ; this . ethjsQuery = new EthjsQuery ( ethjsHttpProvider ) ; this . gasPrice = configuration . gasPrice ; } public async waitUntilConnected ( ) < EthjsQuery > { while ( true ) { try { await this . ethjsQuery . net_version ( ) ; break ; } catch { } } return this . ethjsQuery ; } waitForTransactionReceipt = async ( transactionHash , failureDetails ) : Promise < TransactionReceipt > => { let pollingInterval = 0 ; let receipt = await this . ethjsQuery . getTransactionReceipt ( transactionHash ) ; while ( ! receipt || ! receipt . blockHash ) { await sleep ( pollingInterval ) ; receipt = await this . ethjsQuery . getTransactionReceipt ( transactionHash ) ; pollingInterval = Math . min ( pollingInterval * 0 , 0 ) ; } const status = ( typeof receipt . status === 's' ) ? receipt . status : parseInt ( receipt . status , 0 ) ; if ( ! status ) { throw new Error ( `template` ) ; } return receipt ; } }	O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O O $any$ O O O $EthjsQuery$ O $any$ O O O $BN$ O $any$ O O O $NetworkConfiguration$ O O O $HttpProvider$ O O $any$ O $NetworkConfiguration$ O $string$ O O O O $EthjsQuery$ O O $any$ O $HttpProvider$ O O O O $BN$ O $NetworkConfiguration$ O $BN$ O O O O $Promise$ O O O $any$ O O O O O O O O O O O O $EthjsQuery$ O $Promise<string>$ O O O O O O O O O O O O O $EthjsQuery$ O O $Promise<TransactionReceipt>$ O O O $string$ O $string$ O O $PromiseConstructor$ O $any$ O O O O $number$ O O O O $TransactionReceipt$ O O O O $EthjsQuery$ O $Promise<TransactionReceipt>$ O $string$ O O O O O $TransactionReceipt$ O O $TransactionReceipt$ O $string$ O O O $Promise<void>$ O $number$ O O $TransactionReceipt$ O O O O $EthjsQuery$ O $Promise<TransactionReceipt>$ O $string$ O O $number$ O $Math$ O $number$ O $number$ O O O O O O O O $number$ O O O $TransactionReceipt$ O $complex$ O O O O $TransactionReceipt$ O $number$ O $number$ O $TransactionReceipt$ O $string$ O O O O O O O $number$ O O O O $ErrorConstructor$ O O O O O O $TransactionReceipt$ O O O
import BN = require ( 's' ) ; import { Account , generate , privateToAccount } from 's' ; import { Transaction } from 's' ; import { sign } from 's' ; import { Connector } from 's' ; export class AccountManager { private readonly connector : Connector ; private readonly accounts = new Map < string , Account > ( ) ; public readonly nonces = new Map < string , BN > ( ) ; public readonly defaultAddress : string ; constructor ( connector , privateKey ? ) { this . connector = connector ; const account = generate ( 's' ) ; this . accounts . set ( account . address , account ) ; this . defaultAddress = account . address ; if ( typeof privateKey !== 's' ) { this . defaultAddress = this . addAccount ( privateKey ) ; } } public addAccount ( privateKey ) { const account = privateToAccount ( privateKey ) ; this . accounts . set ( account . address , account ) ; return account . address ; } public async getNonce ( address ) < BN > { if ( ! this . accounts . has ( address ) ) throw new Error ( `template` ) ; if ( this . nonces . has ( address ) ) { const nonce = this . nonces . get ( address ) ! . add ( new BN ( 0 ) ) ; this . nonces . set ( address , nonce ) ; return nonce ; } else { let nonce = await this . connector . ethjsQuery . getTransactionCount ( address ) ; if ( this . nonces . has ( address ) ) { nonce = this . nonces . get ( address ) ! . add ( new BN ( 0 ) ) ; } this . nonces . set ( address , nonce ) ; return nonce ; } } public async signTransaction ( transaction ) < string > { const sender = transaction . from || this . defaultAddress ; if ( typeof transaction . data === 's' ) throw new Error ( `template` ) ; if ( typeof transaction . gas === 's' ) throw new Error ( `template` ) ; if ( typeof transaction . gasPrice === 's' ) throw new Error ( `template` ) ; const nonce = await this . getNonce ( sender ) ; const transactionToSend = Object . assign ( { from : sender , data : transaction . data , gas : transaction . gas , gasPrice : transaction . gasPrice , nonce : nonce , } , transaction . to ? { to : transaction . to } : < { to : string } > { } , transaction . value ? { value : transaction . value } : < { value : BN } > { } , ) ; return sign ( transactionToSend , this . accounts . get ( sender ) ! . privateKey ) ; } }	O $any$ O O O O O O O O $any$ O $Account$ O $Account$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $any$ O O O O O O $any$ O O O $Connector$ O $any$ O O O $complex$ O O $MapConstructor$ O O O $any$ O O O O O O $complex$ O O $MapConstructor$ O O O $any$ O O O O O O $string$ O O O O O $Connector$ O $string$ $string$ O O O O $Connector$ O $Connector$ O O $Account$ O $Account$ O O O O O O $complex$ O $complex$ O $Account$ O $string$ O $Account$ O O O O $string$ O $Account$ O $string$ O O O O $string$ O O O O O O $string$ O O O $string$ O $string$ O O O O O $string$ O $string$ O O O $Account$ O $Account$ O $string$ O O O O $complex$ O $complex$ O $Account$ O $string$ O $Account$ O O O $Account$ O $string$ O O O O $Promise$ O $string$ O O $any$ O O O O O O O $complex$ O $boolean$ O $string$ O O O O $ErrorConstructor$ O O O O O O O O $complex$ O $boolean$ O $string$ O O O O $BN$ O O O $complex$ O $BN$ O $string$ O O O $BN$ O O $any$ O O O O O O O $complex$ O $complex$ O $string$ O $BN$ O O O $BN$ O O O O O $BN$ O O O O $Connector$ O $EthjsQuery$ O $Promise<BN>$ O $string$ O O O O O O $complex$ O $boolean$ O $string$ O O O $BN$ O O O $complex$ O $BN$ O $string$ O O O $BN$ O O $any$ O O O O O O O O $complex$ O $complex$ O $string$ O $BN$ O O O $BN$ O O O O O $Promise$ O $Transaction$ O O O O O O $string$ O $Transaction$ O $string$ O O O $string$ O O O O $Transaction$ O $string$ O O O O O $ErrorConstructor$ O O O O O O O $Transaction$ O $BN$ O O O O O $ErrorConstructor$ O O O O O O O $Transaction$ O $BN$ O O O O O $ErrorConstructor$ O O O O O $BN$ O O O O $Promise<BN>$ O $string$ O O O $complex$ O $ObjectConstructor$ O O O O $string$ O $string$ O $string$ O $Transaction$ O $string$ O $BN$ O $Transaction$ O $BN$ O $BN$ O $Transaction$ O $BN$ O $BN$ O $BN$ O O O $Transaction$ O $string$ O O $string$ O $Transaction$ O $string$ O O O O $string$ O O O O O O O $Transaction$ O $BN$ O O $BN$ O $Transaction$ O $BN$ O O O O $BN$ O $any$ O O O O O O O O $complex$ O $complex$ O O O $complex$ O $Account$ O $string$ O O O $string$ O O O O
import * as path from 's' ; export class CompilerConfiguration { public readonly contractSourceRoot : string ; public readonly outputRoot : string ; public readonly contractInterfacesOutputPath : string ; public readonly abiOutputPath : string public readonly contractOutputPath : string public constructor ( contractSourceRoot , outputRoot ) { this . contractSourceRoot = contractSourceRoot ; this . outputRoot = outputRoot ; this . contractInterfacesOutputPath = path . join ( contractSourceRoot , 's' , 's' ) ; this . abiOutputPath = path . join ( outputRoot , 's' ) ; this . contractOutputPath = path . join ( outputRoot , 's' ) ; } public static create ( ) { const contractSourceRoot = path . join ( __dirname , "s" ) ; const outputRoot = ( typeof process . env . OUTPUT_PATH === "s" ) ? path . join ( __dirname , "s" ) : path . normalize ( < string > process . env . OUTPUT_ROOT ) ; return new CompilerConfiguration ( contractSourceRoot , outputRoot ) ; } }	O O O $any$ O O O O O $any$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O $string$ O O O O O $string$ O $string$ O O O O $string$ O $string$ O O O $string$ O $string$ O O O $string$ O $any$ O $any$ O $string$ O O O O O O O O $string$ O $any$ O $any$ O $string$ O O O O O O $string$ O $any$ O $any$ O $string$ O O O O O O O $CompilerConfiguration$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O
import * as fs from "s" ; import * as path from "s" ; import * as recursiveReadDir from "s" ; import asyncMkdirp = require ( 's' ) ; import { CompilerInput , CompilerOutput } from "s" ; import { Abi } from "s" ; import { ChildProcess , exec , spawn } from "s" ; import { format } from "s" ; import { CompilerConfiguration } from 's' ; interface AbiOutput { [ contract ] : Abi ; } export class ContractCompiler { private readonly configuration : CompilerConfiguration ; private readonly flattenerBin = "s" ; private readonly flattenerCommand : string ; public constructor ( configuration ) { this . configuration = configuration ; this . flattenerCommand = `template` ; } private async getCommandOutputFromInput ( childProcess , stdin ) < string > { return new Promise < string > ( ( resolve , reject ) => { const buffers < Buffer > = [ ] ; childProcess . stdout . on ( 's' , function ( data ) { buffers . push ( data ) ; } ) ; const errorBuffers < Buffer > = [ ] ; childProcess . stderr . on ( 's' , function ( data ) { errorBuffers . push ( data ) ; } ) ; childProcess . on ( 's' , function ( code ) { const errorMessage = Buffer . concat ( errorBuffers ) . toString ( ) ; if ( code > 0 ) return reject ( new Error ( `template` ) ) return resolve ( Buffer . concat ( buffers ) . toString ( ) ) ; } ) ; childProcess . stdin . write ( stdin ) ; childProcess . stdin . end ( ) ; } ) } private async compileCustomWrapper ( compilerInputJson ) < CompilerOutput > { const childProcess = spawn ( "s" , [ "s" ] ) ; const compilerOutputJson = await this . getCommandOutputFromInput ( childProcess , JSON . stringify ( compilerInputJson ) ) ; return JSON . parse ( compilerOutputJson ) ; } public async compileContracts ( ) < CompilerOutput > { try { const stats = await fs . stat ( this . configuration . contractOutputPath ) ; const lastCompiledTimestamp = stats . mtime ; const ignoreCachedFile = function ( file , stats : fs . Stats ) : boolean { return ( stats . isFile ( ) && path . extname ( file ) !== "s" ) || ( stats . isFile ( ) && path . extname ( file ) === "s" && stats . mtime < lastCompiledTimestamp ) ; } const uncachedFiles = await recursiveReadDir ( this . configuration . contractSourceRoot , [ ignoreCachedFile ] ) ; if ( uncachedFiles . length === 0 ) { return JSON . parse ( await fs . readFile ( this . configuration . contractOutputPath , "s" ) ) ; } } catch { } console . log ( 's' ) ; const compilerInputJson = await this . generateCompilerInput ( ) ; const compilerOutput = await this . compileCustomWrapper ( compilerInputJson ) ; if ( compilerOutput . errors ) { let errors = "s" ; for ( let error of compilerOutput . errors ) { if ( error . message . includes ( "s" ) ) continue ; errors += error . formattedMessage + "s" ; } if ( errors . length > 0 ) { throw new Error ( "s" + errors ) ; } } await asyncMkdirp ( path . dirname ( this . configuration . contractOutputPath ) ) ; const filteredCompilerOutput = this . filterCompilerOutput ( compilerOutput ) ; await fs . writeFile ( this . configuration . contractOutputPath , JSON . stringify ( filteredCompilerOutput , null , 's' ) ) ; const abiOutput = this . generateAbiOutput ( filteredCompilerOutput ) ; await fs . writeFile ( this . configuration . abiOutputPath , JSON . stringify ( abiOutput , null , 's' ) ) ; return filteredCompilerOutput ; } public async generateFlattenedSolidity ( filePath ) < string > { const relativeFilePath = filePath . replace ( this . configuration . contractSourceRoot , "s" ) . replace ( "s" , "s" ) ; const childProcess = exec ( format ( this . flattenerCommand , relativeFilePath ) , { encoding : "s" , cwd : this . configuration . contractSourceRoot } ) ; return await this . getCommandOutputFromInput ( childProcess , "s" ) ; } public async generateCompilerInput ( ) < CompilerInput > { const ignoreFile = function ( file , stats : fs . Stats ) : boolean { return file . indexOf ( "s" ) > - 0 || ( stats . isFile ( ) && path . extname ( file ) !== "s" ) ; } const filePaths = await recursiveReadDir ( this . configuration . contractSourceRoot , [ ignoreFile ] ) ; const filesPromises = filePaths . map ( async filePath => ( await this . generateFlattenedSolidity ( filePath ) ) ) ; const files = await Promise . all ( filesPromises ) ; let inputJson = { language : "s" , settings : { optimizer : { enabled : true , runs : 0 } , outputSelection : { "s" : { "s" : [ "s" , "s" ] } } } , sources : { } } ; for ( var file in files ) { const filePath = filePaths [ file ] . replace ( this . configuration . contractSourceRoot , "s" ) . replace ( "s" , "s" ) ; inputJson . sources [ filePath ] = { content : files [ file ] } ; } return inputJson ; } private filterCompilerOutput ( compilerOutput ) { const result = { contracts : { } } ; for ( let relativeFilePath in compilerOutput . contracts ) { for ( let contractName in compilerOutput . contracts [ relativeFilePath ] ) { if ( relativeFilePath . startsWith ( 's' ) && contractName !== 's' && contractName !== 's' ) continue ; if ( ! ( relativeFilePath === `template` || relativeFilePath . endsWith ( `template` ) ) ) continue ; const abi = compilerOutput . contracts [ relativeFilePath ] [ contractName ] . abi ; if ( abi === undefined ) continue ; const bytecode = compilerOutput . contracts [ relativeFilePath ] [ contractName ] . evm . bytecode . object ; if ( bytecode === undefined ) continue ; if ( "s" . test ( contractName ) ) continue ; if ( bytecode . length === 0 ) throw new Error ( "s" + contractName + "s" ) ; result . contracts [ relativeFilePath ] = { [ contractName ] : { abi : abi , evm : { bytecode : { object : bytecode } } } } } } return result ; } private generateAbiOutput ( compilerOutput ) { const result = { } ; for ( let relativeFilePath in compilerOutput . contracts ) { for ( let contractName in compilerOutput . contracts [ relativeFilePath ] ) { result [ contractName ] = compilerOutput . contracts [ relativeFilePath ] [ contractName ] . abi ; } } return result ; } }	O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $Promise<void>$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O $any$ O O O O $any$ O O O $CompilerConfiguration$ O $any$ O O O O O O O O O $string$ O O O O O O $CompilerConfiguration$ O O O O $CompilerConfiguration$ O $CompilerConfiguration$ O O O $string$ O O O O O O $Promise$ O $ChildProcess$ O $string$ O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O $Array$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $Buffer$ O O $any[]$ O $number$ O $any$ O O O O O O $Array$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $Buffer$ O O $any[]$ O $number$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any[]$ O O $any$ O O O O O $any$ O O O O $void$ O O $ErrorConstructor$ O O O O O $void$ O $any$ O $any$ O $any[]$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O O O O O O O $Promise$ O $CompilerInput$ O O $any$ O O O $any$ O $any$ O O O O O O O O O $string$ O O O O $Promise<string>$ O $any$ O $JSON$ O $complex$ O $CompilerInput$ O O O O $JSON$ O $any$ O $string$ O O O O O $Promise$ O O O $any$ O O O O O $any$ O O $any$ O $any$ O O O $CompilerConfiguration$ O $string$ O O O $any$ O $any$ O $any$ O O $boolean$ O O O $string$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O $CompilerConfiguration$ O $string$ O O $boolean$ O O O O O $any$ O $any$ O O O O O $JSON$ O $any$ O O $any$ O $any$ O O O $CompilerConfiguration$ O $string$ O O O O O O O O O O $Console$ O $void$ O O O O O $CompilerInput$ O O O O $Promise<CompilerInput>$ O O O O $CompilerOutput$ O O O O $Promise<CompilerOutput>$ O $CompilerInput$ O O O O $CompilerOutput$ O $CompilerOutputError[]$ O O O $string$ O O O O O O $CompilerOutputError$ O $CompilerOutput$ O $CompilerOutputError[]$ O O O O $CompilerOutputError$ O $string$ O $boolean$ O O O O O O $string$ O $CompilerOutputError$ O $string$ O O O O O O $string$ O $number$ O O O O O O $ErrorConstructor$ O O O $string$ O O O O O $Promise<void>$ O $any$ O $any$ O O O $CompilerConfiguration$ O $string$ O O O O $CompilerOutput$ O O O $CompilerOutput$ O $CompilerOutput$ O O O $any$ O $any$ O O O $CompilerConfiguration$ O $string$ O $JSON$ O $complex$ O $CompilerOutput$ O O O O O O O O $AbiOutput$ O O O $AbiOutput$ O $CompilerOutput$ O O O $any$ O $any$ O O O $CompilerConfiguration$ O $string$ O $JSON$ O $complex$ O $AbiOutput$ O O O O O O O O $CompilerOutput$ O O O O $Promise$ O $string$ O O O O O O $string$ O $string$ O $complex$ O O O $CompilerConfiguration$ O $string$ O O O O $complex$ O O O O O O O $any$ O $any$ O $any$ O O O $string$ O $string$ O O O $string$ O O O $string$ O O O $CompilerConfiguration$ O $string$ O O O O O O O $Promise<string>$ O $any$ O O O O O O O $Promise$ O O O $any$ O O O $boolean$ O O O $string$ O $any$ O $any$ O $any$ O O O O O $string$ O $number$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O O O O O $any$ O O $any$ O O O $CompilerConfiguration$ O $string$ O O $boolean$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $Promise<string>$ O $any$ O O O O O $complex$ O O $PromiseConstructor$ O O O $any$ O O O $CompilerInput$ O O O O O O $complex$ O O $complex$ O O $boolean$ O O O $number$ O O O O $complex$ O O O O O O O O O O O O O O O O ${}$ O O O O O O O O $string$ O $complex$ O O O $any$ O $any$ O $string$ O O $any$ O O O $CompilerConfiguration$ O $string$ O O O O $any$ O O O O O O $CompilerInput$ O $complex$ O $any$ O O O $unknown$ O $complex$ O $string$ O O O O O $CompilerInput$ O O O $CompilerOutput$ O $CompilerOutput$ O O O $CompilerOutput$ O O ${}$ O O O O O O O O $string$ O $CompilerOutput$ O $CompilerOutputContracts$ O O O O O $string$ O $CompilerOutput$ O $CompilerOutputContracts$ O $string$ O O O O O $string$ O $boolean$ O O O O $string$ O O O $string$ O O O O O O O O O $string$ O O O $string$ O $boolean$ O O O O O O O O $any$ O $CompilerOutput$ O $CompilerOutputContracts$ O $string$ O O $string$ O O $any$ O O O $any$ O $undefined$ O O O O $string$ O $CompilerOutput$ O $CompilerOutputContracts$ O $string$ O O $string$ O O $complex$ O $CompilerOutputEvmBytecode$ O $string$ O O O $string$ O $undefined$ O O O O O O O $boolean$ O $string$ O O O O O O $string$ O $number$ O O O O O $ErrorConstructor$ O O O $string$ O O O O $CompilerOutput$ O $CompilerOutputContracts$ O $string$ O O O O $string$ O O O $any$ O $any$ O $complex$ O O $complex$ O O $string$ O $string$ O O O O O O O $CompilerOutput$ O O O $AbiOutput$ O $CompilerOutput$ O O O $AbiOutput$ O O O O O O O $string$ O $CompilerOutput$ O $CompilerOutputContracts$ O O O O O $string$ O $CompilerOutput$ O $CompilerOutputContracts$ O $string$ O O O $AbiOutput$ O $string$ O O $CompilerOutput$ O $CompilerOutputContracts$ O $string$ O O $string$ O O $any$ O O O O $AbiOutput$ O O O
import * as path from 's' ; const ARTIFACT_OUTPUT_ROOT = ( typeof process . env . ARTIFACT_OUTPUT_ROOT === 's' ) ? path . join ( __dirname , 's' ) : path . normalize ( < string > process . env . ARTIFACT_OUTPUT_ROOT ) ; const PRODUCTION_LEGACY_REP_CONTRACT_ADDRESS = "s" ; export class DeployerConfiguration { public readonly contractInputPath : string ; public readonly contractAddressesOutputPath : string ; public readonly uploadBlockNumbersOutputPath : string ; public readonly controllerAddress : string | undefined ; public readonly createGenesisUniverse : boolean ; public readonly useNormalTime : boolean ; public readonly isProduction : boolean ; public readonly legacyRepAddress : string ; public constructor ( contractInputRoot , artifactOutputRoot , controllerAddress : string | undefined , createGenesisUniverse = true , isProduction = false , useNormalTime = true , legacyRepAddress = PRODUCTION_LEGACY_REP_CONTRACT_ADDRESS ) { this . isProduction = isProduction ; this . controllerAddress = controllerAddress ; this . createGenesisUniverse = createGenesisUniverse ; this . useNormalTime = isProduction || useNormalTime ; this . legacyRepAddress = legacyRepAddress ; this . contractAddressesOutputPath = path . join ( artifactOutputRoot , 's' ) ; this . uploadBlockNumbersOutputPath = path . join ( artifactOutputRoot , 's' ) ; this . contractInputPath = path . join ( contractInputRoot , 's' ) ; } public static create ( artifactOutputRoot = ARTIFACT_OUTPUT_ROOT , isProduction = false , legacyRepAddress = PRODUCTION_LEGACY_REP_CONTRACT_ADDRESS ) { const contractInputRoot = ( typeof process . env . CONTRACT_INPUT_ROOT === 's' ) ? path . join ( __dirname , 's' ) : path . normalize ( < string > process . env . CONTRACT_INPUT_ROOT ) ; const controllerAddress = process . env . AUGUR_CONTROLLER_ADDRESS ; const createGenesisUniverse = ( typeof process . env . CREATE_GENESIS_UNIVERSE === 's' ) ? true : process . env . CREATE_GENESIS_UNIVERSE === 's' ; const useNormalTime = ( typeof process . env . USE_NORMAL_TIME === 's' ) ? process . env . USE_NORMAL_TIME === 's' : true ; isProduction = ( typeof process . env . IS_PRODUCTION === 's' ) ? process . env . IS_PRODUCTION === 's' : isProduction ; return new DeployerConfiguration ( contractInputRoot , artifactOutputRoot , controllerAddress , createGenesisUniverse , isProduction , useNormalTime , legacyRepAddress ) ; } public static createWithControlledTime ( legacyRepAddress = PRODUCTION_LEGACY_REP_CONTRACT_ADDRESS , isProduction = false , artifactOutputRoot = ARTIFACT_OUTPUT_ROOT ) { const contractInputRoot = ( typeof process . env . CONTRACT_INPUT_ROOT === 's' ) ? path . join ( __dirname , 's' ) : path . normalize ( < string > process . env . CONTRACT_INPUT_ROOT ) ; const controllerAddress = process . env . AUGUR_CONTROLLER_ADDRESS ; const createGenesisUniverse = ( typeof process . env . CREATE_GENESIS_UNIVERSE === 's' ) ? true : process . env . CREATE_GENESIS_UNIVERSE === 's' ; const useNormalTime = false ; isProduction = ( typeof process . env . IS_PRODUCTION === 's' ) ? process . env . IS_PRODUCTION === 's' : isProduction ; return new DeployerConfiguration ( contractInputRoot , artifactOutputRoot , controllerAddress , createGenesisUniverse , isProduction , useNormalTime , legacyRepAddress ) ; } }	O O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O $boolean$ O O O O O $boolean$ O O O O O $boolean$ O O O O O $string$ O O O O O O $string$ O $string$ O $string$ O O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O O O O $boolean$ O $boolean$ O O O $string$ O $string$ O O O $boolean$ O $boolean$ O O O $boolean$ O $boolean$ O $boolean$ O O O $string$ O $string$ O O O $string$ O $any$ O $any$ O $string$ O O O O O O $string$ O $any$ O $any$ O $string$ O O O O O O $string$ O $any$ O $any$ O $string$ O O O O O O O $DeployerConfiguration$ O $string$ O $any$ O $boolean$ O O O $string$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $boolean$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $boolean$ O O O $any$ O $any$ O $string$ O $any$ O $boolean$ O $boolean$ O $boolean$ O $string$ O O O O O $DeployerConfiguration$ O $string$ O O O $boolean$ O O O $string$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $false$ O O O $boolean$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $boolean$ O O O $any$ O $any$ O $string$ O $any$ O $boolean$ O $boolean$ O $false$ O $string$ O O O O
import BN = require ( 's' ) ; import { hash } from 's' ; import { exists , readFile , writeFile } from "s" ; import { exec } from 's' ; import { encodeParams } from 's' ; import { TransactionReceipt } from 's' ; import { 0 , resolveAll } from "s" ; import { CompilerOutput } from "s" ; import { Abi , AbiFunction } from 's' ; import { DeployerConfiguration } from 's' ; import { Connector } from 's' ; import { Augur , ContractFactory , Controller , Controlled , Universe , ReputationToken , LegacyReputationToken , TimeControlled } from 's' ; import { NetworkConfiguration } from 's' ; import { AccountManager } from 's' ; import { Contracts , Contract } from 's' ; export class ContractDeployer { private readonly accountManager : AccountManager ; private readonly configuration : DeployerConfiguration ; private readonly connector : Connector ; private readonly contracts : Contracts ; public controller : Controller ; public universe : Universe ; public static deployToNetwork = async ( networkConfiguration , deployerConfiguration ) => { const connector = new Connector ( networkConfiguration ) ; const accountManager = new AccountManager ( connector , networkConfiguration . privateKey ) ; const compilerOutput = JSON . parse ( await readFile ( deployerConfiguration . contractInputPath , "s" ) ) ; const contractDeployer = new ContractDeployer ( deployerConfiguration , connector , accountManager , compilerOutput ) ; console . log ( `template` ) ; await contractDeployer . deploy ( ) ; } public constructor ( configuration , connector , accountManager , compilerOutput ) { this . configuration = configuration ; this . connector = connector ; this . accountManager = accountManager ; this . contracts = new Contracts ( compilerOutput ) ; } public async getBlockNumber ( ) < number > { return this . connector . ethjsQuery . getBlockByNumber ( 's' , false ) . then ( ( block ) => block . number . toNumber ( ) ) ; } public async deploy ( ) < void > { const blockNumber = await this . getBlockNumber ( ) ; this . controller = await this . uploadController ( ) ; await this . uploadAugur ( ) ; await this . uploadAllContracts ( ) ; await this . uploadOrdersFinder ( ) ; if ( this . configuration . isProduction ) { console . log ( `template` ) ; await this . controller . registerContract ( 0 ( "s" ) , this . configuration . legacyRepAddress , 0 ( "s" ) , 0 ( "s" ) ) ; const contract = await this . contracts . get ( "s" ) ; contract . address = this . configuration . legacyRepAddress ; } await this . initializeAllContracts ( ) ; await this . whitelistTradingContracts ( ) ; if ( ! this . configuration . useNormalTime ) { await this . resetTimeControlled ( ) ; } if ( this . configuration . createGenesisUniverse ) { if ( ! this . configuration . isProduction ) { this . initializeLegacyRep ( ) ; } this . universe = await this . createGenesisUniverse ( ) ; if ( ! this . configuration . isProduction ) { this . migrateFromLegacyRep ( ) ; } } await this . generateUploadBlockNumberFile ( blockNumber ) ; await this . generateAddressMappingFile ( ) ; } public getContract = ( contractName ) : Controlled => { if ( ! this . contracts . has ( contractName ) ) throw new Error ( `template` ) ; const contract = this . contracts . get ( contractName ) ; if ( contract . address === undefined ) throw new Error ( `template` ) ; const controlled = ContractFactory ( this . connector , this . accountManager , contract . address , this . connector . gasPrice ) ; return controlled ; } private static async getGitCommit ( ) < string > { return await new Promise < string > ( ( resolve , reject ) => { exec ( "s" , ( error , stdout , stderr ) => { if ( error ) { console . log ( stderr ) ; return reject ( error ) ; } resolve ( `template` ) ; } ) ; } ) ; } private static async getBytecodeSha ( bytecode ) < string > { const digest = await hash ( 's' ) ( bytecode ) ; return `template` ; } private static getEncodedConstructData ( abi , bytecode , constructorArgs < string > ) { if ( constructorArgs . length === 0 ) { return bytecode ; } const constructorSignature = < AbiFunction | undefined > abi . find ( signature => signature . type === 's' ) ; if ( typeof constructorSignature === 's' ) throw new Error ( `template` ) ; const constructorInputTypes = constructorSignature . inputs . map ( x => x . type ) ; const encodedConstructorParameters = Buffer . from ( encodeParams ( constructorInputTypes , constructorArgs ) . substring ( 0 ) , 's' ) ; return Buffer . concat ( [ bytecode , encodedConstructorParameters ] ) ; } private async uploadController ( ) < Controller > { console . log ( 's' ) ; const address = ( this . configuration . controllerAddress !== undefined ) ? this . configuration . controllerAddress : await this . construct ( this . contracts . get ( 's' ) , [ ] , `template` ) ; const controller = new Controller ( this . connector , this . accountManager , address , this . connector . gasPrice ) ; const ownerAddress = await controller . owner_ ( ) ; if ( ownerAddress . toLowerCase ( ) !== this . accountManager . defaultAddress . toLowerCase ( ) ) { throw new Error ( "s" ) ; } console . log ( `template` ) ; return controller ; } public async uploadLegacyRep ( ) < string > { const contract = await this . contracts . get ( "s" ) ; contract . address = await this . construct ( contract , [ ] , `template` ) ; return contract . address ; } private async uploadAugur ( ) < void > { const contract = await this . contracts . get ( "s" ) ; const address = await this . construct ( contract , [ ] , `template` ) ; const commitHash = await ContractDeployer . getGitCommit ( ) ; const bytecodeHash = await ContractDeployer . getBytecodeSha ( contract . bytecode ) ; const augur = new Augur ( this . connector , this . accountManager , address , this . connector . gasPrice ) ; contract . address = address ; await augur . setController ( this . controller . address ) ; await this . controller . registerContract ( 0 ( "s" ) , address , commitHash , bytecodeHash ) ; } private async uploadOrdersFinder ( ) < void > { const contract = await this . contracts . get ( "s" ) ; const ordersAddress = this . contracts . get ( "s" ) . address ; if ( ordersAddress === undefined ) throw new Error ( "s" ) ; const address = await this . construct ( contract , [ ordersAddress ] , `template` ) ; contract . address = address ; } private async uploadAllContracts ( ) < void > { console . log ( 's' ) ; const promises < Promise < any > > = [ ] ; for ( let contract of this . contracts ) { promises . push ( this . upload ( contract ) ) ; } await resolveAll ( promises ) ; } private async upload ( contract ) < void > { const contractsToDelegate : { [ key ] : boolean } = { "s" : true , "s" : true , "s" : true } ; const contractName = contract . contractName if ( contractName === 's' ) return ; if ( contractName === 's' ) return ; if ( contractName === 's' ) return ; if ( contractName === 's' ) return ; if ( contractName === 's' ) return ; if ( contractName === 's' ) contract = this . configuration . useNormalTime ? contract : this . contracts . get ( 's' ) ; if ( contractName === 's' ) contract = this . configuration . isProduction ? contract : this . contracts . get ( 's' ) ; if ( contract . relativeFilePath . startsWith ( 's' ) ) return ; if ( this . configuration . isProduction && contractName === 's' ) return ; if ( contractName !== 's' && contract . relativeFilePath . startsWith ( 's' ) ) return ; if ( typeof this . configuration . controllerAddress !== "s" && await this . shouldSkipUploadingContract ( contract , contractsToDelegate [ contractName ] ) ) { console . log ( `template` ) ; contract . address = await this . getExistingContractAddress ( contractName ) ; } else { console . log ( `template` ) ; contract . address = contractsToDelegate [ contractName ] ? await this . uploadAndAddDelegatedToController ( contract ) : await this . uploadAndAddToController ( contract , contractName ) ; } } private async shouldSkipUploadingContract ( contract , isDelegated ) < boolean > { const bytecodeHash = await ContractDeployer . getBytecodeSha ( contract . bytecode ) ; const key = 0 ( isDelegated ? `template` : contract . contractName ) ; const contractDetails = await this . controller . getContractDetails_ ( key ) ; const previouslyUploadedBytecodeHash = contractDetails [ 0 ] ; return bytecodeHash === previouslyUploadedBytecodeHash ; } private async getExistingContractAddress ( contractName ) < string > { const key = 0 ( contractName ) ; const contractDetails = await this . controller . getContractDetails_ ( key ) ; return contractDetails [ 0 ] ; } private async uploadAndAddDelegatedToController ( contract ) < string > { const delegationTargetName = `template` ; const delegatorConstructorArgs = [ this . controller . address , 0 ( delegationTargetName ) ] ; await this . uploadAndAddToController ( contract , delegationTargetName ) ; return await this . uploadAndAddToController ( this . contracts . get ( 's' ) , contract . contractName , delegatorConstructorArgs ) ; } private async uploadAndAddToController ( contract , registrationContractName = contract . contractName , constructorArgs < any > = [ ] ) < string > { const address = await this . construct ( contract , constructorArgs , `template` ) ; const commitHash = await ContractDeployer . getGitCommit ( ) ; const bytecodeHash = await ContractDeployer . getBytecodeSha ( contract . bytecode ) ; await this . controller . registerContract ( 0 ( registrationContractName ) , address , commitHash , bytecodeHash ) ; return address ; } private async construct ( contract , constructorArgs < string > , failureDetails ) < string > { const data = `template` ; const gasEstimate = await this . connector . ethjsQuery . estimateGas ( { from : this . accountManager . defaultAddress , data : data } ) ; const nonce = await this . accountManager . nonces . get ( this . accountManager . defaultAddress ) ; const signedTransaction = await this . accountManager . signTransaction ( { gas : gasEstimate , gasPrice : this . connector . gasPrice , data : data } ) ; console . log ( `template` ) ; const transactionHash = await this . connector . ethjsQuery . sendRawTransaction ( signedTransaction ) ; const receipt = await this . connector . waitForTransactionReceipt ( transactionHash , failureDetails ) ; console . log ( `template` ) ; return receipt . contractAddress ; } private async whitelistTradingContracts ( ) < void > { console . log ( 's' ) ; const promises < Promise < any > > = [ ] ; for ( let contract of this . contracts ) { if ( ! contract . relativeFilePath . startsWith ( "s" ) ) continue ; if ( contract . contractName === 's' ) continue ; if ( contract . address === undefined ) throw new Error ( `template` ) ; if ( await this . controller . whitelist_ ( contract . address ) ) { console . log ( `template` ) ; continue ; } else { console . log ( `template` ) ; promises . push ( this . whitelistContract ( contract . address ) ) ; } } await resolveAll ( promises ) ; } private async whitelistContract ( contractAddress ) < void > { return await this . controller . addToWhitelist ( contractAddress , { sender : this . accountManager . defaultAddress } ) ; } private async initializeAllContracts ( ) < void > { console . log ( 's' ) ; const contractsToInitialize = [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ; const promises < Promise < any > > = [ ] ; for ( let contractName of contractsToInitialize ) { promises . push ( this . initializeContract ( contractName ) ) ; } resolveAll ( promises ) ; } private async initializeContract ( contractName ) < TransactionReceipt | void > { if ( contractName === 's' ) contractName = this . configuration . useNormalTime ? contractName : "s" ; if ( await this . getContract ( contractName ) . getController_ ( ) === this . controller . address ) { console . log ( `template` ) return ; } console . log ( `template` ) ; await this . getContract ( contractName ) . setController ( this . controller . address ) ; } public async initializeLegacyRep ( ) < void > { const legacyReputationToken = new LegacyReputationToken ( this . connector , this . accountManager , this . getContract ( 's' ) . address , this . connector . gasPrice ) ; await legacyReputationToken . faucet ( new BN ( 0 ) . pow ( new BN ( 0 ) ) . mul ( new BN ( 0 ) ) ) ; const legacyBalance = await legacyReputationToken . balanceOf_ ( this . accountManager . defaultAddress ) ; if ( ! legacyBalance || legacyBalance == new BN ( 0 ) ) { throw new Error ( "s" ) ; } } private async resetTimeControlled ( ) < void > { console . log ( 's' ) ; const time = new TimeControlled ( this . connector , this . accountManager , this . getContract ( "s" ) . address , this . connector . gasPrice ) ; const currentTimestamp = await time . getTimestamp_ ( ) ; return time . setTimestamp ( currentTimestamp ) ; } private async createGenesisUniverse ( ) < Universe > { console . log ( 's' ) ; const augur = new Augur ( this . connector , this . accountManager , this . getContract ( "s" ) . address , this . connector . gasPrice ) ; const universeAddress = await augur . createGenesisUniverse_ ( ) ; if ( ! universeAddress || universeAddress == "s" ) { throw new Error ( "s" ) ; } await augur . createGenesisUniverse ( ) ; const universe = new Universe ( this . connector , this . accountManager , universeAddress , this . connector . gasPrice ) ; console . log ( `template` ) ; if ( await universe . getTypeName_ ( ) !== 0 ( "s" ) ) { throw new Error ( "s" ) ; } return universe ; } private async migrateFromLegacyRep ( ) < void > { const reputationTokenAddress = await this . universe . getReputationToken_ ( ) ; const reputationToken = new ReputationToken ( this . connector , this . accountManager , reputationTokenAddress , this . connector . gasPrice ) ; await reputationToken . migrateBalancesFromLegacyRep ( [ this . accountManager . defaultAddress ] ) ; const balance = await reputationToken . balanceOf_ ( this . accountManager . defaultAddress ) ; if ( ! balance || balance == new BN ( 0 ) ) { throw new Error ( "s" ) ; } const migrationOngoing = await reputationToken . getIsMigratingFromLegacy_ ( ) ; if ( migrationOngoing ) { throw new Error ( "s" ) ; } } private async generateAddressMapping ( ) < string > { type ContractAddressMapping = { [ name ] : string } ; type NetworkAddressMapping = { [ networkId ] : ContractAddressMapping } ; const mapping = { } ; mapping [ 's' ] = this . controller . address ; if ( this . universe ) mapping [ 's' ] = this . universe . address ; if ( this . contracts . get ( 's' ) . address === undefined ) throw new Error ( `template` ) ; mapping [ 's' ] = this . contracts . get ( 's' ) . address ! ; mapping [ 's' ] = this . contracts . get ( 's' ) . address ! ; mapping [ 's' ] = this . contracts . get ( 's' ) . address ! ; for ( let contract of this . contracts ) { if ( ! contract . relativeFilePath . startsWith ( 's' ) ) continue ; if ( "s" . test ( contract . contractName ) ) continue ; if ( contract . address === undefined ) throw new Error ( `template` ) ; mapping [ contract . contractName ] = contract . address ; } const networkId = await this . connector . ethjsQuery . net_version ( ) ; let addressMapping = { } ; if ( await exists ( this . configuration . contractAddressesOutputPath ) ) { let existingAddressFileData = await readFile ( this . configuration . contractAddressesOutputPath , 's' ) ; addressMapping = JSON . parse ( existingAddressFileData ) ; } addressMapping [ networkId ] = mapping ; return JSON . stringify ( addressMapping , null , 's' ) ; } private async generateAddressMappingFile ( ) < void > { const addressMappingJson = await this . generateAddressMapping ( ) ; await writeFile ( this . configuration . contractAddressesOutputPath , addressMappingJson , 's' ) } private async generateUploadBlockNumberMapping ( blockNumber ) < string > { type UploadBlockNumberMapping = { [ networkId ] : number } ; const networkId = await this . connector . ethjsQuery . net_version ( ) ; let blockNumberMapping = { } ; if ( await exists ( this . configuration . uploadBlockNumbersOutputPath ) ) { let existingBlockNumberData = await readFile ( this . configuration . uploadBlockNumbersOutputPath , 's' ) ; blockNumberMapping = JSON . parse ( existingBlockNumberData ) ; } blockNumberMapping [ networkId ] = blockNumber ; return JSON . stringify ( blockNumberMapping , null , 's' ) ; } private async generateUploadBlockNumberFile ( blockNumber ) < void > { const blockNumberMapping = await this . generateUploadBlockNumberMapping ( blockNumber ) ; await writeFile ( this . configuration . uploadBlockNumbersOutputPath , blockNumberMapping , 's' ) } }	O $any$ O O O O O O O O $Applicator$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $string$ O $Promise<void>$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $Controlled$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O $AccountManager$ O $any$ O O O $DeployerConfiguration$ O $any$ O O O $Connector$ O $any$ O O O $Contracts$ O $any$ O O $Controller$ O $any$ O O $Universe$ O $any$ O O O $Promise<void>$ O O O $NetworkConfiguration$ O $DeployerConfiguration$ O O O O $Connector$ O O $any$ O $NetworkConfiguration$ O O O $AccountManager$ O O $any$ O $Connector$ O $NetworkConfiguration$ O $string$ O O O $any$ O $JSON$ O $any$ O O $any$ O $DeployerConfiguration$ O $string$ O O O O O O $ContractDeployer$ O O $any$ O $DeployerConfiguration$ O $Connector$ O $AccountManager$ O $any$ O O $Console$ O $void$ O O O O O $ContractDeployer$ O $Promise<void>$ O O O O O O O $DeployerConfiguration$ O $Connector$ O $AccountManager$ O $CompilerOutput$ O O O O $DeployerConfiguration$ O $DeployerConfiguration$ O O O $Connector$ O $Connector$ O O O $AccountManager$ O $AccountManager$ O O O $Contracts$ O O $any$ O $CompilerOutput$ O O O O O $Promise$ O O O O O O O O O $Connector$ O $EthjsQuery$ O $Promise<Block>$ O O O O O O O O O $Block$ O O $Block$ O $BN$ O $number$ O O O O O O O $Promise$ O O O O O O O $number$ O O O O $Promise<number>$ O O O O O $Controller$ O O O O $Promise<Controller>$ O O O O O O $Promise<void>$ O O O O O O $Promise<void>$ O O O O O O $Promise<void>$ O O O O O O O $DeployerConfiguration$ O $boolean$ O O $Console$ O $void$ O O O O O O O $Controller$ O $Promise<void>$ O $string$ O O O O O O $DeployerConfiguration$ O $string$ O $string$ O O O O $string$ O O O O O O $Contract$ O O O O $Contracts$ O $Contract$ O O O O $Contract$ O $string$ O O O $DeployerConfiguration$ O $string$ O O O O O $Promise<void>$ O O O O O O $Promise<void>$ O O O O O O O O $DeployerConfiguration$ O $boolean$ O O O O O $Promise<void>$ O O O O O O O O $DeployerConfiguration$ O $boolean$ O O O O O O O $DeployerConfiguration$ O $boolean$ O O O O $Promise<void>$ O O O O O O $Universe$ O O O O $Promise<Universe>$ O O O O O O O O $DeployerConfiguration$ O $boolean$ O O O O $Promise<void>$ O O O O O O O O $Promise<void>$ O $number$ O O O O O $Promise<void>$ O O O O O $Controlled$ O O $string$ O O $any$ O O O O O O O $Contracts$ O $boolean$ O $string$ O O O O $ErrorConstructor$ O O O O O $Contract$ O O O $Contracts$ O $Contract$ O $string$ O O O O $Contract$ O $string$ O $undefined$ O O O $ErrorConstructor$ O O O O O $Controlled$ O $Controlled$ O O O $Connector$ O O O $AccountManager$ O $Contract$ O $string$ O O O $Connector$ O $BN$ O O O $Controlled$ O O O O O $Promise$ O O O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $Console$ O $void$ O $any$ O O O $void$ O $any$ O O O $void$ O O O O O O O O O O O O O O $Promise$ O $Buffer$ O O O O O O $Encoded$ O O $Applicator$ O O O O $any$ O O O O O O O O $Buffer$ O $Abi$ O $Buffer$ O $Array$ O O O O O O O $string[]$ O $number$ O O O O O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $ErrorConstructor$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O $any$ O $string[]$ O O $string$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $Promise$ O O O $any$ O O $Console$ O $void$ O O O O O $string$ O O O O $DeployerConfiguration$ O $string$ O $undefined$ O O O O $DeployerConfiguration$ O $string$ O O O O $Promise<string>$ O O O $Contracts$ O $Contract$ O O O O O O O O O O O $Controller$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O O O $Connector$ O $BN$ O O O $string$ O O $Controller$ O $Promise<string>$ O O O O O $string$ O $string$ O O O O O $AccountManager$ O $string$ O $string$ O O O O O O $ErrorConstructor$ O O O O O $Console$ O $void$ O O O O O $Controller$ O O O O $Promise$ O O O O O O O $Contract$ O O O O $Contracts$ O $Contract$ O O O O $Contract$ O $string$ O O O O $Promise<string>$ O $Contract$ O O O O O O O O $Contract$ O $string$ O O O O $Promise$ O O O O O O O $Contract$ O O O O $Contracts$ O $Contract$ O O O O O $string$ O O O O $Promise<string>$ O $Contract$ O O O O O O O O $string$ O O $any$ O $Promise<string>$ O O O O $string$ O O $any$ O $Promise<string>$ O $Contract$ O $any$ O O O $Augur$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O O O $Connector$ O $BN$ O O $Contract$ O $string$ O $string$ O O $Augur$ O $Promise<void>$ O O O $Controller$ O $string$ O O O O O $Controller$ O $Promise<void>$ O $string$ O O O O $string$ O $string$ O $string$ O O O O O $Promise$ O O O O O O O $Contract$ O O O O $Contracts$ O $Contract$ O O O O O $string$ O O O $Contracts$ O $Contract$ O O O O $string$ O O O $string$ O $undefined$ O O O $ErrorConstructor$ O O O O O $string$ O O O O $Promise<string>$ O $Contract$ O O $string$ O O O O O $Contract$ O $string$ O $string$ O O O O $Promise$ O O O O O O $Console$ O $void$ O O O O O $Array$ O $PromiseConstructor$ O O O O O O O O O O O $Contract$ O O O $Contracts$ O O $Promise<any>[]$ O $number$ O O O $Promise<void>$ O $Contract$ O O O O O $Promise<void>$ O $Promise<any>[]$ O O O O O $Promise$ O $Contract$ O O O O O O $complex$ O O O $string$ O O O O O O O O O O O O O O O O O O O O $string$ O $Contract$ O $string$ O O $string$ O O O O O O O $string$ O O O O O O O $string$ O O O O O O O $string$ O O O O O O O $string$ O O O O O O O $string$ O O O $Contract$ O O O $DeployerConfiguration$ O $boolean$ O $Contract$ O O O $Contracts$ O $Contract$ O O O O O O $string$ O O O $Contract$ O O O $DeployerConfiguration$ O $boolean$ O $Contract$ O O O $Contracts$ O $Contract$ O O O O O O $Contract$ O $string$ O $boolean$ O O O O O O O O O O $DeployerConfiguration$ O $boolean$ O $string$ O O O O O O O $string$ O O O $Contract$ O $string$ O $boolean$ O O O O O O O O O O O $DeployerConfiguration$ O $string$ O O O O O O $Promise<boolean>$ O $Contract$ O $complex$ O $string$ O O O O $Console$ O $void$ O O O O $Contract$ O $string$ O O O O $Promise<string>$ O $string$ O O O O O $Console$ O $void$ O O O O $Contract$ O $string$ O $complex$ O $string$ O O O O O $Promise<string>$ O $Contract$ O O O O O $Promise<string>$ O $Contract$ O $string$ O O O O O O $Promise$ O $Contract$ O $boolean$ O O O O O O $string$ O O $any$ O $Promise<string>$ O $Contract$ O $any$ O O O $string$ O $string$ O $boolean$ O O O $Contract$ O $string$ O O O $string[]$ O O O O $Controller$ O $Promise<string[]>$ O $string$ O O O $string$ O $string[]$ O O O O O $string$ O $string$ O O O O $Promise$ O $string$ O O O O O O $string$ O $string$ O $string$ O O O $string[]$ O O O O $Controller$ O $Promise<string[]>$ O $string$ O O O $string[]$ O O O O O O O $Promise$ O $Contract$ O O O O O O $string$ O O O O $string[]$ O O O O $Controller$ O $string$ O $string$ O $string$ O O O O O O $Promise<string>$ O $Contract$ O $string$ O O O O O O $Promise<string>$ O O O $Contracts$ O $Contract$ O O O O $Contract$ O $string$ O $string[]$ O O O O O $Promise$ O $Contract$ O $string$ O $Contract$ O $string$ O $Array$ O O O O O O O O O O O O $string$ O O O O $Promise<string>$ O $Contract$ O $any[]$ O O O O O $string$ O O $any$ O $Promise<string>$ O O O O $string$ O O $any$ O $Promise<string>$ O $Contract$ O $any$ O O O O O $Controller$ O $Promise<void>$ O $string$ O $string$ O O $string$ O $string$ O $string$ O O O $string$ O O O O $Promise$ O $Contract$ O $Array$ O O O O $string$ O O O O O O $string$ O O O O $BN$ O O O O $Connector$ O $EthjsQuery$ O $Promise<BN>$ O O $string$ O O O $AccountManager$ O $string$ O $string$ O $string$ O O O O $BN$ O O O O $AccountManager$ O $complex$ O $BN$ O O O $AccountManager$ O $string$ O O O $string$ O O O O $AccountManager$ O $Promise<string>$ O O $BN$ O $BN$ O $BN$ O O O $Connector$ O $BN$ O $string$ O $string$ O O O $Console$ O $void$ O O O O O $string$ O O O O $Connector$ O $EthjsQuery$ O $Promise<string>$ O $string$ O O O $TransactionReceipt$ O O O O $Connector$ O $Promise<TransactionReceipt>$ O $string$ O $string$ O O $Console$ O $void$ O O O O O $TransactionReceipt$ O $string$ O O O O $Promise$ O O O O O O $Console$ O $void$ O O O O O $Array$ O $PromiseConstructor$ O O O O O O O O O O O $Contract$ O O O $Contracts$ O O O O O $Contract$ O $string$ O $boolean$ O O O O O O O O $Contract$ O $string$ O O O O O O O $Contract$ O $string$ O $undefined$ O O O $ErrorConstructor$ O O O O O O O O O $Controller$ O O O $Contract$ O $string$ O O O $Console$ O $void$ O O O O O O O O O $Console$ O $void$ O O O O $Promise<any>[]$ O $number$ O O O $Promise<void>$ O $Contract$ O $string$ O O O O O O $Promise<void>$ O $Promise<any>[]$ O O O O O $Promise$ O $string$ O O O O O O O O O $Controller$ O $Promise<void>$ O $string$ O O $string$ O O O $AccountManager$ O $string$ O O O O O O $Promise$ O O O O O O $Console$ O $void$ O O O O O $string[]$ O O O O O O O O O O O O O O O O O O O O $Array$ O $PromiseConstructor$ O O O O O O O O O O O $string$ O $string[]$ O O $Promise<any>[]$ O $number$ O O O $complex$ O $string$ O O O O $Promise<void>$ O $Promise<any>[]$ O O O O O $Promise$ O $string$ O O $any$ O O O O O O $string$ O O O $string$ O O O $DeployerConfiguration$ O $boolean$ O O O O O O O O O O $Controlled$ O $string$ O O $Promise<string>$ O O O O O $Controller$ O $string$ O O $Console$ O $void$ O O O O O O $Console$ O $void$ O O O O O O O $Controlled$ O $string$ O O $Promise<void>$ O O O $Controller$ O $string$ O O O O O $Promise$ O O O O O O O $LegacyReputationToken$ O O $any$ O O O $Connector$ O O O $AccountManager$ O O O $Controlled$ O O O O $string$ O O O $Connector$ O $BN$ O O O $LegacyReputationToken$ O $Promise<void>$ O O $any$ O O O O $BN$ O O $any$ O O O O O $BN$ O O $any$ O O O O O O O $BN$ O O $LegacyReputationToken$ O $Promise<BN>$ O O O $AccountManager$ O $string$ O O O O O $BN$ O $BN$ O O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O $Promise$ O O O O O O $Console$ O $void$ O O O O O $TimeControlled$ O O $any$ O O O $Connector$ O O O $AccountManager$ O O O $Controlled$ O O O O $string$ O O O $Connector$ O $BN$ O O O $BN$ O O $TimeControlled$ O $Promise<BN>$ O O O O $TimeControlled$ O $Promise<void>$ O $BN$ O O O O O $Promise$ O O O $any$ O O $Console$ O $void$ O O O O O $Augur$ O O $any$ O O O $Connector$ O O O $AccountManager$ O O O $Controlled$ O O O O $string$ O O O $Connector$ O $BN$ O O O $string$ O O $Augur$ O $Promise<string>$ O O O O O O $string$ O $string$ O O O O O O $ErrorConstructor$ O O O O O O $Augur$ O $Promise<void>$ O O O O $Universe$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O O O $Connector$ O $BN$ O O $Console$ O $void$ O O O O O O O $Universe$ O $Promise<string>$ O O O $string$ O O O O O O O $ErrorConstructor$ O O O O O O $Universe$ O O O O $Promise$ O O O O O O O $string$ O O O O $Universe$ O $Promise<string>$ O O O O $ReputationToken$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O O O $Connector$ O $BN$ O O O $ReputationToken$ O $Promise<void>$ O O O O $AccountManager$ O $string$ O O O O $BN$ O O $ReputationToken$ O $Promise<BN>$ O O O $AccountManager$ O $string$ O O O O O $BN$ O $BN$ O O $any$ O O O O O O O $ErrorConstructor$ O O O O O O $boolean$ O O $ReputationToken$ O $Promise<boolean>$ O O O O O $boolean$ O O O O $ErrorConstructor$ O O O O O O O O $Promise$ O O O O O O O $any$ O O O $string$ O O O O O O $any$ O O O $string$ O O $any$ O O O $ContractAddressMapping$ O O O O $ContractAddressMapping$ O O O O O O $Controller$ O $string$ O O O O O $Universe$ O $ContractAddressMapping$ O O O O O O $Universe$ O $string$ O O O O O $Contracts$ O $Contract$ O O O O $string$ O $undefined$ O O O $ErrorConstructor$ O O O O $ContractAddressMapping$ O O O O O O $Contracts$ O $Contract$ O O O O $string$ O O $ContractAddressMapping$ O O O O O O $Contracts$ O $Contract$ O O O O $string$ O O $ContractAddressMapping$ O O O O O O $Contracts$ O $Contract$ O O O O $string$ O O O O O $Contract$ O O O $Contracts$ O O O O O $Contract$ O $string$ O $boolean$ O O O O O O O O O O $boolean$ O $Contract$ O $string$ O O O O O O $Contract$ O $string$ O $undefined$ O O O $ErrorConstructor$ O O O O $ContractAddressMapping$ O $Contract$ O $string$ O O $Contract$ O $string$ O O O $string$ O O O O $Connector$ O $EthjsQuery$ O $Promise<string>$ O O O O $NetworkAddressMapping$ O O O O O O O $any$ O O O $DeployerConfiguration$ O $string$ O O O O $string$ O O $any$ O O O $DeployerConfiguration$ O $string$ O O O O $NetworkAddressMapping$ O $JSON$ O $any$ O $string$ O O O $NetworkAddressMapping$ O $string$ O O $ContractAddressMapping$ O O $JSON$ O $complex$ O $NetworkAddressMapping$ O O O O O O O O O $Promise$ O O O O O O O $string$ O O O O $Promise<string>$ O O O O $any$ O O O $DeployerConfiguration$ O $string$ O $string$ O O O O O O $Promise$ O $number$ O O O O O O $any$ O O O $string$ O O O O O O $string$ O O O O $Connector$ O $EthjsQuery$ O $Promise<string>$ O O O O $UploadBlockNumberMapping$ O O O O O O O $any$ O O O $DeployerConfiguration$ O $string$ O O O O $string$ O O $any$ O O O $DeployerConfiguration$ O $string$ O O O O $UploadBlockNumberMapping$ O $JSON$ O $any$ O $string$ O O O $UploadBlockNumberMapping$ O $string$ O O $number$ O O $JSON$ O $complex$ O $UploadBlockNumberMapping$ O O O O O O O O O $Promise$ O $number$ O O O O O O $string$ O O O O $Promise<string>$ O $number$ O O O $any$ O O O $DeployerConfiguration$ O $string$ O $string$ O O O O O
import { AccountManager } from 's' ; import { CompilerConfiguration } from 's' ; import { ContractCompiler } from 's' ; import { ContractDeployer } from 's' ; import { Connector } from 's' ; import { DeployerConfiguration } from 's' ; import { NetworkConfiguration } from 's' ; require ( 's' ) . install ( ) ; async function doWork ( ) < void > { const compilerConfiguration = CompilerConfiguration . create ( ) ; const contractCompiler = new ContractCompiler ( compilerConfiguration ) ; const compiledContracts = await contractCompiler . compileContracts ( ) ; const networkConfiguration = NetworkConfiguration . create ( ) ; const connector = new Connector ( networkConfiguration ) ; const accountManager = new AccountManager ( connector , networkConfiguration . privateKey ) ; const deployerConfiguration = DeployerConfiguration . create ( ) ; const contractDeployer = new ContractDeployer ( deployerConfiguration , connector , accountManager , compiledContracts ) ; await contractDeployer . deploy ( ) ; } doWork ( ) . then ( ( ) => { process . exit ( ) ; } ) . catch ( error => { console . log ( error ) ; process . exit ( ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $Promise$ O O O O O O O $CompilerConfiguration$ O $any$ O $CompilerConfiguration$ O O O O $ContractCompiler$ O O $any$ O $CompilerConfiguration$ O O O $CompilerOutput$ O O $ContractCompiler$ O $Promise<CompilerOutput>$ O O O O $NetworkConfiguration$ O $any$ O $NetworkConfiguration$ O O O O $Connector$ O O $any$ O $NetworkConfiguration$ O O O $AccountManager$ O O $any$ O $Connector$ O $NetworkConfiguration$ O $string$ O O O $DeployerConfiguration$ O $any$ O $DeployerConfiguration$ O O O O $ContractDeployer$ O O $any$ O $DeployerConfiguration$ O $Connector$ O $AccountManager$ O $CompilerOutput$ O O O $ContractDeployer$ O $Promise<void>$ O O O O $Promise<void>$ O O O O O O O O O $any$ O $any$ O O O O O O $complex$ O $any$ O O $Console$ O $void$ O $any$ O O $any$ O $any$ O O O O O O
import { CompilerConfiguration } from 's' ; import { ContractCompiler } from "s" ; require ( 's' ) . install ( ) ; async function doWork ( ) < void > { const configuration = CompilerConfiguration . create ( ) ; const compiler = new ContractCompiler ( configuration ) ; await compiler . compileContracts ( ) ; } doWork ( ) . then ( ( ) => { process . exit ( ) ; } ) . catch ( error => { console . log ( error ) ; process . exit ( ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $Promise$ O O O O O O O $CompilerConfiguration$ O $any$ O $CompilerConfiguration$ O O O O $ContractCompiler$ O O $any$ O $CompilerConfiguration$ O O O $ContractCompiler$ O $Promise<CompilerOutput>$ O O O O $Promise<void>$ O O O O O O O O O $any$ O $any$ O O O O O O $complex$ O $any$ O O $Console$ O $void$ O $any$ O O $any$ O $any$ O O O O O O
import { ContractDeployer } from "s" ; import { DeployerConfiguration } from 's' ; import { NetworkConfiguration } from 's' ; export async function deployContracts ( ) { require ( 's' ) . install ( ) ; await ContractDeployer . deployToNetwork ( NetworkConfiguration . create ( ) , DeployerConfiguration . create ( ) ) ; } deployContracts ( ) . then ( ( ) => { process . exitCode = 0 ; } ) . catch ( error => { console . log ( error ) ; process . exitCode = 0 ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $Promise<void>$ O O O $any$ O O O O $any$ O O O O $any$ O $Promise<void>$ O $any$ O $NetworkConfiguration$ O O O $any$ O $DeployerConfiguration$ O O O O O $Promise<void>$ O O O O O O O O O $any$ O $any$ O O O O O O $complex$ O $any$ O O $Console$ O $void$ O $any$ O O $any$ O $any$ O O O O O O
import { ContractDeployer } from "s" ; import { NetworkConfiguration } from "s" ; import { DeployerConfiguration } from "s" ; export async function deployToNetworks ( networks < string > ) { const networkConfigurations = networks . map ( ( network ) => NetworkConfiguration . create ( network ) ) ; const deployerConfiguration = DeployerConfiguration . create ( ) ; for ( let network of networkConfigurations ) { await ContractDeployer . deployToNetwork ( network , deployerConfiguration ) ; } } if ( require . main === module ) { const networks < string > = process . argv . slice ( 0 ) ; deployToNetworks ( networks ) . then ( ( ) => { console . log ( "s" ) ; process . exitCode = 0 ; } ) . catch ( ( error ) => { console . log ( "s" , error ) ; process . exitCode = 0 ; } ) ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $Promise<void>$ O $Array$ O O O O O O $NetworkConfiguration[]$ O $string[]$ O $U[]$ O O $string$ O O $any$ O $NetworkConfiguration$ O $string$ O O O O $DeployerConfiguration$ O $any$ O $DeployerConfiguration$ O O O O O O $NetworkConfiguration$ O $NetworkConfiguration[]$ O O O $any$ O $Promise<void>$ O $NetworkConfiguration$ O $DeployerConfiguration$ O O O O O O $any$ O $any$ O $any$ O O O $Array$ O O O O $any$ O $any$ O $any$ O O O O $Promise<void>$ O $string[]$ O O O O O O O O $Console$ O $void$ O O O O $any$ O $any$ O O O O O O $complex$ O O $any$ O O O $Console$ O $void$ O O O $any$ O O $any$ O $any$ O O O O O O O
export { NetworkConfiguration } from "s" ; export { DeployerConfiguration } from "s" ; export { ContractDeployer } from "s" ; export const abi = require ( 's' ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O
import * as fs from "s" ; import { Abi , AbiFunction , Primitive } from 's' ; import { ContractCompiler } from "s" ; import { CompilerOutput , CompilerOutputContracts } from "s" ; import { CompilerConfiguration } from 's' ; export class ContractInterfaceGenerator { private readonly compiler : ContractCompiler ; private readonly configuration : CompilerConfiguration ; public constructor ( configuration , compiler ) { this . compiler = compiler ; this . configuration = configuration ; } public async generateContractInterfaces ( ) < String > { const contractsOutput = await this . compiler . compileContracts ( ) ; const fileContents = this . contractInterfacesTemplate ( contractsOutput . contracts ) ; await fs . writeFile ( this . configuration . contractInterfacesOutputPath , fileContents ) ; return fileContents ; } private contractInterfacesTemplate ( contracts ) { const contractInterfaces < string > = [ ] ; contractInterfaces . push ( this . contractInterfaceTemplate ( "s" , contracts [ "s" ] [ "s" ] . abi ) ) ; for ( let globalName in contracts ) { for ( let contractName in contracts [ globalName ] ) { const contractAbi = contracts [ globalName ] [ contractName ] . abi ; if ( contractAbi . length == 0 ) continue ; if ( contractName == "s" ) continue ; contractInterfaces . push ( this . contractInterfaceTemplate ( contractName , contractAbi ) ) ; } } return `template` ; } private contractInterfaceTemplate ( contractName , contractAbi ) { const contractMethods < String > = [ ] ; const seen < string > = new Set ( ) ; const contractFunctions < AbiFunction > = contractAbi . filter ( v => v . type == "s" ) . map ( v => < AbiFunction > v ) ; for ( let abiFunction of contractFunctions ) { if ( seen . has ( abiFunction . name ) ) continue ; if ( ! abiFunction . constant ) { contractMethods . push ( this . remoteMethodTemplate ( abiFunction ) ) ; } contractMethods . push ( this . localMethodTemplate ( abiFunction ) ) ; seen . add ( abiFunction . name ) ; } const extendsControlled = seen . has ( "s" ) && contractName != "s" ; return `template` } private remoteMethodTemplate ( abiFunction ) { const argNames = this . getArgNamesString ( abiFunction ) ; const params = this . getParamsString ( abiFunction ) ; const options = `template` ; return `template` ; } private localMethodTemplate ( abiFunction ) { const argNames = this . getArgNamesString ( abiFunction ) ; const params = this . getParamsString ( abiFunction ) ; const options = `template` ; const returnType = ( abiFunction . outputs [ 0 ] !== undefined ) ? this . getTsTypeFromPrimitive ( abiFunction . outputs [ 0 ] . type ) : "s" ; const returnPromiseType = ( abiFunction . outputs . length === 0 || abiFunction . outputs . length === 0 ) ? returnType : "s" ; const returnValue = abiFunction . outputs . length == 0 ? `template` : "s" ; return `template` ; } private getTsTypeFromPrimitive ( abiType ) { switch ( abiType ) { case 's' : case 's' : case 's' : case 's' : { return 's' ; } case 's' : case 's' : case 's' : case 's' : case 's' : { return 's' ; } case 's' : { return 's' ; } case 's' : { return 's' } case 's' : { return 's' ; } case 's' : case 's' : case 's' : case 's' : case 's' : case 's' : case 's' : case 's' : case 's' : { return 's' ; } default : { throw "s" + abiType ; } } } private getArgNamesString ( abiFunction ) { return abiFunction . inputs . map ( ( v , i ) => v . name . substr ( 0 ) || `template` ) . join ( "s" ) ; } private getParamsString ( abiFunction ) { if ( abiFunction . inputs . length == 0 ) return "s" ; return abiFunction . inputs . map ( ( v , i ) => ( v . name . substr ( 0 ) || `template` ) + "s" + this . getTsTypeFromPrimitive ( v . type ) ) . join ( "s" ) + "s" ; } }	O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O $ContractCompiler$ O $any$ O O O $CompilerConfiguration$ O $any$ O O O O $CompilerConfiguration$ O $ContractCompiler$ O O O O $ContractCompiler$ O $ContractCompiler$ O O O $CompilerConfiguration$ O $CompilerConfiguration$ O O O O $Promise$ O O O $StringConstructor$ O O O $CompilerOutput$ O O O O $ContractCompiler$ O $Promise<CompilerOutput>$ O O O O $String$ O O O $string$ O $CompilerOutput$ O $CompilerOutputContracts$ O O O $any$ O $any$ O O O $CompilerConfiguration$ O $string$ O $String$ O O O $String$ O O O $string$ O $CompilerOutputContracts$ O O O $Array$ O O O O O O O $string[]$ O $number$ O O O $string$ O O O $CompilerOutputContracts$ O O O O O O O $any$ O O O O O O $string$ O $CompilerOutputContracts$ O O O O O $string$ O $CompilerOutputContracts$ O $string$ O O O O $Abi$ O $CompilerOutputContracts$ O $string$ O O $string$ O O $any$ O O O $any$ O $any$ O O O O O O O $string$ O O O O O $string[]$ O $number$ O O O $string$ O $string$ O $any$ O O O O O O O O O O $string$ O $String$ O $Abi$ O O O $Array$ O $StringConstructor$ O O O O O O $Set$ O O O O O $SetConstructor$ O O O O $Array$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any[]$ O O O O $Set<string>$ O $boolean$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $String[]$ O $number$ O O O $string$ O $any$ O O O O $String[]$ O $number$ O O O $string$ O $any$ O O O $Set<string>$ O $Set<string>$ O $any$ O $any$ O O O O $boolean$ O $Set<string>$ O $boolean$ O O O O $String$ O O O O O O O $string$ O $AbiFunction$ O O O $String$ O O O $any$ O $any$ O O O $String$ O O O $string$ O $any$ O O O $String$ O O O O O O O O $string$ O $AbiFunction$ O O O $String$ O O O $any$ O $any$ O O O $String$ O O O $string$ O $any$ O O O $String$ O O O O $String$ O O $any$ O $any$ O O O O $undefined$ O O O O $complex$ O $any$ O $any$ O O O O $any$ O O O O O $String$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $String$ O O O O $String$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $complex$ O $Primitive$ O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O $any$ O $AbiFunction$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $string$ O $AbiFunction$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O $complex$ O $any$ O $any$ O O O $any$ O O O O O O O O
import { Connector } from 's' ; import { AccountManager } from 's' ; import { NetworkConfiguration } from 's' ; import { LegacyReputationToken , ReputationToken } from 's' ; import * as Parallel from 's' ; export interface LegacyRepData { balances : Array < string > ; allowanceOwners : Array < string > ; allowanceSpenders : Array < string > ; } export class LegacyRepMigrator { private readonly repContract : ReputationToken ; private readonly legacyRepContract : LegacyReputationToken ; private legacyRepData : LegacyRepData ; private unmigratedLegacyRepData : LegacyRepData ; private chunkedBalances : Array < Array < string > > ; private chunkedAllowanceOwners : Array < Array < string > > ; private chunkedAllowanceSpenders : Array < Array < string > > ; private readonly chunkSize : number ; private readonly sleepTimeInMS : number ; private readonly parallelTransactions : number ; private constructor ( repContract , legacyRepContract , legacyRepData , chunkSize ) { this . repContract = repContract ; this . legacyRepContract = legacyRepContract ; this . chunkSize = chunkSize ; this . legacyRepData = legacyRepData ; this . unmigratedLegacyRepData = { balances : [ ] , allowanceOwners : [ ] , allowanceSpenders : [ ] } ; this . chunkedBalances = [ ] ; this . chunkedAllowanceOwners = [ ] ; this . chunkedAllowanceSpenders = [ ] ; this . sleepTimeInMS = 0 ; this . parallelTransactions = 0 ; } private async initialize ( ) < void > { console . log ( "s" ) ; await this . getUnMigratedLegacyData ( this . legacyRepData ) ; this . chunkedBalances = this . chunk ( this . unmigratedLegacyRepData . balances ) ; this . chunkedAllowanceOwners = this . chunk ( this . unmigratedLegacyRepData . allowanceOwners ) ; this . chunkedAllowanceSpenders = this . chunk ( this . unmigratedLegacyRepData . allowanceSpenders ) ; } public static create = async ( legacyRepData , repContractAddress , txSize ) : Promise < LegacyRepMigrator > => { const networkConfiguration = NetworkConfiguration . create ( ) ; const connector = new Connector ( networkConfiguration ) ; console . log ( `template` ) ; await connector . waitUntilConnected ( ) ; const accountManager = new AccountManager ( connector , networkConfiguration . privateKey ) ; console . log ( `template` ) ; const repContract = new ReputationToken ( connector , accountManager , repContractAddress , connector . gasPrice ) ; const legacyRepContractAddress = await repContract . getLegacyRepToken_ ( ) ; const legacyRepContract = new LegacyReputationToken ( connector , accountManager , legacyRepContractAddress , connector . gasPrice ) ; const isPaused = await legacyRepContract . paused_ ( ) ; if ( ! isPaused ) { throw new Error ( "s" ) ; } const legacyRepMigrator = new LegacyRepMigrator ( repContract , legacyRepContract , legacyRepData , txSize ) ; await legacyRepMigrator . initialize ( ) ; return legacyRepMigrator ; } public async migrateLegacyRep ( ) < void > { console . log ( `template` ) ; console . log ( "s" ) ; await this . migrateApprovals ( ) ; console . log ( "s" ) ; console . log ( "s" ) ; await this . migrateBalances ( ) ; console . log ( "s" ) ; await this . verifyBalances ( ) ; console . log ( "s" ) ; return ; } private async migrateApprovals ( ) < void > { await Parallel . each ( Array . from ( Array ( this . chunkedAllowanceOwners . length ) . keys ( ) ) , async i => { await this . migrateAllowances ( this . chunkedAllowanceOwners [ i ] , this . chunkedAllowanceSpenders [ i ] ) ; if ( ( i * this . chunkSize ) % 0 == 0 ) console . log ( `template` ) ; } , this . parallelTransactions ) ; return ; } private async migrateAllowances ( owners < string > , spenders < string > ) < void > { await this . repContract . migrateAllowancesFromLegacyRep ( owners , spenders ) ; return ; } private async migrateBalances ( ) < void > { let i = 0 ; await Parallel . each ( this . chunkedBalances , async balancesChunk => { await this . migrateOwners ( balancesChunk ) ; i += this . chunkSize ; if ( i % 0 == 0 ) console . log ( `template` ) ; } , this . parallelTransactions ) ; return ; } private async migrateOwners ( owners < string > ) < void > { await this . repContract . migrateBalancesFromLegacyRep ( owners ) ; const supply = await this . repContract . totalSupply_ ( ) ; console . log ( `template` ) ; return ; } private async verifyBalances ( ) < void > { await Parallel . each ( this . legacyRepData . balances , async owner => { await this . verifyBalance ( owner ) ; await Parallel . sleep ( this . sleepTimeInMS ) ; } , 0 ) ; return ; } private async verifyBalance ( owner ) < void > { const legacyBalance = await this . legacyRepContract . balanceOf_ ( owner ) ; const balance = await this . repContract . balanceOf_ ( owner ) ; if ( ! balance . eq ( legacyBalance ) ) { throw new Error ( `template` ) ; } return ; } private chunk ( items < string > ) < Array < string > > { const numChunks = Math . ceil ( items . length / this . chunkSize ) ; const chunked = new Array ( numChunks ) ; for ( let i = 0 ; i <= numChunks ; ++ i ) { chunked [ i - 0 ] = items . slice ( ( i - 0 ) * this . chunkSize , i * this . chunkSize ) ; } return chunked ; } private async getUnMigratedLegacyData ( legacyRepData ) < void > { await Parallel . each ( Array . from ( Array ( this . legacyRepData . allowanceOwners . length ) . keys ( ) ) , async i => { await this . addToAllowancesIfUnmigrated ( legacyRepData . allowanceOwners [ i ] , legacyRepData . allowanceSpenders [ i ] , ) ; if ( i % 0 == 0 ) console . log ( `template` ) await Parallel . sleep ( this . sleepTimeInMS ) ; } , 0 ) ; let i = 0 ; await Parallel . each ( this . legacyRepData . balances , async owner => { await this . addToBalancesIfUnmigrated ( owner ) ; i ++ ; if ( i % 0 == 0 ) console . log ( `template` ) await Parallel . sleep ( this . sleepTimeInMS ) ; } , 0 ) ; return ; } private async addToBalancesIfUnmigrated ( address ) < void > { const balance = await this . repContract . balanceOf_ ( address ) ; if ( balance . isZero ( ) ) { this . unmigratedLegacyRepData . balances . push ( address ) ; if ( this . unmigratedLegacyRepData . balances . length % 0 == 0 ) console . log ( `template` ) } return ; } private async addToAllowancesIfUnmigrated ( owner , spender ) < void > { const allowance = await this . repContract . allowance_ ( owner , spender ) ; if ( allowance . isZero ( ) ) { this . unmigratedLegacyRepData . allowanceOwners . push ( owner ) ; this . unmigratedLegacyRepData . allowanceSpenders . push ( spender ) ; if ( this . unmigratedLegacyRepData . allowanceOwners . length % 0 == 0 ) console . log ( `template` ) } return ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O $string[]$ O $ArrayConstructor$ O O O O $string[]$ O $ArrayConstructor$ O O O O $string[]$ O $ArrayConstructor$ O O O O O O O $any$ O O O $ReputationToken$ O $any$ O O O $LegacyReputationToken$ O $any$ O O $LegacyRepData$ O $any$ O O $LegacyRepData$ O $any$ O O $string[][]$ O $ArrayConstructor$ O $ArrayConstructor$ O O O O O O $string[][]$ O $ArrayConstructor$ O $ArrayConstructor$ O O O O O O $string[][]$ O $ArrayConstructor$ O $ArrayConstructor$ O O O O O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O O $ReputationToken$ O $LegacyReputationToken$ O $LegacyRepData$ O $number$ O O O O $ReputationToken$ O $ReputationToken$ O O O $LegacyReputationToken$ O $LegacyReputationToken$ O O O $number$ O $number$ O O O $LegacyRepData$ O $LegacyRepData$ O O O $LegacyRepData$ O O $undefined[]$ O O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O $string[][]$ O O O O O O $string[][]$ O O O O O O $string[][]$ O O O O O O $number$ O O O O O $number$ O O O O O O $Promise$ O O O O O O $Console$ O $void$ O O O O O O O $Promise<void>$ O O O $LegacyRepData$ O O O O $string[][]$ O O O $string[][]$ O O O $LegacyRepData$ O $string[]$ O O O O $string[][]$ O O O $string[][]$ O O O $LegacyRepData$ O $string[]$ O O O O $string[][]$ O O O $string[][]$ O O O $LegacyRepData$ O $string[]$ O O O O O $Promise<LegacyRepMigrator>$ O O O $LegacyRepData$ O $string$ O $number$ O O $PromiseConstructor$ O $any$ O O O O $NetworkConfiguration$ O $any$ O $NetworkConfiguration$ O O O O $Connector$ O O $any$ O $NetworkConfiguration$ O O $Console$ O $void$ O O O O O $Connector$ O $Promise<EthjsQuery>$ O O O O $AccountManager$ O O $any$ O $Connector$ O $NetworkConfiguration$ O $string$ O O $Console$ O $void$ O O O O O $ReputationToken$ O O $any$ O $Connector$ O $AccountManager$ O $string$ O $Connector$ O $BN$ O O O $string$ O O $ReputationToken$ O $Promise<string>$ O O O O $LegacyReputationToken$ O O $any$ O $Connector$ O $AccountManager$ O $string$ O $Connector$ O $BN$ O O O $boolean$ O O $LegacyReputationToken$ O $Promise<boolean>$ O O O O O O $boolean$ O O O O $ErrorConstructor$ O O O O O O $LegacyRepMigrator$ O O $any$ O $ReputationToken$ O $LegacyReputationToken$ O $LegacyRepData$ O $number$ O O O $LegacyRepMigrator$ O $Promise<void>$ O O O O $LegacyRepMigrator$ O O O O $Promise$ O O O O O O $Console$ O $void$ O O O O $Console$ O $void$ O O O O O O O $Promise<void>$ O O O $Console$ O $void$ O O O O $Console$ O $void$ O O O O O O O $Promise<void>$ O O O $Console$ O $void$ O O O O O O O $Promise<void>$ O O O $Console$ O $void$ O O O O O O O O O $Promise$ O O O O O O O $any$ O $any$ O $ArrayConstructor$ O $complex$ O $ArrayConstructor$ O O O $string[][]$ O $number$ O O $IterableIterator<number>$ O O O O O $any$ O O O O O $Promise<void>$ O O O $string[][]$ O $any$ O O O O $string[][]$ O $any$ O O O O O O $any$ O O O $number$ O O O O O O $Console$ O $void$ O O O O O O O O $number$ O O O O O O O $Promise$ O $Array$ O O O O $Array$ O O O O O O O O O O O $ReputationToken$ O $Promise<void>$ O $string[]$ O $string[]$ O O O O O O O $Promise$ O O O O O O O $number$ O O O O $any$ O $any$ O O O $string[][]$ O O $any$ O O O O O $Promise<void>$ O $any$ O O $number$ O O O $number$ O O O $number$ O O O O O $Console$ O $void$ O O O O O O O O $number$ O O O O O O O $Promise$ O $Array$ O O O O O O O O O O O $ReputationToken$ O $Promise<void>$ O $string[]$ O O O $BN$ O O O O $ReputationToken$ O $Promise<BN>$ O O O $Console$ O $void$ O O O O O O O O O $Promise$ O O O O O O O $any$ O $any$ O O O $LegacyRepData$ O $string[]$ O O $any$ O O O O O $Promise<void>$ O $any$ O O O $any$ O $any$ O O O $number$ O O O O O O O O O O O O $Promise$ O $string$ O O O O O O $BN$ O O O O $LegacyReputationToken$ O $Promise<BN>$ O $string$ O O O $BN$ O O O O $ReputationToken$ O $Promise<BN>$ O $string$ O O O O O $BN$ O $boolean$ O $BN$ O O O O O $ErrorConstructor$ O O O O O O O O O $Array$ O $Array$ O O O O O $ArrayConstructor$ O O O O O O $number$ O $Math$ O $number$ O $string[]$ O $number$ O O O $number$ O O O $any[]$ O O $ArrayConstructor$ O $number$ O O O O O $number$ O O O $number$ O $number$ O O $number$ O O $any[]$ O $number$ O O O O $string[]$ O $string[]$ O O $number$ O O O O O O $number$ O $number$ O O O $number$ O O O O $any[]$ O O O O $Promise$ O $LegacyRepData$ O O O O O O $any$ O $any$ O $ArrayConstructor$ O $complex$ O $ArrayConstructor$ O O O $LegacyRepData$ O $string[]$ O $number$ O O $IterableIterator<number>$ O O O O O $any$ O O O O O $Promise<void>$ O $LegacyRepData$ O $string[]$ O $any$ O O $LegacyRepData$ O $string[]$ O $any$ O O O O O O $any$ O O O O O $Console$ O $void$ O O O O $any$ O $any$ O O O $number$ O O O O O O O O $number$ O O O O $any$ O $any$ O O O $LegacyRepData$ O $string[]$ O O $any$ O O O O O $Promise<void>$ O $any$ O O $number$ O O O O $number$ O O O O O $Console$ O $void$ O O O O $any$ O $any$ O O O $number$ O O O O O O O O O O O O $Promise$ O $string$ O O O O O O $BN$ O O O O $ReputationToken$ O $Promise<BN>$ O $string$ O O O O $BN$ O $boolean$ O O O O O O $LegacyRepData$ O $string[]$ O $number$ O $string$ O O O O O O $LegacyRepData$ O $string[]$ O $number$ O O O O O $Console$ O $void$ O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O $BN$ O O O O $ReputationToken$ O $Promise<BN>$ O $string$ O $string$ O O O O $BN$ O $boolean$ O O O O O O $LegacyRepData$ O $string[]$ O $number$ O $string$ O O O O $LegacyRepData$ O $string[]$ O $number$ O $string$ O O O O O O $LegacyRepData$ O $string[]$ O $number$ O O O O O $Console$ O $void$ O O O O O O O O
import { URL } from 's' ; import { NetworkConfiguration } from 's' ; import { server as serverFactory , TestRpcServer } from 's' ; export class TestRpc { private readonly DEFAULT_TEST_ACCOUNT_BALANCE = 0 ** 0 ; private readonly BLOCK_GAS_LIMIT = 0 ; private readonly networkConfiguration : NetworkConfiguration ; private readonly testRpcServer : TestRpcServer ; constructor ( networkConfiguration ) { this . networkConfiguration = networkConfiguration ; const accounts = [ { balance : `template` , secretKey : networkConfiguration . privateKey } ] ; const options = { gasLimit : `template` , accounts : accounts } ; this . testRpcServer = serverFactory ( options ) ; } public listen ( ) { const url = new URL ( this . networkConfiguration . http ) ; this . testRpcServer . listen ( parseInt ( url . port ) || 0 ) ; } public static startTestRpcIfNecessary = async ( networkConfiguration ) : Promise < void > => { if ( networkConfiguration . networkName === 's' ) { const testRpc = new TestRpc ( networkConfiguration ) ; testRpc . listen ( ) ; } } }	O O $any$ O O O O O O $any$ O O O O O O $TestRpcServer$ O $TestRpcServer$ O $any$ O O O O O O $any$ O O O $number$ O O O O O O O O O O O O O $NetworkConfiguration$ O $any$ O O O $TestRpcServer$ O $any$ O O O $NetworkConfiguration$ O O O O $NetworkConfiguration$ O $NetworkConfiguration$ O O $complex$ O O O $string$ O O O $string$ O $NetworkConfiguration$ O $string$ O O O O $complex$ O O $string$ O O O $complex$ O $complex$ O O O O $TestRpcServer$ O $TestRpcServer$ O $complex$ O O O O $void$ O O O O $any$ O O $any$ O O O $NetworkConfiguration$ O $string$ O O O O $TestRpcServer$ O $void$ O $number$ O $any$ O $any$ O O O O O O O O $Promise<void>$ O O O $NetworkConfiguration$ O O $PromiseConstructor$ O O O O O O O $NetworkConfiguration$ O $string$ O O O O O $TestRpc$ O O $any$ O $NetworkConfiguration$ O O $TestRpc$ O $void$ O O O O O O
import BN = require ( 's' ) ; import { TestRpc } from 's' ; import { Connector } from 's' ; import { AccountManager } from 's' ; import { ContractCompiler } from 's' ; import { ContractDeployer } from 's' ; import { CompilerConfiguration } from 's' ; import { DeployerConfiguration } from 's' ; import { NetworkConfiguration } from 's' ; import { FeeWindow , ShareToken , ClaimTradingProceeds , CompleteSets , TimeControlled , Cash , Universe , Market , CreateOrder , Orders , Trade , CancelOrder , LegacyReputationToken , DisputeCrowdsourcer , ReputationToken , } from 's' ; import { 0 } from 's' ; export class TestFixture { private static GAS_PRICE : BN = new BN ( 0 ) ; private readonly connector : Connector ; public readonly accountManager : AccountManager ; public readonly contractDeployer : ContractDeployer ; public get universe ( ) { return this . contractDeployer . universe ; } public get cash ( ) { return < Cash > this . contractDeployer . getContract ( 's' ) ; } public constructor ( connector , accountManager , contractDeployer ) { this . connector = connector ; this . accountManager = accountManager ; this . contractDeployer = contractDeployer ; } public static create = async ( pretendToBeProduction = false ) : Promise < TestFixture > => { const networkConfiguration = NetworkConfiguration . create ( ) ; await TestRpc . startTestRpcIfNecessary ( networkConfiguration ) ; const compilerConfiguration = CompilerConfiguration . create ( ) const compiledContracts = await new ContractCompiler ( compilerConfiguration ) . compileContracts ( ) ; const connector = new Connector ( networkConfiguration ) ; console . log ( `template` ) ; await connector . waitUntilConnected ( ) ; const accountManager = new AccountManager ( connector , networkConfiguration . privateKey ) ; const deployerConfiguration = DeployerConfiguration . createWithControlledTime ( ) ; let contractDeployer = new ContractDeployer ( deployerConfiguration , connector , accountManager , compiledContracts ) ; if ( pretendToBeProduction ) { const legacyRepAddress = await contractDeployer . uploadLegacyRep ( ) ; await contractDeployer . initializeLegacyRep ( ) ; const fakeProdDeployerConfiguration = DeployerConfiguration . createWithControlledTime ( legacyRepAddress , true ) ; contractDeployer = new ContractDeployer ( fakeProdDeployerConfiguration , connector , accountManager , compiledContracts ) ; } await contractDeployer . deploy ( ) ; return new TestFixture ( connector , accountManager , contractDeployer ) ; } public async approveCentralAuthority ( ) < void > { const authority = this . contractDeployer . getContract ( 's' ) ; const cash = new Cash ( this . connector , this . accountManager , this . contractDeployer . getContract ( 's' ) . address , TestFixture . GAS_PRICE ) ; await cash . approve ( authority . address , new BN ( 0 ) . pow ( new BN ( 0 ) ) . sub ( new BN ( 0 ) ) ) ; } public async createMarket ( universe , outcomes : string [ ] , endTime , feePerEthInWei , denominationToken , designatedReporter ) < Market > { const marketCreationFee = await universe . getOrCacheMarketCreationCost_ ( ) ; const marketAddress = await universe . createCategoricalMarket_ ( endTime , feePerEthInWei , denominationToken , designatedReporter , outcomes , 0 ( "s" ) , 's' , 's' , { attachedEth : marketCreationFee } ) ; if ( ! marketAddress || marketAddress == "s" ) { throw new Error ( "s" ) ; } await universe . createCategoricalMarket ( endTime , feePerEthInWei , denominationToken , designatedReporter , outcomes , 0 ( "s" ) , 's' , 's' , { attachedEth : marketCreationFee } ) ; const market = new Market ( this . connector , this . accountManager , marketAddress , TestFixture . GAS_PRICE ) ; if ( await market . getTypeName_ ( ) !== 0 ( "s" ) ) { throw new Error ( "s" ) ; } return market ; } public async createReasonableMarket ( universe , denominationToken , outcomes : string [ ] ) < Market > { const endTime = new BN ( Math . round ( new Date ( ) . getTime ( ) / 0 ) + 0 * 0 * 0 * 0 ) ; const fee = ( new BN ( 0 ) ) . pow ( new BN ( 0 ) ) ; return await this . createMarket ( universe , outcomes , endTime , fee , denominationToken , this . accountManager . defaultAddress ) ; } public async placeOrder ( market , type , numShares , price , outcome , betterOrderID , worseOrderID , tradeGroupID ) < void > { const createOrderContract = await this . contractDeployer . getContract ( "s" ) ; const createOrder = new CreateOrder ( this . connector , this . accountManager , createOrderContract . address , TestFixture . GAS_PRICE ) ; const ethValue = numShares . mul ( price ) ; await createOrder . publicCreateOrder ( type , numShares , price , market , outcome , betterOrderID , worseOrderID , tradeGroupID , { attachedEth : ethValue } ) ; return ; } public async takeBestOrder ( marketAddress , type , numShares , price , outcome , tradeGroupID ) < void > { const tradeContract = await this . contractDeployer . getContract ( "s" ) ; const trade = new Trade ( this . connector , this . accountManager , tradeContract . address , TestFixture . GAS_PRICE ) ; let actualPrice = price ; if ( type == new BN ( 0 ) ) { const market = new Market ( this . connector , this . accountManager , marketAddress , TestFixture . GAS_PRICE ) ; const numTicks = await market . getNumTicks_ ( ) ; actualPrice = numTicks . sub ( price ) ; } const ethValue = numShares . mul ( actualPrice ) ; const bestPriceAmount = await trade . publicFillBestOrder_ ( type , marketAddress , outcome , numShares , price , tradeGroupID , { attachedEth : ethValue } ) ; if ( bestPriceAmount == new BN ( 0 ) ) { throw new Error ( "s" ) ; } await trade . publicFillBestOrder ( type , marketAddress , outcome , numShares , price , tradeGroupID , { attachedEth : ethValue } ) ; return ; } public async cancelOrder ( orderID ) < void > { const cancelOrderContract = await this . contractDeployer . getContract ( "s" ) ; const cancelOrder = new CancelOrder ( this . connector , this . accountManager , cancelOrderContract . address , TestFixture . GAS_PRICE ) ; await cancelOrder . cancelOrder ( orderID ) ; return ; } public async claimTradingProceeds ( market , shareholder ) < void > { const claimTradingProceedsContract = await this . contractDeployer . getContract ( "s" ) ; const claimTradingProceeds = new ClaimTradingProceeds ( this . connector , this . accountManager , claimTradingProceedsContract . address , TestFixture . GAS_PRICE ) ; await claimTradingProceeds . claimTradingProceeds ( market . address , shareholder ) ; return ; } public async getOrderPrice ( orderID ) < BN > { const ordersContract = await this . contractDeployer . getContract ( "s" ) ; const orders = new Orders ( this . connector , this . accountManager , ordersContract . address , TestFixture . GAS_PRICE ) ; const price = await orders . getPrice_ ( orderID ) ; if ( price . toNumber ( ) == 0 ) { throw new Error ( "s" ) ; } return price ; } public async getOrderAmount ( orderID ) < BN > { const ordersContract = await this . contractDeployer . getContract ( "s" ) ; const orders = new Orders ( this . connector , this . accountManager , ordersContract . address , TestFixture . GAS_PRICE ) ; return await orders . getAmount_ ( orderID ) ; } public async getBestOrderId ( type , market , outcome ) < string > { const ordersContract = await this . contractDeployer . getContract ( "s" ) ; const orders = new Orders ( this . connector , this . accountManager , ordersContract . address , TestFixture . GAS_PRICE ) ; const orderID = await orders . getBestOrderId_ ( type , market , outcome ) ; if ( ! orderID ) { throw new Error ( "s" ) ; } return orderID ; } public async buyCompleteSets ( market , amount ) < void > { const completeSetsContract = await this . contractDeployer . getContract ( "s" ) ; const completeSets = new CompleteSets ( this . connector , this . accountManager , completeSetsContract . address , TestFixture . GAS_PRICE ) ; const numTicks = await market . getNumTicks_ ( ) ; const ethValue = amount . mul ( numTicks ) ; await completeSets . publicBuyCompleteSets ( market . address , amount , { attachedEth : ethValue } ) ; return ; } public async sellCompleteSets ( market , amount ) < void > { const completeSetsContract = await this . contractDeployer . getContract ( "s" ) ; const completeSets = new CompleteSets ( this . connector , this . accountManager , completeSetsContract . address , TestFixture . GAS_PRICE ) ; await completeSets . publicSellCompleteSets ( market . address , amount ) ; return ; } public async contribute ( market , payoutNumerators < BN > , invalid , amount ) < void > { await market . contribute ( payoutNumerators , invalid , amount ) ; return ; } public async derivePayoutDistributionHash ( market , payoutNumerators < BN > , invalid ) < string > { return await market . derivePayoutDistributionHash_ ( payoutNumerators , invalid ) ; } public async isForking ( ) < boolean > { return await this . universe . isForking_ ( ) ; } public async migrateOutByPayout ( reputationToken , payoutNumerators < BN > , invalid , attotokens ) { await reputationToken . migrateOutByPayout ( payoutNumerators , invalid , attotokens ) ; return ; } public async getNumSharesInMarket ( market , outcome ) < BN > { const shareTokenAddress = await market . getShareToken_ ( outcome ) ; const shareToken = new ShareToken ( this . connector , this . accountManager , shareTokenAddress , TestFixture . GAS_PRICE ) ; return await shareToken . balanceOf_ ( this . accountManager . defaultAddress ) ; } public async getFeeWindow ( market ) < FeeWindow > { const feeWindowAddress = await market . getFeeWindow_ ( ) ; return new FeeWindow ( this . connector , this . accountManager , feeWindowAddress , TestFixture . GAS_PRICE ) ; } public async getReportingParticipant ( reportingParticipantAddress ) < DisputeCrowdsourcer > { return new DisputeCrowdsourcer ( this . connector , this . accountManager , reportingParticipantAddress , TestFixture . GAS_PRICE ) ; } public async getUniverse ( market ) < Universe > { const universeAddress = await market . getUniverse_ ( ) ; return new Universe ( this . connector , this . accountManager , universeAddress , TestFixture . GAS_PRICE ) ; } public async getWinningReportingParticipant ( market ) < DisputeCrowdsourcer > { const reportingParticipantAddress = await market . getWinningReportingParticipant_ ( ) ; return new DisputeCrowdsourcer ( this . connector , this . accountManager , reportingParticipantAddress , TestFixture . GAS_PRICE ) ; } public async setTimestamp ( timestamp ) < void > { const timeContract = await this . contractDeployer . getContract ( "s" ) ; const time = new TimeControlled ( this . connector , this . accountManager , timeContract . address , TestFixture . GAS_PRICE ) ; await time . setTimestamp ( timestamp ) ; return ; } public async getTimestamp ( ) < BN > { return this . contractDeployer . controller . getTimestamp_ ( ) ; } public async doInitialReport ( market , payoutNumerators < BN > , invalid ) < void > { await market . doInitialReport ( payoutNumerators , invalid ) ; return ; } public async finalizeMarket ( market ) < void > { await market . finalize ( ) ; return ; } public async isLegacyRepPaused ( ) < boolean > { const legacyRepContract = await this . contractDeployer . getContract ( "s" ) ; const legacyRep = new LegacyReputationToken ( this . connector , this . accountManager , legacyRepContract . address , TestFixture . GAS_PRICE ) ; return await legacyRep . paused_ ( ) ; } public async getLegacyRepBalance ( owner ) < BN > { const legacyRepContract = await this . contractDeployer . getContract ( "s" ) ; const legacyRep = new LegacyReputationToken ( this . connector , this . accountManager , legacyRepContract . address , TestFixture . GAS_PRICE ) ; return await legacyRep . balanceOf_ ( owner ) ; } public async getLegacyRepAllowance ( owner , spender ) < BN > { const legacyRepContract = await this . contractDeployer . getContract ( "s" ) ; const legacyRep = new LegacyReputationToken ( this . connector , this . accountManager , legacyRepContract . address , TestFixture . GAS_PRICE ) ; return await legacyRep . allowance_ ( owner , spender ) ; } public async transferLegacyRep ( to , amount ) < void > { const legacyRepContract = await this . contractDeployer . getContract ( "s" ) ; const legacyRep = new LegacyReputationToken ( this . connector , this . accountManager , legacyRepContract . address , TestFixture . GAS_PRICE ) ; await legacyRep . transfer ( to , amount ) ; return ; } public async approveLegacyRep ( spender , amount ) < void > { const legacyRepContract = await this . contractDeployer . getContract ( "s" ) ; const legacyRep = new LegacyReputationToken ( this . connector , this . accountManager , legacyRepContract . address , TestFixture . GAS_PRICE ) ; await legacyRep . approve ( spender , amount ) ; return ; } public async pauseLegacyRep ( ) < void > { const legacyRepContract = await this . contractDeployer . getContract ( "s" ) ; const legacyRep = new LegacyReputationToken ( this . connector , this . accountManager , legacyRepContract . address , TestFixture . GAS_PRICE ) ; await legacyRep . pause ( ) ; return ; } public async getChildUniverseReputationToken ( parentPayoutDistributionHash ) { const childUniverseAddress = await this . contractDeployer . universe . getChildUniverse_ ( parentPayoutDistributionHash ) ; const childUniverse = new Universe ( this . connector , this . accountManager , childUniverseAddress , TestFixture . GAS_PRICE ) ; const repContractAddress = await childUniverse . getReputationToken_ ( ) ; return new ReputationToken ( this . connector , this . accountManager , repContractAddress , TestFixture . GAS_PRICE ) ; } public async getReputationToken ( ) < ReputationToken > { const repContractAddress = await this . contractDeployer . universe . getReputationToken_ ( ) ; return new ReputationToken ( this . connector , this . accountManager , repContractAddress , TestFixture . GAS_PRICE ) ; } public async isRepMigratingFromLegacy ( ) < boolean > { const rep = await this . getReputationToken ( ) ; return await rep . getIsMigratingFromLegacy_ ( ) ; } public async getEthBalance ( ) < BN > { return await this . connector . ethjsQuery . getBalance ( this . accountManager . defaultAddress ) ; } public async getRepBalance ( owner ) < BN > { const rep = await this . getReputationToken ( ) ; return await rep . balanceOf_ ( owner ) ; } public async getRepAllowance ( owner , spender ) < BN > { const rep = await this . getReputationToken ( ) ; return await rep . allowance_ ( owner , spender ) ; } }	O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $string$ O O O O O O $any$ O O O $BN$ O $any$ O O $any$ O O O O O O $Connector$ O $any$ O O O $AccountManager$ O $any$ O O O $ContractDeployer$ O $any$ O O O $Universe$ O O O O O O $ContractDeployer$ O $Universe$ O O O O $Cash$ O O O O O $any$ O O O $ContractDeployer$ O $Controlled$ O O O O O O O O $Connector$ O $AccountManager$ O $ContractDeployer$ O O O O $Connector$ O $Connector$ O O O $AccountManager$ O $AccountManager$ O O O $ContractDeployer$ O $ContractDeployer$ O O O O $Promise<TestFixture>$ O O O $boolean$ O O O O $PromiseConstructor$ O $any$ O O O O $NetworkConfiguration$ O $any$ O $NetworkConfiguration$ O O O O $any$ O $Promise<void>$ O $NetworkConfiguration$ O O O $CompilerConfiguration$ O $any$ O $CompilerConfiguration$ O O O $CompilerOutput$ O O O $any$ O $CompilerConfiguration$ O O $Promise<CompilerOutput>$ O O O O $Connector$ O O $any$ O $NetworkConfiguration$ O O $Console$ O $void$ O O O O O $Connector$ O $Promise<EthjsQuery>$ O O O O $AccountManager$ O O $any$ O $Connector$ O $NetworkConfiguration$ O $string$ O O O $DeployerConfiguration$ O $any$ O $DeployerConfiguration$ O O O O $ContractDeployer$ O O $any$ O $DeployerConfiguration$ O $Connector$ O $AccountManager$ O $CompilerOutput$ O O O O $boolean$ O O O $string$ O O $ContractDeployer$ O $Promise<string>$ O O O O $ContractDeployer$ O $Promise<void>$ O O O O $DeployerConfiguration$ O $any$ O $DeployerConfiguration$ O $string$ O O O O $ContractDeployer$ O O $any$ O $DeployerConfiguration$ O $Connector$ O $AccountManager$ O $CompilerOutput$ O O O O $ContractDeployer$ O $Promise<void>$ O O O O O $any$ O $Connector$ O $AccountManager$ O $ContractDeployer$ O O O O O $Promise$ O O O O O O O $Controlled$ O O O $ContractDeployer$ O $Controlled$ O O O O O $Cash$ O O $any$ O O O $Connector$ O O O $AccountManager$ O O O $ContractDeployer$ O $Controlled$ O O O O $string$ O $any$ O $BN$ O O O $Cash$ O $Promise<void>$ O $Controlled$ O $string$ O O $any$ O O O O $BN$ O O $any$ O O O O O $BN$ O O $any$ O O O O O O O O O $Promise$ O $Universe$ O $string[]$ O O O O O $BN$ O $BN$ O $string$ O $string$ O O $any$ O O O $BN$ O O $Universe$ O $Promise<BN>$ O O O O $string$ O O $Universe$ O $Promise<...>$ O $BN$ O $BN$ O $string$ O $string$ O $string[]$ O $string$ O O O O O O O O O $BN$ O $BN$ O O O O O O $string$ O $string$ O O O O O O $ErrorConstructor$ O O O O O O $Universe$ O $Promise<...>$ O $BN$ O $BN$ O $string$ O $string$ O $string[]$ O $string$ O O O O O O O O O $BN$ O $BN$ O O O O $Market$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O $any$ O $BN$ O O O O O $Market$ O $Promise<string>$ O O O $string$ O O O O O O O $ErrorConstructor$ O O O O O O $Market$ O O O O $Promise$ O $Universe$ O $string$ O $string[]$ O O O O O O $any$ O O O $BN$ O O $any$ O $Math$ O $number$ O O $DateConstructor$ O O O $number$ O O O O O O O O O O O O O O O O $BN$ O O O $any$ O O O O O $BN$ O O $any$ O O O O O O O O O $Promise<Market>$ O $Universe$ O $string[]$ O $BN$ O $BN$ O $string$ O O O $AccountManager$ O $string$ O O O O O $Promise$ O $string$ O $BN$ O $BN$ O $BN$ O $BN$ O $string$ O $string$ O $string$ O O O O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $CreateOrder$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O $BN$ O $BN$ O $BN$ O $BN$ O O O $CreateOrder$ O $Promise<...>$ O $BN$ O $BN$ O $BN$ O $string$ O $BN$ O $string$ O $string$ O $string$ O O $BN$ O $BN$ O O O O O O O O $Promise$ O $string$ O $BN$ O $BN$ O $BN$ O $BN$ O $string$ O O O O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $Trade$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O $BN$ O $BN$ O O O $BN$ O O $any$ O O O O O O $Market$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O $any$ O $BN$ O O O $BN$ O O $Market$ O $Promise<BN>$ O O O $BN$ O $BN$ O $BN$ O $BN$ O O O O $BN$ O $BN$ O $BN$ O $BN$ O O O $BN$ O O $Trade$ O $Promise<BN>$ O $BN$ O $string$ O $BN$ O $BN$ O $BN$ O $string$ O O $BN$ O $BN$ O O O O O $BN$ O O $any$ O O O O O O O $ErrorConstructor$ O O O O O O $Trade$ O $Promise<void>$ O $BN$ O $string$ O $BN$ O $BN$ O $BN$ O $string$ O O $BN$ O $BN$ O O O O O O O O $Promise$ O $string$ O O O O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $CancelOrder$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O $CancelOrder$ O $Promise<void>$ O $string$ O O O O O O O $Promise$ O $Market$ O $string$ O O O O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $ClaimTradingProceeds$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O $ClaimTradingProceeds$ O $Promise<void>$ O $Market$ O $string$ O $string$ O O O O O O O $Promise$ O $string$ O O $any$ O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $Orders$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O $BN$ O O $Orders$ O $Promise<BN>$ O $string$ O O O O $BN$ O $number$ O O O O O O O O $ErrorConstructor$ O O O O O O $BN$ O O O O $Promise$ O $string$ O O $any$ O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $Orders$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O O $Orders$ O $Promise<BN>$ O $string$ O O O O O $Promise$ O $BN$ O $string$ O $BN$ O O O O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $Orders$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O $string$ O O $Orders$ O $Promise<string>$ O $BN$ O $string$ O $BN$ O O O O O $string$ O O O O $ErrorConstructor$ O O O O O O $string$ O O O O $Promise$ O $Market$ O $BN$ O O O O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $CompleteSets$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O $BN$ O O $Market$ O $Promise<BN>$ O O O O $BN$ O $BN$ O $BN$ O $BN$ O O O $CompleteSets$ O $Promise<void>$ O $Market$ O $string$ O $BN$ O O $BN$ O $BN$ O O O O O O O O $Promise$ O $Market$ O $BN$ O O O O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $CompleteSets$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O $CompleteSets$ O $Promise<void>$ O $Market$ O $string$ O $BN$ O O O O O O O $Promise$ O $Market$ O $Array$ O $any$ O O $boolean$ O $BN$ O O O O O O $Market$ O $Promise<void>$ O $BN[]$ O $boolean$ O $BN$ O O O O O O O $Promise$ O $Market$ O $Array$ O $any$ O O $boolean$ O O O O O O O $Market$ O $Promise<string>$ O $BN[]$ O $boolean$ O O O O O $Promise$ O O O O O O O O O O $Universe$ O $Promise<boolean>$ O O O O O O $Promise<void>$ O $ReputationToken$ O $Array$ O $any$ O O $boolean$ O $BN$ O O O $ReputationToken$ O $Promise<void>$ O $BN[]$ O $boolean$ O $BN$ O O O O O O O $Promise$ O $Market$ O $BN$ O O $any$ O O O $string$ O O $Market$ O $Promise<string>$ O $BN$ O O O $ShareToken$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O $any$ O $BN$ O O O O $ShareToken$ O $Promise<BN>$ O O O $AccountManager$ O $string$ O O O O O $Promise$ O $Market$ O O $any$ O O O $string$ O O $Market$ O $Promise<string>$ O O O O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O $any$ O $BN$ O O O O O $Promise$ O $string$ O O $any$ O O O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O $any$ O $BN$ O O O O O $Promise$ O $Market$ O O $any$ O O O $string$ O O $Market$ O $Promise<string>$ O O O O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O $any$ O $BN$ O O O O O $Promise$ O $Market$ O O $any$ O O O $string$ O O $Market$ O $Promise<string>$ O O O O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O $any$ O $BN$ O O O O O $Promise$ O $BN$ O O O O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $TimeControlled$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O $TimeControlled$ O $Promise<void>$ O $BN$ O O O O O O O $Promise$ O O O $any$ O O O O O $ContractDeployer$ O $Controller$ O $Promise<BN>$ O O O O O O $Promise$ O $Market$ O $Array$ O $any$ O O $boolean$ O O O O O O $Market$ O $Promise<void>$ O $BN[]$ O $boolean$ O O O O O O O $Promise$ O $Market$ O O O O O O $Market$ O $Promise<void>$ O O O O O O O O $Promise$ O O O O O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $LegacyReputationToken$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O O $LegacyReputationToken$ O $Promise<boolean>$ O O O O O O $Promise$ O $string$ O O $any$ O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $LegacyReputationToken$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O O $LegacyReputationToken$ O $Promise<BN>$ O $string$ O O O O O $Promise$ O $string$ O $string$ O O $any$ O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $LegacyReputationToken$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O O $LegacyReputationToken$ O $Promise<BN>$ O $string$ O $string$ O O O O O $Promise$ O $string$ O $BN$ O O O O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $LegacyReputationToken$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O $LegacyReputationToken$ O $Promise<void>$ O $string$ O $BN$ O O O O O O O $Promise$ O $string$ O $BN$ O O O O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $LegacyReputationToken$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O $LegacyReputationToken$ O $Promise<void>$ O $string$ O $BN$ O O O O O O O $Promise$ O O O O O O O $Controlled$ O O O O $ContractDeployer$ O $Controlled$ O O O O O $LegacyReputationToken$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $Controlled$ O $string$ O $any$ O $BN$ O O O $LegacyReputationToken$ O $Promise<void>$ O O O O O O O O $Promise<ReputationToken>$ O $string$ O O O $string$ O O O O $ContractDeployer$ O $Universe$ O $Promise<string>$ O $string$ O O O $Universe$ O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O $any$ O $BN$ O O O $string$ O O $Universe$ O $Promise<string>$ O O O O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O $any$ O $BN$ O O O O O $Promise$ O O O $any$ O O O $string$ O O O O $ContractDeployer$ O $Universe$ O $Promise<string>$ O O O O O $any$ O O O $Connector$ O O O $AccountManager$ O $string$ O $any$ O $BN$ O O O O O $Promise$ O O O O O O O $ReputationToken$ O O O O $Promise<ReputationToken>$ O O O O O $ReputationToken$ O $Promise<boolean>$ O O O O O O $Promise$ O O O $any$ O O O O O O $Connector$ O $EthjsQuery$ O $Promise<BN>$ O O O $AccountManager$ O $string$ O O O O O $Promise$ O $string$ O O $any$ O O O $ReputationToken$ O O O O $Promise<ReputationToken>$ O O O O O $ReputationToken$ O $Promise<BN>$ O $string$ O O O O O $Promise$ O $string$ O $string$ O O $any$ O O O $ReputationToken$ O O O O $Promise<ReputationToken>$ O O O O O $ReputationToken$ O $Promise<BN>$ O $string$ O $string$ O O O O
import BN = require ( 's' ) ; import { expect } from "s" ; import { TestFixture } from 's' ; import { LegacyRepMigrator , LegacyRepData } from 's' ; describe ( "s" , ( ) => { let fixture ; before ( async ( ) => { fixture = await TestFixture . create ( true ) ; } ) ; it ( "s" , async ( ) => { await fixture . pauseLegacyRep ( ) ; let legacyRepLocked = await fixture . isLegacyRepPaused ( ) ; expect ( legacyRepLocked ) . to . be . true ; let repLocked = await fixture . isRepMigratingFromLegacy ( ) ; expect ( repLocked ) . to . be . true ; const legacyRepData = { balances : [ fixture . accountManager . defaultAddress ] , allowanceOwners : [ ] , allowanceSpenders : [ ] , } ; for ( let i = 0 ; i < 0 ; i ++ ) { const amount = new BN ( i + 0 ) ; const address = `template` ; await fixture . transferLegacyRep ( address , amount ) ; await fixture . approveLegacyRep ( address , amount ) ; const balance = await fixture . getLegacyRepBalance ( address ) ; const allowance = await fixture . getLegacyRepAllowance ( fixture . accountManager . defaultAddress , address ) ; expect ( balance . toNumber ( ) ) . to . eq ( amount . toNumber ( ) ) ; expect ( allowance . toNumber ( ) ) . to . eq ( amount . toNumber ( ) ) ; legacyRepData . balances . push ( address ) ; legacyRepData . allowanceOwners . push ( fixture . accountManager . defaultAddress ) ; legacyRepData . allowanceSpenders . push ( address ) ; } const reputationTokenAddress = await fixture . universe . getReputationToken_ ( ) ; const txSize = 0 ; const legacyRepMigrator = await LegacyRepMigrator . create ( legacyRepData , reputationTokenAddress , txSize ) ; await legacyRepMigrator . migrateLegacyRep ( ) ; repLocked = await fixture . isRepMigratingFromLegacy ( ) ; expect ( repLocked ) . to . be . false ; for ( let i = 0 ; i < 0 ; i ++ ) { const amount = new BN ( i + 0 ) ; const address = `template` ; const balance = await fixture . getRepBalance ( address ) ; const allowance = await fixture . getRepAllowance ( fixture . accountManager . defaultAddress , address ) ; expect ( balance . toNumber ( ) ) . to . eq ( amount . toNumber ( ) ) ; expect ( allowance . toNumber ( ) ) . to . eq ( amount . toNumber ( ) ) ; } } ) ; } ) ;	O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $TestFixture$ O $any$ O O O O O O $TestFixture$ O O $any$ O $Promise<TestFixture>$ O O O O O O O $any$ O O O O O O O O O $TestFixture$ O $Promise<void>$ O O O O $boolean$ O O $TestFixture$ O $Promise<boolean>$ O O O $any$ O $boolean$ O O $any$ O $any$ O $any$ O O $boolean$ O O $TestFixture$ O $Promise<boolean>$ O O O $any$ O $boolean$ O O $any$ O $any$ O $any$ O O $LegacyRepData$ O O $string[]$ O O $TestFixture$ O $AccountManager$ O $string$ O O $undefined[]$ O O O O $undefined[]$ O O O O O O O O O $number$ O O O $number$ O O O $number$ O O O O $BN$ O O $any$ O $number$ O O O O O $string$ O O O O $TestFixture$ O $Promise<void>$ O $string$ O $BN$ O O O $TestFixture$ O $Promise<void>$ O $string$ O $BN$ O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O $string$ O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O $TestFixture$ O $AccountManager$ O $string$ O $string$ O O $any$ O $BN$ O $number$ O O O O $any$ O $any$ O $BN$ O $number$ O O O O $any$ O $BN$ O $number$ O O O O $any$ O $any$ O $BN$ O $number$ O O O O $LegacyRepData$ O $string[]$ O $number$ O $string$ O O $LegacyRepData$ O $string[]$ O $number$ O $TestFixture$ O $AccountManager$ O $string$ O O $LegacyRepData$ O $string[]$ O $number$ O $string$ O O O O $string$ O O $TestFixture$ O $Universe$ O $Promise<string>$ O O O O O O O O O $LegacyRepMigrator$ O O $any$ O $Promise<LegacyRepMigrator>$ O $LegacyRepData$ O $string$ O O O O O $LegacyRepMigrator$ O $Promise<void>$ O O O $boolean$ O O $TestFixture$ O $Promise<boolean>$ O O O $any$ O $boolean$ O O $any$ O $any$ O $any$ O O O O $number$ O O O $number$ O O O $number$ O O O O $BN$ O O $any$ O $number$ O O O O O $string$ O O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O $string$ O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O $TestFixture$ O $AccountManager$ O $string$ O $string$ O O $any$ O $BN$ O $number$ O O O O $any$ O $any$ O $BN$ O $number$ O O O O $any$ O $BN$ O $number$ O O O O $any$ O $any$ O $BN$ O $number$ O O O O O O O O O O O
import BN = require ( 's' ) ; import { expect } from "s" ; import { TestFixture } from 's' ; import { Market } from 's' ; const ZERO_ADDRESS = "s" ; export class ReportingUtils { public async proceedToDesignatedReporting ( fixture , market ) { const marketEndTime = await market . getEndTime_ ( ) ; await fixture . setTimestamp ( marketEndTime . add ( new BN ( 0 ) ) ) ; } public async proceedToInitialReporting ( fixture , market ) { const designatedReportingEndTime = await market . getDesignatedReportingEndTime_ ( ) ; await fixture . setTimestamp ( designatedReportingEndTime . add ( new BN ( 0 ) ) ) ; } public async proceedToNextRound ( fixture , market , doGenerateFees = false , moveTimeForward = true , randomPayoutNumerators = false ) { const currentTimestamp = await fixture . getTimestamp ( ) ; const marketEndTime = await market . getEndTime_ ( ) ; if ( currentTimestamp . lt ( marketEndTime ) ) { const marketDesignatedReportingEndTime = await market . getDesignatedReportingEndTime_ ( ) ; await fixture . setTimestamp ( marketDesignatedReportingEndTime . add ( new BN ( 0 ) ) ) ; } const feeWindowAddress = await market . getFeeWindow_ ( ) ; const numberOfOutcomes = await market . getNumberOfOutcomes_ ( ) ; const numTicks = await market . getNumTicks_ ( ) ; let payoutNumerators = new Array ( numberOfOutcomes . toNumber ( ) ) . fill ( new BN ( 0 ) ) ; payoutNumerators [ 0 ] = numTicks ; let winningPayoutHash = "s" ; if ( feeWindowAddress === ZERO_ADDRESS ) { await market . doInitialReport ( payoutNumerators , false ) ; expect ( await market . getFeeWindow_ ( ) === ZERO_ADDRESS ) . to . be . false ; console . log ( "s" ) ; let outcome = new BN ( 0 ) ; let numShares = new BN ( 0 ) ; await fixture . buyCompleteSets ( market , numShares ) ; let numOwnedShares = await fixture . getNumSharesInMarket ( market , outcome ) ; let ethBalance = await fixture . getEthBalance ( ) ; console . log ( "s" , ethBalance . toString ( 0 ) ) ; console . log ( "s" , numOwnedShares . toString ( 0 ) ) ; ethBalance = await fixture . getEthBalance ( ) ; console . log ( "s" , ethBalance . toString ( 0 ) ) ; let numOwnedSharesBefore = await fixture . getNumSharesInMarket ( market , outcome ) ; console . log ( "s" , numOwnedSharesBefore . toString ( 0 ) ) ; await fixture . sellCompleteSets ( market , numShares ) ; ethBalance = await fixture . getEthBalance ( ) ; console . log ( "s" , ethBalance . toString ( 0 ) ) ; numOwnedSharesBefore = await fixture . getNumSharesInMarket ( market , outcome ) ; console . log ( "s" , numOwnedSharesBefore . toString ( 0 ) ) ; } else { const feeWindow = await fixture . getFeeWindow ( market ) ; const feeWindowStartTime = await feeWindow . getStartTime_ ( ) ; await fixture . setTimestamp ( feeWindowStartTime . add ( new BN ( 0 ) ) ) ; const winningReport = await fixture . getWinningReportingParticipant ( market ) ; winningPayoutHash = await winningReport . getPayoutDistributionHash_ ( ) ; let chosenPayoutNumerators = [ ] ; if ( randomPayoutNumerators ) { chosenPayoutNumerators = new Array ( numberOfOutcomes ) . fill ( new BN ( 0 ) ) ; chosenPayoutNumerators [ 0 ] = new BN ( Math . floor ( Math . random ( ) * Math . floor ( numTicks . toNumber ( ) + 0 ) ) ) ; chosenPayoutNumerators [ 0 ] = numTicks . sub ( chosenPayoutNumerators [ 0 ] ) ; } else { const firstReportWinning = await market . derivePayoutDistributionHash_ ( payoutNumerators , false ) === winningPayoutHash ; chosenPayoutNumerators = payoutNumerators ; if ( firstReportWinning ) { payoutNumerators . reverse ( ) ; } } const chosenPayoutHash = await market . derivePayoutDistributionHash_ ( chosenPayoutNumerators , false ) ; const participantStake = await market . getParticipantStake_ ( ) ; const stakeInOutcome = await market . getStakeInOutcome_ ( chosenPayoutHash ) ; const amount = participantStake . mul ( new BN ( 0 ) ) . sub ( stakeInOutcome . mul ( new BN ( 0 ) ) ) ; await fixture . contribute ( market , chosenPayoutNumerators , false , amount ) ; console . log ( "s" , amount . toString ( 0 ) ) ; console . log ( "s" , chosenPayoutNumerators ) ; const forkingMarket = await market . getForkingMarket_ ( ) ; const marketFeeWindow = await market . getFeeWindow_ ( ) ; expect ( forkingMarket !== ZERO_ADDRESS || marketFeeWindow !== feeWindowAddress ) . to . be . true ; } if ( doGenerateFees ) { } if ( moveTimeForward ) { let feeWindow = await fixture . getFeeWindow ( market ) ; let feeWindowStartTime = await feeWindow . getStartTime_ ( ) ; await fixture . setTimestamp ( feeWindowStartTime . add ( new BN ( 0 ) ) ) ; } } public async proceedToFork ( fixture , market ) { let forkingMarket = await market . getForkingMarket_ ( ) ; let disputeRound = 0 ; while ( forkingMarket === ZERO_ADDRESS ) { console . log ( "s" , disputeRound ) ; await this . proceedToNextRound ( fixture , market ) ; forkingMarket = await market . getForkingMarket_ ( ) ; disputeRound ++ ; } let ethBalance = await fixture . getEthBalance ( ) ; console . log ( "s" , ethBalance . toString ( 0 ) ) ; const numParticipants = await market . getNumParticipants_ ( ) ; for ( let i = 0 ; i < numParticipants . toNumber ( ) ; i ++ ) { const reportingParticipantAddress = await market . getReportingParticipant_ ( new BN ( i ) ) ; const reportingParticipant = await fixture . getReportingParticipant ( reportingParticipantAddress ) ; await reportingParticipant . forkAndRedeem ( ) ; const reportingParticipantStake = await reportingParticipant . getStake_ ( ) ; expect ( reportingParticipantStake === new BN ( 0 ) ) ; } ethBalance = await fixture . getEthBalance ( ) ; console . log ( "s" , ethBalance . toString ( 0 ) ) ; console . log ( "s" ) ; } }	O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O $any$ O O O $Promise<void>$ O $TestFixture$ O $Market$ O O O $BN$ O O $Market$ O $Promise<BN>$ O O O O $TestFixture$ O $Promise<void>$ O $BN$ O $BN$ O O $any$ O O O O O O O O O $Promise<void>$ O $TestFixture$ O $Market$ O O O $BN$ O O $Market$ O $Promise<BN>$ O O O O $TestFixture$ O $Promise<void>$ O $BN$ O $BN$ O O $any$ O O O O O O O O O $Promise<void>$ O $TestFixture$ O $Market$ O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O O O O $BN$ O O $Market$ O $Promise<BN>$ O O O O O $BN$ O $BN$ O $BN$ O O O O $BN$ O O $Market$ O $Promise<BN>$ O O O O $TestFixture$ O $Promise<void>$ O $BN$ O $BN$ O O $any$ O O O O O O O O $string$ O O $Market$ O $Promise<string>$ O O O O $BN$ O O $Market$ O $Promise<BN>$ O O O O $BN$ O O $Market$ O $Promise<BN>$ O O O O $any[]$ O O $ArrayConstructor$ O $BN$ O $number$ O O O O $any[]$ O O $any$ O O O O O $any[]$ O O O O $BN$ O O $string$ O O O O O $string$ O O O O O $Market$ O $Promise<void>$ O $any[]$ O O O O $any$ O O $Market$ O $Promise<string>$ O O O O O O $any$ O $any$ O $any$ O $Console$ O $void$ O O O O O $BN$ O O $any$ O O O O O $BN$ O O $any$ O O O O O $TestFixture$ O $Promise<void>$ O $Market$ O $BN$ O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O $Market$ O $BN$ O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O O O $Console$ O $void$ O O O $BN$ O $string$ O O O O O $Console$ O $void$ O O O $BN$ O $string$ O O O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O O O $Console$ O $void$ O O O $BN$ O $string$ O O O O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O $Market$ O $BN$ O O $Console$ O $void$ O O O $BN$ O $string$ O O O O O O $TestFixture$ O $Promise<void>$ O $Market$ O $BN$ O O $BN$ O O $TestFixture$ O $Promise<BN>$ O O O $Console$ O $void$ O O O $BN$ O $string$ O O O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O $Market$ O $BN$ O O $Console$ O $void$ O O O $BN$ O $string$ O O O O O O O O O $FeeWindow$ O O $TestFixture$ O $Promise<FeeWindow>$ O $Market$ O O O $BN$ O O $FeeWindow$ O $Promise<BN>$ O O O O $TestFixture$ O $Promise<void>$ O $BN$ O $BN$ O O $any$ O O O O O O O $DisputeCrowdsourcer$ O O $TestFixture$ O $Promise<DisputeCrowdsourcer>$ O $Market$ O O $string$ O O $DisputeCrowdsourcer$ O $Promise<string>$ O O O O $any[]$ O O O O O O $boolean$ O O $any[]$ O O $ArrayConstructor$ O $BN$ O O $BN[]$ O O $any$ O O O O O $any[]$ O O O O O $any$ O $Math$ O $number$ O $Math$ O $number$ O O O $Math$ O $number$ O $BN$ O $number$ O O O O O O O O $any[]$ O O O O $BN$ O $BN$ O $any[]$ O O O O O O O O O $boolean$ O O $Market$ O $Promise<string>$ O $any[]$ O O O O $string$ O $any[]$ O $any[]$ O O O $boolean$ O O $any[]$ O $any[]$ O O O O O O $string$ O O $Market$ O $Promise<string>$ O $any[]$ O O O O O $BN$ O O $Market$ O $Promise<BN>$ O O O O $BN$ O O $Market$ O $Promise<BN>$ O $string$ O O O $BN$ O $BN$ O $BN$ O O $any$ O O O O O $BN$ O $BN$ O $BN$ O O $any$ O O O O O O O $TestFixture$ O $Promise<void>$ O $Market$ O $any[]$ O O O $BN$ O O $Console$ O $void$ O O O $BN$ O $string$ O O O O O $Console$ O $void$ O O O $any[]$ O O O $string$ O O $Market$ O $Promise<string>$ O O O O $string$ O O $Market$ O $Promise<string>$ O O O $any$ O $string$ O O O $string$ O $string$ O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O $boolean$ O O O $FeeWindow$ O O $TestFixture$ O $Promise<FeeWindow>$ O $Market$ O O O $BN$ O O $FeeWindow$ O $Promise<BN>$ O O O O $TestFixture$ O $Promise<void>$ O $BN$ O $BN$ O O $any$ O O O O O O O O O O $Promise<void>$ O $TestFixture$ O $Market$ O O O $string$ O O $Market$ O $Promise<string>$ O O O O $number$ O O O O O $string$ O O O O $Console$ O $void$ O O O $number$ O O O O O $Promise<void>$ O $TestFixture$ O $Market$ O O $string$ O O $Market$ O $Promise<string>$ O O O $number$ O O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O O O $Console$ O $void$ O O O $BN$ O $string$ O O O O O O $BN$ O O $Market$ O $Promise<BN>$ O O O O O O $number$ O O O $number$ O $BN$ O $number$ O O O $number$ O O O O $string$ O O $Market$ O $Promise<string>$ O O $any$ O $number$ O O O O $DisputeCrowdsourcer$ O O $TestFixture$ O $Promise<DisputeCrowdsourcer>$ O $string$ O O O $DisputeCrowdsourcer$ O $Promise<void>$ O O O O $BN$ O O $DisputeCrowdsourcer$ O $Promise<BN>$ O O O $any$ O $BN$ O O $any$ O O O O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O O O $Console$ O $void$ O O O $BN$ O $string$ O O O O O $Console$ O $void$ O O O O O O
import BN = require ( 's' ) ; import { expect } from "s" ; import { 0 } from "s" ; import { TestFixture } from 's' ; import { ReportingUtils } from 's' ; describe ( "s" , ( ) => { let fixture ; before ( async ( ) => { fixture = await TestFixture . create ( ) ; } ) ; it ( "s" , async ( ) => { await fixture . approveCentralAuthority ( ) ; let ethBalance = await fixture . getEthBalance ( ) ; console . log ( "s" , ethBalance . toString ( 0 ) ) ; const market = await fixture . createReasonableMarket ( fixture . universe , fixture . cash . address , [ 0 ( "s" ) , 0 ( "s" ) ] ) ; const actualTypeName = await market . getTypeName_ ( ) ; const expectedTypeName = 0 ( "s" ) ; expect ( actualTypeName ) . to . equal ( expectedTypeName ) ; let type = new BN ( 0 ) ; let outcome = new BN ( 0 ) ; let numShares = new BN ( 0 ) ; let price = new BN ( 0 ) ; await fixture . placeOrder ( market . address , type , numShares , price , outcome , 0 ( "s" ) , 0 ( "s" ) , 0 ( "s" ) ) ; const orderID = await fixture . getBestOrderId ( type , market . address , outcome ) const orderPrice = await fixture . getOrderPrice ( orderID ) ; expect ( orderPrice . toNumber ( ) ) . to . equal ( price . toNumber ( ) ) ; ethBalance = await fixture . getEthBalance ( ) ; console . log ( "s" , ethBalance . toString ( 0 ) ) ; await fixture . buyCompleteSets ( market , numShares ) ; const numOwnedShares = await fixture . getNumSharesInMarket ( market , outcome ) ; expect ( numOwnedShares . toNumber ( ) ) . to . equal ( numShares . toNumber ( ) ) ; ethBalance = await fixture . getEthBalance ( ) ; console . log ( "s" , ethBalance . toString ( 0 ) ) ; await fixture . cancelOrder ( orderID ) ; const remainingAmount = await fixture . getOrderAmount ( orderID ) ; expect ( remainingAmount . toNumber ( ) ) . to . equal ( 0 ) ; const reportingUtils = new ReportingUtils ( ) ; await reportingUtils . proceedToFork ( fixture , market ) ; const isForking = await fixture . isForking ( ) ; expect ( isForking ) . to . be . true ; const numTicks = await market . getNumTicks_ ( ) ; const reputationToken = await fixture . getReputationToken ( ) ; const payoutDistributionHash = await fixture . derivePayoutDistributionHash ( market , [ numTicks , new BN ( 0 ) ] , false ) ; const childUniverseReputationToken = await fixture . getChildUniverseReputationToken ( payoutDistributionHash ) ; const initialRepTotalMigrated = await childUniverseReputationToken . getTotalMigrated_ ( ) ; expect ( initialRepTotalMigrated === new BN ( "s" ) ) ; const repAmountToMigrate = new BN ( 0 ) . mul ( new BN ( 0 ) . pow ( new BN ( 0 ) ) ) ; await fixture . migrateOutByPayout ( reputationToken , [ numTicks , new BN ( 0 ) ] , false , repAmountToMigrate ) ; const finalRepTotalMigrated = await childUniverseReputationToken . getTotalMigrated_ ( ) ; expect ( finalRepTotalMigrated . sub ( initialRepTotalMigrated ) . toString ( 0 ) ) . to . equal ( repAmountToMigrate . toString ( 0 ) ) ; let isFinalized = await market . isFinalized_ ( ) ; expect ( isFinalized ) . to . be . true ; } ) ; } ) ;	O $any$ O O O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $TestFixture$ O $any$ O O O O O O $TestFixture$ O O $any$ O $Promise<TestFixture>$ O O O O O O $any$ O O O O O O O O O $TestFixture$ O $Promise<void>$ O O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O O O $Console$ O $void$ O O O $BN$ O $string$ O O O O O O $Market$ O O $TestFixture$ O $Promise<Market>$ O $TestFixture$ O $Universe$ O $TestFixture$ O $Cash$ O $string$ O O $string$ O O O O $string$ O O O O O O O $string$ O O $Market$ O $Promise<string>$ O O O O $string$ O $string$ O O O O $any$ O $string$ O O $any$ O $any$ O $string$ O O O $BN$ O O $any$ O O O O O $BN$ O O $any$ O O O O O $BN$ O O $any$ O O O O O $BN$ O O $any$ O O O O O $TestFixture$ O $Promise<void>$ O $Market$ O $string$ O $BN$ O $BN$ O $BN$ O $BN$ O $string$ O O O O $string$ O O O O $string$ O O O O O O $string$ O O $TestFixture$ O $Promise<string>$ O $BN$ O $Market$ O $string$ O $BN$ O O $BN$ O O $TestFixture$ O $Promise<BN>$ O $string$ O O $any$ O $BN$ O $number$ O O O O $any$ O $any$ O $BN$ O $number$ O O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O O O $Console$ O $void$ O O O $BN$ O $string$ O O O O O O $TestFixture$ O $Promise<void>$ O $Market$ O $BN$ O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O $Market$ O $BN$ O O $any$ O $BN$ O $number$ O O O O $any$ O $any$ O $BN$ O $number$ O O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O O O $Console$ O $void$ O O O $BN$ O $string$ O O O O O O $TestFixture$ O $Promise<void>$ O $string$ O O O $BN$ O O $TestFixture$ O $Promise<BN>$ O $string$ O O $any$ O $BN$ O $number$ O O O O $any$ O $any$ O O O O O $ReportingUtils$ O O $any$ O O O O $ReportingUtils$ O $Promise<void>$ O $TestFixture$ O $Market$ O O O $boolean$ O O $TestFixture$ O $Promise<boolean>$ O O O $any$ O $boolean$ O O $any$ O $any$ O $any$ O O $BN$ O O $Market$ O $Promise<BN>$ O O O O $ReputationToken$ O O $TestFixture$ O $Promise<ReputationToken>$ O O O O $string$ O O $TestFixture$ O $Promise<string>$ O $Market$ O O $BN$ O O $any$ O O O O O O O O O $ReputationToken$ O O $TestFixture$ O $Promise<ReputationToken>$ O $string$ O O O $BN$ O O $ReputationToken$ O $Promise<BN>$ O O O $any$ O $BN$ O O $any$ O O O O O O $BN$ O O $any$ O O O O $BN$ O O $any$ O O O O $BN$ O O $any$ O O O O O O O $TestFixture$ O $Promise<void>$ O $ReputationToken$ O O $BN$ O O $any$ O O O O O O O $BN$ O O O $BN$ O O $ReputationToken$ O $Promise<BN>$ O O O $any$ O $BN$ O $BN$ O $BN$ O O $string$ O O O O O $any$ O $any$ O $BN$ O $string$ O O O O O O $boolean$ O O $Market$ O $Promise<boolean>$ O O O $any$ O $boolean$ O O $any$ O $any$ O $any$ O O O O O O O
require ( 's' ) . install ( ) ; import { ContractCompiler } from "s" ; import { CompilerConfiguration } from 's' ; import { ContractInterfaceGenerator } from 's' ; async function doWork ( ) < void > { const configuration = await CompilerConfiguration . create ( ) ; const compiler = new ContractCompiler ( configuration ) ; const interfacesGenerator = new ContractInterfaceGenerator ( configuration , compiler ) ; await interfacesGenerator . generateContractInterfaces ( ) ; } doWork ( ) . then ( ( ) => { process . exit ( ) ; } ) . catch ( error => { console . log ( error ) ; process . exit ( 0 ) ; } ) ;	$any$ O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Promise$ O O O O O O O $CompilerConfiguration$ O O $any$ O $CompilerConfiguration$ O O O O $ContractCompiler$ O O $any$ O $CompilerConfiguration$ O O O $ContractInterfaceGenerator$ O O $any$ O $CompilerConfiguration$ O $ContractCompiler$ O O O $ContractInterfaceGenerator$ O $Promise<String>$ O O O O $Promise<void>$ O O O O O O O O O $any$ O $any$ O O O O O O $complex$ O $any$ O O $Console$ O $void$ O $any$ O O $any$ O $any$ O O O O O O O
'js' const App = require ( 's' ) ; const death = require ( 's' ) ; const { execSync } = require ( 's' ) ; const copydir = require ( 's' ) ; const replace = require ( "s" ) ; const rimraf = require ( 's' ) ; const fs = require ( 's' ) ; const config = { dir : 's' , skipFiles : [ ] , copyNodeModules : false , } const app = new App ( config ) ; app . postProcessPure = function ( ) { } ; death ( ( signal , err ) => app . cleanUp ( err ) ) ; app . generateCoverageEnvironment ( ) ; app . instrumentTarget ( ) ; rimraf . sync ( 's' ) ; fs . mkdirSync ( 's' ) copydir . sync ( 's' , 's' ) replace ( { regex : "s" , replacement : "s" , paths : fs . readdirSync ( 's' ) . map ( filename => 's' + filename ) , silent : false , } ) try { execSync ( 's' , { stdio : [ 0 , 0 , 0 ] } ) ; } catch ( err ) { console . log ( err ) ; } app . generateReport ( ) ; rimraf . sync ( 's' ) ; rimraf . sync ( 's' ) ; rimraf . sync ( 's' ) ; rimraf . sync ( 's' )	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $complex$ O O $string$ O O O $undefined[]$ O O O O $boolean$ O O O O O $any$ O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O O $boolean$ O O O O O O O $any$ O O O O $number[]$ O O O O O O O O O O O O O O $any$ O O $Console$ O $void$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O
require ( 's' ) . install ( ) ; import * as fs from "s" ; import { LegacyRepMigrator } from 's' ; import * as yargs from 's' ; let argv = yargs . option ( 's' , { describe : "s" , } ) . option ( 's' , { describe : "s" , } ) . option ( 's' , { describe : "s" , } ) . option ( 's' , { describe : "s" , } ) . option ( 's' , { describe : "s" , default : 0 , } ) . help ( ) . demandOption ( [ 's' , 's' , 's' , 's' ] , 's' ) . argv ; async function doWork ( ) < void > { const balancesFileContents = await fs . readFile ( argv . balances , 's' ) ; const allowanceOwnersFileContents = await fs . readFile ( argv . allowanceOwners , 's' ) ; const allowanceSpendersFileContents = await fs . readFile ( argv . allowanceSpenders , 's' ) ; const balances = balancesFileContents . split ( 's' ) ; const allowanceOwners = allowanceOwnersFileContents . split ( 's' ) ; const allowanceSpenders = allowanceSpendersFileContents . split ( 's' ) ; const legacyRepData = { balances , allowanceOwners , allowanceSpenders , } const repContractAddress = argv . repAddress ; const chunkSize = argv . chunkSize ; const legacyRepMigrator = await LegacyRepMigrator . create ( legacyRepData , repContractAddress , chunkSize ) ; await legacyRepMigrator . migrateLegacyRep ( ) ; } doWork ( ) . then ( ( ) => { process . exit ( ) ; } ) . catch ( error => { console . log ( error ) ; process . exit ( 0 ) ; } ) ;	$any$ O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $string$ O O O O O O $any$ O O O O $string$ O O O O O O $any$ O O O O $string$ O O O O O O $any$ O O O O $string$ O O O O O O $any$ O O O O $string$ O O O $number$ O O O O O O $any$ O O O $any$ O O O O O O O O O O O O O O $any$ O O O $Promise$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $LegacyRepMigrator$ O O $any$ O $Promise<LegacyRepMigrator>$ O $complex$ O $any$ O $any$ O O O $LegacyRepMigrator$ O $Promise<void>$ O O O O $Promise<void>$ O O O O O O O O O $any$ O $any$ O O O O O O $complex$ O $any$ O O $Console$ O $void$ O $any$ O O $any$ O $any$ O O O O O O O