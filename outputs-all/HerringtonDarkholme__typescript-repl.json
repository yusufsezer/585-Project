import * as ts from 's' import * as path from 's' import * as child_process from 's' import * as fs from 's' export function runCode ( argv ) { var temp = require ( 's' ) temp . track ( ) process . on ( 's' , ( ) => temp . cleanupSync ( ) ) process . on ( 's' , ( ) => temp . cleanupSync ( ) ) let tempPath = temp . mkdirSync ( 's' ) let outDir = tempPath if ( argv . o ) { outDir = path . join ( tempPath , argv . o ) } let compileError = compile ( argv . _ , { outDir , noEmitOnError : true , target : ts . ScriptTarget . 0 , module : ts . ModuleKind . CommonJS , experimentalDecorators : true , } ) if ( compileError ) process . exit ( compileError ) linkDir ( process . cwd ( ) , tempPath ) var newArgv = process . argv . slice ( 0 ) . map ( arg => { if ( ! "s" . test ( arg ) ) return arg return path . join ( outDir , arg . replace ( "s" , 's' ) ) } ) child_process . execFileSync ( 's' , newArgv , { stdio : 's' } ) process . exit ( ) } function linkDir ( src , dest ) { let files = [ 's' , 's' ] for ( let file of files ) { let srcpath = path . join ( src , file ) let destpath = path . join ( dest , file ) fs . symlinkSync ( srcpath , destpath , 's' ) } } function compile ( fileNames : string [ ] , options : ts . CompilerOptions ) { var program = ts . createProgram ( fileNames , options ) ; var emitResult = program . emit ( ) ; var allDiagnostics = ts . getPreEmitDiagnostics ( program ) . concat ( emitResult . diagnostics ) ; allDiagnostics . forEach ( diagnostic => { var message = ts . flattenDiagnosticMessageText ( diagnostic . messageText , 's' ) ; if ( ! diagnostic . file ) return console . log ( message ) var { line , character } = diagnostic . file . getLineAndCharacterOfPosition ( diagnostic . start ! ) ; console . log ( `template` ) ; } ) ; var exitCode = emitResult . emitSkipped ? 0 : 0 ; return exitCode }	O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $void$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $number$ O $number$ O $any$ O $any$ O O $any$ O $true$ O O O O O $any$ O $any$ O O O $ModuleKind.CommonJS$ O $any$ O $any$ O $ModuleKind.CommonJS$ O $true$ O O O O O O O $number$ O $any$ O $any$ O $number$ O $void$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $boolean$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O $string$ O O O O $any$ O $any$ O O O O $void$ O $string$ O $string$ O O O $string[]$ O O O O O O O O O $string$ O $string[]$ O O O $any$ O $any$ O $any$ O $string$ O $string$ O O $any$ O $any$ O $any$ O $string$ O $string$ O $any$ O $any$ O $any$ O $any$ O O O O O O $number$ O $string[]$ O O O O O $CompilerOptions$ O $any$ O $any$ O O O $Program$ O $any$ O $complex$ O $string[]$ O $CompilerOptions$ O O O $EmitResult$ O $Program$ O $EmitResult$ O O O O $Diagnostic[]$ O $any$ O $complex$ O $Program$ O O $complex$ O $EmitResult$ O $complex$ O O $Diagnostic[]$ O $void$ O $Diagnostic$ O O O $string$ O $any$ O $string$ O $Diagnostic$ O $complex$ O O O O O O O $Diagnostic$ O $SourceFile$ O O $Console$ O $void$ O $string$ O O O $number$ O $number$ O O $Diagnostic$ O $SourceFile$ O $LineAndCharacter$ O $Diagnostic$ O $number$ O O O $Console$ O $void$ O O O O O O O O $number$ O $EmitResult$ O $boolean$ O O O O O O $number$ O
import * as ts from 's' import * as fs from 's' require . extensions [ 's' ] = function ( module , filename ) { var text = fs . readFileSync ( filename , 's' ) module . _compile ( ts . transpile ( text , { } , filename ) , filename ) }	O O O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O O $any$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O $any$ O O O O $string$ O O $string$ O O
export function assign ( dest , src ) { for ( let key in src ) { dest [ key ] = src [ key ] } }	O O $void$ O $any$ O $any$ O O O O O $string$ O $any$ O O $any$ O $string$ O O $any$ O $string$ O O O
import * as ts from 's' import * as path from 's' import { readdirSync , existsSync , readFileSync , statSync } from 's' import * as diff from 's' import { assign } from 's' export var acceptedCodes = getInitialCommands ( ) var versionCounter = 0 function findConfigFile ( searchPath ) { while ( true ) { const fileName = path . join ( searchPath , "s" ) ; if ( existsSync ( fileName ) ) { return fileName ; } const parentPath = path . dirname ( searchPath ) ; if ( parentPath === searchPath ) { break ; } searchPath = parentPath ; } return undefined ; } const CWD = process . cwd ( ) const DEFAULT_OPTIONS : ts . CompilerOptions = { target : ts . ScriptTarget . 0 , newLine : ts . NewLineKind . LineFeed , experimentalDecorators : true , emitDecoratorMetadata : true , noUnusedLocals : false , configFilePath : path . join ( CWD , 's' ) , } const OVERRIDE_OPTIONS : ts . CompilerOptions = { module : ts . ModuleKind . CommonJS , noEmitHelpers : true , noUnusedLocals : false , sourceMap : false , noEmit : false } function compileOption ( ) : ( ) => ts . CompilerOptions { let configFile = findConfigFile ( process . cwd ( ) ) if ( ! configFile ) { return ( ) => DEFAULT_OPTIONS } let configText = readFileSync ( configFile , 's' ) let result = ts . parseConfigFileTextToJson ( configFile , configText ) if ( result . error ) { return ( ) => DEFAULT_OPTIONS } let optionOrError = ts . convertCompilerOptionsFromJson ( result . config . compilerOptions , path . dirname ( configFile ) ) if ( optionOrError . errors . length ) { return ( ) => DEFAULT_OPTIONS } let options = optionOrError . options assign ( options , OVERRIDE_OPTIONS ) return ( ) => options } const resolvedOpt = compileOption ( ) ( ) const DUMMY_FILE = resolvedOpt . rootDir ? resolvedOpt . rootDir + 's' : 's' var serviceHost : ts . LanguageServiceHost = { getCompilationSettings : compileOption ( ) , getScriptFileNames : ( ) => [ DUMMY_FILE ] , getScriptVersion : ( fileName ) => { return fileName === DUMMY_FILE ? versionCounter . toString ( ) : 's' } , getScriptSnapshot : ( fileName ) => { try { var text = fileName === DUMMY_FILE ? acceptedCodes : readFileSync ( fileName ) . toString ( ) return ts . ScriptSnapshot . fromString ( text ) } catch ( e ) { return undefined } } , getCurrentDirectory : ( ) => CWD , getDirectories : ts . sys . getDirectories , directoryExists : ts . sys . directoryExists , fileExists : ts . sys . fileExists , readFile : ts . sys . readFile , readDirectory : ts . sys . readDirectory , getDefaultLibFileName => ts . getDefaultLibFilePath ( options ) } var service = ts . createLanguageService ( serviceHost ) export var getDeclarations = ( function ( ) { var declarations : { [ fileName ] : { [ name ] : ts . DeclarationName [ ] } } = { } let declFiles = getDeclarationFiles ( ) for ( let file of declFiles ) { let text = readFileSync ( file , 's' ) declarations [ file ] = collectDeclaration ( ts . createSourceFile ( file , text , ts . ScriptTarget . Latest ) ) } return function ( cached = false ) { if ( ! cached ) { declarations [ DUMMY_FILE ] = collectDeclaration ( ts . createSourceFile ( DUMMY_FILE , acceptedCodes , ts . ScriptTarget . Latest ) ) } return declarations } } ) ( ) function getDeclarationFiles ( ) { var libPaths = [ path . resolve ( __dirname , 's' ) ] try { let typings = path . join ( process . cwd ( ) , 's' ) let dirs = readdirSync ( typings ) for ( let dir of dirs ) { if ( ! "s" . test ( dir ) ) continue let p = path . join ( typings , dir ) if ( statSync ( p ) . isFile ( ) ) { libPaths . push ( p ) } } } catch ( e ) { } return libPaths } function getInitialCommands ( ) { return getDeclarationFiles ( ) . map ( dir => `template` ) . join ( ) } function collectDeclaration ( sourceFile ) { let decls = sourceFile . getNamedDeclarations ( ) var ret = { } for ( let decl in decls ) { ret [ decl ] = Array . isArray ( decls [ decl ] ) && decls [ decl ] . map ( ( t ) => t . name ) } return ret } export function completer ( line ) { versionCounter ++ let originalCodes = acceptedCodes acceptedCodes += line if ( 's' === line [ 0 ] ) { let candidates = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' ] candidates = candidates . map ( c => 's' + c ) . filter ( c => c . indexOf ( line ) >= 0 ) return [ candidates , line . trim ( ) ] } let completions = service . getCompletionsAtPosition ( DUMMY_FILE , acceptedCodes . length , undefined ) if ( ! completions ) { acceptedCodes = originalCodes return [ [ ] , line ] } let prefix = "s" . exec ( line ) let candidates : string [ ] = [ ] if ( prefix ) { let prefixStr = prefix [ 0 ] candidates = completions . entries . filter ( ( entry ) => { let name = entry . name return name . substr ( 0 , prefixStr . length ) == prefixStr } ) . map ( entry => entry . name ) } else { candidates = completions . entries . map ( entry => entry . name ) } acceptedCodes = originalCodes return [ candidates , prefix ? prefix [ 0 ] : line ] } export function getType ( name , detailed ) { versionCounter ++ let originalCodes = acceptedCodes acceptedCodes += 's' + name let typeInfo = service . getQuickInfoAtPosition ( DUMMY_FILE , acceptedCodes . length - 0 ) let ret = 's' if ( typeInfo ) { ret = detailed ? ts . displayPartsToString ( typeInfo . documentation ) : ts . displayPartsToString ( typeInfo . displayParts ) } acceptedCodes = originalCodes return ret } export function getDiagnostics ( code ) : string [ ] { let fallback = acceptedCodes acceptedCodes += code versionCounter ++ let allDiagnostics = service . getCompilerOptionsDiagnostics ( ) . concat ( service . getSemanticDiagnostics ( DUMMY_FILE ) ) let ret = allDiagnostics . map ( diagnostic => { let message = ts . flattenDiagnosticMessageText ( diagnostic . messageText , 's' ) return message } ) if ( ret . length ) acceptedCodes = fallback return ret } let lastOutput = 's' export function getCurrentCode ( ) { let emit = service . getEmitOutput ( DUMMY_FILE ) let output = emit . outputFiles [ 0 ] . text let changes = diff . diffLines ( lastOutput , output ) let ret = changes . filter ( c => c . added ) . map ( c => c . value ) . join ( 's' ) lastOutput = output return ret } export function testSyntacticError ( code ) { let fallback = acceptedCodes versionCounter ++ acceptedCodes += code let diagnostics = service . getSyntacticDiagnostics ( DUMMY_FILE ) acceptedCodes = fallback return diagnostics } export function clearHistory ( ) { acceptedCodes = getInitialCommands ( ) lastOutput = 's' }	O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $void$ O O O O O $string$ O $string$ O O O $number$ O O O $any$ O $string$ O O O O O O O O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $string$ O O O O O $string$ O $any$ O O O $undefined$ O O O $any$ O $any$ O $any$ O O O $CompilerOptions$ O $any$ O $any$ O O O O $any$ O $any$ O O O $NewLineKind.LineFeed$ O $any$ O $any$ O $NewLineKind.LineFeed$ O $true$ O O O $true$ O O O $false$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O $CompilerOptions$ O $any$ O $any$ O O $ModuleKind.CommonJS$ O $any$ O $any$ O $ModuleKind.CommonJS$ O $true$ O O O $false$ O O O $false$ O O O $false$ O O O O $CompilerOptions$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $CompilerOptions$ O O $any$ O $any$ O $any$ O O O O $complex$ O $any$ O $complex$ O $any$ O $any$ O O O $complex$ O $Diagnostic$ O O O O O O $CompilerOptions$ O O $complex$ O $any$ O $complex$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $complex$ O $Diagnostic[]$ O $number$ O O O O O O $CompilerOptions$ O O $CompilerOptions$ O $complex$ O $CompilerOptions$ $void$ O $CompilerOptions$ O $CompilerOptions$ O O O O O $CompilerOptions$ O O $CompilerOptions$ O $CompilerOptions$ O O O O O $string$ O $CompilerOptions$ O $string$ O $CompilerOptions$ O $string$ O O O O O $LanguageServiceHost$ O $any$ O $any$ O O $CompilerOptions$ O $CompilerOptions$ O O O $string[]$ O O O O O $string$ O O $string$ O O $string$ O O O O $string$ O $string$ O $number$ O $string$ O O O O O O $IScriptSnapshot$ O O $string$ O O O O O O $any$ O $string$ O $string$ O $string$ O $any$ O $string$ O O $any$ O O O $any$ O $any$ O $IScriptSnapshot$ O $any$ O O O O $any$ O O O $undefined$ O O O $any$ O O O O $any$ O $string[]$ O $any$ O $System$ O $string[]$ O $boolean$ O $any$ O $System$ O $boolean$ O $boolean$ O $any$ O $System$ O $boolean$ O $string$ O $any$ O $System$ O $string$ O $string[]$ O $any$ O $System$ O $string[]$ O $options$ O $any$ O $string$ O $CompilerOptions$ O O O $LanguageService$ O $any$ O $LanguageService$ O $LanguageServiceHost$ O O O $complex$ O O O O O O O $complex$ O O O $string$ O O O O $string$ O O $any$ O $any$ O O O O O O O O $any[]$ O $any[]$ O O O O O $any$ O $any[]$ O O O $any$ O $any$ O $any$ O O O $complex$ O $any$ O O $any$ O $any$ O $SourceFile$ O $any$ O $any$ O $any$ O $any$ O $ScriptTarget.ESNext$ O O O O O O $boolean$ O O O O O O O $boolean$ O O $complex$ O $string$ O O $any$ O $any$ O $SourceFile$ O $string$ O $string$ O $any$ O $any$ O $ScriptTarget.ESNext$ O O O O $complex$ O O O O O O $any[]$ O O O O $any[]$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $boolean$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any[]$ O $number$ O $any$ O O O O O O $any$ O O O O $any[]$ O O $string$ O O O O $any[]$ O O O $U[]$ O $any$ O O O O $string$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $string$ O $any$ O O $any$ O $string$ O O $ArrayConstructor$ O $complex$ O $any$ O $string$ O O O $any$ O $string$ O O $any$ O O $any$ O O $any$ O $any$ O O O $any$ O O O $complex$ O $string$ O O $number$ O O $string$ O $string$ $string$ O $string$ O O O O $string$ O O O O O O $string[]$ O O O O O O O O O O O O O O O O $string[]$ O $string[]$ O $U[]$ O $string$ O O O $string$ O O $complex$ O $string$ O $string$ O $number$ O $string$ O O O O O O $string[]$ O $string$ O $string$ O O O O O $WithMetadata<CompletionInfo>$ O $LanguageService$ O $WithMetadata<CompletionInfo>$ O $string$ O $string$ O $number$ O $undefined$ O O O O $WithMetadata<CompletionInfo>$ O O $string$ O $string$ O O O O O $string$ O O O $RegExpExecArray$ O O O $RegExpExecArray$ O $string$ O O $string[]$ O O O O O O O O O $RegExpExecArray$ O O O $string$ O $RegExpExecArray$ O O O $string[]$ O $WithMetadata<CompletionInfo>$ O $CompletionEntry[]$ O $complex$ O O $CompletionEntry$ O O O O $string$ O $CompletionEntry$ O $string$ O $string$ O $string$ O O O $string$ O $number$ O O $string$ O O O $U[]$ O $CompletionEntry$ O $CompletionEntry$ O $string$ O O O O $string[]$ O $WithMetadata<CompletionInfo>$ O $CompletionEntry[]$ O $U[]$ O $CompletionEntry$ O $CompletionEntry$ O $string$ O O $string$ O $string$ O O $string[]$ O $RegExpExecArray$ O $RegExpExecArray$ O O O O $string$ O O O O $string$ O $string$ O $boolean$ O O $number$ O O $string$ O $string$ $string$ O O O $string$ O $QuickInfo$ O $LanguageService$ O $QuickInfo$ O $string$ O $string$ O $number$ O O O O $string$ O O O O $QuickInfo$ O O $string$ O $boolean$ O $any$ O $string$ O $QuickInfo$ O $SymbolDisplayPart[]$ O O $any$ O $string$ O $QuickInfo$ O $SymbolDisplayPart[]$ O O $string$ O $string$ O $string$ O O O $string[]$ O $string$ O O O O O O O $string$ O $string$ $string$ O $string$ $number$ O O $Diagnostic[]$ O $LanguageService$ O $Diagnostic[]$ O O O $complex$ O $LanguageService$ O $Diagnostic[]$ O $string$ O O O $string[]$ O $Diagnostic[]$ O $U[]$ O $Diagnostic$ O O O $string$ O $any$ O $string$ O $Diagnostic$ O $complex$ O O O O $string$ O O O O $string[]$ O $number$ O $string$ O $string$ O $string[]$ O O $string$ O O O O $any$ O O O O $EmitOutput$ O $LanguageService$ O $EmitOutput$ O $string$ O O $string$ O $EmitOutput$ O $OutputFile[]$ O O O O $string$ O $any$ O $any$ O $any$ O $string$ O $string$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $string$ O $string$ O $any$ O O O $DiagnosticWithLocation[]$ O $string$ O O O $string$ O $string$ $number$ O $string$ O $string$ O $DiagnosticWithLocation[]$ O $LanguageService$ O $DiagnosticWithLocation[]$ O $string$ O $string$ O $string$ O $DiagnosticWithLocation[]$ O O O $void$ O O O $string$ O $string$ O O $string$ O O O
import * as readlineTTY from 's' import * as readlineNoTTY from 's' import * as util from 's' import * as vm from 's' import * as tty from 's' import { Console } from 's' import * as path from 's' import * as child_process from 's' import * as fs from 's' import { completer , acceptedCodes , testSyntacticError , clearHistory , getType , getDiagnostics , getCurrentCode , getDeclarations , } from 's' import { assign } from 's' var Module = require ( 's' ) import 's' const readline = ( process . stdout as tty . WriteStream ) . isTTY ? readlineTTY : readlineNoTTY var options = require ( 's' ) . alias ( 's' , 's' ) . describe ( 's' , 's' ) . alias ( 's' , 's' ) . describe ( 's' , 's' ) . describe ( 's' , "s" ) . describe ( 's' , 's' ) var argv = options . argv var verbose = argv . verbose export var defaultPrompt = 's' , moreLinesPrompt = 's' var multilineBuffer = 's' var rl = createReadLine ( ) function colorize ( line ) { let colorized = 's' let regex : [ RegExp , string ] [ ] = [ [ "s" , 's' ] , [ "s" , 's' ] , [ "s" , 's' ] , [ "s" , 's' ] , [ "s" , 's' ] , [ "s" , 's' ] , [ "s" , 's' ] , [ "s" , 's' ] , [ "s" , 's' ] , [ "s" , 's' ] , [ "s" , 's' ] , [ "s" , 's' ] , [ "s" , 's' ] , [ "s" , 's' ] , ] while ( line !== 's' ) { let start = + Infinity let color = 's' let length = 0 for ( let reg of regex ) { let match = reg [ 0 ] . exec ( line ) if ( match && match . index < start ) { start = match . index color = reg [ 0 ] length = match [ 0 ] . length } } colorized += line . substring ( 0 , start ) if ( color ) { colorized += ( < any > line . substr ( start , length ) ) [ color ] } line = line . substr ( start + length ) } return colorized } function createReadLine ( ) { return readline . createInterface ( { input : process . stdin , output : process . stdout , colorize : colorize , completer ( line ) { let code = multilineBuffer + 's' + line return completer ( code ) as any } } ) } function createContext ( ) { var builtinLibs = require ( 's' ) . _builtinLibs var context ; context = vm . createContext ( ) ; assign ( context , global ) context . console = new Console ( process . stdout ) ; context . global = context ; context . global . global = context ; context . module = new Module ( 's' ) ; try { context . module . filename = path . resolve ( 's' ) ; } catch ( e ) { const dirname = path . dirname ( process . execPath ) ; context . module . filename = path . resolve ( dirname , 's' ) ; } context . module . paths = Module . _nodeModulePaths ( context . module . filename ) context . paths = Module . _resolveLookupPaths ( process . cwd ( ) , context . module ) [ 0 ] var req = context . module . require . bind ( context . module ) context . require = req builtinLibs . forEach ( function ( name ) { Object . defineProperty ( context , name , { get : function ( ) { var lib = require ( name ) ; context [ name ] = lib ; return lib ; } , set : function ( val ) { delete context [ name ] ; context [ name ] = val ; } , configurable : true } ) ; } ) ; return context ; } function printHelp ( ) { console . log ( `template` . blue ) if ( argv . dere ) { console . log ( 's' . blue ) } } var context = createContext ( ) ; function startEvaluate ( code ) { multilineBuffer = 's' let allDiagnostics = getDiagnostics ( code ) if ( allDiagnostics . length ) { console . warn ( allDiagnostics . join ( 's' ) . bold . red ) if ( defaultPrompt != 's' ) { console . log ( 's' ) console . log ( defaultPrompt , 's' . magenta ) console . log ( 's' ) } return repl ( defaultPrompt ) ; } let current = getCurrentCode ( ) if ( verbose ) { console . log ( current . green ) ; } try { var result = vm . runInContext ( current , context ) ; if ( result === undefined && ! argv [ 's' ] ) { console . log ( util . inspect ( result , false , 0 , true ) ) } } catch ( e ) { console . log ( e . stack ) ; } } function waitForMoreLines ( code , indentLevel ) { if ( "s" . test ( code ) ) { console . log ( 's' . yellow ) multilineBuffer = 's' return repl ( defaultPrompt ) } var nextPrompt = 's' ; for ( var i = 0 ; i < indentLevel ; i ++ ) { nextPrompt += moreLinesPrompt ; } multilineBuffer = code repl ( nextPrompt ) ; } function replLoop ( _ , code ) { code = multilineBuffer + 's' + code let diagnostics = testSyntacticError ( code ) if ( diagnostics . length === 0 ) { startEvaluate ( code ) repl ( defaultPrompt ) } else { let openCurly = ( code . match ( "s" ) || [ ] ) . length ; let closeCurly = ( code . match ( "s" ) || [ ] ) . length ; let openParen = ( code . match ( "s" ) || [ ] ) . length ; let closeParen = ( code . match ( "s" ) || [ ] ) . length ; let indentLevel = ( openCurly - closeCurly + openParen - closeParen ) || 0 waitForMoreLines ( code , indentLevel || 0 ) } } function addLine ( line ) { multilineBuffer += 's' + line } function enterPasteMode ( ) { console . log ( 's' . cyan ) console . log ( 's' ) let oldPrompt = defaultPrompt rl . setPrompt ( 's' ) rl . on ( 's' , addLine ) rl . once ( 's' , ( ) => { console . log ( 's' . cyan ) rl . removeListener ( 's' , addLine ) startEvaluate ( multilineBuffer ) rl = createReadLine ( ) repl ( defaultPrompt = oldPrompt ) } ) } function loadFile ( filename ) { try { let filePath = path . resolve ( filename ) let fileContents = fs . readFileSync ( filePath , 's' ) if ( verbose ) { console . log ( `template` . cyan ) console . log ( colorize ( fileContents ) ) console . log ( 's' . cyan ) } startEvaluate ( fileContents ) } catch ( e ) { console . log ( e ) } } function getSource ( name ) { let declarations = getDeclarations ( ) for ( let file in declarations ) { let names = declarations [ file ] if ( names [ name ] ) { let decl = names [ name ] let pager = process . env . PAGER let parent = decl [ 0 ] . parent let text = parent ? parent . getFullText ( ) : 's' if ( ! pager || text . split ( 's' ) . length < 0 ) { console . log ( text ) repl ( defaultPrompt ) return } process . stdin . pause ( ) var tty = require ( 's' ) tty . setRawMode ( false ) var temp = require ( 's' ) let tempFile = temp . openSync ( 's' + Math . random ( ) ) fs . writeFileSync ( tempFile . path , text ) let display = child_process . spawn ( 's' , [ tempFile . path ] , { 's' : [ 0 , 0 , 0 ] } ) display . on ( 's' , function ( ) { temp . cleanupSync ( ) tty . setRawMode ( true ) process . stdin . resume ( ) repl ( defaultPrompt ) } ) return } } console . log ( `template` . yellow ) } export function repl ( prompt ) { 's' ; rl . question ( prompt , function ( code ) { if ( "s" . test ( code ) ) { let identifier = code . split ( 's' ) [ 0 ] if ( ! identifier ) { console . log ( 's' . red ) return repl ( prompt ) } const ret = getType ( identifier , code . indexOf ( 's' ) === 0 ) if ( ret ) { console . log ( colorize ( ret ) ) } else { console . log ( `template` . yellow ) } return repl ( prompt ) } if ( "s" . test ( code ) ) { let identifier = code . split ( 's' ) [ 0 ] if ( ! identifier ) { console . log ( 's' . red ) return repl ( prompt ) } getSource ( identifier ) return } if ( "s" . test ( code ) ) { printHelp ( ) return repl ( prompt ) } if ( "s" . test ( code ) ) { clearHistory ( ) multilineBuffer = 's' context = createContext ( ) return repl ( defaultPrompt ) } if ( "s" . test ( code ) ) { console . log ( colorize ( acceptedCodes ) ) return repl ( prompt ) } if ( "s" . test ( code ) && ! multilineBuffer ) { return enterPasteMode ( ) } if ( "s" . test ( code ) && ! multilineBuffer ) { let filename = code . split ( 's' ) [ 0 ] ; if ( ! filename ) { console . log ( 's' . red ) return repl ( prompt ) } loadFile ( filename ) return repl ( prompt ) } if ( argv . dere && "s" . test ( code ) ) { defaultPrompt = 's' moreLinesPrompt = 's' ; return repl ( defaultPrompt ) } replLoop ( prompt , code ) } ) ; } export function startRepl ( ) { repl ( defaultPrompt ) }	O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $complex$ O $string$ O $DiagnosticWithLocation[]$ O $void$ O $string$ O $string[]$ O $any$ O $complex$ O O O O O O $void$ O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O $any$ O $any$ O O O $string$ O $string$ O O O $string$ O O O $complex$ O O $RegExpConstructor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O $number$ O O $number$ O $string$ O O O $number$ O O O O O $complex$ O $complex$ O O O $RegExpExecArray$ O $complex$ O O O O $RegExpExecArray$ O $string$ O O O $RegExpExecArray$ O $RegExpExecArray$ O $number$ O $number$ O O $number$ O $RegExpExecArray$ O $number$ $string$ O $complex$ O O O $number$ O $RegExpExecArray$ O O O O $number$ O O $string$ O $string$ O $string$ O O O $number$ O O O $string$ O O $string$ O O O O O $string$ O $string$ O $number$ O $number$ O O O $string$ O O $string$ O $string$ O $string$ O $number$ O $number$ O O O $string$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O $string$ O $any$ O $string$ O O O $string$ O $string$ O O O $string$ O $complex$ O $string$ O O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ $any$ O $any$ O O O $string$ O O $ObjectConstructor$ O $any$ O $any$ O $string$ O O $any$ O O O O O O $any$ O $any$ O $string$ O O $any$ O $string$ O O $any$ O O $any$ O O O $void$ O O O $any$ O O O $any$ O $string$ O O $any$ O $string$ O O $any$ O O O $true$ O O O O O O O O O $any$ O O O $void$ O O O $Console$ O $void$ O O O $any$ O O O $any$ O $any$ O O $Console$ O $void$ O O O $any$ O O O O $any$ O $any$ O O O O $void$ O $string$ O O $string$ O O O $string[]$ O $string[]$ O $string$ O O O $string[]$ O $number$ O O $Console$ O $void$ O $string[]$ O $string$ O O O O $string$ O $any$ O O O $string$ O O O O $Console$ O $void$ O O O $Console$ O $void$ O $string$ O O O $any$ O $Console$ O $void$ O O O O O $void$ O $string$ O O O O $any$ O $any$ O O O O $any$ O O $Console$ O $void$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O $any$ O O O O O $Console$ O $void$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O O $Console$ O $void$ O $any$ O $any$ O O O O O $void$ O $string$ O $number$ O O O O O O $boolean$ O $string$ O O O $Console$ O $void$ O O O $any$ O $string$ O O O $void$ O $string$ O O O $string$ O O O O O O $number$ O O O $number$ O $number$ O $number$ O O O $string$ O $string$ O O $string$ O $string$ $void$ O $string$ O O O O $void$ O $string$ O $string$ O O $string$ O $string$ O O O $string$ O $DiagnosticWithLocation[]$ O $DiagnosticWithLocation[]$ O $string$ O O O $DiagnosticWithLocation[]$ O $number$ O O O O $void$ O $string$ O $void$ O $string$ O O O O O $number$ O O $string$ O $complex$ O O O O O O O O $number$ O O $number$ O O $string$ O $complex$ O O O O O O O O $number$ O O $number$ O O $string$ O $complex$ O O O O O O O O $number$ O O $number$ O O $string$ O $complex$ O O O O O O O O $number$ O O $number$ O O $number$ O $number$ O $number$ O $number$ O O O $void$ O $string$ O $number$ O O O O O O $void$ O $string$ O O $string$ O O O $string$ O O $void$ O O O $Console$ O $void$ O O O $any$ O $Console$ O $void$ O O O O $string$ O $string$ $any$ O $any$ O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O O O O O O O $Console$ O $void$ O O O $any$ O $any$ O $any$ O O O $void$ O $void$ O $string$ O $any$ O $any$ O O $void$ O $string$ O $string$ O O O O O $void$ O $string$ O O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $Console$ O $void$ O O O $any$ O $Console$ O $void$ O $string$ O $any$ O O $Console$ O $void$ O O O $any$ O O $void$ O $any$ O O O O $any$ O O $Console$ O $void$ O $any$ O O O O $void$ O $string$ O O O $complex$ O $complex$ O O O O O $string$ O $complex$ O O O $complex$ O $complex$ O $string$ O O O $complex$ O $string$ O O O O $DeclarationName[]$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O $any$ O $complex$ O $DeclarationName[]$ O O O O $complex$ O $string$ O $complex$ O $complex$ O $string$ O O O O O O O $any$ O $string$ O $complex$ O O O O $number$ O O O O $Console$ O $void$ O $string$ O $void$ O $string$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $Math$ O $number$ O O O $any$ O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $void$ O $string$ O O O O O O $Console$ O $void$ O O O $any$ O O O O $void$ O $string$ O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O $boolean$ O $string$ O O O O $string$ O $string$ O $complex$ O O O O O O O O O $string$ O O $Console$ O $void$ O O O $any$ O O $void$ O $string$ O O O $string$ O $string$ O $string$ O $string$ O $number$ O O O O O O O O $string$ O O $Console$ O $void$ O $string$ O $string$ O O O O O $Console$ O $void$ O O O $any$ O O O $void$ O $string$ O O O O O O $boolean$ O $string$ O O O O $string$ O $string$ O $complex$ O O O O O O O O O $string$ O O $Console$ O $void$ O O O $any$ O O $void$ O $string$ O O $void$ O $string$ O O O O O O O $boolean$ O $string$ O O O $void$ O O O $void$ O $string$ O O O O O O $boolean$ O $string$ O O O $void$ O O $string$ O O $any$ O $any$ O O O $void$ O $string$ O O O O O O $boolean$ O $string$ O O O $Console$ O $void$ O $string$ O $string$ O O O $void$ O $string$ O O O O O O $boolean$ O $string$ O O O $string$ O O O $void$ O O O O O O O $boolean$ O $string$ O O O $string$ O O O $string$ O $string$ O $complex$ O O O O O O O O O O $string$ O O $Console$ O $void$ O O O $any$ O O $void$ O $string$ O O $void$ O $string$ O O $void$ O $string$ O O O O $any$ O $any$ O O O $boolean$ O $string$ O O O $string$ O O $string$ O O O O $void$ O $string$ O O $void$ O $string$ O $string$ O O O O O O O $void$ O O O $void$ O $string$ O O
import * as tslib from 's' import { assign } from 's' assign ( global , tslib ) import 's' import { runCode } from 's' import { startRepl } from 's' var options = require ( 's' ) . usage ( `template` ) . alias ( 's' , 's' ) . describe ( 's' , 's' ) . alias ( 's' , 's' ) . describe ( 's' , 's' ) . describe ( 's' , "s" ) var argv = options . argv if ( argv . _ . length === 0 ) { runCode ( argv ) } if ( argv . h ) { options . showHelp ( ) process . exit ( 0 ) } if ( ! argv . dere ) { console . log ( 's' . blue , 's' ) console . log ( 's' ) console . log ( 's' , 's' . blue . bold , 's' ) } else { console . log ( 's' . magenta , "s" ) console . log ( "s" , 's' . magenta . bold , 's' ) } console . log ( 's' ) startRepl ( ) ;	O O O $any$ O O O O $void$ O O O $void$ O $any$ O $any$ O O O O O $void$ O O O O O $void$ O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $void$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $Console$ O $void$ O O O $any$ O O O $Console$ O $void$ O O O $Console$ O $void$ O O O O O $any$ O $any$ O O O O O O $Console$ O $void$ O O O $any$ O O O $Console$ O $void$ O O O O O $any$ O $any$ O O O O $Console$ O $void$ O O O $void$ O O O