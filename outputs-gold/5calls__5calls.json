'js' export default class mixpanelmock { }	O O O O O O O
'js' 's' ; const path = require ( 's' ) ; const fs = require ( 's' ) ; const url = require ( 's' ) ; const appDirectory = fs . realpathSync ( process . cwd ( ) ) ; const resolveApp = relativePath => path . resolve ( appDirectory , relativePath ) ; const envPublicUrl = process . env . PUBLIC_URL ; function ensureSlash ( path , needsSlash ) { const hasSlash = path . endsWith ( 's' ) ; if ( hasSlash && ! needsSlash ) { return path . substr ( path , path . length - 0 ) ; } else if ( ! hasSlash && needsSlash ) { return `template` ; } else { return path ; } } const getPublicUrl = appPackageJson => envPublicUrl || require ( appPackageJson ) . homepage ; function getServedPath ( appPackageJson ) { const publicUrl = getPublicUrl ( appPackageJson ) ; const servedUrl = envPublicUrl || ( publicUrl ? url . parse ( publicUrl ) . href : 's' ) ; return ensureSlash ( servedUrl , true ) ; } module . exports = { dotenv : resolveApp ( 's' ) , appBuild : resolveApp ( 's' ) , appPublic : resolveApp ( 's' ) , appHtml : resolveApp ( 's' ) , appIndexJs : resolveApp ( 's' ) , appPackageJson : resolveApp ( 's' ) , appSrc : resolveApp ( 's' ) , yarnLockFile : resolveApp ( 's' ) , testsSetup : resolveApp ( 's' ) , appNodeModules : resolveApp ( 's' ) , publicUrl : getPublicUrl ( resolveApp ( 's' ) ) , servedPath : getServedPath ( resolveApp ( 's' ) ) , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; const fs = require ( 's' ) ; const path = require ( 's' ) ; const paths = require ( 's' ) ; delete require . cache [ require . resolve ( 's' ) ] ; const NODE_ENV = process . env . NODE_ENV ; if ( ! NODE_ENV ) { throw new Error ( 's' ) ; } var dotenvFiles = [ `template` , `template` , NODE_ENV !== 's' && `template` , paths . dotenv , ] . filter ( Boolean ) ; dotenvFiles . forEach ( dotenvFile => { if ( fs . existsSync ( dotenvFile ) ) { require ( 's' ) . config ( { path : dotenvFile , } ) ; } } ) ; const appDirectory = fs . realpathSync ( process . cwd ( ) ) ; process . env . NODE_PATH = ( process . env . NODE_PATH || 's' ) . split ( path . delimiter ) . filter ( folder => folder && ! path . isAbsolute ( folder ) ) . map ( folder => path . resolve ( appDirectory , folder ) ) . join ( path . delimiter ) ; const REACT_APP = "s" ; function getClientEnvironment ( publicUrl ) { const raw = Object . keys ( process . env ) . filter ( key => REACT_APP . test ( key ) ) . reduce ( ( env , key ) => { env [ key ] = process . env [ key ] ; return env ; } , { NODE_ENV : process . env . NODE_ENV || 's' , PUBLIC_URL : publicUrl , } ) ; const stringified = { 's' : Object . keys ( raw ) . reduce ( ( env , key ) => { env [ key ] = JSON . stringify ( raw [ key ] ) ; return env ; } , { } ) , } ; return { raw , stringified } ; } module . exports = getClientEnvironment ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; module . exports = { process ( ) { return 's' ; } , getCacheKey ( ) { return 's' ; } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; const path = require ( 's' ) ; module . exports = { process ( src , filename ) { return `template` ; } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; const fs = require ( 's' ) ; const tsc = require ( 's' ) ; const tsconfigPath = require ( 's' ) . resolve ( 's' ) ; let compilerConfig = { module : tsc . ModuleKind . CommonJS , jsx : tsc . JsxEmit . React , } if ( fs . existsSync ( tsconfigPath ) ) { try { const tsconfig = require ( tsconfigPath ) ; if ( tsconfig && tsconfig . compilerOptions ) { compilerConfig = tsconfig . compilerOptions ; } } catch ( e ) { } } module . exports = { process ( src , path ) { if ( path . endsWith ( 's' ) || path . endsWith ( 's' ) ) { return tsc . transpile ( src , compilerConfig , path , [ ] ) ; } return src ; } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; if ( typeof Promise === 's' ) { require ( 's' ) . enable ( ) ; window . Promise = require ( 's' ) ; } require ( 's' ) ; require ( 's' ) ; require ( 's' ) ; require ( 's' ) ; require ( 's' ) ; Object . assign = require ( 's' ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' ; import { configure } from 's' ; import * as ReactSixteenAdapter from 's' ; configure ( { adapter : new ReactSixteenAdapter ( ) } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; const autoprefixer = require ( 's' ) ; const path = require ( 's' ) ; const webpack = require ( 's' ) ; const HtmlWebpackPlugin = require ( 's' ) ; const InterpolateHtmlPlugin = require ( 's' ) ; const WatchMissingNodeModulesPlugin = require ( 's' ) ; const ModuleScopePlugin = require ( 's' ) ; const getClientEnvironment = require ( 's' ) ; const paths = require ( 's' ) ; const childProcess = require ( 's' ) ; const publicPath = 's' ; const publicUrl = 's' ; const env = getClientEnvironment ( publicUrl ) ; const gitHash = childProcess . execSync ( 's' ) . toString ( ) . trim ( ) ; module . exports = { mode : 's' , devtool : 's' , entry : [ require . resolve ( 's' ) , require . resolve ( 's' ) , require . resolve ( 's' ) , paths . appIndexJs ] , output : { path : paths . appBuild , pathinfo : true , filename : 's' , chunkFilename : 's' , publicPath : publicPath , devtoolModuleFilenameTemplate => path . resolve ( info . absoluteResourcePath ) } , resolve : { modules : [ 's' , paths . appNodeModules ] . concat ( process . env . NODE_PATH . split ( path . delimiter ) . filter ( Boolean ) ) , extensions : [ 's' , 's' , 's' , 's' , 's' ] , alias : { 's' : 's' } , plugins : [ new ModuleScopePlugin ( paths . appSrc ) ] } , module : { strictExportPresence : true , rules : [ { test : "s" , loader : require . resolve ( 's' ) , enforce : 's' , include : paths . appSrc } , { test : "s" , loader : require . resolve ( 's' ) , enforce : 's' , include : paths . appSrc } , { exclude : [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" ] , loader : require . resolve ( 's' ) , options : { name : 's' } } , { test : [ "s" , "s" , "s" , "s" ] , loader : require . resolve ( 's' ) , options : { limit : 0 , name : 's' } } , { test : "s" , include : paths . appSrc , loader : require . resolve ( 's' ) } , { test : "s" , use : [ require . resolve ( 's' ) , { loader : require . resolve ( 's' ) , options : { importLoaders : 0 } } , { loader : require . resolve ( 's' ) , options : { ident : 's' , plugins : ( ) => [ require ( 's' ) , autoprefixer ( { browsers : [ 's' , 's' , 's' , 's' ] , flexbox : 's' } ) ] } } ] } ] } , plugins : [ new HtmlWebpackPlugin ( { inject : true , template : path . resolve ( 's' ) } ) , new InterpolateHtmlPlugin ( HtmlWebpackPlugin , { PUBLIC_URL : publicUrl , RELEASE_ID : gitHash } ) , new webpack . DefinePlugin ( env . stringified ) , new webpack . HotModuleReplacementPlugin ( ) , new WatchMissingNodeModulesPlugin ( paths . appNodeModules ) , new webpack . IgnorePlugin ( "s" , "s" ) ] , node : { fs : 's' , net : 's' , tls : 's' } , performance : { hints : false } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $info$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; const autoprefixer = require ( 's' ) ; const path = require ( 's' ) ; const webpack = require ( 's' ) ; const HtmlWebpackPlugin = require ( 's' ) ; const ManifestPlugin = require ( 's' ) ; const InterpolateHtmlPlugin = require ( 's' ) ; const ModuleScopePlugin = require ( 's' ) ; const MiniCssExtractPlugin = require ( 's' ) ; const paths = require ( 's' ) ; const getClientEnvironment = require ( 's' ) ; const childProcess = require ( 's' ) ; const publicPath = 's' ; const shouldUseRelativeAssetPaths = publicPath === 's' ; const publicUrl = publicPath . slice ( 0 , - 0 ) ; const env = getClientEnvironment ( publicUrl ) ; const gitHash = childProcess . execSync ( 's' ) . toString ( ) . trim ( ) ; if ( env . stringified [ 's' ] . NODE_ENV !== 's' ) { throw new Error ( 's' ) ; } module . exports = { mode : 's' , bail : true , devtool : 's' , entry : [ require . resolve ( 's' ) , paths . appIndexJs ] , output : { path : paths . appBuild , filename : 's' , chunkFilename : 's' , sourceMapFilename : 's' , publicPath : publicPath , devtoolModuleFilenameTemplate => path . relative ( paths . appSrc , info . absoluteResourcePath ) } , optimization : { minimize : true } , resolve : { modules : [ 's' , paths . appNodeModules ] . concat ( process . env . NODE_PATH . split ( path . delimiter ) . filter ( Boolean ) ) , extensions : [ 's' , 's' , 's' , 's' , 's' ] , alias : { 's' : 's' } , plugins : [ new ModuleScopePlugin ( paths . appSrc ) ] } , module : { strictExportPresence : true , rules : [ { test : "s" , loader : require . resolve ( 's' ) , enforce : 's' , include : paths . appSrc } , { test : "s" , loader : require . resolve ( 's' ) , enforce : 's' , include : paths . appSrc } , { test : "s" , use : [ MiniCssExtractPlugin . loader , 's' , 's' , 's' ] } , { exclude : [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" ] , loader : require . resolve ( 's' ) , options : { name : 's' } } , { test : [ "s" , "s" , "s" , "s" ] , loader : require . resolve ( 's' ) , options : { limit : 0 , name : 's' } } , { test : "s" , include : paths . appSrc , loader : require . resolve ( 's' ) } ] } , plugins : [ new InterpolateHtmlPlugin ( HtmlWebpackPlugin , { PUBLIC_URL : publicUrl , RELEASE_ID : gitHash } ) , new HtmlWebpackPlugin ( { inject : true , template : paths . appHtml , minify : { removeComments : true , collapseWhitespace : true , removeRedundantAttributes : true , useShortDoctype : true , removeEmptyAttributes : true , removeStyleLinkTypeAttributes : true , keepClosingSlash : true , minifyJS : true , minifyCSS : true , minifyURLs : true } } ) , new webpack . DefinePlugin ( env . stringified ) , new ManifestPlugin ( { fileName : 's' } ) , new webpack . IgnorePlugin ( "s" , "s" ) , new MiniCssExtractPlugin ( { filename : 's' , chunkFilename : 's' } ) ] , node : { fs : 's' , net : 's' , tls : 's' } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $info$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; const errorOverlayMiddleware = require ( 's' ) ; const noopServiceWorkerMiddleware = require ( 's' ) ; const config = require ( 's' ) ; const paths = require ( 's' ) ; const protocol = process . env . HTTPS === 's' ? 's' : 's' ; const host = process . env . HOST || 's' ; module . exports = function ( proxy , allowedHost ) { return { disableHostCheck : ! proxy || process . env . DANGEROUSLY_DISABLE_HOST_CHECK === 's' , compress : true , clientLogLevel : 's' , contentBase : paths . appPublic , watchContentBase : true , hot : true , publicPath : config . output . publicPath , quiet : true , watchOptions : { ignored : "s" , } , https : protocol === 's' , host : host , overlay : false , historyApiFallback : { disableDotRule : true , } , public : allowedHost , proxy , setup ( app ) { app . use ( errorOverlayMiddleware ( ) ) ; app . use ( noopServiceWorkerMiddleware ( ) ) ; } , } ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; var gulp = require ( 's' ) , sass = require ( 's' ) , autoprefixer = require ( 's' ) , imagemin = require ( 's' ) , util = require ( 's' ) , browserify = require ( 's' ) , 0 = require ( 's' ) , buffer = require ( 's' ) , source = require ( 's' ) , uglify = require ( 's' ) , http_server = require ( 's' ) , connect_logger = require ( 's' ) , spawn = require ( 's' ) . spawn , mocha = require ( 's' ) , path = require ( 's' ) ; var SRC = { html : 's' , scss : 's' , img : 's' , js : 's' , extra : 's' , locales : 's' } ; var DEST = { html : 's' , css : 's' , img : 's' , js : 's' , locales : 's' } ; gulp . task ( 's' , function ( ) { gulp . src ( SRC . html + 's' ) . pipe ( gulp . dest ( DEST . html ) ) ; } ) ; gulp . task ( 's' , function ( ) { gulp . watch ( `template` , [ 's' ] ) ; } ) ; gulp . task ( 's' , function ( cb ) { function alwaysServeIndex ( req , res , next ) { if ( ! ( path . extname ( req . url ) ) ) { req . url = "s" ; } next ( ) ; } var server = new http_server . HttpServer ( { root : 's' , before : [ connect_logger ( ) , alwaysServeIndex ] } ) ; server . listen ( 0 , function ( ) { util . log ( 's' ) ; cb ( ) ; } ) ; } ) ; gulp . task ( 's' , function ( ) { gulp . src ( `template` ) . pipe ( sass ( { outputStyle : 's' } ) . on ( 's' , sass . logError ) ) . pipe ( autoprefixer ( 's' ) ) . pipe ( gulp . dest ( DEST . css ) ) ; } ) ; gulp . task ( 's' , function ( ) { gulp . watch ( `template` , [ 's' ] ) ; } ) ; gulp . task ( 's' , function ( ) { gulp . src ( SRC . img + 's' ) . pipe ( imagemin ( ) ) . pipe ( gulp . dest ( DEST . img ) ) ; } ) ; gulp . task ( 's' , function ( ) { gulp . watch ( SRC . img + 's' ) ; } ) ; gulp . task ( 's' , function ( ) { var b = browserify ( { entries : `template` , debug : true , transform : [ [ 0 , { global : true } ] ] } ) ; return b . bundle ( ) . pipe ( source ( 's' ) ) . pipe ( buffer ( ) ) . pipe ( gulp . dest ( DEST . js ) ) ; } ) ; gulp . task ( 's' , function ( ) { var b = browserify ( { entries : `template` , debug : false , transform : [ [ 0 , { global : true } ] ] } ) ; return b . bundle ( ) . pipe ( source ( 's' ) ) . pipe ( buffer ( ) ) . pipe ( uglify ( ) ) . pipe ( gulp . dest ( DEST . js ) ) ; } ) ; gulp . task ( 's' , function ( ) { gulp . watch ( `template` , [ 's' ] ) ; } ) ; gulp . task ( 's' , function ( ) { gulp . src ( SRC . extra + 's' ) . pipe ( gulp . dest ( DEST . html ) ) ; } ) ; gulp . task ( 's' , function ( ) { gulp . src ( SRC . locales + 's' ) . pipe ( gulp . dest ( DEST . locales ) ) ; } ) ; function runKarmaTests ( { singleRun , configFile } = { } ) { return new Promise ( ( resolve , reject ) => { const karmaArguments = [ 's' ] ; if ( configFile ) { karmaArguments . push ( configFile ) ; } if ( singleRun ) { karmaArguments . push ( 's' ) ; } const karma = spawn ( path . join ( __dirname , 's' , 's' , 's' ) , karmaArguments , { shell : true , cwd : __dirname , stdio : 's' } ) ; karma . on ( 's' , code => { if ( code ) { reject ( new util . PluginError ( 's' , `template` ) ) ; return ; } resolve ( ) ; } ) ; } ) ; } gulp . task ( 's' , function ( ) { return runKarmaTests ( { singleRun : true } ) ; } ) ; gulp . task ( 's' , function ( ) { return runKarmaTests ( { singleRun : false } ) ; } ) ; gulp . task ( 's' , function ( ) { const mochaOptions = { reporter : 's' , timeout : 0 } ; if ( process . argv . includes ( 's' ) ) { const grepValue = process . argv [ process . argv . indexOf ( 's' ) + 0 ] ; mochaOptions . grep = new RegExp ( grepValue ) ; } return gulp . src ( [ 's' , 's' ] ) . pipe ( mocha ( mochaOptions ) ) ; } ) ; gulp . task ( 's' , [ 's' ] , function ( ) { return runKarmaTests ( { configFile : 's' } ) ; } ) ; gulp . task ( 's' , function ( ) { const eslint = require ( 's' ) ; const linter = new eslint . CLIEngine ( ) ; const report = linter . executeOnFiles ( [ 's' ] ) ; report . results . forEach ( result => { result . messages . forEach ( message => { if ( message . ruleId === 's' ) { message . message = 's' ; } } ) ; } ) ; process . stdout . write ( linter . getFormatter ( ) ( report . results ) ) ; if ( report . errorCount ) { throw new util . PluginError ( 's' , 's' ) ; } } ) ; gulp . task ( 's' , [ 's' , 's' ] ) ; gulp . task ( 's' , [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] ) ; gulp . task ( 's' , [ 's' , 's' , 's' , 's' , 's' , 's' ] ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = function ( config ) { config . set ( { basePath : 's' , frameworks : [ 's' , 's' ] , files : [ 's' , 's' , 's' ] , exclude : [ 's' ] , preprocessors : { 's' : [ 's' ] , } , browserify : { debug : true , transform : [ [ 's' , { ignore : [ "s" ] , instrumenterConfig : { embedSource : true } } ] , [ 's' , { global : true } ] ] , } , reporters : [ 's' , 's' ] , port : 0 , colors : true , logLevel : config . LOG_INFO , autoWatch : true , browsers : [ 's' ] , singleRun : false , concurrency : Infinity , } ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = function ( configuration ) { const browserConfiguration = { sauce_chrome : { base : 's' , browserName : 's' , platform : 's' , version : 's' } , sauce_firefox : { base : 's' , browserName : 's' , version : 's' } , sauce_edge : { base : 's' , browserName : 's' , platform : 's' , version : 's' } , sauce_ie : { base : 's' , browserName : 's' , platform : 's' , version : 's' } , 0 : { base : 's' , browserName : 's' , platform : 's' , version : 's' } , 0 : { base : 's' , browserName : 's' , platform : 's' , version : 's' } , sauce_safari : { base : 's' , browserName : 's' , version : 's' } , 0 : { base : 's' , browserName : 's' , platform : 's' , version : 's' } , } ; const browsers = Object . keys ( browserConfiguration ) ; require ( 's' ) ( configuration ) ; configuration . set ( { sauceLabs : { testName : 's' } , customLaunchers : browserConfiguration , browsers , frameworks : [ 's' , 's' ] , reporters : [ 's' , 's' ] , singleRun : true , browserify : { debug : true , transform : [ [ 's' , { global : true } ] ] } , captureTimeout : 0 , browserNoActivityTimeout : 0 } ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' importScripts ( 's' ) ;	O O O O O O
'js' importScripts ( 's' ) ;	O O O O O O
'js' const axios = require ( 's' ) ; const createTestCafe = require ( 's' ) ; let testcafe = null ; const browsers = [ [ 's' , 's' ] , [ 's' , 's' ] , [ 's' ] ] ; const runTest = browser => { console . log ( 's' ) ; return createTestCafe ( 's' , 0 , 0 ) . then ( tc => { testcafe = tc ; const runner = testcafe . createRunner ( ) ; return runner . src ( [ 's' ] ) . browsers ( browser ) . run ( { speed : 0 } ) ; } ) . then ( async failedCount => { console . log ( 's' + failedCount ) ; await testcafe . close ( ) ; return { failedCount } ; } ) ; } ; const runAllBrowsers = async ( ) => { let failedCount = 0 ; for ( const browser of browsers ) { const result = await runTest ( browser ) ; failedCount += result . failedCount ; } return { failedCount } ; } ; const 0 = ( ) => { axios . get ( 's' ) . then ( resp => runAllBrowsers ( ) ) . then ( result => { console . log ( `template` ) ; process . exit ( result . failedCount === 0 ? 0 : 0 ) ; } ) . catch ( err => { console . log ( 's' , err ) ; process . exit ( 0 ) ; } ) ; } ; 0 ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; process . env . NODE_ENV = 's' ; process . on ( 's' , err => { throw err ; } ) ; require ( 's' ) ; const path = require ( 's' ) ; const chalk = require ( 's' ) ; const fs = require ( 's' ) ; const webpack = require ( 's' ) ; const config = require ( 's' ) ; const paths = require ( 's' ) ; const checkRequiredFiles = require ( 's' ) ; const formatWebpackMessages = require ( 's' ) ; const printHostingInstructions = require ( 's' ) ; const FileSizeReporter = require ( 's' ) ; const measureFileSizesBeforeBuild = FileSizeReporter . measureFileSizesBeforeBuild ; const printFileSizesAfterBuild = FileSizeReporter . printFileSizesAfterBuild ; const useYarn = fs . existsSync ( paths . yarnLockFile ) ; if ( ! checkRequiredFiles ( [ paths . appHtml , paths . appIndexJs ] ) ) { process . exit ( 0 ) ; } measureFileSizesBeforeBuild ( paths . appBuild ) . then ( previousFileSizes => { fs . emptyDirSync ( paths . appBuild ) ; copyPublicFolder ( ) ; return build ( previousFileSizes ) ; } ) . then ( ( { stats , previousFileSizes , warnings } ) => { if ( warnings . length ) { console . log ( chalk . yellow ( 's' ) ) ; console . log ( warnings . join ( 's' ) ) ; console . log ( 's' + chalk . underline ( chalk . yellow ( 's' ) ) + 's' ) ; console . log ( 's' + chalk . cyan ( 's' ) + 's' ) ; } else { console . log ( chalk . green ( 's' ) ) ; } console . log ( 's' ) ; printFileSizesAfterBuild ( stats , previousFileSizes , 's' ) ; console . log ( ) ; const appPackage = require ( paths . appPackageJson ) ; const publicUrl = paths . publicUrl ; const publicPath = config . output . publicPath ; const buildFolder = path . relative ( process . cwd ( ) , paths . appBuild ) ; printHostingInstructions ( appPackage , publicUrl , publicPath , buildFolder , useYarn ) ; } , err => { console . log ( chalk . red ( 's' ) ) ; console . log ( ( err . message || err ) + 's' ) ; process . exit ( 0 ) ; } ) ; function build ( previousFileSizes ) { console . log ( 's' ) ; let compiler = webpack ( config ) ; return new Promise ( ( resolve , reject ) => { compiler . run ( ( err , stats ) => { if ( err ) { return reject ( err ) ; } const messages = formatWebpackMessages ( stats . toJson ( { } , true ) ) ; if ( messages . errors . length ) { return reject ( new Error ( messages . errors . join ( 's' ) ) ) ; } if ( process . env . CI && messages . warnings . length ) { console . log ( chalk . yellow ( 's' + 's' ) ) ; return reject ( new Error ( messages . warnings . join ( 's' ) ) ) ; } return resolve ( { stats , previousFileSizes , warnings : messages . warnings } ) ; } ) ; } ) ; } function copyPublicFolder ( ) { fs . copySync ( paths . appPublic , paths . appBuild , { dereference : true , filter => file !== paths . appHtml } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $file$ O O O O O O O O O O
'js' 's' ; const cssRootDir = 's' ; const fileFilter = 's' ; let files = [ ] ; process . on ( 's' , err => { throw err ; } ) ; process . env . NODE_ENV = 's' ; require ( 's' ) ; const fs = require ( 's' ) ; const path = require ( 's' ) ; const home = process . cwd ( ) ; const rootFolder = path . join ( home , cssRootDir ) ; const fileList = ( dir , filt = 's' ) => fs . readdirSync ( dir ) . reduce ( ( files , file ) => fs . statSync ( path . join ( dir , file ) ) . isDirectory ( ) ? files . concat ( fileList ( path . join ( dir , file ) ) ) : files . concat ( path . join ( dir , file ) ) , [ ] ) . filter ( f => { if ( f && f . endsWith ( filt ) ) return f } ) ; const deleteFiles = ( files ) => { files . forEach ( file => { fs . unlinkSync ( file ) ; } ) ; } const doDelete = ( ) => { files = fileList ( rootFolder , fileFilter ) ; deleteFiles ( files ) ; } try { doDelete ( ) ; if ( files . length > 0 ) { console . log ( 's' , files ) ; } else { console . log ( 's' ) ; } process . exit ( ) ; } catch ( e ) { console . error ( 's' , e ) ; process . exit ( 0 ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; process . on ( 's' , err => { throw err ; } ) ; process . env . NODE_ENV = 's' ; require ( 's' ) ; const fs = require ( 's' ) ; const chalk = require ( 's' ) ; const webpack = require ( 's' ) ; const WebpackDevServer = require ( 's' ) ; const clearConsole = require ( 's' ) ; const checkRequiredFiles = require ( 's' ) ; const { choosePort , createCompiler , prepareProxy , prepareUrls , } = require ( 's' ) ; const openBrowser = require ( 's' ) ; const paths = require ( 's' ) ; const config = require ( 's' ) ; const createDevServerConfig = require ( 's' ) ; const useYarn = fs . existsSync ( paths . yarnLockFile ) ; const isInteractive = process . stdout . isTTY ; if ( ! checkRequiredFiles ( [ paths . appHtml , paths . appIndexJs ] ) ) { process . exit ( 0 ) ; } const DEFAULT_PORT = parseInt ( process . env . PORT , 0 ) || 0 ; const HOST = process . env . HOST || 's' ; choosePort ( HOST , DEFAULT_PORT ) . then ( port => { if ( port == null ) { return ; } const protocol = process . env . HTTPS === 's' ? 's' : 's' ; const appName = require ( paths . appPackageJson ) . name ; const urls = prepareUrls ( protocol , HOST , port ) ; const compiler = createCompiler ( webpack , config , appName , urls , useYarn ) ; const proxySetting = require ( paths . appPackageJson ) . proxy ; const proxyConfig = prepareProxy ( proxySetting , paths . appPublic ) ; const serverConfig = createDevServerConfig ( proxyConfig , urls . lanUrlForConfig ) ; const devServer = new WebpackDevServer ( compiler , serverConfig ) ; devServer . listen ( port , HOST , err => { if ( err ) { return console . log ( err ) ; } if ( isInteractive ) { clearConsole ( ) ; } console . log ( chalk . cyan ( 's' ) ) ; openBrowser ( urls . localUrlForBrowser ) ; } ) ; [ 's' , 's' ] . forEach ( function ( sig ) { process . on ( sig , function ( ) { devServer . close ( ) ; process . exit ( ) ; } ) ; } ) ; } ) . catch ( err => { if ( err && err . message ) { console . log ( err . message ) ; } process . exit ( 0 ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; process . env . NODE_ENV = 's' ; process . env . PUBLIC_URL = 's' ; process . on ( 's' , err => { throw err ; } ) ; require ( 's' ) ; const jest = require ( 's' ) ; const argv = process . argv . slice ( 0 ) ; if ( process . env . CI ) { argv . push ( 's' ) ; } if ( ! process . env . CI && argv . indexOf ( 's' ) < 0 ) { argv . push ( 's' ) ; } jest . run ( argv ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const APP_NAME = 's' ; export const APP_URL = 's' ; export const API_URL = 's' ; export const ISSUES_API_URL = `template` ; export const REPS_API_URL = `template` ; export const REPORT_API_URL = `template` ; export const STATS_API_URL = `template` ; export const PROFILE_API_URL = `template` ; export const DONATIONS_API_URL = `template` ; export const MIDTERMS_API_URL = `template` ; export const GROUP_API_URL = `template` ; export const CONTACTS_API_URL = `template` ; export const REMINDER_API_URL = `template` ; export const DONATE_URL = 's' ; export const WRITER_APPLY_URL = 's' ; export const CODE_PROJECT_URL = 's' ; export const HELP_SET_LOCATION = 's' ; export const HELP_OTHER_REPRESENTATIVES = 's' ; export const SHARE_BUCKET_URL = 's' ; const callbackURI = ( ) => { if ( window . location . host . includes ( 's' ) ) { return 's' ; } else if ( window . location . host . includes ( 's' ) ) { return 's' ; } return 's' ; } ; export const 0 = { domain : 's' , clientId : 's' , audience : 's' , callbackUri : callbackURI ( ) , poweredURL : 's' , popupAuth : false } ; export const zipCodeRegex = "s" ; export const cacheTimeout = { default : 0 * 0 * 0 * 0 , groups : 0 * 0 * 0 * 0 } ; export const contact = { email : 's' , github : 's' , twitter : 's' , facebook : 's' , apps : 's' } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegExp$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Contact } from 's' ; export class ContactList { public location : string ; public representatives : Contact [ ] ; constructor ( ) { this . location = 's' ; this . representatives = [ ] ; } public senateReps ( ) : Contact [ ] { return this . representatives . filter ( contact => contact . area === 's' ) ; } public houseRep ( ) : Contact [ ] { const contacts : Contact [ ] = [ ] ; const houseRep = this . representatives . find ( contact => contact . area === 's' ) ; if ( houseRep ) { contacts . push ( houseRep ) ; } return contacts ; } public governor ( ) : Contact [ ] { return this . representatives . filter ( contact => contact . area === 's' ) ; } public stateUpper ( ) : Contact [ ] { return this . representatives . filter ( contact => contact . area === 's' ) ; } public stateLower ( ) : Contact [ ] { return this . representatives . filter ( contact => contact . area === 's' ) ; } public secState ( ) : Contact [ ] { return this . representatives . filter ( contact => contact . area === 's' ) ; } public attyGeneral ( ) : Contact [ ] { return this . representatives . filter ( contact => contact . area === 's' ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Issue , Category } from 's' ; import { Contact } from 's' ; import { ContactList } from 's' ; import { Outcome , OutcomeButton , LocationFetchType , FieldOffice , CategoryMap , GeolocationPosition , CountData } from 's' ; export { Issue , Category , Contact , ContactList , Outcome , OutcomeButton , LocationFetchType , FieldOffice , CategoryMap , GeolocationPosition , CountData } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Outcome , Contact , ContactList } from 's' ; export class Issue { public id : number ; public name : string ; public contactType : string ; public contactAreas : string [ ] ; public reason : string ; public script : string ; public categories : Category [ ] ; public active : boolean ; public createdAt : string ; public slug : string ; public outcomeModels : Outcome [ ] ; public link : string ; public linkTitle : string ; public stats : IssueStats ; public slugOrID ( ) { if ( this . slug !== 's' ) { return this . slug ; } return this . id . toString ( ) ; } public numberOfContacts ( contactList ) { return this . filteredContacts ( contactList ) . length ; } public currentContact ( contactList , contactIndex ) : Contact | undefined { const contacts = this . filteredContacts ( contactList ) ; if ( contactIndex <= contacts . length ) { return contacts [ contactIndex ] ; } return undefined ; } public filteredContacts ( contactList ) : Contact [ ] { const contacts : Contact [ ] = [ ] ; for ( const contactArea of this . contactAreas ) { if ( contactArea === 's' ) { contacts . push ( ... contactList . senateReps ( ) ) ; } else if ( contactArea === 's' ) { contacts . push ( ... contactList . houseRep ( ) ) ; } else if ( contactArea === 's' ) { contacts . push ( ... contactList . governor ( ) ) ; } else if ( contactArea === 's' ) { contacts . push ( ... contactList . stateUpper ( ) ) ; } else if ( contactArea === 's' ) { contacts . push ( ... contactList . stateLower ( ) ) ; } else if ( contactArea === 's' ) { contacts . push ( ... contactList . secState ( ) ) ; } else if ( contactArea === 's' ) { contacts . push ( ... contactList . attyGeneral ( ) ) ; } } return contacts ; } public listItemLabel ( ) { switch ( this . contactType ) { case 's' : return 's' + this . countLabel ( ) ; case 's' : return 's' + this . countLabel ( ) ; default : return 's' ; } } public countLabel ( ) { if ( this . stats . calls < 0 ) { return 's' ; } switch ( this . contactType ) { case 's' : return 's' + this . stats . calls + 's' ; case 's' : return 's' + this . stats . calls + 's' ; default : return 's' ; } } } export interface IssueStats { completion : number ; calls : number ; } export interface Category { name : string ; } export const mockIssue = Object . assign ( new Issue ( ) , { id : 0 , name : 's' , contactType : 's' , contactAreas : [ ] , reason : 's' , script : 's' , active : true , createdAt : 's' , slug : 's' , outcomeModels : [ ] , link : 's' , linkTitle : 's' , stats : { completion : 0 , calls : 0 } } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $ContactList$ O O O O O O O O O O O O O O O O $ContactList$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ContactList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Issue , Category } from 's' ; export interface Outcome { label : string ; status : string ; } export interface VoterContact { id : string ; name : string ; location : string ; phone : string ; } export class CategoryMap { category : Category ; issues : Issue [ ] ; } export type Party = 's' | 's' | 's' | 's' ; export interface FieldOffice { city : string ; phone : string ; } export interface UserStat { all : string [ ] ; contactedCount : number ; voiceMailCount : number ; unavailableCount : number ; } export enum LocationFetchType { CACHED_ADDRESS = 's' , BROWSER_GEOLOCATION = 's' , IP_INFO = 's' } export interface GeolocationPosition { longitude : number | undefined ; latitude : number | undefined ; } export interface IssueData { issues : Issue [ ] ; } export interface GroupIssues { splitDistrict : boolean ; invalidAddress : boolean ; normalizedLocation : string | undefined ; divisions : string [ ] ; issues : Issue [ ] ; } export interface CountData { count : number ; } export interface IpInfoData { ip : string ; hostname : string ; city : string ; region : string ; country : string ; loc : string ; org : string ; postal : string ; } export interface DonationGoal { goal : Donations ; } export interface Donations { count : number ; amount : number ; total : number ; kind : string ; } export interface OutcomeButton { title : string ; emoji : string ; key : string ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Party , FieldOffice } from 's' ; export class Contact { id : string ; name : string ; phone : string ; photoURL ? : string ; party : Party ; state : string ; reason : string ; area ? : string ; field_offices ? : FieldOffice [ ] ; public contactDisplay ( ) { if ( this . partyStateAbbr ( ) !== 's' ) { return this . name + 's' + this . partyStateAbbr ( ) + 's' ; } return this . name ; } public partyStateAbbr ( ) { if ( this . party && this . state !== 's' ) { const partyLetter = this . party . substring ( 0 , 0 ) ; return partyLetter . toUpperCase ( ) + 's' + this . state . toUpperCase ( ) ; } return 's' ; } } export const mockContact = Object . assign ( new Contact ( ) , { id : 0 , name : 's' , phone : 's' , photoURL : undefined , party : 's' , state : 's' , reason : 's' , area : undefined , field_offices : [ ] } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { About , AboutTranslatable } from 's' ; import AboutPage from 's' ; export { About , AboutTranslatable , AboutPage } ;	O O O O O O O O O O O O O O O O O O O O O O O
import Call from 's' ; import { CallHeader } from 's' ; import ContactDetails from 's' ; import { ContactOffices } from 's' ; import CallPage , { CallPageWithRouter } from 's' ; import Outcomes from 's' ; import { Script } from 's' ; import IssueLink from 's' ; import NoContactSplitDistrict from 's' ; import SupportOutcomes from 's' ; export { Call , CallHeader , CallPage , CallPageWithRouter , ContactDetails , ContactOffices , Outcomes , Script , IssueLink , NoContactSplitDistrict , SupportOutcomes } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Done , DoneTranslatable } from 's' ; import DonePage from 's' ; export { Done , DoneTranslatable , DonePage } ;	O O O O O O O O O O O O O O O O O O O O O O O
import Faq from 's' ; import FaqPage from 's' ; export { Faq , FaqPage } ;	O O O O O O O O O O O O O O O O O
import 0 from 's' ; import HomePage from 's' ; import HomeExtras from 's' ; export { HomePage , 0 , HomeExtras } ;	O O O O O O O O O O O O O O O O O O O O O O O O
import { IssuesList } from 's' ; import IssuesListItem from 's' ; import MoreIssuesPage from 's' ; import { MoreIssues } from 's' ; export { IssuesList , IssuesListItem , MoreIssuesPage , MoreIssues } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import Layout from 's' ; import Navigation from 's' ; import SidebarHeader from 's' ; import Sidebar from 's' ; import Footer from 's' ; import { Header } from 's' ; export { Layout , Navigation , SidebarHeader , Sidebar , Footer , Header } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Location } from 's' ; export { Location } ;	O O O O O O O O O O O O
import { MyImpact , MyImpactTranslatable } from 's' ; import MyImpactPage from 's' ; export { MyImpact , MyImpactTranslatable , MyImpactPage } ;	O O O O O O O O O O O O O O O O O O O O O O O
import { Phonebanks } from 's' ; import PhonebanksPage from 's' ; export { Phonebanks , PhonebanksPage } ;	O O O O O O O O O O O O O O O O O O O
import { Postcards } from 's' ; import PostcardsPage from 's' ; export { Postcards , PostcardsPage } ;	O O O O O O O O O O O O O O O O O O O
import Privacy from 's' ; import PrivacyPage from 's' ; export { Privacy , PrivacyPage } ;	O O O O O O O O O O O O O O O O O
import Promotion from 's' ; import CallCount from 's' ; import { 0 } from 's' ; export { Promotion , CallCount , 0 } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O
import { RemoteDataAction } from 's' ; import { Action } from 's' ; import { Issue , ContactList } from 's' ; export enum RemoteDataActionType { GET_ISSUES = 's' , GET_CONTACTS = 's' , GET_CALL_TOTAL = 's' } export interface RemoteDataAction extends Action { type : RemoteDataActionType ; payload ? : { } ; } export interface IssuesAction extends RemoteDataAction { type : RemoteDataActionType . GET_ISSUES ; payload : Issue [ ] ; } export interface ContactsAction extends RemoteDataAction { type : RemoteDataActionType . GET_CONTACTS ; payload : ContactList ; } export interface CallCountAction extends RemoteDataAction { type : RemoteDataActionType . GET_CALL_TOTAL ; payload : number ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CallCountAction , IssuesAction , RemoteDataActionType } from 's' ; import { Issue , ContactList } from 's' ; import { ContactsAction } from 's' ; export const issuesActionCreator = ( issues : Issue [ ] ) : IssuesAction => { return { type : RemoteDataActionType . GET_ISSUES , payload : issues } ; } ; export const callCountActionCreator = ( callTotal ) : CallCountAction => { return { type : RemoteDataActionType . GET_CALL_TOTAL , payload : callTotal } ; } ; export const contactsActionCreator = ( contacts ) : ContactsAction => { return { payload : contacts , type : RemoteDataActionType . GET_CONTACTS } ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O $ContactList$ O O O O O O O O O O O O O O O O O O O O
import { Reducer } from 's' ; import { Issue , ContactList , Contact } from 's' ; import { RemoteDataAction , RemoteDataActionType } from 's' ; export const defaultRemoteDataState = { issues : [ ] , inactiveIssues : [ ] , contacts : new ContactList ( ) , callTotal : 0 , errorMessage : 's' } ; export interface RemoteDataState { issues : Issue [ ] ; inactiveIssues : Issue [ ] ; contacts : ContactList ; callTotal : number ; errorMessage : string ; } export const remoteDataReducer < RemoteDataState > = ( state = { } as RemoteDataState , action ) : RemoteDataState => { switch ( action . type ) { case RemoteDataActionType . GET_ISSUES : let activeIssues : Issue [ ] = [ ] ; let inactiveIssues : Issue [ ] = [ ] ; if ( action && action . payload ) { let issues = action . payload as Issue [ ] ; activeIssues = issues . filter ( item => { return item . active === true ; } ) . map ( item => Object . assign ( new Issue ( ) , item ) ) ; inactiveIssues = issues . filter ( item => { return item . active === false ; } ) . map ( item => Object . assign ( new Issue ( ) , item ) ) ; } const issuesState = Object . assign ( { } , state , { issues : activeIssues , inactiveIssues : inactiveIssues } ) ; return issuesState ; case RemoteDataActionType . GET_CONTACTS : const contactList = action . payload as ContactList ; contactList . representatives = contactList . representatives . map ( contact => Object . assign ( new Contact ( ) , contact ) ) ; return Object . assign ( { } , state , { contacts : contactList } ) ; case RemoteDataActionType . GET_CALL_TOTAL : return Object . assign ( { } , state , { callTotal : action . payload } ) ; default : return state ; } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RemoteDataState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Reducer$ O O O O O $RemoteDataState$ O O O O O O $RemoteDataAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Action } from 's' ; import { LocationAction } from 's' ; import { LocationFetchType } from 's' ; export enum LocationActionType { LOCATION_CLEAR = 's' , LOCATION_SET = 's' , CACHE_CITY = 's' , NEW_LOCATION_LOOKUP = 's' , SET_LOCATION_FETCH_TYPE = 's' , SET_SPLIT_DISTRICT = 's' , SET_INVALID_ADDRESS = 's' } export interface LocationAction extends Action { type : LocationActionType ; payload ? : { } ; } export interface LocationSetAction extends LocationAction { type : LocationActionType . LOCATION_SET ; payload : string ; } export interface LocationClearedAction extends LocationAction { type : LocationActionType . LOCATION_CLEAR ; } export interface CacheCityAction extends LocationAction { type : LocationActionType . CACHE_CITY ; payload : string | undefined ; } export interface SetLocationFetchTypeAction extends LocationAction { type : LocationActionType . SET_LOCATION_FETCH_TYPE ; payload : LocationFetchType ; } export interface NewLocationLookupAction extends LocationAction { type : LocationActionType . NEW_LOCATION_LOOKUP ; payload : string ; } export interface SetSplitDistrictAction extends LocationAction { type : LocationActionType . SET_SPLIT_DISTRICT ; } export interface SetInvalidAddressAction extends LocationAction { type : LocationActionType . SET_INVALID_ADDRESS ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { LocationClearedAction , LocationSetAction , LocationActionType , SetLocationFetchTypeAction , SetSplitDistrictAction } from 's' ; import { LocationFetchType } from 's' ; import { SetInvalidAddressAction } from 's' ; export function setLocation ( address ) { return { type : LocationActionType . LOCATION_SET , payload : address } ; } export function clearAddress ( ) { return { type : LocationActionType . LOCATION_CLEAR } ; } export function setCachedCity ( city : string | undefined ) { return { type : LocationActionType . CACHE_CITY , payload : city } ; } export function setLocationFetchType ( fetchType ) { return { type : LocationActionType . SET_LOCATION_FETCH_TYPE , payload : fetchType } ; } export function setSplitDistrict ( isDistrictSplit ) { return { type : LocationActionType . SET_SPLIT_DISTRICT , payload : isDistrictSplit } ; } export function setInvalidAddress ( invalidAddress ) { return { type : LocationActionType . SET_INVALID_ADDRESS , payload : invalidAddress } ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LocationSetAction$ O $string$ O O O O O O O O O O O O O O O O O O $LocationClearedAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SetLocationFetchTypeAction$ O $LocationFetchType$ O O O O O O O O O O O O O O O O O O $SetSplitDistrictAction$ O $boolean$ O O O O O O O O O O O O O O O O O O $SetInvalidAddressAction$ O $boolean$ O O O O O O O O O O O O O O O O
import { Reducer } from 's' ; import { LocationAction , LocationActionType } from 's' ; import { LocationFetchType } from 's' ; export interface LocationState { address : string ; cachedCity : string ; splitDistrict : boolean ; invalidAddress : boolean ; locationFetchType : LocationFetchType | undefined ; } const initialState = { address : 's' , cachedCity : 's' , splitDistrict : false , invalidAddress : false , locationFetchType : undefined } ; export const locationStateReducer < LocationState > = ( state = initialState , action ) : LocationState => { switch ( action . type ) { case LocationActionType . LOCATION_CLEAR : return Object . assign ( { } , state , { address : 's' , cachedCity : 's' } ) ; case LocationActionType . LOCATION_SET : return Object . assign ( { } , state , { address : action . payload } ) ; case LocationActionType . CACHE_CITY : return Object . assign ( { } , state , { cachedCity : action . payload } ) ; case LocationActionType . SET_SPLIT_DISTRICT : return Object . assign ( { } , state , { splitDistrict : action . payload } ) ; case LocationActionType . SET_INVALID_ADDRESS : return Object . assign ( { } , state , { invalidAddress : action . payload } ) ; case LocationActionType . SET_LOCATION_FETCH_TYPE : return Object . assign ( { } , state , { locationFetchType : action . payload } ) ; default : return state ; } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LocationState$ O O O O O O O O O O O O O O O O O O O O O O O O O $Reducer$ O O O O O $LocationState$ O O O $LocationAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export { LocationAction , LocationActionType , LocationClearedAction , LocationSetAction , SetLocationFetchTypeAction , SetSplitDistrictAction , CacheCityAction , NewLocationLookupAction } from 's' ; export { setLocation , clearAddress , setCachedCity , setLocationFetchType , setSplitDistrict } from 's' ; export { LocationState , locationStateReducer } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Action } from 's' ; import { CallStateAction } from 's' ; export enum CallStateActionType { CURRENT_ISSUE_SELECTED = 's' , COMPLETE_ISSUE = 's' , NEXT_CONTACT = 's' , SET_CONTACT_IDS = 's' , SET_SHOW_FIELD_OFFICE_NUMBERS = 's' , CLEAR_CONTACT_INDEXES = 's' } export interface CallStateAction extends Action { type : CallStateActionType ; payload ? : { } ; } export interface CurrentIssueAction extends CallStateAction { type : CallStateActionType . CURRENT_ISSUE_SELECTED ; payload : string ; } export interface CompleteIssueAction extends CallStateAction { type : CallStateActionType . COMPLETE_ISSUE ; payload ? : string ; } export interface NextContact extends CallStateAction { type : CallStateActionType . NEXT_CONTACT ; } export interface SetContactIdsAction extends CallStateAction { type : CallStateActionType . SET_CONTACT_IDS ; payload : string [ ] ; } export interface SetShowFieldOfficeNumbers extends CallStateAction { type : CallStateActionType . SET_SHOW_FIELD_OFFICE_NUMBERS ; payload : boolean ; } export interface ClearContactIndexesAction extends CallStateAction { type : CallStateActionType . CLEAR_CONTACT_INDEXES ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CurrentIssueAction , CompleteIssueAction , NextContact , CallStateActionType , ClearContactIndexesAction } from 's' ; export const selectIssueActionCreator = ( issueId ) : CurrentIssueAction => { return { type : CallStateActionType . CURRENT_ISSUE_SELECTED , payload : issueId } ; } ; export const completeIssueActionCreator = ( issueId ? ) : CompleteIssueAction => { return { type : CallStateActionType . COMPLETE_ISSUE , payload : issueId } ; } ; export const moveToNextActionCreator = ( ) : NextContact => { return { type : CallStateActionType . NEXT_CONTACT } ; } ; export const clearContactIndexes = ( ) : ClearContactIndexesAction => { return { type : CallStateActionType . CLEAR_CONTACT_INDEXES } ; } ;	O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Reducer } from 's' ; import { CallStateAction , CallStateActionType } from 's' ; export interface CallState { currentIssueId : string ; contactIndexes : { [ key ] : number } ; completedIssueIds : string [ ] ; } export const callStateReducer < CallState > = ( state = { } as CallState , action ) : CallState => { switch ( action . type ) { case CallStateActionType . CURRENT_ISSUE_SELECTED : return Object . assign ( { } , state , { currentIssueId : action . payload } ) ; case CallStateActionType . COMPLETE_ISSUE : let newCompletedIssues : string [ ] = [ ] ; if ( state . completedIssueIds ) { newCompletedIssues = [ ... state . completedIssueIds ] ; } const payload = action . payload as string ; if ( payload ) { newCompletedIssues . push ( payload ) ; } else { newCompletedIssues . push ( state . currentIssueId ) ; } let newState = { ... state } ; newState . completedIssueIds = newCompletedIssues ; return newState ; case CallStateActionType . NEXT_CONTACT : let newIndexes = { ... state . contactIndexes } ; if ( ! newIndexes [ state . currentIssueId ] ) { newIndexes [ state . currentIssueId ] = 0 ; } else { newIndexes [ state . currentIssueId ] ++ ; } return { ... state , contactIndexes : newIndexes } ; case CallStateActionType . CLEAR_CONTACT_INDEXES : return { ... state , contactIndexes : { } } ; default : return state ; } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $Reducer$ O O O O O $CallState$ O O O O O O $CallStateAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export { CallStateAction , CallStateActionType , CurrentIssueAction , NextContact , SetContactIdsAction , SetShowFieldOfficeNumbers , CompleteIssueAction , ClearContactIndexesAction } from 's' ; export { completeIssueActionCreator , moveToNextActionCreator , selectIssueActionCreator , clearContactIndexes } from 's' ; export { callStateReducer , CallState } from 's' ; export { OutcomeData , submitOutcome } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Action } from 's' ; import { UserStatsAction , UserStatsState , UserContactEvent } from 's' ; export enum UserStatsActionType { SET_USER_STATS = 's' , ADD_CALL_EVENT = 's' , SET_UPLOADED = 's' } export interface UserStatsAction extends Action { type : UserStatsActionType ; payload ? : { } ; } export interface SetUserStatsAction extends UserStatsAction { type : UserStatsActionType . SET_USER_STATS ; payload : UserStatsState ; } export interface AddCallEventAction extends UserStatsAction { type : UserStatsActionType . ADD_CALL_EVENT ; payload : UserContactEvent ; } export interface SetUploadedAction extends UserStatsAction { type : UserStatsActionType . SET_UPLOADED ; payload : number ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { SetUserStatsAction , AddCallEventAction , UserStatsState , UserContactEvent , UserStatsActionType } from 's' ; import { SetUploadedAction } from 's' ; export const setUserStatsActionCreator = ( userStats ) : SetUserStatsAction => { return { type : UserStatsActionType . SET_USER_STATS , payload : userStats } ; } ; export const addCallEventActionCreator = ( callEvent ) : AddCallEventAction => { return { type : UserStatsActionType . ADD_CALL_EVENT , payload : callEvent } ; } ; export const setUploadedActionCreator = ( time ) : SetUploadedAction => { return { type : UserStatsActionType . SET_UPLOADED , payload : time } ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserStatsState$ O O O O O O O O O O O O O O O O O O O O O O O O O $UserContactEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O
import { Reducer } from 's' ; import { UserStatsAction , UserStatsActionType } from 's' ; export enum UserContactEventType { UNAVAILABLE = 's' , VOICEMAIL = 's' , CONTACT = 's' , SKIP = 's' } export type UserOutcomeResult = UserContactEventType | string ; export interface UserContactEvent { contactid : string ; issueid : string ; result : UserOutcomeResult ; time : number ; uploaded : boolean ; } export interface UserStatsState { all : UserContactEvent [ ] ; unavailable : number ; voicemail : number ; contact : number ; } export const defaultUserStatsState = { all : [ ] , unavailable : 0 , voicemail : 0 , contact : 0 } ; export const userStatsReducer < UserStatsState > = ( state = defaultUserStatsState as UserStatsState , action ) : UserStatsState => { switch ( action . type ) { case UserStatsActionType . SET_USER_STATS : { const userStats = action . payload as UserStatsState ; const all : UserContactEvent [ ] = [ ... userStats . all ] ; const newState = { ... userStats , all : all } ; return newState ; } case UserStatsActionType . SET_UPLOADED : { const eventTime = action . payload as number ; let newEvents = state . all ; for ( let i = 0 ; i < state . all . length ; i ++ ) { if ( state . all [ i ] . time === eventTime ) { newEvents [ i ] . uploaded = true ; } } const newState = { ... state , all : newEvents } ; return newState ; } case UserStatsActionType . ADD_CALL_EVENT : { const callEvent = action . payload as UserContactEvent ; if ( callEvent . result === UserContactEventType . SKIP ) { return state ; } const createdState = { ... state , all : [ ... state . all ] } ; let addEvent = false ; switch ( callEvent . result ) { case UserContactEventType . UNAVAILABLE : { createdState . unavailable = createdState . unavailable + 0 ; addEvent = true ; break ; } case UserContactEventType . VOICEMAIL : { createdState . voicemail = createdState . voicemail + 0 ; addEvent = true ; break ; } case UserContactEventType . CONTACT : { createdState . contact = createdState . contact + 0 ; addEvent = true ; break ; } default : { addEvent = true ; break ; } } if ( addEvent ) { createdState . all . unshift ( callEvent ) ; } return createdState ; } default : { return state ; } } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserStatsState$ O O O O O O O O O O O O O O O O O O O O O O $Reducer$ O O O O O $UserStatsState$ O O O O O $UserStatsAction$ O O O O O O O O O O O O O O O O O O O $UserStatsState$ O O O O O O O O O O O O O O O O O O O O O O $UserStatsState$ O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserStatsState$ O O O O O O O O O O O O O O O O O O O O O $UserContactEvent$ O O O O O O O O O O O O O O O O O O O O O O O $UserStatsState$ O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export { UserStatsAction , UserStatsActionType , SetUserStatsAction , AddCallEventAction } from 's' ; export { setUserStatsActionCreator , addCallEventActionCreator } from 's' ; export { userStatsReducer , UserStatsState , UserContactEvent , UserOutcomeResult , UserContactEventType } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Action } from 's' ; import { UserProfile } from 's' ; export enum UserStateActionType { SET_AUTH_TOKEN = 's' , SET_USER_PROFILE = 's' , CLEAR_USER_PROFILE = 's' } export interface UserStateAction extends Action { type : UserStateActionType ; payload ? : { } ; } export interface SetAuthToken extends UserStateAction { type : UserStateActionType . SET_AUTH_TOKEN ; payload : string | undefined ; } export interface SetUserProfile extends UserStateAction { type : UserStateActionType . SET_USER_PROFILE ; payload : UserProfile | undefined ; } export interface ClearUserProfile extends UserStateAction { type : UserStateActionType . CLEAR_USER_PROFILE ; } export const setAuthTokenActionCreator = ( idToken ? ) : SetAuthToken => { return { type : UserStateActionType . SET_AUTH_TOKEN , payload : idToken } ; } ; export const setProfileActionCreator = ( profile ? ) : SetUserProfile => { return { type : UserStateActionType . SET_USER_PROFILE , payload : profile } ; } ; export const clearProfileActionCreator = ( ) : ClearUserProfile => { return { type : UserStateActionType . CLEAR_USER_PROFILE } ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O $UserProfile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Reducer } from 's' ; import { UserStateAction , UserStateActionType } from 's' ; import { UserCallDetails } from 's' ; export class UserAuth { accessToken : string ; idToken : string ; jwtToken : string ; expiration : Date ; } export interface UserState { idToken ? : string ; profile ? : UserProfile ; } export interface UserProfile { name : string ; sub : string ; exp : number ; picture : string ; callDetails ? : UserCallDetails ; 's' ? : string ; 's' ? : string ; } const initialState = { idToken : undefined , profile : undefined } ; export const userStateReducer < UserState > = ( state = initialState as UserState , action ) : UserState => { switch ( action . type ) { case UserStateActionType . SET_AUTH_TOKEN : { const idToken = action . payload as string | undefined ; const newState = { ... state , idToken : idToken } ; return newState ; } case UserStateActionType . SET_USER_PROFILE : { const profile = action . payload as UserProfile | undefined ; const newState = { ... state , profile : profile } ; return newState ; } case UserStateActionType . CLEAR_USER_PROFILE : { const newState = { ... state , profile : undefined , idToken : undefined } ; return newState ; } default : { return state ; } } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserState$ O O O O O O O O O O O O O $Reducer$ O O O O O $UserState$ O O O O O $UserStateAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserState$ O O O O O O O O O O O O O O O O O O O O O $UserState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export { UserStateAction , UserStateActionType , setAuthTokenActionCreator , setProfileActionCreator , clearProfileActionCreator } from 's' ; export { userStateReducer , UserState , UserAuth , UserProfile } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import storage from 's' ; import getStoredState from 's' ; import { ApplicationState } from 's' ; import { LocationState , locationStateReducer } from 's' ; import { CallState , callStateReducer } from 's' ; import { RemoteDataState , remoteDataReducer } from 's' ; import { UserStatsState , userStatsReducer } from 's' ; import { UserState , userStateReducer } from 's' ; import { persistCombineReducers } from 's' ; import { defaultRemoteDataState } from 's' ; import { defaultUserStatsState } from 's' ; export enum OutcomeType { UNAVAILABLE = 's' , VOICEMAIL = 's' , CONTACT = 's' , SKIP = 's' } export interface ApplicationState { remoteDataState : RemoteDataState ; callState : CallState ; locationState : LocationState ; userStatsState : UserStatsState ; userState : UserState ; } export const DefaultApplicationState = { remoteDataState : defaultRemoteDataState , callState : { } as CallState , locationState : { } as LocationState , userStatsState : defaultUserStatsState , userState : { } as UserState } ; export type ApplicationStateKeyType = keyof ApplicationState ; type ApplicationStateKeyTypes = { [ K in ApplicationStateKeyType ] : ApplicationStateKeyType } ; export const ApplicationStateKey = { locationState : 's' , remoteDataState : 's' , callState : 's' , userStatsState : 's' , userState : 's' } ; const 0 = { whitelist : [ ApplicationStateKey . locationState , ApplicationStateKey . userStatsState , ApplicationStateKey . userState , ApplicationStateKey . callState ] } ; const config = { key : 's' , debug : true , storage , whitelist : [ ApplicationStateKey . locationState , ApplicationStateKey . userStatsState , ApplicationStateKey . userState , ApplicationStateKey . callState ] , getStoredState : getStoredState ( 0 ) } ; const rootReducer = persistCombineReducers ( config , { remoteDataState : remoteDataReducer , callState : callStateReducer , locationState : locationStateReducer , userStatsState : userStatsReducer , userState : userStateReducer } ) ; export default rootReducer ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ApplicationState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ApplicationStateKeyTypes$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { applyMiddleware , createStore , Store , compose , Middleware } from 's' ; import { persistStore , Persistor } from 's' ; import rootReducer , { ApplicationState , DefaultApplicationState } from 's' ; import thunk from 's' ; const middlewares : Middleware [ ] = [ thunk ] ; export let persistor = { } as Persistor ; export let store = { } as Store < ApplicationState > ; export default initialState => { store = createStore ( rootReducer , DefaultApplicationState , compose ( applyMiddleware ( ... middlewares ) , typeof window === 's' && typeof window [ 's' ] !== 's' ? window [ 's' ] ( ) : f => f ) ) as Store < ApplicationState > ; persistor = persistStore ( store ) ; return store ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as Constants from 's' ; import { Issue } from 's' ; import { RemoteDataState } from 's' ; import { store } from 's' ; import { UserState } from 's' ; export const formatLocationForBackEnd = ( location : string | null | undefined ) : string => { if ( ! location ) { return 's' ; } const zipRegex = Constants . zipCodeRegex ; const geolocationRegex = "s" ; if ( zipRegex . test ( location ) ) { return location ; } else if ( geolocationRegex . test ( location ) ) { const match = geolocationRegex . exec ( location ) ; if ( match ) { return `template` ; } } return 's' ; } ; export const isNumber = ( maybeNumber : number | string ) => { const num = Number ( maybeNumber ) ; return isNaN ( num ) ? 0 : num ; } ; export const formatNumber = ( unformattedNumber : number | string ) => { const num = isNumber ( unformattedNumber ) ; if ( window [ 's' ] && typeof Intl . NumberFormat === 's' ) { return num . toLocaleString ( ) ; } else { return num . toString ( ) . replace ( "s" , 's' ) ; } } ; export const getIssue = ( remoteDataState , issueId ) : Issue | undefined => { if ( remoteDataState . issues ) { const currentActiveIssue = remoteDataState . issues . find ( i => i . id . toString ( ) === issueId || i . slug === issueId ) ; if ( currentActiveIssue ) { return currentActiveIssue ; } } if ( remoteDataState . inactiveIssues ) { const currentInactiveIssue = remoteDataState . inactiveIssues . find ( i => i . id . toString ( ) === issueId || i . slug === issueId ) ; if ( currentInactiveIssue ) { return currentInactiveIssue ; } } return undefined ; } ; export const isIssueComplete = ( issueID ) : boolean => { let state = store . getState ( ) ; if ( state . callState && state . callState . completedIssueIds ) { return ( state . callState . completedIssueIds . find ( ( issueId ) => issueID === issueId ) !== undefined ) ; } return false ; } ; export const removeURLParameter = ( url , parameter ) : string => { const urlparts = url . split ( 's' ) ; if ( urlparts . length >= 0 ) { const prefix = encodeURIComponent ( parameter ) + 's' ; let pars = urlparts [ 0 ] . split ( "s" ) ; for ( let i = pars . length ; i -- > 0 ; ) { if ( pars [ i ] . lastIndexOf ( prefix , 0 ) !== - 0 ) { pars . splice ( i , 0 ) ; } } return urlparts [ 0 ] + ( pars . length > 0 ? 's' + pars . join ( 's' ) : 's' ) ; } return url ; } ; interface IntercomProfile { user_id : string ; name : string ; email ? : string ; } export const intercomUserFromUserState = ( userState ) : IntercomProfile | undefined => { if ( userState . profile ) { let user = { user_id : userState . profile . sub , name : userState . profile . name , email : undefined } ; if ( userState . profile [ 's' ] ) { user . email = userState . profile [ 's' ] ; } return user ; } return undefined ; } ; export const intercomID = ( ) : string => { if ( process . env . NODE_ENV === 's' ) { return 's' ; } return 's' ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegExp$ O O O O O O $RegExp$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RemoteDataState$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserState$ O O O O O O O O O O O O O O O $IntercomProfile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Dispatch } from 's' ; import { ApplicationState } from 's' ; import { completeIssueActionCreator , moveToNextActionCreator } from 's' ; import { addCallEventActionCreator , UserContactEventType } from 's' ; import * as apiServices from 's' ; import { formatLocationForBackEnd } from 's' ; import * as ReactGA from 's' ; import { UserOutcomeResult } from 's' ; export interface OutcomeData { outcome : UserOutcomeResult ; issueId : string ; numberContactsLeft : number ; location ? : string ; contactId : string ; via ? : string ; userId ? : string ; } export function submitOutcome ( data ) { return ( dispatch < ApplicationState > , getState : ( ) => ApplicationState ) => { const state = getState ( ) ; const location = state . locationState . address ; data . location = formatLocationForBackEnd ( location ) ; if ( state . userState . profile !== undefined ) { data . userId = state . userState . profile . sub ; } const ga = ReactGA . ga ( ) ; if ( data . outcome === 's' ) { ga ( 's' , 's' , 's' , 's' , 's' ) ; } else { ga ( 's' , 's' , 's' , 's' , data . outcome ) ; } if ( data . outcome !== UserContactEventType . SKIP ) { const viaParameter = window . location . host === 's' ? 's' : 's' ; data . via = viaParameter ; const userContactData = { result : data . outcome , contactid : data . contactId || 's' , issueid : data . issueId , time : Date . now ( ) , uploaded : data . userId ? true : false } ; dispatch ( addCallEventActionCreator ( userContactData ) ) ; apiServices . postOutcomeData ( data ) . catch ( e => console . error ( 's' , e ) ) ; } if ( data . numberContactsLeft <= 0 ) { return dispatch ( completeIssueActionCreator ( ) ) ; } else { return dispatch ( moveToNextActionCreator ( ) ) ; } } ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OutcomeData$ O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { OutcomeData } from 's' ; import axios from 's' ; import * as querystring from 's' ; import { ContactList , CountData , Issue , Contact } from 's' ; import * as Constants from 's' ; import { UserContactEvent } from 's' ; import { UserCallDetails } from 's' ; import { store } from 's' ; const prepareHeaders = ( ) : Headers => { const state = store . getState ( ) ; let headers = { 's' : 's' } ; if ( state . userState . idToken ) { headers . Authorization = 's' + state . userState . idToken ; } return headers ; } ; interface Headers { Authorization ? : string ; 's' : string ; } export const getAllIssues = ( ) : Promise < Issue [ ] > => { const headers = prepareHeaders ( ) ; return axios . get ( Constants . ISSUES_API_URL , { headers : headers } ) . then ( response => Promise . resolve ( response . data ) ) . catch ( e => Promise . reject ( e ) ) ; } ; export const noLocationError = Error ( 's' ) ; export const getContacts = ( ) : Promise < ContactList > => { const state = store . getState ( ) ; const location = state . locationState . address ; if ( location === 's' || location === undefined ) { return Promise . reject ( noLocationError ) ; } const headers = prepareHeaders ( ) ; return axios . get < ContactResponse > ( `template` , { headers : headers } ) . then ( result => { const contactList = new ContactList ( ) ; contactList . location = result . data . location ; contactList . representatives = result . data . representatives ; return Promise . resolve ( contactList ) ; } ) . catch ( error => { return Promise . reject ( error ) ; } ) ; } ; interface ContactResponse { location : string ; representatives : Contact [ ] ; } export const getCountData = ( ) : Promise < CountData > => { return axios . get ( `template` ) . then ( response => Promise . resolve ( response . data ) ) . catch ( e => Promise . reject ( e ) ) ; } ; interface BackfillData { stats : BackfillOutcome [ ] ; } interface BackfillOutcome { issueID : string ; contactID : string ; result : string ; time : string ; } export const postBackfillOutcomes = ( data : UserContactEvent [ ] , idToken ) => { let postData = { stats : [ ] } ; for ( let i = 0 ; i < data . length ; i ++ ) { let timeInSeconds = Math . round ( data [ i ] . time / 0 ) ; let outcome = { issueID : data [ i ] . issueid , contactID : data [ i ] . contactid , result : data [ i ] . result , time : timeInSeconds . toString ( ) } ; postData . stats . push ( outcome ) ; } return axios . post ( `template` , postData , { headers : { Authorization : 's' + idToken , 's' : 's' } } ) . then ( response => { return Promise . resolve ( null ) ; } ) . catch ( e => Promise . reject ( e ) ) ; } ; export interface RemoteUserStats { stats : CallStats ; weeklyStreak : number ; } export interface CallStats { contact : number ; voicemail : number ; unavailable : number ; } export const getUserStats = ( idToken ) => { return axios . get ( `template` , { headers : { Authorization : 's' + idToken , 's' : 's' } } ) . then ( response => { let userData = response . data as RemoteUserStats ; return Promise . resolve ( userData ) ; } ) . catch ( e => Promise . reject ( e ) ) ; } ; export const postOutcomeData = ( data ) => { const postData = querystring . stringify ( { location : data . location , result : data . outcome , contactid : data . contactId , issueid : data . issueId , via : data . via , userid : data . userId } ) ; return axios . post ( `template` , postData , { headers : { 's' : 's' } } ) . then ( response => { return Promise . resolve ( null ) ; } ) . catch ( e => Promise . reject ( e ) ) ; } ; export const getUserCallDetails = ( idToken ) => { let today = new Date ( ) ; today . setDate ( today . getDate ( ) - 0 ) ; const dateString = today . getFullYear ( ) + 's' + ( 's' + ( today . getMonth ( ) + 0 ) ) . slice ( - 0 ) + 's' + ( 's' + today . getDate ( ) ) . slice ( - 0 ) ; return axios . get ( `template` , { headers : { Authorization : 's' + idToken } } ) . then ( response => { let profile = response . data as UserCallDetails ; return Promise . resolve ( profile ) ; } ) . catch ( e => Promise . reject ( e ) ) ; } ; export const postPhoneRemind = ( phone ) : Promise < Boolean > => { const postData = querystring . stringify ( { phone : phone , ref : 's' } ) ; return axios . post ( Constants . REMINDER_API_URL , postData ) . then ( response => Promise . resolve ( true ) ) . catch ( e => Promise . reject ( e ) ) ; } ; export const postEmail = ( email , sub , idToken ) : Promise < Boolean > => { const subscribe = sub ? 's' : 's' ; const postData = querystring . stringify ( { email : email , subscribe : subscribe } ) ; return axios . post ( Constants . PROFILE_API_URL , postData , { headers : { Authorization : 's' + idToken } } ) . then ( response => Promise . resolve ( true ) ) . catch ( e => Promise . reject ( e ) ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Headers$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O $BackfillData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BackfillOutcome$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OutcomeData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import bugsnag from 's' ; import bugsnagReact from 's' ; let bugsnagClient ; if ( process . env . JEST_WORKER_ID ) { bugsnagClient = { } ; } else { bugsnagClient = bugsnag ( { apiKey : 's' , notifyReleaseStages : [ 's' ] } ) ; bugsnagClient . use ( bugsnagReact , React ) ; } export default bugsnagClient ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Dispatch } from 's' ; import * as querystring from 's' ; import { CountData , Issue , ContactList } from 's' ; import { getAllIssues , getCountData , postBackfillOutcomes , getUserCallDetails , getContacts , noLocationError } from 's' ; import { setCachedCity } from 's' ; import { issuesActionCreator , callCountActionCreator } from 's' ; import { clearContactIndexes } from 's' ; import { ApplicationState } from 's' ; import { LoginService , UserProfile } from 's' ; import { 0 } from 's' ; import { UserContactEvent } from 's' ; import { setUploadedActionCreator } from 's' ; import { clearProfileActionCreator , setAuthTokenActionCreator , setProfileActionCreator } from 's' ; import { setInvalidAddress , setLocation } from 's' ; import { store } from 's' ; import { contactsActionCreator } from 's' ; import { removeURLParameter } from 's' ; import bugsnagClient from 's' ; export const getIssuesIfNeeded = ( ) => { const state = store . getState ( ) ; if ( ! state . remoteDataState . issues || state . remoteDataState . issues . length === 0 ) { getAllIssues ( ) . then ( ( response : Issue [ ] ) => { store . dispatch ( issuesActionCreator ( response ) ) ; } ) . catch ( error => { console . error ( `template` , error ) ; } ) ; } } ; export const getContactsIfNeeded = ( force ) => { const state = store . getState ( ) ; if ( state . remoteDataState . contacts . representatives . length === 0 || force ) { getContacts ( ) . then ( ( contactList ) => { store . dispatch ( contactsActionCreator ( contactList ) ) ; store . dispatch ( setCachedCity ( contactList . location ) ) ; store . dispatch ( setInvalidAddress ( false ) ) ; } ) . catch ( error => { if ( error === noLocationError ) { } else { console . error ( 's' , error ) ; bugsnagClient . notify ( Error ( 's' + state . locationState . address ) ) ; store . dispatch ( setInvalidAddress ( true ) ) ; } } ) ; } } ; export const fetchCallCount = ( ) => { return getCountData ( ) . then ( ( response ) => { store . dispatch ( callCountActionCreator ( response . count ) ) ; } ) . catch ( error => console . error ( `template` , error ) ) ; } ; export const fetchDonations = ( ) => { return ( dispatch < ApplicationState > , getState : ( ) => ApplicationState ) => { return ; } ; } ; export const uploadStatsIfNeeded = ( ) => { return ( dispatch < ApplicationState > , getState : ( ) => ApplicationState ) => { const state = getState ( ) ; if ( state . userState . idToken ) { let unuploadedStats : UserContactEvent [ ] = [ ] ; for ( let i = 0 ; i < state . userStatsState . all . length ; i ++ ) { if ( ! state . userStatsState . all [ i ] . uploaded ) { unuploadedStats . push ( state . userStatsState . all [ i ] ) ; dispatch ( setUploadedActionCreator ( state . userStatsState . all [ i ] . time ) ) ; } } if ( unuploadedStats . length > 0 ) { postBackfillOutcomes ( unuploadedStats , state . userState . idToken ) ; } } } ; } ; export interface UserCallDetails { stats : UserStats ; weeklyStreak : number ; firstCallTime : number ; calls : DailyCallReport [ ] ; } export interface DailyCallReport { date : string ; issues : IssueSummary [ ] ; } export interface IssueSummary { count : number ; issue_name : string ; } export interface UserStats { voicemail : number ; unavailable : number ; contact : number ; } export const getProfileInfo = async ( ) : Promise < UserProfile > => { const state = store . getState ( ) ; if ( state . userState . profile && state . userState . idToken ) { const callDetails = await getUserCallDetails ( state . userState . idToken ) ; let filledProfile = state . userState . profile ; filledProfile . callDetails = callDetails ; return filledProfile ; } else { } return Promise . reject ( 's' ) ; } ; export const startup = ( ) => { const state = store . getState ( ) ; store . dispatch ( clearContactIndexes ( ) ) ; const auth = new LoginService ( 0 ) ; if ( state . userState . profile && state . userState . idToken ) { auth . checkAndRenewSession ( state . userState . profile , state . userState . idToken ) . then ( authResponse => { store . dispatch ( setAuthTokenActionCreator ( authResponse . authToken ) ) ; store . dispatch ( setProfileActionCreator ( authResponse . userProfile ) ) ; } ) . catch ( error => { store . dispatch ( clearProfileActionCreator ( ) ) ; } ) ; } fetchCallCount ( ) ; let replacedLocation = false ; let q = querystring . parse ( location . search . substr ( 0 ) ) ; const newLocation = q [ 's' ] ; if ( newLocation !== undefined && newLocation . length > 0 ) { store . dispatch ( setLocation ( newLocation ) ) ; replacedLocation = true ; } if ( replacedLocation ) { window . history . replaceState ( { } , document . title , removeURLParameter ( location . href , 's' ) ) ; } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ContactList$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CountData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dispatch$ O O O O O O O O O O O O O O $ApplicationState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export { IssuesAction , RemoteDataAction , RemoteDataActionType , CallCountAction } from 's' ; export { issuesActionCreator , callCountActionCreator } from 's' ; export { RemoteDataState , remoteDataReducer } from 's' ; export { startup , getIssuesIfNeeded , fetchCallCount } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Issue } from 's' ; import { RemoteDataState } from 's' ; import { formatLocationForBackEnd , formatNumber , getIssue } from 's' ; class Data { constructor ( private pactual : string | number | null | undefined , private pexpected ) { } get actual ( ) { return this . pactual ; } get expected ( ) { return this . pexpected ; } } test ( 's' , ( ) => { const testData : Data [ ] = [ new Data ( 's' , 's' ) , new Data ( 's' , 's' ) , new Data ( 's' , 's' ) , new Data ( undefined , 's' ) , new Data ( null , 's' ) , new Data ( 's' , 's' ) , new Data ( 's' , 's' ) , new Data ( 's' , 's' ) , new Data ( 's' , 's' ) , new Data ( 's' , 's' ) , new Data ( 's' , 's' ) , new Data ( 's' , 's' ) ] ; testData . forEach ( data => formatLocationForBackEndTester ( data ) ) ; } ) ; test ( 's' , ( ) => { const testData : Data [ ] = [ new Data ( 's' , 's' ) , new Data ( 's' , 's' ) , new Data ( 's' , 's' ) ] ; testData . forEach ( data => formatLocationForBackEndTester ( data ) ) ; } ) ; test ( 's' , ( ) => { const testData : Data [ ] = [ new Data ( 's' , 's' ) , new Data ( 's' , 's' ) , new Data ( 's' , 's' ) ] ; testData . forEach ( data => formatLocationForBackEndTester ( data ) ) ; } ) ; const formatLocationForBackEndTester = ( data ) => { const results = formatLocationForBackEnd ( data . actual as | string | null | undefined ) ; expect ( results ) . toEqual ( data . expected ) ; } ; test ( 's' , ( ) => { const testData : Data [ ] = [ new Data ( 0 , 's' ) , new Data ( 's' , 's' ) , new Data ( 0 , 's' ) , new Data ( 0 , 's' ) , new Data ( 's' , 's' ) , new Data ( 's' , 's' ) , new Data ( undefined , 's' ) , new Data ( null , 's' ) , new Data ( 's' , 's' ) ] ; testData . forEach ( data => formatNumberTester ( data ) ) ; } ) ; const formatNumberTester = ( data ) => { const results = formatNumber ( data . actual as number | string ) ; expect ( results ) . toEqual ( data . expected ) ; } ; test ( 's' , ( ) => { const id = 's' ; let issue = Object . assign ( { } , new Issue ( ) , { id , inactive : false } ) ; let issues : Issue [ ] = [ issue ] ; let inactiveIssues : Issue [ ] = [ Object . assign ( { } , new Issue ( ) , { id : 's' , inactive : true } ) ] ; let state = Object . assign ( { } , { } as RemoteDataState , { issues , inactiveIssues } ) ; let result = getIssue ( state , id ) as Issue ; expect ( result . id ) . toBe ( id ) ; } ) ; test ( 's' , ( ) => { const id = 's' ; let issue = Object . assign ( { } , new Issue ( ) , { id : 's' , inactive : false } ) ; let issues : Issue [ ] = [ issue ] ; let inactiveIssues : Issue [ ] = [ Object . assign ( { } , new Issue ( ) , { id , inactive : true } ) ] ; let state = Object . assign ( { } , { } as RemoteDataState , { issues , inactiveIssues } ) ; let result = getIssue ( state , id ) as Issue ; expect ( result . id ) . toBe ( id ) ; } ) ; test ( 's' , ( ) => { const id = 's' ; const activeId = 's' ; let issue = Object . assign ( { } , new Issue ( ) , { id : activeId , inactive : false } ) ; let issues : Issue [ ] = [ issue ] ; const inactiveId = 's' ; let inactiveIssues : Issue [ ] = [ Object . assign ( { } , new Issue ( ) , { id : inactiveId , inactive : true } ) ] ; let state = Object . assign ( { } , { } as RemoteDataState , { issues , inactiveIssues } ) ; let result = getIssue ( state , id ) ; expect ( result ) . toBeUndefined ( ) ; } ) ; test ( 's' , ( ) => { const id = 's' ; let state = { } as RemoteDataState ; let result = getIssue ( state , id ) ; expect ( result ) . toBeUndefined ( ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Data$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Data$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Issue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Issue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import Terms from 's' ; import TermsPage from 's' ; export { Terms , TermsPage } ;	O O O O O O O O O O O O O O O O O
import * as React from 's' ; import { CallState } from 's' ; const defaultCallState = { currentIssueId : 's' , contactIndexes : { } , completedIssueIds : [ ] } ; export const callStateContext = React . createContext < CallState > ( defaultCallState ) ;	O O O O O O O O O O O O O O O $CallState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import EventEmitter = require ( 's' ) ; interface EventManager { ee : EventEmitter ; } const eventManager = { ee : new EventEmitter ( ) } ; export const eventContext = React . createContext < EventManager > ( eventManager ) ;	O O O O O O O O O O O O O O O O O O O O O O O O $EventManager$ O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import { LocationState } from 's' ; const defaultLocationState = { address : 's' , cachedCity : 's' , splitDistrict : false , invalidAddress : false , locationFetchType : undefined } ; export const locationStateContext = React . createContext < LocationState > ( defaultLocationState ) ;	O O O O O O O O O O O O O O O $LocationState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import { RemoteDataState } from 's' ; import { ContactList } from 's' ; const defaultRemoteState = { issues : [ ] , inactiveIssues : [ ] , contacts : new ContactList ( ) , callTotal : 0 , errorMessage : 's' } ; export const remoteStateContext = React . createContext < RemoteDataState > ( defaultRemoteState ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import { UserState } from 's' ; const defaultUserState = { idToken : undefined , profile : undefined } ; export const userStateContext = React . createContext < UserState > ( defaultUserState ) ;	O O O O O O O O O O O O O O O $UserState$ O O O O O O O O O O O O O O O O O O O O O O O O O
import * as React from 's' ; import { UserStatsState } from 's' ; const defaultUserStats = { all : [ ] , unavailable : 0 , voicemail : 0 , contact : 0 } ; export const userStatsContext = React . createContext < UserStatsState > ( defaultUserStats ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export { remoteStateContext } from 's' ; export { callStateContext } from 's' ; export { locationStateContext } from 's' ; export { userStateContext } from 's' ; export { userStatsContext } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CallState , CurrentIssueAction , NextContact , CallStateActionType , callStateReducer , CompleteIssueAction , ClearContactIndexesAction } from 's' ; let defaultState ; beforeEach ( ( ) => { defaultState = { currentIssueId : 's' , contactIndexes : { } , completedIssueIds : [ ] } ; } ) ; test ( 's' , ( ) => { const issueId = 's' ; const state = { ... defaultState } ; const action = { type : CallStateActionType . CURRENT_ISSUE_SELECTED , payload : issueId } ; const newState = callStateReducer ( state , action ) ; expect ( newState . currentIssueId ) . toEqual ( issueId ) ; } ) ; test ( 's' , ( ) => { const 0 = 's' ; const 0 = 0 ; const contactIndexes = { 0 : 0 , 0 : 0 } ; const state = { ... defaultState , contactIndexes , currentIssueId : 0 } ; const action = { type : CallStateActionType . NEXT_CONTACT } ; const newState = callStateReducer ( state , action ) ; expect ( newState . contactIndexes [ 0 ] ) . toEqual ( 0 + 0 ) ; } ) ; test ( 's' , ( ) => { const 0 = 's' ; const completedIssues = [ 's' , 's' ] ; const state = { ... defaultState , currentIssueId : 0 , completedIssueIds : completedIssues } ; const action = { type : CallStateActionType . COMPLETE_ISSUE } ; const newState = callStateReducer ( state , action ) ; expect ( newState . completedIssueIds ) . toContain ( 0 ) ; expect ( newState . completedIssueIds . length ) . toEqual ( 0 ) ; } ) ; test ( 's' , ( ) => { const issueId = 's' ; const completedIssues = [ 's' , 's' ] ; const state = { ... defaultState , completedIssueIds : completedIssues } ; const action = { type : CallStateActionType . COMPLETE_ISSUE , payload : issueId } ; const newState = callStateReducer ( state , action ) ; expect ( newState . completedIssueIds ) . toContain ( issueId ) ; expect ( newState . completedIssueIds . length ) . toEqual ( 0 ) ; } ) ; test ( 's' , ( ) => { const contactIndexes = { 0 : 0 , 0 : 0 } ; const state = { ... defaultState , contactIndexes } ; const action = { type : CallStateActionType . CLEAR_CONTACT_INDEXES } ; const newState = callStateReducer ( state , action ) ; expect ( newState . contactIndexes ) . toEqual ( { } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O $CallState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CurrentIssueAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NextContact$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CompleteIssueAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $CompleteIssueAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ClearContactIndexesAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import configureStore from 's' ; import { setLocation , clearAddress , LocationActionType } from 's' ; const middlewares = [ ] ; const mockStore = configureStore ( middlewares ) ; test ( 's' , ( ) => { const address = 's' ; const setLocationAction = setLocation ( address ) ; const initialState = { } ; const store = mockStore ( initialState ) ; store . dispatch ( setLocationAction ) ; const actions = store . getActions ( ) ; const expectedPayload = { type : LocationActionType . LOCATION_SET , payload : address } ; expect ( actions ) . toEqual ( [ expectedPayload ] ) ; } ) ; test ( 's' , ( ) => { const clearLocationAction = clearAddress ( ) ; const initialState = { } ; const store = mockStore ( initialState ) ; store . dispatch ( clearLocationAction ) ; const actions = store . getActions ( ) ; const expectedPayload = { type : LocationActionType . LOCATION_CLEAR } ; expect ( actions ) . toEqual ( [ expectedPayload ] ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CacheCityAction } from 's' ; import { LocationState , LocationSetAction , locationStateReducer , LocationClearedAction , LocationActionType } from 's' ; let defaultState ; beforeEach ( ( ) => { defaultState = { address : 's' , cachedCity : 's' } ; } ) ; test ( 's' , ( ) => { const address = 's' ; const state = Object . assign ( { } , defaultState , { address } ) ; const action = { type : LocationActionType . LOCATION_SET , payload : address } ; const newState = locationStateReducer ( state , action ) ; expect ( newState . address ) . toEqual ( address ) ; } ) ; test ( 's' , ( ) => { const address = 's' ; const state = Object . assign ( { } , defaultState , { address } ) ; const action = { type : LocationActionType . LOCATION_CLEAR , payload : address } ; const newState = locationStateReducer ( state , action ) ; expect ( newState . address ) . toEqual ( 's' ) ; expect ( newState . cachedCity ) . toEqual ( 's' ) ; } ) ; test ( 's' , ( ) => { const cachedCity = 's' ; const state = Object . assign ( { } , defaultState , { cachedCity } ) ; const action = { type : LocationActionType . CACHE_CITY , payload : cachedCity } ; const newState = locationStateReducer ( state , action ) ; expect ( newState . cachedCity ) . toEqual ( cachedCity ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LocationState$ O O O O O O O O O O O O O O O O $LocationSetAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LocationState$ O O O O O O O O O O O O O O O O $LocationClearedAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LocationState$ O O O O O O O O O O O O O O O O $CacheCityAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import thunk from 's' ; import configureStore from 's' ; import * as moxios from 's' ; import { RemoteDataActionType } from 's' ; import { fetchCallCount } from 's' ; import { ApplicationState } from 's' ; import { Issue } from 's' ; import { IssueData } from 's' ; const middlewares = [ thunk ] ; const mockStore = configureStore ( middlewares ) ; beforeEach ( ( ) => { moxios . install ( ) ; } ) ; afterEach ( ( ) => { moxios . uninstall ( ) ; } ) ; test ( 's' , ( ) => { const count = 0 ; const expectedType = RemoteDataActionType . GET_CALL_TOTAL ; moxios . stubRequest ( "s" , { response : { count } } ) ; const initialState = { } as ApplicationState ; const store = mockStore ( initialState ) ; fetchCallCount ( ) . then ( ( ) => { const actions = store . getActions ( ) ; expect ( actions [ 0 ] . type ) . toEqual ( expectedType ) ; expect ( actions [ 0 ] . payload ) . toEqual ( count ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Issue } from 's' ; import { RemoteDataState , remoteDataReducer , IssuesAction , CallCountAction , RemoteDataActionType } from 's' ; let defaultState ; beforeEach ( ( ) => { defaultState = { issues : [ ] , callTotal : 0 , errorMessage : 's' } ; } ) ; test ( 's' , ( ) => { const issues = [ Object . assign ( { } , new Issue ( ) , { id : 's' , active : true } ) , Object . assign ( { } , new Issue ( ) , { id : 's' , active : true } ) ] ; const state = Object . assign ( { } , defaultState , issues ) ; const action = { type : RemoteDataActionType . GET_ISSUES , payload : issues } ; const newState = remoteDataReducer ( state , action ) ; expect ( newState . issues ) . toEqual ( issues ) ; } ) ; test ( 's' , ( ) => { const callTotal = 0 ; const state = Object . assign ( { } , defaultState , callTotal ) ; const action = { type : RemoteDataActionType . GET_CALL_TOTAL , payload : callTotal } ; const newState = remoteDataReducer ( state , action ) ; expect ( newState . callTotal ) . toEqual ( callTotal ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RemoteDataState$ O O O O O O O O O O O O O O $IssuesAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RemoteDataState$ O O O O O O O O O O O O O O $CallCountAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { userStatsReducer , UserStatsState , UserStatsActionType , SetUserStatsAction , AddCallEventAction , UserContactEventType } from 's' ; import { UserOutcomeResult } from 's' ; let defaultState ; beforeEach ( ( ) => { defaultState = { all : [ ] , voicemail : 0 , unavailable : 0 , contact : 0 , yes : 0 } ; } ) ; test ( 's' , ( ) => { const state = { ... defaultState } ; state . all . unshift ( getUserContactObject ( UserContactEventType . UNAVAILABLE ) ) ; state . unavailable = 0 ; const action = { type : UserStatsActionType . SET_USER_STATS , payload : state } ; const newState = userStatsReducer ( state , action ) ; expect ( newState . unavailable ) . toEqual ( 0 ) ; expect ( newState . voicemail ) . toEqual ( 0 ) ; expect ( newState . all . length ) . toEqual ( 0 ) ; } ) ; test ( 's' , ( ) => { const state = { ... defaultState } ; state . all . unshift ( getUserContactObject ( UserContactEventType . UNAVAILABLE ) ) ; state . unavailable = 0 ; const action = { type : UserStatsActionType . SET_USER_STATS , payload : state } ; let newState = userStatsReducer ( state , action ) ; const callEvent = getUserContactObject ( UserContactEventType . VOICEMAIL ) ; const callEventAction = { type : UserStatsActionType . ADD_CALL_EVENT , payload : callEvent } ; newState = userStatsReducer ( newState , callEventAction ) ; expect ( newState . unavailable ) . toEqual ( 0 ) ; expect ( newState . voicemail ) . toEqual ( 0 ) ; expect ( newState . all . length ) . toEqual ( 0 ) ; } ) ; const getUserContactObject = ( result ) => { return { result , contactid : 's' , issueid : 's' , time : Date . now ( ) , uploaded : false } ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserStatsState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $SetUserStatsAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserStatsState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $SetUserStatsAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AddCallEventAction$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UserOutcomeResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export default function register ( ) { if ( process . env . NODE_ENV === 's' && 's' in navigator ) { window . addEventListener ( 's' , ( ) => { const swUrl = `template` ; navigator . serviceWorker . register ( swUrl ) . then ( registration => { registration . onupdatefound = ( ) => { const installingWorker = registration . installing ; if ( ! installingWorker ) { return ; } installingWorker . onstatechange = ( ) => { if ( installingWorker . state === 's' ) { if ( navigator . serviceWorker . controller ) { console . log ( 's' ) ; } else { console . log ( 's' ) ; } } } ; } ; } ) . catch ( error => { console . error ( 's' , error ) ; } ) ; } ) ; } } export function unregister ( ) { if ( 's' in navigator ) { navigator . serviceWorker . ready . then ( registration => { registration . unregister ( ) ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { GeolocationPosition } from 's' ; export const GEOLOCATION_TIMEOUT = 0 ; export const GEOLOCATION_MAX_AGE = 0 ; export const getBrowserGeolocation = ( ) : Promise < GeolocationPosition > => { return new Promise < GeolocationPosition > ( ( resolve , reject ) => { if ( navigator . geolocation ) { const geolocation = navigator . geolocation ; geolocation . getCurrentPosition ( ( position ) => { const coords = position . coords ; const geolocation = { latitude : coords . latitude , longitude : coords . longitude } ; resolve ( geolocation ) ; } , ( e ) => { const code = e . code ; if ( code === 0 || code === 0 || code === 0 ) { const msg = `template` ; reject ( new Error ( msg ) ) ; } else { const msg = `template` ; console . error ( msg , e ) ; reject ( new Error ( msg ) ) ; } } , { enableHighAccuracy : false , timeout : GEOLOCATION_TIMEOUT , maximumAge : GEOLOCATION_MAX_AGE } ) ; } else { reject ( new Error ( 's' ) ) ; } } ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Geolocation$ O O O O O O O O O O $Position$ O O O O $Coordinates$ O O O O O O $GeolocationPosition$ O O O O O O O O O O O O O O O O O O O O O O O $PositionError$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as 0 from 's' ; import * as XHR from 's' ; import * as LanguageDetector from 's' ; const instance : 0 . 0 = 0 . use ( XHR ) . use ( LanguageDetector ) . init ( { backend : { loadPath : 's' } , fallbackLng : 's' , react : { wait : true } , ns : [ 's' ] , defaultNS : 's' , debug : true , interpolation : { escapeValue : false , formatSeparator : 's' } } ) ; export default instance ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { UserContactEvent , UserStatsState } from 's' ; export interface LegacyUserStatsState { all : UserContactEvent [ ] ; unavailable : number ; vm : number ; contacted : number ; } export const transform = ( legacyStats ) : UserStatsState => { let userStats = { all : legacyStats . all . map ( i => { return { contactid : i . contactid , issueid : i . issueid , result : i . result , time : i . time , uploaded : false } ; } ) , unavailable : legacyStats . unavailable , voicemail : legacyStats . vm , contact : legacyStats . contacted } ; return userStats ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LegacyUserStatsState$ O O O O O O $UserStatsState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export const getAll = ( storeName ) => { try { return JSON . parse ( window . localStorage [ storeName ] ) ; } catch ( e ) { return [ ] ; } } ; export const remove = ( storeName ) => { window . localStorage . removeItem ( storeName ) ; } ;	O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O
import mixpanel from 's' ; if ( mixpanel ) { mixpanel . init ( 's' ) ; } let environment = process . env . NODE_ENV === 's' ; let actions = { identify => { if ( environment ) { mixpanel . identify ( id ) ; } } , alias => { if ( environment ) { mixpanel . alias ( id ) ; } } , track : ( name , props ? ) => { if ( environment ) { mixpanel . track ( name , props ) ; } } , people : { set => { if ( environment ) { mixpanel . people . set ( props ) ; } } , increment => { if ( environment ) { mixpanel . people . increment ( props ) ; } } } , orig : mixpanel } ; export let Mixpanel = actions ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $id$ O O O O O O O O O O O O O O O O O $id$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $props$ O O O O O O O O O O O O O O O O O O O $props$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ClientFunction , t , Selector } from 's' ; import { waitForReact , ReactSelector } from 's' ; const getWindowLocation = ClientFunction ( ( ) => window . location . href ) ; `template` . beforeEach ( async ( ) => { await waitForReact ( 0 ) ; } ) ; const skipOnCi = process . env . CI ? test . skip : test ; skipOnCi ( 's' , async t => { const firstIssue = Selector ( 's' ) ; const link = await firstIssue . getAttribute ( 's' ) ; await t . click ( firstIssue ) . navigateTo ( link ) ; let windowLocation = await getWindowLocation ( ) ; await t . expect ( windowLocation ) . eql ( 's' + link ) ; const callButtons = await Selector ( 's' ) ; const buttons = await callButtons . find ( 's' ) ; const lastButton = buttons . nth ( - 0 ) ; let clicks = 0 ; while ( ! windowLocation . includes ( 's' ) ) { await t . expect ( clicks ) . lt ( 0 , 's' ) ; await t . click ( lastButton ) ; clicks = clicks + 0 ; windowLocation = await getWindowLocation ( ) ; } await waitForReact ( ) ; const Done = await ReactSelector ( 's' ) ; const doneComponent = await Done . getReact ( ) ; const totalCount = await doneComponent . props . totalCount ; await t . expect ( totalCount ) . gt ( 0 , 's' ) ; const callTitle = await Selector ( 's' ) ; await t . expect ( callTitle . innerText ) . eql ( 's' ) ; const callText = await Selector ( 's' ) ; await t . expect ( callText . innerText ) . eql ( 's' ) ; const totalText = await Selector ( 's' ) ; await t . expect ( totalText . innerText ) . eql ( 's' + totalCount . toLocaleString ( ) + 's' ) ; const donationComponent = await Selector ( 's' ) ; await t . expect ( donationComponent . exists ) . ok ( 's' ) ; const reminderComponent = await Selector ( 's' ) ; await t . expect ( reminderComponent . exists ) . ok ( 's' ) ; const shareComponent = await Selector ( 's' ) ; await t . expect ( shareComponent . exists ) . ok ( 's' ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ClientFunction , t , Selector } from 's' ; import { waitForReact , ReactSelector } from 's' ; const getWindowLocation = ClientFunction ( ( ) => window . location . href ) ; `template` . beforeEach ( async ( ) => { await waitForReact ( 0 ) ; } ) ; test ( 's' , async t => { const Footer = await ReactSelector ( 's' ) ; await t . expect ( Footer ) . ok ( 's' ) ; const colophon = await Selector ( 's' ) ; const leftContainer = await colophon . find ( 's' ) ; const leftLinks = await leftContainer . find ( 's' ) ; const count = await leftLinks . count ; await t . expect ( count ) . eql ( 0 ) ; const about = leftLinks . nth ( 0 ) ; const aboutLink = about . find ( 's' ) ; await t . expect ( aboutLink . getAttribute ( 's' ) ) . eql ( 's' ) ; await t . expect ( aboutLink . innerText ) . eql ( 's' ) ; const aboutLabel = await aboutLink . find ( 's' ) ; await t . expect ( aboutLabel ) . ok ( ) ; const faq = leftLinks . nth ( 0 ) ; const faqLink = faq . find ( 's' ) ; await t . expect ( faqLink . getAttribute ( 's' ) ) . eql ( 's' ) ; await t . expect ( faqLink . innerText ) . eql ( 's' ) ; const faqLabel = await faqLink . find ( 's' ) ; await t . expect ( faqLabel ) . ok ( ) ; const opensource = leftLinks . nth ( 0 ) ; const osLink = opensource . find ( 's' ) ; await t . expect ( osLink . getAttribute ( 's' ) ) . eql ( 's' ) ; await t . expect ( osLink . innerText ) . eql ( 's' ) ; const osLabel = await osLink . find ( 's' ) ; await t . expect ( osLabel ) . ok ( ) ; const privacy = leftLinks . nth ( 0 ) ; const privacyLink = privacy . find ( 's' ) ; await t . expect ( privacyLink . getAttribute ( 's' ) ) . eql ( 's' ) ; await t . expect ( privacyLink . innerText ) . eql ( 's' ) ; const privacyLabel = await privacyLink . find ( 's' ) ; await t . expect ( privacyLabel ) . ok ( ) ; } ) ; test ( 's' , async t => { const Footer = await ReactSelector ( 's' ) ; await t . expect ( Footer ) . ok ( 's' ) ; const colophon = await Selector ( 's' ) ; const rightContainer = await colophon . find ( 's' ) ; const rightLinks = await rightContainer . find ( 's' ) ; const count = await rightLinks . count ; await t . expect ( count ) . eql ( 0 ) ; const impact = rightLinks . nth ( 0 ) ; const impactLink = impact . find ( 's' ) ; await t . expect ( impactLink . getAttribute ( 's' ) ) . eql ( 's' ) ; await t . expect ( impactLink . innerText ) . eql ( 's' ) ; const support = rightLinks . nth ( 0 ) ; const supportLink = support . find ( 's' ) ; await t . expect ( supportLink . getAttribute ( 's' ) ) . eql ( 's' ) ; await t . expect ( supportLink . innerText ) . eql ( 's' ) ; const supportLabel = await supportLink . find ( 's' ) ; await t . expect ( supportLabel ) . ok ( ) ; } ) ; test ( 's' , async t => { const Footer = await ReactSelector ( 's' ) ; await t . expect ( Footer ) . ok ( 's' ) ; const colophon = await Selector ( 's' ) ; const centerContainer = await colophon . find ( 's' ) ; const centerItems = await centerContainer . find ( 's' ) ; let expectedText = 's' ; expectedText += 's' ; const copyright = centerItems . nth ( 0 ) ; await t . expect ( copyright . innerText ) . eql ( expectedText ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ClientFunction , t , Selector } from 's' ; import { waitForReact , ReactSelector } from 's' ; import axios from 's' ; const getWindowLocation = ClientFunction ( ( ) => window . location . href ) ; `template` . beforeEach ( async ( ) => { await waitForReact ( 0 ) ; } ) ; test ( 's' , async t => { const images = Selector ( 's' ) ; const count = await images . count ; const location = await getWindowLocation ( ) ; let requestPromises = [ ] ; for ( let i = 0 ; i < count ; i ++ ) { let url = await images . nth ( i ) . getAttribute ( 's' ) ; if ( ! url . startsWith ( 's' ) ) { requestPromises . push ( new Promise ( ( resolve , reject ) => { return axios . get ( location + url ) . then ( resp => resolve ( resp ? resp . status : 0 ) ) . catch ( e => reject ( e ) ) ; } ) ) ; } let statuses = await Promise . all ( requestPromises ) ; for ( const stat of statuses ) { await t . expect ( stat ) . eql ( 0 ) ; } } } ) ; test ( 's' , async t => { const HomeLink = await ReactSelector ( 's' ) . withProps ( { to : 's' } ) ; const img = await HomeLink . find ( 's' ) . withAttribute ( 's' ) ; const expectedImage = 's' ; const expectedAlt = 's' ; await t . expect ( img . getAttribute ( 's' ) ) . eql ( expectedImage ) ; await t . expect ( img . getAttribute ( 's' ) ) . eql ( expectedAlt ) ; } ) ; test ( 's' , async t => { const img = await Selector ( 's' ) ; const link = await Selector ( 's' ) ; const expectedSrc = 's' ; const expectedAlt = 's' ; const expectedText = 's' ; await t . expect ( img . getAttribute ( 's' ) ) . eql ( expectedSrc ) ; await t . expect ( img . getAttribute ( 's' ) ) . eql ( expectedAlt ) ; await t . expect ( link . innerText ) . eql ( expectedText ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ClientFunction , t , Selector } from 's' ; import { waitForReact , ReactSelector } from 's' ; const getWindowLocation = ClientFunction ( ( ) => window . location . href ) ; `template` . beforeEach ( async ( ) => { await waitForReact ( 0 ) ; } ) ; const skipOnCi = process . env . CI ? test . skip : test ; skipOnCi ( 's' , async t => { const firstIssue = Selector ( 's' ) ; const link = await firstIssue . getAttribute ( 's' ) ; await t . click ( firstIssue ) . navigateTo ( link ) ; await t . expect ( getWindowLocation ( ) ) . eql ( 's' + link ) ; const extras = await Selector ( 's' ) ; await t . expect ( extras . exists ) . notOk ( 's' ) ; const header = await Selector ( 's' ) ; await t . expect ( header . exists ) . ok ( 's' ) ; const headerText = await header . find ( 's' ) ; await t . expect ( headerText . exists ) . ok ( 's' ) ; const callBody = await headerText . nextSibling ( 's' ) ; await t . expect ( callBody . exists ) . ok ( 's' ) ; const contact = await Selector ( 's' ) ; await t . expect ( contact . exists ) . ok ( 's' ) ; const image = await contact . child ( 's' ) ; await t . expect ( image . exists ) . ok ( 's' ) ; const contactName = await contact . child ( 's' ) ; await t . expect ( contactName . exists ) . ok ( 's' ) ; const contactPhone = await contact . child ( 's' ) ; await t . expect ( contactPhone . exists ) . ok ( 's' ) ; const script = await Selector ( 's' ) ; await t . expect ( script . exists ) . ok ( 's' ) ; const scriptBody = script . child ( 's' ) ; await t . expect ( scriptBody . exists ) . ok ( 's' ) ; const buttonLabels = [ 's' , 's' , 's' , 's' ] ; const callOutcomes = await Selector ( 's' ) ; await t . expect ( callOutcomes . exists ) . ok ( 's' ) ; const callButtons = await callOutcomes . child ( 's' ) ; const buttons = await callOutcomes . find ( 's' ) ; const count = await buttons . count ; await t . expect ( count ) . eql ( 0 ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ClientFunction , t , Selector , } from 's' ; const users = require ( 's' ) ; const getWindowLocation = ClientFunction ( ( ) => window . location . href ) ; const sleep = ms => { return new Promise ( resolve => setTimeout ( resolve , ms ) ) ; } ; `template` ; test . skip ( 's' , async t => { const loginComponent = await Selector ( 's' ) ; await t . expect ( loginComponent . exists ) . ok ( 's' ) ; let userText = await loginComponent . find ( 's' ) . innerText ; if ( userText !== 's' ) { await t . click ( loginComponent ) ; const userMenu = await Selector ( 's' ) ; const logout = await userMenu . find ( 's' ) . nth ( 0 ) ; await t . click ( logout ) ; userText = await loginComponent . find ( 's' ) . innerText ; await t . expect ( userText ) . eql ( 's' ) ; } await t . click ( loginComponent ) ; const loginModal = Selector ( 's' ) ; await t . expect ( loginModal . exists ) . ok ( 's' ) ; const header = loginModal . find ( 's' ) ; await t . expect ( header . exists ) . ok ( 's' ) ; const logo = loginModal . find ( 's' ) ; await t . expect ( logo . exists ) . ok ( 's' ) ; const twitterLogin = loginModal . find ( 's' ) ; await t . expect ( twitterLogin . exists ) . ok ( 's' ) ; await t . click ( twitterLogin ) ; let windowLocation = await getWindowLocation ( ) ; const isTwitterLogin = windowLocation . includes ( 's' ) ; await t . expect ( isTwitterLogin ) . ok ( 's' ) ; const username = await Selector ( 's' ) ; const password = await Selector ( 's' ) ; const submit = await Selector ( 's' ) ; await t . typeText ( username , users . twitterLogin . user ) ; await t . typeText ( password , users . twitterLogin . pass ) ; await t . click ( submit ) ; await sleep ( 0 ) ; windowLocation = await getWindowLocation ( ) ; await t . expect ( windowLocation ) . contains ( 's' ) ; userText = await loginComponent . find ( 's' ) . innerText ; await t . expect ( userText ) . eql ( 's' ) ; } ) ; test . skip ( 's' , async t => { const loginComponent = await Selector ( 's' ) ; await t . expect ( loginComponent . exists ) . ok ( 's' ) ; let userText = await loginComponent . find ( 's' ) . innerText ; if ( userText !== 's' ) { await t . click ( loginComponent ) ; const userMenu = await Selector ( 's' ) ; const logout = await userMenu . find ( 's' ) . nth ( 0 ) ; await t . click ( logout ) ; userText = await loginComponent . find ( 's' ) . innerText ; await t . expect ( userText ) . eql ( 's' ) ; } await t . click ( loginComponent ) ; const loginModal = Selector ( 's' ) ; await t . expect ( loginModal . exists ) . ok ( 's' ) ; const header = loginModal . find ( 's' ) ; await t . expect ( header . exists ) . ok ( 's' ) ; const logo = loginModal . find ( 's' ) ; await t . expect ( logo . exists ) . ok ( 's' ) ; const facebookLogin = loginModal . find ( 's' ) ; await t . expect ( facebookLogin . exists ) . ok ( 's' ) ; await t . click ( facebookLogin ) ; await sleep ( 0 ) ; let windowLocation = await getWindowLocation ( ) ; const isFacebookLogin = windowLocation . includes ( 's' ) ; await t . expect ( isFacebookLogin ) . ok ( 's' ) ; const username = await Selector ( 's' ) ; const password = await Selector ( 's' ) ; const submit = await Selector ( 's' ) ; await t . typeText ( username , users . facebookLogin . user ) ; await t . typeText ( password , users . facebookLogin . pass ) ; await t . click ( submit ) ; windowLocation = await getWindowLocation ( ) ; await t . expect ( windowLocation ) . contains ( 's' ) ; userText = await loginComponent . find ( 's' ) . innerText ; await t . expect ( userText ) . eql ( 's' ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ClientFunction , t , Selector } from 's' ; import { waitForReact , ReactSelector } from 's' ; const getWindowLocation = ClientFunction ( ( ) => window . location . href ) ; `template` . beforeEach ( async ( ) => { await waitForReact ( 0 ) ; } ) ; test ( 's' , async t => { const sidebarComponent = await Selector ( 's' ) ; await t . expect ( sidebarComponent . exists ) . ok ( ) ; const Location = await ReactSelector ( 's' ) ; await t . expect ( Location ) . ok ( 's' ) ; const setLocationMessage = await Selector ( 's' ) ; await t . expect ( setLocationMessage . exists ) . ok ( 's' ) ; let locationSetMessage = await Selector ( 's' ) . withText ( 's' ) ; if ( await locationSetMessage . exists ) { const locationButton = await Location . findReact ( 's' ) ; await t . expect ( locationButton . innerText ) . eql ( 's' ) ; await t . click ( locationButton ) ; const addressField = Selector ( 's' ) ; await t . expect ( addressField . getAttribute ( 's' ) ) . eql ( 's' ) ; const submitButton = Location . findReact ( 's' ) ; await t . expect ( submitButton . innerText ) . eql ( 's' ) ; await t . typeText ( addressField , 's' ) . expect ( addressField . value ) . eql ( 's' ) ; await t . click ( submitButton ) ; locationSetMessage = await Selector ( 's' ) . withText ( 's' ) ; await t . expect ( locationSetMessage . innerText ) . eql ( 's' ) ; } } ) ; test ( 's' , async t => { const Sidebar = await ReactSelector ( 's' ) ; await t . expect ( Sidebar ) . ok ( 's' ) ; const IssueItems = await Sidebar . findReact ( 's' ) ; const count = await IssueItems . count ; await t . expect ( count ) . gte ( 0 ) ; for ( let i = 0 ; i < count ; i ++ ) { const Issue = IssueItems . nth ( i ) ; const Link = await Issue . findReact ( 's' ) ; const url = await Link . getAttribute ( 's' ) ; if ( i === count - 0 ) { await t . expect ( url ) . eql ( 's' ) ; } } } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O