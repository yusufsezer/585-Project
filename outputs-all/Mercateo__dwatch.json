'js' const { app , BrowserWindow , Menu } = require ( 's' ) ; const path = require ( 's' ) ; const spawn = require ( 's' ) . spawn ; let mainWindow = null ; if ( process . platform === 's' ) { const cmd = process . argv [ 0 ] ; const target = path . basename ( process . execPath ) ; if ( cmd === 's' || cmd === 's' ) { run ( [ 's' + target + 's' ] , app . quit ) ; } else if ( cmd === 's' ) { run ( [ 's' + target + 's' ] , app . quit ) ; } else if ( cmd === 's' ) { app . quit ( ) ; } } app . on ( 's' , function ( ) { if ( process . platform != 's' ) { app . quit ( ) ; } } ) ; app . on ( 's' , function ( ) { mainWindow = new BrowserWindow ( { width : 0 , height : 0 } ) ; mainWindow . loadURL ( 's' + __dirname + 's' ) ; mainWindow . on ( 's' , function ( ) { mainWindow = null ; } ) ; let menu = [ ] ; let editMenu = { label : "s" , submenu : [ { label : "s" , accelerator : "s" , selector : "s" } , { label : "s" , accelerator : "s" , selector : "s" } , { type : "s" } , { label : "s" , accelerator : "s" , selector : "s" } , { label : "s" , accelerator : "s" , selector : "s" } , { label : "s" , accelerator : "s" , selector : "s" } , { label : "s" , accelerator : "s" , selector : "s" } ] } ; menu . push ( editMenu ) ; let viewMenu = { label : 's' , submenu : [ { label : 's' , accelerator : process . platform === 's' ? 's' : 's' , click ( item , focusedWindow ) { if ( focusedWindow ) focusedWindow . setFullScreen ( ! focusedWindow . isFullScreen ( ) ) ; } } ] } ; menu . push ( viewMenu ) ; viewMenu . submenu . push ( { label : 's' , accelerator : process . platform === 's' ? 's' : 's' , click ( item , focusedWindow ) { if ( focusedWindow ) focusedWindow . webContents . toggleDevTools ( ) ; } } ) ; viewMenu . submenu . push ( { label : 's' , accelerator : 's' , click ( item , focusedWindow ) { if ( focusedWindow ) focusedWindow . reload ( ) ; } } ) ; let windowMenu = { label : 's' , role : 's' , submenu : [ { label : 's' , accelerator : 's' , role : 's' } , { label : 's' , accelerator : 's' , role : 's' } ] } ; menu . push ( windowMenu ) ; let helpMenu = { label : 's' , role : 's' , submenu : [ { label : 's' , click ( ) { require ( 's' ) . shell . openExternal ( 's' ) ; } } ] } ; menu . push ( helpMenu ) ; if ( process . platform === 's' ) { const name = app . getName ( ) ; menu . unshift ( { label : name , submenu : [ { label : 's' + name , role : 's' } , { type : 's' } , { label : 's' , role : 's' , submenu : [ ] } , { type : 's' } , { label : 's' + name , accelerator : 's' , role : 's' } , { label : 's' , accelerator : 's' , role : 's' } , { label : 's' , role : 's' } , { type : 's' } , { label : 's' , accelerator : 's' , click ( ) { app . quit ( ) ; } } , ] } ) ; menu [ 0 ] . submenu . push ( { type : 's' } , { label : 's' , role : 's' } ) ; } Menu . setApplicationMenu ( Menu . buildFromTemplate ( menu ) ) ; } ) ; function run ( args , done ) { const updateExe = path . resolve ( path . dirname ( process . execPath ) , 's' , 's' ) ; spawn ( updateExe , args , { detached : true } ) . on ( 's' , done ) }	O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O $void$ O O O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O O $void$ O O O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O O $any$ O O $number$ O O O $number$ O O O O O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O $any[]$ O O O O O $complex$ O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $any[]$ O $number$ O $complex$ O O O $complex$ O O $string$ O O O $complex$ O O O $string$ O O O $string$ O $any$ O $any$ O O O O O O O $void$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O $any[]$ O $number$ O $complex$ O O $complex$ O $complex$ O $number$ O O $string$ O O O $string$ O $any$ O $any$ O O O O O O O $void$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O $complex$ O $number$ O O $string$ O O O $string$ O O O $void$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O $any[]$ O $number$ O $complex$ O O O $complex$ O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $void$ O O O $any$ O O O O $any$ O $any$ O O O O O O O O O $any[]$ O $number$ O $complex$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $number$ O O $any$ O $any$ O $complex$ O O O $string$ O O O $any$ O $string$ O O O O O $string$ O O O O O $string$ O O O $string$ O O O $undefined[]$ O O O O O O $string$ O O O O O $string$ O O O $any$ O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O $string$ O O O $void$ O O O $any$ O $any$ O O O O O O O O O O $complex$ O O O O O O $complex$ O O $string$ O O O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O O O O $void$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O $boolean$ O O O O O $any$ O O O $any$ O O
import React , { Component } from 's' ; export abstract class AutoRefreshComponent < P , S > extends Component < P , S > { private intervalHolder : any = null ; getInterval ( ) { return 0 ; } componentWillMount ( ) { this . intervalHolder = setInterval ( ( ) => this . tick ( ) , this . getInterval ( ) || 0 ) ; } componentWillUnmount ( ) { this . clearInterval ( ) ; } clearInterval ( ) { clearInterval ( this . intervalHolder ) ; } abstract tick ( ) ; }	O $any$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O O O $number$ O O O O O O O $void$ O O O O O $any$ O $number$ O O O O O O $any$ O O O O O $number$ O O O O O O O $void$ O O O O O $void$ O O O O $void$ O O O $void$ O O O $any$ O O O O $any$ O O O O
import { Kernel , interfaces } from 's' ; import { makeFluentProvideDecorator } from 's' ; import Dockerode from 's' ; import getDecorators from 's' ; export const kernel = new Kernel ( ) ; export const Fetch = < Symbol > Symbol ( ) ; kernel . bind ( Dockerode ) . toConstantValue ( Dockerode ) ; kernel . bind ( Fetch ) . toConstantValue ( fetch . bind ( window ) ) ; const provide = makeFluentProvideDecorator ( kernel ) ; export function provideInstance ( identifier : string | Symbol | interfaces . Newable < any > ) { return provide ( identifier ) . done ( ) ; } export function provideSingleton ( identifier : string | Symbol | interfaces . Newable < any > ) { return provide ( identifier ) . inSingletonScope ( ) . done ( ) ; } export const inject = getDecorators ( kernel ) . lazyInject ;	O O $any$ O $any$ O O O O O O $any$ O O O O O $Dockerode$ O O O O $any$ O O O O O $any$ O O $any$ O O O O O $Symbol$ O O $SymbolConstructor$ O $SymbolConstructor$ O O O $any$ O $any$ O $Dockerode$ O O $any$ O $Dockerode$ O O $any$ O $any$ O $Symbol$ O O $any$ O $Promise<Response>$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $SymbolConstructor$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O O $SymbolConstructor$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O
import { observable } from 's' ; import { provideInstance } from 's' ; export enum CONFIG_TYPE { SOCKET , HOST } export enum PROTOCOL { HTTP , HTTPS } @ provideInstance ( ConnectionParametersModel ) export class ConnectionParametersModel { @ observable configType : CONFIG_TYPE = CONFIG_TYPE . HOST ; @ observable socketPath : string ; @ observable host : string ; @ observable port : number ; @ observable protocol : PROTOCOL = PROTOCOL . HTTPS ; @ observable caFile : string ; @ observable certFile : string ; @ observable keyFile : string ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $CONFIG_TYPE.SOCKET$ O $CONFIG_TYPE.HOST$ O O O $any$ O $PROTOCOL.HTTP$ O $PROTOCOL.HTTPS$ O O $any$ O $any$ O O O $any$ O O $any$ $CONFIG_TYPE$ O $any$ O $any$ O $CONFIG_TYPE.HOST$ O O $any$ $string$ O O O O $any$ $string$ O O O O $any$ $number$ O O O O $any$ $PROTOCOL$ O $any$ O $any$ O $PROTOCOL.HTTPS$ O O $any$ $string$ O O O O $any$ $string$ O O O O $any$ $string$ O O O O
import { observable , autorun , transaction } from 's' ; import { provideSingleton , inject } from 's' ; import { ConnectionParametersModel } from 's' ; export enum LOCALE { DE_DE , EN_US } @ provideSingleton ( SettingsStore ) export class SettingsStore { @ inject ( ConnectionParametersModel ) connectionSettings : ConnectionParametersModel ; @ observable locale : LOCALE = LOCALE . EN_US ; @ observable showUpdateNotifications : boolean = true ; constructor ( ) { try { const config = JSON . parse ( localStorage . getItem ( 's' ) ) ; if ( config != null ) { transaction ( ( ) => { this . locale = config . locale ; this . showUpdateNotifications = config . showUpdateNotifications ; Object . assign ( this . connectionSettings , config . connectionSettings ) ; } ) ; } } catch ( e ) { } autorun ( ( ) => { localStorage . setItem ( 's' , JSON . stringify ( { locale : this . locale , connectionSettings : this . connectionSettings , showUpdateNotifications : this . showUpdateNotifications } ) ) ; } ) ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $LOCALE.DE_DE$ O $LOCALE.EN_US$ O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $ConnectionParametersModel$ O $any$ O O $any$ $LOCALE$ O $any$ O $any$ O $LOCALE.EN_US$ O O $any$ $boolean$ O O O O O O O O O O O O $SettingsStore$ O $JSON$ O $any$ O $Storage$ O $string$ O O O O O O O $SettingsStore$ O O O O $any$ O O O O O O O $LOCALE$ O $SettingsStore$ O $LOCALE$ O O O $boolean$ O $SettingsStore$ O $boolean$ O $ObjectConstructor$ O O O O O $ConnectionParametersModel$ O $SettingsStore$ O $ConnectionParametersModel$ O O O O O O O O O $any$ O O O $any$ O O O O O $Storage$ O $void$ O O O $JSON$ O $complex$ O O $LOCALE$ O O O $LOCALE$ O $ConnectionParametersModel$ O O O $ConnectionParametersModel$ O $boolean$ O O O $boolean$ O O O O O O O O O
import JSONStream from 's' ; import { LOCALE } from 's' ; export interface Port { port : number ; protocol : string } export function normalizePort ( portString ) { if ( ! portString . includes ( 's' ) ) { throw new Error ( 's' ) ; } const [ port , protocol ] = portString . split ( 's' ) ; const parsedPort = parseInt ( port ) ; if ( isNaN ( parsedPort ) ) { throw new Error ( 's' ) ; } return { port : parseInt ( port ) , protocol } ; } export function normalizeContainerName ( name ) { return name . replace ( 's' , 's' ) ; } export function normalizeImageId ( imageId ) { return imageId . replace ( 's' , 's' ) ; } export function parseRepoTags ( repoTags < string > ) : { name : string , tags : Array < string > } { if ( repoTags == null || repoTags . length === 0 ) { return null ; } repoTags = repoTags . map ( tag => tag . includes ( 's' ) ? tag . split ( 's' ) . pop ( ) : tag ) ; return { name : repoTags [ 0 ] . split ( 's' ) [ 0 ] , tags : repoTags . map ( repoTag => repoTag . split ( 's' ) [ 0 ] ) } ; } export function parseLocale ( locale ) : { fullLocale : string , country : string , language : string } { let [ language , country ] = LOCALE [ locale ] . split ( 's' ) ; return { country , language : language . toLowerCase ( ) , fullLocale : `template` , } ; } export function dockerStream ( stream , onFinished : ( err , data ) => void , onProgress : ( event ) => void ) { var parser = JSONStream . parse ( ) , output = [ ] ; parser . on ( 's' , onStreamEvent ) ; parser . on ( 's' , onStreamError ) ; parser . on ( 's' , onStreamEnd ) ; stream . pipe ( parser ) ; function onStreamEvent ( evt ) { if ( ! ( evt instanceof Object ) ) { evt = { } ; } output . push ( evt ) ; if ( evt . error ) { return onStreamError ( evt . error ) ; } if ( onProgress ) { onProgress ( evt ) ; } } function onStreamError ( err ) { parser . removeListener ( 's' , onStreamEvent ) ; parser . removeListener ( 's' , onStreamError ) ; parser . removeListener ( 's' , onStreamEnd ) ; onFinished ( err , output ) ; } function onStreamEnd ( ) { onFinished ( null , output ) ; } } export function parseBytes ( bytes ) : { size : number , unit : string } { let i = - 0 ; const byteUnits = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' ] ; do { bytes = bytes / 0 ; i ++ ; } while ( bytes > 0 ) ; return { size : parseFloat ( Math . max ( bytes , 0 ) . toFixed ( 0 ) ) , unit : byteUnits [ i ] } ; }	O $JSONStream$ O O O O O $any$ O O O O O O $any$ O $number$ O O O $string$ O O O O O $Port$ O $string$ O O O O O $string$ O $boolean$ O O O O O O O $ErrorConstructor$ O O O O O O O $string$ O $string$ O O $string$ O $complex$ O O O O O $number$ O $number$ O $string$ O O O O $boolean$ O $number$ O O O O O $ErrorConstructor$ O O O O O O O $number$ O $number$ O $string$ O O $string$ O O O O O $string$ O $string$ O O O $string$ O $complex$ O O O O O O O O O $string$ O $string$ O O O $string$ O $complex$ O O O O O O O O O $complex$ O $Array$ O O O O O O $string$ O O O $string[]$ O $ArrayConstructor$ O O O O O O O $string[]$ O O O $string[]$ O $number$ O O O O O O O O $string[]$ O $string[]$ O $U[]$ O $string$ O $string$ O $boolean$ O O O O $string$ O $complex$ O O O O $string$ O O O $string$ O O O O $string$ O $string[]$ O O O O $complex$ O O O O O O O $string[]$ O $string[]$ O $U[]$ O $string$ O $string$ O $complex$ O O O O O O O O O O O O $complex$ O $LOCALE$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $string$ O $string$ O O $any$ O $LOCALE$ O O $complex$ O O O O O O $string$ O $string$ O $string$ O $string$ O O O $string$ O O O O O O O O $void$ O $any$ O $void$ O O $any$ O $any$ O O O O $void$ O O $any$ O O O O O O $any$ O $JSONStream$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O $any$ O O O $void$ O $any$ O O O O O O $any$ O $ObjectConstructor$ O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O O O O O $void$ O O $void$ O $any$ O O O O O $void$ O $any$ O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O O $void$ O $any$ O $any$ O O O O $void$ O O O $void$ O O O $any$ O O O O O O $complex$ O $number$ O O O $number$ O O O $string$ O O O O O $number$ O O O O O $string[]$ O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O $number$ O O O O O $number$ O O O O O O $number$ O $number$ O $Math$ O $number$ O $number$ O O O O $string$ O O O O O $string$ O $string[]$ O $number$ O O O O
import React , { Component } from 's' ; import { dockerStream } from 's' ; export abstract class DockerStreamComponent < StreamData , P , S > extends Component < P , S > { private stream : any = null ; attachStream ( stream ) { this . destroyStream ( ) ; this . stream = stream ; dockerStream ( stream , ( err ) => { if ( err ) { this . onError ( err ) ; } } , ( data ) => { this . onData ( data ) ; } ) } isStreamAttached ( ) { return this . stream != null ; } destroyStream ( ) { if ( this . stream != null ) { this . stream . destroy ( ) ; this . stream = null ; } } componentWillUnmount ( ) { this . destroyStream ( ) ; } abstract onData ( data ) ; abstract onError ( err ) ; }	O $any$ O O $any$ O O O O O O $void$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O O O $void$ O $any$ O O O O $void$ O O O O O $any$ O $any$ O $void$ O $any$ O O $any$ O O O O O $any$ O O O O $void$ O $any$ O O O O O O $StreamData$ O O O O O $void$ O $StreamData$ O O O O O $boolean$ O O O O O O $any$ O O O O $void$ O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $void$ O O O O O $void$ O O O O O $void$ O $StreamData$ O O O $void$ O $any$ O O O
import { 0 } from 's' ; export const en_US = { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , } ;	O O $any$ O O O O O O $I18NLanguage$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { de_DE } from 's' ; import { en_US } from 's' ; export interface 0 { [ key ] : 0 ; } export interface 0 { [ key ] : string ; } export const messages = { de_DE , en_US } ;	O O O O O O O O O O O O O O O O $any$ O O $string$ O O $any$ O O O O $any$ O O $string$ O O O O O O O $I18NMessages$ O O O O O O O
import { 0 } from 's' ; export const de_DE = { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , } ;	O O $any$ O O O O O O $I18NLanguage$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { observable } from 's' ; import { provideSingleton } from 's' ; export interface NotificationAction { actionHandler : ( ) => void ; actionText : string ; } export enum NOTIFICATION_TYPE { WARNING , ERROR , SUCCESS , CUSTOM } export interface Notification { message : string ; type : NOTIFICATION_TYPE ; timeout ? : number ; action ? : NotificationAction ; processedAt ? : number ; } @ provideSingleton ( NotificationStore ) export class NotificationStore { @ observable notifications : Array < Notification > = [ ] ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $void$ O O O O O O $string$ O O O O O O $any$ O $NOTIFICATION_TYPE.WARNING$ O $NOTIFICATION_TYPE.ERROR$ O $NOTIFICATION_TYPE.SUCCESS$ O $NOTIFICATION_TYPE.CUSTOM$ O O O $any$ O $string$ O O O $NOTIFICATION_TYPE$ O $any$ O $number$ O O O O $NotificationAction$ O O $any$ O $number$ O O O O O O $any$ O $any$ O O O $any$ O O $any$ $Notification[]$ O $ArrayConstructor$ O $any$ O O O O O O
import Dockerode from 's' ; import { SettingsStore } from 's' ; import { readFileSync } from 's' ; import { autorun } from 's' ; import { inject , provideSingleton , kernel } from 's' ; import { NOTIFICATION_TYPE , NotificationStore } from 's' ; import { CONFIG_TYPE , PROTOCOL } from 's' ; export interface DockerConfig { protocol ? : string ; host ? : string ; port ? : number ; socketPath ? : string ; ca ? : Buffer ; cert ? : Buffer ; key ? : Buffer ; } export interface Version { Version : string ; Os : string ; KernelVersion : string ; GoVersion : string ; GitCommit : string ; Arch : string ; ApiVersion : string ; BuildTime : Date ; } export interface SummarizedImage { RepoTags : Array < string > ; Id : string ; Created : Date ; Size : number ; VirtualSize : number ; Labels : { [ key ] : string ; } ; } export interface SummarizedContainer { Command : string ; Created : number ; HostConfig : Object ; Id : string ; Image : string ; ImageID : string ; Labels : Object ; Names : Array < string > ; NetworkSettings : Object ; Ports : Array < any > ; Status : string ; } export interface TopModel { Processes : Array < Array < string > > ; Titles : Array < string > ; } export interface DockerEvent { Action : 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' ; Type : 's' | 's' | 's' ; from : string id : string ; status : string ; time : number ; } export interface DockerSwarmEvent { status : 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' | 's' ; id : string ; from : string ; time : number ; node : { Addr : string ; Id : string ; Ip : string ; Name : string ; } ; } export class Container { Id : string ; Name : string ; Created : string ; State : { Error : string , ExitCode : number , FinishedAt : string , OOMKilled : boolean , Dead : boolean , Paused : boolean , Pid : number , Restarting : boolean , Running : boolean , StartedAt : string , Status : string } ; Config : { AttachStderr : boolean ; AttachStdin : boolean ; AttachStdout : boolean ; Cmd : Array < string > ; Domainname : string ; Entrypoint : string , Env : Array < string > ; ExposedPorts : Object ; Hostname : string ; Image : string ; Labels : Object ; MacAddress : string ; NetworkDisabled : boolean ; OnBuild : string ; OpenStdin : boolean ; StdinOnce : boolean ; Tty : boolean ; User : string ; Volumes : Object ; WorkingDir : string ; StopSignal : string ; } ; NetworkSettings : { Bridge : string ; SandboxID : string ; HairpinMode : boolean ; 0 : string ; 0 : number ; Ports : any ; SandboxKey : string ; SecondaryIPAddresses : string ; 0 : string ; EndpointID : string ; Gateway : string ; 0 : string ; 0 : number ; IPAddress : string ; IPPrefixLen : number ; 0 : string ; MacAddress : string ; Networks : any ; } ; Node : { Addr : string ; Cpus : number ; ID : string ; IP : string ; Memory : number ; Name : string ; } ; constructor ( data , private container ) { Object . assign ( this , data ) ; } top ( ) < TopModel > { return new Promise < TopModel > ( ( resolve , reject ) => { this . container . top ( ( err , data ) => { if ( err ) { return reject ( err ) ; } resolve ( data ) ; } ) ; } ) ; } stats ( ) < any > { return new Promise < any > ( ( resolve , reject ) => { this . container . stats ( ( err , stream ) => { if ( err ) { return reject ( err ) ; } resolve ( stream ) ; } ) ; } ) ; } unpause ( ) < void > { return new Promise < void > ( ( resolve , reject ) => { this . container . unpause ( ( err ) => { if ( err ) { return reject ( err ) ; } resolve ( ) ; } ) ; } ) ; } pause ( ) < void > { return new Promise < void > ( ( resolve , reject ) => { this . container . pause ( ( err ) => { if ( err ) { return reject ( err ) ; } resolve ( ) ; } ) ; } ) ; } start ( ) < void > { return new Promise < void > ( ( resolve , reject ) => { this . container . start ( ( err ) => { if ( err ) { return reject ( err ) ; } resolve ( ) ; } ) ; } ) ; } stop ( ) < void > { return new Promise < void > ( ( resolve , reject ) => { this . container . stop ( ( err ) => { if ( err ) { return reject ( err ) ; } resolve ( ) ; } ) ; } ) ; } } export class Image { Id : string ; Container : string ; Comment : string ; Os : string ; Architecture : string ; Parent : string ; ContainerConfig : { Tty : boolean ; Hostname : string ; Volumes : { [ key ] : { [ key ] : string ; } ; } ; Domainname : string ; AttachStdout : boolean ; PublishService : string ; AttachStdin : boolean ; OpenStdin : boolean ; StdinOnce : boolean ; NetworkDisabled : boolean ; OnBuild : Array < string > ; Image : string ; User : string ; WorkingDir : string ; Entrypoint : Array < string > ; MacAddress : string ; AttachStderr : boolean ; Labels : { [ key ] : string } , Env : Array < string > ; ExposedPorts : Object ; Cmd : Array < string > ; } ; DockerVersion : string ; VirtualSize : number ; Size : number ; Author : string ; Created : string ; RepoTags : Array < string > ; Config : { Image : string ; NetworkDisabled : boolean ; OnBuild : Array < string > ; StdinOnce : boolean ; PublishService : string ; AttachStdin : boolean ; OpenStdin : boolean ; Domainname : string ; AttachStdout : boolean ; Tty : boolean ; Hostname : string ; Volumes : { [ key ] : { [ key ] : string ; } ; } ; Cmd : Array < string > ; ExposedPorts : Object ; Env : Array < string > ; Labels : { [ key ] : string ; } ; Entrypoint : Array < string > ; MacAddress : string ; AttachStderr : boolean ; WorkingDir : string ; User : string ; } ; constructor ( data , private image ) { Object . assign ( this , data ) ; } history ( ) < any > { return new Promise < any > ( ( resolve , reject ) => { this . image . history ( ( err , stream ) => { if ( err ) { return reject ( err ) ; } resolve ( stream ) ; } ) ; } ) ; } } @ provideSingleton ( DockerFacade ) export class DockerFacade { private dockerode : Dockerode ; private eventListeners : Array < ( event : DockerEvent | DockerSwarmEvent ) => void > = [ ] ; private eventStream : any ; @ inject ( SettingsStore ) private settingsStore : SettingsStore ; @ inject ( NotificationStore ) private notificationStore : NotificationStore ; constructor ( ) { let dockerConfig = null ; autorun ( ( ) => { switch ( this . settingsStore . connectionSettings . configType ) { case CONFIG_TYPE . SOCKET : dockerConfig = { socketPath : this . settingsStore . connectionSettings . socketPath } ; break ; case CONFIG_TYPE . HOST : try { dockerConfig = { host : this . settingsStore . connectionSettings . host , port : this . settingsStore . connectionSettings . port , protocol : this . settingsStore . connectionSettings . protocol === PROTOCOL . HTTP ? 's' : 's' , ca : this . settingsStore . connectionSettings . caFile ? readFileSync ( this . settingsStore . connectionSettings . caFile ) : null , cert : this . settingsStore . connectionSettings . certFile ? readFileSync ( this . settingsStore . connectionSettings . certFile ) : null , key : this . settingsStore . connectionSettings . keyFile ? readFileSync ( this . settingsStore . connectionSettings . keyFile ) : null } ; } catch ( e ) { } break ; default : throw new Error ( 's' ) ; } this . dockerode = new ( kernel . get ( Dockerode ) ) ( dockerConfig ) ; if ( this . eventStream != null ) { this . eventStream . destroy ( ) ; } this . listenForEvents ( ( error , event ) => { if ( error != null ) { this . notificationStore . notifications . push ( { type : NOTIFICATION_TYPE . ERROR , message : error . message || 's' , } ) ; return ; } this . eventListeners . forEach ( cb => cb ( event ) ) ; } ) ; } ) ; } onEvent ( cb : ( event : DockerEvent | DockerSwarmEvent ) => void ) { this . eventListeners . push ( cb ) ; } listAllContainers ( ) < Array < Container > > { return this . fetchContainers ( { all : true } ) ; } getContainer ( containerId ) < Container > { return new Promise < Container > ( ( resolve , reject ) => { const container = this . dockerode . getContainer ( containerId ) ; container . inspect ( { } , ( err , data ) => { if ( err ) { return reject ( err ) ; } resolve ( new Container ( data , container ) ) ; } ) ; } ) ; } removeContainer ( containerId ) < void > { return new Promise < void > ( ( resolve , reject ) => { this . dockerode . getContainer ( containerId ) . remove ( { } , ( err ) => { if ( err ) { return reject ( err ) ; } resolve ( ) ; } ) ; } ) ; } listImages ( ) < Array < Image > > { return this . fetchImages ( ) ; } listDanglingImages ( ) < Array < Image > > { return this . fetchImages ( { filters : { dangling : [ 's' ] } } ) ; } getImage ( imageId ) < Image > { return new Promise < Image > ( ( resolve , reject ) => { const image = this . dockerode . getImage ( imageId ) ; image . inspect ( ( err , data ) => { if ( err ) { return reject ( err ) ; } resolve ( new Image ( data , image ) ) ; } ) ; } ) ; } removeImage ( imageId ) < void > { return new Promise < void > ( ( resolve , reject ) => { this . dockerode . getImage ( imageId ) . remove ( { } , ( err ) => { if ( err ) { return reject ( err ) ; } resolve ( ) ; } ) ; } ) ; } version ( ) < Version > { return new Promise < Version > ( ( resolve , reject ) => { this . dockerode . version ( ( err , data ) => { if ( err ) { return reject ( err ) ; } resolve ( data ) ; } ) } ) ; } private async fetchImages ( options = { } ) < Array < Image > > { return Promise . all ( ( await new Promise < Array < SummarizedImage > > ( ( resolve , reject ) => { this . dockerode . listImages ( options , ( err , images < SummarizedImage > ) => { if ( err ) { return reject ( err ) ; } resolve ( images ) ; } ) ; } ) ) . map ( ( image ) => this . getImage ( image . Id ) ) ) ; } private async fetchContainers ( options = { } ) < Array < Container > > { return Promise . all ( ( await new Promise < Array < SummarizedContainer > > ( ( resolve , reject ) => { this . dockerode . listContainers ( options , ( err , containers < SummarizedContainer > ) => { if ( err ) { return reject ( err ) ; } resolve ( containers ) ; } ) } ) ) . map ( ( container ) => this . getContainer ( container . Id ) ) ) ; } private listenForEvents ( cb : ( err , event ? : DockerEvent | DockerSwarmEvent ) => void ) { const options = { path : 's' , method : 's' , isStream : true , statusCodes : { 0 : true , 0 : 's' } } ; this . dockerode . modem . dial ( options , ( err , stream ) => { if ( err ) { return cb ( err ) ; } this . eventStream = stream ; this . dockerode . modem . followProgress ( stream , cb , event => cb ( null , event ) ) ; } ) ; } }	O $Dockerode$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $string$ O O O O $string$ O O O O $number$ O O O O $string$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $Date$ O $DateConstructor$ O O O O $any$ O $string[]$ O $ArrayConstructor$ O O O O $string$ O O O $Date$ O $DateConstructor$ O $number$ O O O $number$ O O O $complex$ O O O $string$ O O O O O O O O O $any$ O $string$ O O O $number$ O O O $Object$ O $ObjectConstructor$ O $string$ O O O $string$ O O O $string$ O O O $Object$ O $ObjectConstructor$ O $string[]$ O $ArrayConstructor$ O O O O $Object$ O $ObjectConstructor$ O $any[]$ O $ArrayConstructor$ O O O O $string$ O O O O O O $any$ O $string[][]$ O $ArrayConstructor$ O $ArrayConstructor$ O O O O O $string[]$ O $ArrayConstructor$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O $string$ O O O $number$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O $number$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $string$ O O O $number$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $number$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O $string$ O O O O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string[]$ O $ArrayConstructor$ O O O O $string$ O O O $string$ O O O $string[]$ O $ArrayConstructor$ O O O O $Object$ O $ObjectConstructor$ O $string$ O O O $string$ O O O $Object$ O $ObjectConstructor$ O $string$ O O O $boolean$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O $Object$ O $ObjectConstructor$ O $string$ O O O $string$ O O O O O O O O $string$ O O O $string$ O O O $boolean$ O O O $string$ O O O $number$ O O O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O $number$ O O O $string$ O O O $string$ O O O $any$ O O O O O $complex$ O O $string$ O O O $number$ O O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O O O O $any$ O O $any$ O O $ObjectConstructor$ O O O O O $any$ O O O $Promise$ O O O $any$ O O O O $PromiseConstructor$ O $any$ O O O $void$ O $void$ O O O O O $any$ O $any$ O O $any$ O $TopModel$ O O O O O $any$ O O O $void$ O $any$ O O O $void$ O $TopModel$ O O O O O O O O O $Promise$ O O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $void$ O $any$ O O O $void$ O $any$ O O O O O O O O O $Promise$ O O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O O $any$ O $any$ O O $any$ O O O O O $any$ O O O $void$ O $any$ O O O $void$ O O O O O O O O O O $Promise$ O O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O O $any$ O $any$ O O $any$ O O O O O $any$ O O O $void$ O $any$ O O O $void$ O O O O O O O O O O $Promise$ O O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O O $any$ O $any$ O O $any$ O O O O O $any$ O O O $void$ O $any$ O O O $void$ O O O O O O O O O O $Promise$ O O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O O $any$ O $any$ O O $any$ O O O O O $any$ O O O $void$ O $any$ O O O $void$ O O O O O O O O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $boolean$ O O O $string$ O O O $complex$ O O O $string$ O O O O $string$ O O O O O O O O $string$ O O O $boolean$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string[]$ O $ArrayConstructor$ O O O O $string$ O O O $string$ O O O $string$ O O O $string[]$ O $ArrayConstructor$ O O O O $string$ O O O $boolean$ O O O $complex$ O O O $string$ O O O O O $string[]$ O $ArrayConstructor$ O O O O $Object$ O $ObjectConstructor$ O $string[]$ O $ArrayConstructor$ O O O O O O $string$ O O O $number$ O O O $number$ O O O $string$ O O O $string$ O O O $string[]$ O $ArrayConstructor$ O O O O O O O $string$ O O O $boolean$ O O O $string[]$ O $ArrayConstructor$ O O O O $boolean$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O $complex$ O O O $string$ O O O O $string$ O O O O O O O O $string[]$ O $ArrayConstructor$ O O O O $Object$ O $ObjectConstructor$ O $string[]$ O $ArrayConstructor$ O O O O $complex$ O O O $string$ O O O O O O $string[]$ O $ArrayConstructor$ O O O O $string$ O O O $boolean$ O O O $string$ O O O $string$ O O O O O O O $any$ O O $any$ O O $ObjectConstructor$ O O O O O $any$ O O O $Promise$ O O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O $void$ O $any$ O O O $void$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O $any$ O O $Dockerode$ O $Dockerode$ O O $void)[]$ O $ArrayConstructor$ O O $complex$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O $any$ O O $SettingsStore$ O $any$ O O $any$ O $any$ O O $NotificationStore$ O $any$ O O O O O O $DockerConfig$ O O O $any$ O O O O O O O O O $SettingsStore$ O $ConnectionParametersModel$ O $CONFIG_TYPE$ O O O $any$ O $CONFIG_TYPE.SOCKET$ O $DockerConfig$ O O $string$ O O O $SettingsStore$ O $ConnectionParametersModel$ O $string$ O O O O O $any$ O $CONFIG_TYPE.HOST$ O O O $DockerConfig$ O O $string$ O O O $SettingsStore$ O $ConnectionParametersModel$ O $string$ O $number$ O O O $SettingsStore$ O $ConnectionParametersModel$ O $number$ O $string$ O O O $SettingsStore$ O $ConnectionParametersModel$ O $PROTOCOL$ O $any$ O $PROTOCOL.HTTP$ O O O O O $any$ O O O $SettingsStore$ O $ConnectionParametersModel$ O $string$ O $any$ O O O $SettingsStore$ O $ConnectionParametersModel$ O $string$ O O O O $any$ O O O $SettingsStore$ O $ConnectionParametersModel$ O $string$ O $any$ O O O $SettingsStore$ O $ConnectionParametersModel$ O $string$ O O O O $any$ O O O $SettingsStore$ O $ConnectionParametersModel$ O $string$ O $any$ O O O $SettingsStore$ O $ConnectionParametersModel$ O $string$ O O O O O O O O $any$ O O O O O O O O O $ErrorConstructor$ O O O O O O O $Dockerode$ O O O $any$ O $any$ O $Dockerode$ O O O $DockerConfig$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $void$ O O $any$ O $complex$ O O O O O $any$ O O O O O O $NotificationStore$ O $Notification[]$ O $number$ O O $NOTIFICATION_TYPE.ERROR$ O $any$ O $NOTIFICATION_TYPE.ERROR$ O $any$ O $any$ O $any$ O O O O O O O O O O O $void)[]$ O $void$ O $void$ O $void$ O $complex$ O O O O O O O O O O $void$ O $void$ O O $complex$ O $any$ O $any$ O O O O O O O $void)[]$ O $number$ O $void$ O O O $Promise$ O O O $ArrayConstructor$ O $any$ O O O O O O $Promise<Container[]>$ O O $boolean$ O O O O O O $Promise$ O $string$ O O $any$ O O O O $PromiseConstructor$ O $any$ O O O $void$ O $void$ O O O O $any$ O O O $Dockerode$ O $any$ O $string$ O O $any$ O $any$ O O O O O $Error$ O $any$ O O O O O $Error$ O O O $void$ O $Error$ O O O $void$ O O $any$ O $any$ O $any$ O O O O O O O O O O $Promise$ O $string$ O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O O $Dockerode$ O $any$ O $string$ O O $any$ O O O O O $any$ O O O O O $any$ O O O $void$ O $any$ O O O $void$ O O O O O O O O O O $Promise$ O O O $ArrayConstructor$ O $any$ O O O O O O $Promise<Image[]>$ O O O O $Promise$ O O O $ArrayConstructor$ O $any$ O O O O O O $Promise<Image[]>$ O O $complex$ O O $string[]$ O O O O O O O O O $Promise$ O $string$ O O $any$ O O O O $PromiseConstructor$ O $any$ O O O $void$ O $void$ O O O O $any$ O O O $Dockerode$ O $any$ O $string$ O O $any$ O $any$ O O $Error$ O $any$ O O O O O $Error$ O O O $void$ O $Error$ O O O $void$ O O $any$ O $any$ O $any$ O O O O O O O O O O $Promise$ O $string$ O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O O O $Dockerode$ O $any$ O $string$ O O $any$ O O O O O $any$ O O O O O $any$ O O O $void$ O $any$ O O O $void$ O O O O O O O O O O $Promise$ O O O $any$ O O O O $PromiseConstructor$ O $any$ O O O $void$ O $void$ O O O O O $Dockerode$ O $void$ O O $Error$ O $any$ O O O O O $Error$ O O O $void$ O $Error$ O O O $void$ O $any$ O O O O O O O O O O $Promise$ O $Object$ O O O O O $ArrayConstructor$ O $any$ O O O O $PromiseConstructor$ O O O O O O $PromiseConstructor$ O $ArrayConstructor$ O $any$ O O O O $void$ O $void$ O O O O O $Dockerode$ O $void$ O $Object$ O O $any$ O $Array$ O $any$ O O O O O O $any$ O O O $void$ O $any$ O O O $void$ O $SummarizedImage[]$ O O O O O O O O O $U[]$ O O $SummarizedImage$ O O O O $Promise<Image>$ O $SummarizedImage$ O $string$ O O O O O O O $Promise$ O $Object$ O O O O O $ArrayConstructor$ O $any$ O O O O $PromiseConstructor$ O O O O O O $PromiseConstructor$ O $ArrayConstructor$ O $any$ O O O O $void$ O $void$ O O O O O $Dockerode$ O $void$ O $Object$ O O $any$ O $Array$ O $any$ O O O O O O $any$ O O O $void$ O $any$ O O O $void$ O $SummarizedContainer[]$ O O O O O O O O $U[]$ O O $SummarizedContainer$ O O O O $Promise<Container>$ O $SummarizedContainer$ O $string$ O O O O O O $void$ O $void$ O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $string$ O O O $string$ O O O $boolean$ O O O O O O O O O O O O O O O O O O $Dockerode$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O $void$ O $any$ O O O O O $any$ O $any$ O O O $Dockerode$ O $any$ O $any$ O $any$ O $void$ O $any$ O $void$ O O O $any$ O O O O O O O O
import { Container } from 's' ; import { CONTAINER_RUN_STATE , CONTAINER_STATE } from 's' ; export class ContainerStateModel { runState : CONTAINER_RUN_STATE = CONTAINER_RUN_STATE . STOPPED ; state : CONTAINER_STATE = CONTAINER_STATE . CREATED ; exitCode : number = 0 ; finishedAt : Date ; startedAt : Date ; constructor ( config ) { if ( config . State . Running && ! config . State . Paused ) { this . runState = CONTAINER_RUN_STATE . RUNNING ; } else if ( config . State . Restarting ) { this . runState = CONTAINER_RUN_STATE . RESTARTING ; } else if ( config . State . Running && config . State . Paused ) { this . runState = CONTAINER_RUN_STATE . PAUSED ; } else if ( config . State . Dead ) { this . runState = CONTAINER_RUN_STATE . DEAD ; } this . finishedAt = new Date ( config . State . FinishedAt ) ; this . startedAt = new Date ( config . State . StartedAt ) ; this . exitCode = config . State . ExitCode ; switch ( config . State . Status ) { case 's' : this . state = CONTAINER_STATE . EXITED ; break ; case 's' : this . state = CONTAINER_STATE . CREATED ; break ; case 's' : this . state = CONTAINER_STATE . RUNNING ; break ; } } }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $CONTAINER_RUN_STATE$ O $any$ O $any$ O $CONTAINER_RUN_STATE.STOPPED$ O $CONTAINER_STATE$ O $any$ O $any$ O $CONTAINER_STATE.CREATED$ O $number$ O O O O O $Date$ O $DateConstructor$ O $Date$ O $DateConstructor$ O O O $Container$ O O O O $Container$ O $complex$ O $boolean$ O O $Container$ O $complex$ O $boolean$ O O O O $CONTAINER_RUN_STATE$ O $any$ O $CONTAINER_RUN_STATE.RUNNING$ O O O O O $Container$ O $complex$ O $boolean$ O O O O $CONTAINER_RUN_STATE$ O $any$ O $CONTAINER_RUN_STATE.RESTARTING$ O O O O O $Container$ O $complex$ O $boolean$ O $Container$ O $complex$ O $boolean$ O O O O $CONTAINER_RUN_STATE$ O $any$ O $CONTAINER_RUN_STATE.PAUSED$ O O O O O $Container$ O $complex$ O $boolean$ O O O O $CONTAINER_RUN_STATE$ O $any$ O $CONTAINER_RUN_STATE.DEAD$ O O O O $Date$ O O $DateConstructor$ O $Container$ O $complex$ O $string$ O O O O $Date$ O O $DateConstructor$ O $Container$ O $complex$ O $string$ O O O O $number$ O $Container$ O $complex$ O $number$ O O O $Container$ O $complex$ O $string$ O O O O O O O $CONTAINER_STATE$ O $any$ O $CONTAINER_STATE.EXITED$ O O O O O O O O $CONTAINER_STATE$ O $any$ O $CONTAINER_STATE.CREATED$ O O O O O O O O $CONTAINER_STATE$ O $any$ O $CONTAINER_STATE.RUNNING$ O O O O O O
import { Port , normalizePort , normalizeContainerName } from 's' ; import { Container , TopModel } from 's' ; import { ContainerStateModel } from 's' ; export enum CONTAINER_RUN_STATE { RUNNING , RESTARTING , PAUSED , DEAD , STOPPED } export enum CONTAINER_STATE { CREATED , EXITED , RUNNING } export interface HostPort { port : number ; ip : string ; } export class ContainerModel { id : string ; image : string ; name : string ; ports : Array < [ Port , HostPort ] > ; environment : Array < string > ; state : ContainerStateModel ; cmd : Array < string > ; created : Date ; workingDir : string ; node : { address : string ; cpuCount : number ; id : string ; ip : string ; memoryLimit : number ; name : string ; } ; constructor ( private container ) { this . id = container . Id ; this . name = normalizeContainerName ( container . Name ) ; this . image = container . Config . Image ; this . ports = Object . keys ( container . NetworkSettings . Ports || { } ) . map ( port => { let hostPort = null ; let internalPort = normalizePort ( port ) ; if ( container . NetworkSettings . Ports [ port ] !== null ) { hostPort = { port : parseInt ( container . NetworkSettings . Ports [ port ] [ 0 ] . HostPort ) , ip : container . NetworkSettings . Ports [ port ] [ 0 ] . HostIp } ; } return < [ Port , HostPort ] > [ internalPort , hostPort ] ; } ) ; this . environment = container . Config . Env || [ ] ; this . cmd = container . Config . Cmd || [ ] ; this . created = new Date ( container . Created ) ; this . state = new ContainerStateModel ( container ) ; this . workingDir = container . Config . WorkingDir ; if ( container . Node != null ) { this . node = { address : container . Node . Addr , cpuCount : container . Node . Cpus , id : container . Node . ID , ip : container . Node . IP , memoryLimit : container . Node . Memory , name : container . Node . Name } } } stop ( ) < void > { return this . container . stop ( ) ; } start ( ) < void > { return this . container . start ( ) ; } pauseContainer ( ) < void > { return this . container . pause ( ) ; } unPauseContainer ( ) < void > { return this . container . unpause ( ) ; } stats ( ) < any > { return this . container . stats ( ) ; } top ( ) < TopModel > { return this . container . top ( ) ; } }	O O $any$ O $Port$ O $string$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $CONTAINER_RUN_STATE.RUNNING$ O $CONTAINER_RUN_STATE.RESTARTING$ O $CONTAINER_RUN_STATE.PAUSED$ O $CONTAINER_RUN_STATE.DEAD$ O $CONTAINER_RUN_STATE.STOPPED$ O O O $any$ O $CONTAINER_STATE.CREATED$ O $CONTAINER_STATE.EXITED$ O $CONTAINER_STATE.RUNNING$ O O O $any$ O $number$ O O O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $complex$ O $ArrayConstructor$ O O $any$ O $any$ O O O $string[]$ O $ArrayConstructor$ O O O O $ContainerStateModel$ O $any$ O $string[]$ O $ArrayConstructor$ O O O O $Date$ O $DateConstructor$ O $string$ O O O $complex$ O O $string$ O O O $number$ O O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O O O O O $Container$ O O O O $string$ O $Container$ O $string$ O O O $string$ O $string$ O $Container$ O $string$ O O O O $string$ O $Container$ O O O $string$ O O O $complex$ O $ObjectConstructor$ O $complex$ O $Container$ O O O $any$ O O O O O $U[]$ O $string$ O O O $HostPort$ O O O O $Port$ O $Port$ O $string$ O O O O $Container$ O O O $any$ O $string$ O O O O O $HostPort$ O O $number$ O $number$ O $Container$ O O O $any$ O $string$ O O O O O $any$ O O $any$ O $Container$ O O O $any$ O $string$ O O O O O $any$ O O O O O O $any$ O $any$ O O O $Port$ O $HostPort$ O O O O O O O $string[]$ O $Container$ O O O $string[]$ O O O O O O $string[]$ O $Container$ O O O $string[]$ O O O O O O $Date$ O O $DateConstructor$ O $Container$ O $string$ O O O O $ContainerStateModel$ O O $any$ O $Container$ O O O O $string$ O $Container$ O O O $string$ O O O $Container$ O $complex$ O O O O O O $complex$ O O $string$ O $Container$ O $complex$ O $string$ O $number$ O $Container$ O $complex$ O $number$ O $string$ O $Container$ O $complex$ O $string$ O $string$ O $Container$ O $complex$ O $string$ O $number$ O $Container$ O $complex$ O $number$ O $string$ O $Container$ O $complex$ O $string$ O O O $Promise$ O O O O O O O O O $Container$ O $Promise<void>$ O O O O $Promise$ O O O O O O O O O $Container$ O $Promise<void>$ O O O O $Promise$ O O O O O O O O O $Container$ O $Promise<void>$ O O O O $Promise$ O O O O O O O O O $Container$ O $Promise<void>$ O O O O $Promise$ O O O O O O O O O $Container$ O $Promise<any>$ O O O O $Promise$ O O O $any$ O O O O O $Container$ O $Promise<TopModel>$ O O O O O
import { Image } from 's' ; import { parseRepoTags , Port , normalizePort } from 's' ; export interface HistoryEntry { Comment : string ; Created : number ; CreatedBy : string ; Id : string ; Size : number ; Tags : Array < string > ; } export class ImageModel { id : string ; name : string ; tags : Array < string > ; created : Date ; size : number ; dangling : boolean ; author : string ; os : string ; arch : string ; exposedPorts : Array < Port > ; entrypoints : Array < string > ; workingDir : string ; volumes : Array < string > ; cmd : Array < string > ; user : string ; environment : Array < string > ; constructor ( private image ) { this . id = image . Id ; let parsedRepoTags = parseRepoTags ( image . RepoTags ) ; if ( parsedRepoTags != null ) { this . name = parsedRepoTags . name ; this . tags = parsedRepoTags . tags ; } this . created = new Date ( image . Created ) ; this . size = image . Size ; this . dangling = false ; this . author = image . Author ; this . os = image . Os ; this . arch = image . Architecture ; this . exposedPorts = Object . keys ( image . Config . ExposedPorts || { } ) . map ( port => normalizePort ( port ) ) ; this . entrypoints = image . Config . Entrypoint || [ ] ; this . workingDir = image . Config . WorkingDir ; this . volumes = Object . keys ( image . Config . Volumes || { } ) ; this . cmd = image . Config . Cmd || [ ] ; this . user = image . Config . User ; this . environment = image . Config . Env || [ ] ; } getHistory ( ) < Array < HistoryEntry > > { return this . image . history ( ) ; } }	O O $any$ O O O O O O $complex$ O $any$ O $Port$ O O O O O O $any$ O $string$ O O O $number$ O O O $string$ O O O $string$ O O O $number$ O O O $string[]$ O $ArrayConstructor$ O O O O O O O $any$ O $string$ O O O $string$ O O O $string[]$ O $ArrayConstructor$ O O O O $Date$ O $DateConstructor$ O $number$ O O O $boolean$ O O O $string$ O O O $string$ O O O $string$ O O O $Port[]$ O $ArrayConstructor$ O $any$ O O $string[]$ O $ArrayConstructor$ O O O O $string$ O O O $string[]$ O $ArrayConstructor$ O O O O $string[]$ O $ArrayConstructor$ O O O O $string$ O O O $string[]$ O $ArrayConstructor$ O O O O O O O $Image$ O O O O $string$ O $Image$ O $string$ O O $complex$ O $complex$ O $Image$ O $string[]$ O O O O $complex$ O O O O O O $string$ O $complex$ O $string$ O O O $string[]$ O $complex$ O $string[]$ O O O O $Date$ O O $DateConstructor$ O $Image$ O $string$ O O O O $number$ O $Image$ O $number$ O O O $boolean$ O O O O O $string$ O $Image$ O $string$ O O O $string$ O $Image$ O $string$ O O O $string$ O $Image$ O $string$ O O O $Port[]$ O $ObjectConstructor$ O $complex$ O $Image$ O O O $Object$ O O O O O $U[]$ O $string$ O $Port$ O $string$ O O O O O $string[]$ O $Image$ O O O $string[]$ O O O O O O $string$ O $Image$ O O O $string$ O O O $string[]$ O $ObjectConstructor$ O $complex$ O $Image$ O O O $complex$ O O O O O O O $string[]$ O $Image$ O O O $string[]$ O O O O O O $string$ O $Image$ O O O $string$ O O O $string[]$ O $Image$ O O O $string[]$ O O O O O $Promise$ O O O $ArrayConstructor$ O $any$ O O O O O O $Image$ O $Promise<any>$ O O O O O
import { DockerEvent , DockerSwarmEvent , DockerFacade } from 's' ; import { transaction , asMap , observable } from 's' ; import { ContainerModel } from 's' ; import { inject , provideSingleton } from 's' ; @ provideSingleton ( ContainerStore ) export class ContainerStore { @ inject ( DockerFacade ) private docker : DockerFacade ; @ observable containers = asMap < ContainerModel > ( ) ; constructor ( ) { this . docker . onEvent ( event => { switch ( ( < DockerEvent > event ) . Action || ( < DockerSwarmEvent > event ) . status ) { case 's' : case 's' : case 's' : case 's' : case 's' : this . loadContainer ( event . id ) ; break ; case 's' : this . containers . delete ( event . id ) ; break ; } } ) ; } async loadContainers ( ) < void > { let containers < ContainerModel > = ( await this . docker . listAllContainers ( ) ) . map ( container => new ContainerModel ( container ) ) ; transaction ( ( ) => { this . containers . clear ( ) ; for ( let container of containers ) { this . containers . set ( container . id , container ) ; } } ) ; } async loadContainer ( containerId ) < void > { try { const container = new ContainerModel ( await this . docker . getContainer ( containerId ) ) ; this . containers . set ( container . id , container ) ; } catch ( e ) { throw new Error ( 's' ) ; } } async removeContainer ( containerId ) < void > { const container = this . containers . get ( containerId ) ; if ( container == null ) { throw new Error ( `template` ) ; } await this . docker . removeContainer ( containerId ) ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O $DockerFacade$ O $any$ O O $any$ $any$ O $any$ O $any$ O O O O O O O O O O $DockerFacade$ O $void$ O $complex$ O O O O O O $any$ O $complex$ O O O O O O $any$ O $complex$ O O O O O O O O O O O O O O O O O O O O O O $Promise<void>$ O $complex$ O $string$ O O O O O O O O O $any$ O $any$ O $complex$ O $string$ O O O O O O O O O O $Promise$ O O O O O O O $Array$ O $any$ O O O O O O $DockerFacade$ O $Promise<Container[]>$ O O O O $U[]$ O $Container$ O O $any$ O $Container$ O O O $any$ O O O O O O O $any$ O $any$ O O O O O O $ContainerModel$ O $ContainerModel[]$ O O O O $any$ O $any$ O $ContainerModel$ O $string$ O $ContainerModel$ O O O O O O O O $Promise$ O $string$ O O O O O O O O $ContainerModel$ O O $any$ O O O O $DockerFacade$ O $Promise<Container>$ O $string$ O O O O O $any$ O $any$ O $ContainerModel$ O $string$ O $ContainerModel$ O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $Promise$ O $string$ O O O O O O $any$ O O O $any$ O $any$ O $string$ O O O O $any$ O O O O O O $ErrorConstructor$ O O O O O O O O $DockerFacade$ O $Promise<void>$ O $string$ O O O O
import { observable } from 's' ; import { Version , DockerFacade } from 's' ; import { provideSingleton , inject } from 's' ; @ provideSingleton ( DockerSystemStore ) export class DockerSystemStore { @ inject ( DockerFacade ) private docker : DockerFacade ; @ observable version : Version ; async loadVersion ( ) < void > { this . version = await this . docker . version ( ) ; } }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O $DockerFacade$ O $any$ O O $any$ $Version$ O $any$ O O $Promise$ O O O O O O O O $Version$ O O O O $DockerFacade$ O $Promise<Version>$ O O O O O
import { DockerFacade , DockerEvent , DockerSwarmEvent } from 's' ; import { transaction , map , observable , asMap , ObservableMap } from 's' ; import { inject , provideSingleton } from 's' ; import { ImageModel } from 's' ; @ provideSingleton ( ImageStore ) export class ImageStore { @ inject ( DockerFacade ) private docker : DockerFacade ; @ observable images = asMap < ImageModel > ( ) ; constructor ( ) { this . docker . onEvent ( event => { switch ( ( < DockerEvent > event ) . Action || ( < DockerSwarmEvent > event ) . status ) { case 's' : case 's' : case 's' : this . loadImage ( event . id ) ; break ; case 's' : this . images . delete ( event . id ) ; break ; } } ) ; } async loadImages ( ) < void > { let danglingImages = await this . docker . listDanglingImages ( ) ; let images < ImageModel > = ( await this . docker . listImages ( ) ) . map ( image => new ImageModel ( image ) ) . map ( image => { if ( danglingImages . find ( x => x . Id === image . id ) ) { image . dangling = true ; } return image ; } ) ; transaction ( ( ) => { this . images . clear ( ) ; for ( let image of images ) { this . images . set ( image . id , image ) ; } } ) ; } async loadImage ( imageId ) < void > { let image ; try { image = new ImageModel ( await this . docker . getImage ( imageId ) ) ; } catch ( e ) { throw new Error ( `template` ) ; } let danglingImages = await this . docker . listDanglingImages ( ) ; if ( danglingImages . find ( x => x . Id === image . id ) ) { image . dangling = true ; } this . images . set ( image . id , image ) ; } async removeImage ( imageId ) < void > { const image = this . images . get ( imageId ) ; if ( image == null ) { throw new Error ( `template` ) ; } await this . docker . removeImage ( imageId ) ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O $DockerFacade$ O $any$ O O $any$ $any$ O $any$ O $any$ O O O O O O O O O O $DockerFacade$ O $void$ O $complex$ O O O O O O $any$ O $complex$ O O O O O O $any$ O $complex$ O O O O O O O O O O O O O O O O $Promise<void>$ O $complex$ O $string$ O O O O O O O O O $any$ O $any$ O $complex$ O $string$ O O O O O O O O O O $Promise$ O O O O O O O $Image[]$ O O O O $DockerFacade$ O $Promise<Image[]>$ O O O O $Array$ O $any$ O O O O O O $DockerFacade$ O $Promise<Image[]>$ O O O O $U[]$ O $Image$ O O $any$ O $Image$ O O O $U[]$ O $ImageModel$ O O O O $Image[]$ O $complex$ O $Image$ O $Image$ O $string$ O $ImageModel$ O $string$ O O O $ImageModel$ O $boolean$ O O O O O $ImageModel$ O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O $ImageModel$ O $ImageModel[]$ O O O O $any$ O $any$ O $ImageModel$ O $string$ O $ImageModel$ O O O O O O O O $Promise$ O $string$ O O O O O O $ImageModel$ O O O $ImageModel$ O O $any$ O O O O $DockerFacade$ O $Promise<Image>$ O $string$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $Image[]$ O O O O $DockerFacade$ O $Promise<Image[]>$ O O O O O $Image[]$ O $complex$ O $Image$ O $Image$ O $string$ O $ImageModel$ O $string$ O O O $ImageModel$ O $boolean$ O O O O O O $any$ O $any$ O $ImageModel$ O $string$ O $ImageModel$ O O O O $Promise$ O $string$ O O O O O O $any$ O O O $any$ O $any$ O $string$ O O O O $any$ O O O O O O $ErrorConstructor$ O O O O O O O O $DockerFacade$ O $Promise<void>$ O $string$ O O O O
import { observable , computed } from 's' ; import { Notification , NOTIFICATION_TYPE , NotificationStore } from 's' ; import { provideSingleton , inject } from 's' ; export interface StopAsyncTask { ( error ? ) : void ; } @ provideSingleton ( UiStore ) export class UiStore { @ inject ( NotificationStore ) private notificationStore : NotificationStore ; @ observable private pendingTasks : number = 0 ; @ observable pageTitle : string = 's' ; @ computed get isLoading ( ) : boolean { return this . pendingTasks > 0 ; } startAsyncTask ( ) { this . pendingTasks ++ ; return ( error ) => { this . pendingTasks -- ; if ( error != null ) { const notification = { type : NOTIFICATION_TYPE . ERROR , message : error . message , timeout : 0 } ; this . notificationStore . notifications . push ( notification ) ; } } ; } }	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $Error$ $Error$ O O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O $NotificationStore$ O $any$ O O $any$ O $number$ O O O O O O $any$ $string$ O O O O O O $any$ O $boolean$ O O O O O O O O $number$ O O O O $StopAsyncTask$ O O O O O $number$ O O O O $Error$ O O O O O $number$ O O O O $Error$ O O O O O $Notification$ O O $NOTIFICATION_TYPE.ERROR$ O $any$ O $NOTIFICATION_TYPE.ERROR$ O $string$ O $Error$ O $string$ O $number$ O O O O O O $NotificationStore$ O $Notification[]$ O $number$ O $Notification$ O O O O O O O
import { provideSingleton , inject , Fetch } from 's' ; import { observable } from 's' ; import { UiStore } from 's' ; import { SettingsStore } from 's' ; declare var __VERSION__ ; interface GithubRelease { id : number ; name : string ; } @ provideSingleton ( ReleaseStore ) export class ReleaseStore { private intervalHolder : any = null ; @ inject ( UiStore ) private uiStore : UiStore ; @ inject ( SettingsStore ) private settingsStore : SettingsStore ; @ inject ( Fetch ) private fetch : typeof window . fetch ; @ observable newVersion : string ; currentVersion : string = __VERSION__ ; constructor ( ) { setTimeout ( ( ) => this . checkForUpdate ( ) , 0 ) ; this . intervalHolder = setInterval ( ( ) => this . checkForUpdate ( ) , 0 * 0 * 0 ) ; } async checkForUpdate ( ) < void > { if ( ! this . settingsStore . showUpdateNotifications ) { return ; } const finishTask = this . uiStore . startAsyncTask ( ) ; let releases < GithubRelease > = [ ] ; try { releases = await ( await this . fetch ( 's' ) ) . json < Array < GithubRelease > > ( ) ; } catch ( e ) { } releases . sort ( ( a , b ) => a . id - b . id ) . reverse ( ) ; let latestRelease = releases [ 0 ] && releases [ 0 ] . name ? releases [ 0 ] . name . substr ( 0 ) : null ; if ( latestRelease && latestRelease !== this . currentVersion ) { this . newVersion = latestRelease ; if ( this . intervalHolder != null ) { clearInterval ( this . intervalHolder ) ; } } finishTask ( ) ; } }	O O $any$ O $any$ O $Symbol$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O $any$ O $number$ O O O $string$ O O O O O $any$ O $any$ O O O $any$ O O $any$ O O O O O O $any$ O $any$ O O $UiStore$ O $any$ O O $any$ O $any$ O O $SettingsStore$ O $any$ O O $any$ O $Symbol$ O O $Promise<Response>)$ O O $complex$ O $Promise<Response>)$ O O $any$ $string$ O O O $string$ O O O $any$ O O O O O $number$ O O O O O O $Promise<void>$ O O O O O O O O $any$ O $number$ O O O O O O $Promise<void>$ O O O O O O O O O O O O $Promise$ O O O O O O O O O O O $SettingsStore$ O $boolean$ O O O O O O $StopAsyncTask$ O O O $UiStore$ O $StopAsyncTask$ O O O O $Array$ O $any$ O O O O O O O $GithubRelease[]$ O O O O O O $Promise<Response>)$ O O O O O $Promise<any>$ O $ArrayConstructor$ O $any$ O O O O O O O O $any$ O O O $GithubRelease[]$ O $GithubRelease[]$ O O $GithubRelease$ O $GithubRelease$ O O $GithubRelease$ O $number$ O $GithubRelease$ O $number$ O O $GithubRelease[]$ O O O O $string$ O $GithubRelease[]$ O O O O $GithubRelease[]$ O O O O $string$ O $GithubRelease[]$ O O O O $string$ O $string$ O O O O O O O O $string$ O $string$ O O O $string$ O O O O $string$ O $string$ O O O O O $any$ O O O O $void$ O O O $any$ O O O O $StopAsyncTask$ O O O O O
import { createSpy } from 's' ; import { TopModel , Version } from 's' ; import { HistoryEntry } from 's' ; export function getContainerResponseMock ( ) { return { Id : 's' , Name : 's' , Created : new Date ( ) , Config : { WorkingDir : 's' , Image : 's' , Env : [ 's' ] , Cmd : [ 's' ] } , State : { Running : true , FinishedAt : new Date ( ) , StartedAt : new Date ( ) , ExitCode : 0 , Status : 's' } , NetworkSettings : { Ports : { 's' : null , 's' : [ { HostPort : 's' , HostIp : 's' } ] } } , Node : { Addr : 's' , Cpus : 0 , id : 's' , memoryLimit : 0 , name : 's' } , stop : createSpy ( ) , start : createSpy ( ) , pause : createSpy ( ) , unpause : createSpy ( ) , stats : createSpy ( ) , top : createSpy ( ) } } export function getImageResponseMock ( ) { return { Architecture : 's' , Author : 's' , Config : { Cmd : [ 's' , 's' ] , Entrypoint : [ 's' , 's' ] , Env : [ 's' ] , ExposedPorts : { 's' : null , 's' : null , } , User : 's' , Volumes : { 's' : null } , WorkingDir : 's' } , Created : 's' , Id : 's' , Os : 's' , RepoTags : [ 's' , 's' , ] , Size : 0 , VirtualSize : 0 , history : createSpy ( ) } ; } export function getDockerTopMock ( ) { return { Processes : [ [ 's' ] ] , Titles : [ 's' ] } ; } export function getImageHistoryMock ( ) { return { Comment : 's' , Created : new Date ( ) . getTime ( ) , CreatedBy : 's' , Id : 's' , Size : 0 , Tags : [ 's' ] } ; } export function getVersionResponseMock ( ) { return { Version : 's' , Os : 's' , KernelVersion : 's' , GoVersion : 's' , GitCommit : 's' , Arch : 's' , ApiVersion : 's' , BuildTime : new Date ( ) } ; }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O O O $string$ O O O $Date$ O O $DateConstructor$ O O O $complex$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $string[]$ O O O O O O $complex$ O O $boolean$ O O O $Date$ O O $DateConstructor$ O O O $Date$ O O $DateConstructor$ O O O $number$ O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O $string$ O O O O O O O $complex$ O O $string$ O O O $number$ O O O $string$ O O O $number$ O O O $string$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O $string$ O O O $string$ O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O O O O O O $string$ O O O $complex$ O O O O O O O $string$ O O O O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $number$ O O O $number$ O O O $any$ O $any$ O O O O O O O $TopModel$ O O O O O $string[][]$ O O O O O O O $string[]$ O O O O O O O O O $HistoryEntry$ O O O O O $string$ O O O $number$ O O $DateConstructor$ O O O $number$ O O O $string$ O O O $string$ O O O $number$ O O O $string[]$ O O O O O O O O O $Version$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $Date$ O O $DateConstructor$ O O O O O
import { createSpy } from 's' ; export function getDockerodeContainerDataMock ( ) { return { } ; } class DockerodeMock { getContainer = createSpy ( ) ; version = createSpy ( ) ; listContainers = createSpy ( ) ; listImages = createSpy ( ) ; getImage = createSpy ( ) ; modem = { dial : createSpy ( ) } } export function getDockerodeMock ( ) { return DockerodeMock ; } export function getDockerodeContainerMock ( ) { return { remove : createSpy ( ) , inspect : createSpy ( ) } ; } export function getDockerodeImageMock ( ) { return { remove : createSpy ( ) , inspect : createSpy ( ) } ; } export function getDockerodeImageDataMock ( ) { return { } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O
import expect from 's' ; import { kernel } from 's' ; export function deepEqual ( 0 , 0 ) { expect ( Object . keys ( 0 ) . sort ( ) ) . toEqual ( Object . keys ( 0 ) . sort ( ) ) ; let keys = Object . keys ( 0 ) ; for ( let key of keys ) { expect ( 0 [ key ] ) . toEqual ( 0 [ key ] ) ; } } export function getSingletonMock < T > ( target , mock : { new ( ... args : any [ ] ) : T ; } ) : T { kernel . unbind ( target ) ; kernel . bind < T > ( target ) . to ( mock ) . inSingletonScope ( ) ; return kernel . get < T > ( target ) ; } export function bindMock ( target , mock ) { kernel . unbind ( target ) ; kernel . bind ( target ) . toConstantValue ( mock ) ; } export function getDockerEvent ( id , action ) { return { id , Action : action } ; } export function getDockerSwarmEvent ( id , status ) { return { id , status } ; }	O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $ObjectConstructor$ O $complex$ O $any$ O O $string[]$ O O O O $any$ O $ObjectConstructor$ O $complex$ O $any$ O O $string[]$ O O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $any$ O O O O O $string$ O $string[]$ O O $any$ O $any$ O $string$ O O O $any$ O $any$ O $string$ O O O O O O O $T$ O $any$ O O $Symbol$ O $T$ O O O O O $any[]$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $Symbol$ O O $any$ O $any$ O $any$ O O $Symbol$ O O $any$ O $T$ O O $any$ O O O O $any$ O $any$ O $any$ O O $Symbol$ O O O O O $void$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $string$ O $string$ O O O O $string$ O $string$ O $string$ O O O O O $any$ O $string$ O $string$ O O O O $string$ O $string$ O O O
import { LOCALE } from 's' ; import { CONFIG_TYPE , PROTOCOL } from 's' ; export function getSettingsMock ( ) { return { locale : LOCALE . DE_DE , connectionSettings : { configType : CONFIG_TYPE . SOCKET , host : 's' , port : 0 , protocol : PROTOCOL . HTTP , caFile : 's' , certFile : 's' , keyFile : 's' , socketPath : 's' } } ; }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $LOCALE$ O $any$ O $LOCALE.DE_DE$ O $complex$ O O $CONFIG_TYPE$ O $any$ O $CONFIG_TYPE.SOCKET$ O $string$ O O O $number$ O O O $PROTOCOL$ O $any$ O $PROTOCOL.HTTP$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O
import expect from 's' ; import { getContainerResponseMock } from 's' ; import { ContainerModel } from 's' ; import { normalizeContainerName } from 's' ; describe ( 's' , ( ) => { let containerResponseMock ; let container ; beforeEach ( ( ) => { containerResponseMock = getContainerResponseMock ( ) ; container = new ContainerModel ( containerResponseMock ) ; } ) ; it ( 's' , ( ) => { expect ( container . id ) . toBe ( containerResponseMock . Id ) ; expect ( container . image ) . toBe ( containerResponseMock . Config . Image ) ; expect ( container . name ) . toBe ( normalizeContainerName ( containerResponseMock . Name ) ) ; expect ( container . environment ) . toEqual ( containerResponseMock . Config . Env ) ; expect ( container . cmd ) . toEqual ( containerResponseMock . Config . Cmd ) ; expect ( container . created ) . toEqual ( containerResponseMock . Created ) ; expect ( container . workingDir ) . toBe ( containerResponseMock . Config . WorkingDir ) ; expect ( container . node . address ) . toBe ( containerResponseMock . Node . Addr ) ; expect ( container . node . cpuCount ) . toBe ( containerResponseMock . Node . Cpus ) ; expect ( container . node . id ) . toBe ( containerResponseMock . Node . ID ) ; expect ( container . node . ip ) . toBe ( containerResponseMock . Node . IP ) ; expect ( container . node . memoryLimit ) . toBe ( containerResponseMock . Node . Memory ) ; expect ( container . node . name ) . toBe ( containerResponseMock . Node . Name ) ; } ) ; it ( 's' , ( ) => { delete containerResponseMock . Node ; container = new ContainerModel ( containerResponseMock ) ; expect ( container . node ) . toBeFalsy ( ) ; } ) ; it ( 's' , ( ) => { let ports = Object . keys ( containerResponseMock . NetworkSettings . Ports ) ; expect ( container . ports . length ) . toBe ( ports . length ) ; expect ( container . ports [ 0 ] [ 0 ] . port ) . toBe ( 0 ) ; expect ( container . ports [ 0 ] [ 0 ] . protocol ) . toBe ( 's' ) ; expect ( container . ports [ 0 ] [ 0 ] ) . toBeFalsy ( ) ; expect ( container . ports [ 0 ] [ 0 ] . port ) . toBe ( 0 ) ; expect ( container . ports [ 0 ] [ 0 ] . protocol ) . toBe ( 's' ) ; expect ( container . ports [ 0 ] [ 0 ] ) . toBeTruthy ( ) ; expect ( container . ports [ 0 ] [ 0 ] . port ) . toBe ( 0 ) ; expect ( container . ports [ 0 ] [ 0 ] . ip ) . toBe ( 's' ) ; } ) ; it ( 's' , async ( ) => { expect ( containerResponseMock . stop ) . toNotHaveBeenCalled ( ) ; await container . stop ( ) ; expect ( containerResponseMock . stop ) . toHaveBeenCalled ( ) ; expect ( containerResponseMock . start ) . toNotHaveBeenCalled ( ) ; await container . start ( ) ; expect ( containerResponseMock . start ) . toHaveBeenCalled ( ) ; expect ( containerResponseMock . pause ) . toNotHaveBeenCalled ( ) ; await container . pauseContainer ( ) ; expect ( containerResponseMock . pause ) . toHaveBeenCalled ( ) ; expect ( containerResponseMock . unpause ) . toNotHaveBeenCalled ( ) ; await container . unPauseContainer ( ) ; expect ( containerResponseMock . unpause ) . toHaveBeenCalled ( ) ; expect ( containerResponseMock . stats ) . toNotHaveBeenCalled ( ) ; await container . stats ( ) ; expect ( containerResponseMock . stats ) . toHaveBeenCalled ( ) ; expect ( containerResponseMock . top ) . toNotHaveBeenCalled ( ) ; await container . top ( ) ; expect ( containerResponseMock . top ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O $any$ O O O O O O O O $any$ O O $ContainerModel$ O $any$ O O O O O $any$ O $any$ O O O $ContainerModel$ O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O $ContainerModel$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O $ContainerModel$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ContainerModel$ O $string$ O O $any$ O $string$ O $any$ O $any$ O O O $any$ O $ContainerModel$ O $string[]$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ContainerModel$ O $string[]$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ContainerModel$ O $Date$ O O $any$ O $any$ O $any$ O O $any$ O $ContainerModel$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ContainerModel$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ContainerModel$ O $complex$ O $number$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ContainerModel$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ContainerModel$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ContainerModel$ O $complex$ O $number$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ContainerModel$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $ContainerModel$ O O $any$ O $any$ O O $any$ O $ContainerModel$ O $complex$ O O $any$ O O O O O O $any$ O O O O O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O $any$ O O $any$ O $ContainerModel$ O $complex$ O $number$ O O $any$ O $string[]$ O $number$ O O $any$ O $ContainerModel$ O $complex$ O O O O O O O $number$ O O $any$ O O O O $any$ O $ContainerModel$ O $complex$ O O O O O O O $string$ O O $any$ O O O O $any$ O $ContainerModel$ O $complex$ O O O O O O O O $any$ O O O $any$ O $ContainerModel$ O $complex$ O O O O O O O $number$ O O $any$ O O O O $any$ O $ContainerModel$ O $complex$ O O O O O O O $string$ O O $any$ O O O O $any$ O $ContainerModel$ O $complex$ O O O O O O O O $any$ O O O $any$ O $ContainerModel$ O $complex$ O O O O O O O $number$ O O $any$ O O O O $any$ O $ContainerModel$ O $complex$ O O O O O O O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $ContainerModel$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $ContainerModel$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $ContainerModel$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $ContainerModel$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $ContainerModel$ O $Promise<any>$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $ContainerModel$ O $Promise<TopModel>$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O
import expect from 's' ; import { ContainerStateModel } from 's' ; import { getContainerResponseMock } from 's' ; import { CONTAINER_RUN_STATE , CONTAINER_STATE } from 's' ; describe ( 's' , ( ) => { let containerResponseMock ; beforeEach ( ( ) => { containerResponseMock = getContainerResponseMock ( ) ; } ) ; it ( 's' , ( ) => { let state = new ContainerStateModel ( containerResponseMock ) ; expect ( state . exitCode ) . toBe ( containerResponseMock . State . ExitCode ) ; expect ( state . finishedAt ) . toEqual ( containerResponseMock . State . FinishedAt ) ; expect ( state . startedAt ) . toEqual ( containerResponseMock . State . StartedAt ) ; expect ( state . state ) . toBe ( CONTAINER_STATE . RUNNING ) ; expect ( state . runState ) . toBe ( CONTAINER_RUN_STATE . RUNNING ) ; } ) ; it ( 's' , ( ) => { containerResponseMock . State . Running = false ; let state = new ContainerStateModel ( containerResponseMock ) ; expect ( state . runState ) . toBe ( CONTAINER_RUN_STATE . STOPPED ) ; } ) ; it ( 's' , ( ) => { containerResponseMock . State . Paused = true ; let state = new ContainerStateModel ( containerResponseMock ) ; expect ( state . runState ) . toBe ( CONTAINER_RUN_STATE . PAUSED ) ; } ) ; it ( 's' , ( ) => { containerResponseMock . State . Running = false ; containerResponseMock . State . Dead = true ; let state = new ContainerStateModel ( containerResponseMock ) ; expect ( state . runState ) . toBe ( CONTAINER_RUN_STATE . DEAD ) ; } ) ; it ( 's' , ( ) => { containerResponseMock . State . Running = false ; containerResponseMock . State . Restarting = true ; let state = new ContainerStateModel ( containerResponseMock ) ; expect ( state . runState ) . toBe ( CONTAINER_RUN_STATE . RESTARTING ) ; } ) ; it ( 's' , ( ) => { containerResponseMock . State . Status = 's' ; let state = new ContainerStateModel ( containerResponseMock ) ; expect ( state . state ) . toBe ( CONTAINER_STATE . EXITED ) ; } ) ; it ( 's' , ( ) => { containerResponseMock . State . Status = 's' ; let state = new ContainerStateModel ( containerResponseMock ) ; expect ( state . state ) . toBe ( CONTAINER_STATE . CREATED ) ; } ) ; } ) ;	O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $ContainerStateModel$ O O $any$ O $any$ O O $any$ O $ContainerStateModel$ O $number$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ContainerStateModel$ O $Date$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ContainerStateModel$ O $Date$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ContainerStateModel$ O $CONTAINER_STATE$ O O $any$ O $any$ O $CONTAINER_STATE.RUNNING$ O O $any$ O $ContainerStateModel$ O $CONTAINER_RUN_STATE$ O O $any$ O $any$ O $CONTAINER_RUN_STATE.RUNNING$ O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $ContainerStateModel$ O O $any$ O $any$ O O $any$ O $ContainerStateModel$ O $CONTAINER_RUN_STATE$ O O $any$ O $any$ O $CONTAINER_RUN_STATE.STOPPED$ O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $ContainerStateModel$ O O $any$ O $any$ O O $any$ O $ContainerStateModel$ O $CONTAINER_RUN_STATE$ O O $any$ O $any$ O $CONTAINER_RUN_STATE.PAUSED$ O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $ContainerStateModel$ O O $any$ O $any$ O O $any$ O $ContainerStateModel$ O $CONTAINER_RUN_STATE$ O O $any$ O $any$ O $CONTAINER_RUN_STATE.DEAD$ O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $ContainerStateModel$ O O $any$ O $any$ O O $any$ O $ContainerStateModel$ O $CONTAINER_RUN_STATE$ O O $any$ O $any$ O $CONTAINER_RUN_STATE.RESTARTING$ O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $ContainerStateModel$ O O $any$ O $any$ O O $any$ O $ContainerStateModel$ O $CONTAINER_STATE$ O O $any$ O $any$ O $CONTAINER_STATE.EXITED$ O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $ContainerStateModel$ O O $any$ O $any$ O O $any$ O $ContainerStateModel$ O $CONTAINER_STATE$ O O $any$ O $any$ O $CONTAINER_STATE.CREATED$ O O O O O O O O
import expect from 's' ; import { getImageResponseMock } from 's' ; import { ImageModel } from 's' ; describe ( 's' , ( ) => { let imageResponseMock ; let image ; beforeEach ( ( ) => { imageResponseMock = getImageResponseMock ( ) ; image = new ImageModel ( imageResponseMock ) ; } ) ; it ( 's' , ( ) => { expect ( image . id ) . toBe ( imageResponseMock . Id ) ; expect ( image . name ) . toBe ( 's' ) ; expect ( image . tags ) . toEqual ( [ 's' , 's' ] ) ; expect ( image . arch ) . toBe ( imageResponseMock . Architecture ) ; expect ( image . os ) . toBe ( imageResponseMock . Os ) ; expect ( image . entrypoints ) . toEqual ( imageResponseMock . Config . Entrypoint ) ; expect ( image . exposedPorts ) . toEqual ( [ { port : 0 , protocol : 's' } , { port : 0 , protocol : 's' } ] ) ; expect ( image . workingDir ) . toBe ( imageResponseMock . Config . WorkingDir ) ; expect ( image . cmd ) . toEqual ( imageResponseMock . Config . Cmd ) ; } ) ; it ( 's' , async ( ) => { expect ( imageResponseMock . history ) . toNotHaveBeenCalled ( ) ; await image . getHistory ( ) ; expect ( imageResponseMock . history ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	O $any$ O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $any$ O O $ImageModel$ O $any$ O O O O O $any$ O $any$ O O O $ImageModel$ O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O $ImageModel$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O $ImageModel$ O $string$ O O $any$ O O O O $any$ O $ImageModel$ O $string[]$ O O $any$ O O O O O O O O $any$ O $ImageModel$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O $ImageModel$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O $ImageModel$ O $string[]$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ImageModel$ O $Port[]$ O O $any$ O O O $number$ O O O $string$ O O O O O $number$ O O O $string$ O O O O O O $any$ O $ImageModel$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $ImageModel$ O $string[]$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $ImageModel$ O $Promise<HistoryEntry[]>$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O
import expect , { extend , spyOn } from 's' ; import { getContainerResponseMock } from 's' ; import { ContainerStore } from 's' ; import { ContainerModel } from 's' ; import { DockerSwarmEvent , DockerEvent , DockerFacade } from 's' ; import { kernel } from 's' ; import { bindMock , getDockerEvent , getDockerSwarmEvent } from 's' ; import { Mock , expectExtensions } from 's' ; extend ( expectExtensions ) ; describe ( 's' , ( ) => { let store ; let containerResponseMock ; let dockerFacadeMock < DockerFacade > ; beforeEach ( ( ) => { kernel . snapshot ( ) ; containerResponseMock = getContainerResponseMock ( ) ; dockerFacadeMock = Mock . of ( DockerFacade ) ; bindMock ( DockerFacade , dockerFacadeMock . mock ) ; store = kernel . get ( ContainerStore ) ; } ) ; it ( 's' , async ( ) => { let getContainerSpy = dockerFacadeMock . spyOn ( x => x . getContainer ( containerResponseMock . Id ) ) . andReturn ( new Promise ( ( resolve ) => resolve ( containerResponseMock ) ) ) ; await store . loadContainer ( containerResponseMock . Id ) ; ( < any > expect ( getContainerSpy ) ) . toHaveBeenCalledWithSignature ( ) ; expect ( store . containers . get ( containerResponseMock . Id ) ) . toBeA ( ContainerModel ) ; } ) ; it ( 's' , async ( ) => { let secondContainer = getContainerResponseMock ( ) ; secondContainer . Id = 's' ; let listAllContainerSpy = dockerFacadeMock . spyOn ( x => x . listAllContainers ( ) ) . andReturn ( new Promise ( ( resolve ) => resolve ( [ containerResponseMock , secondContainer ] ) ) ) ; await store . loadContainers ( ) ; ( < any > expect ( listAllContainerSpy ) ) . toHaveBeenCalledWithSignature ( ) ; expect ( store . containers . size ) . toBe ( 0 ) ; expect ( store . containers . get ( containerResponseMock . Id ) ) . toBeA ( ContainerModel ) ; expect ( store . containers . get ( secondContainer . Id ) ) . toBeA ( ContainerModel ) ; } ) ; it ( 's' , async ( ) => { dockerFacadeMock . spyOn ( x => x . getContainer ( containerResponseMock . Id ) ) . andReturn ( new Promise ( ( resolve ) => resolve ( containerResponseMock ) ) ) ; let removeContainerSpy = dockerFacadeMock . spyOn ( x => x . removeContainer ( containerResponseMock . Id ) ) ; await store . loadContainer ( containerResponseMock . Id ) ; await store . removeContainer ( containerResponseMock . Id ) ; ( < any > expect ( removeContainerSpy ) ) . toHaveBeenCalledWithSignature ( ) ; ( < any > removeContainerSpy ) . reset ( ) ; try { await store . removeContainer ( 's' ) ; expect ( 0 ) . toBe ( 0 ) ; } catch ( e ) { expect ( e . message ) . toInclude ( 's' ) ; } expect ( removeContainerSpy ) . toNotHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { let onEventSpy = dockerFacadeMock . spyOn ( x => x . onEvent ( ( e : DockerEvent | DockerSwarmEvent ) => { } ) ) ; expect ( onEventSpy ) . toHaveBeenCalled ( ) ; let onEventCallback : ( event : DockerEvent | DockerSwarmEvent ) => void = onEventSpy . calls [ 0 ] . arguments [ 0 ] ; dockerFacadeMock . spyOn ( x => x . getContainer ( containerResponseMock . Id ) ) . andReturn ( new Promise ( ( resolve ) => resolve ( containerResponseMock ) ) ) ; let loadContainerSpy = spyOn ( store , 's' ) . andCallThrough ( ) ; await store . loadContainer ( containerResponseMock . Id ) ; ( < any > loadContainerSpy ) . reset ( ) ; expect ( store . containers . size ) . toBe ( 0 ) ; [ 's' , 's' , 's' , 's' , 's' ] . forEach ( action => { onEventCallback ( getDockerEvent ( containerResponseMock . Id , action ) ) ; expect ( store . loadContainer ) . toHaveBeenCalled ( ) ; ( < any > loadContainerSpy ) . reset ( ) ; onEventCallback ( getDockerSwarmEvent ( containerResponseMock . Id , action ) ) ; expect ( store . loadContainer ) . toHaveBeenCalled ( ) ; ( < any > loadContainerSpy ) . reset ( ) ; } ) ; onEventCallback ( getDockerEvent ( containerResponseMock . Id , 's' ) ) ; expect ( store . containers . size ) . toBe ( 0 ) ; await store . loadContainer ( containerResponseMock . Id ) ; onEventCallback ( getDockerSwarmEvent ( containerResponseMock . Id , 's' ) ) ; expect ( store . containers . size ) . toBe ( 0 ) ; } ) ; afterEach ( ( ) => { kernel . restore ( ) ; } ) ; } ) ;	O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O $ContainerStore$ O O $any$ O O $Mock$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $void$ O $any$ O $any$ O $any$ O O $ContainerStore$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O $any$ O O O O O $ContainerStore$ O $Promise<void>$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $ContainerStore$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O O $any$ O $any$ O O O O O O $ContainerStore$ O $Promise<void>$ O O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $ContainerStore$ O $any$ O $any$ O O $any$ O O O O $any$ O $ContainerStore$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $ContainerStore$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $ContainerStore$ O $Promise<void>$ O $any$ O $any$ O O O $ContainerStore$ O $Promise<void>$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O O $any$ O O O O O O $ContainerStore$ O $Promise<void>$ O O O O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $complex$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O O O O $void$ O O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O $any$ O O O O O $any$ O $any$ O $ContainerStore$ O O O O $any$ O O O O $ContainerStore$ O $Promise<void>$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O O $any$ O $ContainerStore$ O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O O O $void$ O $string$ O O $void$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $ContainerStore$ O $Promise<void>$ O O $any$ O O O O O O O $any$ O O $any$ O O O $void$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $ContainerStore$ O $Promise<void>$ O O $any$ O O O O O O O $any$ O O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $ContainerStore$ O $any$ O $any$ O O $any$ O O O O O $ContainerStore$ O $Promise<void>$ O $any$ O $any$ O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $ContainerStore$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O
import expect from 's' ; import { Version , DockerFacade } from 's' ; import { DockerSystemStore } from 's' ; import { getVersionResponseMock } from 's' ; import { bindMock } from 's' ; import { kernel } from 's' ; import { Mock } from 's' ; describe ( 's' , ( ) => { let store ; let dockerFacadeMock < DockerFacade > ; let versionResponseMock ; beforeEach ( ( ) => { kernel . snapshot ( ) ; versionResponseMock = getVersionResponseMock ( ) ; dockerFacadeMock = Mock . of ( DockerFacade ) ; bindMock ( DockerFacade , dockerFacadeMock . mock ) ; store = kernel . get ( DockerSystemStore ) ; } ) ; it ( 's' , async ( ) => { let versionSpy = dockerFacadeMock . spyOn ( x => x . version ( ) ) . andReturn ( new Promise < Version > ( ( resolve ) => resolve ( versionResponseMock ) ) ) ; await store . loadVersion ( ) ; expect ( versionSpy ) . toHaveBeenCalled ( ) ; expect ( store . version ) . toEqual ( versionResponseMock ) ; } ) ; it ( 's' , async ( ) => { dockerFacadeMock . spyOn ( x => x . version ( ) ) . andReturn ( new Promise < Version > ( ( resolve , reject ) => reject ( new Error ( 's' ) ) ) ) ; try { await store . loadVersion ( ) ; expect ( 0 ) . toBe ( 0 ) ; } catch ( e ) { expect ( e . message ) . toBe ( 's' ) ; } expect ( store . version ) . toBeFalsy ( ) ; } ) ; afterEach ( ( ) => { kernel . restore ( ) ; } ) ; } ) ;	O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $Version$ O O O O O O $void$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $any$ O O $Mock$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $Version$ O O O $any$ O $any$ O $any$ O $any$ O O $void$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $PromiseConstructor$ O $any$ O O O $void$ O O $void$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $PromiseConstructor$ O $any$ O O O $void$ O $void$ O O $void$ O O $ErrorConstructor$ O O O O O O O O O O $any$ O $any$ O O O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O
import expect , { extend , spyOn } from 's' ; import { getImageResponseMock } from 's' ; import { DockerFacade , DockerEvent , DockerSwarmEvent } from 's' ; import { kernel } from 's' ; import { bindMock , getDockerEvent , getDockerSwarmEvent } from 's' ; import { Mock , expectExtensions } from 's' ; import { ImageStore } from 's' ; import { ImageModel } from 's' ; extend ( expectExtensions ) ; describe ( 's' , ( ) => { let store ; let imageResponseMock ; let dockerFacadeMock < DockerFacade > ; beforeEach ( ( ) => { kernel . snapshot ( ) ; imageResponseMock = getImageResponseMock ( ) ; dockerFacadeMock = Mock . of ( DockerFacade ) ; bindMock ( DockerFacade , dockerFacadeMock . mock ) ; store = kernel . get ( ImageStore ) ; } ) ; it ( 's' , async ( ) => { let listDanglingImagesSpy = dockerFacadeMock . spyOn ( x => x . listDanglingImages ( ) ) . andReturn ( new Promise ( ( resolve ) => resolve ( [ ] ) ) ) ; let getImageSpy = dockerFacadeMock . spyOn ( x => x . getImage ( imageResponseMock . Id ) ) . andReturn ( new Promise ( ( resolve ) => resolve ( imageResponseMock ) ) ) ; await store . loadImage ( imageResponseMock . Id ) ; ( < any > expect ( getImageSpy ) ) . toHaveBeenCalledWithSignature ( ) ; ( < any > expect ( listDanglingImagesSpy ) ) . toHaveBeenCalledWithSignature ( ) ; expect ( store . images . get ( imageResponseMock . Id ) ) . toBeA ( ImageModel ) ; expect ( store . images . get ( imageResponseMock . Id ) . dangling ) . toBeFalsy ( ) ; listDanglingImagesSpy . andReturn ( new Promise ( ( resolve ) => resolve ( [ { Id : imageResponseMock . Id } ] ) ) ) ; await store . loadImage ( imageResponseMock . Id ) ; ( < any > expect ( getImageSpy ) ) . toHaveBeenCalledWithSignature ( ) ; expect ( store . images . get ( imageResponseMock . Id ) ) . toBeA ( ImageModel ) ; expect ( store . images . get ( imageResponseMock . Id ) . dangling ) . toBeTruthy ( ) ; dockerFacadeMock . spyOn ( x => x . getImage ( 's' ) ) . andReturn ( new Promise ( ( resolve , reject ) => reject ( 's' ) ) ) ; try { await store . loadImage ( 's' ) ; expect ( 0 ) . toBe ( 0 ) ; } catch ( e ) { expect ( e . message ) . toInclude ( 's' ) ; } } ) ; it ( 's' , async ( ) => { let secondImage = getImageResponseMock ( ) ; secondImage . Id = 's' ; let listImagesSpy = dockerFacadeMock . spyOn ( x => x . listImages ( ) ) . andReturn ( new Promise ( ( resolve ) => resolve ( [ imageResponseMock , secondImage ] ) ) ) ; let listDanglingImagesSpy = dockerFacadeMock . spyOn ( x => x . listDanglingImages ( ) ) . andReturn ( new Promise ( ( resolve ) => resolve ( [ secondImage ] ) ) ) ; await store . loadImages ( ) ; ( < any > expect ( listDanglingImagesSpy ) ) . toHaveBeenCalledWithSignature ( ) ; ( < any > expect ( listImagesSpy ) ) . toHaveBeenCalledWithSignature ( ) ; expect ( store . images . size ) . toBe ( 0 ) ; expect ( store . images . get ( imageResponseMock . Id ) ) . toBeA ( ImageModel ) ; expect ( store . images . get ( secondImage . Id ) ) . toBeA ( ImageModel ) ; expect ( store . images . get ( secondImage . Id ) . dangling ) . toBeTruthy ( ) ; expect ( store . images . get ( imageResponseMock . Id ) . dangling ) . toBeFalsy ( ) ; } ) ; it ( 's' , async ( ) => { dockerFacadeMock . spyOn ( x => x . getImage ( imageResponseMock . Id ) ) . andReturn ( new Promise ( ( resolve ) => resolve ( imageResponseMock ) ) ) ; dockerFacadeMock . spyOn ( x => x . listDanglingImages ( ) ) . andReturn ( new Promise ( ( resolve ) => resolve ( [ ] ) ) ) ; let removeImageSpy = dockerFacadeMock . spyOn ( x => x . removeImage ( imageResponseMock . Id ) ) ; await store . loadImage ( imageResponseMock . Id ) ; await store . removeImage ( imageResponseMock . Id ) ; ( < any > expect ( removeImageSpy ) ) . toHaveBeenCalledWithSignature ( ) ; ( < any > removeImageSpy ) . reset ( ) ; try { await store . removeImage ( 's' ) ; expect ( 0 ) . toBe ( 0 ) ; } catch ( e ) { expect ( e . message ) . toInclude ( 's' ) ; } expect ( removeImageSpy ) . toNotHaveBeenCalled ( ) ; } ) ; it ( 's' , async ( ) => { let onEventSpy = dockerFacadeMock . spyOn ( x => x . onEvent ( ( e : DockerEvent | DockerSwarmEvent ) => { } ) ) ; expect ( onEventSpy ) . toHaveBeenCalled ( ) ; let onEventCallback : ( event : DockerEvent | DockerSwarmEvent ) => void = onEventSpy . calls [ 0 ] . arguments [ 0 ] ; dockerFacadeMock . spyOn ( x => x . getImage ( imageResponseMock . Id ) ) . andReturn ( new Promise ( ( resolve ) => resolve ( imageResponseMock ) ) ) ; dockerFacadeMock . spyOn ( x => x . listDanglingImages ( ) ) . andReturn ( new Promise ( ( resolve ) => resolve ( [ ] ) ) ) ; let loadImageSpy = spyOn ( store , 's' ) . andCallThrough ( ) ; await store . loadImage ( imageResponseMock . Id ) ; ( < any > loadImageSpy ) . reset ( ) ; expect ( store . images . size ) . toBe ( 0 ) ; [ 's' , 's' , 's' ] . forEach ( action => { onEventCallback ( getDockerEvent ( imageResponseMock . Id , action ) ) ; expect ( store . loadImage ) . toHaveBeenCalled ( ) ; ( < any > loadImageSpy ) . reset ( ) ; onEventCallback ( getDockerSwarmEvent ( imageResponseMock . Id , action ) ) ; expect ( store . loadImage ) . toHaveBeenCalled ( ) ; ( < any > loadImageSpy ) . reset ( ) ; } ) ; onEventCallback ( getDockerEvent ( imageResponseMock . Id , 's' ) ) ; expect ( store . images . size ) . toBe ( 0 ) ; await store . loadImage ( imageResponseMock . Id ) ; onEventCallback ( getDockerSwarmEvent ( imageResponseMock . Id , 's' ) ) ; expect ( store . images . size ) . toBe ( 0 ) ; } ) ; afterEach ( ( ) => { kernel . restore ( ) ; } ) ; } ) ;	O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O $ImageStore$ O O $any$ O O $Mock$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $void$ O $any$ O $any$ O $any$ O O $ImageStore$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O $any$ O O O O O $ImageStore$ O $Promise<void>$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $ImageStore$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $ImageStore$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O O O $any$ O $any$ O $any$ O O O O O O O $ImageStore$ O $Promise<void>$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $ImageStore$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $ImageStore$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O O O O O $ImageStore$ O $Promise<void>$ O O O O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O O $any$ O O O O O O $ImageStore$ O $Promise<void>$ O O O O O O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $ImageStore$ O $any$ O $any$ O O $any$ O O O O $any$ O $ImageStore$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $ImageStore$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $ImageStore$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O $any$ O $ImageStore$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $ImageStore$ O $Promise<void>$ O $any$ O $any$ O O O $ImageStore$ O $Promise<void>$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O O $any$ O O O O O O $ImageStore$ O $Promise<void>$ O O O O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $complex$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O O O O $void$ O O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O O O O O O O O $any$ O $any$ O $ImageStore$ O O O O $any$ O O O O $ImageStore$ O $Promise<void>$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O O $any$ O $ImageStore$ O $any$ O $any$ O O $any$ O O O O O O O O O O O O $void$ O $string$ O O $void$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $ImageStore$ O $Promise<void>$ O O $any$ O O O O O O O $any$ O O $any$ O O O $void$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $ImageStore$ O $Promise<void>$ O O $any$ O O O O O O O $any$ O O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $ImageStore$ O $any$ O $any$ O O $any$ O O O O O $ImageStore$ O $Promise<void>$ O $any$ O $any$ O O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $ImageStore$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O
import expect from 's' ; import { NotificationStore } from 's' ; import { kernel } from 's' ; describe ( 's' , ( ) => { let store ; beforeEach ( ( ) => { kernel . snapshot ( ) ; store = kernel . get ( NotificationStore ) ; } ) ; it ( 's' , ( ) => { expect ( store . notifications . length ) . toBe ( 0 ) ; } ) ; afterEach ( ( ) => { kernel . restore ( ) ; } ) ; } ) ;	O $any$ O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O
import expect , { createSpy } from 's' ; import { SettingsStore } from 's' ; import { bindMock } from 's' ; import { kernel , Fetch } from 's' ; import { ReleaseStore } from 's' ; import { UiStore } from 's' ; import { Mock } from 's' ; declare var __VERSION__ ; describe ( 's' , ( ) => { let store ; let uiStoreMock < UiStore > ; let settingsStoreMock < SettingsStore > ; let newVersion = 's' ; let fetchMock ; beforeEach ( ( ) => { kernel . snapshot ( ) ; fetchMock = createSpy ( ) . andReturn ( new Promise ( ( resolve ) => resolve ( { json : createSpy ( ) . andReturn ( new Promise ( ( resolve ) => resolve ( [ { id : 0 , name : `template` } , { id : 0 , name : newVersion } ] ) ) ) } ) ) ) ; uiStoreMock = Mock . of ( UiStore ) ; settingsStoreMock = Mock . of ( SettingsStore ) ; uiStoreMock . spyOn ( x => x . startAsyncTask ( ) ) . andReturn ( ( ) => { } ) ; bindMock ( UiStore , uiStoreMock . mock ) ; bindMock ( SettingsStore , settingsStoreMock . mock ) ; bindMock ( Fetch , fetchMock ) ; store = kernel . get ( ReleaseStore ) ; } ) ; it ( 's' , async ( ) => { settingsStoreMock . mock . showUpdateNotifications = true ; expect ( fetchMock ) . toNotHaveBeenCalled ( ) ; expect ( store . newVersion ) . toEqual ( null ) ; await store . checkForUpdate ( ) ; expect ( fetchMock ) . toHaveBeenCalled ( ) ; expect ( store . newVersion ) . toEqual ( newVersion . substr ( 0 ) ) ; } ) ; it ( 's' , async ( ) => { settingsStoreMock . mock . showUpdateNotifications = true ; fetchMock . andReturn ( new Promise ( ( resolve ) => resolve ( { json : createSpy ( ) . andReturn ( new Promise ( ( resolve ) => resolve ( [ { id : 0 , name : `template` } ] ) ) ) } ) ) ) ; expect ( fetchMock ) . toNotHaveBeenCalled ( ) ; expect ( store . newVersion ) . toEqual ( null ) ; await store . checkForUpdate ( ) ; expect ( fetchMock ) . toHaveBeenCalled ( ) ; expect ( store . newVersion ) . toEqual ( null ) ; } ) ; it ( 's' , async ( ) => { settingsStoreMock . mock . showUpdateNotifications = true ; fetchMock . andReturn ( new Promise ( ( resolve , reject ) => reject ( 's' ) ) ) ; expect ( fetchMock ) . toNotHaveBeenCalled ( ) ; expect ( store . newVersion ) . toEqual ( null ) ; await store . checkForUpdate ( ) ; expect ( fetchMock ) . toHaveBeenCalled ( ) ; expect ( store . newVersion ) . toEqual ( null ) ; } ) ; it ( 's' , async ( ) => { settingsStoreMock . mock . showUpdateNotifications = false ; expect ( fetchMock ) . toNotHaveBeenCalled ( ) ; expect ( store . newVersion ) . toEqual ( null ) ; await store . checkForUpdate ( ) ; expect ( fetchMock ) . toNotHaveBeenCalled ( ) ; expect ( store . newVersion ) . toEqual ( null ) ; } ) ; afterEach ( ( ) => { kernel . restore ( ) ; } ) ; } ) ;	O $any$ O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O $Symbol$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O $ReleaseStore$ O O $Mock$ O $any$ O O O $Mock$ O $any$ O O O $string$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O O $any$ O $any$ O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O O O $number$ O O O $string$ O O O O O $number$ O O O $string$ O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $void$ O $any$ O $any$ O $any$ O O $void$ O $any$ O $any$ O $any$ O O $void$ O $Symbol$ O $any$ O O $ReleaseStore$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $ReleaseStore$ O $string$ O O $any$ O O O O O $ReleaseStore$ O $Promise<void>$ O O O $any$ O $any$ O O $any$ O O O $any$ O $ReleaseStore$ O $string$ O O $any$ O $string$ O $string$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O O $any$ O $any$ O O O $any$ O O $PromiseConstructor$ O O $void$ O O $void$ O O O $number$ O O O $string$ O O O O O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $ReleaseStore$ O $string$ O O $any$ O O O O O $ReleaseStore$ O $Promise<void>$ O O O $any$ O $any$ O O $any$ O O O $any$ O $ReleaseStore$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $ReleaseStore$ O $string$ O O $any$ O O O O O $ReleaseStore$ O $Promise<void>$ O O O $any$ O $any$ O O $any$ O O O $any$ O $ReleaseStore$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $ReleaseStore$ O $string$ O O $any$ O O O O O $ReleaseStore$ O $Promise<void>$ O O O $any$ O $any$ O O $any$ O O O $any$ O $ReleaseStore$ O $string$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O
import expect from 's' ; import { SettingsStore } from 's' ; import { deepEqual } from 's' ; import { getSettingsMock } from 's' ; import { kernel } from 's' ; function getPersistedStore ( ) { return JSON . parse ( localStorage . getItem ( 's' ) ) ; } describe ( 's' , ( ) => { let settingsMock ; let store ; beforeEach ( ( ) => { kernel . snapshot ( ) ; settingsMock = getSettingsMock ( ) ; store = kernel . get ( SettingsStore ) ; } ) ; it ( 's' , ( ) => { let persistence = getPersistedStore ( ) ; expect ( persistence . locale ) . toBe ( store . locale ) ; deepEqual ( persistence . connectionSettings , store . connectionSettings ) ; } ) ; it ( 's' , ( ) => { let persistence = getPersistedStore ( ) ; expect ( persistence . locale ) . toBe ( store . locale ) ; deepEqual ( persistence . connectionSettings , store . connectionSettings ) ; store . locale = settingsMock . locale ; Object . assign ( store , settingsMock . connectionSettings ) ; persistence = getPersistedStore ( ) ; expect ( persistence . locale ) . toBe ( store . locale ) ; deepEqual ( persistence . connectionSettings , store . connectionSettings ) ; } ) ; it ( 's' , ( ) => { localStorage . setItem ( 's' , JSON . stringify ( settingsMock ) ) ; kernel . unbind ( SettingsStore ) ; kernel . bind ( SettingsStore ) . to ( SettingsStore ) . inSingletonScope ( ) ; store = kernel . get ( SettingsStore ) ; expect ( settingsMock . locale ) . toBe ( store . locale ) ; deepEqual ( settingsMock . connectionSettings , store . connectionSettings ) ; } ) ; afterEach ( ( ) => { localStorage . removeItem ( 's' ) ; kernel . restore ( ) ; } ) ; } ) ;	O $any$ O O O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O $JSON$ O $any$ O $Storage$ O $string$ O O O O O O $any$ O O O O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $SettingsStore$ O $any$ O O O $any$ O $SettingsStore$ O $LOCALE$ O O $any$ O $any$ O $any$ O O O O $SettingsStore$ O $ConnectionParametersModel$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $SettingsStore$ O $any$ O O O $any$ O $SettingsStore$ O $LOCALE$ O O $any$ O $any$ O $any$ O O O O $SettingsStore$ O $ConnectionParametersModel$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $ObjectConstructor$ O O O $any$ O $any$ O $any$ O O $SettingsStore$ O $any$ O O O $any$ O $SettingsStore$ O $LOCALE$ O O $any$ O $any$ O $any$ O O O O $SettingsStore$ O $ConnectionParametersModel$ O $any$ O $any$ O O O O O $any$ O O O O O O O $Storage$ O $void$ O O O $JSON$ O $complex$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $Storage$ O $void$ O O O O $any$ O $any$ O O O O O O O O O
import expect from 's' ; import { UiStore , StopAsyncTask } from 's' ; import { Notification , NOTIFICATION_TYPE , NotificationStore } from 's' ; import { kernel } from 's' ; import { bindMock } from 's' ; import { Mock } from 's' ; describe ( 's' , ( ) => { let store ; let notificationStoreMock < NotificationStore > ; beforeEach ( ( ) => { kernel . snapshot ( ) ; notificationStoreMock = Mock . of ( NotificationStore ) ; bindMock ( NotificationStore , notificationStoreMock . mock ) ; notificationStoreMock . mock . notifications = [ ] ; store = kernel . get ( UiStore ) ; } ) ; it ( 's' , ( ) => { let task = store . startAsyncTask ( ) ; expect ( store . isLoading ) . toBeTruthy ( ) ; task ( ) ; expect ( store . isLoading ) . toBeFalsy ( ) ; } ) ; it ( 's' , ( ) => { let task = store . startAsyncTask ( ) ; expect ( store . isLoading ) . toBeTruthy ( ) ; task ( new Error ( 's' ) ) ; expect ( store . isLoading ) . toBeFalsy ( ) ; expect ( notificationStoreMock . mock . notifications . length ) . toBe ( 0 ) ; let notification = notificationStoreMock . mock . notifications [ 0 ] ; expect ( notification . message ) . toBe ( 's' ) ; expect ( notification . type ) . toBe ( NOTIFICATION_TYPE . ERROR ) ; } ) ; afterEach ( ( ) => { kernel . restore ( ) ; } ) ; } ) ;	O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O $any$ O O O O O O O O $UiStore$ O O $Mock$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $void$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $UiStore$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $StopAsyncTask$ O $UiStore$ O $StopAsyncTask$ O O O $any$ O $UiStore$ O $boolean$ O O $any$ O O O $StopAsyncTask$ O O O $any$ O $UiStore$ O $boolean$ O O $any$ O O O O O O $any$ O O O O O O O O $StopAsyncTask$ O $UiStore$ O $StopAsyncTask$ O O O $any$ O $UiStore$ O $boolean$ O O $any$ O O O $StopAsyncTask$ O O $ErrorConstructor$ O O O O O $any$ O $UiStore$ O $boolean$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $Notification$ O $any$ O $any$ O $any$ O O O O $any$ O $Notification$ O $string$ O O $any$ O O O O $any$ O $Notification$ O $NOTIFICATION_TYPE$ O O $any$ O $any$ O $NOTIFICATION_TYPE.ERROR$ O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O
'js' var testsContext = require . context ( "s" , true , "s" ) ; testsContext . keys ( ) . forEach ( testsContext ) ;	O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O
import expect from 's' ; import { Container , TopModel , DockerFacade , Version , Image } from 's' ; import { getDockerTopMock , getVersionResponseMock , getImageHistoryMock } from 's' ; import { getDockerodeMock , getDockerodeContainerDataMock , getDockerodeContainerMock , getDockerodeImageMock , getDockerodeImageDataMock } from 's' ; import { NotificationStore } from 's' ; import { SettingsStore } from 's' ; import { bindMock } from 's' ; import { kernel } from 's' ; import Dockerode from 's' ; import { getSettingsMock } from 's' ; import { spyOn } from 's' ; import { Mock } from 's' ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { let failActions = false ; let container ; let dockerodeContainerMock < Container > ; let dockerTopMock ; beforeEach ( ( ) => { failActions = false ; dockerodeContainerMock = Mock . of ( Container ) ; dockerTopMock = getDockerTopMock ( ) ; function simpleCb ( cb : ( ( err ) => void ) ) { if ( ! failActions ) { cb ( null ) ; } else { cb ( 's' ) ; } } dockerodeContainerMock . spyOn ( x => x . start ( ) ) . andCall ( simpleCb ) ; dockerodeContainerMock . spyOn ( x => x . stop ( ) ) . andCall ( simpleCb ) ; dockerodeContainerMock . spyOn ( x => x . pause ( ) ) . andCall ( simpleCb ) ; dockerodeContainerMock . spyOn ( x => x . unpause ( ) ) . andCall ( simpleCb ) ; dockerodeContainerMock . spyOn ( x => x . stats ( ) ) . andCall ( ( cb : ( err , data ) => void ) => { if ( ! failActions ) { cb ( null , 's' ) ; } else { cb ( 's' , null ) ; } } ) ; dockerodeContainerMock . spyOn ( x => x . top ( ) ) . andCall ( ( cb : ( err , data ) => void ) => { if ( ! failActions ) { cb ( null , dockerTopMock ) ; } else { cb ( 's' , null ) ; } } ) ; container = new Container ( { } , dockerodeContainerMock . mock ) ; } ) ; it ( 's' , async ( ) => { await Promise . all ( [ 's' , 's' , 's' , 's' ] . map ( async ( action ) => { expect ( dockerodeContainerMock . spyOn ( x => x [ action ] ( ) ) ) . toNotHaveBeenCalled ( ) ; await container [ action ] ( ) ; expect ( dockerodeContainerMock . spyOn ( x => x [ action ] ( ) ) ) . toHaveBeenCalled ( ) ; } ) ) ; expect ( dockerodeContainerMock . spyOn ( x => x . stats ( ) ) ) . toNotHaveBeenCalled ( ) ; let response = await container . stats ( ) ; expect ( dockerodeContainerMock . spyOn ( x => x . stats ( ) ) ) . toHaveBeenCalled ( ) ; expect ( response ) . toBe ( 's' ) ; expect ( dockerodeContainerMock . spyOn ( x => x . top ( ) ) ) . toNotHaveBeenCalled ( ) ; let top = await container . top ( ) ; expect ( dockerodeContainerMock . spyOn ( x => x . top ( ) ) ) . toHaveBeenCalled ( ) ; expect ( top ) . toEqual ( dockerTopMock ) ; } ) ; it ( 's' , async ( ) => { failActions = true ; await Promise . all ( [ 's' , 's' , 's' , 's' ] . map ( async ( action ) => { expect ( dockerodeContainerMock . spyOn ( x => x [ action ] ( ) ) ) . toNotHaveBeenCalled ( ) ; try { await container [ action ] ( ) ; } catch ( e ) { expect ( dockerodeContainerMock . spyOn ( x => x [ action ] ( ) ) ) . toHaveBeenCalled ( ) ; expect ( e ) . toBe ( 's' ) ; } } ) ) ; expect ( dockerodeContainerMock . spyOn ( x => x . stats ( ) ) ) . toNotHaveBeenCalled ( ) ; try { await container . stats ( ) ; } catch ( e ) { expect ( dockerodeContainerMock . spyOn ( x => x . stats ( ) ) ) . toHaveBeenCalled ( ) ; expect ( e ) . toBe ( 's' ) ; } expect ( dockerodeContainerMock . spyOn ( x => x . top ( ) ) ) . toNotHaveBeenCalled ( ) ; try { await container . top ( ) ; } catch ( e ) { expect ( dockerodeContainerMock . spyOn ( x => x . top ( ) ) ) . toHaveBeenCalled ( ) ; expect ( e ) . toBe ( 's' ) ; } } ) ; } ) ; describe ( 's' , ( ) => { let failActions = false ; let image ; let dockerodeImageMock < Image > ; let imageHistoryMock ; beforeEach ( ( ) => { failActions = false ; dockerodeImageMock = Mock . of ( Image ) ; imageHistoryMock = getImageHistoryMock ( ) ; dockerodeImageMock . spyOn ( x => x . history ( ) ) . andCall ( ( cb : ( err , data ) => void ) => { if ( ! failActions ) { cb ( null , imageHistoryMock ) ; } else { cb ( 's' , null ) ; } } ) ; image = new Image ( { } , dockerodeImageMock . mock ) ; } ) ; it ( 's' , async ( ) => { let historySpy = dockerodeImageMock . spyOn ( x => x . history ( ) ) ; expect ( historySpy ) . toNotHaveBeenCalled ( ) ; let history = await image . history ( ) ; expect ( historySpy ) . toHaveBeenCalled ( ) ; expect ( history ) . toEqual ( imageHistoryMock ) ; ( < any > historySpy ) . reset ( ) ; failActions = true ; expect ( historySpy ) . toNotHaveBeenCalled ( ) ; try { await image . history ( ) ; } catch ( e ) { expect ( historySpy ) . toHaveBeenCalled ( ) ; expect ( e ) . toBe ( 's' ) ; } } ) ; } ) ; describe ( 's' , ( ) => { let dockerFacade ; let notificationStoreMock ; let settingsStoreMock ; let dockerodeMock ; let dockerodeContainerMock ; let dockerodeInstance ; let dockerodeContainerDataMock ; let dockerodeImageMock ; let dockerodeImageDataMock ; let versionResponseMock ; let failActions ; beforeEach ( ( ) => { failActions = false ; kernel . snapshot ( ) ; dockerodeMock = getDockerodeMock ( ) ; dockerodeContainerMock = getDockerodeContainerMock ( ) ; dockerodeImageMock = getDockerodeImageMock ( ) ; dockerodeImageDataMock = getDockerodeImageDataMock ( ) ; dockerodeContainerDataMock = getDockerodeContainerDataMock ( ) ; versionResponseMock = getVersionResponseMock ( ) ; settingsStoreMock = getSettingsMock ( ) ; bindMock ( SettingsStore , settingsStoreMock ) ; notificationStoreMock = kernel . get ( NotificationStore ) ; kernel . unbind ( Dockerode ) ; kernel . bind ( Dockerode ) . toConstantValue ( dockerodeMock ) ; dockerFacade = kernel . get ( DockerFacade ) ; dockerodeInstance = ( < any > dockerFacade ) . dockerode ; } ) ; beforeEach ( ( ) => { dockerodeInstance . getContainer . andReturn ( dockerodeContainerMock ) ; dockerodeInstance . getImage . andReturn ( dockerodeImageMock ) ; dockerodeInstance . listContainers . andCall ( ( options , cb : ( err , containers < any > ) => void ) => { if ( ! failActions ) { cb ( null , [ { Id : 's' } , { Id : 's' } ] ) ; } else { cb ( 's' , null ) } } ) ; dockerodeInstance . version . andCall ( ( cb : ( err , data ) => void ) => { if ( ! failActions ) { cb ( null , versionResponseMock ) ; } else { cb ( 's' , null ) ; } } ) ; dockerodeInstance . listImages . andCall ( ( query , cb : ( err , data ) => void ) => { if ( ! failActions ) { cb ( null , [ { Id : 's' } , { Id : 's' } ] ) ; } else { cb ( 's' , null ) ; } } ) ; dockerodeContainerMock . inspect . andCall ( ( query , cb : ( err , data ) => void ) => { if ( ! failActions ) { cb ( null , dockerodeContainerDataMock ) ; } else { cb ( 's' , null ) ; } } ) ; dockerodeContainerMock . remove . andCall ( ( query , cb : ( err ) => void ) => { if ( ! failActions ) { cb ( null ) ; } else { cb ( 's' ) ; } } ) ; dockerodeImageMock . inspect . andCall ( ( cb : ( err , data ) => void ) => { if ( ! failActions ) { cb ( null , dockerodeImageDataMock ) ; } else { cb ( 's' , null ) ; } } ) ; dockerodeImageMock . remove . andCall ( ( query , cb : ( err ) => void ) => { if ( ! failActions ) { cb ( null ) ; } else { cb ( 's' ) ; } } ) ; } ) ; it ( 's' , async ( ) => { expect ( dockerodeInstance . getContainer ) . toNotHaveBeenCalled ( ) ; expect ( dockerodeContainerMock . inspect ) . toNotHaveBeenCalled ( ) ; let container = await dockerFacade . getContainer ( 's' ) ; expect ( dockerodeInstance . getContainer ) . toHaveBeenCalledWith ( 's' ) ; expect ( dockerodeContainerMock . inspect ) . toHaveBeenCalled ( ) ; expect ( container ) . toBeA ( Container ) ; failActions = true ; try { await dockerFacade . getContainer ( 's' ) ; } catch ( e ) { expect ( e ) . toBe ( 's' ) ; } } ) ; it ( 's' , async ( ) => { expect ( dockerodeInstance . getContainer ) . toNotHaveBeenCalled ( ) ; expect ( dockerodeContainerMock . remove ) . toNotHaveBeenCalled ( ) ; await dockerFacade . removeContainer ( 's' ) ; expect ( dockerodeInstance . getContainer ) . toHaveBeenCalledWith ( 's' ) ; expect ( dockerodeContainerMock . remove ) . toHaveBeenCalled ( ) ; failActions = true ; try { await dockerFacade . removeContainer ( 's' ) ; } catch ( e ) { expect ( e ) . toBe ( 's' ) ; } } ) ; it ( 's' , async ( ) => { expect ( dockerodeInstance . version ) . toNotHaveBeenCalled ( ) ; let version = await dockerFacade . version ( ) ; expect ( dockerodeInstance . version ) . toHaveBeenCalled ( ) ; expect ( version ) . toEqual ( versionResponseMock ) ; failActions = true ; try { await dockerFacade . version ( ) ; } catch ( e ) { expect ( e ) . toBe ( 's' ) ; } } ) ; it ( 's' , async ( ) => { let spy = spyOn ( dockerFacade , 's' ) . andReturn ( new Promise ( ( resolve , reject ) => resolve ( { } ) ) ) ; expect ( dockerodeInstance . listContainers ) . toNotHaveBeenCalled ( ) ; expect ( dockerFacade . getContainer ) . toNotHaveBeenCalled ( ) ; let containers < Container > = await dockerFacade . listAllContainers ( ) ; expect ( dockerodeInstance . listContainers ) . toHaveBeenCalled ( ) ; expect ( spy . calls . length ) . toBe ( 0 ) ; expect ( spy . calls [ 0 ] . arguments ) . toEqual ( [ 's' ] ) ; expect ( spy . calls [ 0 ] . arguments ) . toEqual ( [ 's' ] ) ; expect ( containers ) . toEqual ( [ { } , { } ] ) ; failActions = true ; try { await dockerFacade . listAllContainers ( ) ; } catch ( e ) { expect ( e ) . toBe ( 's' ) ; } } ) ; it ( 's' , async ( ) => { expect ( dockerodeInstance . getImage ) . toNotHaveBeenCalled ( ) ; expect ( dockerodeImageMock . inspect ) . toNotHaveBeenCalled ( ) ; let image = await dockerFacade . getImage ( 's' ) ; expect ( dockerodeInstance . getImage ) . toHaveBeenCalledWith ( 's' ) ; expect ( dockerodeImageMock . inspect ) . toHaveBeenCalled ( ) ; expect ( image ) . toBeA ( Image ) ; failActions = true ; try { await dockerFacade . getImage ( 's' ) ; } catch ( e ) { expect ( e ) . toBe ( 's' ) ; } } ) ; it ( 's' , async ( ) => { expect ( dockerodeInstance . getImage ) . toNotHaveBeenCalled ( ) ; expect ( dockerodeImageMock . remove ) . toNotHaveBeenCalled ( ) ; await dockerFacade . removeImage ( 's' ) ; expect ( dockerodeInstance . getImage ) . toHaveBeenCalledWith ( 's' ) ; expect ( dockerodeImageMock . remove ) . toHaveBeenCalled ( ) ; failActions = true ; try { await dockerFacade . removeImage ( 's' ) ; } catch ( e ) { expect ( e ) . toBe ( 's' ) ; } } ) ; it ( 's' , async ( ) => { let spy = spyOn ( dockerFacade , 's' ) . andReturn ( new Promise ( ( resolve , reject ) => resolve ( { } ) ) ) ; expect ( dockerodeInstance . listImages ) . toNotHaveBeenCalled ( ) ; expect ( dockerFacade . getImage ) . toNotHaveBeenCalled ( ) ; let containers < Image > = await dockerFacade . listImages ( ) ; expect ( dockerodeInstance . listImages ) . toHaveBeenCalled ( ) ; expect ( spy . calls . length ) . toBe ( 0 ) ; expect ( spy . calls [ 0 ] . arguments ) . toEqual ( [ 's' ] ) ; expect ( spy . calls [ 0 ] . arguments ) . toEqual ( [ 's' ] ) ; expect ( containers ) . toEqual ( [ { } , { } ] ) ; failActions = true ; try { await dockerFacade . listImages ( ) ; } catch ( e ) { expect ( e ) . toBe ( 's' ) ; } } ) ; it ( 's' , async ( ) => { let spy = spyOn ( dockerFacade , 's' ) . andReturn ( new Promise ( ( resolve , reject ) => resolve ( { } ) ) ) ; expect ( dockerodeInstance . listImages ) . toNotHaveBeenCalled ( ) ; expect ( dockerFacade . getImage ) . toNotHaveBeenCalled ( ) ; let containers < Image > = await dockerFacade . listDanglingImages ( ) ; expect ( dockerodeInstance . listImages ) . toHaveBeenCalled ( ) ; expect ( dockerodeInstance . listImages . getLastCall ( ) . arguments [ 0 ] ) . toEqual ( { filters : { dangling : [ 's' ] } } ) ; expect ( spy . calls . length ) . toBe ( 0 ) ; expect ( spy . calls [ 0 ] . arguments ) . toEqual ( [ 's' ] ) ; expect ( spy . calls [ 0 ] . arguments ) . toEqual ( [ 's' ] ) ; expect ( containers ) . toEqual ( [ { } , { } ] ) ; failActions = true ; try { await dockerFacade . listImages ( ) ; } catch ( e ) { expect ( e ) . toBe ( 's' ) ; } } ) ; afterEach ( ( ) => { kernel . restore ( ) ; } ) ; } ) ; } ) ;	O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $TopModel$ O $Version$ O $HistoryEntry$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O $Dockerode$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $boolean$ O O O O $any$ O O $Mock$ O $any$ O O O $any$ O $any$ O O O O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $TopModel$ O O O O $void$ O $void$ O O O $any$ O O O O O O O O O $boolean$ O O $void$ O O O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $void$ O O $any$ O $any$ O O O O O O O O O $boolean$ O O $void$ O O O O O O O O O $void$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $void$ O O $any$ O $TopModel$ O O O O O O O O O $boolean$ O O $void$ O O O $any$ O O O O O $void$ O O O O O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $PromiseConstructor$ O O O O O O O O O O O O O $U[]$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O O O O $any$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $boolean$ O O O O $PromiseConstructor$ O O O O O O O O O O O O O $U[]$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $boolean$ O O O O $Image$ O O $Mock$ O $any$ O O O $any$ O $any$ O O O O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $HistoryEntry$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $void$ O O $any$ O $TopModel$ O O O O O O O O O $boolean$ O O $void$ O O O $any$ O O O O O $void$ O O O O O O O O O O $Image$ O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O O $Image$ O $Promise<any>$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O O O $boolean$ O O O $any$ O $any$ O O $any$ O O O O O O $Image$ O $Promise<any>$ O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $DockerFacade$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $Version$ O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $Dockerode$ O O $any$ O $any$ O $Dockerode$ O O $any$ O $any$ O O $DockerFacade$ O $any$ O $any$ O $any$ O O $any$ O O O O O $DockerFacade$ O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $Object$ O $void$ O O $any$ O $Array$ O O O O O O O O O O O O $any$ O O $void$ O O O O O $string$ O O O O O $string$ O O O O O O O O O $void$ O O O O O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $Version$ O O O O O O O O O $any$ O O $void$ O O O $any$ O O O O O $void$ O O O O O O O O O O $any$ O $any$ O $any$ O O $Object$ O $void$ O O $any$ O $any$ O O O O O O O O O $any$ O O $void$ O O O O O $string$ O O O O O $string$ O O O O O O O O O $void$ O O O O O O O O O O $any$ O $any$ O $any$ O O $Object$ O $void$ O O $any$ O $any$ O O O O O O O O O $any$ O O $void$ O O O $any$ O O O O O $void$ O O O O O O O O O O $any$ O $any$ O $any$ O O $Object$ O $void$ O O $any$ O O O O O O O O O $any$ O O $void$ O O O O O O O $void$ O O O O O O O O $any$ O $any$ O $any$ O O $void$ O O $any$ O $any$ O O O O O O O O O $any$ O O $void$ O O O $any$ O O O O O $void$ O O O O O O O O O O $any$ O $any$ O $any$ O O $Object$ O $void$ O O $any$ O O O O O O O O O $any$ O O $void$ O O O O O O O $void$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $Container$ O O $DockerFacade$ O $Promise<Container>$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $Container$ O O $any$ O $any$ O O $any$ O O O O O O $DockerFacade$ O $Promise<Container>$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $DockerFacade$ O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O O O $DockerFacade$ O $Promise<void>$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $Version$ O O $DockerFacade$ O $Promise<Version>$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $Version$ O O $any$ O $any$ O O $any$ O O O O O O $DockerFacade$ O $Promise<Version>$ O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $DockerFacade$ O O O O $any$ O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $DockerFacade$ O $Promise<Container>$ O O $any$ O O O O $Array$ O $any$ O O O $DockerFacade$ O $Promise<Container[]>$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O $Container[]$ O O $any$ O O O O O O O O O O $any$ O O O O O O $DockerFacade$ O $Promise<Container[]>$ O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $Image$ O O $DockerFacade$ O $Promise<Image>$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $Image$ O O $any$ O $any$ O O $any$ O O O O O O $DockerFacade$ O $Promise<Image>$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $DockerFacade$ O $Promise<void>$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O O O $DockerFacade$ O $Promise<void>$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $DockerFacade$ O O O O $any$ O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $DockerFacade$ O $Promise<Image>$ O O $any$ O O O O $Array$ O $any$ O O O $DockerFacade$ O $Promise<Image[]>$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O $Image[]$ O O $any$ O O O O O O O O O O $any$ O O O O O O $DockerFacade$ O $Promise<Image[]>$ O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $DockerFacade$ O O O O $any$ O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $DockerFacade$ O $Promise<Image>$ O O $any$ O O O O $Array$ O $any$ O O O $DockerFacade$ O $Promise<Image[]>$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O $complex$ O O $string[]$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O $Image[]$ O O $any$ O O O O O O O O O O $any$ O O O O O O $DockerFacade$ O $Promise<Image[]>$ O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O
import expect from 's' ; import { normalizePort , parseBytes , normalizeContainerName , parseLocale , normalizeImageId , parseRepoTags } from 's' ; import { LOCALE } from 's' ; describe ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { let port = 's' ; let parsedPort = normalizePort ( port ) ; expect ( parsedPort . port ) . toBe ( 0 ) ; expect ( parsedPort . protocol ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( ( ) => normalizePort ( 's' ) ) . toThrow ( ) ; expect ( ( ) => normalizePort ( 's' ) ) . toThrow ( ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { let 0 = 's' ; let 0 = 's' ; let 0 = normalizeImageId ( 0 ) ; let 0 = normalizeImageId ( 0 ) ; expect ( 0 ) . toBe ( 's' ) ; expect ( 0 ) . toBe ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( parseRepoTags ( null ) ) . toBe ( null ) ; expect ( parseRepoTags ( [ ] ) ) . toBe ( null ) ; } ) ; it ( 's' , ( ) => { let repoTags = [ 's' , 's' ] ; let parsed = parseRepoTags ( repoTags ) ; expect ( parsed . name ) . toBe ( 's' ) ; expect ( parsed . tags . length ) . toBe ( 0 ) ; expect ( parsed . tags ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( 's' , ( ) => { let repoTags = [ 's' ] ; let parsed = parseRepoTags ( repoTags ) ; expect ( parsed . name ) . toBe ( 's' ) ; expect ( parsed . tags . length ) . toBe ( 0 ) ; expect ( parsed . tags ) . toEqual ( [ 's' ] ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const 0 = parseBytes ( 0 ) ; expect ( 0 . size ) . toBe ( 0 ) ; expect ( 0 . unit ) . toBe ( 's' ) ; const 0 = parseBytes ( 0 ) ; expect ( 0 . size ) . toBe ( 0 ) ; expect ( 0 . unit ) . toBe ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const 0 = normalizeContainerName ( 's' ) ; expect ( 0 ) . toBe ( 's' ) ; const 0 = normalizeContainerName ( 's' ) ; expect ( 0 ) . toBe ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const locale = parseLocale ( LOCALE . DE_DE ) ; expect ( locale . country ) . toBe ( 's' ) ; expect ( locale . language ) . toBe ( 's' ) ; expect ( locale . fullLocale ) . toBe ( 's' ) ; } ) ; } ) ; } ) ;	O $any$ O O O O O $Port$ O $complex$ O $string$ O $complex$ O $string$ O $complex$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $string$ O O O O $Port$ O $Port$ O $string$ O O $any$ O $Port$ O $number$ O O $any$ O O O O $any$ O $Port$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $Port$ O O O O O $any$ O O O $any$ O O O O $Port$ O O O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $string$ O O O O $string$ O O O O $string$ O $string$ O $string$ O O O $string$ O $string$ O $string$ O O $any$ O $string$ O O $any$ O O O O $any$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $complex$ O O O O O $any$ O O O O $any$ O $complex$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $string[]$ O O O O O O O O $complex$ O $complex$ O $string[]$ O O $any$ O $complex$ O $string$ O O $any$ O O O O $any$ O $complex$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $complex$ O $string[]$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $string[]$ O O O O O O $complex$ O $complex$ O $string[]$ O O $any$ O $complex$ O $string$ O O $any$ O O O O $any$ O $complex$ O $string[]$ O $number$ O O $any$ O O O O $any$ O $complex$ O $string[]$ O O $any$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O O $any$ O $complex$ O $number$ O O $any$ O O O O $any$ O $complex$ O $string$ O O $any$ O O O O O $complex$ O $complex$ O O O O $any$ O $complex$ O $number$ O O $any$ O O O O $any$ O $complex$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $string$ O $string$ O O O O $any$ O $string$ O O $any$ O O O O O $string$ O $string$ O O O O $any$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O $any$ O $LOCALE.DE_DE$ O O $any$ O $complex$ O $string$ O O $any$ O O O O $any$ O $complex$ O $string$ O O $any$ O O O O $any$ O $complex$ O $string$ O O $any$ O O O O O O O O O O O O O
import expect from 's' ; import { provideInstance , provideSingleton , kernel , inject } from 's' ; describe ( 's' , ( ) => { beforeEach ( ( ) => { } ) ; describe ( 's' , ( ) => { @ provideInstance ( InstanceClass ) class InstanceClass { } @ provideSingleton ( SingletonClass ) class SingletonClass { } it ( 's' , ( ) => { let 0 = kernel . get < InstanceClass > ( InstanceClass ) ; let 0 = kernel . get < InstanceClass > ( InstanceClass ) ; expect ( 0 ) . toBeTruthy ( ) ; expect ( 0 ) . toBeTruthy ( ) ; expect ( 0 ) . toNotBe ( 0 ) ; } ) ; } ) ; describe ( 's' , ( ) => { @ provideInstance ( InstanceClass ) class InstanceClass { } @ provideSingleton ( SingletonClass ) class SingletonClass { } it ( 's' , ( ) => { let 0 = kernel . get < SingletonClass > ( SingletonClass ) ; let 0 = kernel . get < SingletonClass > ( SingletonClass ) ; expect ( 0 ) . toBeTruthy ( ) ; expect ( 0 ) . toBeTruthy ( ) ; expect ( 0 ) . toBe ( 0 ) ; } ) ; } ) ; describe ( 's' , ( ) => { @ provideInstance ( InstanceClass ) class InstanceClass { } @ provideSingleton ( SingletonClass ) class SingletonClass { } class Service { @ inject ( InstanceClass ) instanceClass : InstanceClass ; @ inject ( SingletonClass ) singletonClass : SingletonClass ; } class ServiceWithDuplicatedInjects { @ inject ( InstanceClass ) instanceClass : InstanceClass ; @ inject ( SingletonClass ) singletonClass : SingletonClass ; @ inject ( InstanceClass ) 0 : InstanceClass ; @ inject ( SingletonClass ) 0 : SingletonClass ; } it ( 's' , ( ) => { const s = new Service ( ) ; expect ( s . instanceClass ) . toBeTruthy ( ) ; expect ( s . singletonClass ) . toBeTruthy ( ) ; expect ( s . singletonClass ) . toBe ( s . singletonClass ) ; expect ( s . instanceClass ) . toBe ( s . instanceClass ) ; } ) ; it ( 's' , ( ) => { const s = new Service ( ) ; expect ( s . singletonClass ) . toBe ( kernel . get < SingletonClass > ( SingletonClass ) ) ; } ) ; it ( 's' , ( ) => { const s = new Service ( ) ; const 0 = new Service ( ) ; expect ( s . instanceClass ) . toNotBe ( 0 . instanceClass ) ; expect ( s . singletonClass ) . toBe ( 0 . singletonClass ) ; } ) ; it ( 's' , ( ) => { const s = new ServiceWithDuplicatedInjects ( ) ; const 0 = new ServiceWithDuplicatedInjects ( ) ; expect ( s . instanceClass ) . toBeTruthy ( ) ; expect ( s . singletonClass ) . toBeTruthy ( ) ; expect ( s . 0 ) . toBeTruthy ( ) ; expect ( s . 0 ) . toBeTruthy ( ) ; expect ( s . instanceClass ) . toBe ( s . instanceClass ) ; expect ( s . singletonClass ) . toBe ( s . singletonClass ) ; expect ( s . 0 ) . toBe ( s . 0 ) ; expect ( s . 0 ) . toBe ( s . 0 ) ; expect ( 0 . instanceClass ) . toBeTruthy ( ) ; expect ( 0 . singletonClass ) . toBeTruthy ( ) ; expect ( 0 . 0 ) . toBeTruthy ( ) ; expect ( 0 . 0 ) . toBeTruthy ( ) ; expect ( 0 . instanceClass ) . toBe ( 0 . instanceClass ) ; expect ( 0 . singletonClass ) . toBe ( 0 . singletonClass ) ; expect ( 0 . 0 ) . toBe ( 0 . 0 ) ; expect ( 0 . 0 ) . toBe ( s . 0 ) ; expect ( s . instanceClass ) . toNotBe ( s . 0 ) ; expect ( 0 . instanceClass ) . toNotBe ( 0 . 0 ) ; expect ( s . instanceClass ) . toNotBe ( 0 . 0 ) ; } ) ; } ) ; afterEach ( ( ) => { } ) ; } ) ;	O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O $any$ O $InstanceClass$ O $any$ O O $any$ O $any$ O $SingletonClass$ O $any$ O O O $any$ O O $any$ O $any$ O $InstanceClass$ O $any$ O O $any$ O $any$ O $SingletonClass$ O $any$ O O $any$ O $any$ O $InstanceClass$ O $any$ O O $any$ O $any$ O $SingletonClass$ O $any$ O O $any$ O O O O O O O O $Service$ O O $any$ O O O $any$ O $Service$ O $InstanceClass$ O O $any$ O O O $any$ O $Service$ O $SingletonClass$ O O $any$ O O O $any$ O $Service$ O $SingletonClass$ O O $any$ O $Service$ O $SingletonClass$ O O $any$ O $Service$ O $InstanceClass$ O O $any$ O $Service$ O $InstanceClass$ O O O O O $any$ O O O O O O O O $Service$ O O $any$ O O O $any$ O $Service$ O $SingletonClass$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $Service$ O O $any$ O O O O $Service$ O O $any$ O O O $any$ O $Service$ O $InstanceClass$ O O $any$ O $Service$ O $InstanceClass$ O O $any$ O $Service$ O $SingletonClass$ O O $any$ O $Service$ O $SingletonClass$ O O O O O $any$ O O O O O O O O $ServiceWithDuplicatedInjects$ O O $any$ O O O O $ServiceWithDuplicatedInjects$ O O $any$ O O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O O O $any$ O $ServiceWithDuplicatedInjects$ O $SingletonClass$ O O $any$ O O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O O O $any$ O $ServiceWithDuplicatedInjects$ O $SingletonClass$ O O $any$ O O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $SingletonClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $SingletonClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $SingletonClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $SingletonClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O O O $any$ O $ServiceWithDuplicatedInjects$ O $SingletonClass$ O O $any$ O O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O O O $any$ O $ServiceWithDuplicatedInjects$ O $SingletonClass$ O O $any$ O O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $SingletonClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $SingletonClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $SingletonClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $SingletonClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O $any$ O $ServiceWithDuplicatedInjects$ O $InstanceClass$ O O O O O O O O $any$ O O O O O O O O O O O
'js' var path = require ( 's' ) ; module . exports = function ( config ) { config . set ( { basePath : 's' , frameworks : [ 's' , 's' ] , files : [ path . join ( 's' , 's' , 's' , 's' ) , path . join ( 's' , 's' , 's' ) , 's' ] , plugins : [ 's' , 's' , 's' , 's' , 's' , 's' ] , preprocessors : { 's' : [ 's' , 's' , 's' ] } , reporters : [ 's' , 's' ] , port : 0 , colors : true , logLevel : config . LOG_INFO , autoWatch : false , browsers : [ 's' ] , singleRun : true , concurrency : Infinity , coverageReporter : { reporters : [ { type : 's' , dir : 's' , subdir : 's' , file : 's' } ] } } ) } ;	O O $any$ O $any$ O O O O $void$ O $void$ O O O $any$ O O $any$ O $any$ O O $string$ O O O $string[]$ O O O O O O O $any[]$ O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O $string[]$ O O O O O O O O O O O O O O O $complex$ O O O O O O O O O O O O O $string[]$ O O O O O O O $number$ O O O $boolean$ O O O $any$ O $any$ O $any$ O $boolean$ O O O $string[]$ O O O O O $boolean$ O O O $number$ O $number$ O $complex$ O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O
'js' var istanbul = require ( 's' ) ; var collector = new istanbul . Collector ( ) ; var reporter = new istanbul . Reporter ( ) ; var remappedJson = require ( 's' ) ; var keys = Object . keys ( remappedJson ) ; var coverage = { } ; for ( var i = 0 ; i < keys . length ; i ++ ) { if ( keys [ i ] . startsWith ( 's' ) ) { coverage [ keys [ i ] ] = remappedJson [ keys [ i ] ] ; } } collector . add ( coverage ) ; switch ( process . argv [ 0 ] ) { case 's' : reporter . add ( 's' ) ; break ; case 's' : reporter . add ( 's' ) ; break ; case 's' : reporter . add ( 's' ) ; break ; case 's' : default : reporter . add ( 's' ) ; } reporter . write ( collector , true , function ( ) { } ) ;	O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $any$ O O O ${}$ O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O O $string[]$ O $number$ O O $boolean$ O O O O O ${}$ O $string[]$ O $number$ O O O $any$ O $string[]$ O $number$ O O O O O $any$ O $any$ O ${}$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O
'js' var path = require ( 's' ) ; var webpack = require ( 's' ) ; var HtmlWebpackPlugin = require ( 's' ) ; var ExtractTextPlugin = require ( 's' ) ; var nodeExternals = require ( 's' ) ; var version = require ( 's' ) . version ; module . exports = { externals : [ nodeExternals ( { whitelist : [ 's' , 's' , 's' , 's' , 's' , 's' ] , modulesFromFile : false , modulesDir : path . resolve ( __dirname , 's' , 's' ) } ) , { fs : 's' , electron : 's' , JSONStream : 's' } ] , entry : [ 's' ] , output : { path : path . resolve ( __dirname , 's' , 's' ) , filename : 's' } , module : { loaders : [ { test : "s" , exclude : [ "s" ] , loaders : [ 's' , 's' ] } , { test : "s" , include : "s" , loader : ExtractTextPlugin . extract ( 's' , 's' ) } , { test : "s" , loader : 's' } , { test : "s" , loader : 's' } , { test : "s" , loader : 's' } , { test : "s" , loader : 's' } ] } , plugins : [ new webpack . optimize . OccurrenceOrderPlugin ( ) , new HtmlWebpackPlugin ( { template : 's' } ) , new ExtractTextPlugin ( 's' , { allChunks : true } ) , new webpack . NoErrorsPlugin ( ) , require ( 's' ) , new webpack . DefinePlugin ( { __DEVELOP__ : process . env . NODE_ENV === 's' , __PRODUCTION__ : process . env . NODE_ENV === 's' , __VERSION__ : JSON . stringify ( version ) } ) ] , resolve : { extensions : [ 's' , 's' , 's' , 's' ] , modulesDirectories : [ 's' , 's' ] } } ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $complex$ O $complex$ O O $any[]$ O O $any$ O O $string[]$ O O O O O O O O O O O O O O O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $string$ O O O $string$ O O O $string$ O O O O O $string[]$ O O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O O O O $complex$ O O $complex$ O O O $RegExp$ O O O $RegExp[]$ O O O O O $string[]$ O O O O O O O O O $RegExp$ O O O $RegExp$ O O O $any$ O $any$ O $any$ O O O O O O O O $RegExp$ O O O $string$ O O O O O $RegExp$ O O O $string$ O O O O O $RegExp$ O O O $string$ O O O O O $RegExp$ O O O $string$ O O O O O O $any[]$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $string$ O O O O O O $any$ O O O O $boolean$ O O O O O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O O $boolean$ O $any$ O $any$ O $any$ O O O $boolean$ O $any$ O $any$ O $any$ O O O $string$ O $JSON$ O $complex$ O $any$ O O O O O $complex$ O O $string[]$ O O O O O O O O O O O $string[]$ O O O O O O O O O
'js' var conf = require ( 's' ) ; var webpack = require ( 's' ) ; conf . devtool = 's' ; conf . entry . unshift ( 's' ) ; conf . output . publicPath = 's' ; conf . module . loaders . push ( { test : "s" , loaders : [ 's' , 's' ] , exclude : "s" } ) ; module . exports = conf ;	O O $complex$ O $any$ O O O O O $any$ O $any$ O O O O $complex$ O $any$ O O O $complex$ O $string[]$ O $number$ O O O O $complex$ O $complex$ O $any$ O O O $complex$ O $complex$ O $complex$ O $number$ O O $RegExp$ O O O $string[]$ O O O O O O O $RegExp$ O O O O O $complex$ O $complex$ O $complex$ O
'js' var conf = require ( 's' ) ; var webpack = require ( 's' ) ; var ExtractTextPlugin = require ( 's' ) ; conf . output . filename = 's' ; conf . module . loaders . push ( { test : "s" , loader : ExtractTextPlugin . extract ( 's' , 's' ) , exclude : "s" } ) ; conf . plugins . push ( new webpack . optimize . UglifyJsPlugin ( { compress : { warnings : false } } ) ) ; module . exports = conf ;	O O $complex$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $complex$ O $complex$ O $string$ O O O $complex$ O $complex$ O $complex$ O $number$ O O $RegExp$ O O O $any$ O $any$ O $any$ O O O O O O $RegExp$ O O O O O $complex$ O $any[]$ O $number$ O O $any$ O $any$ O $any$ O O $complex$ O O $boolean$ O O O O O O O $complex$ O $complex$ O $complex$ O
'js' var path = require ( 's' ) ; var webpack = require ( 's' ) ; var conf = require ( 's' ) ; conf . devtool = 's' ; conf . externals . shift ( ) ; for ( var i = 0 ; i < conf . module . loaders . length ; i ++ ) { conf . module . loaders [ i ] . loader = 's' ; } conf . module . loaders . push ( { test : "s" , loader : 's' , exclude : "s" } ) ; delete conf . entry ; delete conf . output ; conf . entry = [ 's' ] ; conf . output = { path : path . resolve ( __dirname , 's' , 's' ) , devtoolModuleFilenameTemplate : 's' , filename : 's' } ; conf . plugins . shift ( ) ; conf . plugins . shift ( ) ; conf . plugins . shift ( ) ; conf . plugins . shift ( ) ; module . exports = conf ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $complex$ O $any$ O O O O $complex$ O $any$ O O O $complex$ O $any[]$ O $any$ O O O O O O $number$ O O O $number$ O $complex$ O $complex$ O $complex$ O $number$ O $number$ O O O $complex$ O $complex$ O $complex$ O $number$ O O $any$ O O O O $complex$ O $complex$ O $complex$ O $number$ O O $RegExp$ O O O $string$ O O O $RegExp$ O O O O O O $complex$ O $string[]$ O O $complex$ O $complex$ O $complex$ O $string[]$ O O O O O $complex$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O O O $string$ O O O O $complex$ O $any[]$ O $any$ O O O $complex$ O $any[]$ O $any$ O O O $complex$ O $any[]$ O $any$ O O O $complex$ O $any[]$ O $any$ O O O $complex$ O $complex$ O $complex$ O