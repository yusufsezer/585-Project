jest . mock ( "s" , ( ) => ( { talk : jest . fn ( ) , } ) ) ; jest . mock ( "s" , ( ) => ( { cachedCrop : jest . fn ( ( ) => Promise . resolve ( { svg_icon : "s" } ) ) , } ) ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O $string$ O O O O O O O O O O
interface Token { unencoded : UnencodedToken ; encoded : string ; } export interface AuthState { token : Token ; } interface UnencodedToken { iss : string ; os_update_server : string ; beta_os_update_server ? : string ; jti : string ; }	O $any$ O $UnencodedToken$ O $any$ O $string$ O O O O O O $any$ O $Token$ O $any$ O O O $any$ O $string$ O O O $string$ O O O $string$ O O O O $string$ O O O O
export interface ChangeApiHost { host : string ; } export interface ChangeApiPort { port : string ; } export interface ConfigState { host : string ; port : string ; }	O O $any$ O $string$ O O O O O O $any$ O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O O
import { SequenceBodyItem as Step } from "s" ; export type DataXfer = StepSpliceDataXfer | StepMoveDataXfer ; export type DataXferIntent = "s" | "s" ; export interface DataXferBase { draggerId : number ; value : Step ; uuid : string ; intent : DataXferIntent ; } export interface StepSpliceDataXfer extends DataXferBase { intent : "s" ; } export interface StepMoveDataXfer extends DataXferBase { intent : "s" ; } export interface DraggableState { dataTransfer : { [ key ] : DataXfer | undefined } ; } export interface DropAreaProps { callback ? : ( key ) => void ; isLocked ? : boolean ; } export interface DropAreaState { isHovered ? : boolean ; } export interface StepDraggerProps { dispatch : Function ; step : Step ; intent : DataXferIntent ; children ? : React . ReactNode ; draggerId : number ; }	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O O $any$ O $number$ O O O $any$ O $any$ O $string$ O O O $DataXferIntent$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $complex$ O O O $string$ O O $any$ O O O O O O O $any$ O $void$ O O O $string$ O O O O $boolean$ O O O O O O O $any$ O $boolean$ O O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any$ O $any$ O $DataXferIntent$ O $any$ O $any$ O O $any$ O $any$ O $number$ O O O O
import { TaggedPeripheral } from "s" ; import { Pins } from "s" ; export interface PeripheralState { isEditing : boolean ; } export interface PeripheralFormProps { dispatch : Function ; peripherals : TaggedPeripheral [ ] ; } export interface PeripheralListProps { dispatch : Function ; peripherals : TaggedPeripheral [ ] ; pins : Pins ; disabled : boolean | undefined ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $boolean$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any[]$ O $any$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any[]$ O $any$ O O O $any$ O $any$ O $boolean$ O O O O O O
import { AuthState } from "s" ; import { ConfigState } from "s" ; import { BotState } from "s" ; import { Color as FarmBotJsColor } from "s" ; import { DraggableState } from "s" ; import { PeripheralState } from "s" ; import { RestResources } from "s" ; export type ResourceColor = FarmBotJsColor ; export interface Everything { config : ConfigState ; auth : AuthState | undefined ; dispatch : Function ; bot : BotState ; draggable : DraggableState ; Peripheral : PeripheralState ; resources : RestResources ; } export type UnsafeError = any ; export interface TimeSettings { utcOffset : number ; 0 : boolean ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O $any$ O $ConfigState$ O $any$ O $AuthState$ O $any$ O O O $Function$ O $FunctionConstructor$ O $BotState$ O $any$ O $DraggableState$ O $any$ O $PeripheralState$ O $any$ O $RestResources$ O $any$ O O O O $any$ O O O O O $any$ O $number$ O O O $boolean$ O O O O
import { history } from "s" ; import { trim } from "s" ; export function urlFriendly ( stringToFormat ) { return encodeURIComponent ( stringToFormat . replace ( "s" , "s" ) . toLowerCase ( ) ) ; } export function lastUrlChunk ( ) { const p = history . getCurrentLocation ( ) . pathname ; const pathArray = trim ( p , "s" ) . split ( "s" ) ; return pathArray [ pathArray . length - 0 ] ; }	O O $any$ O O O O O O $any$ O O O O O O $string$ O $string$ O O O $string$ O $string$ O $complex$ O O O O O O $string$ O O O O O O O $string$ O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O
import { ResourceColor , TimeSettings } from "s" ; import { box } from "s" ; import { TaggedResource , TaggedFirmwareConfig , TaggedFbosConfig , Dictionary , ResourceName , } from "s" ; import { BotLocationData } from "s" ; import { sample , padStart , sortBy , merge , isNumber , isUndefined as lodashIsUndefined } from "s" ; import { t } from "s" ; export let colors < ResourceColor > = [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ; export function randomColor ( ) { return sample ( colors ) as typeof colors [ 0 ] ; } export function defensiveClone < T > ( target : T ) : T { const jsonString = JSON . stringify ( target ) ; return JSON . parse ( jsonString || "s" ) ; } export function safeStringFetch ( obj : { } , key ) { const boxed = box ( ( obj as Dictionary < { } > ) [ key ] ) ; switch ( boxed . kind ) { case "s" : case "s" : return "s" ; case "s" : case "s" : return boxed . value . toString ( ) ; case "s" : return ( boxed . value ) ? "s" : "s" ; default : const msg = t ( `template` ) ; throw new Error ( msg ) ; } } export function fancyDebug < T extends { } > ( d : T ) : T { console . log ( Object . keys ( d ) . map ( key => [ key , ( d as Dictionary < string > ) [ key ] ] ) . map ( ( x ) => { const key = padStart ( x [ 0 ] , 0 , "s" ) ; const val = ( JSON . stringify ( x [ 0 ] ) || "s" ) . slice ( 0 , 0 ) ; return `template` ; } ) . join ( "s" ) ) ; return d ; } export type CowardlyDictionary < T > = Dictionary < T | undefined > ; export const NOT_SAVED = - 0 ; export function isUndefined ( x : object | undefined ) : x is undefined { return lodashIsUndefined ( x ) ; } export function betterCompact < T > ( input : ( T | undefined ) [ ] ) : T [ ] { const output : T [ ] = [ ] ; input . forEach ( x => x ? output . push ( x ) : "s" ) ; return output ; } export function sortResourcesById < T extends TaggedResource > ( input : T [ ] ) : T [ ] { return sortBy ( input , ( x ) => x . body . id || Infinity ) ; } export function betterMerge < T , U > ( target : T , update : U ) : T & U { return merge ( { } , target , update ) ; } export function betterParseNum ( num : string | undefined , fallback ) { try { const maybe = JSON . parse ( "s" + num ) ; if ( isNumber ( maybe ) && ! isNaN ( maybe ) ) { return maybe ; } } catch ( _ ) { } return fallback ; } export function oneOf ( list : string [ ] , target ) { let matches = 0 ; list . map ( x => target . includes ( x ) ? matches ++ : "s" ) ; return ! ! matches ; } export type Primitive = boolean | string | number ; export function shortRevision ( ) { return ( globalConfig . SHORT_REVISION || "s" ) . slice ( 0 , 0 ) ; } export * from "s" ; export const trim = ( i ) : string => i . replace ( "s" , "s" ) ; export function bitArray ( ... values : boolean [ ] ) { return values . map ( ( x ) : number => x ? 0 : 0 ) . reduce ( ( res , x ) => { return res << 0 | x ; } ) ; } export const equals = < T > ( a : T , b : T ) : boolean => { return JSON . stringify ( a ) === JSON . stringify ( b ) ; } ; export const timestamp = ( date = new Date ( ) ) => Math . round ( date . getTime ( ) ) ; export function scrollToBottom ( elementId ) { const elToScroll = document . getElementById ( elementId ) ; if ( ! elToScroll ) { return ; } setTimeout ( ( ) => elToScroll . scrollTop = elToScroll . scrollHeight , 0 ) ; } export function validBotLocationData ( botLocationData : BotLocationData | undefined ) { return betterMerge ( { position : { x : undefined , y : undefined , z : undefined } , scaled_encoders : { x : undefined , y : undefined , z : undefined } , raw_encoders : { x : undefined , y : undefined , z : undefined } , } , botLocationData ) ; } export function validFwConfig ( config : TaggedFirmwareConfig | undefined ) : TaggedFirmwareConfig [ "s" ] | undefined { return ( config && config . body . api_migrated ) ? config . body : undefined ; } export function validFbosConfig ( config : TaggedFbosConfig | undefined ) : TaggedFbosConfig [ "s" ] | undefined { return ( config && config . body . api_migrated ) ? config . body : undefined ; } interface BetterUUID { kind : ResourceName ; localId : number ; remoteId ? : number ; } export function unpackUUID ( uuid ) { const [ kind , remoteId , localId ] = uuid . split ( "s" ) ; const id = parseInt ( remoteId , 0 ) ; return { kind : ( kind as ResourceName ) , localId : parseInt ( localId , 0 ) , remoteId : id > 0 ? id : undefined } ; } export const parseIntInput = ( input ) : number => { const int = parseInt ( "s" + parseFloat ( input ) . toFixed ( 0 ) , 0 ) ; return int === 0 ? 0 : int ; } ; export const timeFormatString = ( timeSettings : TimeSettings | undefined ) : string => ( timeSettings && timeSettings . 0 ) ? "s" : "s" ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $Array$ O $any$ O O O O O O O O O O O O O O O O O O O O O O $ResourceColor$ O O O O $any$ O $any[]$ O O O $any[]$ O O O O O O O $T$ O $any$ O O $T$ O $any$ O O $any$ O O $string$ O $JSON$ O $complex$ O $T$ O O O $JSON$ O $any$ O $string$ O O O O O O O $string$ O ${}$ O O O O $string$ O O O $any$ O $any$ O O ${}$ O $any$ O O O O O O $string$ O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O $ErrorConstructor$ O $any$ O O O O O O $T$ O $any$ O O O O O $T$ O $any$ O O $any$ O $Console$ O $void$ O $ObjectConstructor$ O $complex$ O $T$ O O $U[]$ O $string$ O O $string$ O O $T$ O $any$ O O O O O $string$ O O O O $U[]$ O O $any[]$ O O O O $any$ O $any$ O $any[]$ O O O O O O O O O O $string$ O O $JSON$ O $complex$ O $any[]$ O O O O O O O O $string$ O O O O O O O O O O O O $string$ O O O O O O $T$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O O O O O $complex$ O $object$ O O O O O O $object$ O O O O $any$ O $object$ O O O O O $T[]$ O $any$ O O $T[]$ O O $any$ O O O O O O O $any$ O O O O $T[]$ O $any$ O O O O O O $T[]$ O $void$ O $T$ O $T$ O $T[]$ O $number$ O $T$ O O O O O O $T[]$ O O O O $T[]$ O $any$ O $any$ O O $T[]$ O $any$ O O O O $any$ O O O O $any$ O $T[]$ O O $any$ O O $any$ O $any$ O $any$ O $number$ O O O O O $complex$ O $any$ O $any$ O O $T$ O $any$ O $U$ O $any$ O O $any$ O $any$ O O $any$ O O O O $T$ O $U$ O O O O O $number$ O $string$ O O O O O $number$ O O O O O $any$ O $JSON$ O $any$ O O O $string$ O O O O $any$ O $any$ O O O $boolean$ O $any$ O O O O $any$ O O O O O $any$ O O O O $number$ O O O O $boolean$ O $string[]$ O O O O O $string$ O O O $number$ O O O $string[]$ O $U[]$ O $string$ O $string$ O $boolean$ O $string$ O O $number$ O O O O O O O O $number$ O O O O $any$ O O O O O O O O O $string$ O O O O O $complex$ O $any$ O O O O $string$ O O O O O O O O O O O O O O $string$ O O $string$ O O O O $string$ O $complex$ O O O O O O O O $number$ O O $boolean[]$ O O O O O O O $boolean[]$ O $U[]$ O O $boolean$ O O O O $boolean$ O O O O O O $complex$ O O $number$ O $number$ O O O O $number$ O O O $number$ O O O O O O O $boolean$ O O $any$ O O $T$ O $any$ O $T$ O $any$ O O O O O O $JSON$ O $complex$ O $T$ O O $JSON$ O $complex$ O $T$ O O O O O O $number$ O O $Date$ O O $DateConstructor$ O O O O $Math$ O $number$ O $Date$ O $number$ O O O O O O $void$ O $string$ O O O $HTMLElement$ O $Document$ O $HTMLElement$ O $string$ O O O O O $HTMLElement$ O O O O O $number$ O O O O $HTMLElement$ O $number$ O $HTMLElement$ O $number$ O O O O O O O $BotLocationData$ O $complex$ O $any$ O O O O O $complex$ O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O $complex$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $undefined$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O $any$ O $number$ O O O $number$ O O O O O O O $BetterUUID$ O $string$ O O O O $string$ O $string$ O $string$ O O $string$ O $complex$ O O O O O $number$ O $number$ O $string$ O O O O O O $any$ O O $string$ O $any$ O O $number$ O $number$ O $string$ O O O O $number$ O $number$ O O O $number$ O $undefined$ O O O O O $number$ O O $string$ O O O O O O $number$ O $number$ O O O $number$ O $string$ O O $string$ O O O O O O O O $number$ O O O O O $number$ O O O O O $string$ O O $TimeSettings$ O $any$ O O O O O O O $TimeSettings$ O $TimeSettings$ O $boolean$ O O O O O O
import { Dictionary } from "s" ; import { Content } from "s" ; import { capitalize , map } from "s" ; import { t } from "s" ; export interface AxiosErrorResponse { response ? : { data : { [ reason ] : string } ; } ; } const mapper = ( v , k ) => { const reason = capitalize ( ( "s" + k ) . split ( "s" ) . join ( "s" ) ) ; const explanation = v . toString ( ) ; return t ( `template` ) ; } ; export function prettyPrintApiErrors ( err ) { const errors = safelyFetchErrors ( err ) ; return map ( errors , mapper ) . join ( "s" ) ; } function safelyFetchErrors ( err ) < string > { if ( err && err . response && err . response . data ) { return err . response . data ; } else { return { error : t ( Content . WEB_APP_DISCONNECTED ) } ; } } export function bail ( message ) { throw new Error ( message ) ; } export const catchErrors = ( error ) => { if ( window . Rollbar && window . Rollbar . error ) { window . Rollbar . error ( error ) ; } else { throw error ; } } ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $complex$ O O O $complex$ O O O $string$ O O O O O O O O O $any$ O O $string$ O $string$ O O O O $any$ O $any$ O O O O $string$ O O $complex$ O O O O $string$ O O O O O O $string$ O $string$ O $string$ O O O O $any$ O O O O O O O O $any$ O $AxiosErrorResponse$ O O O $any$ O $any$ O $AxiosErrorResponse$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O $Dictionary$ O $AxiosErrorResponse$ O O O O O O O $AxiosErrorResponse$ O $AxiosErrorResponse$ O $complex$ O $AxiosErrorResponse$ O $complex$ O $complex$ O O O $AxiosErrorResponse$ O $complex$ O $complex$ O O O O O O $any$ O $any$ O $any$ O $string$ O O O O O O O $never$ O $string$ O O O O $ErrorConstructor$ O $string$ O O O O O $void$ O O $Error$ O O O O O $complex$ O $Rollbar$ O $complex$ O $Rollbar$ O $void$ O O $complex$ O $Rollbar$ O $void$ O $Error$ O O O O O O $Error$ O O O O
import { parseIntInput } from "s" ; const MAX_SHORT_INPUT = 0 ; const MAX_LONG_INPUT = 0 ; const MIN_INPUT = 0 ; interface High { outcome : "s" ; result : number ; } interface Low { outcome : "s" ; result : number ; } interface Malformed { outcome : "s" ; result : undefined ; } interface Ok { outcome : "s" , result : number ; } type ClampResult = High | Low | Malformed | Ok ; export type IntegerSize = "s" | "s" | undefined ; export const getMaxInputFromIntSize = ( size ) => { switch ( size ) { case "s" : return MAX_LONG_INPUT ; case "s" : default : return MAX_SHORT_INPUT ; } } ; export function clampUnsignedInteger ( input , size ) { const result = parseIntInput ( input ) ; if ( isNaN ( result ) ) { return { outcome : "s" , result : undefined } ; } const max = getMaxInputFromIntSize ( size ) ; if ( result > max ) { return { outcome : "s" , result : max } ; } if ( result < MIN_INPUT ) { return { outcome : "s" , result : MIN_INPUT } ; } return { outcome : "s" , result } ; }	O O $number$ O O O O O O O O O O O O O O O O O O O O $any$ O O O O O $number$ O O O O O $any$ O O O O O $number$ O O O O O $any$ O O O O O $undefined$ O O O O O $any$ O O O O O $number$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O O O O $IntegerSize$ O O O O O $IntegerSize$ O O O O O O O O O O O O O O O O O O O O O $ClampResult$ O $string$ O $IntegerSize$ O O O $number$ O $number$ O $string$ O O O O $boolean$ O $number$ O O O O O O O O O $undefined$ O $undefined$ O O O O O O O O $IntegerSize$ O O O O $number$ O O O O O O O O O O $number$ O O O O O O O $number$ O O O O O O O O O O $number$ O O O O O O O O O O O $number$ O O O
enum Comparison { LOW = - 0 , EQ = 0 , HIGH = 0 } export const threeWayComparison = ( l , r ) : Comparison => { if ( l == r ) { return Comparison . EQ ; } return ( l < r ) ? Comparison . LOW : Comparison . HIGH ; } ; export function move < T > ( array : T [ ] , fromIndex , toIndex ) { const item = array [ fromIndex ] ; const length = array . length ; const diff = fromIndex - toIndex ; switch ( threeWayComparison ( diff , 0 ) ) { case Comparison . LOW : return [ ... array . slice ( 0 , fromIndex ) , ... array . slice ( fromIndex + 0 , toIndex + 0 ) , item , ... array . slice ( toIndex + 0 , length ) ] ; case Comparison . HIGH : return [ ... array . slice ( 0 , toIndex ) , item , ... array . slice ( toIndex , fromIndex ) , ... array . slice ( fromIndex + 0 , length ) ] ; default : return array ; } }	O $any$ O $Comparison.LOW$ O O O O $Comparison.EQ$ O O O $Comparison.HIGH$ O O O O O $Comparison$ O O $number$ O $number$ O O $any$ O O O O $number$ O $number$ O O O $any$ O $Comparison.EQ$ O O O O $number$ O $number$ O O $any$ O $Comparison.LOW$ O $any$ O $Comparison.HIGH$ O O O O O $T[]$ O $any$ O O $T[]$ O $any$ O O O $number$ O $number$ O O O $T$ O $T[]$ O $number$ O O O $number$ O $T[]$ O $number$ O O $number$ O $number$ O $number$ O O O $Comparison$ O $number$ O O O O O O $any$ O $Comparison.LOW$ O O O O $T[]$ O $T[]$ O O O $number$ O O O $T[]$ O $T[]$ O $number$ O O O $number$ O O O O $T$ O O $T[]$ O $T[]$ O $number$ O O O $number$ O O O O $any$ O $Comparison.HIGH$ O O O O $T[]$ O $T[]$ O O O $number$ O O $T$ O O $T[]$ O $T[]$ O $number$ O $number$ O O O $T[]$ O $T[]$ O $number$ O O O $number$ O O O O O O $T[]$ O O O
import { createElement , ComponentClass , Attributes } from "s" ; import { render } from "s" ; import { capitalize } from "s" ; import { t } from "s" ; export function updatePageInfo ( pageName ) { if ( pageName === "s" ) { pageName = "s" ; } document . title = `template` ; } export function attachToRoot < P > ( type < P > , props ? : Attributes & P ) { const node = document . createElement ( "s" ) ; node . id = "s" ; document . body . appendChild ( node ) ; const reactElem = createElement ( type , props ) ; const domElem = document . getElementById ( "s" ) ; domElem && render ( reactElem , domElem ) ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O $string$ O O O O $string$ O O O O $string$ O O O O $Document$ O $string$ O O O O O O $void$ O $any$ O O $ComponentClass$ O $any$ O O $any$ O O $any$ O $any$ O O O $HTMLElement$ O $Document$ O O O O O O $HTMLElement$ O $string$ O O O $Document$ O $HTMLElement$ O $T$ O $HTMLElement$ O O O $any$ O $any$ O $any$ O $any$ O O O $HTMLElement$ O $Document$ O $HTMLElement$ O O O O $HTMLElement$ O $any$ O $any$ O $HTMLElement$ O O O
export class Progress { constructor ( public total , public cb , public completed = 0 ) { } get isDone ( ) { return this . completed >= this . total ; } bump = ( force = false ) => { if ( force || ! this . isDone ) { this . cb ( this ) ; } } inc = ( ) => { this . completed ++ ; this . bump ( ) ; } ; finish = ( ) => { this . completed = this . total ; this . bump ( true ) ; } ; } export type ProgressCallback = ( p < Progress > ) => void ;	O O $any$ O O O O $number$ O O $ProgressCallback$ O O $number$ O O O O O O $boolean$ O O O O O O $number$ O O O $number$ O O $void$ O O $boolean$ O O O O O O O $boolean$ O O O O $boolean$ O O O O $ProgressCallback$ O O O O O O $void$ O O O O O O O $number$ O O O O $void$ O O O O O $void$ O O O O O O O $number$ O O O $number$ O O O $void$ O O O O O O O O O $any$ O O $Readonly$ O $any$ O O O O O
import { isString , isUndefined } from "s" ; import { BotState , Feature , MinOsFeatureLookup } from "s" ; import { TaggedDevice } from "s" ; export enum SemverResult { LEFT_IS_GREATER = 0 , RIGHT_IS_GREATER = - 0 , EQUAL = 0 } export function semverCompare ( left , right ) { const leftSemVer = left . split ( "s" ) [ 0 ] ; const rightSemVer = right . split ( "s" ) [ 0 ] ; const leftHasSuffix = left . includes ( "s" ) ; const rightHasSuffix = right . includes ( "s" ) ; const leftRc = parseInt ( left . toLowerCase ( ) . split ( "s" ) [ 0 ] ) ; const rightRc = parseInt ( right . toLowerCase ( ) . split ( "s" ) [ 0 ] ) ; const pa < string | undefined > = leftSemVer . split ( "s" ) ; const pb < string | undefined > = rightSemVer . split ( "s" ) ; for ( let i = 0 ; i < 0 ; i ++ ) { const num_left = Number ( pa [ i ] ) ; const num_right = Number ( pb [ i ] ) ; if ( num_left > num_right ) { return SemverResult . LEFT_IS_GREATER ; } if ( num_right > num_left ) { return SemverResult . RIGHT_IS_GREATER ; } if ( ! isNaN ( num_left ) && isNaN ( num_right ) ) { return SemverResult . LEFT_IS_GREATER ; } if ( isNaN ( num_left ) && ! isNaN ( num_right ) ) { return SemverResult . RIGHT_IS_GREATER ; } } if ( ! leftHasSuffix && rightHasSuffix ) { return SemverResult . LEFT_IS_GREATER ; } if ( leftHasSuffix && ! rightHasSuffix ) { return SemverResult . RIGHT_IS_GREATER ; } if ( leftRc > rightRc ) { return SemverResult . LEFT_IS_GREATER ; } if ( rightRc > leftRc ) { return SemverResult . RIGHT_IS_GREATER ; } return SemverResult . EQUAL ; } export function minFwVersionCheck ( current : string | undefined , min ) { if ( isString ( current ) ) { switch ( semverCompare ( current . slice ( 0 , - 0 ) , min ) ) { case SemverResult . LEFT_IS_GREATER : case SemverResult . EQUAL : return true ; default : return false ; } } else { return false ; } } export enum MinVersionOverride { ALWAYS = "s" , NEVER = "s" , } export function createShouldDisplayFn ( current : string | undefined , lookupData : MinOsFeatureLookup | undefined , override : string | undefined ) { return function ( feature ) : boolean { const target = override || current ; if ( isString ( target ) ) { const table = lookupData || { } ; const min = table [ feature ] || MinVersionOverride . NEVER ; switch ( semverCompare ( target , min ) ) { case SemverResult . LEFT_IS_GREATER : case SemverResult . EQUAL : return true ; default : return false ; } } return false ; } ; } export function determineInstalledOsVersion ( bot , device : TaggedDevice | undefined ) : string | undefined { const fromBotState = bot . hardware . informational_settings . controller_version ; const fromAPI = device ? device . body . fbos_version : undefined ; if ( isUndefined ( fromBotState ) && isUndefined ( fromAPI ) ) { return undefined ; } switch ( semverCompare ( fromBotState || "s" , fromAPI || "s" ) ) { case SemverResult . LEFT_IS_GREATER : case SemverResult . EQUAL : return fromBotState === "s" ? undefined : fromBotState ; case SemverResult . RIGHT_IS_GREATER : return fromAPI === "s" ? undefined : fromAPI ; } } export function versionOK ( stringyVersion = "s" , _EXPECTED_MAJOR , _EXPECTED_MINOR ) { const [ actual_major , actual_minor ] = stringyVersion . split ( "s" ) . map ( x => parseInt ( x , 0 ) ) ; if ( actual_major > _EXPECTED_MAJOR ) { return true ; } else { const majorOK = ( actual_major == _EXPECTED_MAJOR ) ; const minorOK = ( actual_minor >= _EXPECTED_MINOR ) ; return ( majorOK && minorOK ) ; } }	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $SemverResult.LEFT_IS_GREATER$ O O O $SemverResult.RIGHT_IS_GREATER$ O O O O $SemverResult.EQUAL$ O O O O O $SemverResult$ O $string$ O $string$ O O O $string$ O $string$ O $complex$ O O O O O O O O $string$ O $string$ O $complex$ O O O O O O O O $boolean$ O $string$ O $boolean$ O O O O O $boolean$ O $string$ O $boolean$ O O O O O $number$ O $number$ O $string$ O $string$ O O O $complex$ O O O O O O O O O $number$ O $number$ O $string$ O $string$ O O O $complex$ O O O O O O O O O $Array$ O O O O O O $string$ O $complex$ O O O O O $Array$ O O O O O O $string$ O $complex$ O O O O O O O $number$ O O O $number$ O O O $number$ O O O O $number$ O $NumberConstructor$ O $string[]$ O $number$ O O O O $number$ O $NumberConstructor$ O $string[]$ O $number$ O O O O O $number$ O $number$ O O O $any$ O $SemverResult.LEFT_IS_GREATER$ O O O O $number$ O $number$ O O O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O O O O $boolean$ O $number$ O O $boolean$ O $number$ O O O O $any$ O $SemverResult.LEFT_IS_GREATER$ O O O O $boolean$ O $number$ O O O $boolean$ O $number$ O O O O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O O O O O $boolean$ O $boolean$ O O O $any$ O $SemverResult.LEFT_IS_GREATER$ O O O O $boolean$ O O $boolean$ O O O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O O O $number$ O $number$ O O O $any$ O $SemverResult.LEFT_IS_GREATER$ O O O O $number$ O $number$ O O O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O O $any$ O $SemverResult.EQUAL$ O O O O $boolean$ O $string$ O O O O O $string$ O O O O $any$ O $string$ O O O O O $SemverResult$ O $string$ O $string$ O O O O O O O $string$ O O O O $any$ O $SemverResult.LEFT_IS_GREATER$ O O $any$ O $SemverResult.EQUAL$ O O O O O O O O O O O O O O O O O O O O $any$ O $MinVersionOverride.ALWAYS$ O O O $MinVersionOverride.NEVER$ O O O O O O $boolean$ O $string$ O O O O O $complex$ O $any$ O O O $string$ O O O O O O O O O $Feature$ O O O O O $string$ O $string$ O $string$ O O O $any$ O $string$ O O O O $complex$ O $complex$ O O O O O $string$ O $complex$ O $Feature$ O O $any$ O $MinVersionOverride.NEVER$ O O O $SemverResult$ O $string$ O $string$ O O O O $any$ O $SemverResult.LEFT_IS_GREATER$ O O $any$ O $SemverResult.EQUAL$ O O O O O O O O O O O O O O O O O O O $string$ O $BotState$ O $any$ O $any$ O O O O O O O O O $any$ O $BotState$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O O $any$ O $any$ O O O O $undefined$ O O O O $SemverResult$ O $any$ O O O $any$ O O O O O O $any$ O $SemverResult.LEFT_IS_GREATER$ O O $any$ O $SemverResult.EQUAL$ O O $any$ O O O $undefined$ O $any$ O O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O $any$ O O O $undefined$ O $any$ O O O O O $boolean$ O $string$ O O O $number$ O $number$ O O O O $number$ O $number$ O O $string$ O $complex$ O O O O $U[]$ O $string$ O $number$ O $string$ O O O O O O O $number$ O $number$ O O O O O O O O O $boolean$ O O $number$ O $number$ O O O $boolean$ O O $number$ O $number$ O O O O $boolean$ O $boolean$ O O O O
import { Dictionary } from "s" ; import { Pair } from "s" ; type PrimitiveMap = Dictionary < string | number | boolean | undefined > ; export function toPairs ( input ) : Pair [ ] { return Object . keys ( input ) . map ( function ( key ) : Pair { return { kind : "s" , args : { label : key , value : input [ key ] || "s" } } ; } ) ; }	O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O $any[]$ O $PrimitiveMap$ O O $any$ O O O O $ObjectConstructor$ O $complex$ O $any$ O O $U[]$ O O O $string$ O O $any$ O O O $string$ O O O $complex$ O O $string$ O $string$ O $any$ O $any$ O $string$ O O O O O O O O O O
export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { trim } from "s" ; export namespace ToolTips { export const MOVE = trim ( `template` ) ; export const WEBCAM = trim ( `template` ) ; export const PERIPHERALS = trim ( `template` ) ; export const SENSORS = trim ( `template` ) ; export const SENSOR_HISTORY = trim ( `template` ) ; export const OS_SETTINGS = trim ( `template` ) ; export const HW_SETTINGS = trim ( `template` ) ; export const PIN_BINDINGS = trim ( `template` ) ; export const PIN_BINDING_WARNING = trim ( `template` ) ; export const CONNECTIVITY = trim ( `template` ) ; export const HOMING = trim ( `template` ) ; export const CALIBRATION = trim ( `template` ) ; export const SET_ZERO_POSITION = trim ( `template` ) ; export const FIND_HOME_ON_BOOT = trim ( `template` ) ; export const STOP_AT_HOME = trim ( `template` ) ; export const STOP_AT_MAX = trim ( `template` ) ; export const NEGATIVE_COORDINATES_ONLY = trim ( `template` ) ; export const LENGTH = trim ( `template` ) ; export const TIMEOUT_AFTER = trim ( `template` ) ; export const MAX_MOVEMENT_RETRIES = trim ( `template` ) ; export const E_STOP_ON_MOV_ERR = trim ( `template` ) ; export const MAX_SPEED = trim ( `template` ) ; export const HOME_SPEED = trim ( `template` ) ; export const MIN_SPEED = trim ( `template` ) ; export const ACCELERATE_FOR = trim ( `template` ) ; export const STEPS_PER_MM = trim ( `template` ) ; export const MICROSTEPS_PER_STEP = trim ( `template` ) ; export const ALWAYS_POWER_MOTORS = trim ( `template` ) ; export const INVERT_MOTORS = trim ( `template` ) ; export const MOTOR_CURRENT = trim ( `template` ) ; export const STALL_SENSITIVITY = trim ( `template` ) ; export const 0 = trim ( `template` ) ; export const ENABLE_ENCODERS = trim ( `template` ) ; export const ENCODER_POSITIONING = trim ( `template` ) ; export const INVERT_ENCODERS = trim ( `template` ) ; export const MAX_MISSED_STEPS = trim ( `template` ) ; export const ENCODER_MISSED_STEP_DECAY = trim ( `template` ) ; export const ENCODER_SCALING = trim ( `template` ) ; export const ENABLE_ENDSTOPS = trim ( `template` ) ; export const SWAP_ENDPOINTS = trim ( `template` ) ; export const INVERT_ENDPOINTS = trim ( `template` ) ; export const PIN_GUARD_PIN_NUMBER = trim ( `template` ) ; export const FARMWARE = trim ( `template` ) ; export const FARMWARE_LIST = trim ( `template` ) ; export const PHOTOS = trim ( `template` ) ; export const WEED_DETECTOR = trim ( `template` ) ; export const CAMERA_CALIBRATION = trim ( `template` ) ; export const SEQUENCE_COMMANDS = trim ( `template` ) ; export const SEQUENCE_EDITOR = trim ( `template` ) ; export const SEQUENCE_LIST = trim ( `template` ) ; export const DEFAULT_VALUE = trim ( `template` ) ; export const MOVE_ABSOLUTE = trim ( `template` ) ; export const MOVE_RELATIVE = trim ( `template` ) ; export const WRITE_PIN = trim ( `template` ) ; export const READ_PIN = trim ( `template` ) ; export const WAIT = trim ( `template` ) ; export const SEND_MESSAGE = trim ( `template` ) ; export const FIND_HOME = trim ( `template` ) ; export const IF = trim ( `template` ) ; export const EXECUTE_SEQUENCE = trim ( `template` ) ; export const EXECUTE_SCRIPT = trim ( `template` ) ; export const FARMWARE_CONFIGS = trim ( `template` ) ; export const TAKE_PHOTO = trim ( `template` ) ; export const MARK_AS = trim ( `template` ) ; export const SET_SERVO_ANGLE = trim ( `template` ) ; export const TOGGLE_PIN = trim ( `template` ) ; export const MOVE_TO_HOME = trim ( `template` ) ; export const FIRMWARE_ACTION = trim ( `template` ) ; export const SYSTEM_ACTION = trim ( `template` ) ; export const UNKNOWN_STEP = trim ( `template` ) ; export const BULK_SCHEDULER = trim ( `template` ) ; export const REGIMEN_EDITOR = trim ( `template` ) ; export const REGIMEN_LIST = trim ( `template` ) ; export const TOOL_LIST = trim ( `template` ) ; export const TOOLBAY_LIST = trim ( `template` ) ; export const LOGS = trim ( `template` ) ; export const SEQUENCE_LOG_BEGIN = trim ( `template` ) ; export const SEQUENCE_LOG_STEP = trim ( `template` ) ; export const SEQUENCE_LOG_END = trim ( `template` ) ; export const FIRMWARE_LOG_SENT = trim ( `template` ) ; export const FIRMWARE_LOG_RECEIVED = trim ( `template` ) ; export const FIRMWARE_DEBUG_MESSAGES = trim ( `template` ) ; export const MESSAGES = trim ( `template` ) ; export const LABS = trim ( `template` ) ; export const TOURS = trim ( `template` ) ; } export namespace Content { export const ACCOUNT_PASSWORD_CHANGE = trim ( `template` ) ; export const ACCOUNT_RESET_WARNING = trim ( `template` ) ; export const TYPE_PASSWORD_TO_RESET = trim ( `template` ) ; export const ACCOUNT_DELETE_WARNING = trim ( `template` ) ; export const TYPE_PASSWORD_TO_DELETE = trim ( `template` ) ; export const EXPORT_DATA_DESC = trim ( `template` ) ; export const EXPORT_SENT = trim ( `template` ) ; export const SEED_DATA_SELECTION = trim ( `template` ) ; export const TAKE_A_TOUR = trim ( `template` ) ; export const READ_THE_DOCS = trim ( `template` ) ; export const WELCOME = trim ( `template` ) ; export const MESSAGE_CENTER_WELCOME = trim ( `template` ) ; export const MESSAGE_DISMISS = trim ( `template` ) ; export const FIRMWARE_MISSING = trim ( `template` ) ; export const DEMO_ACCOUNT = trim ( `template` ) ; export const DEMO_NOTE = trim ( `template` ) ; export const MAKE_A_REAL_ACCOUNT = trim ( `template` ) ; export const CONFIRM_STEP_DELETION = trim ( `template` ) ; export const CONFIRM_SEQUENCE_DELETION = trim ( `template` ) ; export const HIDE_WEBCAM_WIDGET = trim ( `template` ) ; export const HIDE_SENSORS_WIDGET = trim ( `template` ) ; export const DYNAMIC_MAP_SIZE = trim ( `template` ) ; export const PLANT_ANIMATIONS = trim ( `template` ) ; export const BROWSER_SPEAK_LOGS = trim ( `template` ) ; export const DISCARD_UNSAVED_CHANGES = trim ( `template` ) ; export const DISCARD_UNSAVED_CHANGES_CONFIRM = trim ( `template` ) ; export const DISCARD_UNSAVED_SEQUENCE_CHANGES = trim ( `template` ) ; export const DISCARD_UNSAVED_SEQUENCE_CHANGES_CONFIRM = trim ( `template` ) ; export const VIRTUAL_TRAIL = trim ( `template` ) ; export const 0 = trim ( `template` ) ; export const SHOW_PINS = trim ( `template` ) ; export const EXPAND_STEP_OPTIONS = trim ( `template` ) ; export const EMERGENCY_UNLOCK_CONFIRM_CONFIG = trim ( `template` ) ; export const USER_INTERFACE_READ_ONLY_MODE = trim ( `template` ) ; export const CONFIRM_EMERGENCY_UNLOCK_CONFIRM_DISABLE = trim ( `template` ) ; export const MAP_SIZE = trim ( `template` ) ; export const MAP_SWAP_XY = trim ( `template` ) ; export const MAP_ORIGIN = trim ( `template` ) ; export const CONFIRM_PLANT_DELETION = trim ( `template` ) ; export const SORT_DESCRIPTION = trim ( `template` ) ; export const NOT_HTTPS = trim ( `template` ) ; export const CONTACT_SYSADMIN = trim ( `template` ) ; export const FACTORY_RESET_WARNING = trim ( `template` ) ; export const FACTORY_RESET_ALERT = trim ( `template` ) ; export const MCU_RESET_ALERT = trim ( `template` ) ; export const AUTO_FACTORY_RESET = trim ( `template` ) ; export const AUTO_FACTORY_RESET_PERIOD = trim ( `template` ) ; export const DIFFERENT_TZ_WARNING = trim ( `template` ) ; export const RESTART_FARMBOT = trim ( `template` ) ; export const RESTART_FIRMWARE = trim ( `template` ) ; export const OS_AUTO_UPDATE = trim ( `template` ) ; export const AUTO_SYNC = trim ( `template` ) ; export const SHUTDOWN_FARMBOT = trim ( `template` ) ; export const OS_BETA_RELEASES = trim ( `template` ) ; export const DIAGNOSTIC_CHECK = trim ( `template` ) ; export const DEVICE_NEVER_SEEN = trim ( `template` ) ; export const TOO_OLD_TO_UPDATE = trim ( `template` ) ; export const RESTORE_DEFAULT_HARDWARE_SETTINGS = trim ( `template` ) ; export const APP_LOAD_TIMEOUT_MESSAGE = trim ( `template` ) ; export const MQTT_DISCONNECTED = trim ( `template` ) ; export const WEB_APP_DISCONNECTED = trim ( `template` ) ; export const MALFORMED_MESSAGE_REC_UPGRADE = trim ( `template` ) ; export const OLD_FBOS_REC_UPGRADE = trim ( `template` ) ; export const EXPERIMENTAL_WARNING = trim ( `template` ) ; export const NEW_TOS = trim ( `template` ) ; export const FORCE_REFRESH_CONFIRM = trim ( `template` ) ; export const FORCE_REFRESH_CANCEL_WARNING = trim ( `template` ) ; export const TOS_UPDATE = trim ( `template` ) ; export const VERIFICATION_EMAIL_RESENT = trim ( `template` ) ; export const VERIFICATION_EMAIL_RESEND_ERROR = trim ( `template` ) ; export const NO_SEQUENCE_SELECTED = trim ( `template` ) ; export const NO_SEQUENCES = trim ( `template` ) ; export const END_DETECTION_DISABLED = trim ( `template` ) ; export const IN_USE = trim ( `template` ) ; export const NO_REGIMEN_SELECTED = trim ( `template` ) ; export const NO_REGIMENS = trim ( `template` ) ; export const OUTSIDE_PLANTING_AREA = trim ( `template` ) ; export const MOVE_MODE_DESCRIPTION = trim ( `template` ) ; export const CREATE_POINTS_DESCRIPTION = trim ( `template` ) ; export const BOX_SELECT_DESCRIPTION = trim ( `template` ) ; export const SAVED_GARDENS = trim ( `template` ) ; export const NO_PLANTS = trim ( `template` ) ; export const NO_GARDENS = trim ( `template` ) ; export const NO_POINTS = trim ( `template` ) ; export const NO_GROUPS = trim ( `template` ) ; export const ENTER_CROP_SEARCH_TERM = trim ( `template` ) ; export const CROP_NOT_FOUND_INTRO = trim ( `template` ) ; export const CROP_NOT_FOUND_LINK = trim ( `template` ) ; export const NO_TOOLS = trim ( `template` ) ; export const NOTHING_SCHEDULED = trim ( `template` ) ; export const REGIMEN_TODAY_SKIPPED_ITEM_RISK = trim ( `template` ) ; export const INVALID_RUN_TIME = trim ( `template` ) ; export const FARM_EVENT_TZ_WARNING = trim ( `template` ) ; export const FIRST_PARTY_WARNING = trim ( `template` ) ; export const SET_TIMEZONE_HEADER = trim ( `template` ) ; export const SET_TIMEZONE_BODY = trim ( `template` ) ; export const NO_IMAGES_YET = trim ( `template` ) ; export const PROCESSING_PHOTO = trim ( `template` ) ; export const NOT_AVAILABLE_WHEN_OFFLINE = trim ( `template` ) ; } export namespace TourContent { export const ADD_PLANTS = trim ( `template` ) ; export const ADD_TOOLS = trim ( `template` ) ; export const ADD_TOOLS_SLOTS = trim ( `template` ) ; export const ADD_PERIPHERALS = trim ( `template` ) ; export const ADD_SEQUENCES = trim ( `template` ) ; export const ADD_REGIMENS = trim ( `template` ) ; export const ADD_FARM_EVENTS = trim ( `template` ) ; export const LOCATION_GRID = trim ( `template` ) ; export const VIRTUAL_FARMBOT = trim ( `template` ) ; export const LOGS_TABLE = trim ( `template` ) ; export const PHOTOS = trim ( `template` ) ; export const APP_SETTINGS = trim ( `template` ) ; } export namespace DiagnosticMessages { export const OK = trim ( `template` ) ; export const MISC = trim ( `template` ) ; export const TOTAL_BREAKAGE = trim ( `template` ) ; export const REMOTE_FIREWALL = trim ( `template` ) ; export const WIFI_OR_CONFIG = trim ( `template` ) ; export const NO_WS_AVAILABLE = trim ( `template` ) ; export const INACTIVE = trim ( `template` ) ; export const ARDUINO_DISCONNECTED = trim ( `template` ) ; } export enum Actions { DESTROY_RESOURCE_START = "s" , DESTROY_RESOURCE_OK = "s" , INIT_RESOURCE = "s" , BATCH_INIT = "s" , SAVE_RESOURCE_OK = "s" , EDIT_RESOURCE = "s" , OVERWRITE_RESOURCE = "s" , SAVE_RESOURCE_START = "s" , RESOURCE_READY = "s" , _RESOURCE_NO = "s" , REFRESH_RESOURCE_START = "s" , REFRESH_RESOURCE_OK = "s" , REFRESH_RESOURCE_NO = "s" , DELETE_POINT_OK = "s" , REPLACE_TOKEN = "s" , LOGIN_ERROR = "s" , CHANGE_API_PORT = "s" , CHANGE_API_HOST = "s" , LOGOUT = "s" , SAVE_DEVICE_OK = "s" , TOGGLE_CONTROL_PANEL_OPTION = "s" , BULK_TOGGLE_CONTROL_PANEL = "s" , CHANGE_STEP_SIZE = "s" , SETTING_UPDATE_START = "s" , SETTING_UPDATE_END = "s" , LEGACY_BOT_CHANGE = "s" , STATUS_UPDATE = "s" , FETCH_OS_UPDATE_INFO_OK = "s" , FETCH_OS_UPDATE_INFO_ERROR = "s" , FETCH_BETA_OS_UPDATE_INFO_OK = "s" , FETCH_BETA_OS_UPDATE_INFO_ERROR = "s" , FETCH_MIN_OS_FEATURE_INFO_OK = "s" , FETCH_MIN_OS_FEATURE_INFO_ERROR = "s" , INVERT_JOG_BUTTON = "s" , DISPLAY_ENCODER_DATA = "s" , STASH_STATUS = "s" , PUT_DATA_XFER = "s" , DROP_DATA_XFER = "s" , SEARCH_QUERY_CHANGE = "s" , SELECT_PLANT = "s" , TOGGLE_HOVERED_PLANT = "s" , TOGGLE_HOVERED_POINT = "s" , HOVER_PLANT_LIST_ITEM = "s" , OF_SEARCH_RESULTS_START = "s" , OF_SEARCH_RESULTS_OK = "s" , OF_SEARCH_RESULTS_NO = "s" , CHOOSE_LOCATION = "s" , SET_CURRENT_POINT_DATA = "s" , CHOOSE_SAVED_GARDEN = "s" , PUSH_WEEK = "s" , POP_WEEK = "s" , DESELECT_ALL_DAYS = "s" , SELECT_ALL_DAYS = "s" , TOGGLE_DAY = "s" , SELECT_REGIMEN = "s" , SET_SEQUENCE = "s" , SET_TIME_OFFSET = "s" , SET_SCHEDULER_STATE = "s" , SELECT_SEQUENCE = "s" , SET_SEQUENCE_POPUP_STATE = "s" , SET_SEQUENCE_STEP_POSITION = "s" , SELECT_FARMWARE = "s" , SELECT_IMAGE = "s" , FETCH_FIRST_PARTY_FARMWARE_NAMES_OK = "s" , SET_FARMWARE_INFO_STATE = "s" , START_TOUR = "s" , NETWORK_EDGE_CHANGE = "s" , SET_CONSISTENCY = "s" , PING_START = "s" , PING_OK = "s" , PING_NO = "s" }	O O $string$ O O O O O O $any$ O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O O $any$ O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O O $any$ O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O O $any$ O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O O $any$ O $Actions.DESTROY_RESOURCE_START$ O O O $Actions.DESTROY_RESOURCE_OK$ O O O $Actions.INIT_RESOURCE$ O O O $Actions.BATCH_INIT$ O O O $Actions.SAVE_RESOURCE_OK$ O O O $Actions.EDIT_RESOURCE$ O O O $Actions.OVERWRITE_RESOURCE$ O O O $Actions.SAVE_RESOURCE_START$ O O O $Actions.RESOURCE_READY$ O O O $Actions._RESOURCE_NO$ O O O $Actions.REFRESH_RESOURCE_START$ O O O $Actions.REFRESH_RESOURCE_OK$ O O O $Actions.REFRESH_RESOURCE_NO$ O O O $Actions.DELETE_POINT_OK$ O O O $Actions.REPLACE_TOKEN$ O O O $Actions.LOGIN_ERROR$ O O O $Actions.CHANGE_API_PORT$ O O O $Actions.CHANGE_API_HOST$ O O O $Actions.LOGOUT$ O O O $Actions.SAVE_DEVICE_OK$ O O O $Actions.TOGGLE_CONTROL_PANEL_OPTION$ O O O $Actions.BULK_TOGGLE_CONTROL_PANEL$ O O O $Actions.CHANGE_STEP_SIZE$ O O O $Actions.SETTING_UPDATE_START$ O O O $Actions.SETTING_UPDATE_END$ O O O $Actions.LEGACY_BOT_CHANGE$ O O O $Actions.STATUS_UPDATE$ O O O $Actions.FETCH_OS_UPDATE_INFO_OK$ O O O $Actions.FETCH_OS_UPDATE_INFO_ERROR$ O O O $Actions.FETCH_BETA_OS_UPDATE_INFO_OK$ O O O $Actions.FETCH_BETA_OS_UPDATE_INFO_ERROR$ O O O $Actions.FETCH_MIN_OS_FEATURE_INFO_OK$ O O O $Actions.FETCH_MIN_OS_FEATURE_INFO_ERROR$ O O O $Actions.INVERT_JOG_BUTTON$ O O O $Actions.DISPLAY_ENCODER_DATA$ O O O $Actions.STASH_STATUS$ O O O $Actions.PUT_DATA_XFER$ O O O $Actions.DROP_DATA_XFER$ O O O $Actions.SEARCH_QUERY_CHANGE$ O O O $Actions.SELECT_PLANT$ O O O $Actions.TOGGLE_HOVERED_PLANT$ O O O $Actions.TOGGLE_HOVERED_POINT$ O O O $Actions.HOVER_PLANT_LIST_ITEM$ O O O $Actions.OF_SEARCH_RESULTS_START$ O O O $Actions.OF_SEARCH_RESULTS_OK$ O O O $Actions.OF_SEARCH_RESULTS_NO$ O O O $Actions.CHOOSE_LOCATION$ O O O $Actions.SET_CURRENT_POINT_DATA$ O O O $Actions.CHOOSE_SAVED_GARDEN$ O O O $Actions.PUSH_WEEK$ O O O $Actions.POP_WEEK$ O O O $Actions.DESELECT_ALL_DAYS$ O O O $Actions.SELECT_ALL_DAYS$ O O O $Actions.TOGGLE_DAY$ O O O $Actions.SELECT_REGIMEN$ O O O $Actions.SET_SEQUENCE$ O O O $Actions.SET_TIME_OFFSET$ O O O $Actions.SET_SCHEDULER_STATE$ O O O $Actions.SELECT_SEQUENCE$ O O O $Actions.SET_SEQUENCE_POPUP_STATE$ O O O $Actions.SET_SEQUENCE_STEP_POSITION$ O O O $Actions.SELECT_FARMWARE$ O O O $Actions.SELECT_IMAGE$ O O O $Actions.FETCH_FIRST_PARTY_FARMWARE_NAMES_OK$ O O O $Actions.SET_FARMWARE_INFO_STATE$ O O O $Actions.START_TOUR$ O O O $Actions.NETWORK_EDGE_CHANGE$ O O O $Actions.SET_CONSISTENCY$ O O O $Actions.PING_START$ O O O $Actions.PING_OK$ O O O $Actions.PING_NO$ O O O
import { Everything } from "s" ; import { Store } from "s" ; import { Actions } from "s" ; export type Store = Store < Everything > ; export interface ReduxAction < T > { readonly type : Actions ; readonly payload : T ; } export type GetState = ( ) => Everything ; export interface Thunk { ( dispatch , getState ) : unknown ; } export type EnvName = "s" | "s" | "s" | "s" ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $Actions$ O $any$ O O $T$ O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O $Function$ O $GetState$ O O O O O O O $any$ O O O O O O O O O
import { generateReducer } from "s" ; import { Actions } from "s" ; export interface HelpState { currentTour : string | undefined ; } export let initialState = { currentTour : undefined , } ; export let helpReducer = generateReducer < HelpState > ( initialState ) . add < string > ( Actions . START_TOUR , ( s , { payload } ) => { s . currentTour = payload ; return s ; } ) ;	O O $GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O O O O O O $HelpState$ O O $undefined$ O $undefined$ O O O O O $generateReducer<HelpState>.GeneratedReducer$ O $GeneratedReducer$ O $any$ O O $HelpState$ O O $generateReducer<HelpState>.GeneratedReducer$ O O O O $any$ O $Actions.START_TOUR$ O O $HelpState$ O O $string$ O O O O $HelpState$ O $string$ O $string$ O O $HelpState$ O O O O
export namespace OpenFarm { export interface OFCrop { name : string ; slug : string ; binomial_name : string ; common_names : string [ ] ; description : string ; sun_requirements : string ; sowing_method : string ; svg_icon ? : string | undefined ; spread ? : number | undefined ; row_spacing ? : number ; height ? : number ; processing_pictures : number ; } export interface Self { api : string ; website : string ; } export interface Links { self : Self ; } export interface 0 { related : string ; } export interface 0 { type : string ; id : string ; } export interface Pictures { links : 0 ; data : 0 [ ] ; } export interface Relationships { pictures : Pictures ; } export interface Datum { id : string ; type : string ; attributes : OFCrop ; links : Links ; relationships : Relationships ; } export interface ImageAttrs { id : string ; image_url : string ; small_url : string ; thumbnail_url : string ; medium_url : string ; large_url : string ; canopy_url : string ; } export interface Included { id : string ; type : string ; attributes : ImageAttrs ; } export let cropUrl = "s" ; export let browsingCropUrl = "s" ; } export interface CropSearchResult { data : OpenFarm . Datum [ ] ; included : OpenFarm . Included [ ] ; }	O O $any$ O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $number$ O O O O O O $number$ O O O O $number$ O O O O $number$ O O O O O O $any$ O $string$ O O O $string$ O O O O O O $any$ O $Self$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O O O O $any$ O O O $any$ O O O $any$ O O O O O O $any$ O $Pictures$ O $any$ O O O O $any$ O $string$ O O O $string$ O O O $OFCrop$ O $any$ O $Links$ O $any$ O $Relationships$ O $any$ O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O $ImageAttrs$ O $any$ O O O O $string$ O O O O O $string$ O O O O O O $any$ O $Datum[]$ O $any$ O $any$ O O O $Included[]$ O $any$ O $any$ O O O O
export enum Color { white = "s" , offWhite = "s" , lightGray = "s" , gray = "s" , mediumGray = "s" , darkGray = "s" , green = "s" , darkGreen = "s" , yellow = "s" , red = "s" , virtualRed = "s" , soilBackground = "s" , templateSoilBkgd = "s" , gridGray = "s" , gridSoil = "s" , templateGridSoil = "s" , soilCloud = "s" , black = "s" , orange = "s" , blue = "s" , magenta = "s" , }	O O $any$ O $Color.white$ O O O $Color.offWhite$ O O O $Color.lightGray$ O O O $Color.gray$ O O O $Color.mediumGray$ O O O $Color.darkGray$ O O O $Color.green$ O O O $Color.darkGreen$ O O O $Color.yellow$ O O O $Color.red$ O O O $Color.virtualRed$ O O O $Color.soilBackground$ O O O $Color.lightGray$ O O O $Color.gridGray$ O O O $Color.gridSoil$ O O O $Color.offWhite$ O O O $Color.soilCloud$ O O O $Color.black$ O O O $Color.orange$ O O O $Color.blue$ O O O $Color.magenta$ O O O O
export interface DropDownItem { label : string ; value : number | string ; heading ? : boolean ; headingId ? : string | undefined ; isNull ? : true ; } export interface NullChoice extends DropDownItem { label : "s" ; value : "s" ; } const nc = { label : "s" , value : "s" } ; export const NULL_CHOICE = Object . freeze ( nc ) ;	O O $any$ O $string$ O O O $complex$ O O O O O $boolean$ O O O O $string$ O O O O O O $true$ O O O O O O O $any$ O $any$ O O O O O O O O O O O $NullChoice$ O O O O O O O O O O O O O $Readonly<NullChoice>$ O $ObjectConstructor$ O $complex$ O $NullChoice$ O O
export const BASE_URL = "s" ; export const DOC_SLUGS = { "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" } ; export type DocSlug = keyof typeof DOC_SLUGS ; export const docLink = ( slug ? ) => BASE_URL + ( slug || "s" ) ;	O O O O O O O O $complex$ O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O $complex$ O O O $string$ O O O $DocSlug$ O O O O O O O O O O
export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TaggedPlantPointer , TaggedGenericPointer , TaggedPlantTemplate } from "s" ; import { State , BotOriginQuadrant } from "s" ; import { BotPosition , BotLocationData } from "s" ; import { GetWebAppConfigValue } from "s" ; import { TimeSettings } from "s" ; export type TaggedPlant = TaggedPlantPointer | TaggedPlantTemplate ; export interface PlantLayerProps { plants : TaggedPlant [ ] ; currentPlant : TaggedPlant | undefined ; dragging : boolean ; editing : boolean ; visible : boolean ; dispatch : Function ; mapTransformProps : MapTransformProps ; zoomLvl : number ; activeDragXY : BotPosition | undefined ; selectedForDel : string [ ] | undefined ; animate : boolean ; } export interface GardenMapLegendProps { zoom : ( value ) => ( ) => void ; toggle : ( property : keyof State ) => ( ) => void ; legendMenuOpen : boolean ; showPlants : boolean ; showPoints : boolean ; showSpread : boolean ; showFarmbot : boolean ; showImages : boolean ; showSensorReadings : boolean ; hasSensorReadings : boolean ; dispatch : Function ; timeSettings : TimeSettings ; getConfigValue : GetWebAppConfigValue ; imageAgeInfo : { newestDate : string , toOldest : number } ; gardenId ? : number ; className ? : string ; } export type MapTransformProps = { quadrant : BotOriginQuadrant , gridSize : AxisNumberProperty xySwap : boolean ; } ; export interface GardenPlantProps { mapTransformProps : MapTransformProps ; dispatch : Function ; plant : Readonly < TaggedPlant > ; selected : boolean ; dragging : boolean ; zoomLvl : number ; activeDragXY : BotPosition | undefined ; uuid : string ; grayscale : boolean ; animate : boolean ; } export interface GardenPlantState { icon : string ; hover : boolean ; } export interface GardenPointProps { mapTransformProps : MapTransformProps ; point : TaggedGenericPointer ; } export interface GardenPointState { } interface DragHelpersBaseProps { dragging : boolean ; mapTransformProps : MapTransformProps ; zoomLvl : number ; activeDragXY : BotPosition | undefined ; plantAreaOffset : AxisNumberProperty ; } export interface ActivePlantDragHelperProps extends DragHelpersBaseProps { currentPlant : TaggedPlant | undefined ; editing : boolean ; } export interface DragHelpersProps extends DragHelpersBaseProps { plant : Readonly < TaggedPlant > ; } export type AxisNumberProperty = Record < "s" | "s" , number > ; export type CheckedAxisLength = { value : number , isDefault : boolean } ; export type BotSize = Record < "s" | "s" , CheckedAxisLength > ; export interface BotExtentsProps { mapTransformProps : MapTransformProps ; stopAtHome : Record < "s" | "s" , boolean > ; botSize : BotSize ; } export interface MapBackgroundProps { mapTransformProps : MapTransformProps ; plantAreaOffset : AxisNumberProperty ; templateView : boolean ; } export interface GridProps { mapTransformProps : MapTransformProps ; onClick ( ) : void ; } export interface VirtualFarmBotProps { mapTransformProps : MapTransformProps ; botLocationData : BotLocationData ; plantAreaOffset : AxisNumberProperty ; peripherals : { label : string , value : boolean } [ ] ; eStopStatus : boolean ; getConfigValue : GetWebAppConfigValue ; } export interface FarmBotLayerProps extends VirtualFarmBotProps , BotExtentsProps { visible : boolean ; } export interface SpreadOverlapHelperProps { dragging : boolean ; plant : Readonly < TaggedPlant > ; mapTransformProps : MapTransformProps ; zoomLvl : number ; activeDragXY : BotPosition | undefined ; activeDragSpread : number | undefined ; } export enum Mode { none = "s" , boxSelect = "s" , clickToAdd = "s" , editPlant = "s" , addPlant = "s" , moveTo = "s" , points = "s" , createPoint = "s" , templateView = "s" , addPointToGroup = "s" , }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any[]$ O $any$ O O O $any$ O $any$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $Function$ O $FunctionConstructor$ O $MapTransformProps$ O $any$ O $number$ O O O $complex$ O $any$ O O O $string[]$ O O O O O O O $boolean$ O O O O O O $any$ O $void$ O O $number$ O O O O O O O $void$ O O $complex$ O O $any$ O O O O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $Function$ O $FunctionConstructor$ O $TimeSettings$ O $any$ O $GetWebAppConfigValue$ O $any$ O $complex$ O O $string$ O O O $number$ O O O O $number$ O O O O $string$ O O O O O O O $any$ O O $BotOriginQuadrant$ O $any$ O $complex$ O $any$ $boolean$ O O O O O O O $any$ O $MapTransformProps$ O $any$ O $Function$ O $FunctionConstructor$ O $Readonly<any>$ O $any$ O $any$ O O $boolean$ O O O $boolean$ O O O $number$ O O O $complex$ O $any$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O O O O $any$ O $string$ O O O $boolean$ O O O O O O $any$ O $MapTransformProps$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $boolean$ O O O $MapTransformProps$ O $any$ O $number$ O O O $complex$ O $any$ O O O $complex$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O O O O O O $any$ O $any$ O $Readonly<any>$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O $number$ O O O $boolean$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $MapTransformProps$ O $any$ O $complex$ O $any$ O O O O O O O O $complex$ O $any$ O O O O $any$ O $MapTransformProps$ O $any$ O $complex$ O $any$ O $boolean$ O O O O O O $any$ O $MapTransformProps$ O $any$ O $void$ O O O O O O O O $any$ O $MapTransformProps$ O $any$ O $complex$ O $any$ O $complex$ O $any$ O $complex$ O O $string$ O O O $boolean$ O O O O O O $boolean$ O O O $GetWebAppConfigValue$ O $any$ O O O O $any$ O $any$ O $any$ O $boolean$ O O O O O O $any$ O $boolean$ O O O $Readonly<any>$ O $any$ O $any$ O O $MapTransformProps$ O $any$ O $number$ O O O $complex$ O $any$ O O O $number$ O O O O O O O O $any$ O $Mode.none$ O O O $Mode.boxSelect$ O O O $Mode.clickToAdd$ O O O $Mode.editPlant$ O O O $Mode.addPlant$ O O O $Mode.moveTo$ O O O $Mode.points$ O O O $Mode.createPoint$ O O O $Mode.templateView$ O O O $Mode.addPointToGroup$ O O O O
export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ;	O O O O O O O O O O O O O O O O O O O O O O O O O
import { OpenFarm } from "s" ; import { DropDownItem } from "s" ; import { CowardlyDictionary } from "s" ; import { TaggedFarmEvent , TaggedSequence , TaggedRegimen , TaggedGenericPointer , TaggedImage , TaggedSensorReading , TaggedSensor , } from "s" ; import { SlotWithTool , ResourceIndex } from "s" ; import { BotPosition , StepsPerMmXY , BotLocationData , ShouldDisplay } from "s" ; import { isNumber } from "s" ; import { McuParams , TaggedCrop } from "s" ; import { AxisNumberProperty , BotSize , TaggedPlant } from "s" ; import { SelectionBoxData } from "s" ; import { GetWebAppConfigValue } from "s" ; import { ExecutableType , PlantPointer } from "s" ; import { BooleanConfigKey } from "s" ; import { TimeSettings } from "s" ; export enum BotOriginQuadrant { ONE = 0 , TWO = 0 , THREE = 0 , FOUR = 0 } type Mystery = BotOriginQuadrant | number | string | boolean | undefined ; export function isBotOriginQuadrant ( mystery ) : mystery is BotOriginQuadrant { return isNumber ( mystery ) && [ 0 , 0 , 0 , 0 ] . includes ( mystery ) ; } type TypeCheckerHint = Partial < Record < BooleanConfigKey , boolean > > ; export interface State extends TypeCheckerHint { legend_menu_open : boolean ; show_plants : boolean ; show_points : boolean ; show_spread : boolean ; show_farmbot : boolean ; show_images : boolean ; show_sensor_readings : boolean ; bot_origin_quadrant : BotOriginQuadrant ; zoom_level : number ; } export interface Props { dispatch : Function ; selectedPlant : TaggedPlant | undefined ; designer : DesignerState ; hoveredPlant : TaggedPlant | undefined ; points : TaggedGenericPointer [ ] ; plants : TaggedPlant [ ] ; toolSlots : SlotWithTool [ ] ; crops : TaggedCrop [ ] ; botLocationData : BotLocationData ; botMcuParams : McuParams ; stepsPerMmXY : StepsPerMmXY ; peripherals : { label : string , value : boolean } [ ] ; eStopStatus : boolean ; latestImages : TaggedImage [ ] ; cameraCalibrationData : CameraCalibrationData ; timeSettings : TimeSettings ; getConfigValue : GetWebAppConfigValue ; sensorReadings : TaggedSensorReading [ ] ; sensors : TaggedSensor [ ] ; } export interface MovePlantProps { deltaX : number ; deltaY : number ; plant : TaggedPlant ; gridSize : AxisNumberProperty ; } export interface CropLiveSearchResult { crop : OpenFarm . OFCrop ; image : string ; } export interface Crop { id ? : undefined ; svg_icon ? : string | undefined ; spread ? : number | undefined ; slug : string ; } export interface DesignerState { selectedPlants : string [ ] | undefined ; hoveredPlant : HoveredPlantPayl ; hoveredPlantListItem : string | undefined ; cropSearchQuery : string ; cropSearchResults : CropLiveSearchResult [ ] ; cropSearchInProgress : boolean ; chosenLocation : BotPosition ; currentPoint : CurrentPointPayl | undefined ; openedSavedGarden : string | undefined ; } export type TaggedExecutable = TaggedSequence | TaggedRegimen ; export type ExecutableQuery = ( kind , id ) => TaggedExecutable ; export interface AddEditFarmEventProps { deviceTimezone : string | undefined ; executableOptions : DropDownItem [ ] ; repeatOptions : DropDownItem [ ] ; farmEvents : TaggedFarmEvent [ ] ; regimensById : CowardlyDictionary < TaggedRegimen > ; sequencesById : CowardlyDictionary < TaggedSequence > ; farmEventsById : CowardlyDictionary < TaggedFarmEvent > ; getFarmEvent ( ) : TaggedFarmEvent | undefined ; findFarmEventByUuid ( uuid : string | undefined ) : TaggedFarmEvent | undefined ; handleTime ( e : React . SyntheticEvent < HTMLInputElement > , currentISO ) : string ; dispatch : Function ; findExecutable : ExecutableQuery ; timeSettings : TimeSettings ; autoSyncEnabled : boolean ; resources : ResourceIndex ; shouldDisplay : ShouldDisplay ; } export interface CalendarOccurrence { mmddyy : string ; sortKey : number ; timeStr : string ; heading : string ; subheading ? : string | undefined ; executableId : number ; id : number ; } export interface CalendarDay { sortKey : number ; year : number ; month : string ; day : number ; items : CalendarOccurrence [ ] ; } export interface FarmEventProps { timezoneIsSet : boolean ; calendarRows : CalendarDay [ ] ; } export interface FarmEventState { searchTerm : string ; } export interface GardenMapProps { showPlants : boolean | undefined ; showPoints : boolean | undefined ; showSpread : boolean | undefined ; showFarmbot : boolean | undefined ; showImages : boolean | undefined ; showSensorReadings : boolean | undefined ; dispatch : Function ; designer : DesignerState ; points : TaggedGenericPointer [ ] ; plants : TaggedPlant [ ] ; toolSlots : SlotWithTool [ ] ; selectedPlant : TaggedPlant | undefined ; hoveredPlant : TaggedPlant | undefined ; crops : TaggedCrop [ ] ; botLocationData : BotLocationData ; botSize : BotSize ; stopAtHome : Record < "s" | "s" , boolean > ; zoomLvl : number ; botOriginQuadrant : BotOriginQuadrant ; gridSize : AxisNumberProperty ; gridOffset : AxisNumberProperty ; peripherals : { label : string , value : boolean } [ ] ; eStopStatus : boolean ; latestImages : TaggedImage [ ] ; cameraCalibrationData : CameraCalibrationData ; getConfigValue : GetWebAppConfigValue ; sensorReadings : TaggedSensorReading [ ] ; sensors : TaggedSensor [ ] ; timeSettings : TimeSettings ; } export interface GardenMapState { isDragging : boolean | undefined ; botOriginQuadrant : BotOriginQuadrant ; qPageX : number | undefined ; qPageY : number | undefined ; activeDragXY : BotPosition | undefined ; activeDragSpread : number | undefined ; selectionBox : SelectionBoxData | undefined ; } export type PlantOptions = Partial < PlantPointer > ; export interface EditPlantInfoProps { push ( url ) : void ; dispatch : Function ; findPlant ( stringyID : string | undefined ) : TaggedPlant | undefined ; openedSavedGarden : string | undefined ; timeSettings : TimeSettings ; getConfigValue : GetWebAppConfigValue ; } export interface DraggableEvent { currentTarget : HTMLImageElement ; dataTransfer : { setDragImage : Function ; } ; } export interface HoveredPlantPayl { plantUUID : string | undefined ; icon : string ; } export type OpenfarmSearch = ( query ) => ( dispatch ) => void ; export interface CropCatalogProps { cropSearchQuery : string ; dispatch : Function ; cropSearchResults : CropLiveSearchResult [ ] ; openfarmSearch : OpenfarmSearch ; cropSearchInProgress : boolean ; } export interface CropInfoProps { dispatch : Function ; cropSearchQuery : string | undefined ; cropSearchResults : CropLiveSearchResult [ ] ; cropSearchInProgress : boolean ; openedSavedGarden : string | undefined ; openfarmSearch : OpenfarmSearch ; botPosition : BotPosition ; } export interface CameraCalibrationData { scale : string | undefined ; rotation : string | undefined ; offset : { x : string | undefined ; y : string | undefined ; } , origin : string | undefined ; calibrationZ : string | undefined ; } export interface CurrentPointPayl { name ? : string ; cx : number ; cy : number ; r : number ; color ? : string ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $BotOriginQuadrant.ONE$ O O O $BotOriginQuadrant.TWO$ O O O $BotOriginQuadrant.THREE$ O O O $BotOriginQuadrant.FOUR$ O O O O $any$ O $any$ O O O O O O O O O O O $complex$ O $Mystery$ O O $complex$ O $any$ O O $any$ O $complex$ O O O O O O O O O O O O $boolean$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $BotOriginQuadrant$ O $any$ O $number$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any$ O $any$ O O O $DesignerState$ O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O O O $any[]$ O $any$ O O O $SlotWithTool[]$ O $any$ O O O $any[]$ O $any$ O O O $complex$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $complex$ O O $string$ O O O $boolean$ O O O O O O $boolean$ O O O $any[]$ O $any$ O O O $CameraCalibrationData$ O $any$ O $TimeSettings$ O $any$ O $GetWebAppConfigValue$ O $any$ O $any[]$ O $any$ O O O $any[]$ O $any$ O O O O O O $any$ O $number$ O O O $number$ O O O $any$ O $any$ O $complex$ O $any$ O O O O $any$ O $OFCrop$ O $any$ O $any$ O $string$ O O O O O O $any$ O $undefined$ O O O O $string$ O O O O O O $number$ O O O O O O $string$ O O O O O O $any$ O $string[]$ O O O O O O O $HoveredPlantPayl$ O $any$ O $string$ O O O O O $string$ O O O $CropLiveSearchResult[]$ O $any$ O O O $boolean$ O O O $complex$ O $any$ O $CurrentPointPayl$ O $any$ O O O $string$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $ExecutableType$ O $number$ O O $any$ O O O $any$ O $string$ O O O O O $DropDownItem[]$ O $any$ O O O $DropDownItem[]$ O $any$ O O O $any[]$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O $any$ O $string$ O O O O O O $any$ O O O $string$ O $any$ O $any$ O $any$ O $complex$ O O $string$ O O O O $Function$ O $FunctionConstructor$ O $ExecutableQuery$ O $any$ O $TimeSettings$ O $any$ O $boolean$ O O O $ResourceIndex$ O $any$ O $ShouldDisplay$ O $any$ O O O O $any$ O $string$ O O O $number$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $number$ O O O $number$ O O O O O O $any$ O $number$ O O O $number$ O O O $string$ O O O $number$ O O O $CalendarOccurrence[]$ O $any$ O O O O O O $any$ O $boolean$ O O O $CalendarDay[]$ O $any$ O O O O O O $any$ O $string$ O O O O O O $any$ O $boolean$ O O O O O $boolean$ O O O O O $boolean$ O O O O O $boolean$ O O O O O $boolean$ O O O O O $boolean$ O O O O O $Function$ O $FunctionConstructor$ O $DesignerState$ O $any$ O $any[]$ O $any$ O O O $any[]$ O $any$ O O O $SlotWithTool[]$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any[]$ O $any$ O O O $complex$ O $any$ O $complex$ O $any$ O $complex$ O $any$ O O O O O O O O $number$ O O O $BotOriginQuadrant$ O $any$ O $complex$ O $any$ O $complex$ O $any$ O $complex$ O O $string$ O O O $boolean$ O O O O O O $boolean$ O O O $any[]$ O $any$ O O O $CameraCalibrationData$ O $any$ O $GetWebAppConfigValue$ O $any$ O $any[]$ O $any$ O O O $any[]$ O $any$ O O O $TimeSettings$ O $any$ O O O O $any$ O $boolean$ O O O O O $BotOriginQuadrant$ O $any$ O $number$ O O O O O $number$ O O O O O $complex$ O $any$ O O O $number$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $void$ O $string$ O O O O $Function$ O $FunctionConstructor$ O $any$ O $string$ O O O O O O $any$ O O O $string$ O O O O O $TimeSettings$ O $any$ O $GetWebAppConfigValue$ O $any$ O O O O $any$ O $HTMLImageElement$ O $complex$ O $complex$ O O $Function$ O $FunctionConstructor$ O O O O O O $any$ O $string$ O O O O O $string$ O O O O O O $any$ O O $string$ O O O $Function$ O O O O O O $any$ O $string$ O O O $Function$ O $FunctionConstructor$ O $CropLiveSearchResult[]$ O $any$ O O O $OpenfarmSearch$ O $any$ O $boolean$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $string$ O O O O O $CropLiveSearchResult[]$ O $any$ O O O $boolean$ O O O $string$ O O O O O $OpenfarmSearch$ O $any$ O $complex$ O $any$ O O O O $any$ O $string$ O O O O O $string$ O O O O O $complex$ O O $string$ O O O O O $string$ O O O O O O O $string$ O O O O O $string$ O O O O O O O O $any$ O $string$ O O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O O O
import { CropLiveSearchResult , CurrentPointPayl } from "s" ; import { generateReducer } from "s" ; import { DesignerState , HoveredPlantPayl } from "s" ; import { cloneDeep } from "s" ; import { TaggedResource } from "s" ; import { Actions } from "s" ; import { BotPosition } from "s" ; export let initialState = { selectedPlants : undefined , hoveredPlant : { plantUUID : undefined , icon : "s" } , hoveredPlantListItem : undefined , cropSearchQuery : "s" , cropSearchResults : [ ] , cropSearchInProgress : false , chosenLocation : { x : undefined , y : undefined , z : undefined } , currentPoint : undefined , openedSavedGarden : undefined , } ; export let designer = generateReducer < DesignerState > ( initialState ) . add < string > ( Actions . SEARCH_QUERY_CHANGE , ( s , { payload } ) => { s . cropSearchInProgress = true ; const state = cloneDeep ( s ) ; state . cropSearchQuery = payload ; return state ; } ) . add < boolean > ( Actions . OF_SEARCH_RESULTS_START , ( s ) => { s . cropSearchInProgress = true ; return s ; } ) . add < boolean > ( Actions . OF_SEARCH_RESULTS_NO , ( s ) => { s . cropSearchInProgress = false ; return s ; } ) . add < string [ ] | undefined > ( Actions . SELECT_PLANT , ( s , { payload } ) => { s . selectedPlants = payload ; return s ; } ) . add < HoveredPlantPayl > ( Actions . TOGGLE_HOVERED_PLANT , ( s , { payload } ) => { s . hoveredPlant = payload ; return s ; } ) . add < string | undefined > ( Actions . HOVER_PLANT_LIST_ITEM , ( s , { payload } ) => { s . hoveredPlantListItem = payload ; return s ; } ) . add < CurrentPointPayl > ( Actions . SET_CURRENT_POINT_DATA , ( s , { payload } ) => { s . currentPoint = payload ; return s ; } ) . add < CropLiveSearchResult [ ] > ( Actions . OF_SEARCH_RESULTS_OK , ( s , a ) => { s . cropSearchResults = a . payload ; s . cropSearchInProgress = false ; return s ; } ) . add < TaggedResource > ( Actions . DESTROY_RESOURCE_OK , ( s ) => { s . selectedPlants = undefined ; s . hoveredPlant = { plantUUID : undefined , icon : "s" } ; return s ; } ) . add < BotPosition > ( Actions . CHOOSE_LOCATION , ( s , { payload } ) => { s . chosenLocation = payload ; return s ; } ) . add < string | undefined > ( Actions . CHOOSE_SAVED_GARDEN , ( s , { payload } ) => { s . openedSavedGarden = payload ; return s ; } ) ;	O O $any$ O $any$ O O O O O O $GeneratedReducer$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $DesignerState$ O O $undefined$ O $undefined$ O $complex$ O O $undefined$ O $undefined$ O $string$ O O O O $undefined$ O $undefined$ O $string$ O O O $undefined[]$ O O O O $false$ O O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O O $generateReducer<DesignerState>.GeneratedReducer$ O $GeneratedReducer$ O $any$ O O $DesignerState$ O O $generateReducer<DesignerState>.GeneratedReducer$ O O O O $any$ O $Actions.SEARCH_QUERY_CHANGE$ O O $DesignerState$ O O $string$ O O O O $DesignerState$ O $boolean$ O O O O $any$ O $any$ O $DesignerState$ O O $any$ O $any$ O $string$ O O $any$ O O O O $generateReducer<DesignerState>.GeneratedReducer$ O O O O $any$ O $Actions.OF_SEARCH_RESULTS_START$ O O $DesignerState$ O O O $DesignerState$ O $boolean$ O O O O $DesignerState$ O O O O $generateReducer<DesignerState>.GeneratedReducer$ O O O O $any$ O $Actions.OF_SEARCH_RESULTS_NO$ O O $DesignerState$ O O O $DesignerState$ O $boolean$ O O O O $DesignerState$ O O O O $generateReducer<DesignerState>.GeneratedReducer$ O O O O O O O O $any$ O $Actions.SELECT_PLANT$ O O $DesignerState$ O O $string[]$ O O O O $DesignerState$ O $string[]$ O $string[]$ O O $DesignerState$ O O O O $generateReducer<DesignerState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.TOGGLE_HOVERED_PLANT$ O O $DesignerState$ O O $HoveredPlantPayl$ O O O O $DesignerState$ O $HoveredPlantPayl$ O $HoveredPlantPayl$ O O $DesignerState$ O O O O $generateReducer<DesignerState>.GeneratedReducer$ O O O O O O $any$ O $Actions.HOVER_PLANT_LIST_ITEM$ O O $DesignerState$ O O $string$ O O O O $DesignerState$ O $string$ O $string$ O O $DesignerState$ O O O O $generateReducer<DesignerState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.SET_CURRENT_POINT_DATA$ O O $DesignerState$ O O $CurrentPointPayl$ O O O O $DesignerState$ O $CurrentPointPayl$ O $CurrentPointPayl$ O O $DesignerState$ O O O O $generateReducer<DesignerState>.GeneratedReducer$ O $any$ O O O O $any$ O $Actions.OF_SEARCH_RESULTS_OK$ O O $DesignerState$ O $ReduxAction<CropLiveSearchResult[]>$ O O O $DesignerState$ O $CropLiveSearchResult[]$ O $ReduxAction<CropLiveSearchResult[]>$ O $CropLiveSearchResult[]$ O $DesignerState$ O $boolean$ O O O O $DesignerState$ O O O O $generateReducer<DesignerState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.DESTROY_RESOURCE_OK$ O O $DesignerState$ O O O $DesignerState$ O $string[]$ O $undefined$ O $DesignerState$ O $HoveredPlantPayl$ O O $undefined$ O $undefined$ O $string$ O O O O O $DesignerState$ O O O O $generateReducer<DesignerState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.CHOOSE_LOCATION$ O O $DesignerState$ O O $complex$ O O O O $DesignerState$ O $complex$ O $complex$ O O $DesignerState$ O O O O $generateReducer<DesignerState>.GeneratedReducer$ O O O O O O $any$ O $Actions.CHOOSE_SAVED_GARDEN$ O O $DesignerState$ O O $string$ O O O O $DesignerState$ O $string$ O $string$ O O $DesignerState$ O O O O
import { betterCompact } from "s" ; interface Pending { kind : "s" ; start : number ; } interface Timeout { kind : "s" ; start : number ; end : number ; } interface Complete { kind : "s" ; start : number ; end : number ; } export type Ping = Complete | Pending | Timeout ; export type PingDictionary = Record < string , Ping | undefined > ; export const now = ( ) => ( new Date ( ) ) . getTime ( ) ; export const startPing = ( s , id , start = now ( ) ) : PingDictionary => { return { ... s , [ id ] : { kind : "s" , start } } ; } ; export const failPing = ( s , id , end = now ( ) ) : PingDictionary => { const failure = s [ id ] ; if ( failure && failure . kind != "s" ) { const nextFailure = { kind : "s" , start : failure . start , end } ; return { ... s , [ id ] : nextFailure } ; } return s ; } ; export const completePing = ( s , id , end = now ( ) ) : PingDictionary => { const failure = s [ id ] ; if ( failure && failure . kind == "s" ) { return { ... s , [ id ] : { kind : "s" , start : failure . start , end } } ; } return s ; } ; type PingLossReport = Record < Ping [ "s" ] | "s" , number > ; const getAll = ( s ) => betterCompact ( Object . values ( s ) ) ; export const calculatePingLoss = ( s ) : PingLossReport => { const all = getAll ( s ) ; const report = { complete : 0 , pending : 0 , timeout : 0 , total : 0 , } ; all . map ( p => report [ p . kind ] += 0 ) ; report . total = all . length ; return report ; } ; interface LatencyReport { best : number ; worst : number ; average : number ; total : number ; } const mapper = ( p ) => ( p . kind === "s" ) ? p . end - p . start : undefined ; export const calculateLatency = ( s ) : LatencyReport => { let latency : number [ ] = betterCompact ( getAll ( s ) . map ( mapper ) ) ; if ( latency . length == 0 ) { latency = [ 0 ] ; } const average = Math . round ( latency . reduce ( ( a , b ) => a + b , 0 ) / latency . length ) ; const report = { best : Math . min ( ... latency ) , worst : Math . max ( ... latency ) , average , total : latency . length } ; const doReport = ! ! report . total && ! ( report . total % 0 ) ; doReport && window . logStore . log ( "s" , report , "s" ) ; return report ; } ;	O O $T[]$ O O O O O $any$ O O O O O $number$ O O O O O $any$ O O O O O $number$ O O O $number$ O O O O O $any$ O O O O O $number$ O O O $number$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O $number$ O O O O O O $DateConstructor$ O O O O $number$ O O O O O $complex$ O O $PingDictionary$ O $string$ O $number$ O $number$ O O O O $any$ O O O O O $complex$ O O $string$ O O O O O O O $number$ O O O O O O O $complex$ O O $PingDictionary$ O $string$ O $number$ O $number$ O O O O $any$ O O O $Ping$ O $complex$ O $string$ O O O O $Ping$ O $Ping$ O O O O O O O $Timeout$ O O O O O O $number$ O $complex$ O $number$ O $number$ O O O O O $complex$ O O $string$ O O $Timeout$ O O O O $complex$ O O O O O $complex$ O O $PingDictionary$ O $string$ O $number$ O $number$ O O O O $any$ O O O $Ping$ O $complex$ O $string$ O O O O $Ping$ O $Ping$ O O O O O O O O O $complex$ O O $string$ O O O O O O O $number$ O $Pending$ O $number$ O $number$ O O O O O $complex$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O $Ping[]$ O O $PingDictionary$ O O $T[]$ O $ObjectConstructor$ O $complex$ O $complex$ O O O O O $complex$ O O $PingDictionary$ O O $any$ O O O $Ping[]$ O $Ping[]$ O $complex$ O O O $PingLossReport$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O $Ping[]$ O $U[]$ O $Ping$ O $complex$ O $Ping$ O O O O O O O $complex$ O $number$ O $Ping[]$ O $number$ O O $complex$ O O O O $any$ O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O $number$ O O $Ping$ O O O $Ping$ O O O O O O $Complete$ O $number$ O $Complete$ O $number$ O $undefined$ O O O $LatencyReport$ O O $PingDictionary$ O O $any$ O O O $number[]$ O O O O O $T[]$ O $Ping[]$ O $complex$ O O $U[]$ O $number$ O O O O O $number[]$ O $number$ O O O O $number[]$ O O O O O O O $number$ O $Math$ O $number$ O $number[]$ O $complex$ O O $number$ O $number$ O O $number$ O $number$ O O O O $number[]$ O $number$ O O O $complex$ O O $number$ O $Math$ O $number$ O O $number[]$ O O $number$ O $Math$ O $number$ O O $number[]$ O O $number$ O $number$ O $number[]$ O $number$ O O O $boolean$ O O O $complex$ O $number$ O O O $complex$ O $number$ O O O O $boolean$ O $complex$ O $LogStore$ O $void$ O O O $complex$ O O O O O $complex$ O O O
import { TaggedResource } from "s" ; import { PingDictionary } from "s" ; export type NetworkState = "s" | "s" ; export interface ConnectionStatus { state : NetworkState ; at : number ; } export interface EdgeStatus { name : Edge ; status : ConnectionStatus ; } export type Edge = | "s" | "s" | "s" ; type ConnectionRecord = Record < Edge , ConnectionStatus | undefined > ; export type ConnectionState = { uptime : ConnectionRecord ; pings : PingDictionary ; } ; export interface UpdateMqttData < T extends TaggedResource > { status : "s" kind : T [ "s" ] ; body : T [ "s" ] ; id : number ; sessionId : string ; } export interface DeleteMqttData < T extends TaggedResource > { status : "s" kind : T [ "s" ] ; id : number ; } export interface BadMqttData { status : "s" ; reason : string ; } export interface SkipMqttData { status : "s" ; } export type MqttDataResult < T extends TaggedResource > = | UpdateMqttData < T > | DeleteMqttData < T > | SkipMqttData | BadMqttData ; export enum Reason { BAD_KIND = "s" , BAD_ID = "s" , BAD_CHAN = "s" } export interface SyncPayload { args : { label : string ; } ; body : object | undefined ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $NetworkState$ O $any$ O $number$ O O O O O O $any$ O $Edge$ O $any$ O $ConnectionStatus$ O $any$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $complex$ O $any$ O $complex$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $T["kind"]$ O $any$ O O O O $T["body"]$ O $any$ O O O O $number$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O $T["kind"]$ O $any$ O O O O $number$ O O O O O O $any$ O O O O O $string$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $Reason.BAD_KIND$ O O O $Reason.BAD_ID$ O O O $Reason.BAD_CHAN$ O O O O O $any$ O $complex$ O O $string$ O O O O O $object$ O O O O O O
import { Dictionary , SyncStatus , FarmwareConfig } from "s" ; import { NetworkState } from "s" ; import { BooleanConfigKey } from "s" ; import { ShouldDisplay } from "s" ; export interface FWState { selectedFarmware : string | undefined ; packageUrl : string | undefined ; } export interface FWProps { botToMqttStatus : NetworkState ; syncStatus : SyncStatus | undefined ; farmwares : Farmwares ; showFirstParty : boolean ; onToggle ( key ) : void ; firstPartyFarmwareNames : string [ ] ; } export interface FarmwareState { currentFarmware : string | undefined ; currentImage : string | undefined ; firstPartyFarmwareNames : string [ ] ; infoOpen : boolean ; } export type FarmwareManifestEntry = Record < "s" | "s" , string > ; export interface FarmwareConfigMenuProps { show : boolean | undefined ; dispatch : Function ; firstPartyFwsInstalled : boolean ; shouldDisplay : ShouldDisplay ; } export type Farmwares = Dictionary < FarmwareManifestInfo > ; export interface FarmwareEnv { id ? : number ; key : string ; value : string | number | boolean ; } export interface FarmwareManifestInfo { name : string ; installation_pending : boolean ; url : string ; config : FarmwareConfig [ ] ; meta : { fbos_version : string ; farmware_tools_version : string ; description : string ; language : string ; version : string ; author : string ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O O O $string$ O O O O O O O O $any$ O $NetworkState$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $boolean$ O O O $void$ O $BooleanConfigKey$ O O O O $string[]$ O O O O O O O O $any$ O $string$ O O O O O $string$ O O O O O $string[]$ O O O O O $boolean$ O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $boolean$ O O O O O $Function$ O $FunctionConstructor$ O $boolean$ O O O $ShouldDisplay$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $number$ O O O O $string$ O O O $complex$ O O O O O O O O O O $any$ O $string$ O O O $boolean$ O O O $string$ O O O $any[]$ O $any$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O
import { generateReducer } from "s" ; import { FarmwareState } from "s" ; import { TaggedResource } from "s" ; import { Actions } from "s" ; export let farmwareState = { currentFarmware : undefined , currentImage : undefined , firstPartyFarmwareNames : [ ] , infoOpen : false , } ; export let farmwareReducer = generateReducer < FarmwareState > ( farmwareState ) . add < TaggedResource > ( Actions . INIT_RESOURCE , ( s , { payload } ) => { if ( payload . kind === "s" ) { s . currentImage = payload . uuid ; } return s ; } ) . add < string > ( Actions . SELECT_FARMWARE , ( s , { payload } ) => { s . currentFarmware = payload ; return s ; } ) . add < string > ( Actions . SELECT_IMAGE , ( s , { payload } ) => { s . currentImage = payload ; return s ; } ) . add < string [ ] > ( Actions . FETCH_FIRST_PARTY_FARMWARE_NAMES_OK , ( s , { payload } ) => { s . firstPartyFarmwareNames = payload ; return s ; } ) . add < TaggedResource > ( Actions . DESTROY_RESOURCE_OK , ( s , { payload } ) => { const thatUUID = payload . uuid ; const thisUUID = s . currentImage ; if ( thisUUID === thatUUID ) { s . currentImage = undefined ; } return s ; } ) . add < boolean > ( Actions . SET_FARMWARE_INFO_STATE , ( s , { payload } ) => { s . infoOpen = payload ; return s ; } ) ;	O O $GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $FarmwareState$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined[]$ O O O O $false$ O O O O O O O $generateReducer<FarmwareState>.GeneratedReducer$ O $GeneratedReducer$ O $any$ O O $FarmwareState$ O O $generateReducer<FarmwareState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.INIT_RESOURCE$ O O $FarmwareState$ O O $any$ O O O O O O $any$ O $any$ O O O O $FarmwareState$ O $string$ O $any$ O $any$ O O O $FarmwareState$ O O O O $generateReducer<FarmwareState>.GeneratedReducer$ O O O O $any$ O $Actions.SELECT_FARMWARE$ O O $FarmwareState$ O O $string$ O O O O $FarmwareState$ O $string$ O $string$ O O $FarmwareState$ O O O O $generateReducer<FarmwareState>.GeneratedReducer$ O O O O $any$ O $Actions.SELECT_IMAGE$ O O $FarmwareState$ O O $string$ O O O O $FarmwareState$ O $string$ O $string$ O O $FarmwareState$ O O O O $generateReducer<FarmwareState>.GeneratedReducer$ O O O O O O $any$ O $Actions.FETCH_FIRST_PARTY_FARMWARE_NAMES_OK$ O O $FarmwareState$ O O $string[]$ O O O O $FarmwareState$ O $string[]$ O $string[]$ O O $FarmwareState$ O O O O $generateReducer<FarmwareState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.DESTROY_RESOURCE_OK$ O O $FarmwareState$ O O $any$ O O O O O $any$ O $any$ O $any$ O O $string$ O $FarmwareState$ O $string$ O O O $string$ O $any$ O O $FarmwareState$ O $string$ O $undefined$ O O O $FarmwareState$ O O O O $generateReducer<FarmwareState>.GeneratedReducer$ O O O O $any$ O $Actions.SET_FARMWARE_INFO_STATE$ O O $FarmwareState$ O O $boolean$ O O O O $FarmwareState$ O $boolean$ O $boolean$ O O $FarmwareState$ O O O O
import { ResourceColor } from "s" ; import { Week } from "s" ; import { AuthState } from "s" ; import { BotState , ShouldDisplay } from "s" ; import { TaggedRegimen , TaggedSequence } from "s" ; import { ResourceIndex , UUID , VariableNameSet } from "s" ; export interface CalendarRow { day : string ; items : RegimenItemCalendarRow [ ] ; } export interface Props { dispatch : Function ; sequences : TaggedSequence [ ] ; variableData : VariableNameSet ; auth : AuthState | undefined ; bot : BotState ; current : TaggedRegimen | undefined ; regimens : TaggedRegimen [ ] ; resources : ResourceIndex ; selectedSequence : TaggedSequence | undefined ; dailyOffsetMs : number ; weeks : Week [ ] ; calendar : CalendarRow [ ] ; regimenUsageStats : Record < UUID , boolean | undefined > ; shouldDisplay : ShouldDisplay ; schedulerOpen : boolean ; } export interface RegimenItemCalendarRow { regimen : TaggedRegimen ; item : RegimenItem ; name : string ; hhmm : string ; color : string ; sortKey : number ; day : number ; dispatch : Function ; variable : string | undefined ; } export interface RegimenProps { regimen : TaggedRegimen ; dispatch : Function ; } export interface Regimen { id ? : number ; name : string ; color : ResourceColor ; regimen_items : RegimenItem [ ] ; } export interface RegimenListItemProps { length : number ; regimen : TaggedRegimen ; dispatch : Function ; inUse : boolean ; index : number ; } export interface RegimenItem { id ? : number ; sequence_id : number ; regimen_id ? : number ; time_offset : number ; } export interface AddRegimenProps { dispatch : Function ; className ? : string ; children ? : React . ReactNode ; length : number ; } export interface RegimensListProps { dispatch : Function ; regimens : TaggedRegimen [ ] ; regimen : TaggedRegimen | undefined ; usageStats : Record < UUID , boolean | undefined > ; } export interface RegimensListState { searchTerm : string ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $string$ O O O $RegimenItemCalendarRow[]$ O $any$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any[]$ O $any$ O O O $complex$ O $any$ O $AuthState$ O $any$ O O O $BotState$ O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O O O $ResourceIndex$ O $any$ O $any$ O $any$ O O O $number$ O O O $Week[]$ O $any$ O O O $CalendarRow[]$ O $any$ O O O $complex$ O $any$ O $any$ O O O O O O $ShouldDisplay$ O $any$ O $boolean$ O O O O O O $any$ O $any$ O $any$ O $RegimenItem$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $number$ O O O $Function$ O $FunctionConstructor$ O $string$ O O O O O O O O $any$ O $any$ O $any$ O $Function$ O $FunctionConstructor$ O O O O $any$ O $number$ O O O O $string$ O O O $any$ O $any$ O $RegimenItem[]$ O $any$ O O O O O O $any$ O $number$ O O O $any$ O $any$ O $Function$ O $FunctionConstructor$ O $boolean$ O O O $number$ O O O O O O $any$ O $number$ O O O O $number$ O O O $number$ O O O O $number$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $string$ O O O O $any$ O O $any$ O $any$ O $number$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any[]$ O $any$ O O O $any$ O $any$ O O O $complex$ O $any$ O $any$ O O O O O O O O O $any$ O $string$ O O O O
import { RegimenItem } from "s" ; import { TaggedSequence } from "s" ; import { ResourceIndex } from "s" ; export interface BulkSchedulerOutput { index : number ; regimenItems : RegimenItem [ ] ; } export interface BulkEditorProps { selectedSequence ? : TaggedSequence ; dailyOffsetMs : number ; weeks : Week [ ] ; resources : ResourceIndex ; sequences : TaggedSequence [ ] ; dispatch : Function ; } type WeekDay = | "s" | "s" | "s" | "s" | "s" | "s" | "s" ; export const DAYS : WeekDay [ ] = [ "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ; export interface Week { days : Record < WeekDay , boolean > ; } export interface ToggleDayParams { week : number ; day : number ; } export interface AddButtonProps { active : boolean ; click : React . EventHandler < React . FormEvent < { } > > ; } export interface SequenceListProps { sequences : TaggedSequence [ ] ; current : TaggedSequence | undefined ; dispatch : Function ; } export interface WeekGridProps { weeks : Week [ ] ; dispatch : Function ; } export interface WeekRowProps { week : Week ; index : number ; dispatch : Function ; } export interface DayProps { day : number ; week : number ; dispatch : Function ; id : string ; active : boolean ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $number$ O O O $RegimenItem[]$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $number$ O O O $Week[]$ O $any$ O O O $ResourceIndex$ O $any$ O $any[]$ O $any$ O O O $Function$ O $FunctionConstructor$ O O O $any$ O O O O O O O O O O O O O O O O O O $WeekDay[]$ O $any$ O O O O O O O O O O O O O O O O O O O O O $any$ O $complex$ O $any$ O $any$ O O O O O O O $any$ O $number$ O O O $number$ O O O O O O $any$ O $boolean$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any[]$ O $any$ O O O $any$ O $any$ O O O $Function$ O $FunctionConstructor$ O O O O $any$ O $Week[]$ O $any$ O O O $Function$ O $FunctionConstructor$ O O O O $any$ O $Week$ O $any$ O $number$ O O O $Function$ O $FunctionConstructor$ O O O O $any$ O $number$ O O O $number$ O O O $Function$ O $FunctionConstructor$ O $string$ O O O $boolean$ O O O O
import { times } from "s" ; import { Dictionary , TaggedResource } from "s" ; import { Week , DAYS } from "s" ; import { generateReducer } from "s" ; import { Actions } from "s" ; export interface RegimenState { dailyOffsetMs : number ; weeks : Week [ ] ; selectedSequenceUUID ? : string | undefined ; currentRegimen ? : string | undefined ; schedulerOpen : boolean ; } function newWeek ( ) { return { days : { 0 : false , 0 : false , 0 : false , 0 : false , 0 : false , 0 : false , 0 : false } } ; } function newState ( ) { return { dailyOffsetMs : 0 , weeks : times ( 0 , newWeek ) , selectedSequenceUUID : undefined , currentRegimen : undefined , schedulerOpen : false , } ; } export let initialState = newState ( ) ; export let regimensReducer = generateReducer < RegimenState > ( initialState ) . add < TaggedResource > ( Actions . DESTROY_RESOURCE_OK , ( s , { payload } ) => { switch ( payload . uuid ) { case s . selectedSequenceUUID : case s . currentRegimen : s . selectedSequenceUUID = undefined ; break ; } return s ; } ) . add < void > ( Actions . PUSH_WEEK , ( s ) => { s . weeks . push ( newWeek ( ) ) ; return s ; } ) . add < void > ( Actions . POP_WEEK , ( s ) => { s . weeks . pop ( ) ; return s ; } ) . add < void > ( Actions . DESELECT_ALL_DAYS , ( s ) => { s . weeks . map ( ( week ) => DAYS . map ( ( key ) => week . days [ key ] = false ) ) ; return s ; } ) . add < void > ( Actions . SELECT_ALL_DAYS , ( s ) => { s . weeks . map ( ( week ) => DAYS . map ( ( key ) => week . days [ key ] = true ) ) ; return s ; } ) . add < { week : number , day : number } > ( Actions . TOGGLE_DAY , ( s , { payload } ) => { const week = s . weeks [ payload . week ] ; const day = `template` ; const days = ( week . days as Dictionary < boolean > ) ; days [ day ] = ! days [ day ] ; return s ; } ) . add < string > ( Actions . SELECT_REGIMEN , ( s , { payload } ) => { s . currentRegimen = payload ; return s ; } ) . add < string > ( Actions . SET_SEQUENCE , ( s , { payload } ) => { s . selectedSequenceUUID = payload ; return s ; } ) . add < number > ( Actions . SET_TIME_OFFSET , ( s , { payload } ) => { s . dailyOffsetMs = payload ; return s ; } ) . add < boolean > ( Actions . SET_SCHEDULER_STATE , ( s , { payload } ) => { s . schedulerOpen = payload ; return s ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $WeekDay[]$ O O O O O O $GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O $number$ O O O $Week[]$ O $any$ O O O $string$ O O O O O O $string$ O O O O O O $boolean$ O O O O O O O O O O O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O O O $RegimenState$ O O O O O $number$ O O O $any$ O $any$ O O O O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $false$ O O O O O O O O $RegimenState$ O $RegimenState$ O O O O O $generateReducer<RegimenState>.GeneratedReducer$ O $GeneratedReducer$ O $any$ O O $RegimenState$ O O $generateReducer<RegimenState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.DESTROY_RESOURCE_OK$ O O $RegimenState$ O O $any$ O O O O O O $any$ O $any$ O O O $RegimenState$ O $string$ O O $RegimenState$ O $string$ O $RegimenState$ O $string$ O $undefined$ O O O O O $RegimenState$ O O O O $generateReducer<RegimenState>.GeneratedReducer$ O O O O $any$ O $Actions.PUSH_WEEK$ O O $RegimenState$ O O O $RegimenState$ O $Week[]$ O $number$ O O O O O O O $RegimenState$ O O O O $generateReducer<RegimenState>.GeneratedReducer$ O O O O $any$ O $Actions.POP_WEEK$ O O $RegimenState$ O O O $RegimenState$ O $Week[]$ O $Week$ O O O O $RegimenState$ O O O O $generateReducer<RegimenState>.GeneratedReducer$ O O O O $any$ O $Actions.DESELECT_ALL_DAYS$ O O $RegimenState$ O O O $RegimenState$ O $Week[]$ O $U[]$ O O $Week$ O O $WeekDay[]$ O $U[]$ O O $WeekDay$ O O $Week$ O $complex$ O $WeekDay$ O O O O O O O $RegimenState$ O O O O $generateReducer<RegimenState>.GeneratedReducer$ O O O O $any$ O $Actions.SELECT_ALL_DAYS$ O O $RegimenState$ O O O $RegimenState$ O $Week[]$ O $U[]$ O O $Week$ O O $WeekDay[]$ O $U[]$ O O $WeekDay$ O O $Week$ O $complex$ O $WeekDay$ O O O O O O O $RegimenState$ O O O O $generateReducer<RegimenState>.GeneratedReducer$ O O $number$ O O O $number$ O O O O O $any$ O $Actions.TOGGLE_DAY$ O O $RegimenState$ O O $complex$ O O O O O $Week$ O $RegimenState$ O $Week[]$ O $complex$ O $number$ O O O $string$ O O O O $any$ O O $Week$ O $complex$ O $any$ O O O O O $any$ O $string$ O O O $any$ O $string$ O O O $RegimenState$ O O O O $generateReducer<RegimenState>.GeneratedReducer$ O O O O $any$ O $Actions.SELECT_REGIMEN$ O O $RegimenState$ O O $string$ O O O O $RegimenState$ O $string$ O $string$ O O $RegimenState$ O O O O $generateReducer<RegimenState>.GeneratedReducer$ O O O O $any$ O $Actions.SET_SEQUENCE$ O O $RegimenState$ O O $string$ O O O O $RegimenState$ O $string$ O $string$ O O $RegimenState$ O O O O $generateReducer<RegimenState>.GeneratedReducer$ O O O O $any$ O $Actions.SET_TIME_OFFSET$ O O $RegimenState$ O O $number$ O O O O $RegimenState$ O $number$ O $number$ O O $RegimenState$ O O O O $generateReducer<RegimenState>.GeneratedReducer$ O O O O $any$ O $Actions.SET_SCHEDULER_STATE$ O O $RegimenState$ O O $boolean$ O O O O $RegimenState$ O $boolean$ O $boolean$ O O $RegimenState$ O O O O
import { SequenceReducerState } from "s" ; import { generateReducer } from "s" ; import { TaggedResource } from "s" ; import { Actions } from "s" ; export const initialState = { current : undefined , menuOpen : false , stepIndex : undefined , } ; export let sequenceReducer = generateReducer < SequenceReducerState > ( initialState ) . add < TaggedResource > ( Actions . DESTROY_RESOURCE_OK , ( s , { payload } ) => { switch ( payload . uuid ) { case s . current : s . current = undefined ; break ; } return s ; } ) . add < string > ( Actions . SELECT_SEQUENCE , function ( s , { payload } ) { s . current = payload ; return s ; } ) . add < boolean > ( Actions . SET_SEQUENCE_POPUP_STATE , function ( s , { payload } ) { s . menuOpen = payload ; return s ; } ) . add < number | undefined > ( Actions . SET_SEQUENCE_STEP_POSITION , function ( s , { payload } ) { s . stepIndex = payload ; return s ; } ) ;	O O $any$ O O O O O O $GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O O O O O O $SequenceReducerState$ O O $undefined$ O $undefined$ O $false$ O O O $undefined$ O $undefined$ O O O O O $generateReducer<SequenceReducerState>.GeneratedReducer$ O $GeneratedReducer$ O $any$ O O $SequenceReducerState$ O O $generateReducer<SequenceReducerState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.DESTROY_RESOURCE_OK$ O O $SequenceReducerState$ O O $any$ O O O O O O $any$ O $any$ O O O $SequenceReducerState$ O $string$ O $SequenceReducerState$ O $string$ O $undefined$ O O O O O $SequenceReducerState$ O O O O $generateReducer<SequenceReducerState>.GeneratedReducer$ O O O O $any$ O $Actions.SELECT_SEQUENCE$ O O O $SequenceReducerState$ O O $string$ O O O $SequenceReducerState$ O $string$ O $string$ O O $SequenceReducerState$ O O O O $generateReducer<SequenceReducerState>.GeneratedReducer$ O O O O $any$ O $Actions.SET_SEQUENCE_POPUP_STATE$ O O O $SequenceReducerState$ O O $boolean$ O O O $SequenceReducerState$ O $boolean$ O $boolean$ O O $SequenceReducerState$ O O O O $generateReducer<SequenceReducerState>.GeneratedReducer$ O O O O O O $any$ O $Actions.SET_SEQUENCE_STEP_POSITION$ O O O $SequenceReducerState$ O O $number$ O O O $SequenceReducerState$ O $number$ O $number$ O O $SequenceReducerState$ O O O O
import { get , set } from "s" ; import { SequenceBodyItem , uuid } from "s" ; import { Traversable } from "s" ; export type StepTag = string ; const TAG_PROP = "s" ; export const maybeTagStep = ( t ) => ! get ( t , TAG_PROP ) && forceSetStepTag ( t ) ; export const forceSetStepTag = < T extends Traversable > ( node : T ) : T => { set ( node , TAG_PROP , uuid ( ) ) ; return node ; } ; export function getStepTag ( i ) { const tag = get ( i , TAG_PROP , "s" ) ; if ( tag ) { return tag ; } throw new Error ( "s" + i . kind ) ; }	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O $Traversable$ O O $Traversable$ O O O $any$ O $Traversable$ O O O O $T$ O $Traversable$ O O O O $T$ O O $any$ O $any$ O O $T$ O $any$ O O $any$ O O $any$ O $T$ O O O $any$ O O O O O $T$ O O O O O $StepTag$ O $SequenceBodyItem$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O O O O $ErrorConstructor$ O O O $any$ O $any$ O O O
import { TaggedResource } from "s" ; import { ResourceIndex } from "s" ; import { isTaggedResource } from "s" ; import { sortResourcesById } from "s" ; export function findAll < T extends TaggedResource > ( index , kind : T [ "s" ] ) : T [ ] { const results : T [ ] = [ ] ; Object . keys ( index . byKind [ kind ] ) . map ( function ( uuid ) { const item = index . references [ uuid ] ; if ( item && isTaggedResource ( item ) && ( item . kind === kind ) ) { results . push ( item as T ) ; } } ) ; return sortResourcesById ( results ) as T [ ] ; }	O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $T[]$ O O O O O O $T[]$ O $any$ O $any$ O O $ResourceIndex$ O $T["kind"]$ O $any$ O O O O O $any$ O O O O $T[]$ O $any$ O O O O O O $ObjectConstructor$ O $complex$ O $ResourceIndex$ O $complex$ O $T["kind"]$ O O O $U[]$ O O O $string$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O O $any$ O $complex$ O $any$ O O O $any$ O $any$ O $T["kind"]$ O O O $T[]$ O $number$ O $any$ O $any$ O O O O O O O $T[]$ O $T[]$ O O $any$ O O O O
import { findId } from "s" ; import { isTaggedFarmEvent , isTaggedPlantPointer , isTaggedRegimen , isTaggedSequence , isTaggedTool , isTaggedToolSlotPointer , sanityCheck , isTaggedPlantTemplate , isTaggedGenericPointer , } from "s" ; import { ResourceName , TaggedResource , TaggedTool , TaggedToolSlotPointer , } from "s" ; import { ResourceIndex } from "s" ; import { isNumber , find } from "s" ; import { joinKindAndId } from "s" ; import { findAll } from "s" ; export const findAllById = < T extends TaggedResource > ( i , _ids : number [ ] , k : T [ "s" ] ) => { const output : TaggedResource [ ] = [ ] ; findAll < T > ( i , k ) . map ( x => x . kind === k ? output . push ( x ) : "s" ) ; return output ; } ; export let byId = < T extends TaggedResource > ( name : T [ "s" ] ) => ( index , id ) : T | undefined => { const resources = findAll ( index , name ) ; const f = ( x ) => ( x . kind === name ) && ( x . body . id === id ) ; return resources . filter ( f ) [ 0 ] as T | undefined ; } ; export let findFarmEventById = ( ri , fe_id ) => { const fe = byId ( "s" ) ( ri , fe_id ) ; if ( fe && isTaggedFarmEvent ( fe ) && sanityCheck ( fe ) ) { return fe ; } else { const e = new Error ( `template` ) ; throw e ; } } ; export let maybeFindToolById = ( ri , tool_id ? ) : TaggedTool | undefined => { const tool = tool_id && byId ( "s" ) ( ri , tool_id ) ; if ( tool && isTaggedTool ( tool ) && sanityCheck ( tool ) ) { return tool ; } else { return undefined ; } } ; export let findToolById = ( ri , tool_id ) => { const tool = maybeFindToolById ( ri , tool_id ) ; if ( tool ) { return tool ; } else { throw new Error ( "s" + tool_id ) ; } } ; export let findSequenceById = ( ri , sequence_id ) => { const sequence = byId ( "s" ) ( ri , sequence_id ) ; if ( sequence && isTaggedSequence ( sequence ) && sanityCheck ( sequence ) ) { return sequence ; } else { throw new Error ( "s" + sequence_id ) ; } } ; export let findSlotById = byId < TaggedToolSlotPointer > ( "s" ) ; export let findSlotByToolId = ( index , tool_id ) => { const tool = findToolById ( index , tool_id ) ; const query = { body : { tool_id : tool . body . id } } ; const every = Object . keys ( index . references ) . map ( x => index . references [ x ] ) ; const tts = find ( every , query ) ; if ( tts && ! isNumber ( tts ) && isTaggedToolSlotPointer ( tts ) && sanityCheck ( tts ) ) { return tts ; } else { return undefined ; } } ; export function maybeFindPlantById ( index , id ) { const uuid = index . byKindAndId [ joinKindAndId ( "s" , id ) ] ; const resource = index . references [ uuid || "s" ] ; if ( resource && isTaggedPlantPointer ( resource ) ) { return resource ; } } export function maybeFindPlantTemplateById ( index , id ) { const uuid = index . byKindAndId [ joinKindAndId ( "s" , id ) ] ; const resource = index . references [ uuid || "s" ] ; if ( resource && isTaggedPlantTemplate ( resource ) ) { return resource ; } } export function maybeFindPointById ( index , id ) { const uuid = index . byKindAndId [ joinKindAndId ( "s" , id ) ] ; const resource = index . references [ uuid || "s" ] ; if ( resource && isTaggedGenericPointer ( resource ) ) { return resource ; } } export let findRegimenById = ( ri , regimen_id ) => { const regimen = byId ( "s" ) ( ri , regimen_id ) ; if ( regimen && isTaggedRegimen ( regimen ) && sanityCheck ( regimen ) ) { return regimen ; } else { throw new Error ( "s" + regimen_id ) ; } } ; export function findResourceById ( index , kind , id ) { return findId ( index , kind , id ) ; }	O O $any$ O O O O O O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $string$ O O O O O O $T[]$ O O O O O O $any[]$ O O $any$ O $any$ O O $ResourceIndex$ O $number[]$ O O O O O $T["kind"]$ O $any$ O O O O O O O $any[]$ O $any$ O O O O O O $T[]$ O $any$ O O $ResourceIndex$ O $T["kind"]$ O O $U[]$ O $T$ O $T$ O $any$ O $T["kind"]$ O $any[]$ O $number$ O $T$ O O O O O O $any[]$ O O O O O $T$ O O $any$ O $any$ O O $T["kind"]$ O $any$ O O O O O O $ResourceIndex$ O $number$ O O $any$ O O O O O $T[]$ O $T[]$ O $ResourceIndex$ O $T["kind"]$ O O O $boolean$ O O $TaggedResource$ O O O $any$ O $any$ O $T["kind"]$ O O O $any$ O $any$ O $any$ O $number$ O O O $T[]$ O $complex$ O $boolean$ O O O O O $any$ O O O O O O O $any$ O O $ResourceIndex$ O $number$ O O O O $any$ O $T$ O O O O $ResourceIndex$ O $number$ O O O O $any$ O $complex$ O $any$ O O $complex$ O $any$ O O O O $any$ O O O O O $Error$ O O $ErrorConstructor$ O O O O O $Error$ O O O O O O $any$ O O $ResourceIndex$ O $number$ $number$ O O $any$ O O O O O $any$ O $number$ O $T$ O O O O $ResourceIndex$ O $number$ O O O O $any$ O $complex$ O $any$ O O $complex$ O $any$ O O O O $any$ O O O O O $undefined$ O O O O O O $any$ O O $ResourceIndex$ O $number$ O O O O $any$ O $any$ O $ResourceIndex$ O $number$ O O O O $any$ O O O $any$ O O O O O O $ErrorConstructor$ O O O $number$ O O O O O O O $any$ O O $ResourceIndex$ O $number$ O O O O $any$ O $T$ O O O O $ResourceIndex$ O $number$ O O O O $any$ O $complex$ O $any$ O O $complex$ O $any$ O O O O $any$ O O O O O O $ErrorConstructor$ O O O $number$ O O O O O O O $any$ O $T$ O $any$ O O O O O O O $any$ O O $ResourceIndex$ O $number$ O O O O $any$ O $any$ O $ResourceIndex$ O $number$ O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O $ObjectConstructor$ O $complex$ O $ResourceIndex$ O $any$ O O $U[]$ O $string$ O $ResourceIndex$ O $any$ O $string$ O O O O $any$ O $any$ O $any[]$ O $complex$ O O O O $any$ O O $any$ O $any$ O O $complex$ O $any$ O O $complex$ O $any$ O O O O $any$ O O O O O $undefined$ O O O O O O $any$ O $ResourceIndex$ O $number$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O $number$ O O O O $any$ O $ResourceIndex$ O $any$ O $any$ O O O O O O $any$ O $complex$ O $any$ O O O O $any$ O O O O O $any$ O $ResourceIndex$ O $number$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O $number$ O O O O $any$ O $ResourceIndex$ O $any$ O $any$ O O O O O O $any$ O $complex$ O $any$ O O O O $any$ O O O O O $any$ O $ResourceIndex$ O $number$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O $number$ O O O O $any$ O $ResourceIndex$ O $any$ O $any$ O O O O O O $any$ O $complex$ O $any$ O O O O $any$ O O O O O $any$ O O $ResourceIndex$ O $number$ O O O O $any$ O $T$ O O O O $ResourceIndex$ O $number$ O O O O $any$ O $complex$ O $any$ O O $complex$ O $any$ O O O O $any$ O O O O O O $ErrorConstructor$ O O O $number$ O O O O O O O $any$ O $ResourceIndex$ O $ResourceName$ O $number$ O O O $any$ O $ResourceIndex$ O $any$ O $number$ O O O
export class FBToast { static everyMessage : Record < string , boolean > = { } ; public toastEl = document . createElement ( "s" ) ; public titleEl = document . createElement ( "s" ) ; public messageEl = document . createElement ( "s" ) ; public loaderEl = document . createElement ( "s" ) ; public leftLoaderEl = document . createElement ( "s" ) ; public rightLoaderEl = document . createElement ( "s" ) ; public spinnerLoaderEl = document . createElement ( "s" ) ; public intervalId = 0 ; public timeout = 0 ; public isHovered = false ; public message = "s" ; public isAttached = false ; constructor ( public parent , title , raw_message , color ) { this . message = raw_message . replace ( "s" , "s" ) ; this . titleEl . innerText = title ; this . messageEl . innerText = this . message ; this . toastEl . classList . add ( "s" ) ; this . toastEl . classList . add ( color ) ; this . titleEl . classList . add ( "s" ) ; this . messageEl . classList . add ( "s" ) ; this . loaderEl . classList . add ( "s" ) ; this . leftLoaderEl . classList . add ( "s" ) ; this . leftLoaderEl . classList . add ( color ) ; this . rightLoaderEl . classList . add ( "s" ) ; this . spinnerLoaderEl . classList . add ( "s" ) ; this . loaderEl . appendChild ( this . leftLoaderEl ) ; this . loaderEl . appendChild ( this . rightLoaderEl ) ; this . loaderEl . appendChild ( this . spinnerLoaderEl ) ; this . toastEl . appendChild ( this . titleEl ) ; this . toastEl . appendChild ( this . messageEl ) ; this . toastEl . appendChild ( this . loaderEl ) ; this . toastEl . addEventListener ( "s" , this . onLeave ) ; this . toastEl . addEventListener ( "s" , this . onEnter ) ; this . toastEl . addEventListener ( "s" , this . onClick ) ; } onEnter = ( e ) => { const children = ( e . currentTarget as HTMLElement ) . children [ 0 ] . children ; for ( let i = 0 ; i < children . length ; i ++ ) { ( children [ i ] as HTMLElement ) . style . animationPlayState = "s" ; } this . isHovered = true ; } ; onLeave = ( e ) => { const children = ( e . currentTarget as HTMLElement ) . children [ 0 ] . children ; for ( let i = 0 ; i < children . length ; i ++ ) { ( children [ i ] as HTMLElement ) . style . animationPlayState = "s" ; } this . isHovered = false ; } ; detach = ( ) => { clearInterval ( this . intervalId ) ; delete FBToast . everyMessage [ this . message ] ; if ( this . isAttached ) { this . parent . removeChild ( this . toastEl ) ; this . isAttached = false ; } } ; onClick = ( e ) => { ( e . currentTarget as Element ) . classList . add ( "s" ) ; setTimeout ( this . detach , 0 ) ; } doPolling = ( ) => { if ( this . timeout <= 0 ) { this . toastEl . classList . add ( "s" ) ; } if ( this . isHovered ) { return ; } if ( this . timeout <= 0 ) { this . toastEl . classList . add ( "s" ) ; } this . timeout -= 0 ; if ( this . timeout <= 0 ) { this . detach ( ) ; } } ; run = ( ) => { this . parent . appendChild ( this . toastEl ) ; this . isAttached = true ; this . intervalId = setInterval ( this . doPolling , 0 ) as any ; } }	O O $any$ O O $complex$ O $any$ O O O O O O O O O O $HTMLDivElement$ O $Document$ O O O O O O O $HTMLHeadingElement$ O $Document$ O O O O O O O $HTMLDivElement$ O $Document$ O O O O O O O $HTMLDivElement$ O $Document$ O O O O O O O $HTMLDivElement$ O $Document$ O O O O O O O $HTMLDivElement$ O $Document$ O O O O O O O $HTMLDivElement$ O $Document$ O O O O O O O $number$ O O O O $number$ O O O O $boolean$ O O O O $string$ O O O O $boolean$ O O O O O O $Element$ O $string$ O $string$ O $string$ O O O O $string$ O $string$ O $complex$ O O O O O O O O $HTMLHeadingElement$ O $string$ O $string$ O O O $HTMLDivElement$ O $string$ O O O $string$ O O O $HTMLDivElement$ O $DOMTokenList$ O $void$ O O O O O O $HTMLDivElement$ O $DOMTokenList$ O $void$ O $string$ O O O O $HTMLHeadingElement$ O $DOMTokenList$ O $void$ O O O O O O $HTMLDivElement$ O $DOMTokenList$ O $void$ O O O O O O $HTMLDivElement$ O $DOMTokenList$ O $void$ O O O O O O $HTMLDivElement$ O $DOMTokenList$ O $void$ O O O O O O $HTMLDivElement$ O $DOMTokenList$ O $void$ O $string$ O O O O $HTMLDivElement$ O $DOMTokenList$ O $void$ O O O O O O $HTMLDivElement$ O $DOMTokenList$ O $void$ O O O O O O $HTMLDivElement$ O $T$ O O O $HTMLDivElement$ O O O O $HTMLDivElement$ O $T$ O O O $HTMLDivElement$ O O O O $HTMLDivElement$ O $T$ O O O $HTMLDivElement$ O O O O $HTMLDivElement$ O $T$ O O O $HTMLHeadingElement$ O O O O $HTMLDivElement$ O $T$ O O O $HTMLDivElement$ O O O O $HTMLDivElement$ O $T$ O O O $HTMLDivElement$ O O O O $HTMLDivElement$ O O O O O O O $void$ O O O O $HTMLDivElement$ O O O O O O O $void$ O O O O $HTMLDivElement$ O O O O O O O $void$ O O O $void$ O O $MouseEvent$ O O O O $HTMLCollection$ O O $MouseEvent$ O $EventTarget$ O $complex$ O O $HTMLCollection$ O O O O $HTMLCollection$ O O O O $number$ O O O $number$ O $HTMLCollection$ O $number$ O $number$ O O O O $HTMLCollection$ O $number$ O O $complex$ O O $CSSStyleDeclaration$ O $string$ O O O O O O $boolean$ O O O O O $void$ O O $MouseEvent$ O O O O $HTMLCollection$ O O $MouseEvent$ O $EventTarget$ O $complex$ O O $HTMLCollection$ O O O O $HTMLCollection$ O O O O $number$ O O O $number$ O $HTMLCollection$ O $number$ O $number$ O O O O $HTMLCollection$ O $number$ O O $complex$ O O $CSSStyleDeclaration$ O $string$ O O O O O O $boolean$ O O O O O $void$ O O O O O $void$ O O O $number$ O O O $any$ O $complex$ O O O $string$ O O O O O O $boolean$ O O O O $Element$ O $T$ O O O $HTMLDivElement$ O O O O $boolean$ O O O O O O $void$ O O $MouseEvent$ O O O O $MouseEvent$ O $EventTarget$ O $complex$ O O $DOMTokenList$ O $void$ O O O O $number$ O O O $void$ O O O O O $void$ O O O O O O O O O $number$ O O O O O O $HTMLDivElement$ O $DOMTokenList$ O $void$ O O O O O O O O O $boolean$ O O O O O O O O O $number$ O O O O O O $HTMLDivElement$ O $DOMTokenList$ O $void$ O O O O O O O $number$ O O O O O O O $number$ O O O O O O $void$ O O O O O O $void$ O O O O O O O $Element$ O $T$ O O O $HTMLDivElement$ O O O O $boolean$ O O O O O $number$ O $number$ O O O $void$ O O O O O O O O
import { FBToast } from "s" ; export const createToast = ( message , title , color ) => { const parent = document . querySelector ( "s" ) ; if ( ! parent ) { throw new Error ( "s" ) ; } const t = new FBToast ( parent , title , message , color ) ; t . run ( ) ; } ; export const createToastOnce = ( message , title , color , fallbackLogger = console . warn ) => { if ( FBToast . everyMessage [ message ] ) { fallbackLogger ( message ) ; } else { createToast ( message , title , color ) ; FBToast . everyMessage [ message ] = true ; } } ;	O O $any$ O O O O O O $void$ O O $string$ O $string$ O $string$ O O O O $Element$ O $Document$ O O O O O O O O O $Element$ O O O O $ErrorConstructor$ O O O O O O $FBToast$ O O $any$ O $Element$ O $string$ O $string$ O $string$ O O $FBToast$ O $void$ O O O O O O O $void$ O O $string$ O $string$ O $string$ O $void$ O $Console$ O $void$ O O O O O $any$ O $complex$ O $string$ O O O $void$ O $string$ O O O O O $void$ O $string$ O $string$ O $string$ O O $any$ O $complex$ O $string$ O O O O O O O
import { createToast , createToastOnce } from "s" ; import { t } from "s" ; export const warning = ( message , title = t ( "s" ) , color = "s" ) => { createToastOnce ( message , title , color , console . warn ) ; } ; export const error = ( message , title = t ( "s" ) , color = "s" ) => { createToastOnce ( message , title , color , console . error ) ; } ; export const success = ( message , title = t ( "s" ) , color = "s" ) => createToast ( message , title , color ) ; export const info = ( message , title = t ( "s" ) , color = "s" ) => createToast ( message , title , color ) ; export const busy = ( message , title = t ( "s" ) , color = "s" ) => createToast ( message , title , color ) ; export const fun = ( message , title = t ( "s" ) , color = "s" ) => createToast ( message , title , color ) ; export const init = ( ) => { const toastContainer = document . createElement ( "s" ) ; toastContainer . classList . add ( "s" ) ; document . body . appendChild ( toastContainer ) ; } ;	O O $void$ O $void$ O O O O O O $any$ O O O O O O $void$ O O $string$ O $any$ O $any$ O O O O $string$ O O O O O $void$ O $string$ O $any$ O $string$ O $Console$ O $void$ O O O O O O $void$ O O $string$ O $any$ O $any$ O O O O $string$ O O O O O $void$ O $string$ O $any$ O $string$ O $Console$ O $void$ O O O O O O $void$ O O $string$ O $any$ O $any$ O O O O $string$ O O O O $void$ O $string$ O $any$ O $string$ O O O O $void$ O O $string$ O $any$ O $any$ O O O O $string$ O O O O $void$ O $string$ O $any$ O $string$ O O O O $void$ O O $string$ O $any$ O $any$ O O O O $string$ O O O O $void$ O $string$ O $any$ O $string$ O O O O $void$ O O $string$ O $any$ O $any$ O O O O $string$ O O O O $void$ O $string$ O $any$ O $string$ O O O O $void$ O O O O O O $HTMLDivElement$ O $Document$ O O O O O O $HTMLDivElement$ O $DOMTokenList$ O $void$ O O O O $Document$ O $HTMLElement$ O $T$ O $HTMLDivElement$ O O O O
import { ResourceIndex } from "s" ; import { TaggedResource , SpecialStatus , TaggedWebcamFeed , TaggedCrop , TaggedRegimen , TaggedImage , TaggedLog , TaggedTool , TaggedFarmEvent , TaggedSequence , TaggedPoint , TaggedSensor , TaggedPeripheral , TaggedPinBinding , TaggedDiagnosticDump , TaggedSensorReading , TaggedSavedGarden , TaggedPlantTemplate , TaggedFarmwareEnv , TaggedFarmwareInstallation , TaggedAlert , TaggedPointGroup , } from "s" ; import { isTaggedResource , sanityCheck , } from "s" ; import { bail } from "s" ; import { error } from "s" ; import { assertUuid } from "s" ; import { joinKindAndId } from "s" ; import { findAll } from "s" ; const isSaved = < T extends TaggedResource > ( t : T ) => t . specialStatus === SpecialStatus . SAVED ; const uuidFinder = < T extends TaggedResource > ( r : T [ "s" ] ) => function findResource ( i , u ) : T { assertUuid ( r , u ) ; const result = i . references [ u ] ; if ( result && isTaggedResource ( result ) && sanityCheck ( result ) ) { return result as T ; } else { error ( "s" ) ; throw new Error ( `template` + JSON . stringify ( result ) ) ; } } ; export let findTool = uuidFinder < TaggedTool > ( "s" ) ; export let findSequence = uuidFinder < TaggedSequence > ( "s" ) ; export let findRegimen = uuidFinder < TaggedRegimen > ( "s" ) ; export let findFarmEvent = uuidFinder < TaggedFarmEvent > ( "s" ) ; export let findPoints = uuidFinder < TaggedPoint > ( "s" ) ; export let findPointGroup = uuidFinder < TaggedPoint > ( "s" ) ; export const selectAllCrops = ( i ) => findAll < TaggedCrop > ( i , "s" ) ; export const selectAllSavedGardens = ( i ) => findAll < TaggedSavedGarden > ( i , "s" ) ; export const selectAllPlantTemplates = ( i ) => findAll < TaggedPlantTemplate > ( i , "s" ) ; export const selectAllFarmEvents = ( i ) => findAll < TaggedFarmEvent > ( i , "s" ) ; export const selectAllImages = ( i ) => findAll < TaggedImage > ( i , "s" ) ; export const selectAllLogs = ( i ) => findAll < TaggedLog > ( i , "s" ) ; export const selectAllPeripherals = ( i ) => findAll < TaggedPeripheral > ( i , "s" ) ; export const selectAllPoints = ( i ) => findAll < TaggedPoint > ( i , "s" ) ; export const selectAllPointGroups = ( i ) => findAll < TaggedPointGroup > ( i , "s" ) ; export const selectAllActivePoints = ( input ) => selectAllPoints ( input ) . filter ( x => ! x . body . discarded_at ) ; export const selectAllDiagnosticDumps = ( i ) => findAll < TaggedDiagnosticDump > ( i , "s" ) ; export const selectAllFarmwareEnvs = ( i ) => findAll < TaggedFarmwareEnv > ( i , "s" ) ; export const selectAllFarmwareInstallations = ( i ) => findAll < TaggedFarmwareInstallation > ( i , "s" ) ; export const selectAllRegimens = ( i ) => findAll < TaggedRegimen > ( i , "s" ) ; export const selectAllSensors = ( i ) => findAll < TaggedSensor > ( i , "s" ) ; export const selectAllPinBindings = ( i ) => findAll < TaggedPinBinding > ( i , "s" ) ; export const selectAllSequences = ( i ) => findAll < TaggedSequence > ( i , "s" ) ; export const selectAllSensorReadings = ( i ) => findAll < TaggedSensorReading > ( i , "s" ) ; export const selectAllTools = ( i ) => findAll < TaggedTool > ( i , "s" ) ; export const selectAllSavedSensors = ( input ) => selectAllSensors ( input ) . filter ( isSaved ) ; export const selectAllWebcamFeeds = ( i ) => findAll < TaggedWebcamFeed > ( i , "s" ) ; export const selectAllSavedPeripherals = ( input ) => selectAllPeripherals ( input ) . filter ( isSaved ) ; export const selectAllAlerts = ( i ) => findAll < TaggedAlert > ( i , "s" ) ; export const findByKindAndId = < T extends TaggedResource > ( i , kind : T [ "s" ] , id : number | undefined ) : T => { const kni = joinKindAndId ( kind , id ) ; const uuid = i . byKindAndId [ kni ] || bail ( "s" + kni ) ; const resource = i . references [ uuid ] || bail ( "s" + uuid ) ; if ( resource . kind === kind ) { return resource as T ; } else { return bail ( "s" + uuid ) ; } } ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O $complex$ O O O O O O O $never$ O O O O O O $void$ O O O O O O $boolean$ O O O O O O $string$ O O O O O O $T[]$ O O O O O $boolean$ O O $any$ O $any$ O O $T$ O $any$ O O $T$ O $any$ O $any$ O $any$ O O $T$ O O $any$ O $any$ O O $T["kind"]$ O $any$ O O O O O O $T$ O $ResourceIndex$ O $string$ O O $any$ O $boolean$ O $T["kind"]$ O $string$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O O $any$ O $complex$ O $any$ O O $complex$ O $any$ O O O O $any$ O $any$ O O O O $void$ O O O O O O $ErrorConstructor$ O O O $JSON$ O $complex$ O $any$ O O O O O O O O $any$ O $T$ O $any$ O O O O O O O $any$ O $T$ O $any$ O O O O O O O $any$ O $T$ O $any$ O O O O O O O $any$ O $T$ O $any$ O O O O O O O $any$ O $T$ O $any$ O O O O O O O $any$ O $T$ O $any$ O O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $any[]$ O $ResourceIndex$ O O $complex$ O $any$ O O $any$ O $any$ O $any$ O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $any[]$ O $ResourceIndex$ O O $complex$ O $boolean$ O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $any[]$ O O $ResourceIndex$ O O $any[]$ O $ResourceIndex$ O O $complex$ O $boolean$ O O O O $any[]$ O O $ResourceIndex$ O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O $T$ O O $any$ O $any$ O O $ResourceIndex$ O $T["kind"]$ O $any$ O O O O $number$ O O O O O O $any$ O O O $string$ O $string$ O $T["kind"]$ O $number$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O $never$ O O O $string$ O O O $any$ O $ResourceIndex$ O $any$ O $any$ O O $never$ O O O $any$ O O O O $any$ O $any$ O $T["kind"]$ O O O $any$ O $any$ O O O O O $never$ O O O $any$ O O O O O
import { findAll } from "s" ; import { ResourceIndex } from "s" ; import { TaggedFbosConfig , TaggedWebAppConfig , TaggedFirmwareConfig } from "s" ; export const getFbosConfig = ( i ) : TaggedFbosConfig | undefined => findAll < TaggedFbosConfig > ( i , "s" ) [ 0 ] ; export const getWebAppConfig = ( i ) : TaggedWebAppConfig | undefined => findAll < TaggedWebAppConfig > ( i , "s" ) [ 0 ] ; export const getFirmwareConfig = ( i ) : TaggedFirmwareConfig | undefined => findAll < TaggedFirmwareConfig > ( i , "s" ) [ 0 ] ;	O O $T[]$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O $ResourceIndex$ O O $any$ O O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O O O O $any$ O O $ResourceIndex$ O O $any$ O O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O O O O $any$ O O $ResourceIndex$ O O $any$ O O O $T[]$ O $any$ O O $ResourceIndex$ O O O O O O O
import { BooleanConfigKey , NumberConfigKey } from "s" ; export const BooleanSetting < BooleanConfigKey , BooleanConfigKey > = { x_axis_inverted : "s" , y_axis_inverted : "s" , z_axis_inverted : "s" , scaled_encoders : "s" , raw_encoders : "s" , home_button_homing : "s" , show_motor_plot : "s" , legend_menu_open : "s" , show_plants : "s" , show_points : "s" , show_historic_points : "s" , show_spread : "s" , show_farmbot : "s" , show_images : "s" , show_sensor_readings : "s" , disable_animations : "s" , display_trail : "s" , encoder_figure : "s" , dynamic_map : "s" , xy_swap : "s" , confirm_plant_deletion : "s" , confirm_step_deletion : "s" , confirm_sequence_deletion : "s" , show_pins : "s" , expand_step_options : "s" , discard_unsaved_sequences : "s" , 0 : "s" , hide_webcam_widget : "s" , hide_sensors : "s" , enable_browser_speak : "s" , discard_unsaved : "s" , 0 : "s" , disable_emergency_unlock_confirmation : "s" , user_interface_read_only_mode : "s" , show_first_party_farmware : "s" , stub_config : "s" , } ; export const NumericSetting < NumberConfigKey , NumberConfigKey > = { assertion_log : "s" , success_log : "s" , busy_log : "s" , warn_log : "s" , error_log : "s" , info_log : "s" , fun_log : "s" , debug_log : "s" , zoom_level : "s" , map_size_x : "s" , map_size_y : "s" , bot_origin_quadrant : "s" , id : "s" , device_id : "s" , } ;	O O $any$ O $any$ O O O O O O $Record$ O $any$ O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $Record$ O $any$ O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O
import { TaggedResource , TaggedSequence , TaggedRegimen , TaggedFarmEvent , TaggedTool , } from "s" ; import { CowardlyDictionary } from "s" ; import { ResourceIndex , SlotWithTool } from "s" ; import { selectAllToolSlotPointers , maybeFindToolById } from "s" ; import { assertUuid } from "s" ; interface IndexLookupDictionary < T extends TaggedResource > extends CowardlyDictionary < T > { } interface Indexer < T extends TaggedResource > { ( index ) : IndexLookupDictionary < T > ; } interface MapperFn < T extends TaggedResource > { ( item : T ) : T | undefined ; } export const buildIndexer = < T extends TaggedResource > ( kind : T [ "s" ] , mapper ? < T > ) : Indexer < T > => { return function ( index , ) { const noop < T > = ( i ) => i ; const output < T > = { } ; const uuids = Object . keys ( index . byKind [ kind ] ) ; const m = mapper || noop ; uuids . map ( uuid => { assertUuid ( kind , uuid ) ; const resource = index . references [ uuid ] ; if ( resource && ( resource . kind === kind ) && resource . body . id && m ( resource as T ) ) { output [ resource . body . id ] = resource as T ; } } ) ; return output ; } ; } ; export const indexSequenceById = buildIndexer < TaggedSequence > ( "s" ) ; export const indexRegimenById = buildIndexer < TaggedRegimen > ( "s" ) ; export const indexFarmEventById = buildIndexer < TaggedFarmEvent > ( "s" ) ; export const indexByToolId = buildIndexer < TaggedTool > ( "s" ) ; export function joinToolsAndSlot ( index ) : SlotWithTool [ ] { return selectAllToolSlotPointers ( index ) . map ( function ( toolSlot ) { return { toolSlot , tool : maybeFindToolById ( index , toolSlot . body . tool_id ) } ; } ) ; }	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any[]$ O $any$ O O O O O O $boolean$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $ResourceIndex$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $T$ O $any$ O O $any$ O O O O O O $Indexer<T>$ O O $any$ O $any$ O O $T["kind"]$ O $any$ O O O O $MapperFn<T>$ $MapperFn$ O $any$ O O O $any$ O $any$ O O O O O O $ResourceIndex$ O O O O $MapperFn$ O $any$ O O O $T$ O O $T$ O O $CowardlyDictionary$ O $any$ O O O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $ResourceIndex$ O $complex$ O $T["kind"]$ O O O O $MapperFn<T>$ O $MapperFn<T>$ O $MapperFn<T>$ O $string[]$ O $U[]$ O $string$ O O $boolean$ O $T["kind"]$ O $string$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O O $any$ O O $any$ O $any$ O $T["kind"]$ O O $any$ O $any$ O $any$ O $MapperFn<T>$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $Indexer<any>$ O $Indexer<T>$ O $any$ O O O O O O O $Indexer<any>$ O $Indexer<T>$ O $any$ O O O O O O O $Indexer<any>$ O $Indexer<T>$ O $any$ O O O O O O O $Indexer<any>$ O $Indexer<T>$ O $any$ O O O O O O O $SlotWithTool[]$ O $ResourceIndex$ O O $any$ O O O O $any[]$ O $ResourceIndex$ O O $U[]$ O O O $any$ O O O O $any$ O $any$ O $any$ O $ResourceIndex$ O $any$ O $any$ O $any$ O O O O O O O
import { ResourceIndex } from "s" ; import { ResourceName , TaggedGenericPointer , TaggedPlantPointer , TaggedRegimen , TaggedResource , TaggedSequence , TaggedTool , TaggedToolSlotPointer , TaggedUser , TaggedDevice , } from "s" ; import { isTaggedPlantPointer , isTaggedGenericPointer , isTaggedRegimen , isTaggedSequence , isTaggedTool , isTaggedToolSlotPointer , sanityCheck , } from "s" ; import { betterCompact , bail } from "s" ; import { findAllById } from "s" ; import { findPoints , selectAllPoints , selectAllActivePoints } from "s" ; import { assertUuid } from "s" ; import { joinKindAndId } from "s" ; import { chain } from "s" ; import { getWebAppConfig } from "s" ; import { TimeSettings } from "s" ; import { BooleanSetting } from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export let maybeDetermineUuid = ( index , kind , id ) => { const kni = joinKindAndId ( kind , id ) ; const uuid = index . byKindAndId [ kni ] ; if ( uuid ) { assertUuid ( kind , uuid ) ; return uuid ; } } ; export let findId = ( index , kind , id ) => { const uuid = maybeDetermineUuid ( index , kind , id ) ; if ( uuid ) { return uuid ; } else { throw new Error ( "s" + id ) ; } } ; export let isKind = ( name ) => ( tr ) => tr . kind === name ; export function groupPointsByType ( index ) { return chain ( selectAllActivePoints ( index ) ) . tap ( x => x [ 0 ] . body . pointer_type ) . groupBy ( "s" ) . value ( ) ; } export function findPointerByTypeAndId ( index , pt , id ) { const pni = joinKindAndId ( "s" , id ) ; const uuid = "s" + index . byKindAndId [ pni ] ; const resource = index . references [ uuid ] ; if ( resource && resource . kind === "s" ) { return resource ; } else { throw new Error ( `template` ) ; } } export function selectAllGenericPointers ( index ) : TaggedGenericPointer [ ] { const genericPointers = selectAllPoints ( index ) . map ( p => isTaggedGenericPointer ( p ) ? p : undefined ) ; return betterCompact ( genericPointers ) ; } export function selectAllPlantPointers ( index ) : TaggedPlantPointer [ ] { const plantPointers = selectAllActivePoints ( index ) . map ( p => isTaggedPlantPointer ( p ) ? p : undefined ) ; return betterCompact ( plantPointers ) ; } export function selectAllToolSlotPointers ( index ) : TaggedToolSlotPointer [ ] { const toolSlotPointers = selectAllActivePoints ( index ) . map ( p => isTaggedToolSlotPointer ( p ) ? p : undefined ) ; return betterCompact ( toolSlotPointers ) ; } export function findToolSlot ( i , uuid ) { const ts = selectAllToolSlotPointers ( i ) . filter ( x => x . uuid === uuid ) [ 0 ] ; if ( ts ) { return ts ; } else { throw new Error ( "s" + uuid ) ; } } export function findPlant ( i , uuid ) { const point = findPoints ( i , uuid ) ; if ( point && sanityCheck ( point ) && point . body . pointer_type === "s" ) { return point as TaggedPlantPointer ; } else { throw new Error ( "s" ) ; } } export function selectCurrentToolSlot ( index , uuid ) { const x = index . references [ uuid ] ; if ( x && isTaggedToolSlotPointer ( x ) ) { return x ; } else { throw new Error ( "s" ) ; } } export function getRegimenByUUID ( index , uuid ) { assertUuid ( "s" , uuid ) ; return index . references [ uuid ] ; } export function getSequenceByUUID ( index , uuid ) { assertUuid ( "s" , uuid ) ; const result = index . references [ uuid ] ; if ( result && isTaggedSequence ( result ) ) { return result ; } else { throw new Error ( "s" ) ; } } export let currentToolInSlot = ( index ) => ( toolSlotUUID ) : TaggedTool | undefined => { const currentSlot = selectCurrentToolSlot ( index , toolSlotUUID ) ; if ( currentSlot && currentSlot . kind === "s" ) { const toolUUID = index . byKindAndId [ joinKindAndId ( "s" , currentSlot . body . tool_id ) ] ; const tool = index . references [ toolUUID || "s" ] ; if ( tool && isTaggedTool ( tool ) ) { return tool ; } } } ; export function toolsInUse ( index ) : TaggedTool [ ] { const ids = betterCompact ( selectAllToolSlotPointers ( index ) . map ( ts => ts . body . tool_id ) ) ; return findAllById ( index , ids , "s" ) as TaggedTool [ ] ; } export function maybeGetSequence ( index , uuid : string | undefined ) : TaggedSequence | undefined { if ( uuid ) { return getSequenceByUUID ( index , uuid ) ; } else { return undefined ; } } export function maybeGetRegimen ( index , uuid : string | undefined ) : TaggedRegimen | undefined { const tr = uuid && getRegimenByUUID ( index , uuid ) ; if ( tr && isTaggedRegimen ( tr ) ) { return tr ; } } export function maybeGetTimeOffset ( index ) { const dev = maybeGetDevice ( index ) ; return dev ? dev . body . tz_offset_hrs : 0 ; } export function 0 ( index ) { const conf = getWebAppConfig ( index ) ; return conf ? conf . body [ BooleanSetting . 0 ] : false ; } export function maybeGetTimeSettings ( index ) { return { utcOffset : maybeGetTimeOffset ( index ) , 0 : 0 ( index ) , } ; } export function maybeGetDevice ( index ) : TaggedDevice | undefined { const dev = index . references [ Object . keys ( index . byKind . Device ) [ 0 ] || "s" ] ; return ( dev && dev . kind === "s" ) ? dev : undefined ; } export const getDeviceAccountSettings = ( index ) : TaggedDevice => { const device = maybeGetDevice ( index ) ; switch ( Object . keys ( index . byKind . Device ) . length ) { case 0 : return bail ( `template` ) ; case 0 : return device ? device : bail ( "s" ) ; default : return bail ( "s" ) ; } } ; export function maybeFetchUser ( index ) : TaggedUser | undefined { const list = Object . keys ( index . byKind . User ) ; const uuid = list [ 0 ] ; const user = index . references [ uuid || - 0 ] ; if ( user && sanityCheck ( user ) && list . length > 0 ) { throw new Error ( "s" + list . length ) ; } if ( ( list . length === 0 ) && user && user . kind === "s" ) { return user ; } else { return undefined ; } } export function getUserAccountSettings ( index ) { const user = maybeFetchUser ( index ) ; if ( user ) { return user ; } else { throw new Error ( `template` ) ; } } export function all ( index ) { return betterCompact ( Object . keys ( index . all ) . map ( uuid => index . references [ uuid ] ) ) ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O $complex$ O O O O O O O $T[]$ O $never$ O O O O O O $any[]$ O O O O O O $any$ O $any[]$ O $any[]$ O O O O O O $boolean$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O O O O O O O O O O O O O O O O $any$ O O $ResourceIndex$ O $ResourceName$ O $number$ O O O O $string$ O $string$ O $any$ O $number$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O O $any$ O O $boolean$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O O $ResourceIndex$ O $ResourceName$ O $number$ O O O O $any$ O $any$ O $ResourceIndex$ O $any$ O $number$ O O O O $any$ O O O $any$ O O O O O O $ErrorConstructor$ O O O $number$ O O O O O O O $boolean$ O O $ResourceName$ O O O $TaggedResource$ O O $any$ O $any$ O $any$ O O O $any$ O $ResourceIndex$ O O O $any$ O $any[]$ O $ResourceIndex$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O O O O O O $any$ O $ResourceIndex$ O $string$ O $number$ O O O $string$ O $string$ O O O $number$ O O O $string$ O O O $ResourceIndex$ O $any$ O $string$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $ErrorConstructor$ O O O O O O O O $any[]$ O $ResourceIndex$ O O $any$ O O O O $any[]$ O $any[]$ O $ResourceIndex$ O O $U[]$ O $any$ O $complex$ O $any$ O O $any$ O $undefined$ O O O $T[]$ O $any[]$ O O O O O $any[]$ O $ResourceIndex$ O O $any$ O O O O $any[]$ O $any[]$ O $ResourceIndex$ O O $U[]$ O $any$ O $complex$ O $any$ O O $any$ O $undefined$ O O O $T[]$ O $any[]$ O O O O O $any[]$ O $ResourceIndex$ O O $any$ O O O O $any[]$ O $any[]$ O $ResourceIndex$ O O $U[]$ O $any$ O $complex$ O $any$ O O $any$ O $undefined$ O O O $T[]$ O $any[]$ O O O O O $TaggedToolSlotPointer$ O $ResourceIndex$ O $string$ O O O $any$ O $any[]$ O $ResourceIndex$ O O $complex$ O $any$ O $any$ O $any$ O $string$ O O O O O O O $any$ O O O $any$ O O O O O O $ErrorConstructor$ O O O $string$ O O O O O O $TaggedPlantPointer$ O $ResourceIndex$ O $string$ O O O $any$ O $any$ O $ResourceIndex$ O $string$ O O O O $any$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $ErrorConstructor$ O O O O O O O O $any$ O $ResourceIndex$ O $string$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O O $any$ O $complex$ O $any$ O O O O $any$ O O O O O O $ErrorConstructor$ O O O O O O O O $any$ O $ResourceIndex$ O $string$ O O $boolean$ O O O $string$ O O O $ResourceIndex$ O $any$ O $string$ O O O O O $TaggedSequence$ O $ResourceIndex$ O $string$ O O $boolean$ O O O $string$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O O $any$ O $complex$ O $any$ O O O O $any$ O O O O O O $ErrorConstructor$ O O O O O O O O $any$ O O $ResourceIndex$ O O O $string$ O O $any$ O O O O O $any$ O $any$ O $ResourceIndex$ O $string$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O O O O $any$ O $ResourceIndex$ O $any$ O $any$ O O O O O O $any$ O $complex$ O $any$ O O O O $any$ O O O O O O O $any[]$ O $ResourceIndex$ O O $any$ O O O O $any[]$ O $T[]$ O $any[]$ O $ResourceIndex$ O O $U[]$ O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O $ResourceIndex$ O $any[]$ O O O O $any$ O O O O O O $any$ O $ResourceIndex$ O $string$ O O O O O O $any$ O O O O O $string$ O O O $any$ O $ResourceIndex$ O $string$ O O O O O O $undefined$ O O O O O $any$ O $ResourceIndex$ O $string$ O O O O O O $any$ O O O O $any$ O $string$ O $any$ O $ResourceIndex$ O $string$ O O O O $any$ O $complex$ O $any$ O O O O $any$ O O O O O $number$ O $ResourceIndex$ O O O $any$ O $any$ O $ResourceIndex$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O $boolean$ O $ResourceIndex$ O O O $any$ O $any$ O $ResourceIndex$ O O O $any$ O $any$ O $any$ O $complex$ O $any$ O O O O O O O $TimeSettings$ O $ResourceIndex$ O O O O $number$ O $number$ O $ResourceIndex$ O O $boolean$ O $boolean$ O $ResourceIndex$ O O O O O O O $any$ O $ResourceIndex$ O O $any$ O O O O $any$ O $ResourceIndex$ O $any$ O $ObjectConstructor$ O $complex$ O $ResourceIndex$ O $complex$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O O O $any$ O O $ResourceIndex$ O O $any$ O O O $any$ O $any$ O $ResourceIndex$ O O O O $ObjectConstructor$ O $complex$ O $ResourceIndex$ O $complex$ O $any$ O O $number$ O O O O O O $never$ O O O O O O O O $any$ O $any$ O $never$ O O O O O O O $never$ O O O O O O O O O $any$ O $ResourceIndex$ O O $any$ O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $ResourceIndex$ O $complex$ O $any$ O O O $string$ O $string[]$ O O O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O O O O O $any$ O $complex$ O $any$ O O $string[]$ O $number$ O O O O O O $ErrorConstructor$ O O O $string[]$ O $number$ O O O O O O $string[]$ O $number$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $undefined$ O O O O O $TaggedUser$ O $ResourceIndex$ O O O $any$ O $any$ O $ResourceIndex$ O O O O $any$ O O O $any$ O O O O O O $ErrorConstructor$ O O O O O O O O $any[]$ O $ResourceIndex$ O O O $T[]$ O $ObjectConstructor$ O $complex$ O $ResourceIndex$ O $complex$ O O $U[]$ O $string$ O $ResourceIndex$ O $any$ O $string$ O O O O O
import { ResourceIndex } from "s" ; import { selectAllToolSlotPointers , selectAllActivePoints , maybeFindToolById , selectAllPointGroups , } from "s" ; import { betterCompact } from "s" ; import { TaggedTool , TaggedPoint , TaggedToolSlotPointer , Xyz , 0 , TaggedPointGroup } from "s" ; import { DropDownItem } from "s" ; import { capitalize , isNumber } from "s" ; import { Point } from "s" ; import { t } from "s" ; const TOOL : "s" = "s" ; export function activeToolDDIs ( resources ) : DropDownItem [ ] { const slots = selectAllToolSlotPointers ( resources ) ; return betterCompact ( slots . map ( slot => { const tool = maybeFindToolById ( resources , slot . body . tool_id ) ; if ( tool ) { return formatTool ( tool , slot ) ; } } ) ) . filter ( x => parseInt ( "s" + x . value ) > 0 ) ; } type PointerTypeName = Point [ "s" ] ; type DropdownHeadingId = | PointerTypeName | typeof TOOL | "s" | "s" ; export const NAME_MAP < DropdownHeadingId , string > = { "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , } ; const heading = ( name ) : DropDownItem [ ] => ( [ { label : t ( NAME_MAP [ name ] ) , heading : true , value : 0 , headingId : name } ] ) ; const 0 = ( points : TaggedPoint [ ] , pointerType ) => points . filter ( x => x . body . pointer_type === pointerType ) . map ( formatPoint ) . filter ( x => parseInt ( "s" + x . value ) > 0 ) ; export const 0 = ( groups : TaggedPointGroup [ ] ) : DropDownItem [ ] => { return groups . filter ( x => x . body . id ) . map ( x => { return { label : x . body . name , value : "s" + x . body . id , headingId : "s" } ; } ) ; } ; export function locationFormList ( resources , additionalItems : DropDownItem [ ] , displayGroups ? ) : DropDownItem [ ] { const points = selectAllActivePoints ( resources ) . filter ( x => x . body . pointer_type !== "s" ) ; const plantDDI = 0 ( points , "s" ) ; const genericPointerDDI = 0 ( points , "s" ) ; const toolDDI = activeToolDDIs ( resources ) ; const output = [ COORDINATE_DDI ( ) ] . concat ( additionalItems ) . concat ( heading ( "s" ) ) . concat ( toolDDI ) . concat ( heading ( "s" ) ) . concat ( plantDDI ) . concat ( heading ( "s" ) ) . concat ( genericPointerDDI ) ; if ( displayGroups ) { return output . concat ( heading ( "s" ) ) . concat ( 0 ( selectAllPointGroups ( resources ) ) ) ; } else { return output ; } } export const formatPoint = ( p ) : DropDownItem => { const { id , name , pointer_type , x , y , z } = p . body ; return { label : dropDownName ( name , { x , y , z } ) , value : "s" + id , headingId : pointer_type } ; } ; export const formatTool = ( tool , slot : TaggedToolSlotPointer | undefined ) : DropDownItem => { const { id , name } = tool . body ; const coordinate = slot ? { x : slot . body . gantry_mounted ? undefined : slot . body . x , y : slot . body . y , z : slot . body . z } : undefined ; return { label : dropDownName ( ( name || "s" ) , coordinate ) , value : "s" + id , headingId : TOOL } ; } ; export function dropDownName ( name , v ? < Xyz , number | undefined > ) { let label = name || "s" ; if ( v ) { const labelFor = ( axis : number | undefined ) => isNumber ( axis ) ? axis : "s" ; label += `template` ; } return capitalize ( label ) ; } export const ALL_POINT_LABELS = { "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , } ; export type EveryPointType = keyof typeof ALL_POINT_LABELS ; export const COORDINATE_DDI = ( vector ? ) : DropDownItem => ( { label : vector ? `template` : t ( "s" ) , value : vector ? JSON . stringify ( vector ) : "s" , headingId : "s" } ) ; export const NO_VALUE_SELECTED_DDI = ( ) : DropDownItem => ( { label : t ( "s" ) , value : "s" , isNull : true } ) ;	O O $any$ O O O O O O $any[]$ O $any[]$ O $any$ O $any[]$ O O O O O O O $T[]$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O $DropDownItem[]$ O $ResourceIndex$ O O $any$ O O O O $any[]$ O $any[]$ O $ResourceIndex$ O O O $T[]$ O $any[]$ O $U[]$ O $any$ O O O $any$ O $any$ O $ResourceIndex$ O $any$ O $any$ O $any$ O O O O $any$ O O O $DropDownItem$ O $any$ O $any$ O O O O O O O $complex$ O $DropDownItem$ O $number$ O O O $DropDownItem$ O $complex$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O O O O $Record$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DropDownItem[]$ O O $DropdownHeadingId$ O O $any$ O O O O O O $any$ O $any$ O $complex$ O $any$ O O O $true$ O O O $number$ O O O $any$ O $any$ O O O O O $DropDownItem[]$ O O $any[]$ O $any$ O O O $PointerTypeName$ O O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $U[]$ O $DropDownItem$ O O $complex$ O $DropDownItem$ O $number$ O O O $DropDownItem$ O $complex$ O O O O O O O $DropDownItem[]$ O O $any[]$ O $any$ O O O O $any$ O O O O O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O $U[]$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O O O O O O O O O $DropDownItem[]$ O $ResourceIndex$ O $DropDownItem[]$ O $any$ O O O $boolean$ $boolean$ O O $any$ O O O O $any[]$ O $any[]$ O $ResourceIndex$ O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O $DropDownItem[]$ O $DropDownItem[]$ O $any[]$ O O O O O $DropDownItem[]$ O $DropDownItem[]$ O $any[]$ O O O O O $DropDownItem[]$ O $DropDownItem[]$ O $ResourceIndex$ O O O $DropDownItem[]$ O O $DropDownItem$ O O O O $complex$ O $DropDownItem[]$ O O $complex$ O $DropDownItem[]$ O O O O O $complex$ O $DropDownItem[]$ O O $complex$ O $DropDownItem[]$ O O O O O $complex$ O $DropDownItem[]$ O O $complex$ O $DropDownItem[]$ O O O O O $complex$ O $DropDownItem[]$ O O O O $boolean$ O O O $DropDownItem[]$ O $complex$ O $DropDownItem[]$ O O O O O $complex$ O $DropDownItem[]$ O $any[]$ O $ResourceIndex$ O O O O O O O O $DropDownItem[]$ O O O O O $DropDownItem$ O O $TaggedPoint$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O $any$ O O O O O O $DropDownItem$ O O $TaggedTool$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $complex$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $undefined$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O O O $any$ O $any$ O O $any$ O O O O $complex$ O O $string$ O O O $any$ O O O O O O O O O O $any$ O $string$ O $complex$ $Record$ O $any$ O O O O O O O O $string$ O $string$ O O O O O $complex$ O O O $complex$ O O $number$ O O O O O O $any$ O $number$ O O $number$ O O O $string$ O O O O O $any$ O $string$ O O O O O $complex$ O O O O O O O O O O O O O O O O O O O O O O $any$ O O O $complex$ O O O $DropDownItem$ O O $any$ $Vector3$ O O $any$ O O O $any$ O $any$ O O O $any$ O O O O $string$ O $any$ O $JSON$ O $complex$ O $any$ O O O O $string$ O O O O O O O $DropDownItem$ O O O O $any$ O O O $any$ O $any$ O O O O $string$ O O O $true$ O O O O O
import { VariableNameSet , ResourceIndex , UUID } from "s" ; import { TaggedSequence , 0 , ScopeDeclarationBodyItem , } from "s" ; import { DropDownItem } from "s" ; import { findPointerByTypeAndId , findPointGroup } from "s" ; import { findSlotByToolId , findToolById , findResourceById } from "s" ; import { formatPoint , NO_VALUE_SELECTED_DDI , formatTool , COORDINATE_DDI } from "s" ; import { VariableNode } from "s" ; import { t } from "s" ; export interface SequenceMeta { celeryNode : VariableNode ; dropdown : DropDownItem ; vector : 0 | undefined ; default ? : boolean ; } export const determineVector = ( node , resources , uuid ? ) : 0 | undefined => { if ( node . kind == "s" ) { return undefined ; } const variableContents = node . args . data_value ; switch ( variableContents . kind ) { case "s" : return variableContents . args ; case "s" : const { pointer_type , pointer_id } = variableContents . args ; return findPointerByTypeAndId ( resources , pointer_type , pointer_id ) . body ; case "s" : const ts = findSlotByToolId ( resources , variableContents . args . tool_id ) ; return ts ? ts . body : undefined ; case "s" : const variable = maybeFindVariable ( node . args . label , resources , uuid ) ; return variable && variable . vector ; } return undefined ; } ; const maybeFindVariable = ( label , resources , uuid ? ) : SequenceMeta | undefined => uuid ? findVariableByName ( resources , uuid , label ) : undefined ; export const withPrefix = ( label ) => `template` ; interface DetermineVarDDILabelProps { label : string ; resources : ResourceIndex ; uuid ? : UUID ; forceExternal ? : boolean ; } export const determineVarDDILabel = ( { label , resources , uuid , forceExternal } ) : string => { if ( forceExternal ) { return t ( "s" ) ; } const variable = maybeFindVariable ( label , resources , uuid ) ; if ( variable ) { if ( variable . celeryNode . kind === "s" ) { return withPrefix ( t ( "s" ) ) ; } if ( variable . celeryNode . kind !== "s" ) { return withPrefix ( t ( "s" ) ) ; } return withPrefix ( variable . dropdown . label ) ; } return withPrefix ( t ( "s" ) ) ; } ; export const determineDropdown = ( node , resources , uuid ? ) : DropDownItem => { if ( node . kind === "s" ) { return { label : t ( "s" ) , value : "s" } ; } const { data_value } = node . args ; switch ( data_value . kind ) { case "s" : return COORDINATE_DDI ( data_value . args ) ; case "s" : const { label } = data_value . args ; const varName = determineVarDDILabel ( { label , resources , uuid } ) ; return { label : varName , value : "s" } ; case "s" : const { pointer_id , pointer_type } = data_value . args ; const pointer = findPointerByTypeAndId ( resources , pointer_type , pointer_id ) ; return formatPoint ( pointer ) ; case "s" : const { tool_id } = data_value . args ; const toolSlot = findSlotByToolId ( resources , tool_id ) ; return formatTool ( findToolById ( resources , tool_id ) , toolSlot ) ; case "s" : const value = data_value . args . point_group_id ; const 0 = findResourceById ( resources , "s" , value ) ; const group = findPointGroup ( resources , 0 ) ; return { label : group . body . name , value } ; case "s" as unknown : return NO_VALUE_SELECTED_DDI ( ) ; } throw new Error ( "s" ) ; } ; export const determineEditable = ( node ) : boolean => { return node . kind !== "s" && node . args . data_value . kind == "s" ; } ; export const createSequenceMeta = ( resources , sequence ) : VariableNameSet => { const collection = sequence . body . args . locals . body || [ ] ; const reducer = ( acc , celeryNode ) : VariableNameSet => ( { ... acc , [ celeryNode . args . label ] : { celeryNode , vector : determineVector ( celeryNode , resources , sequence . uuid ) , dropdown : determineDropdown ( celeryNode , resources , sequence . uuid ) , } } ) ; return collection . reduce ( reducer , { } ) ; } ; export const findVariableByName = ( i , uuid , label ) : SequenceMeta | undefined => { return ( i . sequenceMetas [ uuid ] || { } ) [ label ] ; } ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $DropDownItem$ O $DropDownItem$ O $DropDownItem$ O $DropDownItem$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $DropDownItem$ O $any$ O $any$ O $any$ O O O $boolean$ O O O O O O O $any$ O O $VariableNode$ O $ResourceIndex$ O $string$ $UUID$ O O $any$ O O O O O O $any$ O $any$ O O O O O $undefined$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $ResourceIndex$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $ResourceIndex$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $undefined$ O O O O O $SequenceMeta$ O $SequenceMeta$ O $any$ O $any$ O $any$ O $ResourceIndex$ O $string$ O O O $SequenceMeta$ O $SequenceMeta$ O $any$ O O O $undefined$ O O O O $SequenceMeta$ O O $string$ O $ResourceIndex$ O $string$ $UUID$ O O $any$ O O O $string$ O $SequenceMeta$ O $ResourceIndex$ O $string$ O $string$ O O $undefined$ O O O $string$ O O $string$ O O O O O $any$ O $string$ O O O $ResourceIndex$ O $any$ O $string$ O O $any$ O $boolean$ O O O O O O O $string$ O O O $string$ O $ResourceIndex$ O $string$ O $boolean$ $DetermineVarDDILabelProps$ O O O O O O O $boolean$ O O O $any$ O O O O O O $SequenceMeta$ O $SequenceMeta$ O $string$ O $ResourceIndex$ O $string$ O O O O $SequenceMeta$ O O O O $SequenceMeta$ O $any$ O $any$ O O O O O $string$ O $any$ O O O O O O O O $SequenceMeta$ O $any$ O $any$ O O O O O $string$ O $any$ O O O O O O O $string$ O $SequenceMeta$ O $DropDownItem$ O $string$ O O O O $string$ O $any$ O O O O O O O O O $DropDownItem$ O O $VariableNode$ O $ResourceIndex$ O $string$ $UUID$ O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $string$ O O O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O $DropDownItem$ O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $string$ O $string$ O O $any$ O $ResourceIndex$ O $string$ O O O O O $string$ O $string$ O $string$ O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $ResourceIndex$ O $any$ O $any$ O O O $DropDownItem$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $ResourceIndex$ O $any$ O O O $DropDownItem$ O $any$ O $ResourceIndex$ O $any$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $ResourceIndex$ O O O $any$ O O O $any$ O $any$ O $ResourceIndex$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $DropDownItem$ O O O O O O $ErrorConstructor$ O O O O O O O O $boolean$ O O $VariableNode$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O O $ResourceIndex$ O $TaggedSequence$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O O $VariableNameSet$ O $ScopeDeclarationBodyItem$ O O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $ResourceIndex$ O $any$ O $any$ O O $DropDownItem$ O $DropDownItem$ O $any$ O $ResourceIndex$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $complex$ O O O O O O O O O $SequenceMeta$ O O $ResourceIndex$ O $string$ O $string$ O O $any$ O O O O O O $ResourceIndex$ O $complex$ O $string$ O O O O O O $string$ O O O O
import { ParameterDeclaration , VariableDeclaration , ParameterApplication } from "s" ; import { ResourceIndex , VariableNameSet , UUID } from "s" ; import { SequenceMeta } from "s" ; import { ShouldDisplay } from "s" ; export type VariableNode = ParameterDeclaration | VariableDeclaration | ParameterApplication ; type OnChange = ( sd : VariableNode | undefined ) => void ; export enum AllowedVariableNodes { identifier , parameter , variable , } interface CommonProps { sequenceUuid : UUID ; resources : ResourceIndex ; shouldDisplay : ShouldDisplay ; onChange : OnChange ; bodyVariables ? : VariableNode [ ] ; locationDropdownKey ? : string ; allowedVariableNodes : AllowedVariableNodes ; disallowGroups ? : boolean ; collapsible ? : boolean ; collapsed ? : boolean ; toggleVarShow ? : ( ) => void ; } export interface LocalsListProps extends CommonProps { variableData : VariableNameSet | undefined ; } export interface LocationFormProps extends CommonProps { variable : SequenceMeta ; width ? : number ; hideVariableLabel ? : boolean ; hideTypeLabel ? : boolean ; hideHeader ? : boolean ; } export const PARENT = ( label ) => ( { value : "s" , label , headingId : "s" } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $AllowedVariableNodes.identifier$ O $AllowedVariableNodes.parameter$ O $AllowedVariableNodes.variable$ O O O $any$ O $string$ O $any$ O $ResourceIndex$ O $any$ O $ShouldDisplay$ O $any$ O $OnChange$ O $any$ O $any[]$ O O $any$ O O O $string$ O O O O $AllowedVariableNodes$ O $any$ O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O $void$ O O O O O O O O O O $any$ O $any$ O $complex$ O $any$ O O O O O O $any$ O $any$ O $SequenceMeta$ O $any$ O $number$ O O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O O O O $complex$ O O $string$ O O O O $string$ O O O $string$ O $string$ O O O O O
import { DropDownItem } from "s" ; import { Coordinate , ScopeDeclaration , ParameterApplication , Dictionary , Identifier , Point , Tool , ScopeDeclarationBodyItem , VariableDeclaration , PointGroup , } from "s" ; import { VariableNode , AllowedVariableNodes } from "s" ; import { betterCompact } from "s" ; export const NOTHING_SELECTED = { kind : "s" , args : { } } ; type DataValue = | Coordinate | Identifier | Point | PointGroup | Tool ; type CreateVariableDeclaration = ( label , data_value ) => VariableDeclaration ; type CreateParameterApplication = ( label , data_value ) => ParameterApplication ; type VariableWithAValue = VariableDeclaration | ParameterApplication ; const createVariableNode = ( allowedNodes ) : CreateParameterApplication | CreateVariableDeclaration => allowedNodes == AllowedVariableNodes . parameter ? createVariableDeclaration : createParameterApplication ; const createParameterApplication = ( label , data_value ) : ParameterApplication => ( { kind : "s" , args : { label , data_value } } ) ; const createVariableDeclaration = ( label , data_value ) : VariableDeclaration => ( { kind : "s" , args : { label , data_value } } ) ; interface NewVarProps { identifierLabel : string ; allowedVariableNodes : AllowedVariableNodes ; dropdown : DropDownItem ; newVarLabel ? : string ; } const nothingVar = ( { identifierLabel : label , allowedVariableNodes } ) : VariableWithAValue => createVariableNode ( allowedVariableNodes ) ( label , NOTHING_SELECTED ) ; const toolVar = ( value : string | number ) => ( { identifierLabel : label , allowedVariableNodes } ) : VariableWithAValue => createVariableNode ( allowedVariableNodes ) ( label , { kind : "s" , args : { tool_id : parseInt ( "s" + value ) } } ) ; const pointVar = ( pointer_type : "s" | "s" , value : string | number ) => ( { identifierLabel : label , allowedVariableNodes } ) : VariableWithAValue => createVariableNode ( allowedVariableNodes ) ( label , { kind : "s" , args : { pointer_type , pointer_id : parseInt ( "s" + value ) } } ) ; const manualEntry = ( value : string | number ) => ( { identifierLabel : label , allowedVariableNodes } ) : VariableWithAValue => createVariableNode ( allowedVariableNodes ) ( label , { kind : "s" , args : value ? JSON . parse ( "s" + value ) : { x : 0 , y : 0 , z : 0 } } ) ; export const newParameter = ( p ) : VariableNode => { const { identifierLabel : label , newVarLabel , allowedVariableNodes } = p ; if ( allowedVariableNodes === AllowedVariableNodes . identifier && newVarLabel ) { return createParameterApplication ( label , { kind : "s" , args : { label : newVarLabel } } ) ; } else { return { kind : "s" , args : { label , default_value : NOTHING_SELECTED } } ; } } ; const createNewVariable = ( props ) : VariableNode | undefined => { const ddi = props . dropdown ; if ( ddi . isNull ) { return nothingVar ( props ) ; } switch ( ddi . headingId ) { case "s" : case "s" : return pointVar ( ddi . headingId , ddi . value ) ( props ) ; case "s" : return toolVar ( ddi . value ) ( props ) ; case "s" : return newParameter ( props ) ; case "s" : return manualEntry ( ddi . value ) ( props ) ; case "s" : const point_group_id = parseInt ( "s" + ddi . value , 0 ) ; return { kind : "s" , args : { label : props . identifierLabel , data_value : { kind : "s" , args : { point_group_id } } } } ; } console . error ( "s" + ( ddi . headingId || "s" ) ) ; return undefined ; } ; export const convertDDItoVariable = ( p ) => { if ( p . dropdown . headingId === "s" ) { return createNewVariable ( { ... p , newVarLabel : "s" + p . dropdown . value } ) ; } else { return createNewVariable ( { ... p , newVarLabel : undefined } ) ; } } ; export const isScopeDeclarationBodyItem = ( x ) : x is ScopeDeclarationBodyItem => x . kind === "s" || x . kind === "s" ; export const addOrEditBodyVariables = ( bodyVariables : VariableNode [ ] , updatedItem ) : ScopeDeclarationBodyItem [ ] => { const filteredVariables : ScopeDeclarationBodyItem [ ] = betterCompact ( bodyVariables . map ( v => isScopeDeclarationBodyItem ( v ) ? v : undefined ) ) ; const items = reduceScopeDeclaration ( filteredVariables ) ; items [ updatedItem . args . label ] = updatedItem ; return Object . values ( items ) ; } ; export const addOrEditDeclarationLocals = ( declarations : ScopeDeclarationBodyItem [ ] , updatedItem ) : ScopeDeclaration => { const updatedDeclarations = addOrEditBodyVariables ( declarations , updatedItem ) ; const newLocals = { kind : "s" , args : { } , body : Object . values ( updatedDeclarations ) } ; return newLocals ; } ; const reduceScopeDeclaration = ( declarations : ScopeDeclarationBodyItem [ ] ) : Dictionary < ScopeDeclarationBodyItem > => { const items < ScopeDeclarationBodyItem > = { } ; declarations . map ( d => items [ d . args . label ] = d ) ; return items ; } ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $T[]$ O O O O O O $any$ O O $string$ O O O ${}$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $string$ O $DataValue$ O O $any$ O O $any$ O O $string$ O $DataValue$ O O $any$ O O $any$ O $any$ O $any$ O O $complex$ O O $AllowedVariableNodes$ O O $any$ O $any$ O $AllowedVariableNodes$ O $any$ O $AllowedVariableNodes.parameter$ O $any$ O $any$ O O $any$ O O $string$ O $DataValue$ O O $any$ O O O $string$ O O O $complex$ O O $string$ O $any$ O O O O O $any$ O O $string$ O $DataValue$ O O $any$ O O O $string$ O O O $complex$ O O $string$ O $any$ O O O O O $any$ O $string$ O O O $AllowedVariableNodes$ O $any$ O $DropDownItem$ O $any$ O $string$ O O O O O O $any$ O O O $string$ O $string$ O $AllowedVariableNodes$ $NewVarProps$ O O $any$ O $complex$ O $AllowedVariableNodes$ O O $string$ O $any$ O O O $any$ O O $complex$ O O O O O O O O $string$ O $string$ O $AllowedVariableNodes$ $NewVarProps$ O O $any$ O $complex$ O $AllowedVariableNodes$ O O $string$ O O $string$ O O O $complex$ O O $number$ O $number$ O O O $complex$ O O O O O O $any$ O O O O O O O O $complex$ O O O O O O O O $string$ O $string$ O $AllowedVariableNodes$ $NewVarProps$ O O $any$ O $complex$ O $AllowedVariableNodes$ O O $string$ O O $string$ O O O $complex$ O O O O $number$ O $number$ O O O $complex$ O O O O O O $any$ O O $complex$ O O O O O O O O $string$ O $string$ O $AllowedVariableNodes$ $NewVarProps$ O O $any$ O $complex$ O $AllowedVariableNodes$ O O $string$ O O $string$ O O O $any$ O $complex$ O $JSON$ O $any$ O O O $complex$ O O O $number$ O O O $number$ O O O $number$ O O O O O O O O $any$ O O $NewVarProps$ O O $any$ O O O O $string$ O $string$ O $string$ O $AllowedVariableNodes$ O O $NewVarProps$ O O O $AllowedVariableNodes$ O $any$ O $AllowedVariableNodes.identifier$ O $string$ O O O $any$ O $string$ O O $string$ O O O $complex$ O O $string$ O $string$ O O O O O O O O O $string$ O O O $complex$ O O $string$ O $any$ O $any$ O O O O O O O $any$ O O $NewVarProps$ O O $any$ O O O O O $DropDownItem$ O $NewVarProps$ O $DropDownItem$ O O O $DropDownItem$ O $true$ O O O $any$ O $NewVarProps$ O O O O O $DropDownItem$ O $string$ O O O O O O O O O $any$ O $DropDownItem$ O O O $DropDownItem$ O $complex$ O O $NewVarProps$ O O O O O O $any$ O $DropDownItem$ O $complex$ O O $NewVarProps$ O O O O O O $any$ O $NewVarProps$ O O O O O O $any$ O $DropDownItem$ O $complex$ O O $NewVarProps$ O O O O O O $number$ O $number$ O O O $DropDownItem$ O $complex$ O O O O O O $string$ O O O $complex$ O O $string$ O $NewVarProps$ O $string$ O $complex$ O O $string$ O O O $complex$ O O $number$ O O O O O O $Console$ O $void$ O O O O $DropDownItem$ O $string$ O O O O O O $undefined$ O O O O O $any$ O O $NewVarProps$ O O O O O $NewVarProps$ O $DropDownItem$ O $string$ O O O O O $any$ O O O $NewVarProps$ O $string$ O O O $NewVarProps$ O $DropDownItem$ O $complex$ O O O O O O O $any$ O O O $NewVarProps$ O $undefined$ O $undefined$ O O O O O O O O $complex$ O O $VariableNode$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any[]$ O O $any[]$ O $any$ O O O $ScopeDeclarationBodyItem$ O O $any$ O O O O O $any[]$ O $any$ O O O $T[]$ O $any[]$ O $U[]$ O $any$ O $complex$ O $any$ O O $any$ O $undefined$ O O O O $any$ O $any$ O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $ObjectConstructor$ O $complex$ O $any$ O O O O O O $any$ O O $any[]$ O $any$ O O O $ScopeDeclarationBodyItem$ O O $any$ O O O $any[]$ O $any[]$ O $any[]$ O $any$ O O O $ScopeDeclaration$ O O $string$ O O O ${}$ O O O O $any[]$ O $ObjectConstructor$ O $complex$ O $any[]$ O O O O $any$ O O O O $any$ O O $any[]$ O $any$ O O O O $any$ O $any$ O O O O $Dictionary$ O $any$ O O O O O $any[]$ O $U[]$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O
import { get , uniq } from "s" ; import { Dictionary , Identifier , ScopeDeclarationBodyItem , VariableDeclaration , Execute } from "s" ; import { SequenceResource as Sequence } from "s" ; import { maybeTagStep } from "s" ; import { NOTHING_SELECTED } from "s" ; type Args = Dictionary < Traversable | unknown > ; type Body = Traversable [ ] | undefined ; export interface Traversable { kind : string ; args : Args ; body ? : Body ; } type TreeClimberCB = ( item ) => void ; type InterestingNodes = Identifier | Execute ; const ARGS : keyof InterestingNodes = "s" ; const KIND : keyof InterestingNodes = "s" ; const IDENTIFIER : Identifier [ "s" ] = "s" ; const EXECUTE : Execute [ "s" ] = "s" ; const OBJECT = "s" ; const STRING = "s" ; const isTraversable = ( x ) : x is Traversable => { const hasKind = typeof get ( x , KIND , - 0 ) == STRING ; const hasArgs = typeof get ( x , ARGS , - 0 ) == OBJECT ; return hasKind && hasArgs ; } ; const isIdentifier = ( x ) : x is Identifier => ( x . kind === IDENTIFIER ) ; const isExecute = ( x ) : x is Execute => { return ! ! ( ( x . kind === EXECUTE ) && ( x as Execute ) . args . sequence_id ) ; } ; const newVar = ( label ) : VariableDeclaration => ( { kind : "s" , args : { label , data_value : NOTHING_SELECTED } } ) ; function climb ( t : Traversable | unknown , cb ) { const climbArgs = ( a ) => Object . keys ( a ) . map ( arg => climb ( a [ arg ] , cb ) ) ; const climbBody = ( body = [ ] ) => body . map ( item => climb ( item , cb ) ) ; if ( isTraversable ( t ) ) { t . body = t . body || [ ] ; climbArgs ( t . args ) ; climbBody ( t . body ) ; cb ( t ) ; } } interface SanitizationResult { thisSequence : Sequence ; callsTheseSequences : number [ ] ; } export const sanitizeNodes = ( thisSequence ) : SanitizationResult => { const declared < ScopeDeclarationBodyItem > = { } ; ( thisSequence . args . locals . body || [ ] ) . map ( var_ => declared [ var_ . args . label ] = var_ ) ; const { id } = thisSequence ; const used < Identifier > = { } ; const collectUniqVariables = ( _id ) => used [ _id . args . label ] = _id ; const idList : number [ ] = [ ] ; climb ( thisSequence , node => { maybeTagStep ( node ) ; isIdentifier ( node ) && collectUniqVariables ( node ) ; if ( isExecute ( node ) ) { const { sequence_id } = node . args ; ( sequence_id != id ) && idList . push ( sequence_id ) ; } } ) ; thisSequence . args . locals . body = Object . values ( used ) . map ( ( { args } ) => declared [ args . label ] || newVar ( args . label ) ) . map ( node => { maybeTagStep ( node ) ; return node ; } ) ; return { thisSequence , callsTheseSequences : uniq ( idList ) } ; } ;	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $Traversable$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O $string$ O O O $any$ O $any$ O $Traversable[]$ O O $any$ O O O $any$ O O $Traversable$ O O O O O $any$ O $any$ O $any$ O O $complex$ O O $any$ O O O O $complex$ O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O $complex$ O O $unknown$ O O $unknown$ O $any$ O O O $boolean$ O O $any$ O $unknown$ O $string$ O O O O O O O O $boolean$ O O $any$ O $unknown$ O $string$ O O O O O O O O $boolean$ O $boolean$ O O O O $complex$ O O $Traversable$ O O $Traversable$ O $any$ O O $Traversable$ O $string$ O $any$ O O O $complex$ O O $Traversable$ O O $Traversable$ O $any$ O O O O O O O $Traversable$ O $string$ O $any$ O O O $Traversable$ O $any$ O O $any$ O $any$ O O O O O $any$ O O $string$ O O $any$ O O O $string$ O O O $complex$ O O $string$ O $any$ O $any$ O O O O O $void$ O $unknown$ O $any$ O O O $TreeClimberCB$ O O O $void[]$ O O $Args$ O O $ObjectConstructor$ O $complex$ O $any$ O O $U[]$ O $string$ O $void$ O $any$ O $string$ O O $TreeClimberCB$ O O O O $void[]$ O O $Body$ O O O O O $Traversable[]$ O $U[]$ O $Traversable$ O $void$ O $Traversable$ O $TreeClimberCB$ O O O O O $complex$ O $unknown$ O O O $Traversable$ O $Traversable[]$ O $Traversable$ O $Traversable[]$ O O O O $void[]$ O $Traversable$ O $any$ O O $void[]$ O $Traversable$ O $Traversable[]$ O O $TreeClimberCB$ O $Traversable$ O O O O O $any$ O $any$ O $any$ O $number[]$ O O O O O O O O $SanitizationResult$ O O $Sequence$ O O $any$ O O O $Dictionary$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $any$ O O $Dictionary$ O $any$ O O O O O O $any$ O O $Identifier$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $number[]$ O O O O O O O O $void$ O $any$ O $Traversable$ O O $Traversable$ O $Traversable$ O O $complex$ O $Traversable$ O O $any$ O $Traversable$ O O O O $complex$ O $Traversable$ O O O O O $any$ O O $Traversable$ O $any$ O O $any$ O $any$ O O $number[]$ O $number$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $ObjectConstructor$ O $complex$ O $any$ O O $U[]$ O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $U[]$ O $any$ O O $Traversable$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $number[]$ O O O O O
import { FirmwareHardware , Alert , Dictionary } from "s" ; import { TimeSettings } from "s" ; import { UUID } from "s" ; export interface MessagesProps { alerts : Alert [ ] ; apiFirmwareValue : FirmwareHardware | undefined ; timeSettings : TimeSettings ; dispatch : Function ; findApiAlertById ( id ) : UUID ; } export interface AlertsProps { alerts : Alert [ ] ; apiFirmwareValue : string | undefined ; timeSettings : TimeSettings ; dispatch : Function ; findApiAlertById ( id ) : UUID ; } export interface ProblemTag { author : string ; noun : string ; verb : string ; } export interface FirmwareAlertsProps { alerts : Alert [ ] ; apiFirmwareValue : string | undefined ; timeSettings : TimeSettings ; dispatch : Function ; } export interface AlertCardProps { alert : Alert ; apiFirmwareValue : string | undefined ; timeSettings : TimeSettings ; dispatch : Function ; findApiAlertById ? ( id ) : UUID ; } export interface CommonAlertCardProps { alert : Alert ; timeSettings : TimeSettings ; findApiAlertById ? ( id ) : UUID ; dispatch ? : Function ; } export interface AlertCardTemplateProps { className : string ; title : string ; alert : Alert ; message : string ; timeSettings : TimeSettings ; children ? : React . ReactNode ; findApiAlertById ? ( id ) : UUID ; dispatch ? : Function ; iconName ? : string ; } export interface DismissAlertProps { id ? : number ; findApiAlertById ? ( id ) : UUID ; dispatch ? : Function ; } export interface FirmwareMissingProps extends CommonAlertCardProps { apiFirmwareValue : string | undefined ; } export interface SeedDataMissingProps extends CommonAlertCardProps { dispatch : Function ; } export interface SeedDataMissingState { selection : string ; } export interface TourNotTakenProps extends CommonAlertCardProps { dispatch : Function ; } export interface Bulletin { content : string ; href : string | undefined ; href_label : string | undefined ; type : string ; slug : string ; title : string | undefined ; } export interface BulletinAlertComponentState { bulletin : Bulletin | undefined ; no_content : boolean ; } export interface AlertReducerState { alerts : Dictionary < Alert | undefined > ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any[]$ O $any$ O O O $any$ O $any$ O O O $TimeSettings$ O $any$ O $Function$ O $FunctionConstructor$ O $string$ O $number$ O O $any$ O O O O $any$ O $any[]$ O $any$ O O O $string$ O O O O O $TimeSettings$ O $any$ O $Function$ O $FunctionConstructor$ O $string$ O $number$ O O $any$ O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any[]$ O $any$ O O O $string$ O O O O O $TimeSettings$ O $any$ O $Function$ O $FunctionConstructor$ O O O O $any$ O $any$ O $any$ O $string$ O O O O O $TimeSettings$ O $any$ O $Function$ O $FunctionConstructor$ O $string$ O O $number$ O O $any$ O O O O $any$ O $any$ O $any$ O $TimeSettings$ O $any$ O $string$ O O $number$ O O $any$ O $Function$ O O $FunctionConstructor$ O O O O $any$ O $string$ O O O $string$ O O O $any$ O $any$ O $string$ O O O $TimeSettings$ O $any$ O $any$ O O $any$ O $any$ O $string$ O O $number$ O O $any$ O $Function$ O O $FunctionConstructor$ O $string$ O O O O O O O $any$ O $number$ O O O O $string$ O O $number$ O O $any$ O $Function$ O O $FunctionConstructor$ O O O O $any$ O $any$ O $string$ O O O O O O O O $any$ O $any$ O $Function$ O $FunctionConstructor$ O O O O $any$ O $string$ O O O O O O $any$ O $any$ O $Function$ O $FunctionConstructor$ O O O O $any$ O $string$ O O O $string$ O O O O O $string$ O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O $Bulletin$ O $any$ O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O
type ProtocolString = "s" | "s" ; let current : API | undefined ; interface UrlInfo { protocol : string ; hostname : string ; port : string ; pathname : string ; search : string ; hash : string ; host : string ; } export class API { static inferPort ( location = window . location ) { if ( location . port === "s" ) { return "s" ; } if ( location . port ) { return location . port ; } if ( API . parseURL ( location . origin ) . protocol === "s" ) { return "s" ; } return "s" ; } static fetchBrowserLocation ( ) { return `template` ; } static fetchHostName ( ) { return window . location . hostname ; } static parseURL ( url ) { const info = document . createElement ( "s" ) ; info . href = url ; return info ; } static setBaseUrl ( base ) { current = new API ( base ) ; } static get current ( ) : API { if ( current ) { return current ; } else { throw new Error ( `template` ) ; } } private readonly protocol : ProtocolString ; private readonly host : string ; constructor ( input ) { const url = API . parseURL ( input ) ; this . protocol = url . protocol as ProtocolString ; this . host = url . host ; } get baseUrl ( ) { return `template` ; } get tokensPath ( ) { return `template` ; } get passwordResetPath ( ) { return `template` ; } get devicePath ( ) { return `template` ; } get accountSeedPath ( ) { return `template` ; } get accountResetPath ( ) { return `template` ; } get usersPath ( ) { return `template` ; } get transferCertPath ( ) { return `template` ; } get userResendConfirmationPath ( ) { return this . usersPath + "s" ; } get peripheralsPath ( ) { return `template` ; } get farmEventsPath ( ) { return `template` ; } get regimensPath ( ) { return `template` ; } get sequencesPath ( ) { return `template` ; } get toolsPath ( ) { return `template` ; } get imagesPath ( ) { return `template` ; } get pointsPath ( ) { return `template` ; } get pointGroupsPath ( ) { return `template` ; } get allPointsPath ( ) { return `template` ; } get pointSearchPath ( ) { return `template` ; } get filteredLogsPath ( ) { return `template` ; } get logsPath ( ) { return `template` ; } get webcamFeedPath ( ) { return `template` ; } get webAppConfigPath ( ) { return `template` ; } get fbosConfigPath ( ) { return `template` ; } get firmwareConfigPath ( ) { return `template` ; } get sensorReadingPath ( ) { return `template` ; } get sensorPath ( ) { return `template` ; } get farmwareEnvPath ( ) { return `template` ; } get pinBindingPath ( ) { return `template` ; } get savedGardensPath ( ) { return `template` ; } get snapshotPath ( ) { return this . savedGardensPath + "s" ; } applyGardenPath = ( gardenId ) => `template` ; get exportDataPath ( ) { return `template` ; } get plantTemplatePath ( ) { return `template` ; } get diagnosticDumpsPath ( ) { return `template` ; } get farmwareInstallationPath ( ) { return `template` ; } get alertPath ( ) { return `template` ; } get globalBulletinPath ( ) { return `template` ; } }	O $any$ O O O O O O $API$ O $any$ O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O O $string$ O $Location$ O $complex$ O $Location$ O O O O $Location$ O $string$ O O O O O O O O O O $Location$ O $string$ O O O $Location$ O $string$ O O O O $any$ O $UrlInfo$ O $Location$ O $string$ O O $string$ O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O O O O $complex$ O $Location$ O $string$ O O O $UrlInfo$ O $string$ O O O $HTMLAnchorElement$ O $Document$ O O O O O O $HTMLAnchorElement$ O $string$ O $string$ O O $HTMLAnchorElement$ O O O $void$ O $string$ O O $API$ O O $any$ O $string$ O O O O O $API$ O O O $any$ O O O $API$ O O O $API$ O O O O O O $ErrorConstructor$ O O O O O O O O $ProtocolString$ O $any$ O O O $string$ O O O O O $string$ O O O $UrlInfo$ O $any$ O $UrlInfo$ O $string$ O O O O $ProtocolString$ O $UrlInfo$ O $string$ O $any$ O O O $string$ O $UrlInfo$ O $string$ O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O $string$ O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O $string$ O O O O $string$ O O $number$ O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O
export * from "s" ;	O O O O O
import { AuthState } from "s" ; import { box } from "s" ; import { BooleanSetting , NumericSetting } from "s" ; import { BooleanConfigKey , NumberConfigKey } from "s" ; export namespace Session { const KEY = "s" ; export function replaceToken ( nextState ) { localStorage . setItem ( KEY , JSON . stringify ( nextState ) ) ; } export function fetchStoredToken ( ) : AuthState | undefined { try { const v = JSON . parse ( localStorage . getItem ( KEY ) || "s" ) ; if ( box ( v ) . kind === "s" ) { return v ; } else { throw new Error ( "s" ) ; } } catch ( error ) { return undefined ; } } export function clear ( ) { localStorage . clear ( ) ; sessionStorage . clear ( ) ; location . assign ( window . location . origin || "s" ) ; return undefined as never ; } } export const isBooleanSetting = ( k ) : k is BooleanConfigKey => ! ! BooleanSetting [ k as BooleanConfigKey ] ; export function safeBooleanSetting ( name ) { if ( isBooleanSetting ( name ) ) { return name ; } else { throw new Error ( `template` ) ; } } export const isNumericSetting = ( x ) : x is NumberConfigKey => ! ! NumericSetting [ x as NumberConfigKey ] ; export function safeNumericSetting ( name ) { if ( isNumericSetting ( name ) ) { return name ; } else { throw new Error ( `template` ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $complex$ O $complex$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $void$ O $AuthState$ O O $Storage$ O $void$ O O O $JSON$ O $complex$ O $AuthState$ O O O O O O $AuthState$ O O O $any$ O O O O O O $AuthState$ O $JSON$ O $any$ O $Storage$ O $string$ O O O O O O O O O $any$ O $AuthState$ O O $any$ O O O O O $AuthState$ O O O O O O $ErrorConstructor$ O O O O O O O O $any$ O O O $undefined$ O O O O O $never$ O O O $Storage$ O $void$ O O O $Storage$ O $void$ O O O $Location$ O $void$ O $complex$ O $Location$ O $string$ O O O O O $undefined$ O O O O O O O $complex$ O O $unknown$ O O $unknown$ O $any$ O O O $complex$ O $unknown$ O $any$ O O O O $BooleanConfigKey$ O $string$ O O O O $complex$ O $string$ O O O O $string$ O O O O O O $ErrorConstructor$ O O O O O O O O $complex$ O O $unknown$ O O $unknown$ O $any$ O O O $complex$ O $unknown$ O $any$ O O O O $NumberConfigKey$ O $string$ O O O O $complex$ O $string$ O O O O $string$ O O O O O O $ErrorConstructor$ O O O O O O
import axios from "s" ; import { API } from "s" ; import { Actions } from "s" ; import { TaggedResource as TR , SpecialStatus , TaggedResource } from "s" ; import { Session } from "s" ; import { arrayWrap , generateUuid } from "s" ; export interface SyncBodyContents < T extends TR > { kind : T [ "s" ] ; body : T [ ] ; } export interface SyncResponse < T extends TR > { type : Actions . RESOURCE_READY ; payload : SyncBodyContents < T > } export const resourceReady = < T extends TR > ( kind : T [ "s" ] , body : T | T [ ] ) : SyncResponse < T > => { return { type : Actions . RESOURCE_READY , payload : { kind , body : arrayWrap ( body ) } } ; } ; export const newTaggedResource = < T extends TR > ( kind : T [ "s" ] , bodies : T [ "s" ] | T [ "s" ] [ ] , specialStatus = SpecialStatus . SAVED ) : T [ ] => { const arr = arrayWrap ( bodies ) ; return arr . map ( ( body : T [ "s" ] ) : T => { return { kind : kind as TaggedResource [ "s" ] , body : body as TaggedResource [ "s" ] , uuid : generateUuid ( body && body . id ? body . id : undefined , kind ) , specialStatus } as T ; } ) ; } ; export function syncFail ( e ) { console . error ( "s" ) ; Session . clear ( ) ; throw e ; } const download = ( dispatch ) => < T extends TR > ( kind : T [ "s" ] , url ) => axios . get < T [ "s" ] | T [ "s" ] [ ] > ( url ) . then ( ( { data } ) => { dispatch ( resourceReady ( kind , newTaggedResource ( kind , data ) ) ) ; } , syncFail ) ; export async function fetchSyncData ( dispatch ) { const get = download ( dispatch ) ; const group = { 0 : ( ) => Promise . all < { } > ( [ get ( "s" , API . current . usersPath ) , get ( "s" , API . current . devicePath ) , get ( "s" , API . current . firmwareConfigPath ) , get ( "s" , API . current . farmwareEnvPath ) , get ( "s" , API . current . farmwareInstallationPath ) , get ( "s" , API . current . webAppConfigPath ) , get ( "s" , API . current . savedGardensPath ) , ] ) , 0 : ( ) => Promise . all < { } > ( [ get ( "s" , API . current . plantTemplatePath ) , get ( "s" , API . current . peripheralsPath ) , get ( "s" , API . current . allPointsPath ) , get ( "s" , API . current . sensorPath ) , get ( "s" , API . current . toolsPath ) , get ( "s" , API . current . alertPath ) , ] ) , 0 : ( ) => Promise . all < { } > ( [ get ( "s" , API . current . sensorReadingPath ) , get ( "s" , API . current . sequencesPath ) , get ( "s" , API . current . pointGroupsPath ) ] ) , 0 : ( ) => Promise . all < { } > ( [ get ( "s" , API . current . fbosConfigPath ) , get ( "s" , API . current . regimensPath ) , get ( "s" , API . current . pinBindingPath ) , ] ) , 0 : ( ) => Promise . all < { } > ( [ get ( "s" , API . current . farmEventsPath ) , get ( "s" , API . current . diagnosticDumpsPath ) , get ( "s" , API . current . imagesPath ) , get ( "s" , API . current . filteredLogsPath ) , get ( "s" , API . current . webcamFeedPath ) ] ) , } ; const step = ( num : keyof typeof group ) => group [ num ] ; step ( 0 ) ( ) . then ( step ( 0 ) ) . then ( step ( 0 ) ) . then ( step ( 0 ) ) . then ( step ( 0 ) ) . catch ( syncFail ) ; }	O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $T[]$ O $string$ O O O O O O $any$ O $any$ O $any$ O O $T["kind"]$ O $any$ O O O O $T[]$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $Actions.RESOURCE_READY$ O $any$ O $Actions.RESOURCE_READY$ O $SyncBodyContents<T>$ O $any$ O $any$ O O O O $SyncResponse<T>$ O O $any$ O $any$ O O $T["kind"]$ O $any$ O O O O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $Actions.RESOURCE_READY$ O $any$ O $Actions.RESOURCE_READY$ O $complex$ O O $T["kind"]$ O $T[]$ O $T[]$ O $complex$ O O O O O O O O $T[]$ O O $any$ O $any$ O O $T["kind"]$ O $any$ O O O O $complex$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $T["body"][]$ O $T[]$ O $complex$ O O O $T["body"][]$ O $U[]$ O O $T["body"]$ O $any$ O O O O O $any$ O O O O $any$ O $T["kind"]$ O $any$ O O O O $any$ O $T["body"]$ O $any$ O O O O $string$ O $string$ O $T["body"]$ O $T["body"]$ O $any$ O $T["body"]$ O $any$ O $undefined$ O $T["kind"]$ O O $any$ O O $any$ O O O O O O O O $void$ O $Error$ O O $Console$ O $void$ O O O O $any$ O $never$ O O O O $Error$ O O O $any$ O O $Function$ O O O $any$ O $any$ O O $T["kind"]$ O $any$ O O O O $string$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $string$ O O $any$ O O O $any$ O O O O $Function$ O $SyncResponse<T>$ O $T["kind"]$ O $T[]$ O $T["kind"]$ O $any$ O O O O O O $void$ O O O O O $Promise<void>$ O $Function$ O O O $any$ O $any$ O $Function$ O O O O O O O O O O O $PromiseConstructor$ O O O O O O O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O O O O O O O O O $PromiseConstructor$ O O O O O O O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O O O O O O O O O $PromiseConstructor$ O O O O O O O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O O O O O O O O $PromiseConstructor$ O O O O O O O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O O O O O O O O O $PromiseConstructor$ O O O O O O O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O $API$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $complex$ O $void$ O O O
import { SpecialStatus } from "s" ; export interface EditResourceParams { uuid : string ; update : object ; specialStatus : SpecialStatus ; }	O O $any$ O O O O O O $any$ O $string$ O O O $object$ O O O $any$ O $any$ O O
import { AlertReducerState as State } from "s" ; import { generateReducer } from "s" ; import { SyncBodyContents } from "s" ; import { TaggedResource , TaggedFbosConfig } from "s" ; import { Actions } from "s" ; import { ReduxAction } from "s" ; import { EditResourceParams } from "s" ; import { unpackUUID } from "s" ; type Reducer = ( state , fn < TaggedResource > ) => State ; const DEFAULT = ( s , a ) => handleFbosConf ( s , a . payload ) ; const FIRMWARE_MISSING = "s" ; export const initialState = { alerts : { } } ; const toggleAlert = ( s , body : TaggedFbosConfig [ "s" ] ) => { if ( body . firmware_hardware ) { delete s . alerts [ FIRMWARE_MISSING ] ; } else { s . alerts [ FIRMWARE_MISSING ] = { created_at : 0 , problem_tag : FIRMWARE_MISSING , priority : 0 , slug : "s" , } ; } return s ; } ; const handleFbosConf = ( s , resource ) : State => { return ( resource . kind === "s" ) ? toggleAlert ( s , resource . body ) : s ; } ; const pickConfigs = ( x ) => x . kind === "s" ; export const alertsReducer = generateReducer < State > ( initialState ) . add < SyncBodyContents < TaggedResource > > ( Actions . RESOURCE_READY , ( s , a ) => { const conf = a . payload . body . filter ( pickConfigs ) [ 0 ] ; return ( conf ) ? handleFbosConf ( s , conf ) : s ; } ) . add < TaggedResource [ ] > ( Actions . BATCH_INIT , ( s , a ) => { const conf = a . payload . filter ( pickConfigs ) [ 0 ] ; return conf ? handleFbosConf ( s , conf ) : s ; } ) . add < EditResourceParams > ( Actions . OVERWRITE_RESOURCE , ( s , a ) => { const x = unpackUUID ( a . payload . uuid ) ; const y : TaggedResource [ "s" ] = a . payload . update ; if ( x . kind === "s" ) { return toggleAlert ( s , y as TaggedFbosConfig [ "s" ] ) ; } return s ; } ) . add < TaggedResource > ( Actions . REFRESH_RESOURCE_OK , DEFAULT ) . add < TaggedResource > ( Actions . SAVE_RESOURCE_OK , DEFAULT ) . add < TaggedResource > ( Actions . SAVE_RESOURCE_START , DEFAULT ) ;	O O $any$ O $any$ O O O O O O $GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $BetterUUID$ O O O O O $any$ O O $State$ O $ReduxAction$ O $any$ O O O $any$ O O $Reducer$ O O $AlertReducerState$ O $ReduxAction<any>$ O O $AlertReducerState$ O $AlertReducerState$ O $ReduxAction<any>$ O $any$ O O O O O O O O O $State$ O O ${}$ O O O O O O $AlertReducerState$ O O $State$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $AlertReducerState$ O $any$ O O O O O O O $AlertReducerState$ O $any$ O O O O O $number$ O O O $string$ O O O $number$ O O O $string$ O O O O O O O $AlertReducerState$ O O O O $AlertReducerState$ O O $State$ O $TaggedResource$ O O $any$ O O O O $any$ O $any$ O O O O $AlertReducerState$ O $AlertReducerState$ O $any$ O $any$ O O $AlertReducerState$ O O O O $boolean$ O O $TaggedResource$ O O $any$ O $any$ O O O O O $generateReducer<AlertReducerState>.GeneratedReducer$ O $GeneratedReducer$ O $any$ O O $AlertReducerState$ O O $generateReducer<AlertReducerState>.GeneratedReducer$ O $any$ O $any$ O O O $any$ O $Actions.RESOURCE_READY$ O O $AlertReducerState$ O $ReduxAction<SyncBodyContents<any>>$ O O O O $any$ O $ReduxAction<SyncBodyContents<any>>$ O $SyncBodyContents<any>$ O $any[]$ O $complex$ O $boolean$ O O O O O O O $any$ O O $AlertReducerState$ O $AlertReducerState$ O $any$ O O $AlertReducerState$ O O O O $generateReducer<AlertReducerState>.GeneratedReducer$ O $any$ O O O O $any$ O $Actions.BATCH_INIT$ O O $AlertReducerState$ O $ReduxAction<any[]>$ O O O O $any$ O $ReduxAction<any[]>$ O $any[]$ O $complex$ O $boolean$ O O O O O O $any$ O $AlertReducerState$ O $AlertReducerState$ O $any$ O O $AlertReducerState$ O O O O $generateReducer<AlertReducerState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.OVERWRITE_RESOURCE$ O O $AlertReducerState$ O $ReduxAction<EditResourceParams>$ O O O O $BetterUUID$ O $BetterUUID$ O $ReduxAction<EditResourceParams>$ O $EditResourceParams$ O $string$ O O O $any$ O $any$ O O O O $ReduxAction<EditResourceParams>$ O $EditResourceParams$ O $object$ O O O $BetterUUID$ O $any$ O O O O O $AlertReducerState$ O $AlertReducerState$ O $any$ O $any$ O O O O O O O $AlertReducerState$ O O O O $generateReducer<AlertReducerState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.REFRESH_RESOURCE_OK$ O $Reducer$ O O $generateReducer<AlertReducerState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.SAVE_RESOURCE_OK$ O $Reducer$ O O $generateReducer<AlertReducerState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.SAVE_RESOURCE_START$ O $Reducer$ O O
import { ResourceName , SpecialStatus } from "s" ; import { combineReducers } from "s" ; import { helpReducer as help } from "s" ; import { designer as farm_designer } from "s" ; import { farmwareReducer as farmware } from "s" ; import { regimensReducer as regimens } from "s" ; import { sequenceReducer as sequences } from "s" ; import { RestResources } from "s" ; import { isTaggedResource } from "s" ; import { arrayWrap , arrayUnwrap } from "s" ; import { TaggedResource , TaggedSequence } from "s" ; import { ResourceIndex } from "s" ; import { sanitizeNodes } from "s" ; import { selectAllFarmEvents , findByKindAndId , selectAllLogs , selectAllRegimens , } from "s" ; import { ExecutableType } from "s" ; import { betterCompact , unpackUUID } from "s" ; import { createSequenceMeta } from "s" ; import { alertsReducer as alerts } from "s" ; import { warning } from "s" ; import { ReduxAction } from "s" ; import { ActionHandler } from "s" ; import { get } from "s" ; import { Actions } from "s" ; import { getFbosConfig } from "s" ; export function findByUuid ( index , uuid ) { const x = index . references [ uuid ] ; if ( x && isTaggedResource ( x ) ) { return x ; } else { throw new Error ( "s" + uuid ) ; } } type IndexDirection = | "s" | "s" ; type IndexerCallback = ( self , index ) => void ; export interface Indexer extends Record < IndexDirection , IndexerCallback > { } const REFERENCES = { up : ( r , i ) => i . references [ r . uuid ] = r , down : ( r , i ) => delete i . references [ r . uuid ] , } ; const ALL = { up : ( r , s ) => s . all [ r . uuid ] = true , down : ( r , i ) => delete i . all [ r . uuid ] , } ; const BY_KIND = { up ( r , i ) { i . byKind [ r . kind ] [ r . uuid ] = r . uuid ; } , down ( r , i ) { delete i . byKind [ r . kind ] [ r . uuid ] ; } , } ; const BY_KIND_AND_ID = { up : ( r , i ) => { if ( r . body . id ) { i . byKindAndId [ joinKindAndId ( r . kind , r . body . id ) ] = r . uuid ; } } , down ( r , i ) { delete i . byKindAndId [ joinKindAndId ( r . kind , r . body . id ) ] ; delete i . byKindAndId [ joinKindAndId ( r . kind , 0 ) ] ; } , } ; export function updateSequenceUsageIndex ( myUuid , ids : number [ ] , i ) { ids . map ( id => { const uuid = i . byKindAndId [ joinKindAndId ( "s" , id ) ] ; if ( uuid ) { const inUse = i . inUse [ "s" ] [ uuid ] || { } ; i . inUse [ "s" ] [ uuid ] = { ... inUse , ... { [ myUuid ] : true } } ; } } ) ; } export const updateOtherSequenceIndexes = ( tr , i ) => { i . references [ tr . uuid ] = tr ; i . sequenceMetas [ tr . uuid ] = createSequenceMeta ( i , tr ) ; } ; const reindexSequences = ( i ) => ( s ) => { const { thisSequence , callsTheseSequences } = sanitizeNodes ( s . body ) ; updateSequenceUsageIndex ( s . uuid , callsTheseSequences , i ) ; updateOtherSequenceIndexes ( { ... s , body : thisSequence } , i ) ; } ; const reindexAllSequences = ( i ) => { i . inUse [ "s" ] = { } ; const mapper = reindexSequences ( i ) ; betterCompact ( Object . keys ( i . byKind [ "s" ] ) . map ( uuid => { const resource = i . references [ uuid ] ; return ( resource && resource . kind == "s" ) ? resource : undefined ; } ) ) . map ( mapper ) ; } ; export function reindexAllFarmEventUsage ( i ) { i . inUse [ "s" ] = { } ; i . inUse [ "s" ] = { } ; const whichOne < ExecutableType , typeof i . inUse [ "s" ] > = { "s" : i . inUse [ "s" ] , "s" : i . inUse [ "s" ] , } ; betterCompact ( selectAllFarmEvents ( i ) . map ( fe => { const { executable_type , executable_id } = fe . body ; const { uuid } = findByKindAndId ( i , executable_type , executable_id ) ; return { exe_type : executable_type , exe_uuid : uuid , fe_uuid : fe . uuid } ; } ) ) . map ( ( { exe_type , exe_uuid , fe_uuid } ) => { whichOne [ exe_type ] = whichOne [ exe_type ] || { } ; whichOne [ exe_type ] [ exe_uuid ] = whichOne [ exe_type ] [ exe_uuid ] || { } ; whichOne [ exe_type ] [ exe_uuid ] [ fe_uuid ] = true ; } ) ; } export const INDEXERS : Indexer [ ] = [ REFERENCES , ALL , BY_KIND , BY_KIND_AND_ID , ] ; type IndexerHook = Partial < Record < TaggedResource [ "s" ] , Reindexer > > ; type Reindexer = ( i , strategy : "s" | "s" ) => void ; export function joinKindAndId ( kind , id : number | undefined ) { return `template` ; } const consumerReducer = combineReducers < RestResources [ "s" ] > ( { regimens , sequences , farm_designer , farmware , help , alerts } as any ) ; export const afterEach = ( state , a < unknown > ) => { state . consumers = consumerReducer ( { sequences : state . consumers . sequences , regimens : state . consumers . regimens , farm_designer : state . consumers . farm_designer , farmware : state . consumers . farmware , help : state . consumers . help , alerts : state . consumers . alerts } , a ) ; return state ; } ; export const mutateSpecialStatus = ( uuid , index , status = SpecialStatus . SAVED ) => { findByUuid ( index , uuid ) . specialStatus = status ; } ; export function initResourceReducer ( s , { payload } < TaggedResource > ) { indexUpsert ( s . index , [ payload ] , "s" ) ; return s ; } const BEFORE_HOOKS = { Log ( _index , strategy ) { ( strategy === "s" ) && selectAllLogs ( _index ) . map ( log => indexRemove ( _index , log ) ) ; } , } ; const AFTER_HOOKS = { FbosConfig : ( i ) => { const conf = getFbosConfig ( i ) ; if ( conf && conf . body . boot_sequence_id ) { const { boot_sequence_id } = conf . body ; const tracker = i . inUse [ "s" ] ; const uuid = i . byKindAndId [ joinKindAndId ( "s" , boot_sequence_id ) ] ; if ( uuid ) { tracker [ uuid ] = tracker [ uuid ] || { } ; tracker [ uuid ] [ conf . uuid ] = true ; } } else { i . inUse [ "s" ] = { } ; } } , FarmEvent : reindexAllFarmEventUsage , Sequence : reindexAllSequences , Regimen : ( i ) => { i . inUse [ "s" ] = { } ; const tracker = i . inUse [ "s" ] ; selectAllRegimens ( i ) . map ( reg => { reg . body . regimen_items . map ( ri => { const sequence = findByKindAndId ( i , "s" , ri . sequence_id ) ; tracker [ sequence . uuid ] = tracker [ sequence . uuid ] || { } ; tracker [ sequence . uuid ] [ reg . uuid ] = true ; } ) ; } ) ; } } ; const ups = INDEXERS . map ( x => x . up ) ; const downs = INDEXERS . map ( x => x . down ) . reverse ( ) ; type UpsertStrategy = | "s" | "s" ; type IndexUpsert = ( db , resources : TaggedResource [ ] , strategy ) => void ; export const indexUpsert = ( db , resources , strategy ) => { if ( resources . length == 0 ) { return ; } const { kind } = arrayUnwrap ( resources ) ; const before = BEFORE_HOOKS [ kind ] ; before && before ( db , strategy ) ; ups . map ( callback => { resources . map ( resource => callback ( resource , db ) ) ; } ) ; const after = AFTER_HOOKS [ kind ] ; after && after ( db , strategy ) ; } ; export function indexRemove ( db , resource ) { downs . map ( callback => arrayWrap ( resource ) . map ( r => callback ( r , db ) ) ) ; const after = AFTER_HOOKS [ resource . kind ] ; after && after ( db , "s" ) ; } export const beforeEach = ( state , action < unknown > , handler < RestResources , unknown > ) => { const { byKind , references } = state . index ; const w = references [ Object . keys ( byKind . WebAppConfig ) [ 0 ] ] ; const readOnly = w && w . kind == "s" && w . body . user_interface_read_only_mode ; if ( ! readOnly ) { return handler ( state , action ) ; } const fail = ( place ) => { warning ( `template` ) ; } ; const { kind } = unpackUUID ( get ( action , "s" , "s" ) ) ; switch ( action . type ) { case Actions . EDIT_RESOURCE : if ( kind === "s" ) { return handler ( state , action ) ; } else { fail ( "s" ) ; return state ; } case Actions . SAVE_RESOURCE_START : case Actions . DESTROY_RESOURCE_START : if ( kind !== "s" ) { fail ( "s" ) ; } return handler ( state , action ) ; case Actions . BATCH_INIT : case Actions . INIT_RESOURCE : case Actions . OVERWRITE_RESOURCE : fail ( "s" ) ; return state ; default : return handler ( state , action ) ; } } ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $generateReducer<HelpState>.GeneratedReducer$ O $generateReducer<HelpState>.GeneratedReducer$ O O O O O O $generateReducer<DesignerState>.GeneratedReducer$ O $generateReducer<DesignerState>.GeneratedReducer$ O O O O O O $generateReducer<FarmwareState>.GeneratedReducer$ O $generateReducer<FarmwareState>.GeneratedReducer$ O O O O O O $generateReducer<RegimenState>.GeneratedReducer$ O $generateReducer<RegimenState>.GeneratedReducer$ O O O O O O $generateReducer<SequenceReducerState>.GeneratedReducer$ O $generateReducer<SequenceReducerState>.GeneratedReducer$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $T[]$ O $T$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $SanitizationResult$ O O O O O O $any[]$ O $T$ O $any[]$ O $any[]$ O O O O O O O $any$ O O O O O O $T[]$ O $BetterUUID$ O O O O O O $complex$ O O O O O O $generateReducer<AlertReducerState>.GeneratedReducer$ O $generateReducer<AlertReducerState>.GeneratedReducer$ O O O O O O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $TaggedResource$ O $ResourceIndex$ O $string$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O O $any$ O $complex$ O $any$ O O O O $any$ O O O O O O $ErrorConstructor$ O O O $string$ O O O O O $any$ O O O O O O O $any$ O O $TaggedResource$ O $ResourceIndex$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $Indexer$ O O $any$ O O $any$ O $ResourceIndex$ O O $ResourceIndex$ O $any$ O $any$ O $any$ O O $any$ O $boolean$ O O $any$ O $ResourceIndex$ O O O $ResourceIndex$ O $any$ O $any$ O $any$ O O O O O $Indexer$ O O $boolean$ O O $any$ O $ResourceIndex$ O O $ResourceIndex$ O $complex$ O $any$ O $any$ O O O O $boolean$ O O $any$ O $ResourceIndex$ O O O $ResourceIndex$ O $complex$ O $any$ O $any$ O O O O O $Indexer$ O O $void$ O $any$ O $ResourceIndex$ O O $ResourceIndex$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $void$ O $any$ O $ResourceIndex$ O O O $ResourceIndex$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $Indexer$ O O $void$ O O $any$ O $ResourceIndex$ O O O O O $any$ O $any$ O $any$ O O $ResourceIndex$ O $any$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $void$ O $any$ O $ResourceIndex$ O O O $ResourceIndex$ O $any$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $ResourceIndex$ O $any$ O $string$ O $any$ O $any$ O O O O O O O O O O O $void$ O $string$ O $number[]$ O O O O O $ResourceIndex$ O O $number[]$ O $U[]$ O $number$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O $number$ O O O O O $any$ O O O $complex$ O $ResourceIndex$ O $complex$ O O O O $any$ O O O O O $ResourceIndex$ O $complex$ O O O O $any$ O O O O $complex$ O O O O $string$ O O O O O O O O O O O O O $void$ O O $TaggedSequence$ O $ResourceIndex$ O O O $ResourceIndex$ O $any$ O $any$ O $any$ O O $any$ O $ResourceIndex$ O $complex$ O $any$ O $any$ O O $complex$ O $ResourceIndex$ O $any$ O O O O O $void$ O O $ResourceIndex$ O O O $TaggedSequence$ O O O O O $any$ O $number[]$ O O $SanitizationResult$ O $any$ O $any$ O O $void$ O $any$ O $any$ O $number[]$ O $ResourceIndex$ O O $void$ O O O $any$ O $any$ O $any$ O O $ResourceIndex$ O O O O O $void$ O O $ResourceIndex$ O O O $ResourceIndex$ O $complex$ O O O O O O O O $void$ O $void$ O $ResourceIndex$ O O $T[]$ O $ObjectConstructor$ O $complex$ O $ResourceIndex$ O $complex$ O O O O O $U[]$ O $string$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $undefined$ O O O O O $U[]$ O $void$ O O O O O O $void$ O $ResourceIndex$ O O $ResourceIndex$ O $complex$ O O O O O O O $ResourceIndex$ O $complex$ O O O O O O O O $Record$ O $any$ O O $ResourceIndex$ O $complex$ O O O O O O O O $ResourceIndex$ O $complex$ O O O O O O $ResourceIndex$ O $complex$ O O O O O O $T[]$ O $any[]$ O $ResourceIndex$ O O $U[]$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O $T$ O $ResourceIndex$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $U[]$ O O O $any$ O $any$ O $any$ O O O O $complex$ O $any$ O O $complex$ O $any$ O O O O O $complex$ O $any$ O O $any$ O O $complex$ O $any$ O O $any$ O O O O O $complex$ O $any$ O O $any$ O O $any$ O O O O O O O O O O $Indexer[]$ O $any$ O O O O $Indexer$ O $Indexer$ O $Indexer$ O $Indexer$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O $ResourceIndex$ O O O O O O O O O O O O $string$ O $ResourceName$ O $number$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $generateReducer<RegimenState>.GeneratedReducer$ O $generateReducer<SequenceReducerState>.GeneratedReducer$ O $generateReducer<DesignerState>.GeneratedReducer$ O $generateReducer<FarmwareState>.GeneratedReducer$ O $generateReducer<HelpState>.GeneratedReducer$ O $generateReducer<AlertReducerState>.GeneratedReducer$ O O O O O O O $RestResources$ O O $RestResources$ O $ReduxAction$ O O O O O O $RestResources$ O $complex$ O $any$ O O $SequenceReducerState$ O $RestResources$ O $complex$ O $SequenceReducerState$ O $RegimenState$ O $RestResources$ O $complex$ O $RegimenState$ O $DesignerState$ O $RestResources$ O $complex$ O $DesignerState$ O $FarmwareState$ O $RestResources$ O $complex$ O $FarmwareState$ O $HelpState$ O $RestResources$ O $complex$ O $HelpState$ O $AlertReducerState$ O $RestResources$ O $complex$ O $AlertReducerState$ O O $ReduxAction<unknown>$ O O O $RestResources$ O O O O O $void$ O O $string$ O $ResourceIndex$ O $any$ O $any$ O $any$ O O O $any$ O $ResourceIndex$ O $string$ O O $any$ O $any$ O O O O O $RestResources$ O $RestResources$ O O $any$ $ReduxAction$ O $any$ O O O $IndexUpsert$ O $RestResources$ O $ResourceIndex$ O O $any$ O O O O O O $RestResources$ O O O $IndexerHook$ O O $void$ O $ResourceIndex$ O O O O O O O O O O $any[]$ O $ResourceIndex$ O O $U[]$ O $any$ O $void$ O $ResourceIndex$ O $any$ O O O O O O O O $IndexerHook$ O O $void$ O O $ResourceIndex$ O O O O $any$ O $any$ O $ResourceIndex$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O $complex$ O $ResourceIndex$ O $complex$ O O O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O $any$ O O O O O $any$ O O $complex$ O $any$ O O $complex$ O $any$ O O O O O $complex$ O $any$ O O $any$ O $any$ O O O O O O O O $ResourceIndex$ O $complex$ O O O O O O O O O O $void$ O $void$ O $void$ O $void$ O $void$ O O $ResourceIndex$ O O O $ResourceIndex$ O $complex$ O O O O O O O O $complex$ O $ResourceIndex$ O $complex$ O O O O $any[]$ O $ResourceIndex$ O O $U[]$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $T$ O $ResourceIndex$ O O O $any$ O $any$ O O $complex$ O $any$ O $any$ O O $complex$ O $any$ O $any$ O O O O O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O O O O O O $IndexerCallback[]$ O $Indexer[]$ O $U[]$ O $Indexer$ O $Indexer$ O $IndexerCallback$ O O O $IndexerCallback[]$ O $Indexer[]$ O $U[]$ O $Indexer$ O $Indexer$ O $IndexerCallback$ O O $IndexerCallback[]$ O O O O $any$ O O O O O O O $any$ O O $ResourceIndex$ O $any[]$ O $any$ O O O $UpsertStrategy$ O O O O O O $IndexUpsert$ O O $ResourceIndex$ O $any[]$ O O O O O O O $any[]$ O $number$ O O O O O O O O O $any$ O O $T$ O $any[]$ O O O $Reindexer$ O $complex$ O $any$ O O $Reindexer$ O $Reindexer$ O $ResourceIndex$ O O O O $IndexerCallback[]$ O $U[]$ O $IndexerCallback$ O O $any[]$ O $U[]$ O $any$ O $IndexerCallback$ O $any$ O $ResourceIndex$ O O O O O O O $Reindexer$ O $complex$ O $any$ O O $Reindexer$ O $Reindexer$ O $ResourceIndex$ O O O O O O O O $void$ O $ResourceIndex$ O $TaggedResource$ O O $IndexerCallback[]$ O $U[]$ O $IndexerCallback$ O $T[]$ O $any$ O O $U[]$ O $any$ O $IndexerCallback$ O $any$ O $ResourceIndex$ O O O O O $Reindexer$ O $complex$ O $any$ O $any$ O O $Reindexer$ O $Reindexer$ O $ResourceIndex$ O O O O O O O $RestResources$ O O $RestResources$ O $ReduxAction$ O O O O $ActionHandler$ O $any$ O O O O O O O O $complex$ O $any$ O O $RestResources$ O $ResourceIndex$ O O $any$ O $any$ O $ObjectConstructor$ O $complex$ O $complex$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O $complex$ O $RestResources$ O $ReduxAction<unknown>$ O O O O $void$ O O $string$ O O O $void$ O O O O O O O O $any$ O O $BetterUUID$ O $any$ O $ReduxAction<unknown>$ O O O O O O O O O $ReduxAction<unknown>$ O $Actions$ O O O $any$ O $Actions.EDIT_RESOURCE$ O O O $any$ O O O O O $complex$ O $RestResources$ O $ReduxAction<unknown>$ O O O O O $void$ O O O O O $RestResources$ O O O $any$ O $Actions.SAVE_RESOURCE_START$ O O $any$ O $Actions.DESTROY_RESOURCE_START$ O O O $any$ O O O O $void$ O O O O O O $complex$ O $RestResources$ O $ReduxAction<unknown>$ O O O $any$ O $Actions.BATCH_INIT$ O O $any$ O $Actions.INIT_RESOURCE$ O O $any$ O $Actions.OVERWRITE_RESOURCE$ O $void$ O O O O O $RestResources$ O O O O $complex$ O $RestResources$ O $ReduxAction<unknown>$ O O O O O
import { ResourceName } from "s" ; import { Dictionary } from "s" ; import { betterCompact } from "s" ; import { isArray } from "s" ; import { ResourceIndex } from "s" ; import { joinKindAndId } from "s" ; let count = 0 ; export function generateUuid ( id : number | undefined , kind ) { return `template` ; } export function arrayWrap < T > ( input : T | ( T [ ] ) ) : T [ ] { return isArray ( input ) ? input : [ input ] ; } export function arrayUnwrap < T > ( input : T | T [ ] ) : T { return isArray ( input ) ? input [ 0 ] : input ; } export function entries < T > ( input < T | undefined > ) : T [ ] { const x = Object . keys ( input ) . map ( key => input [ key ] ) ; const y = betterCompact ( x ) ; return y ; } export function hasId ( ri , k , id ) { return ! ! ri . byKindAndId [ joinKindAndId ( k , id ) ] ; } export function assertUuid ( expected , actual : string | undefined ) { if ( actual && ! actual . startsWith ( expected ) ) { console . warn ( `template` ) ; return false ; } else { return true ; } }	O O $any$ O O O O O O $any$ O O O O O O $T[]$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O $number$ O O O O O $string$ O $number$ O O O O O $ResourceName$ O O O O O O O O $T[]$ O $any$ O O $complex$ O $any$ O O $any$ O O O O O $any$ O O O O $any$ O $complex$ O O $complex$ O O $complex$ O O O O O $T$ O $any$ O O $complex$ O $any$ O $any$ O O O O $any$ O O $any$ O $complex$ O O $complex$ O O O O $complex$ O O O O $T[]$ O $any$ O O $Dictionary$ O $any$ O O O O O $any$ O O O O $any[]$ O $ObjectConstructor$ O $complex$ O $any$ O O $U[]$ O $string$ O $any$ O $string$ O O O O $any[]$ O $T[]$ O $any[]$ O O O $any[]$ O O O O $boolean$ O $ResourceIndex$ O $ResourceName$ O $number$ O O O O O $ResourceIndex$ O $any$ O $string$ O $any$ O $number$ O O O O O O $boolean$ O $ResourceName$ O $string$ O O O O O O O O $string$ O O $string$ O $boolean$ O $any$ O O O $Console$ O $void$ O O O O O O O O O O O O O O O
import { isObject , isString , get , chain } from "s" ; import { betterCompact } from "s" ; import { assertUuid } from "s" ; import { TaggedResource , ResourceName , TaggedRegimen , TaggedSequence , TaggedTool , TaggedFarmEvent , TaggedToolSlotPointer , TaggedPlantPointer , TaggedGenericPointer , PointerType , SpecialStatus , TaggedPlantTemplate , } from "s" ; export interface TaggedResourceBase { kind : ResourceName ; uuid : string ; body : object ; specialStatus : SpecialStatus ; } export function getArrayStatus ( i : TaggedResource [ ] ) { const r = betterCompact ( chain ( i ) . map ( x => x . specialStatus ) . uniq ( ) . value ( ) ) ; if ( r . length ) { return ( r . includes ( SpecialStatus . SAVING ) ) ? SpecialStatus . SAVING : SpecialStatus . DIRTY ; } else { return SpecialStatus . SAVED ; } } export function sanityCheck ( x ) : x is TaggedResource { if ( isTaggedResource ( x ) ) { assertUuid ( x . kind , x . uuid ) ; return true ; } else { throw new Error ( "s" + JSON . stringify ( x ) ) ; } } export function isTaggedResource ( x ) : x is TaggedResource { const isOk = ( isObject ( x ) && isString ( get ( x , "s" ) ) && isString ( get ( x , "s" ) ) && isObject ( get ( x , "s" ) ) ) ; if ( isOk ) { return true ; } else { console . error ( JSON . stringify ( x ) ) ; return false ; } } const is = ( r ) => function isOfTag ( x ) : x is TaggedResource { const safe = ( sanityCheck ( x ) && isTaggedResource ( x ) && x . kind == r ) ; if ( ! safe ) { if ( x ) { throw new Error ( "s" ) ; } } return safe ; } ; function isTaggedPoint ( x : { } ) : x is PointerType { return ( is ( "s" ) ( x ) ) && ( x . kind === "s" ) ; } export let isTaggedRegimen = ( x ) : x is TaggedRegimen => is ( "s" ) ( x ) ; export let isTaggedSequence = ( x ) : x is TaggedSequence => is ( "s" ) ( x ) ; export let isTaggedTool = ( x ) : x is TaggedTool => is ( "s" ) ( x ) ; export let isTaggedFarmEvent = ( x ) : x is TaggedFarmEvent => is ( "s" ) ( x ) ; export let isTaggedToolSlotPointer = ( x ) : x is TaggedToolSlotPointer => { return isTaggedPoint ( x ) && ( x . body . pointer_type === "s" ) ; } ; export let isTaggedPlantPointer = ( x ) : x is TaggedPlantPointer => { return isTaggedPoint ( x ) && ( x . body . pointer_type === "s" ) ; } ; export let isTaggedGenericPointer = ( x ) : x is TaggedGenericPointer => { return isTaggedPoint ( x ) && ( x . body . pointer_type === "s" ) ; } ; export let isTaggedPlantTemplate = ( x ) : x is TaggedPlantTemplate => is ( "s" ) ( x ) ;	O O $any$ O $any$ O $any$ O $any$ O O O O O O $T[]$ O O O O O O $boolean$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $string$ O O O $object$ O O O $any$ O $any$ O O O O $SpecialStatus$ O $any[]$ O $any$ O O O O O $unknown[]$ O $T[]$ O $any$ O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O O O $unknown[]$ O $number$ O O O O $unknown[]$ O $boolean$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $complex$ O $object$ O O $object$ O $any$ O O O $complex$ O $object$ O O O $boolean$ O $object$ O $any$ O $object$ O $any$ O O O O O O O O O O $ErrorConstructor$ O O O $JSON$ O $complex$ O $never$ O O O O O O O $complex$ O $object$ O O $object$ O $any$ O O $any$ O O $any$ O $object$ O O $any$ O $any$ O $object$ O O O O O $any$ O $any$ O $object$ O O O O O $any$ O $any$ O $object$ O O O O O O O O $any$ O O O O O O O O $Console$ O $void$ O $JSON$ O $complex$ O $object$ O O O O O O O O O $complex$ O O $ResourceName$ O O O $complex$ O $object$ O O $object$ O $any$ O O $boolean$ O O $complex$ O $object$ O O $complex$ O $object$ O O $object$ O $any$ O $any$ O O O O O $boolean$ O O O O $object$ O O O O $ErrorConstructor$ O O O O O O O $boolean$ O O O O $complex$ O ${}$ O O O O O ${}$ O $any$ O O O $complex$ O O O O ${}$ O O O O ${}$ O $any$ O O O O O O O $complex$ O O $object$ O O $object$ O $any$ O $complex$ O O O O $object$ O O O O $complex$ O O $object$ O O $object$ O $any$ O $complex$ O O O O $object$ O O O O $complex$ O O $object$ O O $object$ O $any$ O $complex$ O O O O $object$ O O O O $complex$ O O $object$ O O $object$ O $any$ O $complex$ O O O O $object$ O O O O $complex$ O O $object$ O O $object$ O $any$ O O O $complex$ O $object$ O O O $object$ O $any$ O $any$ O O O O O O O O $complex$ O O $object$ O O $object$ O $any$ O O O $complex$ O $object$ O O O $object$ O $any$ O $any$ O O O O O O O O $complex$ O O $object$ O O $object$ O $any$ O O O $complex$ O $object$ O O O $object$ O $any$ O $any$ O O O O O O O O $complex$ O O $object$ O O $object$ O $any$ O $complex$ O O O O $object$ O O
import { UnsafeError } from "s" ; import { prettyPrintApiErrors } from "s" ; import { error } from "s" ; export function toastErrors ( { err } ) { return error ( prettyPrintApiErrors ( err ) ) ; }	O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $void$ O O $any$ $UnsafeError$ O O O $void$ O $any$ O $any$ O O O O
import { Farmbot } from "s" ; import { bail } from "s" ; import { set } from "s" ; import { AuthState } from "s" ; let device : Farmbot | undefined ; const secure = location . protocol === "s" ; export const maybeGetDevice = ( ) => device ; export const getDevice = ( ) : Farmbot => ( maybeGetDevice ( ) || bail ( "s" ) ) ; export function fetchNewDevice ( auth ) < Farmbot > { device = new Farmbot ( { token : auth . token . encoded , secure } ) ; set ( window , "s" , device ) ; return device . connect ( ) . then ( ( ) => device || bail ( "s" ) , ( ) => bail ( "s" ) ) ; }	O O $any$ O O O O O O $never$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O $boolean$ O $Location$ O $string$ O O O O O $any$ O O O O $any$ O O O $any$ O O O O $any$ O O $any$ O O O $never$ O O O O O O O $Promise$ O $AuthState$ O O $any$ O O $any$ O O $any$ O O $string$ O $AuthState$ O $Token$ O $string$ O $boolean$ O O O $any$ O $complex$ O O O $any$ O O O $any$ O $any$ O O O $any$ O O O O $any$ O $never$ O O O O O O O $never$ O O O O O O
import { AuthState } from "s" ; import { generateReducer } from "s" ; import { Actions } from "s" ; export let authReducer = generateReducer < AuthState | undefined > ( undefined ) . add < AuthState > ( Actions . REPLACE_TOKEN , ( _ , { payload } ) => { return payload ; } ) ;	O O $any$ O O O O O O $GeneratedReducer$ O O O O O O $any$ O O O O O O $generateReducer<AuthState>.GeneratedReducer$ O $GeneratedReducer$ O $any$ O O O O $undefined$ O O $generateReducer<AuthState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.REPLACE_TOKEN$ O O $AuthState$ O O $AuthState$ O O O O O $AuthState$ O O O O
import { SyncStatus } from "s" ; export enum SyncStrat { AUTO , MANUAL , OFFLINE } interface StratHints { fbosVersion ? : string ; autoSync : boolean ; } export function determineStrategy ( x ) { const { fbosVersion , autoSync } = x ; if ( ! fbosVersion ) { return SyncStrat . OFFLINE ; } const strat = autoSync ? "s" : "s" ; return SyncStrat [ strat ] ; } export interface OverrideHints { consistent : boolean ; syncStatus : SyncStatus | undefined ; fbosVersion : string | undefined ; autoSync : boolean ; } export function maybeNegateStatus ( x ) : SyncStatus | undefined { const { consistent , syncStatus , fbosVersion , autoSync } = x ; if ( consistent ) { return syncStatus ; } switch ( determineStrategy ( { autoSync , fbosVersion } ) ) { case SyncStrat . AUTO : return "s" ; case SyncStrat . MANUAL : return "s" ; case SyncStrat . OFFLINE : return "s" ; } }	O O $any$ O O O O O O $any$ O $SyncStrat.AUTO$ O $SyncStrat.MANUAL$ O $SyncStrat.OFFLINE$ O O $any$ O $string$ O O O O $boolean$ O O O O O O $SyncStrat$ O $StratHints$ O O O O $string$ O $boolean$ O O $StratHints$ O O O O $string$ O O O $any$ O $SyncStrat.OFFLINE$ O O O O O $boolean$ O O O O O O $any$ O O O O O O O $any$ O $boolean$ O O O $any$ O $any$ O O O $string$ O O O O O $boolean$ O O O O O O $any$ O $OverrideHints$ O O $any$ O O O O O $boolean$ O $any$ O $string$ O $boolean$ O O $OverrideHints$ O O O $boolean$ O O O $any$ O O O O $SyncStrat$ O O $boolean$ O $string$ O O O O O $any$ O $SyncStrat.AUTO$ O O O O O $any$ O $SyncStrat.MANUAL$ O O O O O $any$ O $SyncStrat.OFFLINE$ O O O O O O
import { generateReducer } from "s" ; import { Actions } from "s" ; import { ConnectionState , EdgeStatus } from "s" ; import { startPing , completePing , failPing } from "s" ; export const DEFAULT_STATE = { uptime : { "s" : undefined , "s" : undefined , "s" : undefined } , pings : { } , } ; export type PingResultPayload = { id : string , at : number } ; export let connectivityReducer = generateReducer < ConnectionState > ( DEFAULT_STATE ) . add < { id : string } > ( Actions . PING_START , ( s , { payload } ) => { return { ... s , pings : startPing ( s . pings , payload . id ) } ; } ) . add < PingResultPayload > ( Actions . PING_OK , ( s , { payload } ) => { s . pings = completePing ( s . pings , payload . id , payload . at ) ; s . uptime [ "s" ] = { state : "s" , at : payload . at } ; s . uptime [ "s" ] = { state : "s" , at : payload . at } ; return s ; } ) . add < PingResultPayload > ( Actions . PING_NO , ( s , { payload } ) => { s . pings = failPing ( s . pings , payload . id ) ; s . uptime [ "s" ] = { state : "s" , at : payload . at } ; return s ; } ) . add < EdgeStatus > ( Actions . NETWORK_EDGE_CHANGE , ( s , { payload } ) => { if ( payload . name == "s" ) { return s ; } else { s . uptime [ payload . name ] = payload . status ; return s ; } } ) ;	O O $GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $complex$ O $complex$ O $complex$ O O O O O O $ConnectionState$ O O $complex$ O O O O $undefined$ O O O $undefined$ O O O $undefined$ O O ${}$ O O O O O O O O $any$ O O $string$ O O O $number$ O O O O O O $generateReducer<ConnectionState>.GeneratedReducer$ O $GeneratedReducer$ O $any$ O O $ConnectionState$ O O $generateReducer<ConnectionState>.GeneratedReducer$ O O $string$ O O O O O $any$ O $Actions.PING_START$ O O $ConnectionState$ O O $complex$ O O O O O O O $ConnectionState$ O $complex$ O $complex$ O $ConnectionState$ O $complex$ O $complex$ O $string$ O O O O O O $generateReducer<ConnectionState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.PING_OK$ O O $ConnectionState$ O O $PingResultPayload$ O O O O $ConnectionState$ O $complex$ O $complex$ O $ConnectionState$ O $complex$ O $PingResultPayload$ O $string$ O $PingResultPayload$ O $number$ O O $ConnectionState$ O $complex$ O O O O O O O O O $number$ O $PingResultPayload$ O $number$ O O $ConnectionState$ O $complex$ O O O O O O O O O $number$ O $PingResultPayload$ O $number$ O O O $ConnectionState$ O O O O $generateReducer<ConnectionState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.PING_NO$ O O $ConnectionState$ O O $PingResultPayload$ O O O O $ConnectionState$ O $complex$ O $complex$ O $ConnectionState$ O $complex$ O $PingResultPayload$ O $string$ O O $ConnectionState$ O $complex$ O O O O O O O O O $number$ O $PingResultPayload$ O $number$ O O O $ConnectionState$ O O O O $generateReducer<ConnectionState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.NETWORK_EDGE_CHANGE$ O O $ConnectionState$ O O $EdgeStatus$ O O O O O O $EdgeStatus$ O $Edge$ O O O O O $ConnectionState$ O O O O $ConnectionState$ O $complex$ O $EdgeStatus$ O O O O $EdgeStatus$ O $ConnectionStatus$ O O $ConnectionState$ O O O O O
import { ConfigKey } from "s" ; import { McuParams } from "s" ; type Result = | { outcome : "s" , errorMessage : undefined } | { outcome : "s" , errorMessage : string } ; type Validation = ( key , val , state ) => Result ; type EdgeCaseList = Partial < Record < ConfigKey , Validation > > ; export const OK = { outcome : "s" , errorMessage : undefined } ; export const NO = ( errorMessage ) : Result => ( { outcome : "s" , errorMessage } ) ; export enum McuErrors { TOO_HIGH = "s" , TOO_LOW = "s" , DEFAULT = "s" } export const greaterThan = ( compareAgainst , errorMessage = McuErrors . TOO_LOW ) => ( _key , val , state ) : Result => { const minimum = state [ compareAgainst ] || 0 ; return ( val > minimum ) ? OK : NO ( errorMessage ) ; } ; export const lessThan = ( compareAgainst , errorMessage = McuErrors . TOO_HIGH ) => ( _key , val , state ) : Result => { const minimum = state [ compareAgainst ] || 0 ; return ( val < minimum ) ? OK : NO ( errorMessage ) ; } ; const edgeCases = { movement_max_spd_x : greaterThan ( "s" , McuErrors . TOO_LOW ) , movement_max_spd_y : greaterThan ( "s" , McuErrors . TOO_LOW ) , movement_max_spd_z : greaterThan ( "s" , McuErrors . TOO_LOW ) , movement_min_spd_x : lessThan ( "s" , McuErrors . TOO_HIGH ) , movement_min_spd_y : lessThan ( "s" , McuErrors . TOO_HIGH ) , movement_min_spd_z : lessThan ( "s" , McuErrors . TOO_HIGH ) , } ; export const mcuParamValidator = ( key , val , state < McuParams > ) => ( ok : ( ) => void , no ? : ( message ) => void ) : void => { const validator = edgeCases [ key ] ; const result = validator && validator ( key , val , state ) ; if ( result && result . outcome === "s" ) { return ( no && no ( result . errorMessage ) ) ; } else { return ok ( ) ; } } ;	O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O $undefined$ O O O O O O O O O $string$ O O O O O $any$ O O $ConfigKey$ O $number$ O $McuParams$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Result$ O O O O O O $undefined$ O $undefined$ O O O O $Result$ O O $string$ O O $any$ O O O O O O O $string$ O O O O O $any$ O $McuErrors.TOO_HIGH$ O O O $McuErrors.TOO_LOW$ O O O $McuErrors.DEFAULT$ O O O O O $Result$ O O $ConfigKey$ O $McuErrors$ O $any$ O $McuErrors.TOO_LOW$ O O O $ConfigKey$ O $number$ O $McuParams$ O O $any$ O O O $any$ O $any$ O $complex$ O O O O O O $number$ O $any$ O O $complex$ O $Result$ O $McuErrors$ O O O O O O $Result$ O O $ConfigKey$ O $McuErrors$ O $any$ O $McuErrors.TOO_HIGH$ O O O $ConfigKey$ O $number$ O $McuParams$ O O $any$ O O O $any$ O $any$ O $complex$ O O O O O O $number$ O $any$ O O $complex$ O $Result$ O $McuErrors$ O O O O O $EdgeCaseList$ O O $Result$ O $Result$ O O O $any$ O $McuErrors.TOO_LOW$ O O $Result$ O $Result$ O O O $any$ O $McuErrors.TOO_LOW$ O O $Result$ O $Result$ O O O $any$ O $McuErrors.TOO_LOW$ O O $Result$ O $Result$ O O O $any$ O $McuErrors.TOO_HIGH$ O O $Result$ O $Result$ O O O $any$ O $McuErrors.TOO_HIGH$ O O $Result$ O $Result$ O O O $any$ O $McuErrors.TOO_HIGH$ O O O O O O $void$ O O $ConfigKey$ O $number$ O $Partial$ O $any$ O O O O $void$ O O O O O O $void$ O O O $string$ O O O O O O O O O $Validation$ O $complex$ O $complex$ O O O $Result$ O $Validation$ O $Validation$ O $complex$ O $number$ O $any$ O O O O $Result$ O $Result$ O O O O O O O O $void$ O $void$ O $complex$ O $string$ O O O O O O O $void$ O O O O O O
import axios from "s" ; import { success , warning , info , error } from "s" ; import { getDevice } from "s" ; import { Everything } from "s" ; import { GithubRelease , MoveRelProps , MinOsFeatureLookup , SourceFwConfig , Axis } from "s" ; import { Thunk } from "s" ; import { McuParams , Configuration , TaggedFirmwareConfig , ParameterApplication , ALLOWED_PIN_MODES , FirmwareHardware } from "s" ; import { ControlPanelState } from "s" ; import { oneOf , versionOK , trim } from "s" ; import { Actions , Content } from "s" ; import { mcuParamValidator } from "s" ; import { edit , save as apiSave } from "s" ; import { CONFIG_DEFAULTS } from "s" ; import { Log } from "s" ; import { FbosConfig } from "s" ; import { FirmwareConfig } from "s" ; import { getFirmwareConfig , getFbosConfig } from "s" ; import { isObject , isString , get , noop } from "s" ; import { t } from "s" ; const ON = 0 , OFF = 0 ; export type ConfigKey = keyof McuParams ; export const EXPECTED_MAJOR = 0 ; export const EXPECTED_MINOR = 0 ; export const FEATURE_MIN_VERSIONS_URL = "s" + "s" ; const BAD_WORDS = [ "s" , "s" , "s" , "s" ] ; const MESSAGE : keyof Log = "s" ; export function isLog ( x ) : x is Log { const msg = get ( x , MESSAGE ) ; const yup = isObject ( x ) && isString ( msg ) ; if ( yup ) { if ( oneOf ( BAD_WORDS , msg . toUpperCase ( ) ) ) { console . error ( "s" + JSON . stringify ( x ) ) ; return false ; } return true ; } else { return false ; } } export const commandErr = ( noun = "s" ) => ( ) => error ( t ( `template` ) ) ; export const commandOK = ( noun = "s" ) => ( ) => { const msg = t ( noun ) + t ( "s" ) ; success ( msg , t ( "s" ) ) ; } ; export function checkControllerUpdates ( ) { const noun = t ( "s" ) ; commandOK ( noun ) ( ) ; getDevice ( ) . checkUpdates ( ) . catch ( commandErr ( noun ) ) ; } export function powerOff ( ) { const noun = t ( "s" ) ; getDevice ( ) . powerOff ( ) . then ( commandOK ( noun ) , commandErr ( noun ) ) ; } export function factoryReset ( ) { if ( ! confirm ( t ( Content . FACTORY_RESET_ALERT ) ) ) { return ; } getDevice ( ) . resetOS ( ) ; } export function reboot ( ) { const noun = t ( "s" ) ; getDevice ( ) . reboot ( ) . then ( commandOK ( noun ) , commandErr ( noun ) ) ; } export function restartFirmware ( ) { const noun = t ( "s" ) ; getDevice ( ) . rebootFirmware ( ) . then ( commandOK ( noun ) , commandErr ( noun ) ) ; } export function flashFirmware ( firmwareName ) { const noun = t ( "s" ) ; getDevice ( ) . flashFirmware ( firmwareName ) . then ( commandOK ( noun ) , commandErr ( noun ) ) ; } export function emergencyLock ( ) { const noun = t ( "s" ) ; getDevice ( ) . emergencyLock ( ) . then ( commandOK ( noun ) , commandErr ( noun ) ) ; } export function emergencyUnlock ( force = false ) { const noun = t ( "s" ) ; if ( force || confirm ( t ( `template` ) ) ) { getDevice ( ) . emergencyUnlock ( ) . then ( commandOK ( noun ) , commandErr ( noun ) ) ; } } export function sync ( ) { const noun = t ( "s" ) ; return function ( _dispatch , getState ) { const currentFBOSversion = getState ( ) . bot . hardware . informational_settings . controller_version ; const IS_OK = versionOK ( currentFBOSversion , EXPECTED_MAJOR , EXPECTED_MINOR ) ; if ( IS_OK ) { getDevice ( ) . sync ( ) . catch ( commandErr ( noun ) ) ; } else { if ( currentFBOSversion ) { badVersion ( ) ; } else { info ( t ( "s" ) , t ( "s" ) , "s" ) ; } } } ; } export function execSequence ( sequenceId : number | undefined , bodyVariables ? : ParameterApplication [ ] ) { const noun = t ( "s" ) ; if ( sequenceId ) { commandOK ( noun ) ( ) ; return getDevice ( ) . execSequence ( sequenceId , bodyVariables ) . catch ( ( x ) => { if ( x && ( typeof x == "s" ) && ( typeof x . message == "s" ) ) { error ( x . message ) ; } else { commandErr ( noun ) ( ) ; } } ) ; } else { throw new Error ( t ( "s" ) ) ; } } export function requestDiagnostic ( ) { const noun = t ( "s" ) ; return getDevice ( ) . dumpInfo ( ) . then ( commandOK ( noun ) , commandErr ( noun ) ) ; } const tagNameToVersionString = ( tagName ) : string => tagName . toLowerCase ( ) . replace ( "s" , "s" ) ; export const fetchLatestGHBetaRelease = ( url ) => ( dispatch ) => { const urlArray = url . split ( "s" ) ; const releasesURL = urlArray . splice ( 0 , urlArray . length - 0 ) . join ( "s" ) ; axios . get < GithubRelease [ ] > ( releasesURL ) . then ( resp => { const latestBeta = resp . data . filter ( x => x . tag_name . includes ( "s" ) || x . tag_name . includes ( "s" ) ) [ 0 ] ; const { tag_name , target_commitish } = latestBeta ; const version = tagNameToVersionString ( tag_name ) ; dispatch ( { type : Actions . FETCH_BETA_OS_UPDATE_INFO_OK , payload : { version , commit : target_commitish } } ) ; } ) . catch ( ferror => dispatch ( { type : "s" , payload : ferror } ) ) ; } ; export const fetchReleases = ( url , options = { beta : false } ) => ( dispatch ) => { axios . get < GithubRelease > ( url ) . then ( resp => { const { tag_name , target_commitish } = resp . data ; const version = tagNameToVersionString ( tag_name ) ; dispatch ( { type : options . beta ? Actions . FETCH_BETA_OS_UPDATE_INFO_OK : Actions . FETCH_OS_UPDATE_INFO_OK , payload : { version , commit : target_commitish } } ) ; } ) . catch ( ( ferror ) => { ! options . beta && error ( t ( "s" ) ) ; dispatch ( { type : options . beta ? "s" : "s" , payload : ferror } ) ; } ) ; } ; function validMinOsFeatureLookup ( x ) { return isObject ( x ) && Object . entries ( x ) . every ( ( [ key , val ] ) => typeof key === "s" && typeof val === "s" && val . split ( "s" ) . length > 0 ) ; } export let fetchMinOsFeatureData = ( url ) => ( dispatch ) => { axios . get < MinOsFeatureLookup > ( url ) . then ( resp => { const data = resp . data ; if ( validMinOsFeatureLookup ( data ) ) { dispatch ( { type : Actions . FETCH_MIN_OS_FEATURE_INFO_OK , payload : data } ) ; } else { console . log ( `template` + "s" ) ; } } ) . catch ( ( ferror ) => { dispatch ( { type : Actions . FETCH_MIN_OS_FEATURE_INFO_ERROR , payload : ferror } ) ; } ) ; } ; export function toggleControlPanel ( payload : keyof ControlPanelState ) { return { type : Actions . TOGGLE_CONTROL_PANEL_OPTION , payload } ; } export function bulkToggleControlPanel ( payload ) { return { type : Actions . BULK_TOGGLE_CONTROL_PANEL , payload } ; } export function MCUFactoryReset ( ) { if ( ! confirm ( t ( Content . MCU_RESET_ALERT ) ) ) { return ; } return getDevice ( ) . resetMCU ( ) . catch ( commandErr ( "s" ) ) ; } export function settingToggle ( name , sourceFwConfig , displayAlert ? : string | undefined ) { return function ( dispatch , getState : ( ) => Everything ) { if ( displayAlert ) { alert ( trim ( displayAlert ) ) ; } const update = { [ name ] : ( sourceFwConfig ( name ) . value === 0 ) ? ON : OFF } ; const firmwareConfig = getFirmwareConfig ( getState ( ) . resources . index ) ; const toggleFirmwareConfig = ( fwConfig ) => { dispatch ( edit ( fwConfig , update ) ) ; dispatch ( apiSave ( fwConfig . uuid ) ) ; } ; if ( firmwareConfig ) { return toggleFirmwareConfig ( firmwareConfig ) ; } } ; } export function moveRelative ( props ) { return getDevice ( ) . moveRelative ( props ) . then ( noop , commandErr ( "s" ) ) ; } export function moveAbs ( props ) { const noun = t ( "s" ) ; return getDevice ( ) . moveAbsolute ( props ) . then ( noop , commandErr ( noun ) ) ; } export function pinToggle ( pin_number ) { const noun = t ( "s" ) ; return getDevice ( ) . togglePin ( { pin_number } ) . then ( noop , commandErr ( noun ) ) ; } export function readPin ( pin_number , label , pin_mode ) { const noun = t ( "s" ) ; return getDevice ( ) . readPin ( { pin_number , label , pin_mode } ) . then ( noop , commandErr ( noun ) ) ; } export function homeAll ( speed ) { const noun = t ( "s" ) ; getDevice ( ) . home ( { axis : "s" , speed } ) . catch ( commandErr ( noun ) ) ; } export function findHome ( axis , speed = CONFIG_DEFAULTS . speed ) { const noun = t ( "s" ) ; getDevice ( ) . findHome ( { axis , speed } ) . catch ( commandErr ( noun ) ) ; } export function updateMCU ( key , val ) { return function ( dispatch , getState : ( ) => Everything ) { const firmwareConfig = getFirmwareConfig ( getState ( ) . resources . index ) ; const getParams = ( ) => { if ( firmwareConfig ) { return firmwareConfig . body ; } else { return getState ( ) . bot . hardware . mcu_params ; } } ; function proceed ( ) { if ( firmwareConfig ) { dispatch ( edit ( firmwareConfig , { [ key ] : val } as Partial < FirmwareConfig > ) ) ; dispatch ( apiSave ( firmwareConfig . uuid ) ) ; } } const dont = ( err ) => warning ( err ) ; const validate = mcuParamValidator ( key , parseInt ( val , 0 ) , getParams ( ) ) ; validate ( proceed , dont ) ; } ; } export function updateConfig ( config ) { return function ( dispatch , getState : ( ) => Everything ) { const fbosConfig = getFbosConfig ( getState ( ) . resources . index ) ; if ( fbosConfig ) { dispatch ( edit ( fbosConfig , config as Partial < FbosConfig > ) ) ; dispatch ( apiSave ( fbosConfig . uuid ) ) ; } } ; } export function changeStepSize ( integer ) { return { type : Actions . CHANGE_STEP_SIZE , payload : integer } ; } export function badVersion ( ) { info ( t ( "s" ) , t ( "s" ) , "s" ) ; }	O $any$ O O O O O $void$ O $void$ O $void$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $boolean$ O $boolean$ O $string$ O O O O O O $any$ O $any$ O O O O O O $void$ O O O O O O $ReduxAction<EditResourceParams>$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O $any$ O O $any$ O O O O O O O O O O O O O O O $string$ O O O O O O $string[]$ O O O O O O O O O O O O $complex$ O O $any$ O O O O O $complex$ O $unknown$ O O $unknown$ O $any$ O O $any$ O $any$ O $unknown$ O $complex$ O O O $any$ O $any$ O $unknown$ O O $any$ O $any$ O O O O $any$ O O O O $boolean$ O $string[]$ O $any$ O $any$ O O O O O $Console$ O $void$ O O O $JSON$ O $complex$ O $unknown$ O O O O O O O O O O O O O O O O O O O O $void$ O O $string$ O O O O O O O $void$ O $any$ O O O O O O O $void$ O O $string$ O O O O O O O O O $any$ O $any$ O $string$ O O $any$ O O O O $void$ O $any$ O $any$ O O O O O O O O O $void$ O O O O $any$ O $any$ O O O O $void$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O $void$ O $any$ O O O O O O $void$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O $void$ O $any$ O O $void$ O $any$ O O O O O O $void$ O O O O O O $boolean$ O $any$ O $any$ O $string$ O O O O O O O $any$ O O O $any$ O O O O O O $void$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O $void$ O $any$ O O $void$ O $any$ O O O O O O $void$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O $void$ O $any$ O O $void$ O $any$ O O O O O O $void$ O $FirmwareHardware$ O O O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O $any$ O $void$ O $any$ O O $void$ O $any$ O O O O O O $void$ O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O $void$ O $any$ O O $void$ O $any$ O O O O O O $void$ O $boolean$ O O O O O $any$ O $any$ O O O O O O $boolean$ O $boolean$ O $any$ O O O O O O $any$ O O O $any$ O O O $any$ O $void$ O $any$ O O $void$ O $any$ O O O O O O O $Thunk$ O O O O $any$ O $any$ O O O O O O O $Function$ O $GetState$ O O O $any$ O $GetState$ O O O $BotState$ O $any$ O $any$ O $any$ O O $boolean$ O $boolean$ O $any$ O O O O O O O O $boolean$ O O $any$ O O O $any$ O O O $any$ O $void$ O $any$ O O O O O O O O $any$ O O $void$ O O O O O O $void$ O $any$ O O O O $any$ O O O O O O O O O O O O O O $any$ O $number$ O O O O O $any[]$ O O $any$ O O O O O $any$ O $any$ O O O O O O $number$ O O $void$ O $any$ O O O O O $any$ O O O $any$ O $number$ O $any[]$ O O $any$ O O $Error$ O O O O O $Error$ O O O $Error$ O O O O O O $Error$ O $string$ O O O O O $void$ O $Error$ O $string$ O O O O O $void$ O $any$ O O O O O O O O O O O O O $ErrorConstructor$ O $any$ O O O O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O $any$ O $void$ O $any$ O O $void$ O $any$ O O O O O $string$ O O $string$ O O O O $string$ O $string$ O O O $complex$ O O O O O O O O $void$ O O $string$ O O O $Function$ O O O O $string[]$ O $string$ O $complex$ O O O O O $string$ O $string[]$ O $complex$ O O O $string[]$ O $number$ O O O O $string$ O O O O $any$ O $any$ O $any$ O O O O $string$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O $any$ O O $string$ O $string$ O $any$ O O $Function$ O O $Actions$ O $any$ O $Actions.FETCH_BETA_OS_UPDATE_INFO_OK$ O $complex$ O O $string$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $Function$ O O $string$ O O O $any$ O $any$ O O O O O O O O $void$ O O $string$ O $complex$ O O $boolean$ O O O O O O $Function$ O O O $any$ O $any$ O $any$ O O $string$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O $string$ O $string$ O $any$ O O $Function$ O O $Actions$ O $complex$ O $boolean$ O $any$ O $Actions.FETCH_BETA_OS_UPDATE_INFO_OK$ O $any$ O $Actions.FETCH_OS_UPDATE_INFO_OK$ O $complex$ O O $string$ O $any$ O $any$ O O O O O O O $any$ O O $any$ O O O O $complex$ O $boolean$ O $void$ O $any$ O O O O O $Function$ O O $string$ O $complex$ O $boolean$ O O O O O $any$ O $any$ O O O O O O O O O $boolean$ O $MinOsFeatureLookup$ O O O $any$ O $complex$ O O $ObjectConstructor$ O $complex$ O $complex$ O O $boolean$ O O O $string$ O $string$ O O O O $string$ O O O O $string$ O O O $string$ O $complex$ O O O O $number$ O O O O O O O $void$ O O $string$ O O O $Function$ O O O $any$ O $any$ O $any$ O O $string$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $boolean$ O $any$ O O O $Function$ O O $Actions$ O $any$ O $Actions.FETCH_MIN_OS_FEATURE_INFO_OK$ O $any$ O $any$ O O O O O O $Console$ O $void$ O O O O O O O O O O $any$ O O $any$ O O O $Function$ O O $Actions$ O $any$ O $Actions.FETCH_MIN_OS_FEATURE_INFO_ERROR$ O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O O O O $Actions$ O $any$ O $Actions.TOGGLE_CONTROL_PANEL_OPTION$ O O O O O O O $complex$ O $boolean$ O O O O $Actions$ O $any$ O $Actions.BULK_TOGGLE_CONTROL_PANEL$ O $boolean$ O O O O O $any$ O O O O O O $boolean$ O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O $any$ O O O $any$ O $void$ O O O O O O O O $void$ O $ConfigKey$ O $SourceFwConfig$ O $string$ O O O O O O O O O O $Function$ O $Everything$ O O O O $any$ O O O O $string$ O O $void$ O $string$ O $string$ O O O O O $complex$ O O O $complex$ O O O $SourceFwConfig$ O $complex$ O O $number$ O O O O O O O O O O $any$ O $any$ O $Everything$ O O O $RestResources$ O $ResourceIndex$ O O O $void$ O O $TaggedFirmwareConfig$ O O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O $complex$ O O O $Function$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $void$ O $any$ O O O O O O O O $any$ O $MoveRelProps$ O O O $any$ O O O $any$ O $MoveRelProps$ O O $any$ O $any$ O $void$ O O O O O O O O $any$ O $MoveRelProps$ O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $MoveRelProps$ O O $any$ O $any$ O $void$ O $any$ O O O O O O $any$ O $number$ O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $number$ O O O $any$ O $any$ O $void$ O $any$ O O O O O O $any$ O $number$ O $string$ O $ALLOWED_PIN_MODES$ O O O $any$ O $any$ O O O O O $any$ O O O $any$ O O $number$ O $string$ O $any$ O O O $any$ O $any$ O $void$ O $any$ O O O O O O $void$ O $number$ O O O $any$ O $any$ O O O O $any$ O O O $any$ O O $string$ O O O $number$ O O O $any$ O $void$ O $any$ O O O O O O $void$ O $Axis$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O $any$ O O $Axis$ O $any$ O O O $any$ O $void$ O $any$ O O O O O O $void$ O $ConfigKey$ O $string$ O O O O O $Function$ O $Everything$ O O O O $any$ O O O $any$ O $any$ O $Everything$ O O O $RestResources$ O $ResourceIndex$ O O O $any$ O O O O O O O $any$ O O O $any$ O $any$ O O O O O $Everything$ O O O $BotState$ O $any$ O $any$ O O O O O $void$ O O O O O $any$ O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O O O $complex$ O O $string$ O O $any$ O $any$ O O O O $Function$ O $any$ O $any$ O $any$ O O O O O O $void$ O O $string$ O O $void$ O $string$ O O O $void$ O $void$ O $complex$ O $number$ O $string$ O O O O $any$ O O O O $void$ O $void$ O $void$ O O O O O O O $void$ O $Configuration$ O O O O O $Function$ O $Everything$ O O O O $any$ O O O $any$ O $any$ O $Everything$ O O O $RestResources$ O $ResourceIndex$ O O O O $any$ O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O $any$ O $any$ O $any$ O O O O $Function$ O $any$ O $any$ O $any$ O O O O O O O O O $complex$ O $number$ O O O O $Actions$ O $any$ O $Actions.CHANGE_STEP_SIZE$ O $number$ O $number$ O O O O O $void$ O O O $void$ O $any$ O O O O $any$ O O O O O O O O
import { Actions } from "s" ; import { Edge , EdgeStatus } from "s" ; import { ReduxAction } from "s" ; type NetChange = ReduxAction < EdgeStatus > ; const change = ( state : "s" | "s" ) => ( name , at = ( new Date ( ) ) . getTime ( ) ) : NetChange => { return { type : Actions . NETWORK_EDGE_CHANGE , payload : { name , status : { state , at } } } ; } ; export const networkUp = change ( "s" ) ; export let networkDown = change ( "s" ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $ReduxAction<EdgeStatus>$ O O $NetworkState$ O O O O O O O $Edge$ O $number$ O O O $DateConstructor$ O O O O $number$ O O O O $any$ O O O O $Actions.NETWORK_EDGE_CHANGE$ O $any$ O $Actions.NETWORK_EDGE_CHANGE$ O $complex$ O O $Edge$ O $complex$ O O $NetworkState$ O $number$ O O O O O O O O $ReduxAction<EdgeStatus>$ O $ReduxAction<EdgeStatus>$ O O O O O O $ReduxAction<EdgeStatus>$ O $ReduxAction<EdgeStatus>$ O O O O
import { store } from "s" ; import { networkUp , networkDown } from "s" ; import { Edge } from "s" ; import { Actions } from "s" ; const SLOWDOWN_TIME = 0 ; export const networkUptimeThrottleStats < Edge , number > = { "s" : 0 , "s" : 0 , "s" : 0 } ; function shouldThrottle ( edge , now ) { if ( edge === "s" ) { return true ; } const then = networkUptimeThrottleStats [ edge ] ; const diff = now - then ; return diff < SLOWDOWN_TIME ; } function bumpThrottle ( edge , now ) { networkUptimeThrottleStats [ edge ] = now ; } export const dispatchQosStart = ( id ) => { store . dispatch ( { type : Actions . PING_START , payload : { id } } ) ; } ; export let dispatchNetworkUp = ( edge , at ) => { if ( shouldThrottle ( edge , at ) ) { return ; } store . dispatch ( networkUp ( edge , at ) ) ; bumpThrottle ( edge , at ) ; } ; export let dispatchNetworkDown = ( edge , at ) => { if ( shouldThrottle ( edge , at ) ) { return ; } store . dispatch ( networkDown ( edge , at ) ) ; bumpThrottle ( edge , at ) ; } ; export const pingOK = ( id , at ) => { const action = { type : Actions . PING_OK , payload : { id , at } } ; store . dispatch ( action ) ; } ; export const pingNO = ( id , at ) => { const action = { type : Actions . PING_NO , payload : { id , at } } ; store . dispatch ( action ) ; } ;	O O $any$ O O O O O O $ReduxAction<EdgeStatus>$ O $ReduxAction<EdgeStatus>$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O $Record$ O $any$ O O O O O O O O O O O O O O O O O O O $boolean$ O $Edge$ O $number$ O O O O $Edge$ O O O O O O O O O $number$ O $complex$ O O O O O $number$ O $number$ O $number$ O O $number$ O O O O O $void$ O $Edge$ O $number$ O O $complex$ O $Edge$ O O $number$ O O O O $void$ O O $string$ O O O $any$ O $any$ O O $Actions$ O $any$ O $Actions.PING_START$ O $complex$ O O $string$ O O O O O O O O $void$ O O $Edge$ O $number$ O O O O O $boolean$ O $Edge$ O $number$ O O O O O O $any$ O $any$ O $ReduxAction<EdgeStatus>$ O $Edge$ O $number$ O O O $void$ O $Edge$ O $number$ O O O O O O $void$ O O $Edge$ O $number$ O O O O O $boolean$ O $Edge$ O $number$ O O O O O O $any$ O $any$ O $ReduxAction<EdgeStatus>$ O $Edge$ O $number$ O O O $void$ O $Edge$ O $number$ O O O O O O $void$ O O $string$ O $number$ O O O O $complex$ O O $Actions$ O $any$ O $Actions.PING_OK$ O $complex$ O O $string$ O $number$ O O O $any$ O $any$ O $complex$ O O O O O O $void$ O O $string$ O $number$ O O O O $complex$ O O $Actions$ O $any$ O $Actions.PING_NO$ O $complex$ O O $string$ O $number$ O O O $any$ O $any$ O $complex$ O O O O
import { GetState } from "s" ; import { handleCreateOrUpdate } from "s" ; import { maybeDetermineUuid } from "s" ; import { destroyOK } from "s" ; import { MqttDataResult } from "s" ; import { TaggedResource } from "s" ; export function handleInbound ( dispatch , getState , data < TaggedResource > ) { switch ( data . status ) { case "s" : case "s" : return ; case "s" : return handleCreateOrUpdate ( dispatch , getState , data ) ; case "s" : const i = getState ( ) . resources . index ; const r = i . references [ maybeDetermineUuid ( i , data . kind , data . id ) || "s" ] ; return r ? dispatch ( destroyOK ( r ) ) : undefined ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $Function$ O $GetState$ O $MqttDataResult$ O $any$ O O O O O $MqttDataResult<any>$ O O O O O O O O O O O O O O O O $any$ O $Function$ O $GetState$ O $UpdateMqttData<any>$ O O O O O O $ResourceIndex$ O $GetState$ O O O $RestResources$ O $ResourceIndex$ O O $any$ O $ResourceIndex$ O $any$ O $any$ O $ResourceIndex$ O $DeleteMqttData<any>$ O $any$ O $DeleteMqttData<any>$ O $number$ O O O O O O $any$ O $Function$ O $complex$ O $any$ O O O $undefined$ O O O
import { GetState } from "s" ; import { maybeDetermineUuid } from "s" ; import { TaggedResource , SpecialStatus } from "s" ; import { overwrite , init } from "s" ; import { handleInbound } from "s" ; import { SyncPayload , MqttDataResult , Reason , UpdateMqttData } from "s" ; import { outstandingRequests } from "s" ; import { newTaggedResource } from "s" ; export function decodeBinary ( payload ) { return JSON . parse ( ( payload ) . toString ( ) ) ; } const SKIP_THESE = [ "s" ] ; export function routeMqttData ( chan , payload ) < TaggedResource > { if ( ! ( chan . split ( "s" ) [ 0 ] == "s" ) ) { return { status : "s" } ; } const parts = chan . split ( "s" ) ; if ( parts . length !== 0 ) { return { status : "s" , reason : Reason . BAD_CHAN } ; } const id = parseInt ( parts . pop ( ) || "s" , 0 ) ; const kind = parts . pop ( ) as TaggedResource [ "s" ] ; if ( SKIP_THESE . includes ( kind ) ) { return { status : "s" } ; } const { body , args } = decodeBinary ( payload ) ; if ( body ) { return { status : "s" , body , kind : kind , id , sessionId : args . label } ; } else { return { status : "s" , kind : kind , id } ; } } export function asTaggedResource ( data < TaggedResource > ) { return newTaggedResource ( data . kind , data . body ) [ 0 ] ; } export const handleCreate = ( data < TaggedResource > ) => init ( data . kind , data . body , true ) ; export const handleUpdate = ( d < TaggedResource > , uuid ) => { const tr = asTaggedResource ( d ) ; tr . uuid = uuid ; return overwrite ( tr , tr . body , SpecialStatus . SAVED ) ; } ; export function handleCreateOrUpdate ( dispatch , getState , data < TaggedResource > ) { const state = getState ( ) ; const { index } = state . resources ; const hasCopy = maybeDetermineUuid ( index , data . kind , data . id ) ; const isEcho = outstandingRequests . all . has ( data . sessionId ) ; const action = hasCopy ? handleUpdate ( data , hasCopy ) : handleCreate ( data ) ; return isEcho || dispatch ( action ) ; } export const autoSync = ( dispatch , getState ) => { return ( chan , payload ) => { handleInbound ( dispatch , getState , routeMqttData ( chan , payload ) ) ; } ; } ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O $ReduxAction<any>$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $NonSense$ O O O O O O $T[]$ O O O O O O $SyncPayload$ O $Buffer$ O O O $JSON$ O $any$ O O $any$ O O $any$ O O O O O O $string[]$ O O O O O O O $MqttDataResult$ O $string$ O $Buffer$ O O $any$ O O O O O O $string$ O $complex$ O O O O O O O O O O O O O O O O O O O O $string[]$ O $string$ O $complex$ O O O O O O $string[]$ O $number$ O O O O O O O O O O $Reason$ O $any$ O $Reason.BAD_CHAN$ O O O O $number$ O $number$ O $string[]$ O $string$ O O O O O O O O O $any$ O $string[]$ O $string$ O O O $any$ O O O O O O $string[]$ O $boolean$ O $any$ O O O O O O O O O O O O O $object$ O $complex$ O O $SyncPayload$ O $any$ O O O O $object$ O O O O O O O O $object$ O $any$ O $any$ O $number$ O $string$ O $complex$ O $string$ O O O O O O O O O O O $any$ O $any$ O $number$ O O O O O O $TaggedResource$ O $UpdateMqttData$ O $any$ O O O O $T[]$ O $UpdateMqttData<any>$ O $any$ O $UpdateMqttData<any>$ O $any$ O O O O O O O O $ReduxAction<any>$ O O $UpdateMqttData$ O $any$ O O O $ReduxAction<any>$ O $UpdateMqttData<any>$ O $any$ O $UpdateMqttData<any>$ O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O O $UpdateMqttData$ O $any$ O O $string$ O O O O $any$ O $any$ O $UpdateMqttData<any>$ O O $any$ O $any$ O $string$ O O $ReduxAction<EditResourceParams>$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $Function$ O $GetState$ O $UpdateMqttData$ O $any$ O O O O $Everything$ O $GetState$ O O O O O $ResourceIndex$ O O $Everything$ O $RestResources$ O O $any$ O $any$ O $ResourceIndex$ O $UpdateMqttData<any>$ O $any$ O $UpdateMqttData<any>$ O $number$ O O O $boolean$ O $NonSense$ O $Set<string>$ O $boolean$ O $UpdateMqttData<any>$ O $string$ O O O $ReduxAction<any>$ O $any$ O $ReduxAction<EditResourceParams>$ O $UpdateMqttData<any>$ O $any$ O O $ReduxAction<any>$ O $UpdateMqttData<any>$ O O O $boolean$ O $Function$ O $ReduxAction<any>$ O O O O O $void$ O O $Function$ O $GetState$ O O O O O $string$ O $Buffer$ O O O $any$ O $Function$ O $GetState$ O $MqttDataResult<any>$ O $string$ O $any$ O O O O O O O
import { DeviceAccountSettings } from "s" ; export const deviceIsThrottled = ( dev : Partial < DeviceAccountSettings > | undefined ) : boolean => { return ! ! ( dev && dev . throttled_at && dev . throttled_until ) ; } ;	O O $any$ O O O O O O $boolean$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O
import { TaggedLog } from "s" ; import { store } from "s" ; import { batchInitResources , bothUp } from "s" ; import { maybeGetDevice } from "s" ; import { deviceIsThrottled } from "s" ; export class BatchQueue { private queue : TaggedLog [ ] = [ ] ; constructor ( workRateMS ) { window . setInterval ( this . maybeWork , workRateMS ) ; } maybeWork = ( ) => { const { length } = this . queue ; length && this . work ( ) ; } work = ( ) => { const dev = maybeGetDevice ( store . getState ( ) . resources . index ) ; if ( ! deviceIsThrottled ( dev ? dev . body : undefined ) ) { store . dispatch ( batchInitResources ( this . queue ) ) ; } this . clear ( ) ; bothUp ( ) ; } push = ( resource ) => { this . queue . push ( resource ) ; } clear = ( ) => this . queue = [ ] ; } export const globalQueue = new BatchQueue ( 0 ) ;	O O $any$ O O O O O O $any$ O O O O O O $ReduxAction<any[]>$ O $void$ O O O O O O $any$ O O O O O O $boolean$ O O O O O O $any$ O O $any[]$ O $any$ O O O O O O O O $number$ O O $complex$ O $number)$ O O O $void$ O $number$ O O O $void$ O O O O O O O $number$ O O O O $any[]$ O $number$ O O O $void$ O O O O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $boolean$ O $any$ O $any$ O $any$ O $undefined$ O O O $any$ O $any$ O $ReduxAction<any[]>$ O O O $any[]$ O O O O O O $any[]$ O O O $void$ O O O O $void$ O O $TaggedLog$ O O O O O $any[]$ O $number$ O $any$ O O O $any[]$ O O O O O O $any[]$ O O O O O O O $BatchQueue$ O O $any$ O O O O
import { isLog } from "s" ; import { actOnChannelName , showLogOnScreen , speakLogAloud , initLog } from "s" ; import { GetState } from "s" ; import { Log } from "s" ; import { globalQueue } from "s" ; export const onLogs = ( _dispatch , getState ) => ( msg ) => { if ( isLog ( msg ) ) { actOnChannelName ( msg , "s" , showLogOnScreen ) ; actOnChannelName ( msg , "s" , speakLogAloud ( getState ) ) ; const log = initLog ( msg ) . payload ; if ( log . kind == "s" ) { globalQueue . push ( log ) ; return log ; } } } ;	O O $complex$ O O O O O O $any$ O $void$ O $void$ O $ReduxAction<any>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $BatchQueue$ O O O O O O $any$ O O $Function$ O $GetState$ O O O $Log$ O O O O O $complex$ O $any$ O O O $any$ O $any$ O O O $void$ O O $any$ O $any$ O O O $void$ O $GetState$ O O O O $any$ O $ReduxAction<any>$ O $any$ O O $any$ O O O $any$ O $any$ O O O O $BatchQueue$ O $void$ O $any$ O O O $any$ O O O O O
import { throttle } from "s" ; export const slowDown = ( fn : ( ... args : unknown [ ] ) => unknown ) => throttle ( fn , 0 , { leading : false , trailing : true } ) ;	O O $any$ O O O O O O $any$ O O $unknown$ O O O $unknown[]$ O O O O O O O O O $any$ O $unknown$ O O O O $boolean$ O O O $boolean$ O O O O O
import { fetchNewDevice , getDevice } from "s" ; import { dispatchNetworkUp , dispatchNetworkDown } from "s" ; import { Log } from "s" ; import { Farmbot , BotStateTree , TaggedResource } from "s" ; import { FbjsEventName } from "s" ; import { noop } from "s" ; import { success , error , info , warning , fun , busy } from "s" ; import { HardwareState } from "s" ; import { GetState , ReduxAction } from "s" ; import { Content , Actions } from "s" ; import { EXPECTED_MAJOR , EXPECTED_MINOR , commandOK , badVersion , commandErr } from "s" ; import { init } from "s" ; import { AuthState } from "s" ; import { autoSync } from "s" ; import { startPinging } from "s" ; import { talk } from "s" ; import { getWebAppConfigValue } from "s" ; import { BooleanSetting } from "s" ; import { versionOK } from "s" ; import { onLogs } from "s" ; import { ChannelName , MessageType } from "s" ; import { DeepPartial } from "s" ; import { slowDown } from "s" ; import { t } from "s" ; import { now } from "s" ; export const TITLE = ( ) => t ( "s" ) ; export const HACKY_FLAGS = { needVersionCheck : true , alreadyToldUserAboutMalformedMsg : false } ; export const incomingLegacyStatus = ( statusMessage ) => ( { type : Actions . LEGACY_BOT_CHANGE , payload : statusMessage } ) ; export const incomingStatus = ( payload < HardwareState > ) => ( { type : Actions . STATUS_UPDATE , payload } ) ; export function actOnChannelName ( log , channelName , cb : ( log ) => void ) { const CHANNELS : keyof Log = "s" ; const chanList : ChannelName [ ] = log [ CHANNELS ] || [ "s" ] ; return log && ( chanList . includes ( channelName ) ? cb ( log ) : noop ( ) ) ; } export function showLogOnScreen ( log ) { const toast = ( ) => { switch ( log . type ) { case MessageType . success : return success ; case MessageType . warn : return warning ; case MessageType . error : return error ; case MessageType . fun : return fun ; case MessageType . busy : return busy ; case MessageType . debug : return ( msg , title ) => info ( msg , title , "s" ) ; case MessageType . info : default : return info ; } } ; toast ( ) ( log . message , TITLE ( ) ) ; } export function speakLogAloud ( getState ) { return ( log ) => { const getConfigValue = getWebAppConfigValue ( getState ) ; const speak = getConfigValue ( BooleanSetting . enable_browser_speak ) ; if ( speak ) { talk ( log . message , navigator . language . slice ( 0 , 0 ) || "s" ) ; } } ; } export const initLog = ( log ) : ReduxAction < TaggedResource > => init ( "s" , log , true ) ; export const batchInitResources = ( payload : TaggedResource [ ] ) : ReduxAction < TaggedResource [ ] > => { return { type : Actions . BATCH_INIT , payload } ; } ; export const bothUp = ( ) => dispatchNetworkUp ( "s" , now ( ) ) ; export function readStatus ( ) { const noun = "s" ; return getDevice ( ) . readStatus ( ) . then ( ( ) => { commandOK ( noun ) ; } , commandErr ( noun ) ) ; } export const onOffline = ( ) => { dispatchNetworkDown ( "s" , now ( ) ) ; error ( t ( Content . MQTT_DISCONNECTED ) ) ; } ; export const changeLastClientConnected = ( bot ) => ( ) => { bot . setUserEnv ( { "s" : JSON . stringify ( new Date ( ) ) } ) . catch ( noop ) ; } ; const setBothUp = ( ) => bothUp ( ) ; const legacyChecks = ( getState ) => { const { controller_version } = getState ( ) . bot . hardware . informational_settings ; if ( HACKY_FLAGS . needVersionCheck && controller_version ) { const IS_OK = versionOK ( controller_version , EXPECTED_MAJOR , EXPECTED_MINOR ) ; if ( ! IS_OK ) { badVersion ( ) ; } HACKY_FLAGS . needVersionCheck = false ; } } ; export const onLegacyStatus = ( dispatch , getState ) => slowDown ( ( msg ) => { setBothUp ( ) ; dispatch ( incomingLegacyStatus ( msg ) ) ; legacyChecks ( getState ) ; } ) ; export const onStatus = ( dispatch , getState ) => ( msg < BotStateTree > ) => { setBothUp ( ) ; dispatch ( incomingStatus ( msg ) ) ; legacyChecks ( getState ) ; } ; type Client = { connected ? : boolean } ; export const onSent = ( client ) => ( ) => { const connected = ! ! client . connected ; const cb = connected ? dispatchNetworkUp : dispatchNetworkDown ; cb ( "s" , now ( ) ) ; } ; export function onMalformed ( ) { bothUp ( ) ; if ( ! HACKY_FLAGS . alreadyToldUserAboutMalformedMsg ) { warning ( t ( Content . MALFORMED_MESSAGE_REC_UPGRADE ) ) ; HACKY_FLAGS . alreadyToldUserAboutMalformedMsg = true ; } } export const onOnline = ( ) => { success ( t ( "s" ) , t ( "s" ) ) ; dispatchNetworkUp ( "s" , now ( ) ) ; } ; export const onReconnect = ( ) => warning ( t ( "s" ) , t ( "s" ) , "s" ) ; export function onPublicBroadcast ( payl ) { console . log ( FbjsEventName . publicBroadcast , payl ) ; if ( confirm ( t ( Content . FORCE_REFRESH_CONFIRM ) ) ) { location . assign ( window . location . origin || "s" ) ; } else { alert ( t ( Content . FORCE_REFRESH_CANCEL_WARNING ) ) ; } } export const attachEventListeners = ( bot , dispatch , getState ) => { if ( bot . client ) { startPinging ( bot ) ; readStatus ( ) . then ( changeLastClientConnected ( bot ) , noop ) ; bot . on ( FbjsEventName . online , onOnline ) ; bot . on ( FbjsEventName . online , ( ) => bot . readStatus ( ) . then ( noop , noop ) ) ; bot . on ( FbjsEventName . offline , onOffline ) ; bot . on ( FbjsEventName . sent , onSent ( bot . client ) ) ; bot . on ( FbjsEventName . logs , onLogs ( dispatch , getState ) ) ; bot . on ( FbjsEventName . legacy_status , onLegacyStatus ( dispatch , getState ) ) ; bot . on ( FbjsEventName . upsert , onStatus ( dispatch , getState ) ) ; bot . on ( FbjsEventName . malformed , onMalformed ) ; bot . client . subscribe ( FbjsEventName . publicBroadcast ) ; bot . on ( FbjsEventName . publicBroadcast , onPublicBroadcast ) ; bot . client . on ( "s" , autoSync ( dispatch , getState ) ) ; bot . client . on ( "s" , onReconnect ) ; } } ; export let connectDevice = ( token ) => ( dispatch , getState ) => fetchNewDevice ( token ) . then ( bot => attachEventListeners ( bot , dispatch , getState ) , onOffline ) ;	O O $Promise<any>$ O $any$ O O O O O O $void$ O $void$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O $void$ O $void$ O $void$ O O O O O O $ReduxAction<any>$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $complex$ O O O O O O $boolean$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $number$ O O O O O O $any$ O O O O $any$ O O O O O O $complex$ O O $boolean$ O O O $boolean$ O O O O O O $complex$ O O $HardwareState$ O O O O $Actions$ O $any$ O $Actions.LEGACY_BOT_CHANGE$ O $any$ O $any$ O O O O O $complex$ O O $DeepPartial$ O $any$ O O O O O $Actions$ O $any$ O $Actions.STATUS_UPDATE$ O $any$ O O O O O $any$ O $Log$ O $ChannelName$ O $void$ O O $Log$ O O O O O O $complex$ O O $any$ O O O O $any[]$ O $any$ O O O $any$ O $string$ O O O O O O O $any$ O O $any[]$ O $boolean$ O $any$ O O $void$ O $any$ O O $any$ O O O O O O O $void$ O $Log$ O O O $void$ O O O O O O O $any$ O $any$ O O O $any$ O $MessageType.success$ O O $void$ O O $any$ O $MessageType.warn$ O O $void$ O O $any$ O $MessageType.error$ O O $void$ O O $any$ O $MessageType.fun$ O O $void$ O O $any$ O $MessageType.busy$ O O $void$ O O $any$ O $MessageType.debug$ O O O $string$ O $string$ O O $void$ O $string$ O $string$ O O O O O $any$ O $MessageType.info$ O O O O $void$ O O O O $void$ O O O $any$ O $any$ O $any$ O O O O O O O $void$ O $GetState$ O O O O $Log$ O O O O $complex$ O $complex$ O $GetState$ O O O $complex$ O $complex$ O $complex$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O $Navigator$ O $string$ O $string$ O O O O O O O O O O O O O O O $ReduxAction<any>$ O O $Log$ O O $any$ O $any$ O O $ReduxAction<any>$ O O O $any$ O O O O O O $ReduxAction<any[]>$ O O $any[]$ O $any$ O O O O $any$ O $any$ O O O O O O O $Actions.BATCH_INIT$ O $any$ O $Actions.BATCH_INIT$ O $any[]$ O O O O O O $void$ O O O O $void$ O O O $number$ O O O O O O $any$ O O O O O O O O O $any$ O O O $any$ O O O $any$ O O O O O $void$ O O O O O O $void$ O O O O O O O O $void$ O O O O O $void$ O O O $number$ O O O O $void$ O $any$ O $any$ O $string$ O O O O O O O $void$ O O $Farmbot$ O O O O O O $any$ O $any$ O O O O $JSON$ O $complex$ O O $DateConstructor$ O O O O O O $any$ O $any$ O O O O O $void$ O O O O $void$ O O O O $void$ O O $GetState$ O O O O O $any$ O O $GetState$ O O O $BotState$ O $any$ O $any$ O O O $complex$ O $boolean$ O $any$ O O O $boolean$ O $boolean$ O $any$ O O O O O O O O O $boolean$ O O $void$ O O O O $complex$ O $boolean$ O O O O O O O O $any$ O O $Function$ O $GetState$ O O $any$ O O $BotStateTree$ O O O $void$ O O O $Function$ O $complex$ O $any$ O O O $void$ O $GetState$ O O O O O O O $void$ O O $Function$ O $GetState$ O O O $DeepPartial$ O $any$ O O O O $void$ O O O $Function$ O $complex$ O $any$ O O O $void$ O $GetState$ O O O O O $any$ O O $boolean$ O O O O O O O $void$ O O $Client$ O O O O O O O $boolean$ O O O $Client$ O $boolean$ O O $void$ O $boolean$ O $void$ O $void$ O $void$ O O O $number$ O O O O O O O O $void$ O O O $void$ O O O O O O $complex$ O $boolean$ O O $void$ O $any$ O $any$ O $string$ O O O $complex$ O $boolean$ O O O O O O O $void$ O O O O O $void$ O $any$ O O O O $any$ O O O O O $void$ O O O $number$ O O O O O O O O $void$ O O O O $void$ O $any$ O O O O $any$ O O O O O O O O O $void$ O $unknown$ O O $Console$ O $void$ O $any$ O $any$ O $unknown$ O O O O $boolean$ O $any$ O $any$ O $string$ O O O O $Location$ O $void$ O $complex$ O $Location$ O $string$ O O O O O O O $void$ O $any$ O $any$ O $string$ O O O O O O O $void$ O O $Farmbot$ O $Function$ O $GetState$ O O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $void$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $void$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $void$ O O $any$ O $any$ O $any$ O $any$ O $void$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $Function$ O $GetState$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $Function$ O $GetState$ O O O $any$ O $any$ O $any$ O $any$ O $void$ O $Function$ O $GetState$ O O O $any$ O $any$ O $any$ O $any$ O $void$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $void$ O O $any$ O $any$ O $any$ O O O $void$ O $Function$ O $GetState$ O O O $any$ O $any$ O $any$ O O O $void$ O O O O O O O $Promise<void>$ O O $AuthState$ O O O $Function$ O $GetState$ O O $Promise<any>$ O $AuthState$ O O O O $any$ O $void$ O $any$ O $Function$ O $GetState$ O O $void$ O O
import { BotState , HardwareState , ControlPanelState , OsUpdateInfo , MinOsFeatureLookup } from "s" ; import { generateReducer } from "s" ; import { Actions } from "s" ; import { maybeNegateStatus } from "s" ; import { ReduxAction } from "s" ; import { connectivityReducer , PingResultPayload } from "s" ; import { versionOK } from "s" ; import { EXPECTED_MAJOR , EXPECTED_MINOR } from "s" ; import { DeepPartial } from "s" ; import { incomingLegacyStatus } from "s" ; import { merge } from "s" ; const afterEach = ( state , a < { } > ) => { state . connectivity = connectivityReducer ( state . connectivity , a ) ; return state ; } ; export let initialState = ( ) : BotState => ( { consistent : true , stepSize : 0 , controlPanelState : { homing_and_calibration : false , motors : false , encoders_and_endstops : false , danger_zone : false , power_and_reset : false , pin_guard : false , diagnostic_dumps : false } , hardware : { gpio_registry : { } , mcu_params : { } , jobs : { } , location_data : { "s" : { x : undefined , y : undefined , z : undefined } , "s" : { x : undefined , y : undefined , z : undefined } , "s" : { x : undefined , y : undefined , z : undefined } , } , pins : { } , configuration : { } , informational_settings : { busy : false , locked : false , commit : "s" , target : "s" , env : "s" , node_name : "s" , firmware_commit : "s" } , user_env : { } , process_info : { farmwares : { } , } } , dirty : false , currentOSVersion : undefined , currentBetaOSVersion : undefined , minOsFeatureData : undefined , connectivity : { uptime : { "s" : undefined , "s" : undefined , "s" : undefined } , pings : { } } } ) ; export let botReducer = generateReducer < BotState > ( initialState ( ) ) . afterEach ( afterEach ) . add < boolean > ( Actions . SET_CONSISTENCY , ( s , a ) => { s . consistent = a . payload ; s . hardware . informational_settings . sync_status = maybeNegateStatus ( { consistent : s . consistent , syncStatus : s . hardware . informational_settings . sync_status , fbosVersion : s . hardware . informational_settings . controller_version , autoSync : ! ! s . hardware . configuration . auto_sync } ) ; return s ; } ) . add < void > ( Actions . SETTING_UPDATE_START , ( s ) => { s . isUpdating = true ; return s ; } ) . add < void > ( Actions . SETTING_UPDATE_END , ( s ) => { s . isUpdating = false ; return s ; } ) . add < number > ( Actions . CHANGE_STEP_SIZE , ( s , a ) => { return Object . assign ( { } , s , { stepSize : a . payload } ) ; } ) . add < keyof ControlPanelState > ( Actions . TOGGLE_CONTROL_PANEL_OPTION , ( s , a ) => { s . controlPanelState [ a . payload ] = ! s . controlPanelState [ a . payload ] ; return s ; } ) . add < boolean > ( Actions . BULK_TOGGLE_CONTROL_PANEL , ( s , a ) => { s . controlPanelState . homing_and_calibration = a . payload ; s . controlPanelState . motors = a . payload ; s . controlPanelState . encoders_and_endstops = a . payload ; s . controlPanelState . pin_guard = a . payload ; s . controlPanelState . danger_zone = a . payload ; return s ; } ) . add < OsUpdateInfo > ( Actions . FETCH_OS_UPDATE_INFO_OK , ( s , { payload } ) => { s . currentOSVersion = payload . version ; return s ; } ) . add < OsUpdateInfo > ( Actions . FETCH_BETA_OS_UPDATE_INFO_OK , ( s , { payload } ) => { s . currentBetaOSVersion = payload . version ; s . currentBetaOSCommit = payload . commit ; return s ; } ) . add < MinOsFeatureLookup > ( Actions . FETCH_MIN_OS_FEATURE_INFO_OK , ( s , { payload } ) => { s . minOsFeatureData = payload ; return s ; } ) . add < DeepPartial < HardwareState > > ( Actions . STATUS_UPDATE , ( s , { payload } ) => { s . hardware = merge ( s . hardware , payload ) ; legacyStatusHandler ( s , incomingLegacyStatus ( s . hardware ) ) ; return s ; } ) . add < HardwareState > ( Actions . LEGACY_BOT_CHANGE , legacyStatusHandler ) . add < void > ( Actions . STASH_STATUS , ( s ) => { stash ( s ) ; return s ; } ) . add < void > ( Actions . _RESOURCE_NO , ( s ) => { unstash ( s ) ; return s ; } ) . add < PingResultPayload > ( Actions . PING_OK , ( s ) => { const currentState = s . connectivity . uptime [ "s" ] ; const backOnline = currentState && currentState . state === "s" ; backOnline && unstash ( s ) ; return s ; } ) . add < PingResultPayload > ( Actions . PING_NO , ( s ) => { stash ( s ) ; s . hardware . informational_settings . sync_status = undefined ; return s ; } ) ; const stash = ( s ) => { const botStatus = s . hardware . informational_settings . sync_status ; botStatus && ( s . statusStash = botStatus ) ; } ; const unstash = ( s ) => s . hardware . informational_settings . sync_status = s . statusStash ; function legacyStatusHandler ( state , action < HardwareState > ) { const { payload } = action ; state . hardware = payload ; const { informational_settings } = state . hardware ; const syncStatus = informational_settings . sync_status ; if ( syncStatus === "s" ) { const emptyState = initialState ( ) ; state . hardware = emptyState . hardware ; state . hardware . informational_settings . sync_status = "s" ; return state ; } const info = { consistent : state . consistent , syncStatus , fbosVersion : informational_settings . controller_version , autoSync : ! ! state . hardware . configuration . auto_sync } ; state . consistent = info . consistent ; info . consistent = state . consistent ; const nextSyncStatus = maybeNegateStatus ( info ) ; versionOK ( informational_settings . controller_version , EXPECTED_MAJOR , EXPECTED_MINOR ) ; state . hardware . informational_settings . sync_status = nextSyncStatus ; return state ; }	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $generateReducer<ConnectionState>.GeneratedReducer$ O $any$ O O O O O O $boolean$ O O O O O O O O O O O O O O O $any$ O O O O O O $complex$ O O O O O O $any$ O O O O O $BotState$ O O $BotState$ O $ReduxAction$ O O O O O O O $BotState$ O $ConnectionState$ O $generateReducer<ConnectionState>.GeneratedReducer$ O $BotState$ O $ConnectionState$ O $ReduxAction<{}>$ O O O $BotState$ O O O O O $BotState$ O O O O $any$ O O O $true$ O O O $number$ O O O $complex$ O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O $complex$ O O O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O ${}$ O O O O ${}$ O O O O $complex$ O O $boolean$ O O O $boolean$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O ${}$ O O O O $complex$ O O ${}$ O O O O O O O $false$ O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $complex$ O O $complex$ O O O O $undefined$ O O O $undefined$ O O O $undefined$ O O ${}$ O O O O O O O O O $generateReducer<BotState>.GeneratedReducer$ O $GeneratedReducer$ O $any$ O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O O $generateReducer<BotState>.GeneratedReducer$ O O O O $any$ O $Actions.SET_CONSISTENCY$ O O $BotState$ O $ReduxAction<boolean>$ O O O $BotState$ O $boolean$ O $ReduxAction<boolean>$ O $boolean$ O $BotState$ O $any$ O $any$ O $any$ O $any$ O O $boolean$ O $BotState$ O $boolean$ O $any$ O $BotState$ O $any$ O $any$ O $any$ O $any$ O $BotState$ O $any$ O $any$ O $any$ O $boolean$ O O O $BotState$ O $any$ O $any$ O $any$ O O O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O O O O $any$ O $Actions.SETTING_UPDATE_START$ O O $BotState$ O O O $BotState$ O $boolean$ O O O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O O O O $any$ O $Actions.SETTING_UPDATE_END$ O O $BotState$ O O O $BotState$ O $boolean$ O O O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O O O O $any$ O $Actions.CHANGE_STEP_SIZE$ O O $BotState$ O $ReduxAction<number>$ O O O O $ObjectConstructor$ O O O O O O $BotState$ O O $number$ O $ReduxAction<number>$ O $number$ O O O O O O $generateReducer<BotState>.GeneratedReducer$ O O $any$ O O $any$ O $Actions.TOGGLE_CONTROL_PANEL_OPTION$ O O $BotState$ O $complex$ O O O $BotState$ O $ControlPanelState$ O $complex$ O O O O O $BotState$ O $ControlPanelState$ O $complex$ O O O O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O O O O $any$ O $Actions.BULK_TOGGLE_CONTROL_PANEL$ O O $BotState$ O $ReduxAction<boolean>$ O O O $BotState$ O $ControlPanelState$ O $boolean$ O $ReduxAction<boolean>$ O $boolean$ O $BotState$ O $ControlPanelState$ O $boolean$ O $ReduxAction<boolean>$ O $boolean$ O $BotState$ O $ControlPanelState$ O $boolean$ O $ReduxAction<boolean>$ O $boolean$ O $BotState$ O $ControlPanelState$ O $boolean$ O $ReduxAction<boolean>$ O $boolean$ O $BotState$ O $ControlPanelState$ O $boolean$ O $ReduxAction<boolean>$ O $boolean$ O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.FETCH_OS_UPDATE_INFO_OK$ O O $BotState$ O O $OsUpdateInfo$ O O O O $BotState$ O $string$ O $OsUpdateInfo$ O $string$ O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.FETCH_BETA_OS_UPDATE_INFO_OK$ O O $BotState$ O O $OsUpdateInfo$ O O O O $BotState$ O $string$ O $OsUpdateInfo$ O $string$ O $BotState$ O $string$ O $OsUpdateInfo$ O $string$ O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.FETCH_MIN_OS_FEATURE_INFO_OK$ O O $BotState$ O O $complex$ O O O O $BotState$ O $complex$ O $complex$ O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O $any$ O $any$ O O O $any$ O $Actions.STATUS_UPDATE$ O O $BotState$ O O $any$ O O O O $BotState$ O $any$ O $any$ O $BotState$ O $any$ O $any$ O O $BotState$ O $BotState$ O $complex$ O $BotState$ O $any$ O O O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.LEGACY_BOT_CHANGE$ O $BotState$ O O $generateReducer<BotState>.GeneratedReducer$ O O O O $any$ O $Actions.STASH_STATUS$ O O $BotState$ O O O $void$ O $BotState$ O O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O O O O $any$ O $Actions._RESOURCE_NO$ O O $BotState$ O O O $any$ O $BotState$ O O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.PING_OK$ O O $BotState$ O O O O $ConnectionStatus$ O $BotState$ O $ConnectionState$ O $complex$ O O O O O $boolean$ O $ConnectionStatus$ O $ConnectionStatus$ O $NetworkState$ O O O $boolean$ O $any$ O $BotState$ O O O $BotState$ O O O O $generateReducer<BotState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.PING_NO$ O O $BotState$ O O O $void$ O $BotState$ O O $BotState$ O $any$ O $any$ O $any$ O $undefined$ O O $BotState$ O O O O O $void$ O O $BotState$ O O O O $any$ O $BotState$ O $any$ O $any$ O $any$ O $any$ O O $BotState$ O $any$ O $any$ O O O O O $any$ O O $BotState$ O O $BotState$ O $any$ O $any$ O $any$ O $BotState$ O $any$ O O $BotState$ O $BotState$ O $ReduxAction$ O $any$ O O O O O $any$ O O $ReduxAction<any>$ O $BotState$ O $any$ O $any$ O O O $any$ O O $BotState$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O O O O O $BotState$ O $BotState$ O O O $BotState$ O $any$ O $BotState$ O $any$ O $BotState$ O $any$ O $any$ O $any$ O O O O $BotState$ O O O $complex$ O O $boolean$ O $BotState$ O $boolean$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O $BotState$ O $any$ O $any$ O $any$ O O $BotState$ O $boolean$ O $complex$ O $boolean$ O $complex$ O $boolean$ O $BotState$ O $boolean$ O O $any$ O $any$ O $complex$ O O $boolean$ O $any$ O $any$ O O O O O O $BotState$ O $any$ O $any$ O $any$ O $any$ O O $BotState$ O O
import { generateReducer } from "s" ; import { ChangeApiHost , ChangeApiPort , ConfigState } from "s" ; import { API } from "s" ; import { Actions } from "s" ; const initialState = { host : location . hostname , port : API . inferPort ( ) } ; export let configReducer = generateReducer < ConfigState > ( initialState ) . add < ChangeApiPort > ( Actions . CHANGE_API_PORT , ( s , { payload } ) => { s . port = payload . port . replace ( "s" , "s" ) ; return s ; } ) . add < ChangeApiHost > ( Actions . CHANGE_API_HOST , ( s , { payload } ) => { s . host = payload . host ; return s ; } ) ;	O O $GeneratedReducer$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $ConfigState$ O O $string$ O $Location$ O $string$ O $string$ O $any$ O $string$ O O O O O O $generateReducer<ConfigState>.GeneratedReducer$ O $GeneratedReducer$ O $any$ O O $ConfigState$ O O $generateReducer<ConfigState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.CHANGE_API_PORT$ O O $ConfigState$ O O $ChangeApiPort$ O O O O $ConfigState$ O $string$ O $ChangeApiPort$ O $string$ O $complex$ O O O O O O O $ConfigState$ O O O O $generateReducer<ConfigState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.CHANGE_API_HOST$ O O $ConfigState$ O O $ChangeApiHost$ O O O O $ConfigState$ O $string$ O $ChangeApiHost$ O $string$ O O $ConfigState$ O O O O
import { generateReducer } from "s" ; import { DraggableState , DataXfer } from "s" ; import { Actions } from "s" ; const INITIAL_STATE = { dataTransfer : { } } ; export let draggableReducer = generateReducer < DraggableState > ( INITIAL_STATE ) . add < DataXfer > ( Actions . PUT_DATA_XFER , ( s , { payload } ) => { s . dataTransfer [ payload . uuid ] = payload ; return s ; } ) . add < string > ( Actions . DROP_DATA_XFER , ( s , { payload } ) => { delete s . dataTransfer [ payload ] ; return s ; } ) ;	O O $GeneratedReducer$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $DraggableState$ O O ${}$ O O O O O O O $generateReducer<DraggableState>.GeneratedReducer$ O $GeneratedReducer$ O $any$ O O $DraggableState$ O O $generateReducer<DraggableState>.GeneratedReducer$ O $any$ O O $any$ O $Actions.PUT_DATA_XFER$ O O $DraggableState$ O O $DataXfer$ O O O O $DraggableState$ O $complex$ O $DataXfer$ O $string$ O O $DataXfer$ O O $DraggableState$ O O O O $generateReducer<DraggableState>.GeneratedReducer$ O O O O $any$ O $Actions.DROP_DATA_XFER$ O O $DraggableState$ O O $string$ O O O O O $DraggableState$ O $complex$ O $string$ O O O $DraggableState$ O O O O
import { generateReducer } from "s" ; import { RestResources } from "s" ; import { indexUpsert , mutateSpecialStatus , findByUuid , indexRemove , initResourceReducer , afterEach , beforeEach } from "s" ; import { TaggedResource , SpecialStatus } from "s" ; import { Actions } from "s" ; import { EditResourceParams } from "s" ; import { defensiveClone , equals } from "s" ; import { merge } from "s" ; import { SyncBodyContents } from "s" ; import { GeneralizedError } from "s" ; import { initialState as helpState } from "s" ; import { initialState as designerState } from "s" ; import { farmwareState } from "s" ; import { initialState as regimenState } from "s" ; import { initialState as sequenceState } from "s" ; import { initialState as alertState } from "s" ; export const emptyState = ( ) : RestResources => { return { consumers : { sequences : sequenceState , regimens : regimenState , farm_designer : designerState , farmware : farmwareState , help : helpState , alerts : alertState } , loaded : [ ] , index : { all : { } , byKind : { Alert : { } , Crop : { } , Device : { } , DiagnosticDump : { } , FarmEvent : { } , FarmwareEnv : { } , FarmwareInstallation : { } , FbosConfig : { } , FirmwareConfig : { } , Image : { } , Log : { } , Peripheral : { } , PinBinding : { } , Plant : { } , PlantTemplate : { } , Point : { } , PointGroup : { } , Regimen : { } , SavedGarden : { } , Sensor : { } , SensorReading : { } , Sequence : { } , Tool : { } , User : { } , WebAppConfig : { } , WebcamFeed : { } , } , byKindAndId : { } , references : { } , sequenceMetas : { } , inUse : { "s" : { } , "s" : { } , "s" : { } , "s" : { } , "s" : { } } } } ; } ; export let resourceReducer = generateReducer < RestResources > ( emptyState ( ) ) . beforeEach ( beforeEach ) . afterEach ( afterEach ) . add < TaggedResource > ( Actions . SAVE_RESOURCE_OK , ( s , { payload } ) => { indexUpsert ( s . index , [ payload ] , "s" ) ; mutateSpecialStatus ( payload . uuid , s . index , SpecialStatus . SAVED ) ; return s ; } ) . add < EditResourceParams > ( Actions . EDIT_RESOURCE , ( s , { payload } ) => { const { update } = payload ; const target = findByUuid ( s . index , payload . uuid ) ; const before = defensiveClone ( target . body ) ; merge ( target , { body : update } ) ; const didChange = ! equals ( before , target . body ) ; if ( didChange ) { mutateSpecialStatus ( target . uuid , s . index , SpecialStatus . DIRTY ) ; indexUpsert ( s . index , [ target ] , "s" ) ; } return s ; } ) . add < EditResourceParams > ( Actions . OVERWRITE_RESOURCE , ( s , { payload } ) => { const { uuid , update , specialStatus } = payload ; const original = findByUuid ( s . index , uuid ) ; original . body = update ; indexUpsert ( s . index , [ original ] , "s" ) ; mutateSpecialStatus ( uuid , s . index , specialStatus ) ; return s ; } ) . add < SyncBodyContents < TaggedResource > > ( Actions . RESOURCE_READY , ( s , { payload } ) => { ! s . loaded . includes ( payload . kind ) && s . loaded . push ( payload . kind ) ; indexUpsert ( s . index , payload . body , "s" ) ; return s ; } ) . add < TaggedResource > ( Actions . REFRESH_RESOURCE_OK , ( s , { payload } ) => { indexUpsert ( s . index , [ payload ] , "s" ) ; mutateSpecialStatus ( payload . uuid , s . index ) ; return s ; } ) . add < TaggedResource > ( Actions . DESTROY_RESOURCE_OK , ( s , { payload } ) => { indexRemove ( s . index , payload ) ; return s ; } ) . add < GeneralizedError > ( Actions . _RESOURCE_NO , ( s , { payload } ) => { merge ( findByUuid ( s . index , payload . uuid ) , payload ) ; mutateSpecialStatus ( payload . uuid , s . index , payload . statusBeforeError ) ; return s ; } ) . add < TaggedResource > ( Actions . INIT_RESOURCE , initResourceReducer ) . add < string > ( Actions . REFRESH_RESOURCE_START , ( s , a ) => { mutateSpecialStatus ( a . payload , s . index , SpecialStatus . SAVING ) ; return s ; } ) . add < GeneralizedError > ( Actions . REFRESH_RESOURCE_NO , ( s , { payload } ) => { mutateSpecialStatus ( payload . uuid , s . index ) ; return s ; } ) . add < TaggedResource > ( Actions . SAVE_RESOURCE_START , ( s , { payload } ) => { mutateSpecialStatus ( payload . uuid , s . index , SpecialStatus . SAVING ) ; return s ; } ) . add < TaggedResource [ ] > ( Actions . BATCH_INIT , ( s , { payload } ) => { return payload . reduce ( ( state , resource ) => { return initResourceReducer ( state , { type : Actions . INIT_RESOURCE , payload : resource } ) ; } , s ) ; } ) ;	O O $GeneratedReducer$ O O O O O O $any$ O O O O O O $IndexUpsert$ O $void$ O $any$ O $void$ O $RestResources$ O $RestResources$ O $RestResources$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $T$ O $boolean$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $HelpState$ O $HelpState$ O O O O O O $DesignerState$ O $DesignerState$ O O O O O O $FarmwareState$ O O O O O O $RegimenState$ O $RegimenState$ O O O O O O $SequenceReducerState$ O $SequenceReducerState$ O O O O O O $AlertReducerState$ O $AlertReducerState$ O O O O O O $RestResources$ O O O O $any$ O O O O $complex$ O O $SequenceReducerState$ O $SequenceReducerState$ O $RegimenState$ O $RegimenState$ O $DesignerState$ O $DesignerState$ O $FarmwareState$ O $FarmwareState$ O $HelpState$ O $HelpState$ O $AlertReducerState$ O $AlertReducerState$ O O $undefined[]$ O O O O O O O ${}$ O O O O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O O O ${}$ O O O O ${}$ O O O O ${}$ O O O O $complex$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $generateReducer<RestResources>.GeneratedReducer$ O $GeneratedReducer$ O $any$ O O $RestResources$ O O O O $generateReducer<RestResources>.GeneratedReducer$ O $RestResources$ O O $generateReducer<RestResources>.GeneratedReducer$ O $RestResources$ O O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O O $any$ O $Actions.SAVE_RESOURCE_OK$ O O $RestResources$ O O $any$ O O O O $IndexUpsert$ O $RestResources$ O $ResourceIndex$ O O $any$ O O O O O $void$ O $any$ O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $any$ O O O $RestResources$ O O O O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O O $any$ O $Actions.EDIT_RESOURCE$ O O $RestResources$ O O $EditResourceParams$ O O O O O O $object$ O O $EditResourceParams$ O O $any$ O $any$ O $RestResources$ O $ResourceIndex$ O $EditResourceParams$ O $string$ O O O $any$ O $T$ O $any$ O $any$ O O $any$ O $any$ O O $object$ O $object$ O O O O $boolean$ O O $boolean$ O $any$ O $any$ O $any$ O O O O $boolean$ O O $void$ O $any$ O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $any$ O O $IndexUpsert$ O $RestResources$ O $ResourceIndex$ O O $any$ O O O O O O O $RestResources$ O O O O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O O $any$ O $Actions.OVERWRITE_RESOURCE$ O O $RestResources$ O O $EditResourceParams$ O O O O O O $string$ O $object$ O $any$ O O $EditResourceParams$ O O $any$ O $any$ O $RestResources$ O $ResourceIndex$ O $string$ O O $any$ O $any$ O $object$ O $IndexUpsert$ O $RestResources$ O $ResourceIndex$ O O $any$ O O O O O $void$ O $string$ O $RestResources$ O $ResourceIndex$ O $any$ O O O $RestResources$ O O O O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O $any$ O O O $any$ O $Actions.RESOURCE_READY$ O O $RestResources$ O O $SyncBodyContents<any>$ O O O O O $RestResources$ O $any[]$ O $boolean$ O $SyncBodyContents<any>$ O $any$ O O $RestResources$ O $any[]$ O $number$ O $SyncBodyContents<any>$ O $any$ O O $IndexUpsert$ O $RestResources$ O $ResourceIndex$ O $SyncBodyContents<any>$ O $any[]$ O O O O O $RestResources$ O O O O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O O $any$ O $Actions.REFRESH_RESOURCE_OK$ O O $RestResources$ O O $any$ O O O O $IndexUpsert$ O $RestResources$ O $ResourceIndex$ O O $any$ O O O O O $void$ O $any$ O $any$ O $RestResources$ O $ResourceIndex$ O O O $RestResources$ O O O O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O O $any$ O $Actions.DESTROY_RESOURCE_OK$ O O $RestResources$ O O $any$ O O O O $void$ O $RestResources$ O $ResourceIndex$ O $any$ O O O $RestResources$ O O O O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O O $any$ O $Actions._RESOURCE_NO$ O O $RestResources$ O O $GeneralizedError$ O O O O $any$ O $any$ O $RestResources$ O $ResourceIndex$ O $GeneralizedError$ O $string$ O O $GeneralizedError$ O O $void$ O $GeneralizedError$ O $string$ O $RestResources$ O $ResourceIndex$ O $GeneralizedError$ O $any$ O O O $RestResources$ O O O O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O O $any$ O $Actions.INIT_RESOURCE$ O $RestResources$ O O $generateReducer<RestResources>.GeneratedReducer$ O O O O $any$ O $Actions.REFRESH_RESOURCE_START$ O O $RestResources$ O $ReduxAction<string>$ O O O $void$ O $ReduxAction<string>$ O $string$ O $RestResources$ O $ResourceIndex$ O $any$ O $any$ O O O $RestResources$ O O O O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O O $any$ O $Actions.REFRESH_RESOURCE_NO$ O O $RestResources$ O O $GeneralizedError$ O O O O $void$ O $GeneralizedError$ O $string$ O $RestResources$ O $ResourceIndex$ O O O $RestResources$ O O O O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O O $any$ O $Actions.SAVE_RESOURCE_START$ O O $RestResources$ O O $any$ O O O O $void$ O $any$ O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $any$ O O O $RestResources$ O O O O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O O O O $any$ O $Actions.BATCH_INIT$ O O $RestResources$ O O $any[]$ O O O O O $any[]$ O $complex$ O O $any$ O $any$ O O O O $RestResources$ O $any$ O O $Actions.INIT_RESOURCE$ O $any$ O $Actions.INIT_RESOURCE$ O $any$ O $any$ O O O O O $RestResources$ O O O O O
import { authReducer as auth } from "s" ; import { botReducer as bot } from "s" ; import { configReducer as config } from "s" ; import { draggableReducer as draggable } from "s" ; import { combineReducers } from "s" ; import { ReduxAction } from "s" ; import { Session } from "s" ; import { resourceReducer as resources } from "s" ; import { Everything } from "s" ; import { Actions } from "s" ; export let reducers = combineReducers ( { auth , bot , config , draggable , resources , } ) ; export function rootReducer ( state , action < { } > ) { ( action . type === Actions . LOGOUT ) && Session . clear ( ) ; return reducers ( state , action ) ; }	O O $generateReducer<AuthState>.GeneratedReducer$ O $generateReducer<AuthState>.GeneratedReducer$ O O O O O O $generateReducer<BotState>.GeneratedReducer$ O $generateReducer<BotState>.GeneratedReducer$ O O O O O O $generateReducer<ConfigState>.GeneratedReducer$ O $generateReducer<ConfigState>.GeneratedReducer$ O O O O O O $generateReducer<DraggableState>.GeneratedReducer$ O $generateReducer<DraggableState>.GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $generateReducer<RestResources>.GeneratedReducer$ O $generateReducer<RestResources>.GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O $generateReducer<AuthState>.GeneratedReducer$ O $generateReducer<BotState>.GeneratedReducer$ O $generateReducer<ConfigState>.GeneratedReducer$ O $generateReducer<DraggableState>.GeneratedReducer$ O $generateReducer<RestResources>.GeneratedReducer$ O O O O O O $any$ O $Everything$ O $ReduxAction$ O O O O O O O $ReduxAction<{}>$ O $Actions$ O $any$ O $Actions.LOGOUT$ O O $any$ O $never$ O O O O $any$ O $Everything$ O $ReduxAction<{}>$ O O O
import { Everything } from "s" ; import { Store } from "s" ; import { EnvName } from "s" ; import { all } from "s" ; import { getWebAppConfig } from "s" ; import { TaggedResource , TaggedWebAppConfig } from "s" ; export function stopThem ( ) { return "s" ; } export function dontStopThem ( ) { } const shouldStop = ( allResources : TaggedResource [ ] , config : TaggedWebAppConfig | undefined ) => { const loggedIn = ! ! localStorage . getItem ( "s" ) ; const discardUnsaved = config && config . body . discard_unsaved ; const sequenceResources = allResources . filter ( r => r . kind === "s" ) ; const discardUnsavedSequences = config && config . body . discard_unsaved_sequences ; return loggedIn && areSomeDirty ( allResources ) && ! discardUnsaved && ( ! areSomeDirty ( sequenceResources ) || ! discardUnsavedSequences ) ; } ; const areSomeDirty = ( resources : TaggedResource [ ] ) => { const dirty = resources . filter ( r => ! ! r . specialStatus ) ; const total = dirty . length ; return total !== 0 ; } ; export function unsavedCheck ( state ) { const { index } = state . resources ; const resources = all ( index ) ; const conf = getWebAppConfig ( index ) ; window . onbeforeunload = shouldStop ( resources , conf ) ? stopThem : dontStopThem ; } export interface Subscription { fn : ( state ) => void ; env : EnvName ; } export let subscriptions : Subscription [ ] = [ { env : "s" , fn : unsavedCheck } ] ; export function registerSubscribers ( store ) { const ENV_LIST = [ process . env . NODE_ENV , "s" ] ; subscriptions . forEach ( function ( s ) { ENV_LIST . includes && ENV_LIST . includes ( s . env ) && store . subscribe ( ( ) => s . fn && s . fn ( store . getState ( ) ) ) ; } ) ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any[]$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $string$ O O O O O O O O O $void$ O O O O O $boolean$ O O $any[]$ O $any$ O O O $any$ O $any$ O O O O O O $boolean$ O O O $Storage$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $any[]$ O $complex$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $boolean$ O $boolean$ O $any[]$ O O O $any$ O O O $boolean$ O $any[]$ O O O $any$ O O O O O $boolean$ O O $any[]$ O $any$ O O O O O O $any[]$ O $any[]$ O $complex$ O $any$ O O O $any$ O $any$ O O O $number$ O $any[]$ O $number$ O O $number$ O O O O O O O $void$ O $Everything$ O O O O $ResourceIndex$ O O $Everything$ O $RestResources$ O O $any[]$ O $any[]$ O $ResourceIndex$ O O O $any$ O $any$ O $ResourceIndex$ O O $complex$ O $any)$ O $boolean$ O $any[]$ O $any$ O O $string$ O $void$ O O O O $any$ O $void$ O O $Everything$ O O O O $EnvName$ O $any$ O O O O $Subscription[]$ O $any$ O O O O O O O O O $void$ O $void$ O O O O O $void$ O $Store$ O O O $any[]$ O O $any$ O $any$ O $any$ O O O O $Subscription[]$ O $void$ O O O $Subscription$ O O $any[]$ O $boolean$ O $any[]$ O $boolean$ O $Subscription$ O $EnvName$ O O $any$ O $any$ O O O O $Subscription$ O $void$ O $Subscription$ O $void$ O $any$ O $any$ O O O O O O O O O
import { NetworkState , ConnectionStatus } from "s" ; import { maybeGetDevice } from "s" ; import { changeLastClientConnected } from "s" ; export function createRefreshTrigger ( ) { const that = { lastStatus : ( undefined as NetworkState | undefined ) } ; return ( status : ConnectionStatus | undefined ) => { if ( status ) { const { state } = status ; const isUp = state === "s" ; const wasDown = that . lastStatus === "s" ; const device = maybeGetDevice ( ) ; that . lastStatus = state ; if ( device && isUp && wasDown ) { changeLastClientConnected ( device ) ( ) ; } } } ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $void$ O O O O $complex$ O O $NetworkState$ O O $undefined$ O $any$ O O O O O O O $ConnectionStatus$ O $any$ O O O O O O O $ConnectionStatus$ O O O O $NetworkState$ O O $ConnectionStatus$ O O $boolean$ O $NetworkState$ O O O O $boolean$ O $complex$ O $NetworkState$ O O O O $any$ O $any$ O O O $complex$ O $NetworkState$ O $NetworkState$ O O O $any$ O $boolean$ O $boolean$ O O $void$ O $any$ O O O O O O O O O
import { MiddlewareConfig } from "s" ; import { Middleware } from "s" ; import { Everything } from "s" ; import { createRefreshTrigger } from "s" ; const maybeRefresh = createRefreshTrigger ( ) ; const stateFetchMiddleware = ( store ) => ( next ) => ( action ) => { const s = store . getState ( ) as any ; maybeRefresh ( s . bot . connectivity . uptime [ "s" ] ) ; next ( action ) ; } ; export const stateFetchMiddlewareConfig = ( { env : "s" , fn : stateFetchMiddleware } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O $void$ O $void$ O O O O $Middleware$ O O $any$ O O O $any$ O O O $any$ O O O O $Everything$ O $any$ O $any$ O O O O O $void$ O $Everything$ O $BotState$ O $ConnectionState$ O $complex$ O O O O O $any$ O $any$ O O O O O O $MiddlewareConfig$ O O O O O O O $any$ O $any$ O O O
import axios from "s" ; import I from "s" ; import { merge } from "s" ; const translationFilePath = ( lang ) : string => `template` ; export function generateUrl ( langCode , host , port ) { const lang = langCode . slice ( 0 , 0 ) ; const baseUrl = `template` ; const url = `template` ; return url ; } export function getUserLang ( langCode = "s" , host = location . host , port = location . port ) { return axios . get ( generateUrl ( langCode , host , port ) ) . then ( ( ) => langCode . slice ( 0 , 0 ) ) . catch ( ( ) => "s" ) ; } type TranslationFile = { [ cat ] : { [ key ] : string } } ; type Translations = { [ key ] : string } ; const parseTranslationData = ( data ) : Translations => merge ( data [ "s" ] , data [ "s" ] , data [ "s" ] ) ; export function 0 ( lang ) < I . InitOptions > { return axios . get < TranslationFile > ( translationFilePath ( lang ) ) . then ( response => { const translation = parseTranslationData ( response . data ) ; return { nsSeparator : "s" , keySeparator : "s" , lng : lang , resources : { [ lang ] : { translation } } } ; } ) ; } export const detectLanguage = ( lang = navigator . language ) => getUserLang ( lang ) . then ( 0 ) ;	O $any$ O O O O $any$ O O O O O $any$ O O O O O $string$ O O $string$ O O O O O O O O $string$ O $string$ O $string$ O $string$ O O O $string$ O $string$ O $string$ O O O O O O O $string$ O O O O $string$ O O O O $string$ O O O O $any$ O $string$ O O O $string$ O $Location$ O $string$ O $string$ O $Location$ O $string$ O O O $any$ O $any$ O $string$ O $string$ O $string$ O $string$ O O O $any$ O O O O $string$ O $string$ O O O O O O O $any$ O O O O O O O O O $any$ O O O $string$ O O O O $string$ O O O O O O O $any$ O O O $string$ O O O O O O $Translations$ O O $TranslationFile$ O O $any$ O $any$ O $TranslationFile$ O O O O $TranslationFile$ O O O O $TranslationFile$ O O O O O O O $Promise$ O $string$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $string$ O $string$ O O O $any$ O $any$ O O O $Translations$ O $Translations$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O $string$ O $string$ O $complex$ O O O $string$ O O O $Translations$ O O O O O O O O O O $any$ O O $string$ O $Navigator$ O $string$ O O $any$ O $string$ O O $any$ O $Promise<any>$ O O
import { detectLanguage } from "s" ; import I from "s" ; import { noop } from "s" ; export async function revertToEnglish ( ) { I . init ( await detectLanguage ( "s" ) , noop ) ; }	O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise<void>$ O O O $any$ O $any$ O O $any$ O O O O $any$ O O O
import { Middleware , DeepPartial } from "s" ; import { MiddlewareConfig } from "s" ; import { ResourceName , TaggedWebAppConfig } from "s" ; import { Actions } from "s" ; import { revertToEnglish } from "s" ; import { SyncResponse } from "s" ; import { arrayUnwrap } from "s" ; const WEB_APP_CONFIG = "s" ; const fn = ( ) => ( dispatch ) => ( action ) => { const x < SyncResponse < TaggedWebAppConfig > > = action ; if ( x && x . type === Actions . RESOURCE_READY && x . payload && x . payload . body && x . payload . kind === WEB_APP_CONFIG ) { const conf = arrayUnwrap ( x . payload . body ) ; conf && conf . body && conf . body . 0 && revertToEnglish ( ) ; } return dispatch ( action ) ; } ; export const revertToEnglishMiddleware = { fn , env : "s" } ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O O $any$ O O O O O O $T$ O O O O O $ResourceName$ O O O O $Middleware$ O O O O O $any$ O O O $any$ O O O O $DeepPartial$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $Actions.RESOURCE_READY$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $T$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Promise<void>$ O O O O O $any$ O $any$ O O O O O O $MiddlewareConfig$ O O $any$ O O O O O O
import { info } from "s" ; import { semverCompare , SemverResult , MinVersionOverride } from "s" ; import { Content } from "s" ; import { Dictionary } from "s" ; const IDEAL_VERSION = globalConfig . FBOS_END_OF_LIFE_VERSION || MinVersionOverride . ALWAYS ; export function createReminderFn ( ) { const alreadyChecked < boolean | undefined > = { [ MinVersionOverride . ALWAYS ] : true } ; return function reminder ( version ) { ! alreadyChecked [ version ] && semverCompare ( version , IDEAL_VERSION ) === SemverResult . RIGHT_IS_GREATER && info ( Content . OLD_FBOS_REC_UPGRADE ) ; alreadyChecked [ version ] = true ; } ; }	O O $void$ O O O O O O $SemverResult$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O $complex$ O $any$ O $any$ O $MinVersionOverride.ALWAYS$ O O O $void$ O O O O $Dictionary$ O O O O O O O O $any$ O $MinVersionOverride.ALWAYS$ O O O O O O O $void$ O $string$ O O O $any$ O $string$ O O $SemverResult$ O $string$ O $string$ O O $any$ O $SemverResult.RIGHT_IS_GREATER$ O $void$ O $any$ O $string$ O O $any$ O $string$ O O O O O O O
import { EnvName } from "s" ; import { determineInstalledOsVersion , MinVersionOverride } from "s" ; import { maybeGetDevice } from "s" ; import { MW } from "s" ; import { Everything } from "s" ; import { Store , Action } from "s" ; import { Dispatch } from "s" ; import { createReminderFn } from "s" ; const maybeRemindUserToUpdate = createReminderFn ( ) ; function getVersionFromState ( state ) { const device = maybeGetDevice ( state . resources . index ) ; const v = determineInstalledOsVersion ( state . bot , device ) || MinVersionOverride . ALWAYS ; maybeRemindUserToUpdate ( v ) ; return v ; } const fn = ( store < Everything > ) => ( dispatch < Action < object > > ) => ( action ) => { const fbos = getVersionFromState ( store . getState ( ) ) ; window . Rollbar && window . Rollbar . configure ( { payload : { fbos } } ) ; return dispatch ( action ) ; } ; const env = "s" ; export const versionChangeMiddleware = { env , fn } ;	O O $any$ O O O O O O $string$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O $void$ O $void$ O O O O $string$ O $Everything$ O O O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $string$ O $string$ O $Everything$ O $BotState$ O $any$ O O $any$ O $MinVersionOverride.ALWAYS$ O $void$ O $string$ O O O $string$ O O O $MW$ O O $Store$ O $any$ O O O O $Dispatch$ O $any$ O O O O O O O $any$ O O O O $string$ O $string$ O $any$ O $any$ O O O O $complex$ O $Rollbar$ O $complex$ O $Rollbar$ O $object$ O O $complex$ O O $string$ O O O O O $any$ O $any$ O O O O O $EnvName$ O O O O O $complex$ O O O O $MW$ O O
import { API } from "s" ; import { noop , throttle } from "s" ; import axios from "s" ; import { ResourceName } from "s" ; import { Log } from "s" ; import { resourceReady , newTaggedResource } from "s" ; const kind = "s" ; export const refreshLogs = async ( dispatch ) => { return axios . get < Log [ ] > ( API . current . filteredLogsPath ) . then ( ( { data } ) => { dispatch ( resourceReady ( kind , newTaggedResource ( "s" , data ) ) ) ; } , noop ) ; } ; export const throttledLogRefresh = throttle ( refreshLogs , 0 ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $SyncResponse<T>$ O $T[]$ O O O O O $ResourceName$ O O O O O $Promise<any>$ O O O $Function$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $API$ O $string$ O O $any$ O O O $any$ O O O O $Function$ O $SyncResponse<T>$ O $any$ O $T[]$ O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $Promise<any>$ O O O O
import { Actions } from "s" ; import { Middleware } from "s" ; import { MiddlewareConfig } from "s" ; import { ResourceName } from "s" ; import { throttledLogRefresh } from "s" ; const WEB_APP_CONFIG = "s" ; export const fn = ( ) => ( dispatch ) => ( action ) => { const needsRefresh = action && action . payload && action . type === Actions . SAVE_RESOURCE_OK && action . payload . kind === WEB_APP_CONFIG ; needsRefresh && throttledLogRefresh ( dispatch ) ; return dispatch ( action ) ; } ; export const refilterLogsMiddleware = { fn , env : "s" } ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $ResourceName$ O O O O O $Middleware$ O O O O O $any$ O O O $any$ O O O O $boolean$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Actions.SAVE_RESOURCE_OK$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $MiddlewareConfig$ O O $any$ O O O O O O
import thunk from "s" ; import { applyMiddleware , compose } from "s" ; import { EnvName , ReduxAction } from "s" ; import { Actions } from "s" ; import { stateFetchMiddlewareConfig } from "s" ; import { revertToEnglishMiddleware } from "s" ; import { versionChangeMiddleware } from "s" ; import { Everything } from "s" ; import { Middleware } from "s" ; import { Store } from "s" ; import { refilterLogsMiddleware } from "s" ; export interface MW extends Middleware { ( store < Everything > ) : ( dispatch ) => ( action < object > ) => void ; } export interface MiddlewareConfig { fn : MW ; env : EnvName ; } export let mwConfig : MiddlewareConfig [ ] = [ { env : "s" , fn : thunk } , { env : "s" , fn : require ( "s" ) . default ( ) } , stateFetchMiddlewareConfig , revertToEnglishMiddleware , versionChangeMiddleware , refilterLogsMiddleware ] ; export function getMiddleware ( env ) { const middlewareFns = mwConfig . filter ( function ( mwc ) { return ( mwc . env === env ) || ( mwc . env === "s" ) ; } ) . map ( ( mwc ) => mwc . fn ) ; const wow = ( window as any ) . __REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ; const dtCompose = wow && wow ( { actionsBlacklist : [ Actions . NETWORK_EDGE_CHANGE , Actions . PING_NO , Actions . PING_OK , Actions . PING_START , Actions . RESOURCE_READY ] } ) ; const composeEnhancers = dtCompose || compose ; const middleware = applyMiddleware ( ... middlewareFns ) ; return composeEnhancers ( middleware ) ; }	O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $MiddlewareConfig$ O O O O O O $MiddlewareConfig$ O O O O O O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $MiddlewareConfig$ O O O O O O $any$ O $any$ O O $Store$ O $any$ O O O O $Function$ O O O $ReduxAction$ O O O O O O O O O O $any$ O $MW$ O $any$ O $EnvName$ O $any$ O O O O $MiddlewareConfig[]$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O O O O $MiddlewareConfig$ O $MiddlewareConfig$ O $complex$ O $MiddlewareConfig$ O O O O $any$ O $EnvName$ O O O $MW[]$ O $MiddlewareConfig[]$ O $complex$ O O O $MiddlewareConfig$ O O O O $MiddlewareConfig$ O $EnvName$ O $EnvName$ O O O $MiddlewareConfig$ O $EnvName$ O O O O O O O $U[]$ O O $MiddlewareConfig$ O O $MiddlewareConfig$ O $MW$ O O O $any$ O O $complex$ O O O O $any$ O O $any$ O $any$ O $any$ O O $Actions[]$ O O $any$ O $Actions.NETWORK_EDGE_CHANGE$ O $any$ O $Actions.PING_NO$ O $any$ O $Actions.PING_OK$ O $any$ O $Actions.PING_START$ O $any$ O $Actions.RESOURCE_READY$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $MW[]$ O O O $any$ O $any$ O O O
import { createStore } from "s" ; import { Store } from "s" ; import { rootReducer } from "s" ; import { registerSubscribers } from "s" ; import { getMiddleware } from "s" ; import { set } from "s" ; function dev ( ) { store = createStore ( rootReducer , maybeFetchOldState ( ) , getMiddleware ( "s" ) ) ; return store ; } function prod ( ) { return createStore ( rootReducer , ( { } as any ) , getMiddleware ( "s" ) ) ; } export function configureStore ( ) { const ENV = process . env . NODE_ENV || "s" ; const 0 = ( ENV === "s" ? prod ( ) : dev ( ) ) ; set ( window , "s" , 0 ) ; registerSubscribers ( 0 ) ; return 0 ; } export let store = configureStore ( ) ; function maybeFetchOldState ( ) { try { return JSON . parse ( sessionStorage . getItem ( "s" ) || "s" ) ; } catch ( e ) { return { } ; } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O $Store$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O O O $Store$ O O O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $Store$ O O $any$ O O O $any$ O O O $any$ O O O O $any$ O $complex$ O O O $any$ O O $void$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O $JSON$ O $any$ O $Storage$ O $string$ O O O O O O O O O O $any$ O O O O O O O O
import { getDevice } from "s" ; import { store } from "s" ; import { Actions } from "s" ; import { set } from "s" ; interface NonSense { last : string ; all : Set < string > ; } export const outstandingRequests = { last : "s" , all : new Set ( ) } ; export function storeUUID ( uuid ) { outstandingRequests . last = cleanUUID ( uuid ) ; outstandingRequests . all . add ( outstandingRequests . last ) ; } function unstoreUUID ( uuid ) { outstandingRequests . all . delete ( PLACEHOLDER ) ; outstandingRequests . all . delete ( cleanUUID ( uuid ) ) ; } set ( window , "s" , outstandingRequests ) ; const PLACEHOLDER = "s" ; const MAX_WAIT = 0 ; export function startTracking ( uuid = PLACEHOLDER ) { const cleanID = cleanUUID ( uuid ) ; ifQueueEmpty ( ( ) => store . dispatch ( stash ( ) ) ) ; const isConsistent = getConsistencyState ( ) ; if ( isConsistent ) { store . dispatch ( setConsistency ( false ) ) ; } storeUUID ( cleanID ) ; getDevice ( ) . on ( cleanID , ( ) => stopTracking ( cleanID ) ) ; setTimeout ( ( ) => stopTracking ( uuid ) , MAX_WAIT ) ; } export function stopTracking ( uuid ) { const cleanID = cleanUUID ( uuid ) ; unstoreUUID ( cleanID ) ; if ( ! getConsistencyState ( ) ) { ifQueueEmpty ( ( ) => store . dispatch ( setConsistency ( true ) ) ) ; } } const setConsistency = ( payload ) => ( { type : Actions . SET_CONSISTENCY , payload } ) ; export const stash = ( ) => ( { type : Actions . STASH_STATUS , payload : undefined } ) ; const ifQueueEmpty = < T > ( cb : ( ) => T ) : T | false => ( outstandingRequests . all . size === 0 ) && cb ( ) ; const getConsistencyState = ( ) => ! ! store . getState ( ) . bot . consistent ; export const cleanUUID = ( uuid ) => uuid . toLowerCase ( ) . split ( "s" ) . join ( "s" ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $string$ O O O $Set<string>$ O $SetConstructor$ O O O O O O O $NonSense$ O O $string$ O O O $Set<string>$ O O $SetConstructor$ O O O O O O $void$ O $string$ O O $NonSense$ O $string$ O $string$ O $string$ O O $NonSense$ O $Set<string>$ O $Set<string>$ O $NonSense$ O $string$ O O O O $void$ O $string$ O O $NonSense$ O $Set<string>$ O $boolean$ O O O O $NonSense$ O $Set<string>$ O $boolean$ O $string$ O $string$ O O O O $any$ O $complex$ O O O $NonSense$ O O O O O O O O O O O O O O $void$ O $string$ O O O O O $string$ O $string$ O $string$ O O $complex$ O O O O $any$ O $any$ O $complex$ O O O O O O $boolean$ O $boolean$ O O O O O $boolean$ O O $any$ O $any$ O $complex$ O O O O O O $void$ O $string$ O O $any$ O O O $any$ O $string$ O O O O $void$ O $string$ O O O $number$ O O O O $void$ O $string$ O O O O O O O O $void$ O $string$ O O O $string$ O $string$ O $string$ O O $void$ O $string$ O O O O O $boolean$ O O O O $complex$ O O O O $any$ O $any$ O $complex$ O O O O O O O O O $complex$ O O $boolean$ O O O O $Actions$ O $any$ O $Actions.SET_CONSISTENCY$ O $boolean$ O O O O O $complex$ O O O O O O $Actions$ O $any$ O $Actions.STASH_STATUS$ O $undefined$ O $undefined$ O O O O $complex$ O O $any$ O O $T$ O O O O $any$ O O $any$ O O O O $NonSense$ O $Set<string>$ O $number$ O O O O $T$ O O O O $boolean$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O O $string$ O O $string$ O $string$ O O O $complex$ O O O O $string$ O O O O
import { TaggedResource , SpecialStatus } from "s" ; import { UnsafeError } from "s" ; import { Actions } from "s" ; import { toastErrors } from "s" ; import { stopTracking } from "s" ; export function saveOK ( payload ) { return { type : Actions . SAVE_RESOURCE_OK , payload } ; } export function destroyOK ( payload ) { return { type : Actions . DESTROY_RESOURCE_OK , payload } ; } export interface GeneralizedError { err : UnsafeError ; uuid : string ; statusBeforeError : SpecialStatus ; } export const generalizedError = ( payload ) => { const badStatus = payload . statusBeforeError == SpecialStatus . SAVING ; if ( badStatus ) { payload . statusBeforeError = SpecialStatus . DIRTY ; } toastErrors ( payload ) ; stopTracking ( payload . uuid ) ; return { type : Actions . _RESOURCE_NO , payload } ; } ; export let destroyNO = generalizedError ; export let createNO = generalizedError ; export let updateNO = generalizedError ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $void$ O O O O O O $complex$ O $TaggedResource$ O O O O $Actions$ O $any$ O $Actions.SAVE_RESOURCE_OK$ O $any$ O O O O O $complex$ O $TaggedResource$ O O O O $Actions$ O $any$ O $Actions.DESTROY_RESOURCE_OK$ O $any$ O O O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O $any$ O O O O $complex$ O O $GeneralizedError$ O O O O $boolean$ O $GeneralizedError$ O $any$ O $any$ O $any$ O O O $boolean$ O O $GeneralizedError$ O $any$ O $any$ O $any$ O O $void$ O $GeneralizedError$ O O $void$ O $GeneralizedError$ O $string$ O O O O $Actions$ O $any$ O $Actions._RESOURCE_NO$ O $GeneralizedError$ O O O O O O $complex$ O $complex$ O O O $complex$ O $complex$ O O O $complex$ O $complex$ O
import { ResourceName } from "s" ; import { startTracking } from "s" ; import { unpackUUID } from "s" ; const BLACKLIST : ResourceName [ ] = [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , ] ; export function maybeStartTracking ( uuid ) { const ignore = BLACKLIST . includes ( unpackUUID ( uuid ) . kind ) ; ignore || startTracking ( uuid ) ; }	O O $any$ O O O O O O $void$ O O O O O O $BetterUUID$ O O O O O $any[]$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O $boolean$ O $any[]$ O $boolean$ O $BetterUUID$ O $string$ O O $any$ O O $boolean$ O $void$ O $string$ O O O
import { TaggedResource , SpecialStatus , ResourceName , TaggedSequence } from "s" ; import { isTaggedResource , } from "s" ; import { GetState , ReduxAction } from "s" ; import { API } from "s" ; import axios from "s" ; import { updateNO , destroyOK , destroyNO , GeneralizedError , saveOK } from "s" ; import { UnsafeError } from "s" ; import { defensiveClone , unpackUUID } from "s" ; import { EditResourceParams } from "s" ; import { ResourceIndex } from "s" ; import { SequenceBodyItem } from "s" ; import { Actions } from "s" ; import { maybeStartTracking } from "s" ; import { newTaggedResource } from "s" ; import { arrayUnwrap } from "s" ; import { findByUuid } from "s" ; import { assign , noop } from "s" ; import { t } from "s" ; import { appIsReadonly } from "s" ; export function edit ( tr , changes < typeof tr . body > ) < EditResourceParams > { return { type : Actions . EDIT_RESOURCE , payload : { uuid : tr . uuid , update : changes , specialStatus : SpecialStatus . DIRTY } } ; } export function overwrite < T extends TaggedResource > ( tr : T , changeset : T [ "s" ] , specialStatus = SpecialStatus . DIRTY ) < EditResourceParams > { return { type : Actions . OVERWRITE_RESOURCE , payload : { uuid : tr . uuid , update : changeset , specialStatus } } ; } export interface EditStepProps { step : Readonly < SequenceBodyItem > ; sequence : Readonly < TaggedSequence > ; index : number ; executor ( stepCopy ) : void ; } export function editStep ( { step , sequence , index , executor } ) { const nextStep = defensiveClone ( step ) ; const nextSeq = defensiveClone ( sequence ) ; executor ( nextStep ) ; nextSeq . body . body = nextSeq . body . body || [ ] ; nextSeq . body . body [ index ] = nextStep ; return overwrite ( sequence , nextSeq . body ) ; } export function init < T extends TaggedResource > ( kind : T [ "s" ] , body : T [ "s" ] , clean = false ) < TaggedResource > { const resource = arrayUnwrap ( newTaggedResource ( kind , body ) ) ; resource . specialStatus = SpecialStatus [ clean ? "s" : "s" ] ; return { type : Actions . INIT_RESOURCE , payload : resource } ; } export const initSaveGetId = < T extends TaggedResource > ( kind : T [ "s" ] , body : T [ "s" ] ) => ( dispatch ) => { const resource = arrayUnwrap ( newTaggedResource ( kind , body ) ) ; resource . specialStatus = SpecialStatus . DIRTY ; dispatch ( { type : Actions . INIT_RESOURCE , payload : resource } ) ; dispatch ( { type : Actions . SAVE_RESOURCE_START , payload : resource } ) ; maybeStartTracking ( resource . uuid ) ; return axios . post < typeof resource . body > ( urlFor ( resource . kind ) , resource . body ) . then ( resp => { dispatch ( saveOK ( resource ) ) ; return resp . data . id ; } ) . catch ( ( err ) => { dispatch ( updateNO ( { err , uuid : resource . uuid , statusBeforeError : resource . specialStatus } ) ) ; return Promise . reject ( err ) ; } ) ; } ; export function initSave < T extends TaggedResource > ( kind : T [ "s" ] , body : T [ "s" ] ) { return function ( dispatch ) { const action = init ( kind , body ) ; dispatch ( action ) ; return dispatch ( save ( action . payload . uuid ) ) ; } ; } export function save ( uuid ) { return function ( dispatch , getState ) { const resource = findByUuid ( getState ( ) . resources . index , uuid ) ; const oldStatus = resource . specialStatus ; dispatch ( { type : Actions . SAVE_RESOURCE_START , payload : resource } ) ; return dispatch ( update ( uuid , oldStatus ) ) ; } ; } export function refresh ( resource , urlNeedsId = false ) { return function ( dispatch ) { dispatch ( refreshStart ( resource . uuid ) ) ; const endPart = "s" + urlNeedsId ? resource . body . id : "s" ; const statusBeforeError = resource . specialStatus ; axios . get < typeof resource . body > ( urlFor ( resource . kind ) + endPart ) . then ( resp => { const 0 = defensiveClone ( resource ) ; const 0 = { body : defensiveClone ( resp . data ) } ; const newTR = assign ( { } , 0 , 0 ) ; if ( isTaggedResource ( newTR ) ) { dispatch ( refreshOK ( newTR ) ) ; } else { const action = refreshNO ( { err : { message : "s" } , uuid : resource . uuid , statusBeforeError } ) ; dispatch ( action ) ; } } ) ; } ; } export function refreshStart ( uuid ) < string > { return { type : Actions . REFRESH_RESOURCE_START , payload : uuid } ; } export function refreshOK ( payload ) < TaggedResource > { return { type : Actions . REFRESH_RESOURCE_OK , payload } ; } export function refreshNO ( payload ) < GeneralizedError > { return { type : Actions . REFRESH_RESOURCE_NO , payload } ; } interface AjaxUpdatePayload { index : ResourceIndex ; uuid : string ; dispatch : Function ; statusBeforeError : SpecialStatus ; } function update ( uuid , statusBeforeError ) { return function ( dispatch , getState ) { const { index } = getState ( ) . resources ; const payl = { index , uuid , dispatch , statusBeforeError } ; return updateViaAjax ( payl ) ; } ; } interface DestroyNoProps { uuid : string ; statusBeforeError : SpecialStatus ; dispatch : Function ; } export const destroyCatch = ( p ) => ( err ) => { p . dispatch ( destroyNO ( { err , uuid : p . uuid , statusBeforeError : p . statusBeforeError } ) ) ; return Promise . reject ( err ) ; } ; function destroyStart ( ) { return { type : Actions . DESTROY_RESOURCE_START , payload : { } } ; } export function destroy ( uuid , force = false ) { return function ( dispatch , getState ) { dispatch ( destroyStart ( ) ) ; if ( appIsReadonly ( getState ( ) . resources . index ) ) { return Promise . reject ( "s" ) ; } const resource = findByUuid ( getState ( ) . resources . index , uuid ) ; const maybeProceed = confirmationChecker ( resource . kind , force ) ; return maybeProceed ( ( ) => { const statusBeforeError = resource . specialStatus ; if ( resource . body . id ) { maybeStartTracking ( uuid ) ; return axios . delete ( urlFor ( resource . kind ) + resource . body . id ) . then ( function ( ) { dispatch ( destroyOK ( resource ) ) ; } ) . catch ( destroyCatch ( { dispatch , uuid , statusBeforeError } ) ) ; } else { dispatch ( destroyOK ( resource ) ) ; return Promise . resolve ( "s" ) ; } } ) || Promise . reject ( "s" ) ; } ; } export function destroyAll ( resourceName , force = false ) { if ( force || confirm ( t ( "s" ) ) ) { return axios . delete ( urlFor ( resourceName ) + "s" ) ; } else { return Promise . reject ( "s" ) ; } } export function saveAll ( input : TaggedResource [ ] , callback : ( ) => void = noop , errBack : ( err ) => void = noop ) { return function ( dispatch ) { const p = input . filter ( x => x . specialStatus === SpecialStatus . DIRTY ) . map ( tts => tts . uuid ) . map ( uuid => { maybeStartTracking ( uuid ) ; return dispatch ( save ( uuid ) ) ; } ) ; Promise . all ( p ) . then ( callback , errBack ) ; } ; } export function urlFor ( tag ) { const OPTIONS < Record < ResourceName , string > > = { Alert : API . current . alertPath , Device : API . current . devicePath , DiagnosticDump : API . current . diagnosticDumpsPath , FarmEvent : API . current . farmEventsPath , FarmwareEnv : API . current . farmwareEnvPath , FarmwareInstallation : API . current . farmwareInstallationPath , FbosConfig : API . current . fbosConfigPath , FirmwareConfig : API . current . firmwareConfigPath , Image : API . current . imagesPath , Log : API . current . logsPath , Peripheral : API . current . peripheralsPath , PinBinding : API . current . pinBindingPath , PlantTemplate : API . current . plantTemplatePath , Point : API . current . pointsPath , PointGroup : API . current . pointGroupsPath , Regimen : API . current . regimensPath , SavedGarden : API . current . savedGardensPath , Sensor : API . current . sensorPath , Sequence : API . current . sequencesPath , Tool : API . current . toolsPath , User : API . current . usersPath , WebAppConfig : API . current . webAppConfigPath , WebcamFeed : API . current . webcamFeedPath , } ; const url = OPTIONS [ tag ] ; if ( url ) { return url ; } else { throw new Error ( `template` ) ; } } const SINGULAR_RESOURCE : ResourceName [ ] = [ "s" , "s" , "s" ] ; export function updateViaAjax ( payl ) { const { uuid , statusBeforeError , dispatch , index } = payl ; const resource = findByUuid ( index , uuid ) ; const { body , kind } = resource ; let verb : "s" | "s" ; let url = urlFor ( kind ) ; if ( body . id ) { verb = "s" ; if ( ! SINGULAR_RESOURCE . includes ( unpackUUID ( payl . uuid ) . kind ) ) { url += body . id ; } } else { verb = "s" ; } maybeStartTracking ( uuid ) ; return axios [ verb ] < typeof resource . body > ( url , body ) . then ( function ( resp ) { const 0 = defensiveClone ( resource ) ; const 0 = { body : defensiveClone ( resp . data ) } ; const newTR = assign ( { } , 0 , 0 ) ; if ( isTaggedResource ( newTR ) ) { dispatch ( saveOK ( newTR ) ) ; } else { throw new Error ( "s" ) ; } } ) . catch ( function ( err ) { dispatch ( updateNO ( { err , uuid , statusBeforeError } ) ) ; return Promise . reject ( err ) ; } ) ; } const MUST_CONFIRM_LIST : ResourceName [ ] = [ "s" , "s" , "s" , "s" , "s" , "s" , ] ; const confirmationChecker = ( resourceName , force = false ) => < T > ( proceed : ( ) => T ) : T | undefined => { if ( MUST_CONFIRM_LIST . includes ( resourceName ) ) { if ( force || confirm ( t ( "s" ) ) ) { return proceed ( ) ; } else { return undefined ; } } return proceed ( ) ; } ;	O O $any$ O $any$ O $any$ O $any$ O O O O O O $complex$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $complex$ O $complex$ O $complex$ O $any$ O $complex$ O O O O O O $any$ O O O O O O $T$ O $BetterUUID$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $T[]$ O O O O O O $T$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $ReduxAction$ O $TaggedResource$ O $Partial$ O O $any$ O $any$ O O O $any$ O O O O $Actions.EDIT_RESOURCE$ O $any$ O $Actions.EDIT_RESOURCE$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $ReduxAction$ O $any$ O $any$ O O $T$ O $any$ O $T["body"]$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $Actions.OVERWRITE_RESOURCE$ O $any$ O $Actions.OVERWRITE_RESOURCE$ O $complex$ O O $any$ O $T$ O $any$ O $T["body"]$ O $T["body"]$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $number$ O O O $void$ O $SequenceBodyItem$ O O O O O O O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O $number$ O $void$ $EditStepProps$ O O O $any$ O $T$ O $any$ O O O $any$ O $T$ O $any$ O O $void$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $number$ O O $any$ O O $ReduxAction<EditResourceParams>$ O $any$ O $any$ O $any$ O O O O O $ReduxAction$ O $any$ O $any$ O O $T["kind"]$ O $any$ O O O O $T["body"]$ O $any$ O O O O $boolean$ O O O O $any$ O O O $T$ O $T$ O $T[]$ O $T["kind"]$ O $T["body"]$ O O O $T$ O $any$ O $any$ O $boolean$ O O O O O O O O $Actions.INIT_RESOURCE$ O $any$ O $Actions.INIT_RESOURCE$ O $T$ O $T$ O O O O O $any$ O O $any$ O $any$ O O $T["kind"]$ O $any$ O O O O $T["body"]$ O $any$ O O O O O O $Function$ O O O O $T$ O $T$ O $T[]$ O $T["kind"]$ O $T["body"]$ O O O $T$ O $any$ O $any$ O $any$ O $Function$ O O $Actions$ O $any$ O $Actions.INIT_RESOURCE$ O $T$ O $T$ O O O $Function$ O O $Actions$ O $any$ O $Actions.SAVE_RESOURCE_START$ O $T$ O $T$ O O O $void$ O $T$ O $any$ O O O $any$ O $any$ O O $T$ O $any$ O O $string$ O $T$ O $any$ O O $T$ O $any$ O O $any$ O $any$ O O $Function$ O $complex$ O $T$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $UnsafeError$ O O O $Function$ O $complex$ O O $any$ O $any$ O $T$ O $any$ O $any$ O $T$ O $any$ O O O O O $PromiseConstructor$ O $Promise<T>$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $T["kind"]$ O $any$ O O O O $T["body"]$ O $any$ O O O O O O O O $Function$ O O O $ReduxAction<any>$ O $ReduxAction<any>$ O $T["kind"]$ O $T["body"]$ O O $Function$ O $ReduxAction<any>$ O O O $Function$ O $any$ O $ReduxAction<any>$ O $any$ O $any$ O O O O O O O O $any$ O $string$ O O O O O $Function$ O $GetState$ O O O $any$ O $any$ O $GetState$ O O O $RestResources$ O $ResourceIndex$ O $string$ O O O $any$ O $any$ O $any$ O $Function$ O O $Actions$ O $any$ O $Actions.SAVE_RESOURCE_START$ O $any$ O $any$ O O O O $Function$ O $any$ O $string$ O $any$ O O O O O O O O $void$ O $TaggedResource$ O $boolean$ O O O O O O O $Function$ O O $Function$ O $ReduxAction<string>$ O $any$ O $any$ O O O O $any$ O O O $boolean$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $string$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O $any$ O $T$ O $any$ O O O $complex$ O O $any$ O $T$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $complex$ O O O O $complex$ O $any$ O O O $Function$ O $ReduxAction<any>$ O $any$ O O O O O O O $ReduxAction<GeneralizedError>$ O $ReduxAction<GeneralizedError>$ O O $complex$ O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O O O $Function$ O $ReduxAction<GeneralizedError>$ O O O O O O O O O O O $ReduxAction$ O $string$ O O O O O O O $Actions.REFRESH_RESOURCE_START$ O $any$ O $Actions.REFRESH_RESOURCE_START$ O $string$ O $string$ O O O O O $ReduxAction$ O $TaggedResource$ O O $any$ O O O O $Actions.REFRESH_RESOURCE_OK$ O $any$ O $Actions.REFRESH_RESOURCE_OK$ O $any$ O O O O O $ReduxAction$ O $GeneralizedError$ O O $any$ O O O O $Actions.REFRESH_RESOURCE_NO$ O $any$ O $Actions.REFRESH_RESOURCE_NO$ O $GeneralizedError$ O O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O O $Function$ O $FunctionConstructor$ O $any$ O $any$ O O O $any$ O $string$ O $SpecialStatus$ O O O O O $Function$ O $GetState$ O O O O $ResourceIndex$ O O $GetState$ O O O $RestResources$ O O $AjaxUpdatePayload$ O O $ResourceIndex$ O $string$ O $Function$ O $any$ O O O $any$ O $AjaxUpdatePayload$ O O O O O O $any$ O $string$ O O O $any$ O $any$ O $Function$ O $FunctionConstructor$ O O O O $Promise<never>$ O O $DestroyNoProps$ O O O $UnsafeError$ O O O $DestroyNoProps$ O $Function$ O $complex$ O O $any$ O $string$ O $DestroyNoProps$ O $string$ O $any$ O $DestroyNoProps$ O $any$ O O O O O $PromiseConstructor$ O $Promise<T>$ O $any$ O O O O O $complex$ O O O O O $Actions$ O $any$ O $Actions.DESTROY_RESOURCE_START$ O ${}$ O O O O O O O O $any$ O $string$ O $boolean$ O O O O O O O $Function$ O $GetState$ O O $Function$ O $complex$ O O O O O O $any$ O $GetState$ O O O $RestResources$ O $ResourceIndex$ O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O O $any$ O $any$ O $GetState$ O O O $RestResources$ O $ResourceIndex$ O $string$ O O O $T$ O $T$ O $any$ O $any$ O $boolean$ O O O $T$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $void$ O $string$ O O O $any$ O $any$ O $string$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O $Function$ O $complex$ O $any$ O O O O O O $any$ O $Promise<never>$ O O $Function$ O $string$ O $any$ O O O O O O O $Function$ O $complex$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O O O O O $any$ O $ResourceName$ O $boolean$ O O O O O O $boolean$ O $boolean$ O $any$ O O O O O O O $any$ O $any$ O $string$ O $any$ O O O O O O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O O O O $void$ O $any[]$ O $any$ O O O $void$ O O O O O O $any$ O $void$ O O $UnsafeError$ O O O O $any$ O O O O O $Function$ O O O $any[]$ O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $U[]$ O $any$ O $any$ O $any$ O O $U[]$ O $any$ O O $void$ O $any$ O O O $Function$ O $any$ O $any$ O O O O O O $PromiseConstructor$ O O O $any[]$ O O O O $void$ O $void$ O O O O O O O $string$ O $ResourceName$ O O O $Partial$ O $any$ O $any$ O O O O O O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O $string$ O $any$ O $API$ O $string$ O O O O $string$ O $complex$ O $any$ O O O O $string$ O O O $string$ O O O O O O $ErrorConstructor$ O O O O O O O $any[]$ O $any$ O O O O O O O O O O O O O $any$ O $AjaxUpdatePayload$ O O O O $string$ O $any$ O $Function$ O $ResourceIndex$ O O $AjaxUpdatePayload$ O O $any$ O $any$ O $ResourceIndex$ O $string$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O $string$ O $string$ O $any$ O O O O $any$ O $any$ O O O O O O O O O $any[]$ O $boolean$ O $BetterUUID$ O $AjaxUpdatePayload$ O $string$ O O $any$ O O O $string$ O $any$ O $any$ O O O O O O O O O O $void$ O $string$ O O O $any$ O O O O O $any$ O $any$ O O $string$ O $any$ O O $any$ O O O $any$ O O O $any$ O $T$ O $any$ O O O $complex$ O O $any$ O $T$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $complex$ O O O O $complex$ O $any$ O O O $Function$ O $complex$ O $any$ O O O O O O O O $ErrorConstructor$ O O O O O O O O $any$ O O O $UnsafeError$ O O $Function$ O $complex$ O O $any$ O $string$ O $any$ O O O O O $PromiseConstructor$ O $Promise<T>$ O $any$ O O O O O O O $any[]$ O $any$ O O O O O O O O O O O O O O O O O O O $T$ O O $ResourceName$ O $boolean$ O O O O O $any$ O O $T$ O O O O $any$ O O $any$ O O O O O O $any[]$ O $boolean$ O $any$ O O O O O $boolean$ O $boolean$ O $any$ O O O O O O O $T$ O O O O O O O $undefined$ O O O O $T$ O O O O O
import { GetState } from "s" ; import { edit , save } from "s" ; import { BooleanConfigKey , WebAppConfig , NumberConfigKey , StringConfigKey } from "s" ; import { getWebAppConfig } from "s" ; export function toggleWebAppBool ( key ) { return ( dispatch , getState ) => { const conf = getWebAppConfig ( getState ( ) . resources . index ) ; if ( conf ) { const val = ! ( conf . body as WebAppConfig ) [ key ] ; dispatch ( edit ( conf , { [ key ] : val } ) ) ; dispatch ( save ( conf . uuid ) ) ; } else { throw new Error ( "s" ) ; } } ; } type WebAppConfigKey = BooleanConfigKey | NumberConfigKey | StringConfigKey ; type WebAppConfigValue = boolean | number | string | undefined ; export type GetWebAppConfigValue = ( k ) => WebAppConfigValue ; export function getWebAppConfigValue ( getState ) { return ( key ) : WebAppConfigValue => { const conf = getWebAppConfig ( getState ( ) . resources . index ) ; return conf && ( conf . body as WebAppConfig ) [ key ] ; } ; } export function setWebAppConfigValue ( key , value ) { return ( dispatch , getState ) => { const conf = getWebAppConfig ( getState ( ) . resources . index ) ; if ( conf ) { dispatch ( edit ( conf , { [ key ] : value } ) ) ; dispatch ( save ( conf . uuid ) ) ; } else { throw new Error ( "s" ) ; } } ; }	O O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O $BooleanConfigKey$ O O O O $Function$ O $GetState$ O O O O $any$ O $any$ O $GetState$ O O O $RestResources$ O $ResourceIndex$ O O O O $any$ O O O $boolean$ O O O $any$ O $any$ O $any$ O O $any$ O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O O O $any$ O O $boolean$ O O O O $Function$ O $any$ O $any$ O $any$ O O O O O O O O $ErrorConstructor$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O O $WebAppConfigKey$ O O $any$ O O O $complex$ O $GetState$ O O O O $WebAppConfigKey$ O O $any$ O O O $any$ O $any$ O $GetState$ O O O $RestResources$ O $ResourceIndex$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $void$ O $WebAppConfigKey$ O $WebAppConfigValue$ O O O O $Function$ O $GetState$ O O O O $any$ O $any$ O $GetState$ O O O $RestResources$ O $ResourceIndex$ O O O O $any$ O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O O O $any$ O O $complex$ O O O O $Function$ O $any$ O $any$ O $any$ O O O O O O O O $ErrorConstructor$ O O O O O O O O
import { ResourceColor } from "s" ; import { Sequence as CeleryScriptSequence , SequenceBodyItem , LegalArgString , SyncStatus , ALLOWED_CHANNEL_NAMES , Xyz , FarmwareConfig , ALLOWED_MESSAGE_TYPES , 0 , } from "s" ; import { StepMoveDataXfer , StepSpliceDataXfer } from "s" ; import { TaggedSequence } from "s" ; import { ResourceIndex , VariableNameSet , UUID } from "s" ; import { ShouldDisplay } from "s" ; import { GetWebAppConfigValue } from "s" ; export interface HardwareFlags { findHomeEnabled : Record < Xyz , boolean > ; stopAtHome : Record < Xyz , boolean > ; stopAtMax : Record < Xyz , boolean > ; negativeOnly : Record < Xyz , boolean > ; axisLength : Record < Xyz , number > ; } export interface CheckConflictCaseProps { axis : Xyz ; target : number ; hardwareFlags : HardwareFlags ; } export interface MoveAbsoluteWarningProps { vector : 0 | undefined ; offset : 0 ; hardwareFlags : HardwareFlags | undefined ; } export interface Props { dispatch : Function ; sequences : TaggedSequence [ ] ; sequence : TaggedSequence | undefined ; resources : ResourceIndex ; syncStatus : SyncStatus ; hardwareFlags : HardwareFlags ; farmwareInfo : FarmwareInfo ; shouldDisplay : ShouldDisplay ; getWebAppConfigValue : GetWebAppConfigValue ; menuOpen : boolean ; stepIndex : number | undefined ; } export interface SequenceEditorMiddleProps { dispatch : Function ; sequence : TaggedSequence | undefined ; resources : ResourceIndex ; syncStatus : SyncStatus ; hardwareFlags : HardwareFlags ; farmwareInfo : FarmwareInfo ; shouldDisplay : ShouldDisplay ; getWebAppConfigValue : GetWebAppConfigValue ; menuOpen : boolean ; } export interface ActiveMiddleProps extends SequenceEditorMiddleProps { sequence : TaggedSequence ; } export interface SequenceHeaderProps { dispatch : Function ; sequence : TaggedSequence ; syncStatus : SyncStatus ; resources : ResourceIndex ; shouldDisplay : ShouldDisplay ; menuOpen : boolean ; variablesCollapsed : boolean ; toggleVarShow : ( ) => void ; getWebAppConfigValue : GetWebAppConfigValue ; } export type ChannelName = ALLOWED_CHANNEL_NAMES ; export const INT_NUMERIC_FIELDS = [ "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ; export const FLOAT_NUMERIC_FIELDS = [ "s" , "s" , "s" ] ; export const NUMERIC_FIELDS = INT_NUMERIC_FIELDS . concat ( FLOAT_NUMERIC_FIELDS ) ; export enum MessageType { success = "s" , busy = "s" , warn = "s" , error = "s" , info = "s" , fun = "s" , debug = "s" , assertion = "s" , } export const MESSAGE_TYPES = Object . keys ( MessageType ) ; export const isMessageType = ( x ) : x is ALLOWED_MESSAGE_TYPES => MESSAGE_TYPES . includes ( x ) ; export interface Sequence extends CeleryScriptSequence { id ? : number ; color : ResourceColor ; name : string ; } export interface SequenceReducerState { current : string | undefined ; menuOpen : boolean ; stepIndex : number | undefined ; } export interface SequencesListProps { sequences : TaggedSequence [ ] ; resourceUsage : Record < UUID , boolean | undefined > ; sequence : TaggedSequence | undefined ; dispatch : Function ; sequenceMetas : Record < UUID , VariableNameSet | undefined > ; } export interface SequencesListState { searchTerm : string ; } export interface MoveAbsState { more : boolean ; } export interface StepButtonParams { current : TaggedSequence | undefined ; step : SequenceBodyItem ; dispatch : Function ; children ? : React . ReactNode ; color : "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" | "s" ; index ? : number | undefined ; } export interface CopyParams { dispatch : Function ; step : SequenceBodyItem ; } export interface RemoveParams { index : number ; dispatch : Function ; } export interface StepInputProps { step : SequenceBodyItem ; sequence : TaggedSequence ; field : LegalArgString ; dispatch : Function ; type_ ? : "s" | "s" | undefined ; index : number ; fieldOverride ? : boolean ; } export interface StepTitleBarProps { step : SequenceBodyItem ; index : number ; dispatch : Function ; sequence : TaggedSequence ; } export interface SelectSequence { type : "s" ; payload : string ; } export type DataXferObj = StepMoveDataXfer | StepSpliceDataXfer ; export type dispatcher = ( a : Function | { type : string } ) => DataXferObj ; export type FarmwareConfigs = { [ x ] : FarmwareConfig [ ] } ; export interface FarmwareInfo { farmwareNames : string [ ] ; firstPartyFarmwareNames : string [ ] ; showFirstPartyFarmware : boolean ; farmwareConfigs : FarmwareConfigs ; } export interface StepParams { currentSequence : TaggedSequence ; currentStep : SequenceBodyItem ; dispatch : Function ; index : number ; resources : ResourceIndex ; hardwareFlags ? : HardwareFlags ; farmwareInfo ? : FarmwareInfo ; shouldDisplay ? : ShouldDisplay ; confirmStepDeletion : boolean ; showPins ? : boolean ; expandStepOptions ? : boolean ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $complex$ O $any$ O $any$ O O O O $complex$ O $any$ O $any$ O O O O $complex$ O $any$ O $any$ O O O O $complex$ O $any$ O $any$ O O O O $complex$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $number$ O O O $HardwareFlags$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $HardwareFlags$ O $any$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any[]$ O $any$ O O O $any$ O $any$ O O O $ResourceIndex$ O $any$ O $any$ O $any$ O $HardwareFlags$ O $any$ O $FarmwareInfo$ O $any$ O $ShouldDisplay$ O $any$ O $GetWebAppConfigValue$ O $any$ O $boolean$ O O O $number$ O O O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any$ O $any$ O O O $ResourceIndex$ O $any$ O $any$ O $any$ O $HardwareFlags$ O $any$ O $FarmwareInfo$ O $any$ O $ShouldDisplay$ O $any$ O $GetWebAppConfigValue$ O $any$ O $boolean$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $Function$ O $FunctionConstructor$ O $any$ O $any$ O $any$ O $any$ O $ResourceIndex$ O $any$ O $ShouldDisplay$ O $any$ O $boolean$ O O O $boolean$ O O O $void$ O O O O O O $GetWebAppConfigValue$ O $any$ O O O O $any$ O $any$ O O O $string[]$ O O O O O O O O O O O O O O O O O O O $string[]$ O O O O O O O O O O O $string[]$ O $string[]$ O $complex$ O $string[]$ O O O O $any$ O $MessageType.success$ O O O $MessageType.busy$ O O O $MessageType.warn$ O O O $MessageType.error$ O O O $MessageType.info$ O O O $MessageType.fun$ O O O $MessageType.debug$ O O O $MessageType.assertion$ O O O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $any$ O O O O $complex$ O O $any$ O O $any$ O $any$ O $string[]$ O $boolean$ O $any$ O O O O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $string$ O O O O O O $any$ O $string$ O O O O O $boolean$ O O O $number$ O O O O O O O O $any$ O $any[]$ O $any$ O O O $complex$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $Function$ O $FunctionConstructor$ O $complex$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $string$ O O O O O O $any$ O $boolean$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $Function$ O $FunctionConstructor$ O $any$ O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any$ O $any$ O O O O $any$ O $number$ O O O $Function$ O $FunctionConstructor$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Function$ O $FunctionConstructor$ O O O O O O O O O O $number$ O O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O $number$ O O O $Function$ O $FunctionConstructor$ O $any$ O $any$ O O O O $any$ O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $complex$ O $FunctionConstructor$ O O $string$ O O O O O $any$ O O O $any$ O O O $string$ O O $any$ O O O O O O $any$ O $string[]$ O O O O O $string[]$ O O O O O $boolean$ O O O $FarmwareConfigs$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $Function$ O $FunctionConstructor$ O $number$ O O O $ResourceIndex$ O $any$ O $HardwareFlags$ O O $any$ O $FarmwareInfo$ O O $any$ O $ShouldDisplay$ O O $any$ O $boolean$ O O O $boolean$ O O O O $boolean$ O O O O O
import { UUID } from "s" ; type UUIDSet = Record < UUID , boolean > ; export type UsageMap = Record < UUID , UUIDSet > ; export type UsageIndex = Record < UsageKind , UsageMap > ; export type UsageKind = | "s" | "s" | "s" | "s" | "s" ; const values < UsageKind , UsageKind > = { "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" } ; export const EVERY_USAGE_KIND = Object . values ( values ) ; const EMPTY_LOOKUP < Record < UUID , boolean > > = { } ; export const resourceUsageList = ( usageIndex ) : Record < UUID , boolean > => { return EVERY_USAGE_KIND . map ( key => Object . keys ( usageIndex [ key ] ) ) . reduce < string [ ] > ( ( acc , item ) => acc . concat ( item ) , [ ] ) . reduce ( ( acc , item ) => ( { ... acc , [ item ] : true } ) , EMPTY_LOOKUP ) ; } ;	O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O $Record$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O $UsageKind[]$ O $ObjectConstructor$ O $complex$ O $complex$ O O O $Readonly$ O $any$ O $any$ O O O O O O O O O O $complex$ O O $UsageIndex$ O O $any$ O $any$ O O O O O O $UsageKind[]$ O $U[]$ O $UsageKind$ O $ObjectConstructor$ O $complex$ O $complex$ O $UsageKind$ O O O O $complex$ O O O O O O O $string[]$ O $string[]$ O O $string[]$ O $complex$ O $string[]$ O O O O O O $complex$ O O $complex$ O $string$ O O O O O $complex$ O O $string$ O O O O O O $complex$ O O O O
import { Dictionary } from "s" ; import { SequenceReducerState } from "s" ; import { DesignerState } from "s" ; import { CowardlyDictionary } from "s" ; import { TaggedResource , ResourceName , TaggedToolSlotPointer , TaggedTool } from "s" ; import { RegimenState } from "s" ; import { FarmwareState } from "s" ; import { HelpState } from "s" ; import { UsageIndex } from "s" ; import { SequenceMeta } from "s" ; import { AlertReducerState } from "s" ; export type UUID = string ; export type VariableNameSet = Record < string , SequenceMeta | undefined > ; export type UUIDSet = Record < UUID , true > ; export interface ResourceIndex { all : UUIDSet ; byKind : Record < ResourceName , Record < UUID , UUID > > ; byKindAndId : CowardlyDictionary < UUID > ; references : Dictionary < TaggedResource | undefined > ; sequenceMetas : Record < UUID , VariableNameSet | undefined > ; inUse : UsageIndex ; } export interface RestResources { loaded : ResourceName [ ] ; index : ResourceIndex ; consumers : { sequences : SequenceReducerState ; regimens : RegimenState ; farm_designer : DesignerState ; farmware : FarmwareState ; help : HelpState ; alerts : AlertReducerState ; } } export interface SlotWithTool { toolSlot : TaggedToolSlotPointer ; tool : TaggedTool | undefined ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $complex$ O $any$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $complex$ O $any$ O $any$ O $any$ O O O O $complex$ O $any$ O O O O $any$ O $any[]$ O $any$ O O O $ResourceIndex$ O $any$ O $complex$ O O $SequenceReducerState$ O $any$ O $RegimenState$ O $any$ O $DesignerState$ O $any$ O $FarmwareState$ O $any$ O $HelpState$ O $any$ O $AlertReducerState$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O
import { box } from "s" ; import { WDENVKey , Translation , FormatTranslationMap } from "s" ; import { snakeCase , get , isUndefined } from "s" ; export enum SPECIAL_VALUES { FALSE = 0 , TRUE = 0 , TOP_LEFT = 0 , TOP_RIGHT = 0 , BOTTOM_LEFT = 0 , BOTTOM_RIGHT = 0 , X = 0 , Y = 0 } export const WD_KEY_DEFAULTS = { CAMERA_CALIBRATION_calibration_along_axis : SPECIAL_VALUES . X , CAMERA_CALIBRATION_image_bot_origin_location : SPECIAL_VALUES . BOTTOM_LEFT , CAMERA_CALIBRATION_invert_hue_selection : SPECIAL_VALUES . TRUE , CAMERA_CALIBRATION_blur : 0 , CAMERA_CALIBRATION_calibration_object_separation : 0 , CAMERA_CALIBRATION_camera_offset_x : 0 , CAMERA_CALIBRATION_camera_offset_y : 0 , CAMERA_CALIBRATION_coord_scale : 0 , CAMERA_CALIBRATION_H_HI : 0 , CAMERA_CALIBRATION_H_LO : 0 , CAMERA_CALIBRATION_iteration : 0 , CAMERA_CALIBRATION_morph : 0 , CAMERA_CALIBRATION_S_HI : 0 , CAMERA_CALIBRATION_S_LO : 0 , CAMERA_CALIBRATION_total_rotation_angle : 0 , CAMERA_CALIBRATION_V_HI : 0 , CAMERA_CALIBRATION_V_LO : 0 , WEED_DETECTOR_blur : 0 , WEED_DETECTOR_H_HI : 0 , WEED_DETECTOR_H_LO : 0 , WEED_DETECTOR_iteration : 0 , WEED_DETECTOR_morph : 0 , WEED_DETECTOR_S_HI : 0 , WEED_DETECTOR_S_LO : 0 , WEED_DETECTOR_V_HI : 0 , WEED_DETECTOR_V_LO : 0 , } ; export const EVERY_WD_KEY : WDENVKey [ ] = Object . keys ( WD_KEY_DEFAULTS ) . map ( ( x ) => x ) ; export const DEFAULT_FORMATTER = { format : ( key , val ) : number | string => { switch ( key ) { case "s" : case "s" : case "s" : return ( "s" + ( SPECIAL_VALUES [ val ] || val ) ) ; default : return val ; } } , parse : ( __ , val ) => { try { const b = box ( JSON . parse ( val ) ) ; switch ( b . kind ) { case "s" : return b . value ; case "s" : case "s" : return getSpecialValue ( val ) ; default : throw new Error ( "s" ) ; } } catch ( error ) { throw new Error ( `template` ) ; } } } ; export const TRANSLATORS = { } ; export function getSpecialValue ( key : string | number ) { const k = snakeCase ( ( "s" + key ) . toUpperCase ( ) ) . toUpperCase ( ) ; const v = get ( SPECIAL_VALUES , k , NaN ) ; if ( isUndefined ( v ) || isNaN ( v ) ) { throw new Error ( "s" + k ) ; } else { return v ; } }	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $SPECIAL_VALUES.FALSE$ O O O $SPECIAL_VALUES.TRUE$ O O O $SPECIAL_VALUES.TOP_LEFT$ O O O $SPECIAL_VALUES.TOP_RIGHT$ O O O $SPECIAL_VALUES.BOTTOM_LEFT$ O O O $SPECIAL_VALUES.BOTTOM_RIGHT$ O O O $SPECIAL_VALUES.X$ O O O $SPECIAL_VALUES.Y$ O O O O O O O O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.X$ O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.BOTTOM_LEFT$ O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.TRUE$ O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O O O O O $any$ O O O $ObjectConstructor$ O $complex$ O O O O $U[]$ O O $WDENVKey$ O O O O O O O $Translation$ O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $number$ O O $number$ O O O O O O $number$ O O O O O O O O O $string$ O O O O O O $any$ O $any$ O $JSON$ O $any$ O $string$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $SPECIAL_VALUES$ O $string$ O O O O O O $ErrorConstructor$ O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O O O $FormatTranslationMap$ O O O O O O $SPECIAL_VALUES$ O $complex$ O O O O O O O $any$ O $any$ O O O O $complex$ O O $string$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $number$ O O O O $any$ O $any$ O O $boolean$ O $any$ O O O O O $ErrorConstructor$ O O O $any$ O O O O O O $any$ O O O
import { Primitive } from "s" ; import { WD_KEY_DEFAULTS , EVERY_WD_KEY } from "s" ; export const isWDENVKey = ( key ) : key is WDENVKey => ( EVERY_WD_KEY as string [ ] ) . includes ( "s" + key ) ; export type WDENVKey = keyof typeof WD_KEY_DEFAULTS ; export type WD_ENV = Record < WDENVKey , number > ; export type FormatterFn = ( key , val ) => Primitive ; export type ParserFn = ( key , val ) => number ; export interface Translation { format : FormatterFn ; parse : ParserFn ; } export type FormatTranslationMap = Partial < Record < WDENVKey , Translation > > ;	O O $any$ O O O O O O O O O O O O O O O O O O $unknown$ O O $unknown$ O $any$ O O O O O O O O O $boolean$ O O O $unknown$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O $WDENVKey$ O $number$ O O $any$ O O O $any$ O O $WDENVKey$ O $string$ O O O O O O $any$ O $FormatterFn$ O $any$ O $ParserFn$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O
import { AuthState } from "s" ; import { BotStateTree , ConfigurationName , McuParamName , SyncStatus , LocationName , TaggedImage , TaggedPeripheral , TaggedDevice , TaggedSensor , TaggedDiagnosticDump , TaggedFarmwareInstallation , JobProgress , FirmwareHardware , Alert , } from "s" ; import { ResourceIndex } from "s" ; import { WD_ENV } from "s" ; import { ConnectionStatus , ConnectionState , NetworkState } from "s" ; import { IntegerSize } from "s" ; import { Farmwares } from "s" ; import { FirmwareConfig } from "s" ; import { GetWebAppConfigValue } from "s" ; import { TimeSettings } from "s" ; export interface Props { userToApi : ConnectionStatus | undefined ; userToMqtt : ConnectionStatus | undefined ; botToMqtt : ConnectionStatus | undefined ; auth : AuthState | undefined ; bot : BotState ; deviceAccount : TaggedDevice ; images : TaggedImage [ ] ; dispatch : Function ; resources : ResourceIndex ; sourceFbosConfig : SourceFbosConfig ; sourceFwConfig : SourceFwConfig ; shouldDisplay : ShouldDisplay ; firmwareConfig : FirmwareConfig | undefined ; isValidFbosConfig : boolean ; env : UserEnv ; saveFarmwareEnv : SaveFarmwareEnv ; timeSettings : TimeSettings ; alerts : Alert [ ] ; } export type SaveFarmwareEnv = ( key , value ) => ( dispatch ) => void ; export type SourceFbosConfig = ( config ) => { value : boolean | number | string | undefined , consistent : boolean } ; export type SourceFwConfig = ( config ) => { value : number | undefined , consistent : boolean } ; export type ShouldDisplay = ( x ) => boolean ; export enum Feature { api_farmware_env = "s" , api_farmware_installations = "s" , api_pin_bindings = "s" , assertion_block = "s" , backscheduled_regimens = "s" , boot_sequence = "s" , change_ownership = "s" , diagnostic_dumps = "s" , endstop_invert = "s" , 0 = "s" , 0 = "s" , firmware_restart = "s" , flash_firmware = "s" , groups = "s" , jest_feature = "s" , long_scaling_factor = "s" , mark_as_step = "s" , named_pins = "s" , none_firmware = "s" , rpi_led_control = "s" , sensors = "s" , use_update_channel = "s" , variables = "s" } export type MinOsFeatureLookup = Partial < Record < Feature , string > > ; export interface BotState { statusStash ? : SyncStatus | undefined ; stepSize : number ; currentOSVersion ? : string ; currentBetaOSVersion ? : string ; currentBetaOSCommit ? : string ; minOsFeatureData ? : MinOsFeatureLookup ; dirty : boolean ; hardware : HardwareState ; isUpdating ? : boolean ; controlPanelState : ControlPanelState ; consistent : boolean ; connectivity : ConnectionState ; } export type HardwareState = BotStateTree ; export interface GithubRelease { tag_name : string ; target_commitish : string ; } export interface OsUpdateInfo { version : string ; commit : string ; } export interface MoveRelProps { x : number ; y : number ; z : number ; speed ? : number | undefined ; } export type Xyz = "s" | "s" | "s" ; export type Axis = Xyz | "s" ; export type BotPosition = Record < Xyz , ( number | undefined ) > ; export type BotLocationData = Record < LocationName , BotPosition > ; export type StepsPerMmXY = Record < "s" | "s" , ( number | undefined ) > ; export type UserEnv = Record < string , string | undefined > ; export interface FarmbotOsProps { bot : BotState ; alerts : Alert [ ] ; diagnostics : TaggedDiagnosticDump [ ] ; deviceAccount : TaggedDevice ; botToMqttStatus : NetworkState ; botToMqttLastSeen : number ; dispatch : Function ; sourceFbosConfig : SourceFbosConfig ; shouldDisplay : ShouldDisplay ; isValidFbosConfig : boolean ; env : UserEnv ; saveFarmwareEnv : SaveFarmwareEnv ; timeSettings : TimeSettings ; } export interface FarmbotOsState { osReleaseNotesHeading : string ; osReleaseNotes : string ; } export interface McuInputBoxProps { sourceFwConfig : SourceFwConfig ; setting : McuParamName ; dispatch : Function ; intSize ? : IntegerSize ; float ? : boolean ; scale ? : number ; filter ? : number ; gray ? : boolean ; } export interface EStopButtonProps { bot : BotState ; forceUnlock : boolean ; } export interface PeripheralsProps { bot : BotState ; peripherals : TaggedPeripheral [ ] ; dispatch : Function ; disabled : boolean | undefined ; } export interface SensorsProps { bot : BotState ; sensors : TaggedSensor [ ] ; dispatch : Function ; disabled : boolean | undefined ; } export interface FarmwareProps { dispatch : Function ; env : Partial < WD_ENV > ; user_env : UserEnv ; images : TaggedImage [ ] ; currentImage : TaggedImage | undefined ; botToMqttStatus : NetworkState ; farmwares : Farmwares ; timeSettings : TimeSettings ; syncStatus : SyncStatus | undefined ; getConfigValue : GetWebAppConfigValue ; firstPartyFarmwareNames : string [ ] ; currentFarmware : string | undefined ; shouldDisplay : ShouldDisplay ; saveFarmwareEnv : SaveFarmwareEnv ; taggedFarmwareInstallations : TaggedFarmwareInstallation [ ] ; imageJobs : JobProgress [ ] ; infoOpen : boolean ; } export interface HardwareSettingsProps { controlPanelState : ControlPanelState ; dispatch : Function ; botToMqttStatus : NetworkState ; bot : BotState ; shouldDisplay : ShouldDisplay ; sourceFwConfig : SourceFwConfig ; firmwareConfig : FirmwareConfig | undefined ; firmwareHardware : FirmwareHardware | undefined ; resources : ResourceIndex ; } export interface ControlPanelState { homing_and_calibration : boolean ; motors : boolean ; encoders_and_endstops : boolean ; danger_zone : boolean ; power_and_reset : boolean ; pin_guard : boolean ; diagnostic_dumps : boolean ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $ConnectionStatus$ O $any$ O O O $ConnectionStatus$ O $any$ O O O $ConnectionStatus$ O $any$ O O O $AuthState$ O $any$ O O O $BotState$ O $any$ O $any$ O $any$ O $any[]$ O $any$ O O O $Function$ O $FunctionConstructor$ O $ResourceIndex$ O $any$ O $SourceFbosConfig$ O $any$ O $SourceFwConfig$ O $any$ O $ShouldDisplay$ O $any$ O $any$ O $any$ O O O $boolean$ O O O $complex$ O $any$ O $SaveFarmwareEnv$ O $any$ O $TimeSettings$ O $any$ O $any[]$ O $any$ O O O O O O $any$ O O $string$ O $string$ O O O $Function$ O O O O O O $any$ O O $ConfigurationName$ O O O $complex$ O O O O O O O O O $boolean$ O O O O O O $any$ O O $McuParamName$ O O O $number$ O O O O O $boolean$ O O O O O O $any$ O O $Feature$ O O O O O O $any$ O $Feature.api_farmware_env$ O O O $Feature.api_farmware_installations$ O O O $Feature.api_pin_bindings$ O O O $Feature.assertion_block$ O O O $Feature.backscheduled_regimens$ O O O $Feature.boot_sequence$ O O O $Feature.change_ownership$ O O O $Feature.diagnostic_dumps$ O O O $Feature.endstop_invert$ O O O O O O O O O O O $Feature.firmware_restart$ O O O $Feature.flash_firmware$ O O O $Feature.groups$ O O O $Feature.jest_feature$ O O O $Feature.long_scaling_factor$ O O O $Feature.mark_as_step$ O O O $Feature.named_pins$ O O O $Feature.none_firmware$ O O O $Feature.rpi_led_control$ O O O $Feature.sensors$ O O O $Feature.use_update_channel$ O O O $Feature.variables$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O O O $number$ O O O $string$ O O O O $string$ O O O O $string$ O O O O $complex$ O O $any$ O $boolean$ O O O $any$ O $any$ O $boolean$ O O O O $ControlPanelState$ O $any$ O $boolean$ O O O $ConnectionState$ O $any$ O O O O $any$ O $any$ O O O $any$ O $string$ O O O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O O O O $any$ O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $BotState$ O $any$ O $any[]$ O $any$ O O O $any[]$ O $any$ O O O $any$ O $any$ O $NetworkState$ O $any$ O $number$ O O O $Function$ O $FunctionConstructor$ O $SourceFbosConfig$ O $any$ O $ShouldDisplay$ O $any$ O $boolean$ O O O $complex$ O $any$ O $SaveFarmwareEnv$ O $any$ O $TimeSettings$ O $any$ O O O O $any$ O $string$ O O O $string$ O O O O O O $any$ O $SourceFwConfig$ O $any$ O $any$ O $any$ O $Function$ O $FunctionConstructor$ O $IntegerSize$ O O $any$ O $boolean$ O O O O $number$ O O O O $number$ O O O O $boolean$ O O O O O O O $any$ O $BotState$ O $any$ O $boolean$ O O O O O O $any$ O $BotState$ O $any$ O $any[]$ O $any$ O O O $Function$ O $FunctionConstructor$ O $boolean$ O O O O O O O O $any$ O $BotState$ O $any$ O $any[]$ O $any$ O O O $Function$ O $FunctionConstructor$ O $boolean$ O O O O O O O O $any$ O $Function$ O $FunctionConstructor$ O O O $any$ O $any$ O O $complex$ O $any$ O $any[]$ O $any$ O O O $any$ O $any$ O O O $NetworkState$ O $any$ O $any$ O $any$ O $TimeSettings$ O $any$ O $any$ O $any$ O O O $GetWebAppConfigValue$ O $any$ O $string[]$ O O O O O $string$ O O O O O $ShouldDisplay$ O $any$ O $SaveFarmwareEnv$ O $any$ O $any[]$ O $any$ O O O $any[]$ O $any$ O O O $boolean$ O O O O O O $any$ O $ControlPanelState$ O $any$ O $Function$ O $FunctionConstructor$ O $NetworkState$ O $any$ O $BotState$ O $any$ O $ShouldDisplay$ O $any$ O $SourceFwConfig$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $ResourceIndex$ O $any$ O O O O $any$ O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O
import { ControlPanelState } from "s" ; export const panelState = ( ) : ControlPanelState => { return { homing_and_calibration : false , motors : false , encoders_and_endstops : false , danger_zone : false , power_and_reset : false , pin_guard : false , diagnostic_dumps : false } ; } ;	O O $any$ O O O O O O $ControlPanelState$ O O O O $any$ O O O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O O O O
'js' const diff = require ( 's' ) ; expect . extend ( { toBeSameTimeAs ( received , expected ) { const pass = received . isSame ( expected ) ; const message = pass ? ( ) => this . utils . matcherHint ( 's' ) + 's' + `template` + `template` + `template` + `template` : ( ) => { const diffString = diff ( expected , received , { expand : this . expand , } ) ; return ( this . utils . matcherHint ( 's' ) + 's' + `template` + `template` + `template` + `template` + ( diffString ? `template` : 's' ) ) ; } ; return { actual : received , message , pass } ; } , } ) ;	O O $any$ O $any$ O O O O $any$ O $any$ O O $complex$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O $string$ O $any$ O O O O O O O
import { CropLiveSearchResult } from "s" ; export const fakeCropLiveSearchResult = ( ) : CropLiveSearchResult => ( { crop : { name : "s" , slug : "s" , binomial_name : "s" , common_names : [ ] , description : "s" , sun_requirements : "s" , sowing_method : "s" , processing_pictures : 0 } , image : "s" } ) ;	O O $any$ O O O O O O $CropLiveSearchResult$ O O O O $any$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O O $string$ O O O O O
import { DesignerState } from "s" ; export const fakeDesignerState = ( ) : DesignerState => ( { selectedPlants : undefined , hoveredPlant : { plantUUID : undefined , icon : "s" } , hoveredPlantListItem : undefined , cropSearchQuery : "s" , cropSearchResults : [ ] , cropSearchInProgress : false , chosenLocation : { x : undefined , y : undefined , z : undefined } , currentPoint : undefined , openedSavedGarden : undefined , } ) ;	O O $any$ O O O O O O $DesignerState$ O O O O $any$ O O O $undefined$ O $undefined$ O $complex$ O O $undefined$ O $undefined$ O $string$ O O O O $undefined$ O $undefined$ O $string$ O O O $undefined[]$ O O O O $false$ O O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O
import { Farmwares , FarmwareManifestInfo } from "s" ; import { LegacyFarmwareManifest as 0 , FarmwareManifest as 0 , } from "s" ; export function fakeFarmware ( ) { return { name : "s" , installation_pending : false , url : "s" , config : [ { name : "s" , label : "s" , value : "s" } ] , meta : { fbos_version : "s" , farmware_tools_version : "s" , description : "s" , language : "s" , version : "s" , author : "s" , } } ; } export function fakeFarmwares ( ) { return { "s" : fakeFarmware ( ) } ; } export const 0 = ( ) : 0 => ( { name : "s" , uuid : "s" , executable : "s" , args : [ "s" ] , url : "s" , path : "s" , config : [ { name : "s" , label : "s" , value : "s" } ] , meta : { min_os_version_major : "s" , description : "s" , language : "s" , version : "s" , author : "s" , zip : "s" } } ) ; export const 0 = ( ) : 0 => ( { farmware_manifest_version : "s" , package : "s" , package_version : "s" , description : "s" , author : "s" , language : "s" , executable : "s" , args : "s" , config : { } , farmbot_os_version_requirement : "s" , farmware_tools_version_requirement : "s" , url : "s" , zip : "s" , } ) ;	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $FarmwareManifestInfo$ O O O O O $string$ O O O $false$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O $Farmwares$ O O O O O O O $FarmwareManifestInfo$ O O O O O O O $any$ O O O O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $string[]$ O O O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $any$ O O O O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O ${}$ O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O
import { DeepPartial } from "s" ; type DomEvent = React . SyntheticEvent < HTMLInputElement > ; export const inputEvent = ( value ) : DomEvent => { const event < DomEvent > = { currentTarget : { value } } ; return event as DomEvent ; } ;	O O $any$ O O O O O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O O $string$ O O $any$ O O O $DeepPartial$ O $any$ O O O $complex$ O O $string$ O O O O $any$ O $any$ O O O
import { TaggedResource } from "s" ; import { arrayUnwrap } from "s" ; import { newTaggedResource } from "s" ; export function fakeResource < T extends TaggedResource > ( kind : T [ "s" ] , body : T [ "s" ] ) : T { return arrayUnwrap ( newTaggedResource ( kind , body ) ) ; }	O O $any$ O O O O O O $T$ O O O O O O $T[]$ O O O O O O $T$ O $any$ O $any$ O O $T["kind"]$ O $any$ O O O O $T["body"]$ O $any$ O O O O O $any$ O O $T$ O $T[]$ O $T["kind"]$ O $T["body"]$ O O O O
import { Everything } from "s" ; export let bot : Everything [ "s" ] = { "s" : true , "s" : 0 , "s" : { "s" : false , "s" : false , "s" : false , "s" : false , "s" : false , "s" : false , "s" : false } , "s" : { "s" : { } , "s" : { encoder_enabled_x : 0 , encoder_enabled_y : 0 , encoder_enabled_z : 0 } , "s" : { } , "s" : { "s" : { x : undefined , y : undefined , z : undefined } , "s" : { x : undefined , y : undefined , z : undefined } , "s" : { x : undefined , y : undefined , z : undefined } , } , "s" : { } , "s" : { } , "s" : { busy : false , locked : false , commit : "s" , target : "s" , env : "s" , node_name : "s" , firmware_commit : "s" , } , "s" : { } , "s" : { "s" : { } } } , "s" : false , "s" : "s" , "s" : { uptime : { "s" : undefined , "s" : undefined , "s" : undefined , } , pings : { } } } ;	O O $any$ O O O O O O $BotState$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O $number$ O O O $number$ O O O O O O O O O O O O O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O O O O O O O O O O O O O O $boolean$ O O O $boolean$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $complex$ O O O O $undefined$ O O O $undefined$ O O O $undefined$ O O O ${}$ O O O O O O
import { Everything } from "s" ; export let config : Everything [ "s" ] = { "s" : "s" , "s" : "s" } ;	O O $any$ O O O O O O $ConfigState$ O $any$ O O O O O O O O O O O O O O
import { Everything } from "s" ; export let draggable : Everything [ "s" ] = { "s" : { } } ;	O O $any$ O O O O O O $DraggableState$ O $any$ O O O O O O O O O O O
import { TaggedImage , SpecialStatus } from "s" ; export let fakeImages : TaggedImage [ ] = [ { "s" : "s" , "s" : SpecialStatus . SAVED , "s" : { "s" : 0 , "s" : 0 , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : { "s" : 0 , "s" : 0 , "s" : 0 } } , "s" : "s" } , { "s" : "s" , "s" : SpecialStatus . SAVED , "s" : { "s" : 0 , "s" : 0 , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : { "s" : 0 , "s" : 0 , "s" : 0 } } , "s" : "s" } , { "s" : "s" , "s" : SpecialStatus . SAVED , "s" : { "s" : 0 , "s" : 0 , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : { "s" : 0 , "s" : 0 , "s" : 0 } } , "s" : "s" } ] ;	O O $any$ O $any$ O O O O O O $any[]$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Everything } from "s" ; export let peripherals : Everything [ "s" ] = { "s" : true } ;	O O $any$ O O O O O O $PeripheralState$ O $any$ O O O O O O O O O O
import { PingDictionary } from "s" ; export function fakePings ( ) { return { "s" : { kind : "s" , start : 0 , end : 0 } , "s" : { kind : "s" , start : 0 } , "s" : { kind : "s" , start : 0 , end : 0 } } ; }	O O $any$ O O O O O O $PingDictionary$ O O O O O O O O O O O O $number$ O O O $number$ O O O O O O O O O O O $number$ O O O O O O O O O O O $number$ O O O $number$ O O O O O O
import { SpecialStatus , TaggedDevice , TaggedLog , TaggedPoint , TaggedResource , TaggedSequence , TaggedRegimen , } from "s" ; import { resourceReducer , emptyState } from "s" ; import { resourceReady } from "s" ; import { threeWayComparison as 0 } from "s" ; import { defensiveClone } from "s" ; import { chain , groupBy } from "s" ; import { MessageType } from "s" ; const DEFAULT_DEVICE_BODY : TaggedDevice [ "s" ] = { "s" : 0 , "s" : "s" , "s" : 0 } ; export function fakeDevice ( body < TaggedDevice [ "s" ] > = { } ) { return { "s" : "s" , "s" : SpecialStatus . SAVED , "s" : { ... DEFAULT_DEVICE_BODY , ... body } , "s" : "s" } ; } const 0 = { "s" : "s" , "s" : SpecialStatus . SAVED , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : [ { "s" : "s" , "s" : { "s" : { "s" : "s" , "s" : { "s" : 0 , "s" : 0 , "s" : 0 } } , "s" : { "s" : "s" , "s" : { "s" : 0 , "s" : 0 , "s" : 0 } } , "s" : 0 } } ] , "s" : { "s" : 0 , "s" : { kind : "s" , args : { } } , } , "s" : "s" } , "s" : "s" } ; const 0 = { "s" : "s" , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , } , "s" : SpecialStatus . SAVED , "s" : "s" } ; const 0 = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 . body . id || 0 , "s" : "s" } , "s" : "s" } ; const 0 = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 . body . id || 0 , "s" : "s" } , "s" : "s" } ; const 0 = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : 0 , "s" : undefined , "s" : "s" , "s" : "s" , "s" : "s" , "s" : { "s" : 0 , "s" : 0 , "s" : 0 } } , "s" : "s" } ; const 0 = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : 0 , "s" : undefined , "s" : "s" , "s" : "s" , "s" : "s" , "s" : { "s" : 0 , "s" : 0 , "s" : 0 } } , "s" : "s" } ; const 0 = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : 0 , "s" : "s" } , "s" : "s" } ; const 0 = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : { } , "s" : "s" , "s" : "s" , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : "s" , "s" : "s" } , "s" : "s" } ; const 0 = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : { } , "s" : "s" , "s" : "s" , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : "s" , "s" : "s" } , "s" : "s" } ; const 0 = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : { "s" : undefined , "s" : "s" } , "s" : "s" , "s" : "s" , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 } , "s" : "s" } ; const 0 = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : { "s" : "s" , "s" : "s" } , "s" : "s" , "s" : "s" , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 } , "s" : "s" } ; const 0 = { "s" : "s" , "s" : SpecialStatus . SAVED , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : { } , "s" : "s" , "s" : "s" , "s" : 0 , "s" : false , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 } , "s" : "s" } ; const 0 = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : [ { "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 } ] , body : [ ] , } , "s" : "s" } ; const 0 = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : "s" , "s" : "s" } , "s" : "s" } ; const 0 = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : "s" , "s" : "s" } , "s" : "s" } ; const log = { kind : "s" , specialStatus : SpecialStatus . SAVED , body : { id : 0 , created_at : 0 , message : "s" , type : MessageType . success , channels : [ ] } , uuid : "s" } ; export let FAKE_RESOURCES : TaggedResource [ ] = [ 0 , fakeDevice ( ) , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , log ] ; const KIND : keyof TaggedResource = "s" ; type ResourceGroupNumber = 0 | 0 | 0 | 0 | 0 ; type ResourceLookupTable = Record < TaggedResource [ "s" ] , ResourceGroupNumber > ; const KIND_PRIORITY = { User : 0 , Device : 0 , FirmwareConfig : 0 , FarmwareEnv : 0 , FarmwareInstallation : 0 , WebAppConfig : 0 , SavedGarden : 0 , PlantTemplate : 0 , Peripheral : 0 , Point : 0 , Sensor : 0 , Tool : 0 , Alert : 0 , PointGroup : 0 , SensorReading : 0 , Sequence : 0 , FbosConfig : 0 , Regimen : 0 , PinBinding : 0 , FarmEvent : 0 , DiagnosticDump : 0 , Image : 0 , Log : 0 , WebcamFeed : 0 , Crop : 0 , } ; export function buildResourceIndex ( resources : TaggedResource [ ] = FAKE_RESOURCES , state = emptyState ( ) ) { const sortedResources = repairBrokeReferences ( resources ) . sort ( ( l , r ) => 0 ( KIND_PRIORITY [ l . kind ] , KIND_PRIORITY [ r . kind ] ) ) ; type K = keyof typeof KIND_PRIORITY ; return chain ( sortedResources ) . groupBy ( KIND ) . toPairs ( ) . sort ( ( l , r ) => 0 ( KIND_PRIORITY [ l [ 0 ] as K || 0 ] , KIND_PRIORITY [ r [ 0 ] as K || 0 ] ) ) . map ( ( x : [ TaggedResource [ "s" ] , TaggedResource [ ] ] ) => x ) . map ( ( y ) => resourceReady ( y [ 0 ] , y [ 0 ] ) ) . reduce ( resourceReducer , state ) . value ( ) ; } const blankSeq = { "s" : "s" , "s" : SpecialStatus . SAVED , "s" : { "s" : undefined , "s" : "s" , "s" : "s" , "s" : [ ] , "s" : { "s" : 0 , "s" : { kind : "s" , args : { } } , } , "s" : "s" } , "s" : "s" } ; const blankReg = { "s" : SpecialStatus . SAVED , "s" : "s" , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : [ ] , body : [ ] , } , "s" : "s" } ; function repairBrokeReferences ( resources : TaggedResource [ ] ) : TaggedResource [ ] { const table = groupBy ( resources , x => x . kind ) ; resources . map ( resource => { if ( resource . kind === "s" ) { const { executable_type , executable_id } = resource . body ; const missingResource = ! ( table [ executable_type ] || [ ] ) . find ( r => r . body . id === executable_id ) ; if ( missingResource ) { const base = defensiveClone ( executable_type == "s" ? blankReg : blankSeq ) ; base . body . id = executable_id ; resources . push ( base ) ; } } } ) ; return resources ; }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $generateReducer<RestResources>.GeneratedReducer$ O $RestResources$ O O O O O O $SyncResponse<T>$ O O O O O O $Comparison$ O $Comparison$ O O O O O O $T$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O $TaggedDevice$ O $Partial$ O $any$ O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O O O $TaggedResource$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O ${}$ O O O O O O O O O O O O O O O O O O $TaggedResource$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O $TaggedResource$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $TaggedResource$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $TaggedResource$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O $undefined$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TaggedResource$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O $undefined$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TaggedResource$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $TaggedPoint$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TaggedPoint$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TaggedPoint$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O $undefined$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TaggedPoint$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TaggedPoint$ O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TaggedResource$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $undefined[]$ O O O O O O O O O O O O $TaggedResource$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $TaggedResource$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $TaggedLog$ O O $string$ O O O $any$ O $any$ O $any$ O $complex$ O O $number$ O O O $number$ O O O $string$ O O O $MessageType$ O $any$ O $MessageType.success$ O $undefined[]$ O O O O O $string$ O O O O O O $any[]$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O $any$ O O O O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $ResourceLookupTable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any[]$ O $any$ O O O $any[]$ O $RestResources$ O $RestResources$ O O O O O $any[]$ O $any[]$ O $any[]$ O O $any[]$ O O $any$ O $any$ O O $Comparison$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O O O O $any$ O $any[]$ O O $any$ O $complex$ O O $any$ O O O $any$ O O $any$ O $any$ O O $Comparison$ O O O $any$ O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O $any$ O O $complex$ O O $any$ O O O O $any$ O O O O O $complex$ O O $any$ O O $any$ O O $SyncResponse<T>$ O $any$ O O O O $any$ O O O O O O $any$ O $generateReducer<RestResources>.GeneratedReducer$ O $RestResources$ O O $any$ O O O O O $TaggedSequence$ O O O O O O O O $any$ O $any$ O O O O O O $undefined$ O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O ${}$ O O O O O O O O O O O O O O O O O O $TaggedRegimen$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O $undefined[]$ O O O O O O O O O O O O $any[]$ O $any[]$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O O $any[]$ O $U[]$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O $boolean$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O O O $any$ O $T$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any[]$ O $number$ O $any$ O O O O O O O O $any[]$ O O
import { Everything } from "s" ; import { buildResourceIndex } from "s" ; import { TaggedDiagnosticDump , TaggedFarmEvent , TaggedFbosConfig , TaggedFirmwareConfig , TaggedGenericPointer , TaggedImage , TaggedLog , TaggedPeripheral , TaggedPinBinding , TaggedPlantPointer , TaggedRegimen , TaggedSensor , TaggedSensorReading , TaggedSequence , TaggedTool , TaggedUser , TaggedWebAppConfig , TaggedWebcamFeed , TaggedSavedGarden , TaggedPlantTemplate , TaggedToolSlotPointer , TaggedFarmwareEnv , TaggedFarmwareInstallation , TaggedAlert , TaggedPointGroup , } from "s" ; import { fakeResource } from "s" ; import { ExecutableType , PinBindingType } from "s" ; import { FirmwareConfig } from "s" ; import { MessageType } from "s" ; export let resources : Everything [ "s" ] = buildResourceIndex ( ) ; let idCounter = 0 ; export function fakeSequence ( ) { return fakeResource ( "s" , { args : { version : 0 , locals : { kind : "s" , args : { } } , } , id : idCounter ++ , color : "s" , name : "s" , kind : "s" , body : [ ] } ) ; } export function fakeRegimen ( ) { return fakeResource ( "s" , { name : "s" , color : "s" , regimen_items : [ ] , body : [ ] , } ) ; } export function fakeFarmEvent ( exe_type , exe_id ) { return fakeResource ( "s" , { "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : exe_id , "s" : exe_type , } ) ; } export function fakeLog ( ) { return fakeResource ( "s" , { id : idCounter ++ , message : "s" , type : MessageType . info , x : 0 , y : 0 , z : 0 , verbosity : 0 , major_version : 0 , minor_version : 0 , channels : [ "s" ] , created_at : 0 } ) ; } export function fakeImage ( ) { return fakeResource ( "s" , { id : idCounter ++ , device_id : idCounter ++ , attachment_processed_at : undefined , updated_at : new Date ( ) . toISOString ( ) , created_at : new Date ( ) . toISOString ( ) , attachment_url : "s" , meta : { x : 0 , y : 0 , z : 0 } } ) ; } export function fakeTool ( ) { return fakeResource ( "s" , { name : "s" } ) ; } export function fakeUser ( ) { return fakeResource ( "s" , { id : idCounter ++ , name : "s" , email : "s" , created_at : "s" , updated_at : "s" } ) ; } export function fakeToolSlot ( ) { return fakeResource ( "s" , { x : 0 , y : 0 , z : 0 , radius : 0 , pointer_type : "s" , meta : { } , tool_id : undefined , name : "s" , pullout_direction : 0 , gantry_mounted : false , } ) ; } export function fakePlant ( ) { return fakeResource ( "s" , { id : idCounter ++ , name : "s" , pointer_type : "s" , plant_stage : "s" , x : 0 , y : 0 , z : 0 , radius : 0 , meta : { } , openfarm_slug : "s" } ) ; } export function fakeDiagnosticDump ( ) { const string = "s" ; return fakeResource ( "s" , { id : idCounter ++ , device_id : idCounter ++ , ticket_identifier : string , fbos_commit : string , fbos_version : string , firmware_commit : string , firmware_state : string , network_interface : string , fbos_dmesg_dump : string , created_at : string , updated_at : string , } ) ; } export function fakePoint ( ) { return fakeResource ( "s" , { id : idCounter ++ , name : "s" , pointer_type : "s" , x : 0 , y : 0 , z : 0 , radius : 0 , meta : { created_by : "s" } } ) ; } export function fakeSavedGarden ( ) { return fakeResource ( "s" , { id : idCounter ++ , name : "s" , } ) ; } export function fakePlantTemplate ( ) { return fakeResource ( "s" , { id : idCounter ++ , saved_garden_id : idCounter ++ , radius : 0 , x : 0 , y : 0 , z : 0 , name : "s" , openfarm_slug : "s" , } ) ; } export function fakeWebcamFeed ( ) { const id = idCounter ++ ; return fakeResource ( "s" , { id , created_at : "s" , updated_at : "s" , url : "s" , name : "s" + id } ) ; } export function fakePinBinding ( ) { return fakeResource ( "s" , { id : idCounter ++ , pin_num : 0 , sequence_id : idCounter ++ , binding_type : PinBindingType . standard , } ) ; } export function fakeSensor ( ) { return fakeResource ( "s" , { id : idCounter ++ , label : "s" , mode : 0 , pin : 0 } ) ; } export function fakeSensorReading ( ) { return fakeResource ( "s" , { id : idCounter ++ , created_at : "s" , pin : 0 , value : 0 , mode : 0 , x : 0 , y : 0 , z : 0 , } ) ; } export function fakePeripheral ( ) { return fakeResource ( "s" , { id : ++ idCounter , label : "s" , pin : 0 } ) ; } export function fakeFbosConfig ( ) { return fakeResource ( "s" , { id : idCounter ++ , device_id : idCounter ++ , created_at : "s" , updated_at : "s" , auto_sync : false , beta_opt_in : false , disable_factory_reset : false , firmware_input_log : false , firmware_output_log : false , sequence_body_log : false , sequence_complete_log : false , sequence_init_log : false , network_not_found_timer : 0 , firmware_hardware : "s" , api_migrated : false , os_auto_update : false , arduino_debug_messages : false } ) ; } export function fakeWebAppConfig ( ) { return fakeResource ( "s" , { id : idCounter ++ , device_id : idCounter ++ , created_at : "s" , updated_at : "s" , assertion_log : 0 , confirm_plant_deletion : true , confirm_step_deletion : false , confirm_sequence_deletion : true , disable_animations : false , 0 : false , display_trail : false , dynamic_map : false , encoder_figure : false , hide_webcam_widget : false , legend_menu_open : false , raw_encoders : true , scaled_encoders : true , show_spread : false , show_farmbot : true , show_images : false , show_sensor_readings : false , show_plants : true , show_points : true , x_axis_inverted : false , y_axis_inverted : false , z_axis_inverted : true , bot_origin_quadrant : 0 , zoom_level : - 0 , success_log : 0 , busy_log : 0 , warn_log : 0 , error_log : 0 , info_log : 0 , fun_log : 0 , debug_log : 0 , stub_config : false , show_first_party_farmware : false , expand_step_options : false , hide_sensors : false , enable_browser_speak : false , photo_filter_begin : "s" , photo_filter_end : "s" , discard_unsaved : false , discard_unsaved_sequences : false , xy_swap : false , home_button_homing : false , show_motor_plot : false , show_historic_points : false , 0 : false , show_pins : false , disable_emergency_unlock_confirmation : false , map_size_x : 0 , map_size_y : 0 , user_interface_read_only_mode : false } ) ; } export function fakeFirmwareConfig ( ) { return fakeResource ( "s" , { device_id : idCounter ++ , created_at : "s" , updated_at : "s" , encoder_enabled_x : 0 , encoder_enabled_y : 0 , encoder_enabled_z : 0 , encoder_invert_x : 0 , encoder_invert_y : 0 , encoder_invert_z : 0 , encoder_missed_steps_decay_x : 0 , encoder_missed_steps_decay_y : 0 , encoder_missed_steps_decay_z : 0 , encoder_missed_steps_max_x : 0 , encoder_missed_steps_max_y : 0 , encoder_missed_steps_max_z : 0 , encoder_scaling_x : 0 , encoder_scaling_y : 0 , encoder_scaling_z : 0 , encoder_type_x : 0 , encoder_type_y : 0 , encoder_type_z : 0 , encoder_use_for_pos_x : 0 , encoder_use_for_pos_y : 0 , encoder_use_for_pos_z : 0 , movement_axis_nr_steps_x : 0 , movement_axis_nr_steps_y : 0 , movement_axis_nr_steps_z : 0 , movement_enable_endpoints_x : 0 , movement_enable_endpoints_y : 0 , movement_enable_endpoints_z : 0 , movement_home_at_boot_x : 0 , movement_home_at_boot_y : 0 , movement_home_at_boot_z : 0 , movement_home_spd_x : 0 , movement_home_spd_y : 0 , movement_home_spd_z : 0 , movement_home_up_x : 0 , movement_home_up_y : 0 , movement_home_up_z : 0 , movement_invert_endpoints_x : 0 , movement_invert_endpoints_y : 0 , movement_invert_endpoints_z : 0 , movement_invert_motor_x : 0 , movement_invert_motor_y : 0 , movement_invert_motor_z : 0 , movement_keep_active_x : 0 , movement_keep_active_y : 0 , movement_keep_active_z : 0 , movement_max_spd_x : 0 , movement_max_spd_y : 0 , movement_max_spd_z : 0 , movement_min_spd_x : 0 , movement_min_spd_y : 0 , movement_min_spd_z : 0 , movement_secondary_motor_invert_x : 0 , movement_secondary_motor_x : 0 , movement_step_per_mm_x : 0 , movement_step_per_mm_y : 0 , movement_step_per_mm_z : 0 , movement_microsteps_x : 0 , movement_microsteps_y : 0 , movement_microsteps_z : 0 , movement_motor_current_x : 0 , movement_motor_current_y : 0 , movement_motor_current_z : 0 , movement_stall_sensitivity_x : 0 , movement_stall_sensitivity_y : 0 , movement_stall_sensitivity_z : 0 , movement_steps_acc_dec_x : 0 , movement_steps_acc_dec_y : 0 , movement_steps_acc_dec_z : 0 , movement_stop_at_home_x : 0 , movement_stop_at_home_y : 0 , movement_stop_at_home_z : 0 , movement_stop_at_max_x : 0 , movement_stop_at_max_y : 0 , movement_stop_at_max_z : 0 , movement_timeout_x : 0 , movement_timeout_y : 0 , movement_timeout_z : 0 , param_config_ok : 0 , param_e_stop_on_mov_err : 0 , param_mov_nr_retry : 0 , param_test : 0 , param_use_eeprom : 0 , param_version : 0 , 0 : 0 , 0 : 0 , 0 : 0 , 0 : 0 , 0 : 0 , 0 : 0 , 0 : 0 , 0 : 0 , 0 : 0 , 0 : 0 , 0 : 0 , 0 : 0 , 0 : 0 , 0 : 0 , 0 : 0 , api_migrated : false } as FirmwareConfig ) ; } export function fakeFarmwareEnv ( ) { return fakeResource ( "s" , { key : "s" , value : "s" } ) ; } export function fakeFarmwareInstallation ( ) { return fakeResource ( "s" , { url : "s" , package : undefined , package_error : undefined , } ) ; } export function fakeAlert ( ) { return fakeResource ( "s" , { slug : "s" , created_at : 0 , problem_tag : "s" , priority : 0 , } ) ; } export function fakePointGroup ( ) { return fakeResource ( "s" , { name : "s" , sort_type : "s" , point_ids : [ ] } ) ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $T$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $RestResources$ O $any$ O O O O $any$ O O O O $number$ O O O O O $TaggedSequence$ O O O O $T$ O O O O $complex$ O O $number$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O $number$ O $number$ O O $string$ O O O $string$ O O O $string$ O O O $undefined[]$ O O O O O O O O O $TaggedRegimen$ O O O O $T$ O O O O $string$ O O O $string$ O O O $undefined[]$ O O O O $undefined[]$ O O O O O O O O O O $TaggedFarmEvent$ O $ExecutableType$ O $number$ O O O $T$ O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O $any$ O O O O O O O $TaggedLog$ O O O O $T$ O O O O $number$ O $number$ O O $string$ O O O $MessageType$ O $any$ O $MessageType.info$ O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string[]$ O O O O O $number$ O O O O O O O O $TaggedImage$ O O O O $T$ O O O O $number$ O $number$ O O $number$ O $number$ O O $undefined$ O $undefined$ O $string$ O O $DateConstructor$ O O O $string$ O O O $string$ O O $DateConstructor$ O O O $string$ O O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O O $TaggedTool$ O O O O $T$ O O O O $string$ O O O O O O O O $TaggedUser$ O O O O $T$ O O O O $number$ O $number$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O $TaggedToolSlotPointer$ O O O O $T$ O O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O ${}$ O O O O $undefined$ O $undefined$ O $string$ O O O $number$ O O O $boolean$ O O O O O O O O O $TaggedPlantPointer$ O O O O $T$ O O O O $number$ O $number$ O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O ${}$ O O O O $string$ O O O O O O O O $TaggedDiagnosticDump$ O O O O O O O O O $T$ O O O O $number$ O $number$ O O $number$ O $number$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O $TaggedGenericPointer$ O O O O $T$ O O O O $number$ O $number$ O O $string$ O O O $string$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $complex$ O O $string$ O O O O O O O O O $TaggedSavedGarden$ O O O O $T$ O O O O $number$ O $number$ O O $string$ O O O O O O O O O $TaggedPlantTemplate$ O O O O $T$ O O O O $number$ O $number$ O O $number$ O $number$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O $string$ O O O O O O O O O $TaggedWebcamFeed$ O O O O $number$ O $number$ O O O $T$ O O O O $number$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $number$ O O O O O O $TaggedPinBinding$ O O O O $T$ O O O O $number$ O $number$ O O $number$ O O O $number$ O $number$ O O $any$ O $any$ O $any$ O O O O O O O $TaggedSensor$ O O O O $T$ O O O O $number$ O $number$ O O $string$ O O O $number$ O O O $number$ O O O O O O O O $TaggedSensorReading$ O O O O $T$ O O O O $number$ O $number$ O O $string$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O O O O O $TaggedPeripheral$ O O O O $T$ O O O O $number$ O O $number$ O $string$ O O O $number$ O O O O O O O O $TaggedFbosConfig$ O O O O $T$ O O O O $number$ O $number$ O O $number$ O $number$ O O $string$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $number$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O O O O $TaggedWebAppConfig$ O O O O $T$ O O O O $number$ O $number$ O O $number$ O $number$ O O $string$ O O O $string$ O O O $number$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $number$ O O O $number$ O O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $string$ O O O $string$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $number$ O O O $number$ O O O $boolean$ O O O O O O O O $TaggedFirmwareConfig$ O O O O $T$ O O O O $number$ O $number$ O O $string$ O O O $string$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $boolean$ O O O O $any$ O O O O O $TaggedFarmwareEnv$ O O O O $T$ O O O O $string$ O O O $string$ O O O O O O O O $TaggedFarmwareInstallation$ O O O O $T$ O O O O $string$ O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O O O O $TaggedAlert$ O O O O $T$ O O O O $string$ O O O $number$ O O O $string$ O O O $number$ O O O O O O O O O $TaggedPointGroup$ O O O O $T$ O O O O $string$ O O O $string$ O O O $undefined[]$ O O O O O O O
import { AuthState } from "s" ; export let auth = { "s" : { "s" : { "s" : "s" , "s" : "s" , "s" : "s" + "s" } , "s" : "s" + "s" + "s" + "s" + "s" + "s" + "s" + "s" + "s" + "s" + "s" + "s" + "s" + "s" } } ;	O O $any$ O O O O O O $AuthState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { noop } from "s" ; import { Everything } from "s" ; import { peripherals as Peripheral } from "s" ; import { auth } from "s" ; import { bot } from "s" ; import { config } from "s" ; import { draggable } from "s" ; import { resources } from "s" ; export function fakeState ( _ = noop ) { return { dispatch : jest . fn ( ) , Peripheral , auth , bot , config , draggable , resources } ; }	O O $any$ O O O O O O $any$ O O O O O O $PeripheralState$ O $PeripheralState$ O O O O O O $AuthState$ O O O O O O $BotState$ O O O O O O $ConfigState$ O O O O O O $DraggableState$ O O O O O O $RestResources$ O O O O O O $Everything$ O $Function$ O $any$ O O O O $any$ O $any$ O $any$ O O O $PeripheralState$ O $AuthState$ O $BotState$ O $ConfigState$ O $DraggableState$ O $RestResources$ O O O
import { TimeSettings } from "s" ; export const fakeTimeSettings = ( ) : TimeSettings => ( { utcOffset : 0 , 0 : false , } ) ;	O O $any$ O O O O O O $TimeSettings$ O O O O $any$ O O O $number$ O O O $false$ O O O O O O
import { Coordinate } from "s" ; import { VariableNameSet } from "s" ; export const fakeVariableNameSet = ( label = "s" , vector = { x : 0 , y : 0 , z : 0 } ) : VariableNameSet => { const data_value = { kind : "s" , args : vector } ; return { [ label ] : { celeryNode : { kind : "s" , args : { label , data_value } } , dropdown : { label , value : "s" } , vector , } } ; } ;	O O $any$ O O O O O O $any$ O O O O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O $any$ O O O $Coordinate$ O O $string$ O O O $complex$ O $complex$ O O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O $any$ O O O $complex$ O O $string$ O $string$ O O O O $complex$ O O O O O O
import { Regimen } from "s" ; import { Sequence } from "s" ; import { FarmEvent } from "s" ; export type FarmEventWithExecutable = FarmEventWithRegimen | FarmEventWithSequence ; export interface FarmEventWithSequence extends FarmEvent { executable_type : "s" ; executable : Sequence ; } export interface FarmEventWithRegimen extends FarmEvent { executable_type : "s" ; executable : Regimen ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $Sequence$ O $any$ O O O O $any$ O $any$ O O O O O $Regimen$ O $any$ O O
import moment from "s" ; import { FarmEventWithExecutable } from "s" ; export const TIME = { MONDAY : moment ( "s" ) , TUESDAY : moment ( "s" ) , WEDNESDAY : moment ( "s" ) , THURSDAY : moment ( "s" ) , FRIDAY : moment ( "s" ) , SATURDAY : moment ( "s" ) } ; export let fakeFarmEventWithExecutable = ( ) : FarmEventWithExecutable => { return { id : 0 , start_time : "s" , repeat : 0 , time_unit : "s" , executable_id : 0 , executable_type : "s" , executable : { color : "s" , name : "s" , kind : "s" , args : { version : 0 , locals : { kind : "s" , args : { } } , } } } ; } ; export let calendarRows = [ { "s" : 0 , "s" : 0 , "s" : "s" , "s" : 0 , "s" : [ { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } ] } , { "s" : 0 , "s" : 0 , "s" : "s" , "s" : 0 , "s" : [ { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } ] } , { "s" : 0 , "s" : 0 , "s" : "s" , "s" : 0 , "s" : [ { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } , { "s" : "s" , "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } ] } ] ;	O $any$ O O O O O $any$ O O O O O O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $FarmEventWithExecutable$ O O O O $any$ O O O O $number$ O O O $string$ O O O $number$ O O O $string$ O O O $number$ O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $number$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O O O O O $complex$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ReactWrapper , ShallowWrapper } from "s" ; import { range } from "s" ; export function clickButton ( wrapper : ReactWrapper | ShallowWrapper , position , text , options ? : { partial_match ? : boolean , button_tag ? : string } ) { const btnTag = options && options . button_tag ? options . button_tag : "s" ; const button = wrapper . find ( btnTag ) . at ( position ) ; const expectedText = text . toLowerCase ( ) ; const actualText = button . text ( ) . toLowerCase ( ) ; options && options . partial_match ? expect ( actualText ) . toContain ( expectedText ) : expect ( actualText ) . toEqual ( expectedText ) ; button . simulate ( "s" ) ; } export function allButtonText ( wrapper : ReactWrapper | ShallowWrapper ) { const buttons = wrapper . find ( "s" ) ; const btnCount = buttons . length ; const btnPositions = range ( btnCount ) ; const btnTextArray = btnPositions . map ( position => wrapper . find ( "s" ) . at ( position ) . text ( ) ) ; return btnTextArray . join ( "s" ) ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O $number$ O $string$ O $complex$ O O O $boolean$ O O O O $string$ O O O O O O O $string$ O $complex$ O $complex$ O $string$ O $complex$ O $string$ O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $number$ O O O $string$ O $string$ O $string$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O $complex$ O $complex$ O $boolean$ O $any$ O $any$ O O $any$ O $string$ O O $any$ O $any$ O O $any$ O $string$ O O $any$ O $any$ O O O O O O O $string$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O
'js' function Whatever ( ) { var store = { items : { } } ; store . clear = jest . fn ( ( ) => store . items = { } ) ; store . getItem = ( key ) => store . items [ key ] ; store . isFakeStore = true ; store . removeItem = ( key ) => store . items [ key ] = undefined ; store . setItem = ( key , value ) => store . items [ key ] = value ; return store ; } global . localStorage = Whatever ( ) ; global . sessionStorage = Whatever ( ) ;	O O $complex$ O O O O $complex$ O O ${}$ O O O O O $complex$ O $any$ O $any$ O $any$ O O O O $complex$ O ${}$ O O O O O $complex$ O $any$ O O $any$ O O $complex$ O ${}$ O $any$ O O $complex$ O $any$ O O O $complex$ O $any$ O O $any$ O O $complex$ O ${}$ O $any$ O O $undefined$ O $complex$ O $any$ O O $any$ O $any$ O O $complex$ O ${}$ O $any$ O O $any$ O O $complex$ O O $any$ O $complex$ O $complex$ O O O $any$ O $complex$ O $complex$ O O O
'js' function Whatever ( ) { return { log : jest . fn ( function ( x , y , z ) { var fn = console [ z ] || console . log ; fn ( x ) y && console . dir ( y ) ; } ) } ; } global . logStore = Whatever ( ) ;	O O $complex$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $Console$ O $any$ O O $Console$ O $void$ O $any$ O $any$ O $any$ O $Console$ O $void$ O $any$ O O O O O O O $any$ O $complex$ O $complex$ O O O
import { MapTransformProps } from "s" ; export const fakeMapTransformProps = ( ) : MapTransformProps => { return { quadrant : 0 , gridSize : { x : 0 , y : 0 } , xySwap : false , } ; } ;	O O $any$ O O O O O O $MapTransformProps$ O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O O $false$ O O O O O O O
jest . resetAllMocks ( ) ; jest . mock ( "s" , ( ) => ( { fun : jest . fn ( ) , init : jest . fn ( ) , success : jest . fn ( ) , info : jest . fn ( ) , error : jest . fn ( ) , warning : jest . fn ( ) , busy : jest . fn ( ) , } ) ) ;	$any$ O $any$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O
import { HardwareFlags } from "s" ; export const fakeHardwareFlags = ( ) : HardwareFlags => { return { findHomeEnabled : { x : false , y : false , z : false } , stopAtHome : { x : false , y : false , z : false } , stopAtMax : { x : false , y : false , z : false } , negativeOnly : { x : false , y : false , z : false } , axisLength : { x : 0 , y : 0 , z : 0 } , } ; } ;	O O $any$ O O O O O O $HardwareFlags$ O O O O $any$ O O O O $complex$ O O $false$ O O O $false$ O O O $false$ O O O O $complex$ O O $false$ O O O $false$ O O O $false$ O O O O $complex$ O O $false$ O O O $false$ O O O $false$ O O O O $complex$ O O $false$ O O O $false$ O O O $false$ O O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O
'js' require ( "s" ) ; var Adapter = require ( 's' ) ; require ( 's' ) . configure ( { adapter : new Adapter ( ) } ) ;	O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O O $any$ O O $any$ O O $any$ O O O O O
import { User } from "s" ; import { TaggedUser , SpecialStatus } from "s" ; export let user = { created_at : "s" , email : "s" , id : 0 , name : "s" , updated_at : "s" } ; export let taggedUser = { kind : "s" , uuid : "s" , specialStatus : SpecialStatus . SAVED , body : { created_at : "s" , email : "s" , id : 0 , name : "s" , updated_at : "s" } } ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $User$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O $string$ O O O O O O $TaggedUser$ O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O $string$ O O O O O
import { DataChangeType , Dictionary } from "s" ; import { box } from "s" ; import { isNumber , isNaN } from "s" ; export let METHOD_MAP < DataChangeType > = { "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" } ; export let METHODS = [ "s" , "s" , "s" , "s" ] ; export function inferUpdateId ( url ) { try { const ids = url . split ( "s" ) . filter ( x => ! x . includes ( "s" ) ) . map ( x => parseInt ( x , 0 ) ) . filter ( x => ! isNaN ( x ) ) ; const id : number | undefined = ids [ 0 ] ; const isNum = isNumber ( id ) ; const onlyOne = ids . length === 0 ; return ( isNum && onlyOne ) ? ( "s" + id ) : "s" ; } catch ( error ) { return "s" ; } } export interface SafeError { request : { responseURL : string ; } , response : { status : number ; } ; } export function isSafeError ( x : SafeError | any ) : x is SafeError { return ! ! ( ( box ( x ) . kind === "s" ) && ( box ( x . response ) . kind === "s" ) && ( box ( x . response . status ) . kind === "s" ) ) ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $Dictionary$ O $any$ O O O O O O O O O O O O O O O O O O O O O O $string[]$ O O O O O O O O O O O O O $string$ O $string$ O O O O O $number[]$ O $string$ O $complex$ O O O O $complex$ O $string$ O O $string$ O $boolean$ O O O O O $U[]$ O $string$ O $number$ O $string$ O O O O O $complex$ O $number$ O O $any$ O $number$ O O O O $number$ O O O O O $number[]$ O O O O O $any$ O $any$ O $number$ O O O $boolean$ O $number[]$ O $number$ O O O O O $any$ O $boolean$ O O O O O $number$ O O O O O O O $any$ O O O O O O O O O $any$ O $complex$ O O $string$ O O O O O $complex$ O O $number$ O O O O O O O O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O
import { SafeError , isSafeError } from "s" ; import { API } from "s" ; import { AuthState } from "s" ; import { AxiosRequestConfig , AxiosResponse } from "s" ; import { Content } from "s" ; import { dispatchNetworkUp , dispatchNetworkDown } from "s" ; import { Dictionary } from "s" ; import { outstandingRequests } from "s" ; import { Session } from "s" ; import { get } from "s" ; import { t } from "s" ; import { error } from "s" ; import { now } from "s" ; export function responseFulfilled ( input ) { dispatchNetworkUp ( "s" , now ( ) ) ; return input ; } const request : keyof SafeError = "s" ; const responseUrl : keyof SafeError [ "s" ] = "s" ; export const isLocalRequest = ( x ) => get ( x , [ request , responseUrl ] , "s" ) . includes ( API . current . baseUrl ) ; let ONLY_ONCE = true ; export function responseRejected ( x : SafeError | undefined ) { if ( x && isSafeError ( x ) ) { dispatchNetworkUp ( "s" , now ( ) ) ; const a = ! [ 0 , 0 , 0 ] . includes ( x . response . status ) ; const b = x . response . status > 0 ; const c = ! get ( x , "s" , "s" ) . includes ( "s" ) ; if ( a && b && c ) { setTimeout ( ( ) => { const msg = `template` ; throw new Error ( msg ) ; } , 0 ) ; } switch ( x . response . status ) { case 0 : isLocalRequest ( x ) && Session . clear ( ) ; break ; case 0 : break ; case 0 : error ( t ( "s" ) ) ; break ; case 0 : ONLY_ONCE && alert ( t ( Content . TOS_UPDATE ) ) ; ONLY_ONCE = false ; window . location . assign ( "s" ) ; break ; } return Promise . reject ( x ) ; } else { dispatchNetworkDown ( "s" , now ( ) ) ; return Promise . reject ( x ) ; } } export function requestFulfilled ( auth ) { return ( config ) => { const req = config . url || "s" ; const isAPIRequest = req . includes ( API . current . baseUrl ) ; if ( isAPIRequest ) { config . headers = config . headers || { } ; const headers < string > = config . headers ; headers [ "s" ] = outstandingRequests . last ; headers . Authorization = auth . token . encoded || "s" ; } return config ; } ; }	O O $any$ O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O $void$ O O O O O O $any$ O O O O O O $NonSense$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $number$ O O O O O O $AxiosResponse$ O $AxiosResponse$ O O $void$ O O O $number$ O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $SafeError$ O O $any$ O $SafeError$ O O O O O O O O O O $any$ O $any$ O $API$ O $string$ O O O $boolean$ O O O O O $Promise<never>$ O $SafeError$ O $any$ O O O O O O $SafeError$ O $complex$ O $SafeError$ O O O $void$ O O O $number$ O O O O O $boolean$ O O O O O O O O O O $boolean$ O $SafeError$ O $complex$ O $number$ O O O $boolean$ O $SafeError$ O $complex$ O $number$ O O O O $boolean$ O O $any$ O $SafeError$ O O O O O O $any$ O O O O O O $boolean$ O $boolean$ O $boolean$ O O $number$ O O O O O O $string$ O O O O O $ErrorConstructor$ O $string$ O O O O O O O O O O $SafeError$ O $complex$ O $number$ O O O O O $any$ O $SafeError$ O O $any$ O $never$ O O O O O O O O O O O O O $void$ O $any$ O O O O O O O O O O $boolean$ O $void$ O $any$ O $any$ O $string$ O O O $boolean$ O O O $complex$ O $Location$ O $void$ O O O O O O O O $PromiseConstructor$ O $Promise<T>$ O $SafeError$ O O O O O $void$ O O O $number$ O O O O O $PromiseConstructor$ O $Promise<T>$ O $SafeError$ O O O O O O $any$ O $AuthState$ O O O O $AxiosRequestConfig$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $API$ O $string$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $Dictionary$ O O O O $any$ O $any$ O $any$ O O O O $NonSense$ O $string$ O $any$ O $any$ O $AuthState$ O $Token$ O $string$ O O O O O $any$ O O O O
import axios from "s" ; import { FarmwareManifestEntry } from "s" ; import { Actions } from "s" ; import { urlFor } from "s" ; const farmwareManifestUrl = "s" + "s" ; export const getFirstPartyFarmwareList = ( ) => { return ( dispatch ) => { axios . get < FarmwareManifestEntry [ ] > ( farmwareManifestUrl ) . then ( r => { const names = r . data . map ( ( fw ) => fw . name ) ; dispatch ( { type : Actions . FETCH_FIRST_PARTY_FARMWARE_NAMES_OK , payload : names } ) ; } ) ; } ; } ; export const retryFetchPackageName = ( id : number | undefined ) => id && axios . post ( `template` ) . then ( ( ) => { } ) ;	O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O $string$ O O O O O O O $void$ O O O O O O O $Function$ O O O $any$ O $any$ O $any$ O O O O $string$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $FarmwareManifestEntry$ O O $complex$ O $string$ O O $Function$ O O $Actions$ O $any$ O $Actions.FETCH_FIRST_PARTY_FARMWARE_NAMES_OK$ O $any$ O $any$ O O O O O O O O O O O O $any$ O O $number$ O O O O O O $number$ O $any$ O $any$ O O O O $any$ O O O O O O O O
import axios from "s" ; import { fetchReleases , fetchMinOsFeatureData , FEATURE_MIN_VERSIONS_URL , fetchLatestGHBetaRelease } from "s" ; import { AuthState } from "s" ; import { ReduxAction } from "s" ; import * as Sync from "s" ; import { API } from "s" ; import { responseFulfilled , responseRejected , requestFulfilled } from "s" ; import { Actions } from "s" ; import { connectDevice } from "s" ; import { getFirstPartyFarmwareList } from "s" ; import { readOnlyInterceptor } from "s" ; export function didLogin ( authState , dispatch ) { API . setBaseUrl ( authState . token . unencoded . iss ) ; const { os_update_server , beta_os_update_server } = authState . token . unencoded ; dispatch ( fetchReleases ( os_update_server ) ) ; beta_os_update_server && beta_os_update_server != "s" && dispatch ( fetchLatestGHBetaRelease ( beta_os_update_server ) ) ; dispatch ( getFirstPartyFarmwareList ( ) ) ; dispatch ( fetchMinOsFeatureData ( FEATURE_MIN_VERSIONS_URL ) ) ; dispatch ( setToken ( authState ) ) ; Sync . fetchSyncData ( dispatch ) ; dispatch ( connectDevice ( authState ) ) ; } export function setToken ( auth ) < AuthState > { axios . interceptors . request . use ( readOnlyInterceptor ) ; axios . interceptors . request . use ( requestFulfilled ( auth ) ) ; axios . interceptors . response . use ( responseFulfilled , responseRejected ) ; return { type : Actions . REPLACE_TOKEN , payload : auth } ; }	O $any$ O O O O O $void$ O $void$ O $string$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $Promise<never>$ O $any$ O O O O O O $any$ O O O O O O $Promise<void>$ O O O O O O $void$ O O O O O O $any$ O O O O O O $void$ O $AuthState$ O $Function$ O O $any$ O $void$ O $AuthState$ O $Token$ O $UnencodedToken$ O $string$ O O O O $string$ O $string$ O O $AuthState$ O $Token$ O $UnencodedToken$ O $Function$ O $void$ O $string$ O O O $string$ O $string$ O O O $Function$ O $void$ O $string$ O O O $Function$ O $void$ O O O O $Function$ O $void$ O $string$ O O O $Function$ O $ReduxAction<AuthState>$ O $AuthState$ O O O $any$ O $Promise<void>$ O $Function$ O O $Function$ O $Promise<void>$ O $AuthState$ O O O O O O $ReduxAction$ O $AuthState$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $AuthState$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $Promise<never>$ O O O O $Actions.REPLACE_TOKEN$ O $any$ O $Actions.REPLACE_TOKEN$ O $AuthState$ O $AuthState$ O O O
import axios , { AxiosResponse } from "s" ; import { API } from "s" ; import { AuthState } from "s" ; import { setToken } from "s" ; const ok = ( x < AuthState > ) => { setToken ( x . data ) ; return x . data ; } ; export let maybeRefreshToken = ( old ) : Promise < AuthState | undefined > => { API . setBaseUrl ( old . token . unencoded . iss ) ; setToken ( old ) ; return axios . get < AuthState > ( API . current . tokensPath ) . then ( ok , ( ) => Promise . resolve ( undefined ) ) ; } ;	O $any$ O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $ReduxAction<AuthState>$ O O O O O $any$ O O $AxiosResponse$ O $any$ O O O O $ReduxAction<AuthState>$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $Promise<AuthState>$ O O $AuthState$ O O $PromiseConstructor$ O $any$ O O O O O $any$ O $void$ O $AuthState$ O $Token$ O $UnencodedToken$ O $string$ O O $ReduxAction<AuthState>$ O $AuthState$ O O O $any$ O $any$ O $any$ O O $any$ O $API$ O $string$ O O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O $undefined$ O O O O O
import { didLogin , setToken } from "s" ; import { Thunk } from "s" ; import { Session } from "s" ; import { maybeRefreshToken } from "s" ; import { AuthState } from "s" ; import { timeout } from "s" ; export const storeToken = ( old , dispatch ) => ( _new : AuthState | undefined ) => { const t = _new || old ; ( ! _new ) && console . warn ( "s" ) ; dispatch ( setToken ( t ) ) ; didLogin ( t , dispatch ) ; } ; const MAX_TOKEN_WAIT_TIME = 0 ; export function ready ( ) { return ( dispatch , getState ) => { const auth = Session . fetchStoredToken ( ) || getState ( ) . auth ; if ( auth ) { const ok = storeToken ( auth , dispatch ) ; const no = ( ) => ok ( undefined ) ; const p = maybeRefreshToken ( auth ) ; timeout ( p , MAX_TOKEN_WAIT_TIME ) . then ( ok , no ) ; } else { Session . clear ( ) ; } } ; }	O O $void$ O $ReduxAction<AuthState>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Promise<AuthState>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O $AuthState$ O $Function$ O O O $AuthState$ O $any$ O O O O O O $AuthState$ O $AuthState$ O $AuthState$ O O O $AuthState$ O O $Console$ O $void$ O O O O $Function$ O $ReduxAction<AuthState>$ O $AuthState$ O O O $void$ O $AuthState$ O $Function$ O O O O O O O O O O O $Thunk$ O O O O O $Function$ O $GetState$ O O O O $AuthState$ O $any$ O $AuthState$ O O O $GetState$ O O O $AuthState$ O O O $AuthState$ O O O $void$ O $void$ O $AuthState$ O $Function$ O O O $void$ O O O O $void$ O $undefined$ O O O $Promise<AuthState>$ O $Promise<AuthState>$ O $AuthState$ O O $any$ O $Promise<AuthState>$ O O O O $any$ O $void$ O $void$ O O O O O $any$ O $never$ O O O O O O O
jest . mock ( "s" , ( ) => { return { attachToRoot : jest . fn ( ) , trim : jest . fn ( x => x ) } ; } ) ; jest . mock ( "s" , ( ) => { return { store : { dispatch : jest . fn ( ) } } ; } ) ; jest . mock ( "s" , ( ) => ( { DevSettings : { futureFeaturesEnabled : ( ) => false , } } ) ) ; jest . mock ( "s" , ( ) => { return { ready : ( ) => ( { type : "s" } ) } ; } ) ; import { attachAppToDom , RootComponent } from "s" ; import { attachToRoot } from "s" ; import { store } from "s" ; import { ready } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { attachAppToDom ( ) ; const 0 = { store } ; expect ( attachToRoot ) . toHaveBeenCalledWith ( RootComponent , 0 ) ; expect ( store . dispatch ) . toHaveBeenCalledWith ( ready ( ) ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $boolean$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O O $complex$ O O O O O O $string$ O O O O O O O O O O O $any$ O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O $Thunk$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $complex$ O O $any$ O O $any$ O $void$ O O $any$ O $any$ O $complex$ O O $any$ O $any$ O $any$ O O $any$ O $Thunk$ O O O O O O O O O O
class mockFarmbot { connect = ( ) => Promise . resolve ( this ) ; } jest . mock ( "s" , ( ) => { return { Farmbot : mockFarmbot } ; } ) ; import { fetchNewDevice } from "s" ; import { auth } from "s" ; import { get } from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const bot = await fetchNewDevice ( auth ) ; expect ( bot ) . toBeInstanceOf ( mockFarmbot ) ; expect ( get ( global , "s" ) ) . toBeDefined ( ) ; } ) ; } ) ;	O $any$ O $Promise<this>$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $Promise<any>$ O O O O O O $AuthState$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O $AuthState$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O
class mockFarmbot { connect = ( ) => Promise . resolve ( this ) ; } jest . mock ( "s" , ( ) => { return { Farmbot : mockFarmbot } ; } ) ; import { getDevice } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( ( ) => getDevice ( ) ) . toThrow ( "s" ) ; } ) ; } ) ;	O $any$ O $Promise<this>$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O O O O O
jest . mock ( "s" , ( ) => { return { get : jest . fn ( ( _url ) => { return Promise . reject ( "s" ) ; } ) } ; } ) ; import { generateUrl , getUserLang } from "s" ; import axios from "s" ; const LANG_CODE = "s" ; const HOST = "s" ; const PORT = "s" ; describe ( "s" , ( ) => { it ( "s" , ( done ) => { getUserLang ( LANG_CODE , HOST , PORT ) . then ( ( result ) => { expect ( axios . get ) . toHaveBeenCalled ( ) ; expect ( axios . get ) . toHaveBeenCalledWith ( generateUrl ( LANG_CODE , HOST , PORT ) ) ; expect ( result ) . toEqual ( "s" ) ; done ( ) ; } ) . catch ( ( x ) => { fail ( x . message ) ; } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O O O O O O O O O $string$ O $any$ O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O $any$ O O O O O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $string$ O O O O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O O O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O
jest . mock ( "s" , ( ) => ( { get : jest . fn ( ( ) => Promise . resolve ( { data : { "s" : { "s" : "s" } , "s" : { "s" : "s" } , "s" : { "s" : "s" } } } ) ) } ) ) ; import { generateUrl , getUserLang , 0 } from "s" ; import axios from "s" ; const LANG_CODE = "s" ; const HOST = "s" ; const PORT = "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = generateUrl ( LANG_CODE , HOST , PORT ) ; expect ( result ) . toBe ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( done ) => { getUserLang ( LANG_CODE , HOST , PORT ) . then ( result => { expect ( axios . get ) . toHaveBeenCalled ( ) ; expect ( axios . get ) . toHaveBeenCalledWith ( generateUrl ( LANG_CODE , HOST , PORT ) ) ; expect ( result ) . toEqual ( "s" ) ; done ( ) ; } ) . catch ( x => fail ( x . message ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const result = await 0 ( "s" ) ; expect ( result . lng ) . toBe ( "s" ) ; result . resources ? expect ( result . resources . en . translation ) . toEqual ( { A : "s" , C : "s" , D : "s" } ) : expect ( result . resources ) . toBeTruthy ( ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O $complex$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O $Promise<any>$ O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $string$ O $string$ O O O O O O O O $any$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $string$ O O O O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $Promise<any>$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O
jest . mock ( "s" , ( ) => { return { getDevice : ( ) => ( { publish : jest . fn ( ) } ) } ; } ) ; import { isSafeError , inferUpdateId } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const notSafe = { response : { status : "s" } } ; expect ( isSafeError ( notSafe ) ) . toBe ( false ) ; const safe = { response : { status : 0 } } ; expect ( isSafeError ( safe ) ) . toBe ( true ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( inferUpdateId ( "s" ) ) . toBe ( "s" ) ; expect ( inferUpdateId ( ( true as any ) ) ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( inferUpdateId ( "s" ) ) . toBe ( "s" ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $complex$ O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $complex$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $complex$ O O $string$ O O O O O $any$ O $complex$ O $complex$ O O O $any$ O O O O O $complex$ O O $complex$ O O $number$ O O O O O $any$ O $complex$ O $complex$ O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $string$ O O O O O $any$ O O O O $any$ O $string$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $string$ O O O O O $any$ O O O O O O O O O O
jest . mock ( "s" , ( ) => { return { startTracking : jest . fn ( ) , outstandingRequests : { last : "s" } } ; } ) ; jest . mock ( "s" , ( ) => { return { dispatchNetworkUp : jest . fn ( ) , dispatchNetworkDown : jest . fn ( ) , } ; } ) ; jest . mock ( "s" , ( ) => ( { Session : { clear : jest . fn ( ) } } ) ) ; import { responseFulfilled , isLocalRequest , requestFulfilled , responseRejected } from "s" ; import { AxiosResponse , Method } from "s" ; import { uuid } from "s" ; import { startTracking } from "s" ; import { SafeError } from "s" ; import { API } from "s" ; import { auth } from "s" ; import { dispatchNetworkUp , dispatchNetworkDown } from "s" ; import { Session } from "s" ; import { error } from "s" ; const ANY_NUMBER = expect . any ( Number ) ; interface FakeProps { uuid : string ; method : Method ; requestId : string ; url : string ; } function fakeResponse ( config < FakeProps > ) { const output < AxiosResponse > = { headers : { "s" : config . uuid || uuid ( ) } , config : { method : config . method || "s" , url : config . url || "s" } } ; return output as AxiosResponse ; } describe ( "s" , ( ) => { it ( "s" , ( ) => { const resp = fakeResponse ( { method : "s" , url : "s" } ) ; responseFulfilled ( resp ) ; expect ( startTracking ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await expect ( responseRejected ( undefined ) ) . rejects . toEqual ( undefined ) ; expect ( dispatchNetworkUp ) . not . toHaveBeenCalled ( ) ; expect ( dispatchNetworkDown ) . toHaveBeenCalledWith ( "s" , ANY_NUMBER ) ; } ) ; it ( "s" , async ( ) => { const safeError = { request : { responseURL : "s" } , response : { status : 0 } } ; await expect ( responseRejected ( safeError ) ) . rejects . toEqual ( safeError ) ; expect ( dispatchNetworkDown ) . not . toHaveBeenCalled ( ) ; expect ( dispatchNetworkUp ) . toHaveBeenCalledWith ( "s" , ANY_NUMBER ) ; } ) ; it ( "s" , async ( ) => { const safeError = { request : { responseURL : "s" } , response : { status : 0 } } ; await expect ( responseRejected ( safeError ) ) . rejects . toEqual ( safeError ) ; expect ( error ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { const safeError = { request : { responseURL : "s" } , response : { status : 0 } } ; API . setBaseUrl ( "s" ) ; await expect ( responseRejected ( safeError ) ) . rejects . toEqual ( safeError ) ; expect ( Session . clear ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , async ( ) => { const safeError = { request : { responseURL : "s" } , response : { status : 0 } } ; window . alert = jest . fn ( ) ; window . location . assign = jest . fn ( ) ; await expect ( responseRejected ( safeError ) ) . rejects . toEqual ( safeError ) ; expect ( window . alert ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; expect ( window . location . assign ) . toHaveBeenCalledWith ( "s" ) ; await expect ( responseRejected ( safeError ) ) . rejects . toEqual ( safeError ) ; expect ( window . alert ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; } ) ; const fake = ( responseURL ) : Partial < SafeError > => ( { request : { responseURL } } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { API . setBaseUrl ( "s" ) ; const openfarm = fake ( "s" ) as SafeError ; expect ( isLocalRequest ( openfarm ) ) . toBe ( false ) ; const api = fake ( "s" ) as SafeError ; expect ( isLocalRequest ( api ) ) . toBe ( true ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { API . setBaseUrl ( "s" ) ; const config = requestFulfilled ( auth ) ( { url : "s" } ) ; expect ( config ) . toEqual ( { url : "s" } ) ; } ) ; it ( "s" , ( ) => { API . setBaseUrl ( "s" ) ; const config = requestFulfilled ( auth ) ( { url : "s" } ) ; expect ( config . url ) . toEqual ( "s" ) ; expect ( config . headers . Authorization ) . toEqual ( auth . token . encoded ) ; expect ( config . headers [ "s" ] ) . toEqual ( "s" ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $complex$ O O $string$ O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $Promise<never>$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $AuthState$ O O O O O O $void$ O $void$ O O O O O O $any$ O O O O O O $void$ O O O O O $any$ O $any$ O $any$ O $NumberConstructor$ O O O $any$ O $string$ O O O $any$ O $any$ O $string$ O O O $string$ O O O O O $AxiosResponse$ O $Partial$ O $any$ O O O O $Partial$ O $any$ O O O $complex$ O O O O $Partial<FakeProps>$ O $string$ O $any$ O O O O $complex$ O O $any$ O $Partial<FakeProps>$ O $any$ O O O $string$ O $Partial<FakeProps>$ O $string$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O O $any$ O $void$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $Promise<never>$ O $undefined$ O O O $any$ O $any$ O $undefined$ O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $void$ O O $any$ O O O $any$ O O O O O $any$ O O O O O O O O O $SafeError$ O O $complex$ O O $string$ O O O O $complex$ O O $number$ O O O O O O $any$ O $Promise<never>$ O $SafeError$ O O O $any$ O $any$ O $SafeError$ O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $void$ O O $any$ O O O $any$ O O O O O $any$ O O O O O O O O O $SafeError$ O O $complex$ O O $string$ O O O O $complex$ O O $number$ O O O O O O $any$ O $Promise<never>$ O $SafeError$ O O O $any$ O $any$ O $SafeError$ O O $any$ O $void$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O $SafeError$ O O $complex$ O O $string$ O O O O $complex$ O O $number$ O O O O O $any$ O $void$ O O O O O $any$ O $Promise<never>$ O $SafeError$ O O O $any$ O $any$ O $SafeError$ O O $any$ O $any$ O $never$ O O $any$ O O O O O O $any$ O O O O O O O O O $SafeError$ O O $complex$ O O $string$ O O O O $complex$ O O $number$ O O O O O $complex$ O $void)$ O $any$ O $any$ O O O $complex$ O $Location$ O $void$ O $any$ O $any$ O O O O $any$ O $Promise<never>$ O $SafeError$ O O O $any$ O $any$ O $SafeError$ O O $any$ O $complex$ O $void)$ O O $any$ O $any$ O $any$ O O O O O $any$ O $complex$ O $Location$ O $void$ O O $any$ O O O O O $any$ O $Promise<never>$ O $SafeError$ O O O $any$ O $any$ O $SafeError$ O O $any$ O $complex$ O $void)$ O O $any$ O O O O O O O O O O O $Partial<SafeError>$ O O $string$ O O $any$ O $any$ O O O O $complex$ O O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $void$ O O O O O $SafeError$ O $Partial<SafeError>$ O O O O $any$ O $any$ O $any$ O $SafeError$ O O O $any$ O O O O O $SafeError$ O $Partial<SafeError>$ O O O O $any$ O $any$ O $any$ O $SafeError$ O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $void$ O O O O O $any$ O $any$ O $AuthState$ O O O $string$ O O O O O $any$ O $any$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O $any$ O $void$ O O O O O $any$ O $any$ O $AuthState$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $AuthState$ O $Token$ O $string$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O
import { TaggedUser } from "s" ; import { GetWebAppConfigValue } from "s" ; import { Thunk } from "s" ; export interface Props { user : TaggedUser ; dispatch : Function ; getConfigValue : GetWebAppConfigValue ; } export interface DeletionRequest { password : string ; } export interface DangerousDeleteProps { title : string ; warning : string ; confirmation : string ; dispatch : Function ; onClick ( payload ) : Thunk ; } export interface DangerousDeleteState extends DeletionRequest { } export interface SettingsPropTypes { user : TaggedUser ; onChange : React . EventHandler < React . FormEvent < HTMLInputElement > > ; onSave : React . EventHandler < React . MouseEvent < HTMLButtonElement > > ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $Function$ O $FunctionConstructor$ O $GetWebAppConfigValue$ O $any$ O O O O $any$ O $string$ O O O O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $Function$ O $FunctionConstructor$ O $Thunk$ O $DeletionRequest$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O
import { BotState , Xyz , BotPosition , ShouldDisplay } from "s" ; import { 0 , McuParams } from "s" ; import { TaggedWebcamFeed , TaggedPeripheral , TaggedSensor , TaggedSensorReading } from "s" ; import { NetworkState } from "s" ; import { GetWebAppConfigValue } from "s" ; import { TimeSettings } from "s" ; export interface Props { dispatch : Function ; bot : BotState ; feeds : TaggedWebcamFeed [ ] ; peripherals : TaggedPeripheral [ ] ; sensors : TaggedSensor [ ] ; botToMqttStatus : NetworkState ; firmwareSettings : McuParams ; shouldDisplay : ShouldDisplay ; getWebAppConfigVal : GetWebAppConfigValue ; sensorReadings : TaggedSensorReading [ ] ; timeSettings : TimeSettings ; } export interface AxisDisplayGroupProps { position : BotPosition ; label : string ; } export interface AxisInputBoxGroupProps { onCommit : ( v ) => void ; position : BotPosition ; disabled : boolean | undefined ; } export interface AxisInputBoxGroupState { x ? : number | undefined ; y ? : number | undefined ; z ? : number | undefined ; } export interface AxisInputBoxProps { axis : Xyz ; value : number | undefined ; onChange : ( key , val : number | undefined ) => void ; } export interface ToggleButtonProps { toggleAction : ( ) => void ; toggleValue : number | string | boolean | undefined ; disabled ? : boolean | undefined ; customText ? : { textFalse : string , textTrue : string } ; dim ? : boolean ; grayscale ? : boolean ; title ? : string ; }	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $BotState$ O $any$ O $any[]$ O $any$ O O O $any[]$ O $any$ O O O $any[]$ O $any$ O O O $NetworkState$ O $any$ O $any$ O $any$ O $ShouldDisplay$ O $any$ O $GetWebAppConfigValue$ O $any$ O $any[]$ O $any$ O O O $TimeSettings$ O $any$ O O O O $any$ O $complex$ O $any$ O $string$ O O O O O O $any$ O $void$ O O $Vector3$ O O O O $complex$ O $any$ O $boolean$ O O O O O O O O $any$ O $number$ O O O O O O $number$ O O O O O O $number$ O O O O O O O O O $any$ O $Xyz$ O $any$ O $number$ O O O O O $void$ O O $string$ O $number$ O O O O O O O O O O O $any$ O $void$ O O O O O O $complex$ O O O O O O O O O $boolean$ O O O O O O $complex$ O O O $string$ O O O $string$ O O O O $boolean$ O O O O $boolean$ O O O O $string$ O O O O O
import { TaggedSensor } from "s" ; import { Pins } from "s" ; export interface SensorState { isEditing : boolean ; } export interface SensorFormProps { dispatch : Function ; sensors : TaggedSensor [ ] ; } export interface SensorListProps { dispatch : Function ; sensors : TaggedSensor [ ] ; pins : Pins ; disabled : boolean | undefined ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $boolean$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any[]$ O $any$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any[]$ O $any$ O O O $any$ O $any$ O $boolean$ O O O O O O
import { TaggedWebcamFeed } from "s" ; export interface WebcamPanelProps { onToggle ( ) : void ; feeds : TaggedWebcamFeed [ ] ; init ( ) : void ; edit ( tr , changes < typeof tr . body > ) : void ; save ( tr ) : void ; destroy ( tr ) : void ; }	O O $any$ O O O O O O $any$ O $void$ O O O O O $any[]$ O $any$ O O O $void$ O O O O O $void$ O $TaggedWebcamFeed$ O $Partial$ O O $any$ O $any$ O O O O O $void$ O $TaggedWebcamFeed$ O O O O $void$ O $TaggedWebcamFeed$ O O O O O
import { BotState , Xyz , SourceFwConfig , ControlPanelState , ShouldDisplay } from "s" ; import { McuParamName , McuParams , FirmwareHardware } from "s" ; import { IntegerSize } from "s" ; import { FirmwareConfig } from "s" ; import { ResourceIndex } from "s" ; export interface HomingRowProps { hardware : McuParams ; botDisconnected : boolean ; } export interface ZeroRowProps { botDisconnected : boolean ; } export interface HomingAndCalibrationProps { dispatch : Function ; bot : BotState ; sourceFwConfig : SourceFwConfig ; firmwareConfig : FirmwareConfig | undefined ; botDisconnected : boolean ; } export interface BooleanMCUInputGroupProps { sourceFwConfig : SourceFwConfig ; dispatch : Function ; tooltip : string ; name : string ; x : McuParamName ; y : McuParamName ; z : McuParamName ; disable ? : Record < Xyz , boolean > ; grayscale ? : Record < Xyz , boolean > ; caution ? : boolean | undefined ; displayAlert ? : string | undefined ; } export interface CalibrationRowProps { hardware : McuParams ; botDisconnected : boolean ; } export interface NumericMCUInputGroupProps { sourceFwConfig : SourceFwConfig ; dispatch : Function ; tooltip : string ; name : string ; x : McuParamName ; xScale ? : number ; y : McuParamName ; yScale ? : number ; z : McuParamName ; zScale ? : number ; float ? : boolean ; intSize ? : IntegerSize ; gray ? : Record < Xyz , boolean > ; } export interface PinGuardMCUInputGroupProps { sourceFwConfig : SourceFwConfig ; dispatch : Function ; name : string ; pinNumKey : McuParamName ; timeoutKey : McuParamName ; activeStateKey : McuParamName ; resources : ResourceIndex ; } export interface PinGuardProps { dispatch : Function ; controlPanelState : ControlPanelState ; sourceFwConfig : SourceFwConfig ; resources : ResourceIndex ; } export interface MotorsProps { dispatch : Function ; firmwareVersion : string | undefined ; controlPanelState : ControlPanelState ; sourceFwConfig : SourceFwConfig ; isValidFwConfig : boolean ; firmwareHardware : FirmwareHardware | undefined ; } export interface EncodersProps { dispatch : Function ; shouldDisplay : ShouldDisplay ; controlPanelState : ControlPanelState ; sourceFwConfig : SourceFwConfig ; } export interface DangerZoneProps { dispatch : Function ; controlPanelState : ControlPanelState ; onReset ( ) : void ; botDisconnected : boolean ; }	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $boolean$ O O O O O O $any$ O $boolean$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $BotState$ O $any$ O $SourceFwConfig$ O $any$ O $any$ O $any$ O O O $boolean$ O O O O O O $any$ O $SourceFwConfig$ O $any$ O $Function$ O $FunctionConstructor$ O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O O O O $boolean$ O O O O O O $string$ O O O O O O O O O $any$ O $any$ O $any$ O $boolean$ O O O O O O $any$ O $SourceFwConfig$ O $any$ O $Function$ O $FunctionConstructor$ O $string$ O O O $string$ O O O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $number$ O O O O $boolean$ O O O O $IntegerSize$ O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O $any$ O $SourceFwConfig$ O $any$ O $Function$ O $FunctionConstructor$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $ResourceIndex$ O $any$ O O O O $any$ O $Function$ O $FunctionConstructor$ O $ControlPanelState$ O $any$ O $SourceFwConfig$ O $any$ O $ResourceIndex$ O $any$ O O O O $any$ O $Function$ O $FunctionConstructor$ O $string$ O O O O O $ControlPanelState$ O $any$ O $SourceFwConfig$ O $any$ O $boolean$ O O O $any$ O $any$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $ShouldDisplay$ O $any$ O $ControlPanelState$ O $any$ O $SourceFwConfig$ O $any$ O O O O $any$ O $Function$ O $FunctionConstructor$ O $ControlPanelState$ O $any$ O $void$ O O O O O $boolean$ O O O O
import { SourceFbosConfig , BotState , ControlPanelState , ShouldDisplay , SaveFarmwareEnv , UserEnv } from "s" ; import { InformationalSettings , TaggedDevice , Alert } from "s" ; import { TimeSettings } from "s" ; export interface AutoSyncRowProps { dispatch : Function ; sourceFbosConfig : SourceFbosConfig ; } export interface AutoUpdateRowProps { dispatch : Function ; sourceFbosConfig : SourceFbosConfig ; } export interface CameraSelectionProps { env : UserEnv ; botOnline : boolean ; saveFarmwareEnv : SaveFarmwareEnv ; shouldDisplay : ShouldDisplay ; dispatch : Function ; } export interface CameraSelectionState { cameraStatus : "s" | "s" | "s" | "s" ; } export interface BoardTypeProps { botOnline : boolean ; bot : BotState ; alerts : Alert [ ] ; dispatch : Function ; shouldDisplay : ShouldDisplay ; timeSettings : TimeSettings ; sourceFbosConfig : SourceFbosConfig ; } export interface PowerAndResetProps { controlPanelState : ControlPanelState ; dispatch : Function ; sourceFbosConfig : SourceFbosConfig ; shouldDisplay : ShouldDisplay ; botOnline : boolean ; } export interface FactoryResetRowProps { dispatch : Function ; sourceFbosConfig : SourceFbosConfig ; botOnline : boolean ; } export interface FarmbotOsRowProps { bot : BotState ; osReleaseNotesHeading : string ; osReleaseNotes : string ; dispatch : Function ; sourceFbosConfig : SourceFbosConfig ; shouldDisplay : ShouldDisplay ; botOnline : boolean ; botToMqttLastSeen : number ; timeSettings : TimeSettings ; deviceAccount : TaggedDevice ; } export interface FbosDetailsProps { botInfoSettings : InformationalSettings ; dispatch : Function ; shouldDisplay : ShouldDisplay ; sourceFbosConfig : SourceFbosConfig ; botToMqttLastSeen : number ; timeSettings : TimeSettings ; deviceAccount : TaggedDevice ; } export interface OsUpdateButtonProps { bot : BotState ; sourceFbosConfig : SourceFbosConfig ; botOnline : boolean ; shouldDisplay : ShouldDisplay ; }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $SourceFbosConfig$ O $any$ O O O O $any$ O $Function$ O $FunctionConstructor$ O $SourceFbosConfig$ O $any$ O O O O $any$ O $complex$ O $any$ O $boolean$ O O O $SaveFarmwareEnv$ O $any$ O $ShouldDisplay$ O $any$ O $Function$ O $FunctionConstructor$ O O O O $any$ O O O O O O O O O O O O O O $any$ O $boolean$ O O O $BotState$ O $any$ O $any[]$ O $any$ O O O $Function$ O $FunctionConstructor$ O $ShouldDisplay$ O $any$ O $TimeSettings$ O $any$ O $SourceFbosConfig$ O $any$ O O O O $any$ O $ControlPanelState$ O $any$ O $Function$ O $FunctionConstructor$ O $SourceFbosConfig$ O $any$ O $ShouldDisplay$ O $any$ O $boolean$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $SourceFbosConfig$ O $any$ O $boolean$ O O O O O O $any$ O $BotState$ O $any$ O $string$ O O O $string$ O O O $Function$ O $FunctionConstructor$ O $SourceFbosConfig$ O $any$ O $ShouldDisplay$ O $any$ O $boolean$ O O O $number$ O O O $TimeSettings$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $Function$ O $FunctionConstructor$ O $ShouldDisplay$ O $any$ O $SourceFbosConfig$ O $any$ O $number$ O O O $TimeSettings$ O $any$ O $any$ O $any$ O O O O $any$ O $BotState$ O $any$ O $SourceFbosConfig$ O $any$ O $boolean$ O O O $ShouldDisplay$ O $any$ O O
import { TaggedImage , SyncStatus } from "s" ; import { WD_ENV } from "s" ; import { NetworkState } from "s" ; import { ShouldDisplay , SaveFarmwareEnv } from "s" ; import { TimeSettings } from "s" ; export interface CameraCalibrationProps { dispatch : Function ; images : TaggedImage [ ] ; currentImage : TaggedImage | undefined ; env : Partial < WD_ENV > ; iteration : number ; morph : number ; blur : number ; H_LO : number ; S_LO : number ; V_LO : number ; H_HI : number ; S_HI : number ; V_HI : number ; botToMqttStatus : NetworkState ; syncStatus : SyncStatus | undefined ; shouldDisplay : ShouldDisplay ; saveFarmwareEnv : SaveFarmwareEnv ; timeSettings : TimeSettings ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any[]$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $NetworkState$ O $any$ O $any$ O $any$ O O O $ShouldDisplay$ O $any$ O $SaveFarmwareEnv$ O $any$ O $TimeSettings$ O $any$ O O
import { TaggedImage , JobProgress , SyncStatus } from "s" ; import { NetworkState } from "s" ; import { TimeSettings } from "s" ; export interface ImageFlipperProps { onFlip ( uuid : string | undefined ) : void ; images : TaggedImage [ ] ; currentImage : TaggedImage | undefined ; } export interface ImageFlipperState { isLoaded : boolean ; disablePrev : boolean ; disableNext : boolean ; } export interface PhotosProps { dispatch : Function ; images : TaggedImage [ ] ; currentImage : TaggedImage | undefined ; timeSettings : TimeSettings ; imageJobs : JobProgress [ ] ; botToMqttStatus : NetworkState ; syncStatus : SyncStatus | undefined ; } export interface PhotoButtonsProps { takePhoto : ( ) => void , deletePhoto : ( ) => void , imageJobs : JobProgress [ ] , botToMqttStatus : NetworkState ; syncStatus : SyncStatus | undefined ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $void$ O $string$ O O O O O O O O $any[]$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any[]$ O $any$ O O O $any$ O $any$ O O O $TimeSettings$ O $any$ O $any[]$ O $any$ O O O $NetworkState$ O $any$ O $any$ O $any$ O O O O O O $any$ O $void$ O O O O O O $void$ O O O O O O $any[]$ O $any$ O O O $NetworkState$ O $any$ O $any$ O $any$ O O O O
import { WD_ENV } from "s" ; export interface SettingsMenuProps { values : Partial < WD_ENV > ; onChange ( key : keyof WD_ENV , value ) : void ; } export type HSV = "s" | "s" | "s" ; export interface HiLo { hi : number ; lo : number ; } export interface DetectorState { isEditing : boolean ; deletionProgress : string ; settingsMenuOpen : boolean ; remoteFarmwareSettings : Partial < WD_ENV > ; } export interface FarmbotPickerProps { h : [ number , number ] ; s : [ number , number ] ; v : [ number , number ] ; invertHue ? : boolean ; } export interface EnvSliderProps { name : HSV ; env : Partial < WD_ENV > ; onChange ? : ( key , val : [ number , number ] ) => void ; } export interface EnvSliderState extends Partial < HiLo > { sliding : boolean ; }	O O $any$ O O O O O O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $number$ O O O O O O O $any$ O O O O O O O O O $any$ O $number$ O O O $number$ O O O O O O $any$ O $boolean$ O O O $string$ O O O $boolean$ O O O O O $any$ O $any$ O O O O O $any$ O $complex$ O O O O O O O $complex$ O O O O O O O $complex$ O O O O O O O $boolean$ O O O O O O O $any$ O $HSV$ O $any$ O O O $any$ O $any$ O O $void$ O O O $HSV$ O $complex$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O $boolean$ O O O O
export interface FrontPageState { registrationSent : boolean ; agreeToTerms : boolean ; email : string ; forgotPasswordEmail : string ; loginPassword : string ; regConfirmation : string ; regEmail : string ; regName : string ; regPassword : string ; activePanel : | "s" | "s" | "s" ; } export type SetterCB = ( stat < FrontPageState > ) => void ;	O O $any$ O $boolean$ O O O $boolean$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O O O O $any$ O O $Partial$ O $any$ O O O O O
import { TaggedLog , ConfigurationName , ALLOWED_MESSAGE_TYPES } from "s" ; import { SourceFbosConfig , ShouldDisplay } from "s" ; import { GetWebAppConfigValue } from "s" ; import { TimeSettings } from "s" ; export interface LogsProps { logs : TaggedLog [ ] ; timeSettings : TimeSettings ; dispatch : Function ; sourceFbosConfig : SourceFbosConfig ; getConfigValue : GetWebAppConfigValue ; shouldDisplay : ShouldDisplay ; } export type Filters = Record < ALLOWED_MESSAGE_TYPES , number > ; export interface LogsState extends Filters { autoscroll : boolean ; markdown : boolean ; } export interface LogsTableProps { logs : TaggedLog [ ] ; dispatch : Function ; state : LogsState ; timeSettings : TimeSettings ; } type ToggleEventHandler = ( e : React . MouseEvent < HTMLButtonElement > ) => void ; type SetNumSetting = ( property : keyof LogsState ) => ( value ) => void ; export interface LogsFilterMenuProps { toggle : ( property : keyof LogsState ) => ToggleEventHandler ; state : LogsState ; setFilterLevel : SetNumSetting ; shouldDisplay : ShouldDisplay ; } export interface LogSettingProps { label : string ; setting : ConfigurationName ; toolTip : string ; setFilterLevel : SetNumSetting ; dispatch : Function ; sourceFbosConfig : SourceFbosConfig ; getConfigValue : GetWebAppConfigValue ; } export interface LogsSettingsMenuProps { setFilterLevel : SetNumSetting ; dispatch : Function ; sourceFbosConfig : SourceFbosConfig ; getConfigValue : GetWebAppConfigValue ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any[]$ O $any$ O O O $TimeSettings$ O $any$ O $Function$ O $FunctionConstructor$ O $SourceFbosConfig$ O $any$ O $GetWebAppConfigValue$ O $any$ O $ShouldDisplay$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $boolean$ O O O $boolean$ O O O O O O $any$ O $any[]$ O $any$ O O O $Function$ O $FunctionConstructor$ O $LogsState$ O $any$ O $TimeSettings$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $complex$ O O O O O O $any$ O O $complex$ O O $any$ O O O $number$ O O O O O O $any$ O $ToggleEventHandler$ O O $complex$ O O $any$ O O $any$ O $LogsState$ O $any$ O $SetNumSetting$ O $any$ O $ShouldDisplay$ O $any$ O O O O $any$ O $string$ O O O $any$ O $any$ O $string$ O O O $SetNumSetting$ O $any$ O $Function$ O $FunctionConstructor$ O $SourceFbosConfig$ O $any$ O $GetWebAppConfigValue$ O $any$ O O O O $any$ O $SetNumSetting$ O $any$ O $Function$ O $FunctionConstructor$ O $SourceFbosConfig$ O $any$ O $GetWebAppConfigValue$ O $any$ O O
import { BotState } from "s" ; import { TaggedUser , TaggedLog , TaggedDevice } from "s" ; import { GetWebAppConfigValue } from "s" ; import { TimeSettings } from "s" ; import { PingDictionary } from "s" ; export interface SyncButtonProps { dispatch : Function ; bot : BotState ; consistent : boolean ; onClick ? : ( ) => void ; autoSync : boolean ; } export interface NavBarProps { consistent : boolean ; logs : TaggedLog [ ] ; bot : BotState ; user : TaggedUser | undefined ; dispatch : Function ; timeSettings : TimeSettings ; getConfigValue : GetWebAppConfigValue ; tour : string | undefined ; device : TaggedDevice ; autoSync : boolean ; alertCount : number ; pings : PingDictionary ; } export interface NavBarState { mobileMenuOpen : boolean ; tickerListOpen : boolean ; accountMenuOpen : boolean ; } type ToggleEventHandler = ( e : React . MouseEvent < HTMLElement > ) => void ; export interface MobileMenuProps { close : ( property : keyof NavBarState ) => ToggleEventHandler ; mobileMenuOpen : boolean ; alertCount : number ; } export interface TickerListProps { toggle : ( property : keyof NavBarState ) => ToggleEventHandler ; logs : TaggedLog [ ] tickerListOpen : boolean ; timeSettings : TimeSettings ; getConfigValue : GetWebAppConfigValue ; } export interface NavLinksProps { close : ( property : keyof NavBarState ) => ToggleEventHandler ; alertCount : number ; } export interface AccountMenuProps { close : ( property : keyof NavBarState ) => ToggleEventHandler ; logout : ( ) => void ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $BotState$ O $any$ O $boolean$ O O O $void$ O O O O O O O $boolean$ O O O O O O $any$ O $boolean$ O O O $any[]$ O $any$ O O O $BotState$ O $any$ O $any$ O $any$ O O O $Function$ O $FunctionConstructor$ O $TimeSettings$ O $any$ O $GetWebAppConfigValue$ O $any$ O $string$ O O O O O $any$ O $any$ O $boolean$ O O O $number$ O O O $complex$ O $any$ O O O O $any$ O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O $any$ O O $any$ O $any$ O $any$ O $complex$ O O O O O O O $any$ O $ToggleEventHandler$ O O O O O $any$ O O $any$ O $boolean$ O O O $number$ O O O O O O $any$ O $ToggleEventHandler$ O O O O O $any$ O O $any$ O $any[]$ O $any$ O O $boolean$ O O O $TimeSettings$ O $any$ O $GetWebAppConfigValue$ O $any$ O O O O $any$ O $ToggleEventHandler$ O O O O O $any$ O O $any$ O $number$ O O O O O O $any$ O $ToggleEventHandler$ O O O O O $any$ O O $any$ O $void$ O O O O O O O
import { CalendarRow , RegimenItemCalendarRow } from "s" ; import { TaggedRegimen } from "s" ; import { Actions } from "s" ; import { ResourceIndex , VariableNameSet } from "s" ; import { ShouldDisplay } from "s" ; export interface ActiveEditorProps { regimen : TaggedRegimen ; calendar : CalendarRow [ ] ; dispatch : Function ; resources : ResourceIndex ; shouldDisplay : ShouldDisplay ; variableData : VariableNameSet ; } export interface ActiveEditorState { variablesCollapsed : boolean ; } export interface RegimenItemListProps { calendar : RegimenItemCalendarRow [ ] ; dispatch : Function ; } export interface RegimenItemStepProps { item : CalendarRow ; dispatch : Function ; } export interface RegimenItemDayGroupProps { row : CalendarRow ; dispatch : Function ; } export interface RegimenEditorProps { current : TaggedRegimen | undefined ; dispatch : Function ; calendar : CalendarRow [ ] ; resources : ResourceIndex ; shouldDisplay : ShouldDisplay ; variableData : VariableNameSet ; } export interface CopyButtonProps { dispatch : Function ; regimen : TaggedRegimen ; } export interface SelectRegimen { type : Actions . SELECT_REGIMEN ; payload : string ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $CalendarRow[]$ O $any$ O O O $Function$ O $FunctionConstructor$ O $ResourceIndex$ O $any$ O $ShouldDisplay$ O $any$ O $complex$ O $any$ O O O O $any$ O $boolean$ O O O O O O $any$ O $RegimenItemCalendarRow[]$ O $any$ O O O $Function$ O $FunctionConstructor$ O O O O $any$ O $CalendarRow$ O $any$ O $Function$ O $FunctionConstructor$ O O O O $any$ O $CalendarRow$ O $any$ O $Function$ O $FunctionConstructor$ O O O O $any$ O $any$ O $any$ O O O $Function$ O $FunctionConstructor$ O $CalendarRow[]$ O $any$ O O O $ResourceIndex$ O $any$ O $ShouldDisplay$ O $any$ O $complex$ O $any$ O O O O $any$ O $Function$ O $FunctionConstructor$ O $any$ O $any$ O O O O $any$ O $Actions.SELECT_REGIMEN$ O $any$ O $Actions.SELECT_REGIMEN$ O $string$ O O O O
import { DropDownItem } from "s" ; import { TaggedTool , TaggedToolSlotPointer , } from "s" ; import { BotPosition } from "s" ; export interface ToolsState { editingTools : boolean ; editingBays : boolean ; } export interface Props { toolSlots : TaggedToolSlotPointer [ ] ; tools : TaggedTool [ ] ; getToolOptions ( ) : DropDownItem [ ] ; getChosenToolOption ( toolSlotUuid : string | undefined ) : DropDownItem ; getToolByToolSlotUUID ( uuid ) : TaggedTool | undefined ; getToolSlots ( ) : TaggedToolSlotPointer [ ] ; dispatch : Function ; isActive : ( tool ) => boolean ; changeToolSlot ( t , dispatch ) : ( d ) => void ; botPosition : BotPosition ; } export interface Tool { id ? : number | undefined ; name ? : string ; status ? : string | undefined ; } export interface ToolBayListProps { toggle ( ) : void ; getToolByToolSlotUUID ( uuid ) : TaggedTool | undefined ; getToolSlots ( ) : TaggedToolSlotPointer [ ] ; } export interface ToolBayFormProps { dispatch : Function ; toolSlots : TaggedToolSlotPointer [ ] ; botPosition : BotPosition ; toggle ( ) : void ; getToolOptions ( ) : DropDownItem [ ] ; getChosenToolOption ( uuid : string | undefined ) : DropDownItem ; getToolSlots ( ) : TaggedToolSlotPointer [ ] ; changeToolSlot ( t , dispatch ) : ( d ) => void ; } export interface ToolListAndFormProps { dispatch : Function ; tools : TaggedTool [ ] ; toggle ( ) : void ; isActive ( tool ) : boolean ; }	O O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O $any$ O $boolean$ O O O $boolean$ O O O O O O $any$ O $any[]$ O $any$ O O O $any[]$ O $any$ O O O $DropDownItem[]$ O O O $any$ O O O $DropDownItem$ O $string$ O O O O O O $any$ O $any$ O $string$ O O $any$ O O O $any[]$ O O O $any$ O O O $Function$ O $FunctionConstructor$ O $boolean$ O O $TaggedTool$ O O O O $void$ O $TaggedToolSlotPointer$ O $Function$ O O O $DropDownItem$ O O O O $complex$ O $any$ O O O O $any$ O $number$ O O O O O O $string$ O O O O $string$ O O O O O O O O O $any$ O $void$ O O O O O $any$ O $string$ O O $any$ O O O $any[]$ O O O $any$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any[]$ O $any$ O O O $complex$ O $any$ O $void$ O O O O O $DropDownItem[]$ O O O $any$ O O O $DropDownItem$ O $string$ O O O O O O $any$ O $any[]$ O O O $any$ O O O $void$ O $TaggedToolSlotPointer$ O $Function$ O O O $DropDownItem$ O O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $any[]$ O $any$ O O O $void$ O O O O O $boolean$ O $TaggedTool$ O O O O O
import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; import "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( 0 + 0 ) . toBe ( 0 ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O O O O O O
jest . mock ( "s" , ( ) => ( { interceptors : { response : { use : jest . fn ( ) } , request : { use : jest . fn ( ) } } , get ( ) { return Promise . reject ( "s" ) ; } } ) ) ; jest . mock ( "s" , ( ) => ( { Session : { clear : jest . fn ( ) , } } ) ) ; import { maybeRefreshToken } from "s" ; import { API } from "s" ; API . setBaseUrl ( "s" ) ; describe ( "s" , ( ) => { it ( "s" , ( done ) => { const t = { token : { encoded : "s" , unencoded : { jti : "s" , iss : "s" , exp : 0 , mqtt : "s" , os_update_server : "s" } } } ; maybeRefreshToken ( t ) . then ( ( result ) => { expect ( result ) . toBeUndefined ( ) ; done ( ) ; } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O $Promise<never>$ O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O O $Promise<AuthState>$ O O O O O O $any$ O O O O $any$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O $string$ O O O O O O $Promise<AuthState>$ O $complex$ O O O O O $AuthState$ O O O $any$ O $AuthState$ O O $any$ O O O $any$ O O O O O O O O O O O O
const mockAuth = ( iss = "s" ) : AuthState => ( { token : { encoded : "s" , unencoded : { iss , os_update_server : "s" , jti : "s" } } } ) ; jest . mock ( "s" , ( ) => ( { get ( ) { return Promise . resolve ( { data : mockAuth ( "s" ) } ) ; } , interceptors : { response : { use : jest . fn ( ) } , request : { use : jest . fn ( ) } } } ) ) ; import { AuthState } from "s" ; import { maybeRefreshToken } from "s" ; import { API } from "s" ; API . setBaseUrl ( "s" ) ; describe ( "s" , ( ) => { it ( "s" , ( done ) => { maybeRefreshToken ( mockAuth ( "s" ) ) . then ( ( nextToken ) => { if ( nextToken ) { expect ( nextToken . token . unencoded . iss ) . toEqual ( "s" ) ; done ( ) ; } else { fail ( ) ; } } ) ; } ) ; } ) ;	O $AuthState$ O O $string$ O O O O $any$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O $string$ O O O $string$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O $PromiseConstructor$ O $complex$ O O $AuthState$ O $AuthState$ O O O O O O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O $Promise<AuthState>$ O O O O O O $any$ O O O O $any$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O $Promise<AuthState>$ O $AuthState$ O O O O O O O O $AuthState$ O O O O O $AuthState$ O O $any$ O $AuthState$ O $Token$ O $UnencodedToken$ O $string$ O O $any$ O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O
import { buildResourceIndex , FAKE_RESOURCES } from "s" ; import { TaggedFarmEvent , SpecialStatus } from "s" ; const STUB_RESOURCE = { "s" : "s" , "s" : "s" , "s" : SpecialStatus . SAVED , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : 0 , "s" : "s" , "s" : 0 , "s" : "s" } } ; test ( "s" , ( ) => { const 0 = buildResourceIndex ( FAKE_RESOURCES ) ; const { index } = 0 ; const OK_LENGTH = FAKE_RESOURCES . length ; expect ( Object . keys ( index . all ) . length ) . toBe ( OK_LENGTH ) ; expect ( Object . keys ( index . references ) . length ) . toBe ( OK_LENGTH ) ; } ) ; test ( "s" , ( ) => { const db = buildResourceIndex ( [ STUB_RESOURCE ] ) ; const key = Object . keys ( db . index . byKind . FarmEvent ) [ 0 ] ; const fe = db . index . references [ key ] ; expect ( fe ) . toBeTruthy ( ) ; if ( fe && fe . kind === "s" ) { const { body } = fe ; expect ( body ) . toEqual ( STUB_RESOURCE . body ) ; } else { fail ( "s" ) ; } } ) ;	O O $any$ O $any[]$ O O O O O O $any$ O $any$ O O O O O $TaggedFarmEvent$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any[]$ O O O O $any$ O O $any$ O O $number$ O $any[]$ O $number$ O $any$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O O $number$ O O $any$ O $number$ O O $any$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O O $number$ O O $any$ O $number$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O $any$ O O O O $string$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O
jest . mock ( "s" , ( ) => { return { detectLanguage : jest . fn ( ( ) => Promise . resolve ( { lng : "s" } ) ) } ; } ) ; import { detectLanguage } from "s" ; import { revertToEnglish } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { jest . resetAllMocks ( ) ; revertToEnglish ( ) ; expect ( detectLanguage ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O $string$ O O O O O O O O O O O O $any$ O O O O O O $Promise<void>$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $Promise<void>$ O O O $any$ O $any$ O O $any$ O O O O O O O O O O
import { isNumericSetting , isBooleanSetting , safeBooleanSetting , safeNumericSetting , Session , } from "s" ; import { auth } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( Session . fetchStoredToken ( ) ) . toEqual ( undefined ) ; } ) ; it ( "s" , ( ) => { localStorage . setItem ( "s" , JSON . stringify ( auth ) ) ; expect ( Session . fetchStoredToken ( ) ) . toEqual ( auth ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( isNumericSetting ( "s" ) ) . toBe ( true ) ; expect ( isNumericSetting ( "s" ) ) . toBe ( false ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( isBooleanSetting ( "s" ) ) . toBe ( true ) ; expect ( isBooleanSetting ( "s" ) ) . toBe ( false ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( ( ) => safeBooleanSetting ( "s" ) ) . toThrow ( ) ; expect ( safeBooleanSetting ( "s" ) ) . toBe ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( ( ) => safeNumericSetting ( "s" ) ) . toThrow ( ) ; expect ( safeNumericSetting ( "s" ) ) . toBe ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { jest . clearAllMocks ( ) ; localStorage . foo = "s" ; sessionStorage . foo = "s" ; location . assign = jest . fn ( ) ; expect ( localStorage . foo ) . toBeTruthy ( ) ; expect ( sessionStorage . foo ) . toBeTruthy ( ) ; expect ( Session . clear ( ) ) . toEqual ( undefined ) ; expect ( location . assign ) . toHaveBeenCalled ( ) ; expect ( localStorage . foo ) . toBeFalsy ( ) ; expect ( sessionStorage . foo ) . toBeFalsy ( ) ; } ) ; } ) ;	O O $complex$ O $complex$ O $any$ O $any$ O $any$ O O O O O O O $AuthState$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $AuthState$ O O O O $any$ O $undefined$ O O O O O $any$ O O O O O O O $Storage$ O $void$ O O O $JSON$ O $complex$ O $AuthState$ O O O $any$ O $any$ O $AuthState$ O O O O $any$ O $AuthState$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $complex$ O O O O O $any$ O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $complex$ O O O O O $any$ O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $Storage$ O $any$ O O O $Storage$ O $any$ O O O $Location$ O $void$ O $any$ O $any$ O O O $any$ O $Storage$ O $any$ O O $any$ O O O $any$ O $Storage$ O $any$ O O $any$ O O O $any$ O $any$ O $never$ O O O O $any$ O $undefined$ O O $any$ O $Location$ O $void$ O O $any$ O O O $any$ O $Storage$ O $any$ O O $any$ O O O $any$ O $Storage$ O $any$ O O $any$ O O O O O O O O O
jest . mock ( "s" , ( ) => ( { navigate : jest . fn ( ) } ) ) ; import { navigate } from "s" ; import { push } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { push ( "s" ) ; expect ( navigate ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O
import axios from "s" ; import { Thunk } from "s" ; import { API } from "s" ; import { DeletionRequest } from "s" ; import { Session } from "s" ; import { UnsafeError } from "s" ; import { toastErrors } from "s" ; import { t } from "s" ; export function deleteUser ( payload ) { return ( _ , getState ) => { const { auth } = getState ( ) ; auth && axios ( { method : "s" , url : API . current . usersPath , data : payload , params : { force : true } } ) . then ( ( ) => { alert ( "s" ) ; Session . clear ( ) ; } ) . catch ( ( err ) => { toastErrors ( { err } ) ; } ) ; } ; } export const resetAccount = ( payload ) : Thunk => ( _ , getState ) => getState ( ) . auth && axios ( { method : "s" , url : API . current . accountResetPath , data : payload , } ) . then ( ( ) => alert ( t ( "s" ) ) ) . catch ( ( err ) => toastErrors ( { err } ) ) ;	O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O $Thunk$ O $DeletionRequest$ O O O O $Function$ O $GetState$ O O O O O $AuthState$ O O $GetState$ O O O $AuthState$ O $any$ O O $string$ O O O $string$ O $any$ O $API$ O $string$ O $DeletionRequest$ O $DeletionRequest$ O $complex$ O O $boolean$ O O O O O O $any$ O O O O O $void$ O O O O $any$ O $never$ O O O O O O $any$ O O $UnsafeError$ O O O $void$ O O $any$ O O O O O O O O O O O $Thunk$ O O $DeletionRequest$ O O $any$ O O $Function$ O $GetState$ O O $GetState$ O O O $AuthState$ O $any$ O O $string$ O O O $string$ O $any$ O $API$ O $string$ O $DeletionRequest$ O $DeletionRequest$ O O O O $any$ O O O O $void$ O $any$ O O O O O O $any$ O O $UnsafeError$ O O $void$ O O $any$ O O O O
jest . mock ( "s" , ( ) => ( { toastErrors : jest . fn ( ) } ) ) ; import { API } from "s" ; import * as moxios from "s" ; import { deleteUser , resetAccount } from "s" ; import { toastErrors } from "s" ; describe ( "s" , ( ) => { beforeEach ( function ( ) { moxios . install ( ) ; } ) ; afterEach ( function ( ) { moxios . uninstall ( ) ; } ) ; it ( "s" , ( done ) => { expect . assertions ( 0 ) ; API . setBaseUrl ( "s" ) ; const thunk = deleteUser ( { password : "s" } ) ; const dispatch = jest . fn ( ) ; const getState = jest . fn ( ) ; getState . mockImplementation ( ( ) => ( { auth : { } } ) ) ; window . alert = jest . fn ( ) ; thunk ( dispatch , getState ) ; moxios . wait ( function ( ) { const request = moxios . requests . mostRecent ( ) ; request . respondWith ( { status : 0 , response : { } } ) . then ( function ( resp ) { expect ( window . alert ) . toHaveBeenCalled ( ) ; expect ( resp . config . url ) . toContain ( "s" ) ; expect ( resp . config . method ) . toBe ( "s" ) ; done ( ) ; } ) ; } ) ; } ) ; it ( "s" , ( done ) => { expect . assertions ( 0 ) ; API . setBaseUrl ( "s" ) ; const thunk = resetAccount ( { password : "s" } ) ; const dispatch = jest . fn ( ) ; const getState = jest . fn ( ) ; getState . mockImplementation ( ( ) => ( { auth : { } } ) ) ; window . alert = jest . fn ( ) ; thunk ( dispatch , getState ) ; moxios . wait ( function ( ) { const request = moxios . requests . mostRecent ( ) ; request . respondWith ( { status : 0 , response : { } } ) . then ( function ( resp ) { expect ( window . alert ) . toHaveBeenCalled ( ) ; expect ( resp . config . url ) . toContain ( "s" ) ; expect ( resp . config . method ) . toBe ( "s" ) ; done ( ) ; } ) ; } ) ; } ) ; it ( "s" , ( done ) => { expect . assertions ( 0 ) ; API . setBaseUrl ( "s" ) ; const thunk = resetAccount ( { password : "s" } ) ; const dispatch = jest . fn ( ) ; const getState = jest . fn ( ) ; getState . mockImplementation ( ( ) => ( { auth : { } } ) ) ; window . alert = jest . fn ( ) ; thunk ( dispatch , getState ) ; moxios . wait ( function ( ) { const request = moxios . requests . mostRecent ( ) ; request . respondWith ( { status : 0 , response : { } } ) . then ( resp => { expect ( window . alert ) . not . toHaveBeenCalled ( ) ; expect ( toastErrors ) . toHaveBeenCalled ( ) ; expect ( resp . config . url ) . toContain ( "s" ) ; done ( ) ; } , console . log ) ; } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O $Thunk$ O $Thunk$ O O O O O O $void$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $void$ O O O O O $Thunk$ O $Thunk$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O ${}$ O O O O O O O $complex$ O $void)$ O $any$ O $any$ O O O $Thunk$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $number$ O O O ${}$ O O O O O O $any$ O O O $any$ O O $any$ O $complex$ O $void)$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O O O O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $void$ O O O O O $Thunk$ O $Thunk$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O ${}$ O O O O O O O $complex$ O $void)$ O $any$ O $any$ O O O $Thunk$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $number$ O O O ${}$ O O O O O O $any$ O O O $any$ O O $any$ O $complex$ O $void)$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O O O O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $void$ O O O O O $Thunk$ O $Thunk$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O ${}$ O O O O O O O $complex$ O $void)$ O $any$ O $any$ O O O $Thunk$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $number$ O O O ${}$ O O O O O O $any$ O $any$ O O $any$ O $complex$ O $void)$ O O $any$ O $any$ O O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O O $Console$ O $void$ O O O O O O O O O O O
import { API } from "s" ; import { Content } from "s" ; import { success } from "s" ; import axios , { AxiosResponse } from "s" ; import { DeviceAccountSettings } from "s" ; import { t } from "s" ; interface DataDumpExport { device ? : DeviceAccountSettings ; } type Response = AxiosResponse < DataDumpExport | undefined > ; export function generateFilename ( { device } ) { let name ; name = device ? ( device . name + "s" + device . id ) : "s" ; return `template` . toLowerCase ( ) ; } export function jsonDownload ( data , fname = generateFilename ( data ) ) { const a = document . createElement ( "s" ) ; document . body . appendChild ( a ) ; a . style . display = "s" ; const json = JSON . stringify ( data ) , blob = new Blob ( [ json ] , { type : "s" } ) , url = window . URL . createObjectURL ( blob ) ; a . href = url ; a . download = fname ; a . click ( ) ; window . URL . revokeObjectURL ( url ) ; return a ; } const ok = ( resp ) => { const { data } = resp ; return data ? jsonDownload ( data ) : success ( t ( Content . EXPORT_SENT ) ) ; } ; export const requestAccountExport = ( ) => axios . post ( API . current . exportDataPath ) . then ( ok ) ;	O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O $any$ O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O O O $string$ O O $any$ $DataDumpExport$ O O O $string$ O $string$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $string$ O O O O O O $HTMLAnchorElement$ O $object$ O $string$ O $string$ O $object$ O O O O $HTMLAnchorElement$ O $Document$ O O O O O O $Document$ O $HTMLElement$ O $T$ O $HTMLAnchorElement$ O O $HTMLAnchorElement$ O $CSSStyleDeclaration$ O $string$ O O O O $string$ O $JSON$ O $complex$ O $object$ O O $Blob$ O O $complex$ O O $string$ O O O $string$ O O O O O $string$ O $complex$ O $complex$ O $string$ O $Blob$ O O $HTMLAnchorElement$ O $string$ O $string$ O $HTMLAnchorElement$ O $string$ O $string$ O $HTMLAnchorElement$ O $void$ O O O $complex$ O $complex$ O $void$ O $string$ O O O $HTMLAnchorElement$ O O O $complex$ O O $Response$ O O O O O $any$ O O $any$ O O $any$ O $HTMLAnchorElement$ O $any$ O O $void$ O $any$ O $any$ O $string$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $API$ O $string$ O O $any$ O $complex$ O O
const mock = { response : { data : ( undefined as undefined | { } ) } } ; jest . mock ( "s" , ( ) => ( { post : jest . fn ( ( ) => Promise . resolve ( mock . response ) ) } ) ) ; import { API } from "s" ; import { Content } from "s" ; import { requestAccountExport , generateFilename } from "s" ; import { success } from "s" ; import axios from "s" ; import { fakeDevice } from "s" ; API . setBaseUrl ( "s" ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const device = fakeDevice ( ) . body ; device . name = "s" ; device . id = 0 ; const result = generateFilename ( { device } ) ; expect ( result ) . toEqual ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await requestAccountExport ( ) ; expect ( axios . post ) . toHaveBeenCalledWith ( API . current . exportDataPath ) ; expect ( success ) . toHaveBeenCalledWith ( Content . EXPORT_SENT ) ; } ) ; it ( "s" , async ( ) => { mock . response . data = { } ; window . URL = window . URL || ( { } as typeof window . URL ) ; window . URL . createObjectURL = jest . fn ( ) ; window . URL . revokeObjectURL = jest . fn ( ) ; const a = await requestAccountExport ( ) ; if ( a ) { expect ( a ) . toBeInstanceOf ( HTMLElement ) ; expect ( a . tagName ) . toBe ( "s" ) ; expect ( window . URL . createObjectURL ) . toHaveBeenCalledWith ( expect . any ( Blob ) ) ; expect ( window . URL . revokeObjectURL ) . toHaveBeenCalled ( ) ; mock . response . data = undefined ; } else { fail ( ) ; } } ) ; } ) ;	O $complex$ O O $complex$ O O ${}$ O O $undefined$ O O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O $complex$ O $complex$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O O O O $void$ O O O O O $any$ O O O O O $any$ O O O O $any$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O $string$ O $string$ O O $any$ O O O $any$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $API$ O $string$ O O $any$ O $void$ O O $any$ O $any$ O $string$ O O O O O $any$ O O O O O O O O $complex$ O $complex$ O ${}$ O O O O $complex$ O $complex$ O $complex$ O $complex$ O O O O O O $complex$ O $complex$ O O $complex$ O $complex$ O $string$ O $any$ O $any$ O O O $complex$ O $complex$ O $void$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $complex$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $complex$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O $complex$ O O O $any$ O $complex$ O $complex$ O $void$ O O $any$ O O O $complex$ O $complex$ O ${}$ O $undefined$ O O O O $any$ O O O O O O O O O O
import { Everything } from "s" ; import { Props } from "s" ; import { getUserAccountSettings } from "s" ; import { getWebAppConfigValue } from "s" ; export function mapStateToProps ( props ) { const user = getUserAccountSettings ( props . resources . index ) ; return { user , dispatch : ( ) => { throw new Error ( "s" ) ; } , getConfigValue : getWebAppConfigValue ( ( ) => props ) , } ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $Props$ O $Everything$ O O O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $any$ O $never$ O O O O O O O $ErrorConstructor$ O O O O O O $complex$ O $complex$ O O O O $Everything$ O O O O O
import { mapStateToProps } from "s" ; import { fakeState } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = mapStateToProps ( fakeState ( ) ) ; expect ( result . user ) . toBeTruthy ( ) ; expect ( result . user ) . toBeInstanceOf ( Object ) ; expect ( ( ) => result . dispatch ( ) ) . toThrow ( ) ; } ) ; } ) ;	O O $Props$ O O O O O O $Everything$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Props$ O $Props$ O $Everything$ O O O O $any$ O $Props$ O $any$ O O $any$ O O O $any$ O $Props$ O $any$ O O $any$ O $ObjectConstructor$ O O $any$ O O O O $Props$ O $Function$ O O O O $any$ O O O O O O O O O
export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ;	O O O O O O O O O O O O O O O O O O O O
import { store } from "s" ; import { getWebAppConfigValue , setWebAppConfigValue } from "s" ; import { BooleanConfigKey } from "s" ; namespace devStorage { const webAppConfigKey = "s" as BooleanConfigKey ; const { dispatch , getState } = store ; export enum Key { FUTURE_FE_FEATURES = "s" , FBOS_VERSION_OVERRIDE = "s" , } type Storage = { [ K in Key ] : string } ; const loadStorage = ( ) : Storage => JSON . parse ( "s" + ( getWebAppConfigValue ( getState ) ( webAppConfigKey ) || "s" ) ) ; const saveStorage = ( storage ) : void => { const storageString = JSON . stringify ( storage ) ; setWebAppConfigValue ( webAppConfigKey , storageString ) ( dispatch , getState ) ; } ; export const getItem = ( key ) : string | undefined => loadStorage ( ) [ key ] ; export const setItem = ( key , value ) : void => { const storage = loadStorage ( ) ; storage [ key ] = value ; saveStorage ( storage ) ; } ; export const removeItem = ( key ) : void => { const storage = loadStorage ( ) ; delete storage [ key ] ; saveStorage ( storage ) ; } ; } export namespace DevSettings { export const FUTURE_FE_FEATURES = devStorage . Key . FUTURE_FE_FEATURES ; export const futureFeaturesEnabled = ( ) => ! ! devStorage . getItem ( FUTURE_FE_FEATURES ) ; export const enableFutureFeatures = ( ) => devStorage . setItem ( FUTURE_FE_FEATURES , "s" ) ; export const disableFutureFeatures = ( ) => devStorage . removeItem ( FUTURE_FE_FEATURES ) ; export const FBOS_VERSION_OVERRIDE = devStorage . Key . FBOS_VERSION_OVERRIDE ; export const MAX_FBOS_VERSION_OVERRIDE = "s" ; export const overriddenFbosVersion = ( ) => devStorage . getItem ( FBOS_VERSION_OVERRIDE ) ; export const resetFbosVersionOverride = ( ) => devStorage . removeItem ( FBOS_VERSION_OVERRIDE ) ; export const setFbosVersionOverride = ( override ) => devStorage . setItem ( FBOS_VERSION_OVERRIDE , override ) ; export const setMaxFbosVersionOverride = ( ) => devStorage . setItem ( FBOS_VERSION_OVERRIDE , MAX_FBOS_VERSION_OVERRIDE ) ; }	O O $any$ O O O O O O $complex$ O $void$ O O O O O O $any$ O O O O O $any$ O O $any$ O O O $any$ O O O $any$ O $any$ O O $any$ O O O $any$ O $Key.FUTURE_FE_FEATURES$ O O O $Key.FBOS_VERSION_OVERRIDE$ O O O O O $any$ O O O $any$ O $any$ O O O O O O $Storage$ O O O O $any$ O $JSON$ O $any$ O O O O $complex$ O $any$ O O $any$ O O O O O O O $void$ O O $Storage$ O O O O O O $string$ O $JSON$ O $complex$ O $Storage$ O O $void$ O $any$ O $string$ O O $any$ O $any$ O O O O O O $string$ O O $Key$ O O O O O O $Storage$ O O O $Key$ O O O O $void$ O O $Key$ O $string$ O O O O O O $Storage$ O $Storage$ O O O $Storage$ O $Key$ O O $string$ O $void$ O $Storage$ O O O O O O $void$ O O $Key$ O O O O O O $Storage$ O $Storage$ O O O O $Storage$ O $Key$ O O $void$ O $Storage$ O O O O O O O $any$ O O O $Key.FUTURE_FE_FEATURES$ O $any$ O $any$ O $Key.FUTURE_FE_FEATURES$ O O O $boolean$ O O O O O O $any$ O $string$ O $Key.FUTURE_FE_FEATURES$ O O O O $void$ O O O O $any$ O $void$ O $Key.FUTURE_FE_FEATURES$ O O O O O O $void$ O O O O $any$ O $void$ O $Key.FUTURE_FE_FEATURES$ O O O O $Key.FBOS_VERSION_OVERRIDE$ O $any$ O $any$ O $Key.FBOS_VERSION_OVERRIDE$ O O O O O O O O O $string$ O O O O $any$ O $string$ O $Key.FBOS_VERSION_OVERRIDE$ O O O O $void$ O O O O $any$ O $void$ O $Key.FBOS_VERSION_OVERRIDE$ O O O O $void$ O O $string$ O O $any$ O $void$ O $Key.FBOS_VERSION_OVERRIDE$ O $string$ O O O O $void$ O O O O $any$ O $void$ O $Key.FBOS_VERSION_OVERRIDE$ O O O O O
import { BooleanSetting } from "s" ; import { Content } from "s" ; import { GetWebAppConfigValue , setWebAppConfigValue } from "s" ; import { BooleanConfigKey } from "s" ; import { t } from "s" ; export interface LabsFeature { name : string ; description : string ; storageKey : BooleanConfigKey ; value : boolean ; confirmationMessage ? : string ; displayInvert ? : boolean ; callback ? ( ) : void ; } export const fetchLabFeatures = ( getConfigValue ) : LabsFeature [ ] => ( [ { name : t ( "s" ) , description : t ( "s" ) , storageKey : BooleanSetting . 0 , value : false , displayInvert : true , callback : ( ) => window . location . reload ( ) } , { name : t ( "s" ) , description : t ( Content . 0 ) , storageKey : BooleanSetting . 0 , value : false , } , { name : t ( "s" ) , description : t ( Content . HIDE_WEBCAM_WIDGET ) , storageKey : BooleanSetting . hide_webcam_widget , value : false } , { name : t ( "s" ) , description : t ( Content . HIDE_SENSORS_WIDGET ) , storageKey : BooleanSetting . hide_sensors , value : false } , { name : t ( "s" ) , description : t ( Content . BROWSER_SPEAK_LOGS ) , storageKey : BooleanSetting . enable_browser_speak , value : false } , { name : t ( "s" ) , description : t ( Content . DISCARD_UNSAVED_CHANGES ) , storageKey : BooleanSetting . discard_unsaved , value : false , confirmationMessage : t ( Content . DISCARD_UNSAVED_CHANGES_CONFIRM ) } , { name : t ( "s" ) , description : t ( Content . EMERGENCY_UNLOCK_CONFIRM_CONFIG ) , confirmationMessage : t ( Content . CONFIRM_EMERGENCY_UNLOCK_CONFIRM_DISABLE ) , storageKey : BooleanSetting . disable_emergency_unlock_confirmation , value : false , displayInvert : true , } , { name : t ( "s" ) , description : t ( Content . USER_INTERFACE_READ_ONLY_MODE ) , storageKey : BooleanSetting . user_interface_read_only_mode , value : false , displayInvert : false , } ] . map ( fetchSettingValue ( getConfigValue ) ) ) ; export const maybeToggleFeature = ( getConfigValue , dispatch ) => ( x ) : LabsFeature | undefined => ( x . value || ! x . confirmationMessage || window . confirm ( x . confirmationMessage ) ) ? toggleFeatureValue ( getConfigValue , dispatch ) ( x ) : undefined ; const fetchSettingValue = ( getConfigValue ) => ( x ) : LabsFeature => { return { ... x , value : ! ! getConfigValue ( x . storageKey ) } ; } ; const toggleFeatureValue = ( getConfigValue , dispatch ) => ( x ) => { const value = ! getConfigValue ( x . storageKey ) ; dispatch ( setWebAppConfigValue ( x . storageKey , value ) ) ; return { ... x , value } ; } ;	O O $complex$ O O O O O O $any$ O O O O O O $any$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O $string$ O O O $any$ O $any$ O $boolean$ O O O $string$ O O O O $boolean$ O O O O $void$ O O O O O O O O O $LabsFeature[]$ O O $GetWebAppConfigValue$ O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $complex$ O $any$ O $boolean$ O O O $boolean$ O O O $void$ O O O O $complex$ O $Location$ O $complex$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $complex$ O $any$ O $boolean$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $complex$ O $any$ O $boolean$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $complex$ O $any$ O $boolean$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $complex$ O $any$ O $boolean$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $complex$ O $any$ O $boolean$ O O O $any$ O $any$ O $any$ O $string$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $string$ O O $any$ O $complex$ O $any$ O $boolean$ O O O $boolean$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $complex$ O $any$ O $boolean$ O O O $boolean$ O O O O O O $complex$ O $LabsFeature$ O $GetWebAppConfigValue$ O O O O O O $LabsFeature$ O O $GetWebAppConfigValue$ O $Function$ O O O $LabsFeature$ O O $any$ O O O O $LabsFeature$ O $boolean$ O O $LabsFeature$ O $string$ O $complex$ O $boolean)$ O $LabsFeature$ O $string$ O O O $complex$ O $GetWebAppConfigValue$ O $Function$ O O $LabsFeature$ O O $undefined$ O O $LabsFeature$ O O $GetWebAppConfigValue$ O O O $LabsFeature$ O O $any$ O O O O O $LabsFeature$ O $boolean$ O O O $GetWebAppConfigValue$ O $LabsFeature$ O $any$ O O O O O O $complex$ O O $GetWebAppConfigValue$ O $Function$ O O O $LabsFeature$ O O O O $boolean$ O O $GetWebAppConfigValue$ O $LabsFeature$ O $any$ O O $Function$ O $void$ O $LabsFeature$ O $any$ O $boolean$ O O O O O O $LabsFeature$ O $boolean$ O O O O
import { fetchLabFeatures } from "s" ; describe ( "s" , ( ) => { Object . defineProperty ( window . location , "s" , { value : jest . fn ( ) } ) ; it ( "s" , ( ) => { const val = fetchLabFeatures ( jest . fn ( ) ) ; expect ( val . length ) . toBe ( 0 ) ; expect ( val [ 0 ] . value ) . toBeFalsy ( ) ; const { callback } = val [ 0 ] ; if ( callback ) { expect ( callback ) . not . toThrowError ( ) ; } else { expect ( callback ) . toBeDefined ( ) ; } } ) ; } ) ;	O O $LabsFeature[]$ O O O O $any$ O O O O O O O $ObjectConstructor$ O $any$ O $complex$ O $Location$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $LabsFeature[]$ O $LabsFeature[]$ O $any$ O $any$ O O O O $any$ O $LabsFeature[]$ O $number$ O O $any$ O O O O $any$ O $LabsFeature[]$ O O O O $boolean$ O O $any$ O O O O O $void$ O O $LabsFeature[]$ O O O O O O $void$ O O $any$ O $void$ O O $any$ O $any$ O O O O O O $any$ O $void$ O O $any$ O O O O O O O O O O
const mockStorj < boolean > = { } ; import { Dictionary } from "s" ; import { maybeToggleFeature , LabsFeature } from "s" ; import { BooleanSetting } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { window . confirm = jest . fn ( ( ) => false ) ; const data = { name : "s" , value : false , description : "s" , storageKey : BooleanSetting . stub_config , confirmationMessage : "s" } ; const out = maybeToggleFeature ( x => mockStorj [ x ] , jest . fn ( ) ) ( data ) ; expect ( data . value ) . toBeFalsy ( ) ; expect ( out ) . toBeUndefined ( ) ; expect ( window . confirm ) . toHaveBeenCalledWith ( data . confirmationMessage ) ; } ) ; it ( "s" , ( ) => { window . confirm = ( ) => true ; const data = { name : "s" , value : ( mockStorj [ BooleanSetting . stub_config ] = false ) , description : "s" , storageKey : BooleanSetting . stub_config , confirmationMessage : "s" } ; const out = maybeToggleFeature ( x => mockStorj [ x ] , jest . fn ( ) ) ( data ) ; out ? expect ( out . value ) . toBeTruthy ( ) : fail ( "s" ) ; expect ( out ) . toBeTruthy ( ) ; } ) ; it ( "s" , ( ) => { window . confirm = jest . fn ( ( ) => true ) ; const output = maybeToggleFeature ( x => mockStorj [ x ] , jest . fn ( ) ) ( { name : "s" , value : ( mockStorj [ BooleanSetting . stub_config ] = true ) , description : "s" , storageKey : BooleanSetting . stub_config , confirmationMessage : "s" } ) ; expect ( window . confirm ) . not . toHaveBeenCalled ( ) ; output ? expect ( output . value ) . toBeFalsy ( ) : fail ( "s" ) ; } ) ; it ( "s" , ( ) => { const data = { name : "s" , value : ( mockStorj [ BooleanSetting . stub_config ] = false ) , description : "s" , storageKey : BooleanSetting . stub_config } ; const out = maybeToggleFeature ( x => mockStorj [ x ] , jest . fn ( ) ) ( data ) ; out ? expect ( out . value ) . toBeTruthy ( ) : fail ( "s" ) ; expect ( out ) . toBeTruthy ( ) ; } ) ; } ) ;	O $Dictionary$ O O O O O O O O O $any$ O O O O O O $LabsFeature$ O $any$ O O O O O O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O O $complex$ O $boolean)$ O $any$ O $any$ O O O O O O O O $LabsFeature$ O O $string$ O O O $false$ O O O $string$ O O O $any$ O $complex$ O $any$ O $string$ O O O O O $LabsFeature$ O $LabsFeature$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $LabsFeature$ O O $any$ O $LabsFeature$ O $boolean$ O O $any$ O O O $any$ O $LabsFeature$ O O $any$ O O O $any$ O $complex$ O $boolean)$ O O $any$ O $LabsFeature$ O $string$ O O O O O $any$ O O O O O O O $complex$ O $boolean)$ O O O O O O O $LabsFeature$ O O $string$ O O O $false$ O O $any$ O $complex$ O $any$ O O O O O $string$ O O O $any$ O $complex$ O $any$ O $string$ O O O O O $LabsFeature$ O $LabsFeature$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $LabsFeature$ O O $LabsFeature$ O $any$ O $LabsFeature$ O $boolean$ O O $any$ O O O $any$ O O O O $any$ O $LabsFeature$ O O $any$ O O O O O O $any$ O O O O O O O $complex$ O $boolean)$ O $any$ O $any$ O O O O O O O O $LabsFeature$ O $LabsFeature$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $string$ O O O $true$ O O $any$ O $complex$ O $any$ O O O O O $string$ O O O $any$ O $complex$ O $any$ O $string$ O O O O O $any$ O $complex$ O $boolean)$ O O $any$ O $any$ O O O $LabsFeature$ O $any$ O $LabsFeature$ O $boolean$ O O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $LabsFeature$ O O $string$ O O O $false$ O O $any$ O $complex$ O $any$ O O O O O $string$ O O O $any$ O $complex$ O $any$ O O O $LabsFeature$ O $LabsFeature$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $LabsFeature$ O O $LabsFeature$ O $any$ O $LabsFeature$ O $boolean$ O O $any$ O O O $any$ O O O O $any$ O $LabsFeature$ O O $any$ O O O O O O O O O
import { API } from "s" ; describe ( "s" , ( ) => { type L = typeof location ; const fakeLocation = ( input < L > ) => input as L ; it ( "s" , ( ) => { expect ( ( ) => API . current ) . toThrow ( ) ; const BASE = "s" ; API . setBaseUrl ( BASE ) ; [ [ API . current . pointSearchPath , BASE + "s" ] , [ API . current . allPointsPath , BASE + "s" ] , [ API . current . sensorReadingPath , BASE + "s" ] , [ API . current . farmwareEnvPath , BASE + "s" ] , [ API . current . plantTemplatePath , BASE + "s" ] , [ API . current . diagnosticDumpsPath , BASE + "s" ] , [ API . current . farmwareInstallationPath , BASE + "s" ] , [ API . current . globalBulletinPath , BASE + "s" ] , [ API . current . accountSeedPath , BASE + "s" ] , ] . map ( x => expect ( x [ 0 ] ) . toEqual ( x [ 0 ] ) ) ; } ) ; it ( "s" , ( ) => { const xmp : [ string , L ] [ ] = [ [ "s" , fakeLocation ( { port : "s" } ) ] , [ "s" , fakeLocation ( { port : "s" } ) ] , [ "s" , fakeLocation ( { port : undefined } ) ] , [ "s" , fakeLocation ( { port : undefined , origin : "s" } ) ] , ] ; xmp . map ( x => expect ( API . inferPort ( x [ 0 ] ) ) . toEqual ( x [ 0 ] ) ) ; } ) ; } ) ;	O O $any$ O O O O $any$ O O O O O O O O $any$ O O $Location$ O O $Location$ O O $Partial$ O $any$ O O O $Partial<Location>$ O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $API$ O O $any$ O O O O O O O O $any$ O $void$ O O O O O O $any$ O $API$ O $string$ O O O O O O O $any$ O $API$ O $string$ O O O O O O O $any$ O $API$ O $string$ O O O O O O O $any$ O $API$ O $string$ O O O O O O O $any$ O $API$ O $string$ O O O O O O O $any$ O $API$ O $string$ O O O O O O O $any$ O $API$ O $string$ O O O O O O O $any$ O $API$ O $string$ O O O O O O O $any$ O $API$ O $string$ O O O O O O O O $U[]$ O $string[]$ O $any$ O $string[]$ O O O O O $any$ O $string[]$ O O O O O O O O O $any$ O O O O O O O O $complex$ O O O O $any$ O O O O O O O O $Location$ O O $string$ O O O O O O O O O $Location$ O O $string$ O O O O O O O O O $Location$ O O $undefined$ O $undefined$ O O O O O O O $Location$ O O $undefined$ O $undefined$ O $string$ O O O O O O O O $complex$ O $U[]$ O $complex$ O $any$ O $any$ O $string$ O $complex$ O O O O O O $any$ O $complex$ O O O O O O O O O O O O
jest . mock ( "s" , ( ) => { return { maybeStartTracking : jest . fn ( ) } ; } ) ; jest . mock ( "s" , ( ) => ( { appIsReadonly : jest . fn ( ) } ) ) ; const mockBody < TaggedUser [ "s" ] > = { id : 0 } ; jest . mock ( "s" , ( ) => { return { delete : ( ) => Promise . resolve ( { } ) , post : ( ) => Promise . resolve ( { data : mockBody } ) , put : ( ) => Promise . resolve ( { data : mockBody } ) } ; } ) ; import { destroy , saveAll , initSave , initSaveGetId } from "s" ; import { buildResourceIndex } from "s" ; import { createStore , applyMiddleware } from "s" ; import { resourceReducer } from "s" ; import thunk from "s" ; import { ReduxAction } from "s" ; import { maybeStartTracking } from "s" ; import { API } from "s" ; import { betterCompact } from "s" ; import { SpecialStatus , TaggedUser } from "s" ; import { uniq } from "s" ; describe ( "s" , ( ) => { API . setBaseUrl ( "s" ) ; const initialState = { resources : buildResourceIndex ( ) } ; const wrappedReducer = ( state : typeof initialState , action < void > ) => { return { resources : resourceReducer ( state . resources , action ) } ; } ; const store = createStore ( wrappedReducer , initialState , applyMiddleware ( thunk ) ) ; const resources = ( ) => betterCompact ( Object . values ( store . getState ( ) . resources . index . references ) ) ; it ( "s" , ( ) => { const uuid = Object . keys ( store . getState ( ) . resources . index . byKind . Tool ) [ 0 ] ; store . dispatch ( destroy ( uuid ) as any ) ; expect ( maybeStartTracking ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const r = resources ( ) . map ( x => { x . specialStatus = SpecialStatus . DIRTY ; return x ; } ) ; store . dispatch ( saveAll ( r ) as any ) ; expect ( maybeStartTracking ) . toHaveBeenCalled ( ) ; const list = ( maybeStartTracking as jest . Mock ) . mock . calls ; const uuids : string [ ] = uniq ( list . map ( ( x : string [ ] ) => x [ 0 ] ) ) ; expect ( uuids . length ) . toEqual ( r . length ) ; } ) ; it ( "s" , ( ) => { const action = initSave ( "s" , { name : "s" , email : "s" } ) ; store . dispatch ( action ) ; expect ( maybeStartTracking ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const action = initSaveGetId ( "s" , { name : "s" , email : "s" } ) ; store . dispatch ( action ) ; expect ( maybeStartTracking ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $Partial$ O $any$ O O O O O O $number$ O O O O $any$ O $any$ O O O O O O O O O $Promise<{}>$ O O O O $PromiseConstructor$ O $complex$ O O O O O $complex$ O O O O $PromiseConstructor$ O $complex$ O O $any$ O $any$ O O O $complex$ O O O O $PromiseConstructor$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $void$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $generateReducer<RestResources>.GeneratedReducer$ O O O O O $any$ O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O $T[]$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $void$ O O O O O $complex$ O O $any$ O $any$ O O O O O $complex$ O O $complex$ O O $complex$ O $ReduxAction$ O O O O O O O O $RestResources$ O $generateReducer<RestResources>.GeneratedReducer$ O $complex$ O $any$ O $ReduxAction<void>$ O O O O O O $any$ O $any$ O $complex$ O $complex$ O $any$ O $any$ O O O O $unknown[]$ O O O O $T[]$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O $string$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $void$ O O $any$ O O O O O O $any$ O O O O O O O O $unknown[]$ O $unknown[]$ O O O $U[]$ O $unknown$ O O $unknown$ O $any$ O $any$ O $any$ O O $unknown$ O O O O $any$ O $any$ O $void$ O $unknown[]$ O O O O O $any$ O $void$ O O $any$ O O O O $any$ O O $void$ O $any$ O $any$ O O $any$ O $any$ O O $string[]$ O O O O O $any$ O $any$ O $any$ O O $string[]$ O O O O O O $string[]$ O O O O O O $any$ O $string[]$ O $number$ O O $any$ O $unknown[]$ O $number$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O O O O O O O
const mockDevice = { on : jest . fn ( ( ) => { return Promise . resolve ( ) ; } ) , } ; jest . mock ( "s" , ( ) => ( { getDevice : ( ) => mockDevice } ) ) ; jest . mock ( "s" , ( ) => ( { get : ( ) => { return Promise . resolve ( { data : "s" } ) ; } , put : ( ) => { return Promise . resolve ( { data : "s" } ) ; } , } ) ) ; import { refresh , updateViaAjax } from "s" ; import { TaggedDevice , SpecialStatus } from "s" ; import { API } from "s" ; import { get } from "s" ; import { Actions } from "s" ; import { buildResourceIndex } from "s" ; import { fakePeripheral } from "s" ; describe ( "s" , ( ) => { API . setBaseUrl ( "s" ) ; it ( "s" , ( done ) => { const 0 = { "s" : "s" , "s" : "s" , "s" : "s" as SpecialStatus , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : "s" , "s" : 0 } , } ; const thunk = refresh ( 0 ) ; const dispatch = jest . fn ( ) ; const { mock } = dispatch ; console . error = jest . fn ( ) ; thunk ( dispatch ) ; setImmediate ( ( ) => { expect ( dispatch ) . toHaveBeenCalledTimes ( 0 ) ; const firstCall = mock . calls [ 0 ] [ 0 ] ; const 0 = get ( firstCall , "s" , "s" ) ; expect ( 0 ) . toBe ( Actions . REFRESH_RESOURCE_START ) ; const 0 = get ( firstCall , "s" , "s" ) ; expect ( 0 ) . toBe ( 0 . uuid ) ; const secondCall = mock . calls [ 0 ] [ 0 ] ; const 0 = get ( secondCall , "s" , "s" ) ; expect ( 0 ) . toEqual ( Actions . REFRESH_RESOURCE_NO ) ; const dispatchPayl = get ( secondCall , "s" , "s" ) ; expect ( dispatchPayl ) . toEqual ( "s" ) ; expect ( console . error ) . toHaveBeenCalledTimes ( 0 ) ; expect ( console . error ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; done ( ) ; } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const payload = { uuid : "s" , statusBeforeError : SpecialStatus . DIRTY , dispatch : jest . fn ( ) , index : buildResourceIndex ( [ fakePeripheral ( ) ] ) . index } ; payload . uuid = Object . keys ( payload . index . all ) [ 0 ] ; console . error = jest . fn ( ) ; updateViaAjax ( payload ) . catch ( e => { expect ( "s" + e ) . toEqual ( "s" ) ; expect ( console . error ) . toHaveBeenCalledTimes ( 0 ) ; expect ( console . error ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; } ) ; } ) ; } ) ;	O $complex$ O O $any$ O $any$ O $any$ O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O $complex$ O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O O $PromiseConstructor$ O $complex$ O O $string$ O O O O O O O $complex$ O O O O O O $PromiseConstructor$ O $complex$ O O $string$ O O O O O O O O O O O O O $void$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $void$ O O O O $any$ O O O O $any$ O O O O $TaggedDevice$ O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $void$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $Console$ O $void$ O $any$ O $any$ O O O $void$ O $any$ O O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $Actions.REFRESH_RESOURCE_START$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O $Actions.REFRESH_RESOURCE_NO$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $Console$ O $void$ O O $any$ O O O O $any$ O $Console$ O $void$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O O $complex$ O $string$ O $ObjectConstructor$ O $complex$ O $complex$ O $any$ O $any$ O O O O O $Console$ O $void$ O $any$ O $any$ O O O $any$ O $complex$ O O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O O O O $any$ O $Console$ O $void$ O O $any$ O O O O $any$ O $Console$ O $void$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O
let mockPost = Promise . resolve ( { data : { id : 0 } } ) ; jest . mock ( "s" , ( ) => ( { get : ( ) => Promise . resolve ( { data : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : "s" } } ) , post : ( ) => mockPost , } ) ) ; import { refresh , initSaveGetId } from "s" ; import { TaggedDevice , SpecialStatus } from "s" ; import { API } from "s" ; import { Actions } from "s" ; import { get } from "s" ; describe ( "s" , ( ) => { API . setBaseUrl ( "s" ) ; it ( "s" , ( done ) => { const 0 = { "s" : "s" , "s" : "s" , "s" : SpecialStatus . SAVED , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : "s" , "s" : 0 } , } ; const thunk = refresh ( 0 ) ; const dispatch = jest . fn ( ) ; thunk ( dispatch ) ; setImmediate ( ( ) => { const { calls } = dispatch . mock ; expect ( calls . length ) . toBe ( 0 ) ; const first = calls [ 0 ] [ 0 ] ; expect ( first ) . toBeInstanceOf ( Object ) ; expect ( get ( first , "s" , "s" ) ) . toEqual ( Actions . REFRESH_RESOURCE_START ) ; expect ( get ( first , "s" , "s" ) ) . toEqual ( 0 . uuid ) ; const second = calls [ 0 ] [ 0 ] ; expect ( second ) . toBeInstanceOf ( Object ) ; expect ( get ( second , "s" , "s" ) ) . toEqual ( Actions . REFRESH_RESOURCE_OK ) ; expect ( get ( second , "s" , "s" ) ) . toEqual ( "s" ) ; done ( ) ; } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const dispatch = jest . fn ( ) ; const result = await initSaveGetId ( "s" , { } ) ( dispatch ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { type : Actions . SAVE_RESOURCE_START , payload : expect . objectContaining ( { kind : "s" } ) } ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { type : Actions . INIT_RESOURCE , payload : expect . objectContaining ( { kind : "s" } ) } ) ; await expect ( result ) . toEqual ( 0 ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { type : Actions . SAVE_RESOURCE_OK , payload : expect . objectContaining ( { kind : "s" } ) } ) ; } ) ; it ( "s" , async ( ) => { mockPost = Promise . reject ( "s" ) ; const dispatch = jest . fn ( ) ; await initSaveGetId ( "s" , { } ) ( dispatch ) . catch ( ( ) => { } ) ; await expect ( dispatch ) . toHaveBeenLastCalledWith ( { type : Actions . _RESOURCE_NO , payload : expect . objectContaining ( { err : "s" } ) } ) ; } ) ; } ) ;	O $complex$ O $PromiseConstructor$ O $complex$ O O $complex$ O O $number$ O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O $PromiseConstructor$ O $complex$ O O $complex$ O O O O O O O O O O O O O O O O O O O O O $complex$ O O O O $complex$ O O O O O O O $void$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $void$ O O O O $any$ O O O O $any$ O O O O $TaggedDevice$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $void$ O $any$ O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O $ObjectConstructor$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $Actions.REFRESH_RESOURCE_START$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O $ObjectConstructor$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $Actions.REFRESH_RESOURCE_OK$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions.SAVE_RESOURCE_START$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions.INIT_RESOURCE$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions.SAVE_RESOURCE_OK$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O O O O $any$ O O O O O O O O $complex$ O $PromiseConstructor$ O $Promise<T>$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions._RESOURCE_NO$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O O O O O O O
import { urlFor } from "s" ; import { API } from "s" ; import { ResourceName } from "s" ; describe ( "s" , ( ) => { API . setBaseUrl ( "s" ) ; it ( "s" , ( ) => { expect ( ( ) => urlFor ( "s" as ResourceName ) ) . toThrowError ( "s" ) ; } ) ; } ) ;	O O $string$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O $string$ O O O $any$ O O O $any$ O O O O O O O O O O
import { SpecialStatus } from "s" ; import { destroyNO } from "s" ; import { destroyCatch } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const uuid = "s" ; const statusBeforeError = SpecialStatus . DIRTY ; const err = { } ; const handler = destroyCatch ( { dispatch , uuid , statusBeforeError } ) ; handler ( err ) . catch ( ( ) => { } ) ; const expected = destroyNO ( { err , uuid , statusBeforeError } ) ; expect ( dispatch ) . toHaveBeenCalledWith ( expected ) ; } ) ; } ) ;	O O $any$ O O O O O O $complex$ O O O O O O $Promise<never>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O ${}$ O O O O O $Promise<never>$ O $Promise<never>$ O O $any$ O $string$ O $any$ O O O $Promise<never>$ O ${}$ O O $Promise<TResult>$ O O O O O O O O O $complex$ O $complex$ O O ${}$ O $string$ O $any$ O O O $any$ O $any$ O O $any$ O $complex$ O O O O O O O O
interface MockRespone { kind : string ; body : { id : number | undefined ; } } const mockResource = { kind : "s" , body : { id : 0 } } ; let mockDelete < { } | void > = Promise . resolve ( { } ) ; jest . mock ( "s" , ( ) => ( { findByUuid : ( ) => ( mockResource ) , afterEach : ( s : { } ) => s } ) ) ; jest . mock ( "s" , ( ) => ( { destroyOK : jest . fn ( ) , destroyNO : jest . fn ( ) } ) ) ; jest . mock ( "s" , ( ) => ( { maybeStartTracking : jest . fn ( ) } ) ) ; jest . mock ( "s" , ( ) => ( { delete : jest . fn ( ( ) => mockDelete ) } ) ) ; let mockReadonlyState = false ; jest . mock ( "s" , ( ) => ( { appIsReadonly : jest . fn ( ( ) => mockReadonlyState ) } ) ) ; import { destroy , destroyAll } from "s" ; import { API } from "s" ; import axios from "s" ; import { destroyOK , destroyNO } from "s" ; describe ( "s" , ( ) => { beforeEach ( ( ) => { mockResource . body . id = 0 ; mockResource . kind = "s" ; mockReadonlyState = false ; } ) ; API . setBaseUrl ( "s" ) ; const fakeGetState = ( ) => ( { resources : { index : { } } } as any ) ; const fakeDestroy = ( ) => destroy ( "s" ) ( jest . fn ( ) , fakeGetState ) ; const expectDestroyed = ( ) => { const kind = mockResource . kind . toLowerCase ( ) + "s" ; expect ( axios . delete ) . toHaveBeenCalledWith ( `template` ) ; expect ( destroyOK ) . toHaveBeenCalledWith ( mockResource ) ; } ; const expectNotDestroyed = ( ) => { expect ( axios . delete ) . not . toHaveBeenCalled ( ) ; } ; it ( "s" , ( ) => { window . confirm = ( ) => false ; expect ( fakeDestroy ( ) ) . rejects . toEqual ( "s" ) ; expectNotDestroyed ( ) ; } ) ; it ( "s" , ( ) => { mockResource . body . id = 0 ; window . confirm = ( ) => true ; expect ( fakeDestroy ( ) ) . resolves . toEqual ( "s" ) ; expect ( destroyOK ) . toHaveBeenCalledWith ( mockResource ) ; } ) ; it ( "s" , ( ) => { mockResource . body . id = undefined ; window . confirm = ( ) => true ; expect ( fakeDestroy ( ) ) . resolves . toEqual ( "s" ) ; expect ( destroyOK ) . toHaveBeenCalledWith ( mockResource ) ; } ) ; it ( "s" , async ( ) => { window . confirm = ( ) => true ; await expect ( fakeDestroy ( ) ) . resolves . toEqual ( undefined ) ; expectDestroyed ( ) ; } ) ; it ( "s" , async ( ) => { window . confirm = ( ) => false ; const forceDestroy = ( ) => destroy ( "s" , true ) ( jest . fn ( ) , fakeGetState ) ; await expect ( forceDestroy ( ) ) . resolves . toEqual ( undefined ) ; expectDestroyed ( ) ; } ) ; it ( "s" , async ( ) => { mockResource . kind = "s" ; window . confirm = ( ) => false ; await expect ( fakeDestroy ( ) ) . resolves . toEqual ( undefined ) ; expectDestroyed ( ) ; } ) ; it ( "s" , async ( ) => { window . confirm = ( ) => true ; mockDelete = Promise . reject ( "s" ) ; await expect ( fakeDestroy ( ) ) . rejects . toEqual ( "s" ) ; expect ( destroyNO ) . toHaveBeenCalledWith ( { err : "s" , statusBeforeError : undefined , uuid : "s" } ) ; } ) ; it ( "s" , async ( ) => { mockReadonlyState = true ; await expect ( fakeDestroy ( ) ) . rejects . toEqual ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { window . confirm = ( ) => true ; mockDelete = Promise . resolve ( ) ; await expect ( destroyAll ( "s" ) ) . resolves . toEqual ( undefined ) ; expect ( axios . delete ) . toHaveBeenCalledWith ( "s" ) ; } ) ; it ( "s" , async ( ) => { window . confirm = ( ) => false ; mockDelete = Promise . resolve ( ) ; await expect ( destroyAll ( "s" , true ) ) . resolves . toEqual ( undefined ) ; expect ( axios . delete ) . toHaveBeenCalledWith ( "s" ) ; } ) ; it ( "s" , async ( ) => { window . confirm = ( ) => false ; mockDelete = Promise . resolve ( ) ; await expect ( destroyAll ( "s" ) ) . rejects . toEqual ( "s" ) ; expect ( axios . delete ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , async ( ) => { window . confirm = ( ) => true ; mockDelete = Promise . reject ( "s" ) ; await expect ( destroyAll ( "s" ) ) . rejects . toEqual ( "s" ) ; expect ( axios . delete ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ;	O $any$ O $string$ O O O $complex$ O O $number$ O O O O O O O O $MockRespone$ O O $string$ O O O $complex$ O O $number$ O O O O O O $Promise$ O O O O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $any$ O O O O O O O O $MockRespone$ O O O O O $MockRespone$ O O ${}$ O O ${}$ O O O O O ${}$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O O O O O $boolean$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $complex$ O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O $MockRespone$ O $complex$ O $number$ O O O $MockRespone$ O $string$ O O O $boolean$ O O O O O O $any$ O $void$ O O O O O $any$ O O O O O O $complex$ O O ${}$ O O O O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O $void$ O O O O O O $string$ O $MockRespone$ O $string$ O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $complex$ O O $any$ O $MockRespone$ O O O O O $void$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O $complex$ O $boolean)$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $void$ O O O O O O $any$ O O O O O O O $MockRespone$ O $complex$ O $number$ O O O $complex$ O $boolean)$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $complex$ O O $any$ O $MockRespone$ O O O O O $any$ O O O O O O O $MockRespone$ O $complex$ O $number$ O $undefined$ O $complex$ O $boolean)$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $complex$ O O $any$ O $MockRespone$ O O O O O $any$ O O O O O O O O $complex$ O $boolean)$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $undefined$ O O $void$ O O O O O O $any$ O O O O O O O O $complex$ O $boolean)$ O O O O O O O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $undefined$ O O $void$ O O O O O O $any$ O O O O O O O O $MockRespone$ O $string$ O O O $complex$ O $boolean)$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $undefined$ O O $void$ O O O O O O $any$ O O O O O O O O $complex$ O $boolean)$ O O O O O O $complex$ O $PromiseConstructor$ O $Promise<T>$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $complex$ O O $any$ O O $string$ O O O $undefined$ O $undefined$ O $string$ O O O O O O O O $any$ O O O O O O O O $boolean$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $boolean)$ O O O O O O $complex$ O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $boolean)$ O O O O O O $complex$ O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $boolean)$ O O O O O O $complex$ O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $complex$ O $boolean)$ O O O O O O $complex$ O $PromiseConstructor$ O $Promise<T>$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
jest . mock ( "s" , ( ) => ( { interceptors : { response : { use : jest . fn ( ) } , request : { use : jest . fn ( ) } } , post : jest . fn ( ( ) => { return Promise . resolve ( { data : { foo : "s" } } ) ; } ) , get : jest . fn ( ( ) => { return Promise . resolve ( { data : { foo : "s" } } ) ; } ) , } ) ) ; jest . mock ( "s" , ( ) => ( { API : { setBaseUrl : jest . fn ( ) , inferPort : ( ) => 0 , current : { tokensPath : "s" , usersPath : "s" } } } ) ) ; jest . mock ( "s" , ( ) => ( { fetchReleases : jest . fn ( ) , fetchLatestGHBetaRelease : jest . fn ( ) , fetchMinOsFeatureData : jest . fn ( ) , } ) ) ; import { didLogin } from "s" ; import { Actions } from "s" ; import { API } from "s" ; import { AuthState } from "s" ; import { fetchReleases , fetchLatestGHBetaRelease } from "s" ; const mockToken = ( ) : AuthState => ( { token : { encoded : "s" , unencoded : { iss : "s" , os_update_server : "s" , jti : "s" } } } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const result = didLogin ( mockToken ( ) , dispatch ) ; expect ( result ) . toBeUndefined ( ) ; const { iss } = mockToken ( ) . token . unencoded ; expect ( API . setBaseUrl ) . toHaveBeenCalledWith ( iss ) ; const actions = dispatch . mock . calls . map ( x => x && x [ 0 ] && x [ 0 ] . type ) ; expect ( actions ) . toContain ( Actions . REPLACE_TOKEN ) ; } ) ; it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const mockAuth = mockToken ( ) ; mockAuth . token . unencoded . beta_os_update_server = "s" ; didLogin ( mockAuth , dispatch ) ; expect ( fetchReleases ) . toHaveBeenCalledWith ( "s" ) ; expect ( fetchLatestGHBetaRelease ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $PromiseConstructor$ O $complex$ O O $complex$ O O $string$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $PromiseConstructor$ O $complex$ O O $complex$ O O $string$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $number$ O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O $void$ O O O O O $AuthState$ O O O O $any$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $void$ O $void$ O $AuthState$ O O O $any$ O O $any$ O $void$ O O $any$ O O O O O $string$ O O $AuthState$ O O O $Token$ O $UnencodedToken$ O $any$ O $any$ O $void$ O O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $Actions.REPLACE_TOKEN$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $AuthState$ O $AuthState$ O O O $AuthState$ O $Token$ O $UnencodedToken$ O $string$ O O O $void$ O $AuthState$ O $any$ O O $any$ O $void$ O O $any$ O O O O $any$ O $void$ O O $any$ O O O O O O O O O O
import { authReducer } from "s" ; import { setToken } from "s" ; import { AuthState } from "s" ; describe ( "s" , ( ) => { function fakeToken ( ) { const output < AuthState > = { token : ( { } as any ) } ; return output as AuthState ; } it ( "s" , ( ) => { const result = authReducer ( undefined , setToken ( fakeToken ( ) ) ) ; expect ( result ) . toBeTruthy ( ) ; expect ( result && result . token ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $generateReducer<AuthState>.GeneratedReducer$ O O O O O O $ReduxAction<AuthState>$ O O O O O O $any$ O O O O $any$ O O O O O O O O $AuthState$ O O O O $Partial$ O $any$ O O O $any$ O O O O O O O O O O $Partial<AuthState>$ O $any$ O O $any$ O O O O O O O O $AuthState$ O $generateReducer<AuthState>.GeneratedReducer$ O $undefined$ O $ReduxAction<AuthState>$ O $AuthState$ O O O O O $any$ O $AuthState$ O O $any$ O O O $any$ O $AuthState$ O $AuthState$ O $Token$ O O $any$ O O O O O O O O O
const mockState = { auth : { token : { unencoded : { iss : "s" } } } } ; jest . mock ( "s" , ( ) => ( { interceptors : { response : { use : jest . fn ( ) } , request : { use : jest . fn ( ) } } , get ( ) { return Promise . resolve ( { data : mockState } ) ; } } ) ) ; jest . mock ( "s" , ( ) => ( { Session : { fetchStoredToken : jest . fn ( ) , getAll : ( ) => undefined , clear : jest . fn ( ) } } ) ) ; jest . mock ( "s" , ( ) => ( { didLogin : jest . fn ( ) , setToken : jest . fn ( ) } ) ) ; import { ready , storeToken } from "s" ; import { setToken , didLogin } from "s" ; import { Session } from "s" ; import { auth } from "s" ; import { fakeState } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { jest . resetAllMocks ( ) ; const dispatch = jest . fn ( ) ; const thunk = ready ( ) ; thunk ( dispatch , fakeState ) ; expect ( setToken ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { jest . resetAllMocks ( ) ; const dispatch = jest . fn ( ) ; const state = fakeState ( ) ; delete state . auth ; const getState = ( ) => state ; const thunk = ready ( ) ; thunk ( dispatch , getState ) ; expect ( Session . clear ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const old = auth ; old . token . unencoded . jti = "s" ; const dispatch = jest . fn ( ) ; console . warn = jest . fn ( ) ; storeToken ( old , dispatch ) ( undefined ) ; expect ( setToken ) . toHaveBeenCalledWith ( old ) ; expect ( didLogin ) . toHaveBeenCalledWith ( old , dispatch ) ; expect ( console . warn ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; } ) ; } ) ;	O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O $complex$ O O O O $PromiseConstructor$ O $complex$ O O $complex$ O $complex$ O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $any$ O O O O $undefined$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $Thunk$ O $void$ O O O O O O $ReduxAction<AuthState>$ O $void$ O O O O O O $any$ O O O O O O $AuthState$ O O O O O O $Everything$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $Thunk$ O $Thunk$ O O O $Thunk$ O $any$ O $Everything$ O O $any$ O $ReduxAction<AuthState>$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $Everything$ O $Everything$ O O O O $Everything$ O $AuthState$ O O $Everything$ O O O O $Everything$ O O $Thunk$ O $Thunk$ O O O $Thunk$ O $any$ O $Everything$ O O $any$ O $any$ O $never$ O O $any$ O O O O O O $any$ O O O O O O O O $AuthState$ O $AuthState$ O $AuthState$ O $Token$ O $UnencodedToken$ O $string$ O O O O $any$ O $any$ O $any$ O O O $Console$ O $void$ O $any$ O $any$ O O O $void$ O $AuthState$ O $any$ O O $undefined$ O O $any$ O $ReduxAction<AuthState>$ O O $any$ O $AuthState$ O O $any$ O $void$ O O $any$ O $AuthState$ O $any$ O O $any$ O $Console$ O $void$ O O $any$ O $any$ O $any$ O O O O O O O O O O O
import { configReducer } from "s" ; import { ConfigState , ChangeApiPort , ChangeApiHost } from "s" ; import { Actions } from "s" ; import { ReduxAction } from "s" ; describe ( "s" , ( ) => { const 0 = { host : "s" , port : "s" } ; it ( "s" , ( ) => { const 0 < ChangeApiPort > = { type : Actions . CHANGE_API_PORT , payload : { port : "s" } } ; const r = configReducer ( 0 , 0 ) ; expect ( r . port ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const 0 < ChangeApiHost > = { type : Actions . CHANGE_API_HOST , payload : { host : "s" } } ; const r = configReducer ( 0 , 0 ) ; expect ( r . host ) . toEqual ( "s" ) ; } ) ; } ) ;	O O $generateReducer<ConfigState>.GeneratedReducer$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $ConfigState$ O O $string$ O O O $string$ O O O O $any$ O O O O O O O O $ReduxAction$ O $any$ O O O $Actions.CHANGE_API_PORT$ O $any$ O $Actions.CHANGE_API_PORT$ O $complex$ O O $string$ O O O O O O $ConfigState$ O $generateReducer<ConfigState>.GeneratedReducer$ O $ConfigState$ O $ReduxAction<ChangeApiPort>$ O O $any$ O $ConfigState$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $ReduxAction$ O $any$ O O O $Actions.CHANGE_API_HOST$ O $any$ O $Actions.CHANGE_API_HOST$ O $complex$ O O $string$ O O O O O O $ConfigState$ O $generateReducer<ConfigState>.GeneratedReducer$ O $ConfigState$ O $ReduxAction<ChangeApiHost>$ O O $any$ O $ConfigState$ O $string$ O O $any$ O O O O O O O O O O
import { toggleWebAppBool } from "s" ; import { BooleanSetting } from "s" ; import { fakeState } from "s" ; jest . mock ( "s" , ( ) => { return { save : jest . fn ( ) , edit : jest . fn ( ) } ; } ) ; jest . mock ( "s" , ( ) => { return { getWebAppConfig : jest . fn ( ( ) => ( undefined ) ) , getFbosConfig : jest . fn ( ( ) => ( undefined ) ) , } ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const action = toggleWebAppBool ( BooleanSetting . show_first_party_farmware ) ; const dispatch = jest . fn ( ) ; const kaboom = ( ) => action ( dispatch , fakeState ) ; expect ( kaboom ) . toThrowError ( "s" ) ; } ) ; } ) ;	O O $void$ O O O O O O $complex$ O O O O O O $Everything$ O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O $undefined$ O O O $any$ O $any$ O $any$ O O O O O $undefined$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $void$ O $void$ O $complex$ O $any$ O O O $any$ O $any$ O $any$ O O O O $void$ O O O O $void$ O $any$ O $Everything$ O O $any$ O $void$ O O $any$ O O O O O O O O O O
import { toggleWebAppBool , getWebAppConfigValue , setWebAppConfigValue } from "s" ; import { BooleanSetting , NumericSetting } from "s" ; import { edit , save } from "s" ; import { fakeWebAppConfig } from "s" ; import { fakeState } from "s" ; jest . mock ( "s" , ( ) => { return { save : jest . fn ( ) , edit : jest . fn ( ) } ; } ) ; let mockConfig = fakeWebAppConfig ( ) ; jest . mock ( "s" , ( ) => { return { getWebAppConfig : ( ) => mockConfig } ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const action = toggleWebAppBool ( BooleanSetting . show_first_party_farmware ) ; const dispatch = jest . fn ( ) ; action ( dispatch , fakeState ) ; expect ( edit ) . toHaveBeenCalledWith ( mockConfig , { show_first_party_farmware : true } ) ; expect ( save ) . toHaveBeenCalledWith ( mockConfig . uuid ) ; } ) ; } ) ; describe ( "s" , ( ) => { const getValue = getWebAppConfigValue ( fakeState ) ; it ( "s" , ( ) => { expect ( getValue ( BooleanSetting . show_first_party_farmware ) ) . toEqual ( false ) ; } ) ; it ( "s" , ( ) => { expect ( getValue ( NumericSetting . warn_log ) ) . toEqual ( 0 ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { setWebAppConfigValue ( NumericSetting . fun_log , 0 ) ( jest . fn ( ) , fakeState ) ; expect ( edit ) . toHaveBeenCalledWith ( mockConfig , { fun_log : 0 } ) ; expect ( save ) . toHaveBeenCalledWith ( mockConfig . uuid ) ; } ) ; it ( "s" , ( ) => { mockConfig = undefined as any ; const action = ( ) => setWebAppConfigValue ( NumericSetting . fun_log , 0 ) ( jest . fn ( ) , fakeState ) ; expect ( action ) . toThrowError ( "s" ) ; } ) ; } ) ;	O O $void$ O $complex$ O $void$ O O O O O O $complex$ O $complex$ O O O O O O $ReduxAction<EditResourceParams>$ O $any$ O O O O O O $any$ O O O O O O $Everything$ O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $void$ O $void$ O $complex$ O $any$ O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O $Everything$ O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O O $boolean$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O $Everything$ O O $any$ O O O O O O O $any$ O $complex$ O $complex$ O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $complex$ O $complex$ O $any$ O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $void$ O $complex$ O $any$ O O O O $any$ O $any$ O O O $Everything$ O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O O $number$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O $undefined$ O O O O $void$ O O O O $void$ O $complex$ O $any$ O O O O $any$ O $any$ O O O $Everything$ O O $any$ O $void$ O O $any$ O O O O O O O O O O
jest . mock ( "s" , ( ) => ( { handleCreateOrUpdate : jest . fn ( ) } ) ) ; jest . mock ( "s" , ( ) => ( { destroyOK : jest . fn ( ) } ) ) ; import { fakeState } from "s" ; import { GetState } from "s" ; import { handleInbound } from "s" ; import { handleCreateOrUpdate } from "s" ; import { destroyOK } from "s" ; import { SkipMqttData , BadMqttData , UpdateMqttData , DeleteMqttData } from "s" ; import { unpackUUID } from "s" ; import { TaggedSequence } from "s" ; describe ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const getState = jest . fn ( fakeState ) ; it ( "s" , ( ) => { const fixtr = { status : "s" } ; const result = handleInbound ( dispatch , getState , fixtr ) ; expect ( result ) . toBeUndefined ( ) ; expect ( dispatch ) . not . toHaveBeenCalled ( ) ; expect ( getState ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const fixtr = { status : "s" , reason : "s" } ; const result = handleInbound ( dispatch , getState , fixtr ) ; expect ( result ) . toBeUndefined ( ) ; expect ( dispatch ) . not . toHaveBeenCalled ( ) ; expect ( getState ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const fixtr < TaggedSequence > = { status : "s" , kind : "s" , id : 0 , body : { } as TaggedSequence [ "s" ] , sessionId : "s" } ; handleInbound ( dispatch , getState , fixtr ) ; expect ( handleCreateOrUpdate ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const i = getState ( ) . resources . index . byKind . Sequence ; const id = unpackUUID ( Object . keys ( i ) [ 0 ] ) . remoteId || - 0 ; const fixtr < TaggedSequence > = { status : "s" , kind : "s" , id } ; handleInbound ( dispatch , getState , fixtr ) ; expect ( dispatch ) . toHaveBeenCalled ( ) ; expect ( destroyOK ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const fixtr < TaggedSequence > = { status : "s" , kind : "s" , id : - 0 } ; handleInbound ( dispatch , getState , fixtr ) ; expect ( dispatch ) . not . toHaveBeenCalled ( ) ; expect ( destroyOK ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $Everything$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $BetterUUID$ O O O O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $GetState$ O $any$ O $any$ O $Everything$ O O $any$ O O O O O O O O $SkipMqttData$ O O O O O O O O $any$ O $any$ O $any$ O $GetState$ O $SkipMqttData$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $GetState$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $BadMqttData$ O O O O O O $string$ O O O O O $any$ O $any$ O $any$ O $GetState$ O $BadMqttData$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $GetState$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $UpdateMqttData$ O $any$ O O O O O O O $string$ O O O $number$ O O O $any$ O O O O $any$ O O O O $string$ O O O O $any$ O $any$ O $GetState$ O $UpdateMqttData<any>$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $complex$ O $GetState$ O O O $RestResources$ O $ResourceIndex$ O $complex$ O $any$ O O $number$ O $BetterUUID$ O $ObjectConstructor$ O $complex$ O $complex$ O O O O O O $number$ O O O O O $DeleteMqttData$ O $any$ O O O O O O O $string$ O O O $number$ O O $any$ O $any$ O $GetState$ O $DeleteMqttData<any>$ O O $any$ O $any$ O O $any$ O O O $any$ O $complex$ O O $any$ O O O O O O $any$ O O O O O O O O $DeleteMqttData$ O $any$ O O O O O O O $string$ O O O $number$ O O O O O $any$ O $any$ O $GetState$ O $DeleteMqttData<any>$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O
import { decodeBinary , routeMqttData , asTaggedResource , handleCreate , handleUpdate , handleCreateOrUpdate } from "s" ; import { SpecialStatus , TaggedSequence } from "s" ; import { Actions } from "s" ; import { fakeState } from "s" ; import { GetState } from "s" ; import { SyncPayload , UpdateMqttData , Reason } from "s" ; import { storeUUID } from "s" ; import { unpackUUID } from "s" ; function toBinary ( input ) { return Buffer . from ( JSON . stringify ( input ) , "s" ) ; } const fakePayload = { args : { label : "s" } , body : { foo : "s" } } ; const payload = ( ) : UpdateMqttData < TaggedSequence > => ( { status : "s" , kind : "s" , id : 0 , body : { } as TaggedSequence [ "s" ] , sessionId : "s" } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const myPayload = payload ( ) ; const dispatch = jest . fn ( ) ; const getState = jest . fn ( fakeState ) ; const result = handleCreateOrUpdate ( dispatch , getState , myPayload ) ; expect ( result ) . toBe ( undefined ) ; expect ( dispatch ) . toHaveBeenCalled ( ) ; expect ( dispatch ) . toHaveBeenCalledWith ( expect . objectContaining ( { type : Actions . INIT_RESOURCE } ) ) ; } ) ; it ( "s" , ( ) => { jest . resetAllMocks ( ) ; const myPayload = payload ( ) ; const dispatch = jest . fn ( ) ; const getState = jest . fn ( fakeState ) as GetState ; const fakeUuid = "s" ; myPayload . sessionId = fakeUuid ; storeUUID ( fakeUuid ) ; const result = handleCreateOrUpdate ( dispatch , getState , myPayload ) ; expect ( result ) . toBe ( true ) ; expect ( dispatch ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const myPayload = payload ( ) ; const dispatch = jest . fn ( ) ; const getState = jest . fn ( fakeState ) as GetState ; const { index } = getState ( ) . resources ; const fakeId = unpackUUID ( Object . keys ( index . byKind . Sequence ) [ 0 ] ) . remoteId || - 0 ; myPayload . id = fakeId ; myPayload . kind = "s" ; handleCreateOrUpdate ( dispatch , getState , myPayload ) ; expect ( dispatch ) . toHaveBeenCalled ( ) ; expect ( dispatch ) . toHaveBeenCalledWith ( expect . objectContaining ( { type : Actions . OVERWRITE_RESOURCE } ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const uuid = "s" ; const wow = handleUpdate ( payload ( ) , uuid ) ; expect ( wow . type ) . toEqual ( Actions . OVERWRITE_RESOURCE ) ; expect ( wow . payload . uuid ) . toBe ( uuid ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const wow = handleCreate ( payload ( ) ) ; expect ( wow . type ) . toEqual ( Actions . INIT_RESOURCE ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const p = payload ( ) ; const result = asTaggedResource ( p ) ; expect ( result . body ) . toEqual ( p . body ) ; expect ( result . kind ) . toEqual ( p . kind ) ; expect ( result . specialStatus ) . toEqual ( SpecialStatus . SAVED ) ; expect ( result . uuid ) . toContain ( p . kind ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const results = decodeBinary ( toBinary ( fakePayload ) ) ; expect ( results . args ) . toBeInstanceOf ( Object ) ; expect ( results . args . label ) . toEqual ( "s" ) ; expect ( results . body ) . toBeInstanceOf ( Object ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const other = "s" ; expect ( routeMqttData ( other , toBinary ( { } ) ) . status ) . toEqual ( "s" ) ; const 0 = "s" ; expect ( routeMqttData ( 0 , toBinary ( { } ) ) . status ) . toEqual ( "s" ) ; const sync = "s" ; expect ( routeMqttData ( sync , toBinary ( { } ) ) . status ) . not . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const results = routeMqttData ( "s" , toBinary ( { } ) ) ; expect ( results . status ) . toEqual ( "s" ) ; results . status === "s" && expect ( results . reason ) . toEqual ( Reason . BAD_CHAN ) ; } ) ; it ( "s" , ( ) => { const results = routeMqttData ( "s" , toBinary ( { } ) ) ; expect ( results . status ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const results = routeMqttData ( "s" , toBinary ( { } ) ) ; expect ( results . status ) . toEqual ( "s" ) ; if ( results . status !== "s" ) { fail ( ) ; return ; } expect ( results . id ) . toEqual ( 0 ) ; expect ( results . kind ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const 0 = { args : { label : "s" } , body : { foo : "s" } } ; const payl = toBinary ( 0 ) ; const results = routeMqttData ( "s" , payl ) ; expect ( results . status ) . toEqual ( "s" ) ; if ( results . status !== "s" ) { fail ( ) ; return ; } expect ( results . id ) . toEqual ( 0 ) ; expect ( results . kind ) . toEqual ( "s" ) ; expect ( results . body ) . toEqual ( 0 . body ) ; } ) ; } ) ;	O O $SyncPayload$ O $MqttDataResult<any>$ O $any$ O $ReduxAction<any>$ O $ReduxAction<EditResourceParams>$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $Everything$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $void$ O O O O O O $BetterUUID$ O O O O O $Buffer$ O $object$ O O O $any$ O $any$ O $JSON$ O $complex$ O $object$ O O O O O O O $SyncPayload$ O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O O O O $UpdateMqttData<any>$ O O O O $any$ O $any$ O O O O O O O O $string$ O O O $number$ O O O $any$ O O O O $any$ O O O O $string$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $UpdateMqttData<any>$ O $UpdateMqttData<any>$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $Everything$ O O O $any$ O $any$ O $any$ O $any$ O $UpdateMqttData<any>$ O O $any$ O $any$ O O $any$ O $undefined$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $Actions$ O $any$ O $Actions.INIT_RESOURCE$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $UpdateMqttData<any>$ O $UpdateMqttData<any>$ O O O O $any$ O $any$ O $any$ O O O O $GetState$ O $any$ O $any$ O $Everything$ O O $any$ O O O O O O $UpdateMqttData<any>$ O $string$ O O O $void$ O O O O O $any$ O $any$ O $any$ O $GetState$ O $UpdateMqttData<any>$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $UpdateMqttData<any>$ O $UpdateMqttData<any>$ O O O O $any$ O $any$ O $any$ O O O O $GetState$ O $any$ O $any$ O $Everything$ O O $any$ O O O $ResourceIndex$ O O $GetState$ O O O $RestResources$ O O $number$ O $BetterUUID$ O $ObjectConstructor$ O $complex$ O $ResourceIndex$ O $complex$ O $any$ O O O O O O $number$ O O O O $UpdateMqttData<any>$ O $number$ O $number$ O $UpdateMqttData<any>$ O $any$ O O O $any$ O $any$ O $GetState$ O $UpdateMqttData<any>$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $Actions$ O $any$ O $Actions.OVERWRITE_RESOURCE$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $ReduxAction<EditResourceParams>$ O $ReduxAction<EditResourceParams>$ O $UpdateMqttData<any>$ O O O O O O $any$ O $ReduxAction<EditResourceParams>$ O $Actions$ O O $any$ O $any$ O $Actions.OVERWRITE_RESOURCE$ O O $any$ O $ReduxAction<EditResourceParams>$ O $EditResourceParams$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $ReduxAction<any>$ O $ReduxAction<any>$ O $UpdateMqttData<any>$ O O O O $any$ O $ReduxAction<any>$ O $Actions$ O O $any$ O $any$ O $Actions.INIT_RESOURCE$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $UpdateMqttData<any>$ O $UpdateMqttData<any>$ O O O O $any$ O $any$ O $UpdateMqttData<any>$ O O $any$ O $any$ O $any$ O O $any$ O $UpdateMqttData<any>$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $UpdateMqttData<any>$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $UpdateMqttData<any>$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $SyncPayload$ O $SyncPayload$ O $any$ O $SyncPayload$ O O O $any$ O $SyncPayload$ O $complex$ O O $any$ O $ObjectConstructor$ O O $any$ O $SyncPayload$ O $complex$ O $string$ O O $any$ O O O O $any$ O $SyncPayload$ O $object$ O O $any$ O $ObjectConstructor$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O $any$ O $MqttDataResult<any>$ O O O $any$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $MqttDataResult<any>$ O O O $any$ O O O O O O O O O $any$ O O O O O O O O O $any$ O $MqttDataResult<any>$ O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $MqttDataResult<any>$ O $MqttDataResult<any>$ O O O $any$ O O O O O O $any$ O $MqttDataResult<any>$ O O O O $any$ O O O O $MqttDataResult<any>$ O O O O O $any$ O $BadMqttData$ O $string$ O O $any$ O $any$ O $Reason.BAD_CHAN$ O O O O O $any$ O O O O O O O O $MqttDataResult<any>$ O $MqttDataResult<any>$ O O O $any$ O O O O O O $any$ O $MqttDataResult<any>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $MqttDataResult<any>$ O $MqttDataResult<any>$ O O O $any$ O O O O O O $any$ O $MqttDataResult<any>$ O O O O $any$ O O O O O O $MqttDataResult<any>$ O O O O O O $any$ O O O O O O $any$ O $DeleteMqttData<any>$ O $number$ O O $any$ O O O O $any$ O $DeleteMqttData<any>$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O O O O $any$ O $any$ O $complex$ O O O $MqttDataResult<any>$ O $MqttDataResult<any>$ O O O $any$ O O $any$ O $MqttDataResult<any>$ O O O O $any$ O O O O O O $MqttDataResult<any>$ O O O O O O $any$ O O O O O O $any$ O $UpdateMqttData<any>$ O $number$ O O $any$ O O O O $any$ O $UpdateMqttData<any>$ O $any$ O O $any$ O O O O $any$ O $UpdateMqttData<any>$ O $any$ O O $any$ O $complex$ O $complex$ O O O O O O O O
jest . mock ( "s" , ( ) => { return { bothUp : jest . fn ( ) , batchInitResources : jest . fn ( ( ) => ( { type : "s" , payload : undefined } ) ) } ; } ) ; const mockThrottleStatus = { value : false } ; jest . mock ( "s" , ( ) => { return { deviceIsThrottled : jest . fn ( ( ) => mockThrottleStatus . value ) } ; } ) ; import { BatchQueue } from "s" ; import { fakeLog } from "s" ; import { bothUp , batchInitResources } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { mockThrottleStatus . value = false ; const q = new BatchQueue ( 0 ) ; const log = fakeLog ( ) ; q . push ( log ) ; q . maybeWork ( ) ; expect ( bothUp ) . toHaveBeenCalled ( ) ; expect ( batchInitResources ) . toHaveBeenCalledWith ( [ log ] ) ; } ) ; it ( "s" , ( ) => { mockThrottleStatus . value = true ; const q = new BatchQueue ( 0 ) ; q . push ( fakeLog ( ) ) ; q . maybeWork ( ) ; expect ( bothUp ) . toHaveBeenCalled ( ) ; expect ( batchInitResources ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $undefined$ O $undefined$ O O O O O O O O O $complex$ O O $boolean$ O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O $boolean$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O $ReduxAction<any[]>$ O O O O $any$ O O O O O O O $any$ O O O O O O O $complex$ O $boolean$ O O O O $BatchQueue$ O O $any$ O O O O O $any$ O $any$ O O O $BatchQueue$ O $void$ O $any$ O O $BatchQueue$ O $void$ O O O $any$ O $void$ O O $any$ O O O $any$ O $ReduxAction<any[]>$ O O $any$ O O $any$ O O O O O O $any$ O O O O O O O $complex$ O $boolean$ O O O O $BatchQueue$ O O $any$ O O O O $BatchQueue$ O $void$ O $any$ O O O O $BatchQueue$ O $void$ O O O $any$ O $void$ O O $any$ O O O $any$ O $ReduxAction<any[]>$ O O $any$ O $any$ O O O O O O O O O
jest . mock ( "s" , ( ) => { return { fetchNewDevice : jest . fn ( ( ) => Promise . resolve ( { } ) ) } ; } ) ; import { fetchNewDevice } from "s" ; import { connectDevice } from "s" ; import { DeepPartial } from "s" ; import { AuthState } from "s" ; import { fakeState } from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const auth < AuthState > = { token : { } } ; const dispatch = jest . fn ( ) ; const getState = jest . fn ( ( ) => fakeState ( ) ) ; const fn = connectDevice ( auth as AuthState ) ; await fn ( dispatch , getState ) ; expect ( fetchNewDevice ) . toHaveBeenCalledWith ( auth ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O O O $Promise<any>$ O O O O O O $Promise<void>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Everything$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $DeepPartial$ O $any$ O O O ${}$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $Everything$ O O O O O $Promise<void>$ O $Promise<void>$ O $any$ O $any$ O O O $Promise<void>$ O $any$ O $any$ O O $any$ O $Promise<any>$ O O $any$ O $any$ O O O O O O O O
const on = jest . fn ( ( _e , _cb ) => undefined ) ; const stub = ( ) => Promise . resolve ( ) ; const mockBot = { client : { subscribe : jest . fn ( ) , on } , on , readStatus : jest . fn ( stub ) , setUserEnv : stub , } ; jest . mock ( "s" , ( ) => { return { getDevice : ( ) => mockBot } ; } ) ; jest . mock ( "s" , ( ) => { return { startPinging : jest . fn ( ) } ; } ) ; import { getDevice } from "s" ; import { FbjsEventName } from "s" ; import { attachEventListeners } from "s" ; import { startPinging } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dev = getDevice ( ) ; attachEventListeners ( dev , jest . fn ( ) , jest . fn ( ) ) ; [ FbjsEventName . legacy_status , FbjsEventName . logs , FbjsEventName . malformed , FbjsEventName . offline , FbjsEventName . online , FbjsEventName . online , FbjsEventName . sent , FbjsEventName . upsert , FbjsEventName . publicBroadcast , ] . map ( e => expect ( dev . on ) . toHaveBeenCalledWith ( e , expect . any ( Function ) ) ) ; [ "s" , "s" ] . map ( e => { if ( dev . client ) { expect ( dev . client . on ) . toHaveBeenCalledWith ( e , expect . any ( Function ) ) ; } else { fail ( "s" ) ; } } ) ; expect ( dev . readStatus ) . toHaveBeenCalled ( ) ; expect ( dev . client && dev . client . subscribe ) . toHaveBeenCalled ( ) ; expect ( startPinging ) . toHaveBeenCalledWith ( dev ) ; } ) ; } ) ;	O $any$ O $any$ O $any$ O O $string$ O $unknown$ O O $undefined$ O O O $Promise<void>$ O O O O $PromiseConstructor$ O $complex$ O O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $Promise<void>$ O O $Promise<void>$ O $Promise<void>$ O O O $any$ O $any$ O O O O O O O O O $complex$ O O O O $complex$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $U[]$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $FunctionConstructor$ O O O O O O O O O O $U[]$ O $string$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $string$ O $any$ O $any$ O $FunctionConstructor$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O
jest . mock ( "s" , ( ) => ( { dispatchNetworkUp : jest . fn ( ) , dispatchNetworkDown : jest . fn ( ) } ) ) ; const mockDevice = { readStatus : jest . fn ( ( ) => Promise . resolve ( ) ) } ; jest . mock ( "s" , ( ) => ( { getDevice : ( ) => mockDevice } ) ) ; let mockConfigValue = false ; jest . mock ( "s" , ( ) => ( { getWebAppConfigValue : ( ) => ( ) => mockConfigValue , } ) ) ; import { HardwareState } from "s" ; import { incomingLegacyStatus , actOnChannelName , showLogOnScreen , TITLE , bothUp , initLog , readStatus , onOffline , changeLastClientConnected , onSent , onOnline , onMalformed , speakLogAloud , onPublicBroadcast , onReconnect , } from "s" ; import { Actions , Content } from "s" ; import { Log } from "s" ; import { ALLOWED_CHANNEL_NAMES , ALLOWED_MESSAGE_TYPES , Farmbot } from "s" ; import { dispatchNetworkUp , dispatchNetworkDown } from "s" ; import { getDevice } from "s" ; import { talk } from "s" ; import { MessageType } from "s" ; import { FbjsEventName } from "s" ; import { info , error , success , warning , fun , busy } from "s" ; import { onLogs } from "s" ; import { fakeState } from "s" ; import { globalQueue } from "s" ; const ANY_NUMBER = expect . any ( Number ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { readStatus ( ) ; expect ( getDevice ( ) . readStatus ) . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const stub = { } as HardwareState ; const result = incomingLegacyStatus ( stub ) ; expect ( result . type ) . toEqual ( Actions . LEGACY_BOT_CHANGE ) ; expect ( result . payload ) . toEqual ( stub ) ; } ) ; } ) ; function fakeLog ( meta_type , channels : ALLOWED_CHANNEL_NAMES [ ] = [ "s" ] ) { return { message : "s" , type : meta_type , channels , created_at : - 0 } ; } describe ( "s" , ( ) => { it ( "s" , ( ) => { const callback = jest . fn ( ) ; actOnChannelName ( fakeLog ( MessageType . success , [ "s" ] ) , "s" , callback ) ; expect ( callback ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const callback = jest . fn ( ) ; const fakeToast = fakeLog ( MessageType . success , [ "s" , "s" ] ) ; actOnChannelName ( fakeToast , "s" , callback ) ; expect ( callback ) . toHaveBeenCalledWith ( fakeToast ) ; } ) ; } ) ; describe ( "s" , ( ) => { function assertToastr ( types : ALLOWED_MESSAGE_TYPES [ ] , toastr ) { jest . resetAllMocks ( ) ; types . map ( ( x ) => { const log = fakeLog ( x , [ "s" ] ) ; showLogOnScreen ( log ) ; expect ( toastr ) . toHaveBeenCalledWith ( log . message , TITLE ( ) ) ; } ) ; } it ( "s" , ( ) => { assertToastr ( [ MessageType . info , ( "s" as ALLOWED_MESSAGE_TYPES ) ] , info ) ; } ) ; it ( "s" , ( ) => { assertToastr ( [ MessageType . error ] , error ) ; } ) ; it ( "s" , ( ) => { assertToastr ( [ MessageType . warn ] , warning ) ; } ) ; it ( "s" , ( ) => { assertToastr ( [ MessageType . busy ] , busy ) ; } ) ; it ( "s" , ( ) => { assertToastr ( [ MessageType . fun ] , fun ) ; } ) ; it ( "s" , ( ) => { assertToastr ( [ MessageType . success ] , success ) ; } ) ; it ( "s" , ( ) => { const log = fakeLog ( MessageType . debug , [ "s" ] ) ; showLogOnScreen ( log ) ; expect ( info ) . toHaveBeenCalledWith ( log . message , TITLE ( ) , "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { const fakeSpeakLog = fakeLog ( MessageType . info ) ; fakeSpeakLog . message = "s" ; it ( "s" , ( ) => { mockConfigValue = false ; const speak = speakLogAloud ( jest . fn ( ) ) ; speak ( fakeSpeakLog ) ; expect ( talk ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { mockConfigValue = true ; const speak = speakLogAloud ( jest . fn ( ) ) ; Object . defineProperty ( navigator , "s" , { value : "s" , configurable : true } ) ; speak ( fakeSpeakLog ) ; expect ( talk ) . toHaveBeenCalledWith ( "s" , "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const log = fakeLog ( MessageType . error ) ; const action = initLog ( log ) ; expect ( action . payload . kind ) . toBe ( "s" ) ; if ( action . payload . kind === "s" ) { expect ( action . payload . body . message ) . toBe ( log . message ) ; } else { fail ( ) ; } } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { bothUp ( ) ; expect ( dispatchNetworkUp ) . toHaveBeenCalledWith ( "s" , ANY_NUMBER ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { jest . resetAllMocks ( ) ; onOffline ( ) ; expect ( dispatchNetworkDown ) . toHaveBeenCalledWith ( "s" , ANY_NUMBER ) ; expect ( error ) . toHaveBeenCalledWith ( Content . MQTT_DISCONNECTED ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { jest . resetAllMocks ( ) ; onOnline ( ) ; expect ( dispatchNetworkUp ) . toHaveBeenCalledWith ( "s" , ANY_NUMBER ) ; } ) ; } ) ; describe ( "s" , ( ) => { onReconnect ( ) ; expect ( warning ) . toHaveBeenCalledWith ( "s" , "s" , "s" ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const setUserEnv = jest . fn ( ( ) => Promise . resolve ( { } ) ) ; const fakeFarmbot = { setUserEnv : setUserEnv as any } as Farmbot ; changeLastClientConnected ( fakeFarmbot ) ( ) ; expect ( setUserEnv ) . toHaveBeenCalledWith ( expect . objectContaining ( { "s" : expect . any ( String ) } ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { jest . resetAllMocks ( ) ; onSent ( { connected : true } ) ( ) ; expect ( dispatchNetworkUp ) . toHaveBeenCalledWith ( "s" , ANY_NUMBER ) ; } ) ; it ( "s" , ( ) => { jest . resetAllMocks ( ) ; onSent ( { connected : false } ) ( ) ; expect ( dispatchNetworkDown ) . toHaveBeenCalledWith ( "s" , ANY_NUMBER ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { onMalformed ( ) ; expect ( warning ) . toHaveBeenCalledWith ( Content . MALFORMED_MESSAGE_REC_UPGRADE ) ; jest . resetAllMocks ( ) ; onMalformed ( ) ; expect ( warning ) . not . toHaveBeenCalledWith ( Content . MALFORMED_MESSAGE_REC_UPGRADE ) ; } ) ; } ) ; describe ( "s" , ( ) => { const expectBroadcastLog = ( ) => expect ( console . log ) . toHaveBeenCalledWith ( FbjsEventName . publicBroadcast , expect . any ( Object ) ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const fn = onLogs ( dispatch , fakeState ) ; const log = fakeLog ( MessageType . error , [ ] ) ; log . message = "s" ; const taggedLog = fn ( log ) ; globalQueue . maybeWork ( ) ; expect ( taggedLog && taggedLog . kind ) . toEqual ( "s" ) ; } ) ; } ) ; it ( "s" , ( ) => { location . assign = jest . fn ( ) ; window . confirm = jest . fn ( ( ) => true ) ; console . log = jest . fn ( ) ; onPublicBroadcast ( { } ) ; expectBroadcastLog ( ) ; expect ( window . confirm ) . toHaveBeenCalledWith ( Content . FORCE_REFRESH_CONFIRM ) ; expect ( location . assign ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { window . confirm = jest . fn ( ( ) => false ) ; window . alert = jest . fn ( ) ; console . log = jest . fn ( ) ; onPublicBroadcast ( { } ) ; expectBroadcastLog ( ) ; expect ( window . alert ) . toHaveBeenCalledWith ( Content . FORCE_REFRESH_CANCEL_WARNING ) ; expect ( location . assign ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O $complex$ O O O O O $boolean$ O O O $any$ O $any$ O O O O O O O O $boolean$ O O O O O O O $boolean$ O O O O O O O $any$ O O O O O O $complex$ O $any$ O $void$ O $any$ O $void$ O $ReduxAction<any>$ O $any$ O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $void$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O O O O O O $any$ O O O O O O $Everything$ O O O O O O $BatchQueue$ O O O O O $any$ O $any$ O $any$ O $NumberConstructor$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O $any$ O $any$ O O O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O O $complex$ O $complex$ O $any$ O O $any$ O $complex$ O $Actions$ O O $any$ O $any$ O $Actions.LEGACY_BOT_CHANGE$ O O $any$ O $complex$ O $any$ O O $any$ O $any$ O O O O O O O O O $Log$ O $ALLOWED_MESSAGE_TYPES$ O $any[]$ O $any$ O O O O O O O O O O $string$ O O O $any$ O $any$ O $any[]$ O $number$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $MessageType.success$ O O O O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $MessageType.success$ O O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $void$ O $any[]$ O $any$ O O O $Function$ O O $any$ O $any$ O O O $any[]$ O $U[]$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $void$ O $any$ O O $any$ O $Function$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $void$ O O $any$ O $MessageType.info$ O O O O $any$ O O O $void$ O O O O O $any$ O O O O O O O $void$ O O $any$ O $MessageType.error$ O O $void$ O O O O O $any$ O O O O O O O $void$ O O $any$ O $MessageType.warn$ O O $void$ O O O O O $any$ O O O O O O O $void$ O O $any$ O $MessageType.busy$ O O $void$ O O O O O $any$ O O O O O O O $void$ O O $any$ O $MessageType.fun$ O O $void$ O O O O O $any$ O O O O O O O $void$ O O $any$ O $MessageType.success$ O O $void$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $MessageType.debug$ O O O O O O $void$ O $any$ O O $any$ O $void$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $MessageType.info$ O O $any$ O $any$ O O O $any$ O O O O O O O $boolean$ O O O O $void$ O $void$ O $any$ O $any$ O O O O $void$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $boolean$ O O O O $void$ O $void$ O $any$ O $any$ O O O O $ObjectConstructor$ O $any$ O $Navigator$ O O O O $string$ O O O $true$ O O O O O $void$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $MessageType.error$ O O O $ReduxAction<any>$ O $ReduxAction<any>$ O $any$ O O $any$ O $ReduxAction<any>$ O $any$ O $any$ O O $any$ O O O O O O $ReduxAction<any>$ O $any$ O $any$ O O O O $any$ O $ReduxAction<any>$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $void$ O O O $any$ O $void$ O O $any$ O O O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $void$ O O O $any$ O $void$ O O $any$ O O O $any$ O O $any$ O $void$ O O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $void$ O O O $any$ O $void$ O O $any$ O O O $any$ O O O O O O O O $any$ O O O O O O O $void$ O O O $any$ O $void$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O $any$ O O $any$ O $any$ O O O O $any$ O $void$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $StringConstructor$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $void$ O O $true$ O O O O O O O $any$ O $void$ O O $any$ O O O $any$ O O O O O $any$ O O O O O O O $any$ O $any$ O O O $void$ O O $false$ O O O O O O O $any$ O $void$ O O $any$ O O O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $void$ O O O $any$ O $void$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O O O $void$ O O O $any$ O $void$ O O $any$ O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $Console$ O $void$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $ObjectConstructor$ O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $Everything$ O O O $any$ O $any$ O $any$ O $MessageType.error$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $BatchQueue$ O $void$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $Location$ O $void$ O $any$ O $any$ O O O $complex$ O $boolean)$ O $any$ O $any$ O O O O O O O $Console$ O $void$ O $any$ O $any$ O O O $void$ O O O O O $any$ O O O $any$ O $complex$ O $boolean)$ O O $any$ O $any$ O $string$ O O $any$ O $Location$ O $void$ O O $any$ O O O O O O $any$ O O O O O O O $complex$ O $boolean)$ O $any$ O $any$ O O O O O O O $complex$ O $void)$ O $any$ O $any$ O O O $Console$ O $void$ O $any$ O $any$ O O O $void$ O O O O O $any$ O O O $any$ O $complex$ O $void)$ O O $any$ O $any$ O $string$ O O $any$ O $Location$ O $void$ O O $any$ O $any$ O O O O O O O O O
jest . mock ( "s" , ( ) => ( { throttle : jest . fn ( ) } ) ) ; import { slowDown } from "s" ; import { throttle } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const fn = jest . fn ( ) ; slowDown ( fn ) ; expect ( throttle ) . toHaveBeenCalledWith ( fn , 0 , { leading : false , trailing : true } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O $boolean$ O O O $boolean$ O O O O O O O O O O O
jest . mock ( "s" , ( ) => { return { slowDown : jest . fn ( ( fn ) => fn ) , } ; } ) ; jest . mock ( "s" , ( ) => ( { badVersion : jest . fn ( ) , EXPECTED_MAJOR : 0 , EXPECTED_MINOR : 0 , } ) ) ; import { onStatus , incomingStatus , incomingLegacyStatus , onLegacyStatus , HACKY_FLAGS } from "s" ; import { slowDown } from "s" ; import { fakeState } from "s" ; import { badVersion } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const fake = { location_data : { position : { x : 0 , y : 0 , z : 0 } } } ; expect ( slowDown ) . not . toHaveBeenCalled ( ) ; onStatus ( dispatch , fakeState ) ( fake ) ; expect ( dispatch ) . toHaveBeenCalledWith ( incomingStatus ( fake ) ) ; } ) ; const callOnStatus = ( version : string | undefined ) => { HACKY_FLAGS . needVersionCheck = true ; const dispatch = jest . fn ( ) ; const state = fakeState ( ) ; state . bot . hardware . informational_settings . controller_version = version ; onStatus ( dispatch , ( ) => state ) ( { } ) ; } ; it ( "s" , ( ) => { callOnStatus ( "s" ) ; expect ( badVersion ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { callOnStatus ( undefined ) ; expect ( badVersion ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { callOnStatus ( "s" ) ; expect ( badVersion ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = fakeState ( ( ) => state ) ; const getState = jest . fn ( ( ) => state ) ; const dispatch = jest . fn ( ) ; const fake = state . bot . hardware ; expect ( slowDown ) . not . toHaveBeenCalled ( ) ; onLegacyStatus ( dispatch , getState ) ( fake ) ; expect ( dispatch ) . toHaveBeenCalledWith ( incomingLegacyStatus ( state . bot . hardware ) ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $Function$ O O $Function$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $number$ O O O $number$ O O O O O O O O O $void$ O $complex$ O $complex$ O $any$ O $complex$ O O O O O O $any$ O O O O O O $Everything$ O O O O O O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O $complex$ O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $void$ O $any$ O $Everything$ O O $complex$ O O $any$ O $any$ O O $any$ O $complex$ O $complex$ O O O O O O O $void$ O O $string$ O O O O O O O $complex$ O $boolean$ O O O O $any$ O $any$ O $any$ O O O O $Everything$ O $Everything$ O O O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O $string$ O $void$ O $any$ O O O O $Everything$ O O O O O O O O $any$ O O O O O O O $void$ O O O O $any$ O $void$ O O $any$ O O O O O O $any$ O O O O O O O $void$ O $undefined$ O O $any$ O $void$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $void$ O O O O $any$ O $void$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $Everything$ O O O $any$ O $any$ O $any$ O O O O $Everything$ O O O $any$ O $any$ O $any$ O O O O $any$ O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O $complex$ O $Everything$ O $BotState$ O $any$ O O O O O O O O O
jest . mock ( "s" , ( ) => { const on = jest . fn ( ) ; return { getDevice : ( ) => ( { on } ) } ; } ) ; const mockConsistency = { value : true } ; jest . mock ( "s" , ( ) => { return { store : { dispatch : jest . fn ( ) , getState ( ) { return { bot : { consistent : mockConsistency . value } } ; } } } ; } ) ; import { getDevice } from "s" ; import { store } from "s" ; import { Actions } from "s" ; import { startTracking , outstandingRequests , stopTracking , cleanUUID } from "s" ; const unprocessedUuid = "s" ; const niceUuid = cleanUUID ( unprocessedUuid ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const 0 = outstandingRequests . all . size ; startTracking ( unprocessedUuid ) ; expect ( store . dispatch ) . toHaveBeenCalledWith ( { type : Actions . SET_CONSISTENCY , payload : false } ) ; expect ( getDevice ( ) . on ) . toHaveBeenCalledWith ( niceUuid , expect . anything ( ) ) ; expect ( outstandingRequests . all . size ) . toBe ( 0 + 0 ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const 0 = outstandingRequests . all . size ; mockConsistency . value = false ; stopTracking ( unprocessedUuid ) ; expect ( store . dispatch ) . toHaveBeenCalledWith ( { type : Actions . SET_CONSISTENCY , payload : true } ) ; expect ( outstandingRequests . all . size ) . toBe ( 0 - 0 ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $complex$ O O O O O O $any$ O O O O O O O O $complex$ O O $boolean$ O O O O $any$ O $any$ O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $complex$ O O O O O $complex$ O O $boolean$ O $complex$ O $boolean$ O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O $NonSense$ O $void$ O $string$ O O O O O O O O O O $string$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $number$ O $NonSense$ O $Set<string>$ O $number$ O $void$ O O O O $any$ O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions.SET_CONSISTENCY$ O $boolean$ O O O O O $any$ O $any$ O O O $any$ O O $any$ O $string$ O $any$ O $any$ O O O O $any$ O $NonSense$ O $Set<string>$ O $number$ O O $any$ O $number$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $number$ O $NonSense$ O $Set<string>$ O $number$ O $complex$ O $boolean$ O O O $void$ O O O O $any$ O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions.SET_CONSISTENCY$ O $boolean$ O O O O O $any$ O $NonSense$ O $Set<string>$ O $number$ O O $any$ O $number$ O O O O O O O O O O
import { fakeDevice } from "s" ; import { deviceIsThrottled } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dev = fakeDevice ( ) ; dev . body . throttled_until = "s" ; dev . body . throttled_at = "s" ; expect ( deviceIsThrottled ( dev . body ) ) . toBeTruthy ( ) ; } ) ; it ( "s" , ( ) => { expect ( deviceIsThrottled ( fakeDevice ( ) . body ) ) . toBeFalsy ( ) ; } ) ; it ( "s" , ( ) => { expect ( deviceIsThrottled ( undefined ) ) . toBeFalsy ( ) ; } ) ; } ) ;	O O $any$ O O O O O O $boolean$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $boolean$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $boolean$ O $any$ O O O $any$ O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $boolean$ O $undefined$ O O O $any$ O O O O O O O O O
jest . mock ( "s" , ( ) => { return { store : { dispatch : jest . fn ( ) , getState : jest . fn ( ( ) : DeepPartial < Everything > => ( { bot : { connectivity : { pings : { "s" : { kind : "s" , start : 0 , end : 0 } } } } } ) ) } } ; } ) ; jest . mock ( "s" , ( ) => ( { handleInbound : jest . fn ( ) } ) ) ; import { dispatchNetworkUp , dispatchNetworkDown , dispatchQosStart , networkUptimeThrottleStats , } from "s" ; import { networkUp , networkDown } from "s" ; import { GetState } from "s" ; import { autoSync , routeMqttData } from "s" ; import { handleInbound } from "s" ; import { store } from "s" ; import { DeepPartial } from "s" ; import { Everything } from "s" ; import { Actions } from "s" ; const NOW = new Date ( ) ; const SHORT_TIME_LATER = new Date ( NOW . getTime ( ) + 0 ) . getTime ( ) ; const LONGER_TIME_LATER = new Date ( NOW . getTime ( ) + 0 ) . getTime ( ) ; const resetStats = ( ) => { networkUptimeThrottleStats [ "s" ] = 0 ; networkUptimeThrottleStats [ "s" ] = 0 ; networkUptimeThrottleStats [ "s" ] = 0 ; } ; describe ( "s" , ( ) => { const NOW_UP = networkUp ( "s" , NOW . getTime ( ) ) ; const LATER_UP = networkUp ( "s" , LONGER_TIME_LATER ) ; it ( "s" , ( ) => { dispatchNetworkUp ( "s" , NOW . getTime ( ) ) ; expect ( store . dispatch ) . toHaveBeenLastCalledWith ( NOW_UP ) ; dispatchNetworkUp ( "s" , SHORT_TIME_LATER ) ; expect ( store . dispatch ) . toHaveBeenLastCalledWith ( NOW_UP ) ; dispatchNetworkUp ( "s" , LONGER_TIME_LATER ) ; expect ( store . dispatch ) . toHaveBeenLastCalledWith ( LATER_UP ) ; } ) ; it ( "s" , ( ) => { dispatchNetworkUp ( "s" , 0 ) ; expect ( store . dispatch ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { const NOW_DOWN = networkDown ( "s" , NOW . getTime ( ) ) ; const LATER_DOWN = networkDown ( "s" , LONGER_TIME_LATER ) ; beforeEach ( resetStats ) ; it ( "s" , ( ) => { dispatchNetworkDown ( "s" , 0 ) ; expect ( store . dispatch ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { dispatchNetworkDown ( "s" , NOW . getTime ( ) ) ; expect ( store . dispatch ) . toHaveBeenLastCalledWith ( NOW_DOWN ) ; dispatchNetworkDown ( "s" , SHORT_TIME_LATER ) ; expect ( store . dispatch ) . toHaveBeenLastCalledWith ( NOW_DOWN ) ; dispatchNetworkDown ( "s" , LONGER_TIME_LATER ) ; expect ( store . dispatch ) . toHaveBeenLastCalledWith ( LATER_DOWN ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const getState = jest . fn ( ) ; const chan = "s" ; const payload = Buffer . from ( [ ] ) ; const rmd = routeMqttData ( chan , payload ) ; autoSync ( dispatch , getState ) ( chan , payload ) ; expect ( handleInbound ) . toHaveBeenCalledWith ( dispatch , getState , rmd ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const id = "s" ; dispatchQosStart ( id ) ; expect ( store . dispatch ) . toHaveBeenCalledWith ( { type : Actions . PING_START , payload : { id } } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $complex$ O O $complex$ O O $complex$ O O O O O $string$ O O O $number$ O O O $number$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $void$ O $void$ O $void$ O $complex$ O O O O O O O $ReduxAction<EdgeStatus>$ O $ReduxAction<EdgeStatus>$ O O O O O O $any$ O O O O O O $void$ O $MqttDataResult<any>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $Date$ O O $DateConstructor$ O O O O $number$ O O $DateConstructor$ O $Date$ O $number$ O O O O O O $number$ O O O O $number$ O O $DateConstructor$ O $Date$ O $number$ O O O O O O $number$ O O O O $void$ O O O O O $complex$ O O O O O O $complex$ O O O O O O $complex$ O O O O O O O O $any$ O O O O O O O O $ReduxAction<EdgeStatus>$ O $ReduxAction<EdgeStatus>$ O O O $Date$ O $number$ O O O O O $ReduxAction<EdgeStatus>$ O $ReduxAction<EdgeStatus>$ O O O $number$ O O $any$ O O O O O O O $void$ O O O $Date$ O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O $ReduxAction<EdgeStatus>$ O O $void$ O O O $number$ O O $any$ O $any$ O $any$ O O $any$ O $ReduxAction<EdgeStatus>$ O O $void$ O O O $number$ O O $any$ O $any$ O $any$ O O $any$ O $ReduxAction<EdgeStatus>$ O O O O O $any$ O O O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O $ReduxAction<EdgeStatus>$ O $ReduxAction<EdgeStatus>$ O O O $Date$ O $number$ O O O O O $ReduxAction<EdgeStatus>$ O $ReduxAction<EdgeStatus>$ O O O $number$ O O $any$ O $void$ O O $any$ O O O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $void$ O O O $Date$ O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O $ReduxAction<EdgeStatus>$ O O $void$ O O O $number$ O O $any$ O $any$ O $any$ O O $any$ O $ReduxAction<EdgeStatus>$ O O $void$ O O O $number$ O O $any$ O $any$ O $any$ O O $any$ O $ReduxAction<EdgeStatus>$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $GetState$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $MqttDataResult<any>$ O $MqttDataResult<any>$ O O O $any$ O O $void$ O $any$ O $GetState$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $GetState$ O $MqttDataResult<any>$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O $void$ O O O O $any$ O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions.PING_START$ O $complex$ O O $string$ O O O O O O O O O O
import { determineStrategy , SyncStrat , maybeNegateStatus , } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( determineStrategy ( { fbosVersion : "s" , autoSync : true } ) ) . toBe ( SyncStrat . AUTO ) ; } ) ; it ( "s" , ( ) => { expect ( determineStrategy ( { fbosVersion : "s" , autoSync : false } ) ) . toBe ( SyncStrat . MANUAL ) ; } ) ; it ( "s" , ( ) => { expect ( determineStrategy ( { autoSync : false } ) ) . toBe ( SyncStrat . OFFLINE ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = maybeNegateStatus ( { consistent : true , syncStatus : "s" , fbosVersion : "s" , autoSync : false , } ) ; expect ( result ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const result = maybeNegateStatus ( { consistent : true , syncStatus : "s" , fbosVersion : "s" , autoSync : true , } ) ; expect ( result ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const result = maybeNegateStatus ( { consistent : false , syncStatus : "s" , fbosVersion : "s" , autoSync : true , } ) ; expect ( result ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const result = maybeNegateStatus ( { consistent : false , syncStatus : "s" , fbosVersion : "s" , autoSync : false , } ) ; expect ( result ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const result = maybeNegateStatus ( { consistent : false , syncStatus : "s" , fbosVersion : undefined , autoSync : false , } ) ; expect ( result ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const result = maybeNegateStatus ( { consistent : false , syncStatus : "s" , fbosVersion : "s" , autoSync : false , } ) ; expect ( result ) . toEqual ( "s" ) ; } ) ; } ) ;	O O $SyncStrat$ O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $SyncStrat$ O O $string$ O O O $true$ O O O O O O $any$ O $any$ O $SyncStrat.AUTO$ O O O O O $any$ O O O O O O O $any$ O $SyncStrat$ O O $string$ O O O $false$ O O O O O O $any$ O $any$ O $SyncStrat.MANUAL$ O O O O O $any$ O O O O O O O $any$ O $SyncStrat$ O O $false$ O O O O O O $any$ O $any$ O $SyncStrat.OFFLINE$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $true$ O O O $string$ O O O $string$ O O O $false$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $true$ O O O $string$ O O O $string$ O O O $true$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $false$ O O O $string$ O O O $string$ O O O $true$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $false$ O O O $string$ O O O $string$ O O O $false$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $false$ O O O $string$ O O O $undefined$ O $undefined$ O $false$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $false$ O O O $string$ O O O $string$ O O O $false$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O O
jest . mock ( "s" , ( ) : Partial < typeof import ( "s" ) > => { return { dispatchNetworkDown : jest . fn ( ) , dispatchNetworkUp : jest . fn ( ) , } ; } ) ; jest . mock ( "s" , ( ) => { return { get : jest . fn ( ( _url ) => { return Promise . reject ( "s" ) ; } ) } ; } ) ; import { dispatchNetworkDown , dispatchNetworkUp } from "s" ; import { pingAPI } from "s" ; import { API } from "s" ; describe ( "s" , ( ) => { beforeAll ( ( ) => { API . setBaseUrl ( "s" ) ; } ) ; it ( "s" , ( done ) => { pingAPI ( ) . then ( ( ) => { expect ( dispatchNetworkDown ) . toHaveBeenCalled ( ) ; expect ( dispatchNetworkUp ) . not . toHaveBeenCalled ( ) ; done ( ) ; } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O O O O O O O O O $void$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $void$ O O O O O O O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O O O $any$ O $void$ O O $any$ O O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O O O O O O O O O O O O
jest . mock ( "s" , ( ) => ( { dispatchNetworkDown : jest . fn ( ) , dispatchNetworkUp : jest . fn ( ) , dispatchQosStart : jest . fn ( ) , pingOK : jest . fn ( ) } ) ) ; const mockTimestamp = 0 ; jest . mock ( "s" , ( ) => ( { timestamp : ( ) => mockTimestamp } ) ) ; import { readPing , startPinging , PING_INTERVAL } from "s" ; import { Farmbot , RpcRequest , RpcRequestBodyItem } from "s" ; import { FarmBotInternalConfig } from "s" ; const state < FarmBotInternalConfig > = { LAST_PING_IN : 0 , LAST_PING_OUT : 0 } ; function fakeBot ( ) { const fb < Farmbot > = { rpcShim : jest . fn ( ( _ : RpcRequestBodyItem [ ] ) : RpcRequest => ( { kind : "s" , args : { label : "s" , priority : 0 } } ) ) , setConfig : jest . fn ( ) , publish : jest . fn ( ) , on : jest . fn ( ) , ping : jest . fn ( ( _timeout , _now ) => Promise . resolve ( 0 ) ) , getConfig : jest . fn ( ( key : keyof FarmBotInternalConfig ) => state [ key ] as never ) , } ; return fb as Farmbot ; } describe ( "s" , ( ) => { it ( "s" , ( ) => { const bot = fakeBot ( ) ; expect ( readPing ( bot , "s" ) ) . toEqual ( 0 ) ; expect ( readPing ( bot , "s" ) ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( done ) => { const bot = fakeBot ( ) ; startPinging ( bot ) ; setTimeout ( ( ) => { expect ( bot . ping ) . toHaveBeenCalled ( ) ; done ( ) ; } , PING_INTERVAL + 0 ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O $number$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $Partial$ O $any$ O O O $number$ O O O $number$ O O O O O $Farmbot$ O O O O $Partial$ O $any$ O O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O O O O $any$ O O O $string$ O O O $complex$ O O $string$ O O O $number$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $number$ O $number$ O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $any$ O $any$ O O $complex$ O O $any$ O O $any$ O $complex$ O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O $number$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O O $any$ O O O O O O O O O O
import { connectivityReducer , DEFAULT_STATE } from "s" ; import { networkUp , networkDown } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = connectivityReducer ( DEFAULT_STATE , networkUp ( "s" ) ) ; expect ( state ) . toEqual ( DEFAULT_STATE ) ; } ) ; it ( "s" , ( ) => { const state = connectivityReducer ( DEFAULT_STATE , networkUp ( "s" ) ) ; expect ( state ) . toBeDefined ( ) ; const x = state && state . uptime [ "s" ] ; if ( x ) { expect ( x . state ) . toBe ( "s" ) ; expect ( x . at ) . toBeTruthy ( ) ; } else { fail ( ) ; } } ) ; it ( "s" , ( ) => { const state = connectivityReducer ( DEFAULT_STATE , networkDown ( "s" ) ) ; const x = state && state . uptime [ "s" ] ; if ( x ) { expect ( x . state ) . toBe ( "s" ) ; expect ( x . at ) . toBeTruthy ( ) ; } else { fail ( ) ; } } ) ; } ) ;	O O $generateReducer<ConnectionState>.GeneratedReducer$ O $ConnectionState$ O O O O O O $ReduxAction<EdgeStatus>$ O $ReduxAction<EdgeStatus>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $ConnectionState$ O $generateReducer<ConnectionState>.GeneratedReducer$ O $ConnectionState$ O $ReduxAction<EdgeStatus>$ O O O O O $any$ O $ConnectionState$ O O $any$ O $ConnectionState$ O O O O O $any$ O O O O O O O O $ConnectionState$ O $generateReducer<ConnectionState>.GeneratedReducer$ O $ConnectionState$ O $ReduxAction<EdgeStatus>$ O O O O O $any$ O $ConnectionState$ O O $any$ O O O O $ConnectionStatus$ O $ConnectionState$ O $ConnectionState$ O $complex$ O O O O O O $ConnectionStatus$ O O $any$ O $ConnectionStatus$ O $NetworkState$ O O $any$ O O O O $any$ O $ConnectionStatus$ O $number$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $ConnectionState$ O $generateReducer<ConnectionState>.GeneratedReducer$ O $ConnectionState$ O $ReduxAction<EdgeStatus>$ O O O O O O $ConnectionStatus$ O $ConnectionState$ O $ConnectionState$ O $complex$ O O O O O O $ConnectionStatus$ O O $any$ O $ConnectionStatus$ O $NetworkState$ O O $any$ O O O O $any$ O $ConnectionStatus$ O $number$ O O $any$ O O O O O O $any$ O O O O O O O O O O
jest . mock ( "s" , ( ) => { return { store : { dispatch : jest . fn ( ) , getState : jest . fn ( ( ) => ( { NO : "s" } ) ) } } ; } ) ; import { connectivityReducer , DEFAULT_STATE } from "s" ; import { Actions } from "s" ; import { pingOK , pingNO } from "s" ; import { store } from "s" ; describe ( "s" , ( ) => { const newState = ( ) => { const action = { type : Actions . PING_START , payload : { id : "s" } } ; return connectivityReducer ( DEFAULT_STATE , action ) ; } ; it ( "s" , ( ) => { const ping = newState ( ) . pings [ "s" ] ; if ( ping ) { expect ( ping . kind ) . toBe ( "s" ) ; } else { fail ( ) ; } } ) ; it ( "s" , ( ) => { const action = { type : Actions . PING_OK , payload : { id : "s" , at : 0 } } ; const state = connectivityReducer ( newState ( ) , action ) ; const { yep } = state . pings ; expect ( yep ) . toBeTruthy ( ) ; if ( yep ) { expect ( yep . kind ) . toEqual ( "s" ) ; } } ) ; it ( "s" , ( ) => { pingOK ( "s" , 0 ) ; expect ( store . dispatch ) . toHaveBeenCalledWith ( { payload : { at : 0 , id : "s" , } , type : "s" , } ) ; } ) ; it ( "s" , ( ) => { pingNO ( "s" , 0 ) ; expect ( store . dispatch ) . toHaveBeenCalledWith ( { payload : { id : "s" , at : 0 } , type : "s" } ) ; } ) ; it ( "s" , ( ) => { const action = { type : Actions . PING_NO , payload : { id : "s" , at : 0 } } ; const state = connectivityReducer ( newState ( ) , action ) ; const { yep } = state . pings ; expect ( yep ) . toBeTruthy ( ) ; if ( yep ) { expect ( yep . kind ) . toEqual ( "s" ) ; } } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O O O O O O O O O O O $generateReducer<ConnectionState>.GeneratedReducer$ O $ConnectionState$ O O O O O O $any$ O O O O O O $void$ O $void$ O O O O O O $any$ O O O O $any$ O O O O O O O O $ConnectionState$ O O O O O O $complex$ O O $Actions$ O $any$ O $Actions.PING_START$ O $complex$ O O $string$ O O O O O O $generateReducer<ConnectionState>.GeneratedReducer$ O $ConnectionState$ O $complex$ O O O O $any$ O O O O O O O O $Ping$ O $ConnectionState$ O O O $complex$ O O O O O O $Ping$ O O $any$ O $Ping$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $Actions$ O $any$ O $Actions.PING_OK$ O $complex$ O O $string$ O O O $number$ O O O O O O $ConnectionState$ O $generateReducer<ConnectionState>.GeneratedReducer$ O $ConnectionState$ O O O $complex$ O O O O $Ping$ O O $ConnectionState$ O $complex$ O $any$ O $Ping$ O O $any$ O O O O O $Ping$ O O $any$ O $Ping$ O O O O $any$ O O O O O O O O $any$ O O O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O $complex$ O O $number$ O O O $string$ O O O O O $string$ O O O O O O O O O $any$ O O O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O $complex$ O O $string$ O O O $number$ O O O O $string$ O O O O O O O O $any$ O O O O O O O O $complex$ O O $Actions$ O $any$ O $Actions.PING_NO$ O $complex$ O O $string$ O O O $number$ O O O O O O $ConnectionState$ O $generateReducer<ConnectionState>.GeneratedReducer$ O $ConnectionState$ O O O $complex$ O O O O $Ping$ O O $ConnectionState$ O $complex$ O $any$ O $Ping$ O O $any$ O O O O O $Ping$ O O $any$ O $Ping$ O O O O $any$ O O O O O O O O O O O
import { ConnectionStatus } from "s" ; export function getStatus ( cs : ConnectionStatus | undefined ) : "s" | "s" { return ( cs && cs . state ) || "s" ; }	O O $any$ O O O O O O $NetworkState$ O $ConnectionStatus$ O $any$ O O O O O O O O O O $ConnectionStatus$ O $ConnectionStatus$ O $NetworkState$ O O O O O
import { getStatus } from "s" ; const NOW_UNIX = ( new Date ( "s" ) ) . getTime ( ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( getStatus ( undefined ) ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( getStatus ( { at : NOW_UNIX , state : "s" } ) ) . toBe ( "s" ) ; } ) ; } ) ;	O O $NetworkState$ O O O O O $number$ O O O $DateConstructor$ O O O O O $number$ O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $NetworkState$ O $undefined$ O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $NetworkState$ O O $number$ O $number$ O O O O O O O O $any$ O O O O O O O O O O
import { mount } from "s" ; import { AxisDisplayGroup } from "s" ; describe ( "s" , ( ) => { const params = { position : { x : undefined , y : undefined , z : undefined } , label : "s" } ; const wrapper = mount ( AxisDisplayGroup ( params ) ) ; it ( "s" , ( ) => { expect ( wrapper . find ( "s" ) . length ) . toEqual ( 0 ) ; expect ( wrapper . find ( "s" ) . length ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { const inputs = wrapper . find ( "s" ) ; const label = wrapper . find ( "s" ) ; expect ( inputs . at ( 0 ) . props ( ) . value ) . toBe ( "s" ) ; expect ( inputs . at ( 0 ) . props ( ) . value ) . toBe ( "s" ) ; expect ( inputs . at ( 0 ) . props ( ) . value ) . toBe ( "s" ) ; expect ( label . text ( ) ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { const props = { position : { x : 0 , y : 0 , z : 0 } , label : "s" } ; props . position = { x : 0 , y : 0 , z : 0 } ; const el = mount ( AxisDisplayGroup ( props ) ) ; const inputs = el . find ( "s" ) ; const label = el . find ( "s" ) ; expect ( inputs . at ( 0 ) . props ( ) . value ) . toBe ( 0 ) ; expect ( inputs . at ( 0 ) . props ( ) . value ) . toBe ( 0 ) ; expect ( inputs . at ( 0 ) . props ( ) . value ) . toBe ( 0 ) ; expect ( label . text ( ) ) . toBe ( "s" ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $complex$ O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O $string$ O O O O O $any$ O $any$ O $any$ O $complex$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O $string$ O O O O $complex$ O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O $any$ O $any$ O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O
import { Everything } from "s" ; import { selectAllPeripherals , selectAllWebcamFeeds , selectAllSensors , maybeGetDevice , selectAllSensorReadings , maybeGetTimeSettings } from "s" ; import { Props } from "s" ; import { validFwConfig , createShouldDisplayFn as shouldDisplayFunc , determineInstalledOsVersion } from "s" ; import { getWebAppConfigValue } from "s" ; import { getFirmwareConfig } from "s" ; import { uniq } from "s" ; import { getStatus } from "s" ; import { DevSettings } from "s" ; export function mapStateToProps ( props ) { const fwConfig = validFwConfig ( getFirmwareConfig ( props . resources . index ) ) ; const { mcu_params } = props . bot . hardware ; const device = maybeGetDevice ( props . resources . index ) ; const installedOsVersion = determineInstalledOsVersion ( props . bot , device ) ; const fbosVersionOverride = DevSettings . overriddenFbosVersion ( ) ; const shouldDisplay = shouldDisplayFunc ( installedOsVersion , props . bot . minOsFeatureData , fbosVersionOverride ) ; return { feeds : selectAllWebcamFeeds ( props . resources . index ) , dispatch : props . dispatch , bot : props . bot , peripherals : uniq ( selectAllPeripherals ( props . resources . index ) ) , sensors : uniq ( selectAllSensors ( props . resources . index ) ) , botToMqttStatus : getStatus ( props . bot . connectivity . uptime [ "s" ] ) , firmwareSettings : fwConfig || mcu_params , getWebAppConfigVal : getWebAppConfigValue ( ( ) => props ) , shouldDisplay , sensorReadings : selectAllSensorReadings ( props . resources . index ) , timeSettings : maybeGetTimeSettings ( props . resources . index ) , } ; }	O O $any$ O O O O O O $any[]$ O $any[]$ O $any[]$ O $any$ O $any[]$ O $TimeSettings$ O O O O O O $any$ O O O O O O $any$ O $boolean$ O $boolean$ O $string$ O O O O O O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $NetworkState$ O O O O O O $any$ O O O O O O $Props$ O $Everything$ O O O $any$ O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O O $any$ O O $Everything$ O $BotState$ O $any$ O O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $string$ O $string$ O $Everything$ O $BotState$ O $any$ O O O $string$ O $any$ O $string$ O O O O $boolean$ O $boolean$ O $string$ O $Everything$ O $BotState$ O $complex$ O $string$ O O O O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $Function$ O $Everything$ O $Function$ O $BotState$ O $Everything$ O $BotState$ O $any$ O $any$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $any$ O $any$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $NetworkState$ O $NetworkState$ O $Everything$ O $BotState$ O $ConnectionState$ O $complex$ O O O O O $any$ O $any$ O $any$ O $complex$ O $complex$ O O O O $Everything$ O O $boolean$ O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $TimeSettings$ O $TimeSettings$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O O
import { mapStateToProps } from "s" ; import { buildResourceIndex } from "s" ; import { fakeUser } from "s" ; import { fakeState } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = fakeState ( ) ; state . resources = buildResourceIndex ( [ fakeUser ( ) ] ) ; const result = mapStateToProps ( state ) ; expect ( result . timeSettings ) . toEqual ( { utcOffset : 0 , 0 : false } ) ; } ) ; } ) ;	O O $Props$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Everything$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O O O $Props$ O $Props$ O $Everything$ O O $any$ O $Props$ O $TimeSettings$ O O $any$ O O $number$ O O O $boolean$ O O O O O O O O O O O
import { BotPosition , BotState } from "s" ; import { McuParams , Xyz } from "s" ; import { NetworkState } from "s" ; import { GetWebAppConfigValue } from "s" ; import { BooleanConfigKey } from "s" ; export type ToggleWebAppBool = ( key ) => ( ) => void ; export type GetWebAppBool = ( key ) => boolean ; export interface MoveProps { dispatch : Function ; bot : BotState ; arduinoBusy : boolean ; botToMqttStatus : NetworkState ; firmwareSettings : McuParams ; getWebAppConfigVal : GetWebAppConfigValue ; } export interface DirectionButtonProps { axis : Xyz ; direction : "s" | "s" | "s" | "s" ; directionAxisProps : { isInverted : boolean ; stopAtHome : boolean ; stopAtMax : boolean ; axisLength : number ; negativeOnly : boolean ; position : number | undefined ; } steps : number ; disabled : boolean | undefined ; } export interface StepSizeSelectorProps { choices : number [ ] ; selected : number ; selector : ( num ) => void ; } export interface DirectionAxesProps { axisInversion : Record < Xyz , boolean > ; botPosition : BotPosition ; firmwareSettings : McuParams ; } interface JogMovementControlsBaseProps extends DirectionAxesProps { stepSize : number ; arduinoBusy : boolean ; xySwap : boolean ; } export interface JogMovementControlsProps extends JogMovementControlsBaseProps { doFindHome : boolean ; } export interface ControlsPopupProps extends JogMovementControlsBaseProps { dispatch : Function ; botOnline : boolean ; }	O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O $BooleanConfigKey$ O O O O O O O O O $any$ O O $BooleanConfigKey$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $BotState$ O $any$ O $boolean$ O O O $NetworkState$ O $any$ O $any$ O $any$ O $GetWebAppConfigValue$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $complex$ O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $number$ O O O $boolean$ O O O $number$ O O O O O O $number$ O O O $boolean$ O O O O O O O O $any$ O $number[]$ O O O O O $number$ O O O $void$ O O $number$ O O O O O O O $any$ O $complex$ O $any$ O $any$ O O O O $complex$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $number$ O O O $boolean$ O O O $boolean$ O O O O O O $any$ O $any$ O $boolean$ O O O O O O $any$ O $any$ O $Function$ O $FunctionConstructor$ O $boolean$ O O O O
import { DirectionAxesProps } from "s" ; import { McuParams } from "s" ; export const calcMicrostepsPerMm = ( steps_per_mm : number | undefined , microsteps_per_step : number | undefined ) => ( steps_per_mm || 0 ) * ( 0 || microsteps_per_step || 0 ) ; const calcAxisLength = ( nr_steps : number | undefined , steps_per_mm : number | undefined , microsteps_per_step : number | undefined ) => { return ( nr_steps || 0 ) / calcMicrostepsPerMm ( steps_per_mm , microsteps_per_step ) ; } ; export function calculateAxialLengths ( props : { firmwareSettings : McuParams } ) { const fwParams = props . firmwareSettings ; return { x : calcAxisLength ( fwParams . movement_axis_nr_steps_x , fwParams . movement_step_per_mm_x , fwParams . movement_microsteps_x ) , y : calcAxisLength ( fwParams . movement_axis_nr_steps_y , fwParams . movement_step_per_mm_y , fwParams . movement_microsteps_y ) , z : calcAxisLength ( fwParams . movement_axis_nr_steps_z , fwParams . movement_step_per_mm_z , fwParams . movement_microsteps_z ) , } ; } export function buildDirectionProps ( props ) { const { firmwareSettings , botPosition } = props ; const lengths = calculateAxialLengths ( props ) ; return { x : { isInverted : props . axisInversion . x , stopAtHome : ! ! firmwareSettings . movement_stop_at_home_x , stopAtMax : ! ! firmwareSettings . movement_stop_at_max_x , axisLength : lengths . x , negativeOnly : ! ! firmwareSettings . movement_home_up_x , position : botPosition . x } , y : { isInverted : props . axisInversion . y , stopAtHome : ! ! firmwareSettings . movement_stop_at_home_y , stopAtMax : ! ! firmwareSettings . movement_stop_at_max_y , axisLength : lengths . y , negativeOnly : ! ! firmwareSettings . movement_home_up_y , position : botPosition . y } , z : { isInverted : props . axisInversion . z , stopAtHome : ! ! firmwareSettings . movement_stop_at_home_z , stopAtMax : ! ! firmwareSettings . movement_stop_at_max_z , axisLength : lengths . z , negativeOnly : ! ! firmwareSettings . movement_home_up_z , position : botPosition . z } , } ; }	O O $any$ O O O O O O $any$ O O O O O O $number$ O O $number$ O O O O O $number$ O O O O O O O $number$ O O O O O O O $number$ O O O O O $number$ O O $number$ O O O O O $number$ O O O O O $number$ O O O O O O O O O $number$ O O O O $number$ O $number$ O $number$ O O O O O O $complex$ O $complex$ O O $any$ O $any$ O O O O $any$ O $complex$ O $any$ O O O $number$ O $number$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $number$ O $number$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $number$ O $number$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O $DirectionAxesProps$ O O O O $any$ O $complex$ O O $DirectionAxesProps$ O O $complex$ O $complex$ O $DirectionAxesProps$ O O O O $complex$ O O $boolean$ O $DirectionAxesProps$ O $complex$ O $any$ O $boolean$ O O O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O $number$ O $complex$ O $number$ O $boolean$ O O O $any$ O $any$ O $number$ O $complex$ O $number$ O O $complex$ O O $boolean$ O $DirectionAxesProps$ O $complex$ O $any$ O $boolean$ O O O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O $number$ O $complex$ O $number$ O $boolean$ O O O $any$ O $any$ O $number$ O $complex$ O $number$ O O $complex$ O O $boolean$ O $DirectionAxesProps$ O $complex$ O $any$ O $boolean$ O O O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O $number$ O $complex$ O $number$ O $boolean$ O O O $any$ O $any$ O $number$ O $complex$ O $number$ O O O O O
import { calcMicrostepsPerMm , calculateAxialLengths } from "s" ; import { fakeFirmwareConfig } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( calcMicrostepsPerMm ( undefined , undefined ) ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { expect ( calcMicrostepsPerMm ( 0 , 0 ) ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { expect ( calcMicrostepsPerMm ( 0 , 0 ) ) . toEqual ( 0 ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const firmwareSettings = fakeFirmwareConfig ( ) . body ; firmwareSettings . movement_axis_nr_steps_x = 0 ; firmwareSettings . movement_step_per_mm_x = 0 ; firmwareSettings . movement_microsteps_x = 0 ; firmwareSettings . movement_axis_nr_steps_y = 0 ; firmwareSettings . movement_step_per_mm_y = 0 ; firmwareSettings . movement_microsteps_y = 0 ; firmwareSettings . movement_axis_nr_steps_z = 0 ; firmwareSettings . movement_step_per_mm_z = 0 ; firmwareSettings . movement_microsteps_z = 0 ; expect ( calculateAxialLengths ( { firmwareSettings } ) ) . toEqual ( { x : 0 , y : 0 , z : 0 } ) ; } ) ; } ) ;	O O $number$ O $complex$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $number$ O $undefined$ O $undefined$ O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $number$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $number$ O O O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $complex$ O O $any$ O O O O $any$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O O O O
import { TaggedSensorReading , TaggedSensor } from "s" ; import { AxisInputBoxGroupState } from "s" ; import { TimeSettings } from "s" ; export interface SensorReadingsProps { sensorReadings : TaggedSensorReading [ ] ; sensors : TaggedSensor [ ] ; timeSettings : TimeSettings ; } export interface SensorReadingsState { sensor : TaggedSensor | undefined ; timePeriod : number ; endDate : number ; location : AxisInputBoxGroupState | undefined ; showPreviousPeriod : boolean ; deviation : number ; hovered : string | undefined ; } export interface SensorReadingsTableProps { readingsForPeriod : ( period : "s" | "s" ) => TaggedSensorReading [ ] ; sensors : TaggedSensor [ ] ; timeSettings : TimeSettings ; hovered : string | undefined ; hover : ( hovered : string | undefined ) => void ; } export interface TableRowProps { sensorReading : TaggedSensorReading ; sensorName : string ; timeSettings : TimeSettings ; period : "s" | "s" ; hovered : string | undefined ; hover : ( hovered : string | undefined ) => void ; } export interface SensorSelectionProps { selectedSensor : TaggedSensor | undefined ; sensors : TaggedSensor [ ] ; setSensor : ( sensor ) => void ; } export interface LocationSelectionProps { location : AxisInputBoxGroupState | undefined ; deviation : number ; setDeviation : ( deviation ) => void ; setLocation : ( location : AxisInputBoxGroupState | undefined ) => void ; } export interface TimePeriodSelectionProps { timePeriod : number ; endDate : number ; showPreviousPeriod : boolean ; setEndDate : ( date ) => void ; setPeriod : ( period ) => void ; togglePrevious : ( event : React . ChangeEvent < HTMLInputElement > ) => void ; } export interface DateDisplayProps { endDate : number ; timeSettings : TimeSettings ; timePeriod : number ; showPreviousPeriod : boolean ; } export interface SensorReadingPlotProps { readingsForPeriod : ( period : "s" | "s" ) => TaggedSensorReading [ ] ; endDate : number ; timeSettings : TimeSettings ; hovered : string | undefined ; hover : ( hovered : string | undefined ) => void ; showPreviousPeriod : boolean ; timePeriod : number ; }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any[]$ O $any$ O O O $any[]$ O $any$ O O O $TimeSettings$ O $any$ O O O O $any$ O $any$ O $any$ O O O $number$ O O O $number$ O O O $AxisInputBoxGroupState$ O $any$ O O O $boolean$ O O O $number$ O O O $string$ O O O O O O O O $any$ O $any[]$ O O O O O O O O O $any$ O O O $any[]$ O $any$ O O O $TimeSettings$ O $any$ O $string$ O O O O O $void$ O O $string$ O O O O O O O O O O O $any$ O $any$ O $any$ O $string$ O O O $TimeSettings$ O $any$ O O O O O O O $string$ O O O O O $void$ O O $string$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O $any[]$ O $any$ O O O $void$ O O $TaggedSensor$ O O O O O O O $any$ O $AxisInputBoxGroupState$ O $any$ O O O $number$ O O O $void$ O O $number$ O O O O $void$ O O $AxisInputBoxGroupState$ O $any$ O O O O O O O O O $any$ O $number$ O O O $number$ O O O $boolean$ O O O $void$ O O $number$ O O O O $void$ O O $number$ O O O O $void$ O O $any$ O $any$ O $any$ O $complex$ O O O O O O O O $any$ O $number$ O O O $TimeSettings$ O $any$ O $number$ O O O $boolean$ O O O O O O $any$ O $any[]$ O O O O O O O O O $any$ O O O $number$ O O O $TimeSettings$ O $any$ O $string$ O O O O O $void$ O O $string$ O O O O O O O O $boolean$ O O O $number$ O O O O
import { TaggedSensorReading } from "s" ; import { SensorReadingsState } from "s" ; import { every , isNumber } from "s" ; import { Xyz } from "s" ; import moment from "s" ; const oneDay = 0 * 0 ; export const calcEndOfPeriod = ( timePeriod , endDate , period : "s" | "s" ) => endDate + oneDay - timePeriod * ( period === "s" ? 0 : 0 ) ; export const filterSensorReadings = ( sensorReadings : TaggedSensorReading [ ] , sensorReadingsState ) => ( period : "s" | "s" ) : TaggedSensorReading [ ] => { const { sensor , endDate , timePeriod , showPreviousPeriod , location , deviation } = sensorReadingsState ; if ( period === "s" && ! showPreviousPeriod ) { return [ ] ; } const end = calcEndOfPeriod ( timePeriod , endDate , period ) ; const begin = end - timePeriod ; return sensorReadings . filter ( x => { const readingCreatedAt = moment ( x . body . created_at ) . unix ( ) ; return ( readingCreatedAt >= begin && readingCreatedAt < end ) ; } ) . filter ( x => sensor ? x . body . pin === sensor . body . pin : true ) . filter ( sensorReading => { if ( location ) { const { body } = sensorReading ; return every ( [ "s" , "s" , "s" ] . map ( ( axis ) => { const a = body [ axis ] ; const input = location [ axis ] ; return isNumber ( a ) && isNumber ( input ) ? ( a <= input + deviation ) && ( a >= input - deviation ) : true ; } ) ) ; } else { return true ; } } ) ; } ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $number$ O O O O O O O $number$ O O $number$ O $number$ O O O O O O O O $number$ O $number$ O $number$ O O O O O O O O O O O O O $any[]$ O O $any[]$ O $any$ O O O $SensorReadingsState$ O O O O O O O O O O $any$ O O O O O O $any$ O $number$ O $number$ O $boolean$ O $AxisInputBoxGroupState$ O $number$ O O $SensorReadingsState$ O O O O O O O O $boolean$ O O O O O O O O $number$ O $number$ O $number$ O $number$ O O O O O $number$ O $number$ O $number$ O O $any[]$ O $complex$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $number$ O $any$ O $number$ O O O O O $complex$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $complex$ O $any$ O O O O $AxisInputBoxGroupState$ O O O O $any$ O O $any$ O O $any$ O O O O O O O O O $U[]$ O O $Xyz$ O O O O $any$ O $any$ O $Xyz$ O O O $number$ O $AxisInputBoxGroupState$ O $Xyz$ O O O $any$ O $any$ O O $any$ O $number$ O O O $any$ O $number$ O $number$ O O O $any$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O
import { fakeSensorReading , fakeSensor } from "s" ; import { filterSensorReadings } from "s" ; import { SensorReadingsState } from "s" ; import moment from "s" ; import { Xyz } from "s" ; describe ( "s" , ( ) => { const createDatedReading = ( timestamps : string [ ] ) => timestamps . map ( timestamp => { const sr = fakeSensorReading ( ) ; sr . body . created_at = timestamp ; return sr ; } ) ; const defaultCreatedAt = "s" ; const createPinnedReading = ( pins : number [ ] ) => pins . map ( pin => { const sr = fakeSensorReading ( ) ; sr . body . pin = pin ; sr . body . created_at = defaultCreatedAt ; return sr ; } ) ; const createLocatedReading = ( locations : Record < Xyz , number | undefined > [ ] ) => locations . map ( location => { const sr = fakeSensorReading ( ) ; sr . body . x = location . x ; sr . body . y = location . y ; sr . body . z = location . z ; sr . body . created_at = defaultCreatedAt ; return sr ; } ) ; const sensorReadingsState = ( ) : SensorReadingsState => ( { sensor : undefined , timePeriod : 0 * 0 * 0 , endDate : 0 , location : undefined , showPreviousPeriod : false , deviation : 0 , hovered : undefined , } ) ; it ( "s" , ( ) => { const expected = "s" ; const timestamps = [ expected , "s" ] ; const filters = sensorReadingsState ( ) ; filters . endDate = moment ( expected ) . unix ( ) + 0 ; const result = filterSensorReadings ( createDatedReading ( timestamps ) , filters ) ( "s" ) ; expect ( result . length ) . toEqual ( 0 ) ; expect ( result [ 0 ] . body . created_at ) . toEqual ( expected ) ; } ) ; it ( "s" , ( ) => { const expected = "s" ; const weekAhead = "s" ; const timestamps = [ expected , weekAhead ] ; const filters = sensorReadingsState ( ) ; filters . endDate = moment ( weekAhead ) . unix ( ) - 0 ; filters . showPreviousPeriod = true ; const result = filterSensorReadings ( createDatedReading ( timestamps ) , filters ) ( "s" ) ; expect ( result . length ) . toEqual ( 0 ) ; expect ( result [ 0 ] . body . created_at ) . toEqual ( expected ) ; } ) ; it ( "s" , ( ) => { const expected = 0 ; const sensor = fakeSensor ( ) ; sensor . body . pin = expected ; const pins = [ expected , 0 ] ; const filters = sensorReadingsState ( ) ; filters . endDate = moment ( defaultCreatedAt ) . unix ( ) + 0 ; filters . sensor = sensor ; const result = filterSensorReadings ( createPinnedReading ( pins ) , filters ) ( "s" ) ; expect ( result . length ) . toEqual ( 0 ) ; expect ( result [ 0 ] . body . pin ) . toEqual ( expected ) ; } ) ; it ( "s" , ( ) => { const expected = { x : 0 , y : 0 , z : 0 } ; const locations = [ expected , { x : 0 , y : 0 , z : 0 } ] ; const filters = sensorReadingsState ( ) ; filters . endDate = moment ( defaultCreatedAt ) . unix ( ) + 0 ; filters . location = expected ; const result = filterSensorReadings ( createLocatedReading ( locations ) , filters ) ( "s" ) ; expect ( result . length ) . toEqual ( 0 ) ; expect ( result [ 0 ] . body . x ) . toEqual ( expected . x ) ; expect ( result [ 0 ] . body . y ) . toEqual ( expected . y ) ; expect ( result [ 0 ] . body . z ) . toEqual ( expected . z ) ; } ) ; it ( "s" , ( ) => { const expected = { x : 0 , y : 0 , z : undefined } ; const locations = [ { x : 0 , y : 0 , z : 0 } , { x : 0 , y : 0 , z : 0 } ] ; const filters = sensorReadingsState ( ) ; filters . endDate = moment ( defaultCreatedAt ) . unix ( ) + 0 ; filters . location = expected ; filters . deviation = 0 ; const result = filterSensorReadings ( createLocatedReading ( locations ) , filters ) ( "s" ) ; expect ( result . length ) . toEqual ( 0 ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any[]$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O O O O $any[]$ O O $string[]$ O O O O O O $string[]$ O $U[]$ O $string$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O $any$ O O O O O O O O O O $any[]$ O O $number[]$ O O O O O O $number[]$ O $U[]$ O $number$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $number$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any[]$ O O $complex$ O $any$ O $any$ O O O O O O O O O $complex$ O $U[]$ O $complex$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $complex$ O $number$ O $any$ O $any$ O $any$ O $complex$ O $number$ O $any$ O $any$ O $any$ O $complex$ O $number$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $SensorReadingsState$ O O O O $any$ O O O $undefined$ O $undefined$ O $number$ O O O O O O O $number$ O O O $undefined$ O $undefined$ O $false$ O O O $number$ O O O $undefined$ O $undefined$ O O O O $any$ O O O O O O O O O O O O O $string[]$ O O O O O O O O $SensorReadingsState$ O $SensorReadingsState$ O O O $SensorReadingsState$ O $number$ O $any$ O O O O $any$ O O O O O O $any[]$ O $any[]$ O $any[]$ O $string[]$ O O $SensorReadingsState$ O O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O $string[]$ O O O O O O O O $SensorReadingsState$ O $SensorReadingsState$ O O O $SensorReadingsState$ O $number$ O $any$ O O O O $any$ O O O O O $SensorReadingsState$ O $boolean$ O O O O $any[]$ O $any[]$ O $any[]$ O $string[]$ O O $SensorReadingsState$ O O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $number[]$ O O O O O O O O $SensorReadingsState$ O $SensorReadingsState$ O O O $SensorReadingsState$ O $number$ O $any$ O O O O $any$ O O O O O $SensorReadingsState$ O $any$ O $any$ O O $any[]$ O $any[]$ O $any[]$ O $number[]$ O O $SensorReadingsState$ O O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O $complex$ O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O $SensorReadingsState$ O $SensorReadingsState$ O O O $SensorReadingsState$ O $number$ O $any$ O O O O $any$ O O O O O $SensorReadingsState$ O $AxisInputBoxGroupState$ O $complex$ O O $any[]$ O $any[]$ O $any[]$ O $complex$ O O $SensorReadingsState$ O O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O $complex$ O $number$ O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O $complex$ O $number$ O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O $complex$ O $number$ O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O $undefined$ O $undefined$ O O O $complex$ O O O $number$ O O O $number$ O O O $number$ O O O O O $number$ O O O $number$ O O O $number$ O O O O O O $SensorReadingsState$ O $SensorReadingsState$ O O O $SensorReadingsState$ O $number$ O $any$ O O O O $any$ O O O O O $SensorReadingsState$ O $AxisInputBoxGroupState$ O $complex$ O $SensorReadingsState$ O $number$ O O O O $any[]$ O $any[]$ O $any[]$ O $complex$ O O $SensorReadingsState$ O O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O O O O O O O
export class Flipper < T > { private go = ( n ) => ( cb : ( next : T | undefined , index ) => void ) => { this . inc ( n ) ; cb ( this . current , this . index ) ; } private inc = ( num ) => { const i = this . index ; const maxIndex = this . list . length - 0 ; const newIndex = i + num ; if ( newIndex < 0 ) { this . index = maxIndex ; } else if ( newIndex > maxIndex ) { this . index = 0 ; } else { this . index = newIndex ; } return this . index ; } get current ( ) : T { return this . list [ this . index ] || this . fallback ; } constructor ( public list : T [ ] , public fallback : T , private index , ) { } up = this . go ( 0 ) ; down = this . go ( - 0 ) ; }	O O $any$ O $any$ O O O $void$ O O $number$ O O O $void$ O O $T$ O $any$ O O O $number$ O O O O O O O O $number$ O $number$ O O $void$ O O O $T$ O O O $number$ O O O O $number$ O O $number$ O O O O $number$ O O O $number$ O O $number$ O O O $T[]$ O $number$ O O O O $number$ O $number$ O $number$ O O O $number$ O O O O O O $number$ O $number$ O O O O O $number$ O $number$ O O O O $number$ O O O O O O O O $number$ O $number$ O O O O O $number$ O O O $T$ O O O $any$ O O O O $T[]$ O O O $number$ O O O O $T$ O O O O O $T[]$ O $any$ O O O O $T$ O $any$ O O $number$ O O O O $void$ O O O $void$ O O O O $void$ O O O $void$ O O O O O O
import { Flipper } from "s" ; import { times , noop } from "s" ; describe ( "s" , ( ) => { type Item = { value : number } ; const items = ( ) : Item [ ] => { return [ { value : 0 } , { value : 0 } , { value : 0 } , ] ; } ; it ( "s" , ( ) => { const f = new Flipper < Item > ( items ( ) , { value : - 0 } , 0 ) ; expect ( f . current . value ) . toBe ( 0 ) ; f . up ( ( item , index ) => { expect ( index ) . toBe ( 0 ) ; expect ( item && item . value ) . toBe ( 0 ) ; } ) ; times ( 0 , ( ) => f . up ( noop ) ) ; f . up ( ( item , index ) => { expect ( index ) . toBe ( 0 ) ; expect ( item && item . value ) . toBe ( 0 ) ; } ) ; } ) ; it ( "s" , ( ) => { const f = new Flipper < Item > ( items ( ) , { value : - 0 } , 0 ) ; f . up ( ( item , index ) => { expect ( index ) . toBe ( 0 ) ; expect ( item && item . value ) . toBe ( 0 ) ; } ) ; } ) ; it ( "s" , ( ) => { const f = new Flipper < Item > ( [ ] , { value : - 0 } , 0 ) ; f . up ( ( item , index ) => { expect ( index ) . toBe ( 0 ) ; expect ( item && item . value ) . toBe ( - 0 ) ; } ) ; } ) ; it ( "s" , ( ) => { const f = new Flipper < Item > ( items ( ) , { value : - 0 } , 0 ) ; expect ( f . current . value ) . toBe ( 0 ) ; f . down ( ( item , index ) => { expect ( index ) . toBe ( 0 ) ; expect ( item && item . value ) . toBe ( 0 ) ; } ) ; } ) ; it ( "s" , ( ) => { const f = new Flipper < Item > ( items ( ) , { value : - 0 } , 0 ) ; f . down ( ( item , index ) => { expect ( index ) . toBe ( 0 ) ; expect ( item && item . value ) . toBe ( 0 ) ; } ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any$ O O $number$ O O O O O $Item[]$ O O O O $any$ O O O O O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O O O O $any$ O O O O O O O O $Flipper<Item>$ O O $any$ O $any$ O O $Item[]$ O O O O $number$ O O O O O O O O $any$ O $Flipper<Item>$ O $Item$ O $number$ O O $any$ O O O O $Flipper<Item>$ O $void$ O O $Item$ O $number$ O O O $any$ O $number$ O O $any$ O O O O $any$ O $Item$ O $Item$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O $Flipper<Item>$ O $void$ O $any$ O O O $Flipper<Item>$ O $void$ O O $Item$ O $number$ O O O $any$ O $number$ O O $any$ O O O O $any$ O $Item$ O $Item$ O $number$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $Flipper<Item>$ O O $any$ O $any$ O O $Item[]$ O O O O $number$ O O O O O O O O $Flipper<Item>$ O $void$ O O $Item$ O $number$ O O O $any$ O $number$ O O $any$ O O O O $any$ O $Item$ O $Item$ O $number$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $Flipper<Item>$ O O $any$ O $any$ O O O O O O $number$ O O O O O O O O $Flipper<Item>$ O $void$ O O $Item$ O $number$ O O O $any$ O $number$ O O $any$ O O O O $any$ O $Item$ O $Item$ O $number$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $Flipper<Item>$ O O $any$ O $any$ O O $Item[]$ O O O O $number$ O O O O O O O O $any$ O $Flipper<Item>$ O $Item$ O $number$ O O $any$ O O O O $Flipper<Item>$ O $void$ O O $Item$ O $number$ O O O $any$ O $number$ O O $any$ O O O O $any$ O $Item$ O $Item$ O $number$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $Flipper<Item>$ O O $any$ O $any$ O O $Item[]$ O O O O $number$ O O O O O O O O $Flipper<Item>$ O $void$ O O $Item$ O $number$ O O O $any$ O $number$ O O $any$ O O O O $any$ O $Item$ O $Item$ O $number$ O O $any$ O O O O O O O O O O O O O
const mockDeviceDefault < Farmbot > = { checkUpdates : jest . fn ( ( ) => Promise . resolve ( ) ) , powerOff : jest . fn ( ( ) => Promise . resolve ( ) ) , resetOS : jest . fn ( ) , reboot : jest . fn ( ( ) => Promise . resolve ( ) ) , rebootFirmware : jest . fn ( ( ) => Promise . resolve ( ) ) , flashFirmware : jest . fn ( ( ) => Promise . resolve ( ) ) , emergencyLock : jest . fn ( ( ) => Promise . resolve ( ) ) , emergencyUnlock : jest . fn ( ( ) => Promise . resolve ( ) ) , execSequence : jest . fn ( ( ) => Promise . resolve ( ) ) , resetMCU : jest . fn ( ( ) => Promise . resolve ( ) ) , togglePin : jest . fn ( ( ) => Promise . resolve ( ) ) , readPin : jest . fn ( ( ) => Promise . resolve ( ) ) , home : jest . fn ( ( ) => Promise . resolve ( ) ) , sync : jest . fn ( ( ) => Promise . resolve ( ) ) , readStatus : jest . fn ( ( ) => Promise . resolve ( ) ) , dumpInfo : jest . fn ( ( ) => Promise . resolve ( ) ) , } ; const mockDevice = { current : mockDeviceDefault } ; jest . mock ( "s" , ( ) => ( { getDevice : ( ) => mockDevice . current } ) ) ; jest . mock ( "s" , ( ) => ( { edit : jest . fn ( ) , save : jest . fn ( ) , } ) ) ; let mockGetRelease < { } > = Promise . resolve ( { } ) ; jest . mock ( "s" , ( ) => ( { get : jest . fn ( ( ) => mockGetRelease ) } ) ) ; import * as actions from "s" ; import { fakeFirmwareConfig , fakeFbosConfig } from "s" ; import { fakeState } from "s" ; import { changeStepSize , commandErr } from "s" ; import { Actions } from "s" ; import { buildResourceIndex } from "s" ; import axios from "s" ; import { success , error , warning , info } from "s" ; import { edit , save } from "s" ; import { DeepPartial } from "s" ; import { Farmbot } from "s" ; const replaceDeviceWith = async ( d < Farmbot > , cb ) => { jest . clearAllMocks ( ) ; mockDevice . current = { ... mockDeviceDefault , ... d } ; await cb ( ) ; mockDevice . current = mockDeviceDefault ; } ; describe ( "s" , function ( ) { it ( "s" , async ( ) => { await actions . checkControllerUpdates ( ) ; expect ( mockDevice . current . checkUpdates ) . toHaveBeenCalled ( ) ; expect ( success ) . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , async ( ) => { await actions . powerOff ( ) ; expect ( mockDevice . current . powerOff ) . toHaveBeenCalled ( ) ; expect ( success ) . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { window . confirm = ( ) => false ; await actions . factoryReset ( ) ; expect ( mockDevice . current . resetOS ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , async ( ) => { window . confirm = ( ) => true ; await actions . factoryReset ( ) ; expect ( mockDevice . current . resetOS ) . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , async ( ) => { await actions . reboot ( ) ; expect ( mockDevice . current . reboot ) . toHaveBeenCalled ( ) ; expect ( success ) . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , async ( ) => { await actions . restartFirmware ( ) ; expect ( mockDevice . current . rebootFirmware ) . toHaveBeenCalled ( ) ; expect ( success ) . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , async ( ) => { await actions . flashFirmware ( "s" ) ; expect ( mockDevice . current . flashFirmware ) . toHaveBeenCalled ( ) ; expect ( success ) . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , ( ) => { actions . emergencyLock ( ) ; expect ( mockDevice . current . emergencyLock ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { window . confirm = ( ) => true ; actions . emergencyUnlock ( ) ; expect ( mockDevice . current . emergencyUnlock ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { window . confirm = ( ) => false ; actions . emergencyUnlock ( ) ; expect ( mockDevice . current . emergencyUnlock ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , ( ) => { const state = fakeState ( ) ; state . bot . hardware . informational_settings . controller_version = "s" ; actions . sync ( ) ( jest . fn ( ) , ( ) => state ) ; expect ( mockDevice . current . sync ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; state . bot . hardware . informational_settings . controller_version = "s" ; actions . sync ( ) ( jest . fn ( ) , ( ) => state ) ; expect ( mockDevice . current . sync ) . not . toHaveBeenCalled ( ) ; expect ( info ) . toBeCalledWith ( expect . stringContaining ( "s" ) , expect . stringContaining ( "s" ) , "s" ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; state . bot . hardware . informational_settings . controller_version = undefined ; actions . sync ( ) ( jest . fn ( ) , ( ) => state ) ; expect ( mockDevice . current . sync ) . not . toHaveBeenCalled ( ) ; const expectedMessage = [ "s" , "s" , "s" ] ; expect ( info ) . toBeCalledWith ( ... expectedMessage ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , ( ) => { const errorThrower < Farmbot > = { execSequence : jest . fn ( ( ) => Promise . reject ( new Error ( "s" ) ) ) } ; replaceDeviceWith ( errorThrower , async ( ) => { await actions . execSequence ( 0 , [ ] ) ; expect ( mockDevice . current . execSequence ) . toHaveBeenCalledWith ( 0 , [ ] ) ; expect ( error ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ; it ( "s" , async ( ) => { const errorThrower < Farmbot > = { execSequence : jest . fn ( ( ) => Promise . reject ( "s" ) ) } ; await replaceDeviceWith ( errorThrower , async ( ) => { await actions . execSequence ( 0 , [ ] ) ; expect ( mockDevice . current . execSequence ) . toHaveBeenCalledWith ( 0 , [ ] ) ; expect ( error ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ; it ( "s" , async ( ) => { await actions . execSequence ( 0 ) ; expect ( mockDevice . current . execSequence ) . toHaveBeenCalledWith ( 0 , undefined ) ; expect ( success ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , async ( ) => { await actions . execSequence ( 0 , [ ] ) ; expect ( mockDevice . current . execSequence ) . toHaveBeenCalledWith ( 0 , [ ] ) ; expect ( success ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { expect ( ( ) => actions . execSequence ( undefined ) ) . toThrow ( ) ; expect ( mockDevice . current . execSequence ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , ( ) => { window . confirm = ( ) => false ; actions . MCUFactoryReset ( ) ; expect ( mockDevice . current . resetMCU ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { window . confirm = ( ) => true ; actions . MCUFactoryReset ( ) ; expect ( mockDevice . current . resetMCU ) . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { actions . requestDiagnostic ( ) ; expect ( mockDevice . current . dumpInfo ) . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const sourceSetting = ( ) => ( { value : 0 , consistent : true } ) ; const state = fakeState ( ) ; const fakeConfig = fakeFirmwareConfig ( ) ; state . resources = buildResourceIndex ( [ fakeConfig ] ) ; actions . settingToggle ( "s" , sourceSetting ) ( jest . fn ( ) , ( ) => state ) ; expect ( edit ) . toHaveBeenCalledWith ( fakeConfig , { param_mov_nr_retry : 0 } ) ; expect ( save ) . toHaveBeenCalledWith ( fakeConfig . uuid ) ; } ) ; it ( "s" , ( ) => { window . alert = jest . fn ( ) ; const msg = "s" ; actions . settingToggle ( "s" , jest . fn ( ( ) => ( { value : 0 , consistent : true } ) ) , msg ) ( jest . fn ( ) , fakeState ) ; expect ( window . alert ) . toHaveBeenCalledWith ( msg ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = fakeState ( ) ; const fakeConfig = fakeFirmwareConfig ( ) ; state . resources = buildResourceIndex ( [ fakeConfig ] ) ; actions . updateMCU ( "s" , "s" ) ( jest . fn ( ) , ( ) => state ) ; expect ( edit ) . toHaveBeenCalledWith ( fakeConfig , { param_mov_nr_retry : "s" } ) ; expect ( save ) . toHaveBeenCalledWith ( fakeConfig . uuid ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; const fakeConfig = fakeFirmwareConfig ( ) ; fakeConfig . body . movement_max_spd_x = 0 ; state . resources = buildResourceIndex ( [ fakeConfig ] ) ; actions . updateMCU ( "s" , "s" ) ( jest . fn ( ) , ( ) => state ) ; expect ( warning ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , async ( ) => { await actions . pinToggle ( 0 ) ; expect ( mockDevice . current . togglePin ) . toHaveBeenCalledWith ( { pin_number : 0 } ) ; expect ( success ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , async ( ) => { await actions . readPin ( 0 , "s" , 0 ) ; expect ( mockDevice . current . readPin ) . toHaveBeenCalledWith ( { pin_number : 0 , label : "s" , pin_mode : 0 , } ) ; expect ( success ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , async ( ) => { await actions . homeAll ( 0 ) ; expect ( mockDevice . current . home ) . toHaveBeenCalledWith ( { axis : "s" , speed : 0 } ) ; expect ( success ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , ( ) => { expect ( actions . isLog ( { } ) ) . toBe ( false ) ; expect ( actions . isLog ( { message : "s" } ) ) . toBe ( true ) ; } ) ; it ( "s" , ( ) => { const log = { message : "s" } ; console . error = jest . fn ( ) ; const result = actions . isLog ( log ) ; expect ( result ) . toBe ( false ) ; expect ( console . error ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { commandErr ( ) ( ) ; expect ( error ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ; describe ( "s" , function ( ) { it ( "s" , ( ) => { const action = actions . toggleControlPanel ( "s" ) ; expect ( action . payload ) . toEqual ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const payload = 0 ; const result = changeStepSize ( payload ) ; expect ( result . type ) . toBe ( Actions . CHANGE_STEP_SIZE ) ; expect ( result . payload ) . toBe ( payload ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { mockGetRelease = Promise . resolve ( { data : { tag_name : "s" } } ) ; const dispatch = jest . fn ( ) ; await actions . fetchReleases ( "s" ) ( dispatch ) ; expect ( axios . get ) . toHaveBeenCalledWith ( "s" ) ; expect ( error ) . not . toHaveBeenCalled ( ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : { version : "s" , commit : undefined } , type : Actions . FETCH_OS_UPDATE_INFO_OK } ) ; } ) ; it ( "s" , async ( ) => { mockGetRelease = Promise . resolve ( { data : { tag_name : "s" , target_commitish : "s" } } ) ; const dispatch = jest . fn ( ) ; await actions . fetchReleases ( "s" , { beta : true } ) ( dispatch ) ; expect ( axios . get ) . toHaveBeenCalledWith ( "s" ) ; expect ( error ) . not . toHaveBeenCalled ( ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : { version : "s" , commit : "s" } , type : Actions . FETCH_BETA_OS_UPDATE_INFO_OK } ) ; } ) ; it ( "s" , async ( ) => { mockGetRelease = Promise . reject ( "s" ) ; const dispatch = jest . fn ( ) ; await actions . fetchReleases ( "s" ) ( dispatch ) ; await expect ( axios . get ) . toHaveBeenCalledWith ( "s" ) ; expect ( error ) . toHaveBeenCalledWith ( "s" ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : "s" , type : Actions . FETCH_OS_UPDATE_INFO_ERROR } ) ; } ) ; it ( "s" , async ( ) => { mockGetRelease = Promise . reject ( "s" ) ; const dispatch = jest . fn ( ) ; await actions . fetchReleases ( "s" , { beta : true } ) ( dispatch ) ; await expect ( axios . get ) . toHaveBeenCalledWith ( "s" ) ; expect ( error ) . not . toHaveBeenCalled ( ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : "s" , type : Actions . FETCH_BETA_OS_UPDATE_INFO_ERROR } ) ; } ) ; } ) ; describe ( "s" , ( ) => { const testFetchBeta = ( tag_name , version ) => it ( `template` , async ( ) => { mockGetRelease = Promise . resolve ( { data : [ { tag_name } ] } ) ; const dispatch = jest . fn ( ) ; await actions . fetchLatestGHBetaRelease ( "s" ) ( dispatch ) ; expect ( axios . get ) . toHaveBeenCalledWith ( "s" ) ; expect ( error ) . not . toHaveBeenCalled ( ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : { version , commit : undefined } , type : Actions . FETCH_BETA_OS_UPDATE_INFO_OK } ) ; } ) ; testFetchBeta ( "s" , "s" ) ; testFetchBeta ( "s" , "s" ) ; it ( "s" , async ( ) => { mockGetRelease = Promise . reject ( "s" ) ; const dispatch = jest . fn ( ) ; await actions . fetchLatestGHBetaRelease ( "s" ) ( dispatch ) ; await expect ( axios . get ) . toHaveBeenCalledWith ( "s" ) ; expect ( error ) . not . toHaveBeenCalled ( ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : "s" , type : Actions . FETCH_BETA_OS_UPDATE_INFO_ERROR } ) ; } ) ; } ) ; describe ( "s" , ( ) => { afterEach ( ( ) => jest . restoreAllMocks ( ) ) ; it ( "s" , async ( ) => { mockGetRelease = Promise . resolve ( { data : { } } ) ; const dispatch = jest . fn ( ) ; await actions . fetchMinOsFeatureData ( "s" ) ( dispatch ) ; expect ( axios . get ) . toHaveBeenCalledWith ( "s" ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : { } , type : Actions . FETCH_MIN_OS_FEATURE_INFO_OK } ) ; } ) ; it ( "s" , async ( ) => { mockGetRelease = Promise . resolve ( { data : { "s" : "s" , "s" : "s" } } ) ; const dispatch = jest . fn ( ) ; await actions . fetchMinOsFeatureData ( "s" ) ( dispatch ) ; expect ( axios . get ) . toHaveBeenCalledWith ( "s" ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : { a_feature : "s" , b_feature : "s" } , type : Actions . FETCH_MIN_OS_FEATURE_INFO_OK } ) ; } ) ; it ( "s" , async ( ) => { mockGetRelease = Promise . resolve ( { data : "s" } ) ; const dispatch = jest . fn ( ) ; const mockConsole = jest . spyOn ( console , "s" ) . mockImplementation ( ( ) => { } ) ; await actions . fetchMinOsFeatureData ( "s" ) ( dispatch ) ; expect ( axios . get ) . toHaveBeenCalledWith ( "s" ) ; expect ( dispatch ) . not . toHaveBeenCalled ( ) ; expect ( mockConsole ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { mockGetRelease = Promise . resolve ( { data : { a : "s" , b : 0 } } ) ; const dispatch = jest . fn ( ) ; const mockConsole = jest . spyOn ( console , "s" ) . mockImplementation ( ( ) => { } ) ; await actions . fetchMinOsFeatureData ( "s" ) ( dispatch ) ; expect ( axios . get ) . toHaveBeenCalledWith ( "s" ) ; expect ( dispatch ) . not . toHaveBeenCalled ( ) ; expect ( mockConsole ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { mockGetRelease = Promise . reject ( "s" ) ; const dispatch = jest . fn ( ) ; await actions . fetchMinOsFeatureData ( "s" ) ( dispatch ) ; await expect ( axios . get ) . toHaveBeenCalledWith ( "s" ) ; expect ( error ) . not . toHaveBeenCalled ( ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : "s" , type : Actions . FETCH_MIN_OS_FEATURE_INFO_ERROR } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = fakeState ( ) ; const fakeConfig = fakeFbosConfig ( ) ; state . resources = buildResourceIndex ( [ fakeConfig ] ) ; actions . updateConfig ( { auto_sync : true } ) ( jest . fn ( ) , ( ) => state ) ; expect ( edit ) . toHaveBeenCalledWith ( fakeConfig , { auto_sync : true } ) ; expect ( save ) . toHaveBeenCalledWith ( fakeConfig . uuid ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { actions . badVersion ( ) ; expect ( info ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) , "s" , "s" ) ; } ) ; } ) ;	O $DeepPartial$ O $any$ O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O $complex$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O $any$ O O O O $complex$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $Promise$ O O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Promise<{}>$ O O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $Everything$ O O O O O O $complex$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $void$ O $void$ O $void$ O $void$ O O O O O O $ReduxAction<EditResourceParams>$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $Promise<void>$ O O O $DeepPartial$ O $any$ O O $Function$ O O O $any$ O $any$ O O O $complex$ O $any$ O O O $any$ O O $any$ O O O $Function$ O O O $complex$ O $any$ O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $void$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O $any$ O $void$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $void$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O $any$ O $void$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $boolean)$ O O O O O O O $any$ O $void$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $complex$ O $boolean)$ O O O O O O O $any$ O $void$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $void$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O $any$ O $void$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $void$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O $any$ O $void$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $void$ O O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O $any$ O $void$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $void$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O $complex$ O $boolean)$ O O O O O O $any$ O $void$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O $complex$ O $boolean)$ O O O O O O $any$ O $void$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O O O $any$ O $Thunk$ O O O $any$ O $any$ O O O O O O $Everything$ O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O O O $any$ O $Thunk$ O O O $any$ O $any$ O O O O O O $Everything$ O O $any$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $void$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O $undefined$ O $any$ O $Thunk$ O O O $any$ O $any$ O O O O O O $Everything$ O O $any$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O $string[]$ O O O O O O O O O $any$ O $void$ O O $any$ O O $string[]$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $DeepPartial$ O $any$ O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $Promise<T>$ O O $ErrorConstructor$ O O O O O O O $Promise<void>$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O O $DeepPartial$ O $any$ O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O O O $Promise<void>$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O $undefined$ O O $any$ O $void$ O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O $void$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O $undefined$ O O O $any$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $complex$ O $boolean)$ O O O O O O $any$ O $any$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $complex$ O $boolean)$ O O O O O O $any$ O $any$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O O O O O $number$ O O O $boolean$ O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O $any$ O $void$ O O O $complex$ O O $any$ O $any$ O O O O O O $Everything$ O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O O $number$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $complex$ O $void)$ O $any$ O $any$ O O O O O O O O $any$ O $void$ O O O $any$ O $any$ O O O O O O $number$ O O O $boolean$ O O O O O O O O O $any$ O $any$ O O O $Everything$ O O $any$ O $complex$ O $void)$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O $any$ O $void$ O O O O O O $any$ O $any$ O O O O O O $Everything$ O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O O $string$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O $any$ O $void$ O O O O O O $any$ O $any$ O O O O O O $Everything$ O O $any$ O $void$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O $number$ O O O O O $any$ O $void$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O $number$ O O O $string$ O O O $number$ O O O O O O $any$ O $void$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $void$ O O O O $any$ O $complex$ O $any$ O $any$ O O $any$ O O $string$ O O O $number$ O O O O O $any$ O $void$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $complex$ O O O O O O $any$ O O O O $any$ O $any$ O $complex$ O O $string$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O $Console$ O $void$ O $any$ O $any$ O O O O $boolean$ O $any$ O $complex$ O $complex$ O O $any$ O $boolean$ O O $any$ O O O O $any$ O $Console$ O $void$ O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $void$ O O O O O $any$ O $void$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $any$ O O O O O O $any$ O $complex$ O O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $complex$ O $complex$ O O O O $any$ O $complex$ O $Actions$ O O $any$ O $any$ O $Actions.CHANGE_STEP_SIZE$ O O $any$ O $complex$ O $number$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $complex$ O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $complex$ O O $string$ O O O $undefined$ O $undefined$ O O $Actions$ O $any$ O $Actions.FETCH_OS_UPDATE_INFO_OK$ O O O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O O O $true$ O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $complex$ O O $string$ O O O $string$ O O O O $Actions$ O $any$ O $Actions.FETCH_BETA_OS_UPDATE_INFO_OK$ O O O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $Promise<T>$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $void$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $string$ O O O $Actions$ O $any$ O $Actions.FETCH_OS_UPDATE_INFO_ERROR$ O O O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $Promise<T>$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O O O $true$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $string$ O O O $Actions$ O $any$ O $Actions.FETCH_BETA_OS_UPDATE_INFO_ERROR$ O O O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O $string$ O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $complex$ O O $complex$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $complex$ O O $string$ O $undefined$ O $undefined$ O O $Actions$ O $any$ O $Actions.FETCH_BETA_OS_UPDATE_INFO_OK$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $Promise<T>$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $string$ O O O $Actions$ O $any$ O $Actions.FETCH_BETA_OS_UPDATE_INFO_ERROR$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $complex$ O O ${}$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O ${}$ O O O O $Actions$ O $any$ O $Actions.FETCH_MIN_OS_FEATURE_INFO_OK$ O O O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $complex$ O O $complex$ O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $complex$ O O $string$ O O O $string$ O O O O $Actions$ O $any$ O $Actions.FETCH_MIN_OS_FEATURE_INFO_OK$ O O O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $complex$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $Console$ O O O O $any$ O O O O O O O O O $any$ O $void$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $complex$ O O $complex$ O O $string$ O O O $number$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $Console$ O O O O $any$ O O O O O O O O O $any$ O $void$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $Promise<{}>$ O $PromiseConstructor$ O $Promise<T>$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $void$ O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $string$ O O O $Actions$ O $any$ O $Actions.FETCH_MIN_OS_FEATURE_INFO_ERROR$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O $any$ O $void$ O O $boolean$ O O O O O $any$ O $any$ O O O O O O $Everything$ O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O O $boolean$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $void$ O O O $any$ O $void$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O
import { botReducer , initialState } from "s" ; import { Actions } from "s" ; import { ControlPanelState , BotState } from "s" ; import { defensiveClone } from "s" ; import { stash } from "s" ; import { incomingStatus } from "s" ; import { 0 , uuid } from "s" ; import { values , omit } from "s" ; import { now } from "s" ; const statusOf = ( state ) => { return state . hardware . informational_settings . sync_status ; } ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const 0 = botReducer ( initialState ( ) , { type : Actions . SETTING_UPDATE_START , payload : undefined } ) ; expect ( 0 . isUpdating ) . toBe ( true ) ; const 0 = botReducer ( 0 , { type : Actions . SETTING_UPDATE_END , payload : undefined } ) ; expect ( 0 . isUpdating ) . toBe ( false ) ; } ) ; it ( "s" , ( ) => { const state = botReducer ( initialState ( ) , { type : Actions . CHANGE_STEP_SIZE , payload : 0 } ) ; expect ( state . stepSize ) . toBe ( 0 ) ; } ) ; it ( "s" , ( ) => { const payload : keyof ControlPanelState = "s" ; const state = botReducer ( initialState ( ) , { type : Actions . TOGGLE_CONTROL_PANEL_OPTION , payload } ) ; expect ( state . controlPanelState . danger_zone ) . toBe ( ! initialState ( ) . controlPanelState . danger_zone ) ; } ) ; it ( "s" , ( ) => { const state = botReducer ( initialState ( ) , { type : Actions . BULK_TOGGLE_CONTROL_PANEL , payload : true } ) ; const bulkToggable = omit ( state . controlPanelState , "s" , "s" ) ; values ( bulkToggable ) . map ( value => { expect ( value ) . toBeTruthy ( ) ; } ) ; } ) ; it ( "s" , ( ) => { const r = botReducer ( initialState ( ) , { type : Actions . FETCH_OS_UPDATE_INFO_OK , payload : { version : "s" , commit : undefined } } ) . currentOSVersion ; expect ( r ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { const r = botReducer ( initialState ( ) , { type : Actions . FETCH_BETA_OS_UPDATE_INFO_OK , payload : { version : "s" , commit : undefined } } ) . currentBetaOSVersion ; expect ( r ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { const r = botReducer ( initialState ( ) , { type : Actions . FETCH_MIN_OS_FEATURE_INFO_OK , payload : { } } ) . minOsFeatureData ; expect ( r ) . toEqual ( { } ) ; } ) ; it ( "s" , ( ) => { const n = ( ) => Math . round ( Math . random ( ) * 0 ) ; const position = { x : n ( ) , y : n ( ) , z : n ( ) } ; const state = initialState ( ) ; state . hardware . informational_settings . sync_status = "s" ; const action = incomingStatus ( { location_data : { position } } ) ; const r = botReducer ( state , action ) ; expect ( r . hardware . location_data . position ) . toEqual ( position ) ; } ) ; it ( "s" , ( ) => { const state = initialState ( ) ; const payload = defensiveClone ( state . hardware ) ; payload . informational_settings . sync_status = "s" ; payload . location_data . position . x = - 0 ; payload . location_data . position . y = - 0 ; payload . location_data . position . z = - 0 ; const action = { type : Actions . LEGACY_BOT_CHANGE , payload } ; const result = botReducer ( state , action ) ; expect ( result . hardware . location_data . position ) . toEqual ( initialState ( ) . hardware . location_data . position ) ; expect ( result . hardware . informational_settings . sync_status ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { const 0 = initialState ( ) ; 0 . statusStash = "s" ; 0 . hardware . informational_settings . sync_status = "s" ; const go = ( direction : "s" | "s" , one ) => { const id = uuid ( ) ; const 0 = { type : Actions . PING_START , payload : { id } } ; const two = botReducer ( one , 0 ) ; const type_ = ( direction == "s" ) ? Actions . PING_OK : Actions . PING_NO ; const 0 = { type : type_ , payload : { id , at : now ( ) } } ; return botReducer ( two , 0 ) ; } ; const 0 = go ( "s" , 0 ) ; expect ( 0 . statusStash ) . toBe ( statusOf ( 0 ) ) ; expect ( statusOf ( 0 ) ) . toBeUndefined ( ) ; const 0 = go ( "s" , 0 ) ; expect ( 0 . statusStash ) . toBe ( statusOf ( 0 ) ) ; expect ( statusOf ( 0 ) ) . toBeUndefined ( ) ; const 0 = go ( "s" , 0 ) ; expect ( statusOf ( 0 ) ) . toBe ( 0 . statusStash ) ; } ) ; it ( "s" , ( ) => { const 0 = initialState ( ) ; 0 . statusStash = "s" ; 0 . hardware . informational_settings . sync_status = "s" ; const 0 = botReducer ( 0 , stash ( ) ) ; expect ( 0 . statusStash ) . toBe ( statusOf ( 0 ) ) ; const no = { type : Actions . _RESOURCE_NO , payload : undefined } ; const 0 = botReducer ( 0 , no ) ; expect ( statusOf ( 0 ) ) . toBe ( 0 . statusStash ) ; } ) ; } ) ;	O O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $T$ O O O O O O $complex$ O O O O O O $complex$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $number$ O O O O O $any$ O O $BotState$ O O O O $BotState$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $BotState$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O O O O $Actions.SETTING_UPDATE_START$ O $any$ O $Actions.SETTING_UPDATE_START$ O $undefined$ O $undefined$ O O O $any$ O $BotState$ O $boolean$ O O $any$ O O O O O $BotState$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O O $Actions.SETTING_UPDATE_END$ O $any$ O $Actions.SETTING_UPDATE_END$ O $undefined$ O $undefined$ O O O $any$ O $BotState$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotState$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O O O O $Actions.CHANGE_STEP_SIZE$ O $any$ O $Actions.CHANGE_STEP_SIZE$ O $number$ O O O O O $any$ O $BotState$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O $BotState$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O O O O $Actions.TOGGLE_CONTROL_PANEL_OPTION$ O $any$ O $Actions.TOGGLE_CONTROL_PANEL_OPTION$ O O O O O $any$ O $BotState$ O $ControlPanelState$ O $boolean$ O O $any$ O O $BotState$ O O O $ControlPanelState$ O $boolean$ O O O O O $any$ O O O O O O O O $BotState$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O O O O $Actions.BULK_TOGGLE_CONTROL_PANEL$ O $any$ O $Actions.BULK_TOGGLE_CONTROL_PANEL$ O $boolean$ O O O O O O $any$ O $any$ O $BotState$ O $ControlPanelState$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O O $string$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O O O O $Actions.FETCH_OS_UPDATE_INFO_OK$ O $any$ O $Actions.FETCH_OS_UPDATE_INFO_OK$ O $complex$ O O $string$ O O O $undefined$ O $undefined$ O O O O $string$ O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $string$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O O O O $Actions.FETCH_BETA_OS_UPDATE_INFO_OK$ O $any$ O $Actions.FETCH_BETA_OS_UPDATE_INFO_OK$ O $complex$ O O $string$ O O O $undefined$ O $undefined$ O O O O $string$ O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O O O O $Actions.FETCH_MIN_OS_FEATURE_INFO_OK$ O $any$ O $Actions.FETCH_MIN_OS_FEATURE_INFO_OK$ O ${}$ O O O O O O $complex$ O $any$ O $complex$ O O $any$ O O O O O O O O $any$ O O O O O O O O $number$ O O O O $Math$ O $number$ O $Math$ O $number$ O O O O O O O $Vector3$ O O $number$ O $number$ O O O $number$ O $number$ O O O $number$ O $number$ O O O O O $BotState$ O $BotState$ O O O $BotState$ O $any$ O $any$ O $any$ O O O O $complex$ O $complex$ O O $complex$ O O $any$ O O O O O $BotState$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O $complex$ O O $any$ O $BotState$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $BotState$ O $BotState$ O O O O $any$ O $T$ O $BotState$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $complex$ O O $Actions$ O $any$ O $Actions.LEGACY_BOT_CHANGE$ O $any$ O O O $BotState$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O $complex$ O O $any$ O $BotState$ O $any$ O $any$ O $any$ O O $any$ O $BotState$ O O O $any$ O $any$ O $any$ O O $any$ O $BotState$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $BotState$ O $BotState$ O O O $BotState$ O $any$ O O O $BotState$ O $any$ O $any$ O $any$ O O O O $BotState$ O O $NetworkState$ O O O O O $BotState$ O O O O $any$ O $any$ O O O O $complex$ O O $Actions$ O $any$ O $Actions.PING_START$ O $complex$ O O $any$ O O O O $BotState$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O $complex$ O O O $complex$ O O $NetworkState$ O O O O $any$ O $Actions.PING_OK$ O $any$ O $Actions.PING_NO$ O O $complex$ O O $Actions$ O $complex$ O $complex$ O O $any$ O $number$ O $number$ O O O O O O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O $complex$ O O O O O $BotState$ O $BotState$ O O O $BotState$ O O $any$ O $BotState$ O $any$ O O $any$ O $any$ O $BotState$ O O O $any$ O $any$ O $BotState$ O O O $any$ O O O O $BotState$ O $BotState$ O O O $BotState$ O O $any$ O $BotState$ O $any$ O O $any$ O $any$ O $BotState$ O O O $any$ O $any$ O $BotState$ O O O $any$ O O O O $BotState$ O $BotState$ O O O $BotState$ O O $any$ O $any$ O $BotState$ O O O $any$ O $BotState$ O $any$ O O O O O $any$ O O O O O O O O $BotState$ O $BotState$ O O O $BotState$ O $any$ O O O $BotState$ O $any$ O $any$ O $any$ O O O O $BotState$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O $complex$ O O O O $any$ O $BotState$ O $any$ O O $any$ O $any$ O $BotState$ O O O O $complex$ O O $Actions$ O $any$ O $Actions._RESOURCE_NO$ O $undefined$ O $undefined$ O O O $BotState$ O $generateReducer<BotState>.GeneratedReducer$ O $BotState$ O $complex$ O O $any$ O $any$ O $BotState$ O O O $any$ O $BotState$ O $any$ O O O O O O O O
import { greaterThan , lessThan , mcuParamValidator , OK , McuErrors } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const params = { movement_min_spd_x : 0 } ; const comparison = greaterThan ( "s" ) ; expect ( comparison ( "s" , 0 , params ) ) . toEqual ( OK ) ; params . movement_min_spd_x = 0 ; expect ( comparison ( "s" , 0 , params ) . errorMessage ) . toEqual ( McuErrors . TOO_LOW ) ; params . movement_min_spd_x = 0 ; expect ( comparison ( "s" , 0 , params ) . errorMessage ) . toEqual ( McuErrors . TOO_LOW ) ; } ) ; it ( "s" , ( ) => { const params = { movement_max_spd_x : 0 } ; const comparison = lessThan ( "s" ) ; expect ( comparison ( "s" , 0 , params ) ) . toEqual ( OK ) ; params . movement_max_spd_x = 0 ; expect ( comparison ( "s" , 0 , params ) . errorMessage ) . toEqual ( McuErrors . TOO_HIGH ) ; expect ( comparison ( "s" , 0 , params ) . errorMessage ) . toEqual ( McuErrors . TOO_HIGH ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = { movement_min_spd_y : 0 , movement_max_spd_y : 0 } ; const validate = mcuParamValidator ( "s" , 0 , state ) ; const ok = jest . fn ( ) ; const no = jest . fn ( ) ; validate ( ok , no ) ; expect ( no ) . toHaveBeenCalled ( ) ; expect ( ok ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const state = { movement_min_spd_y : 0 , movement_max_spd_y : 0 , } ; const validate = mcuParamValidator ( "s" , 0 , state ) ; const ok = jest . fn ( ) ; const no = jest . fn ( ) ; validate ( ok , no ) ; expect ( ok ) . toHaveBeenCalled ( ) ; expect ( no ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { } ) ; } ) ;	O O $Result$ O $Result$ O $void$ O $Result$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O O O $Result$ O $Result$ O O O O $any$ O $Result$ O O O O O $complex$ O O O $any$ O $Result$ O O $complex$ O $number$ O O O $any$ O $Result$ O O O O O $complex$ O O $string$ O O $any$ O $any$ O $McuErrors.TOO_LOW$ O O $complex$ O $number$ O O O $any$ O $Result$ O O O O O $complex$ O O $string$ O O $any$ O $any$ O $McuErrors.TOO_LOW$ O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O O O $Result$ O $Result$ O O O O $any$ O $Result$ O O O O O $complex$ O O O $any$ O $Result$ O O $complex$ O $number$ O O O $any$ O $Result$ O O O O O $complex$ O O $string$ O O $any$ O $any$ O $McuErrors.TOO_HIGH$ O O $any$ O $Result$ O O O O O $complex$ O O $string$ O O $any$ O $any$ O $McuErrors.TOO_HIGH$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O O O $void$ O $void$ O O O O O $complex$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O O O O $void$ O $void$ O O O O O $complex$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O O
import { FirmwareHardware } from "s" ; import { ShouldDisplay , Feature } from "s" ; export const isFwHardwareValue = ( x ? ) : x is FirmwareHardware => { const values : FirmwareHardware [ ] = [ "s" , "s" , "s" , "s" , "s" ] ; return ! ! values . includes ( x as FirmwareHardware ) ; } ; export const getBoardIdentifier = ( firmwareVersion : string | undefined ) : string => firmwareVersion ? firmwareVersion . slice ( - 0 ) : "s" ; export const isKnownBoard = ( firmwareVersion : string | undefined ) : boolean => { const boardIdentifier = getBoardIdentifier ( firmwareVersion ) ; return [ "s" , "s" , "s" , "s" ] . includes ( boardIdentifier ) ; } ; export const getBoardCategory = ( firmwareVersion : string | undefined ) : "s" | "s" => { const boardIdentifier = getBoardIdentifier ( firmwareVersion ) ; return boardIdentifier === "s" ? "s" : "s" ; } ; export const boardType = ( firmwareVersion : string | undefined ) : FirmwareHardware | "s" => { if ( firmwareVersion === "s" ) { return "s" ; } const boardIdentifier = getBoardIdentifier ( firmwareVersion ) ; switch ( boardIdentifier ) { case "s" : return "s" ; case "s" : return "s" ; case "s" : return "s" ; case "s" : return "s" ; default : return "s" ; } } ; const ARDUINO = { label : "s" , value : "s" } ; const FARMDUINO = { label : "s" , value : "s" } ; const 0 = { label : "s" , value : "s" } ; const 0 = { label : "s" , value : "s" } ; const NONE = { label : "s" , value : "s" } ; export const FIRMWARE_CHOICES_DDI = { [ ARDUINO . value ] : ARDUINO , [ FARMDUINO . value ] : FARMDUINO , [ 0 . value ] : 0 , [ 0 . value ] : 0 , [ NONE . value ] : NONE } ; export const getFirmwareChoices = ( shouldDisplay = ( ) => true ) => ( [ ARDUINO , FARMDUINO , 0 , ... ( shouldDisplay ( Feature . 0 ) ? [ 0 ] : [ ] ) , ... ( shouldDisplay ( Feature . none_firmware ) ? [ NONE ] : [ ] ) , ] ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $complex$ O O $unknown$ $unknown$ O O $unknown$ O $any$ O O O $any[]$ O $any$ O O O O O O O O O O O O O O O O O O $any[]$ O $boolean$ O $unknown$ O $any$ O O O O O O $string$ O O $string$ O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O $boolean$ O O $string$ O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O $complex$ O O $string$ O O O O O O O O O O O O $string$ O $string$ O $string$ O O O $string$ O O O O O O O O O O O $any$ O O $string$ O O O O O O $any$ O O O O O O $string$ O O O O O O O O O $string$ O $string$ O $string$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O $complex$ O O $string$ O O O $string$ O O O O O O $complex$ O O O $complex$ O $string$ O O $complex$ O O $complex$ O $string$ O O $complex$ O O $complex$ O $string$ O O $complex$ O O $complex$ O $string$ O O $complex$ O O $complex$ O $string$ O O $complex$ O O O O $complex$ O O $ShouldDisplay$ O O O O O O O O O $complex$ O $complex$ O $complex$ O O O $ShouldDisplay$ O $any$ O O O O O $complex$ O O O O O O O O $ShouldDisplay$ O $any$ O $Feature.none_firmware$ O O O $complex$ O O O O O O O O O
import { boardType } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( boardType ( "s" ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( boardType ( "s" ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( boardType ( "s" ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( boardType ( "s" ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( boardType ( undefined ) ) . toEqual ( "s" ) ; expect ( boardType ( "s" ) ) . toEqual ( "s" ) ; expect ( boardType ( "s" ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( boardType ( "s" ) ) . toEqual ( "s" ) ; } ) ; } ) ;	O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $undefined$ O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O O
import { Configuration , ConfigurationName , McuParams , McuParamName } from "s" ; import { SourceFbosConfig , SourceFwConfig } from "s" ; import { FbosConfig } from "s" ; import { FirmwareConfig } from "s" ; export const sourceFbosConfigValue = ( apiConfig : FbosConfig | undefined , botConfig ) : SourceFbosConfig => ( setting ) => { const apiValue = apiConfig && apiConfig [ setting as keyof FbosConfig ] ; const botValue = botConfig [ setting ] ; return { value : apiConfig ? apiValue : botValue , consistent : apiConfig ? apiValue === botValue : true } ; } ; export const sourceFwConfigValue = ( apiConfig : FirmwareConfig | undefined , botConfig ) : SourceFwConfig => ( setting ) => { const apiValue = apiConfig && apiConfig [ setting ] ; const botValue = botConfig [ setting ] ; return { value : apiConfig ? apiValue : botValue , consistent : apiConfig ? apiValue === botValue : true } ; } ;	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $SourceFbosConfig$ O O $any$ O $any$ O O O $Configuration$ O O $any$ O O $ConfigurationName$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $boolean$ O $any$ O $any$ O $any$ O O O O O O O O $SourceFwConfig$ O O $any$ O $any$ O O O $McuParams$ O O $any$ O O $McuParamName$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $boolean$ O $any$ O $any$ O $any$ O O O O O O
import { sourceFbosConfigValue , sourceFwConfigValue } from "s" ; import { bot } from "s" ; import { fakeFbosConfig , fakeFirmwareConfig } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const fakeConfig = fakeFbosConfig ( ) . body ; fakeConfig . auto_sync = false ; bot . hardware . configuration . auto_sync = true ; const source = sourceFbosConfigValue ( fakeConfig , bot . hardware . configuration ) ; expect ( source ( "s" ) ) . toEqual ( { value : false , consistent : false } ) ; } ) ; it ( "s" , ( ) => { bot . hardware . configuration . auto_sync = true ; const source = sourceFbosConfigValue ( undefined , bot . hardware . configuration ) ; expect ( source ( "s" ) ) . toEqual ( { value : true , consistent : true } ) ; } ) ; it ( "s" , ( ) => { const fakeConfig = fakeFbosConfig ( ) . body ; fakeConfig . auto_sync = true ; bot . hardware . configuration . auto_sync = true ; const source = sourceFbosConfigValue ( fakeConfig , bot . hardware . configuration ) ; expect ( source ( "s" ) ) . toEqual ( { value : true , consistent : true } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const fakeConfig = fakeFirmwareConfig ( ) . body ; fakeConfig . param_mov_nr_retry = 0 ; bot . hardware . mcu_params . param_mov_nr_retry = 0 ; const source = sourceFwConfigValue ( fakeConfig , bot . hardware . mcu_params ) ; expect ( source ( "s" ) ) . toEqual ( { value : 0 , consistent : false } ) ; } ) ; it ( "s" , ( ) => { bot . hardware . mcu_params . param_mov_nr_retry = 0 ; const source = sourceFwConfigValue ( undefined , bot . hardware . mcu_params ) ; expect ( source ( "s" ) ) . toEqual ( { value : 0 , consistent : true } ) ; } ) ; it ( "s" , ( ) => { const fakeConfig = fakeFirmwareConfig ( ) . body ; fakeConfig . param_mov_nr_retry = 0 ; bot . hardware . mcu_params . param_mov_nr_retry = 0 ; const source = sourceFwConfigValue ( fakeConfig , bot . hardware . mcu_params ) ; expect ( source ( "s" ) ) . toEqual ( { value : 0 , consistent : true } ) ; } ) ; } ) ;	O O $SourceFbosConfig$ O $SourceFwConfig$ O O O O O O $BotState$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $BotState$ O $any$ O $any$ O $any$ O O O O $SourceFbosConfig$ O $SourceFbosConfig$ O $any$ O $BotState$ O $any$ O $any$ O O $any$ O $SourceFbosConfig$ O O O O O $any$ O O $boolean$ O O O $boolean$ O O O O O O O O $any$ O O O O O O O $BotState$ O $any$ O $any$ O $any$ O O O O $SourceFbosConfig$ O $SourceFbosConfig$ O $undefined$ O $BotState$ O $any$ O $any$ O O $any$ O $SourceFbosConfig$ O O O O O $any$ O O $boolean$ O O O $boolean$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $BotState$ O $any$ O $any$ O $any$ O O O O $SourceFbosConfig$ O $SourceFbosConfig$ O $any$ O $BotState$ O $any$ O $any$ O O $any$ O $SourceFbosConfig$ O O O O O $any$ O O $boolean$ O O O $boolean$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $BotState$ O $any$ O $any$ O $any$ O O O O $SourceFwConfig$ O $SourceFwConfig$ O $any$ O $BotState$ O $any$ O $any$ O O $any$ O $SourceFwConfig$ O O O O O $any$ O O $number$ O O O $boolean$ O O O O O O O O $any$ O O O O O O O $BotState$ O $any$ O $any$ O $any$ O O O O $SourceFwConfig$ O $SourceFwConfig$ O $undefined$ O $BotState$ O $any$ O $any$ O O $any$ O $SourceFwConfig$ O O O O O $any$ O O $number$ O O O $boolean$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $BotState$ O $any$ O $any$ O $any$ O O O O $SourceFwConfig$ O $SourceFwConfig$ O $any$ O $BotState$ O $any$ O $any$ O O $any$ O $SourceFwConfig$ O O O O O $any$ O O $number$ O O O $boolean$ O O O O O O O O O O O
import { McuParams } from "s" ; import { Xyz } from "s" ; import { transform } from "s" ; interface AxisStatus { axis : Xyz ; disabled : boolean ; } export function axisTrackingStatus ( h ) : AxisStatus [ ] { const stats = enabledAxisMap ( h ) ; const mapper = ( a : keyof typeof stats ) => ( { axis : a , disabled : ! stats [ a ] } ) ; return Object . keys ( stats ) . map ( mapper ) ; } export function enabledAxisMap ( h ) < Xyz , boolean > { return { x : ! ! ( h . encoder_enabled_x || h . movement_enable_endpoints_x ) , y : ! ! ( h . encoder_enabled_y || h . movement_enable_endpoints_y ) , z : ! ! ( h . encoder_enabled_z || h . movement_enable_endpoints_z ) } ; } export function disabledAxisMap ( h ) < Xyz , boolean > { return transform < boolean , Record < Xyz , boolean > > ( enabledAxisMap ( h ) , ( d < Xyz , boolean > , value , key ) => { d [ key ] = ! value ; } , { x : false , y : false , z : false } ) ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $Xyz$ O $any$ O $boolean$ O O O O O O $AxisStatus[]$ O $McuParams$ O O $any$ O O O O $complex$ O $complex$ O $any$ O O O $complex$ O O $Xyz$ O O O $complex$ O O O O $Xyz$ O $Xyz$ O $boolean$ O O $complex$ O $Xyz$ O O O O O $ObjectConstructor$ O $complex$ O $complex$ O O $U[]$ O $complex$ O O O O O $Record$ O $McuParams$ O O $any$ O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $Record$ O $McuParams$ O O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O O $complex$ O $any$ O O O $Record$ O $any$ O O O O $boolean$ O $Xyz$ O O O $complex$ O $Xyz$ O O O $boolean$ O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O O
import { calculateLatency , calculatePingLoss , completePing , startPing , failPing , PingDictionary } from "s" ; import { fakePings } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const report = calculateLatency ( { "s" : { kind : "s" , start : 0 , end : 0 } , "s" : { kind : "s" , start : 0 } , "s" : { kind : "s" , start : 0 , end : 0 } , "s" : { kind : "s" , start : 0 , end : 0 } , "s" : { kind : "s" , start : 0 , end : 0 } , "s" : { kind : "s" , start : 0 , end : 0 } , } ) ; expect ( report . best ) . toEqual ( 0 ) ; expect ( report . worst ) . toEqual ( 0 ) ; expect ( report . average ) . toEqual ( 0 ) ; expect ( report . total ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { const report = calculateLatency ( { } ) ; expect ( report . best ) . toEqual ( 0 ) ; expect ( report . worst ) . toEqual ( 0 ) ; expect ( report . average ) . toEqual ( 0 ) ; expect ( report . total ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { const report = calculatePingLoss ( fakePings ( ) ) ; expect ( report . total ) . toEqual ( 0 ) ; expect ( report . complete ) . toEqual ( 0 ) ; expect ( report . pending ) . toEqual ( 0 ) ; expect ( report . complete ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { const KEY = "s" ; const state = fakePings ( ) ; const before = state [ KEY ] ; const nextState = completePing ( state , KEY ) ; const after = nextState [ KEY ] ; expect ( before && before . kind ) . toEqual ( "s" ) ; expect ( after && after . kind ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const state = { "s" : { kind : "s" , start : 0 , end : 0 } , } ; const nextState = completePing ( state , "s" ) ; expect ( nextState ) . toBe ( state ) ; } ) ; it ( "s" , ( ) => { const state = fakePings ( ) ; const nextState = startPing ( state , "s" ) ; expect ( state [ "s" ] ) . toBeFalsy ( ) ; expect ( nextState [ "s" ] ) . toBeTruthy ( ) ; } ) ; it ( "s" , ( ) => { const state = fakePings ( ) ; state [ "s" ] = { kind : "s" , start : 0 } ; const nextState = failPing ( state , "s" ) ; const after = nextState [ "s" ] ; expect ( after && after . kind ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const state = { "s" : { kind : "s" , start : 0 , end : 0 } , } ; const nextState = failPing ( state , "s" ) ; expect ( nextState ) . toBe ( state ) ; } ) ; } ) ;	O O $LatencyReport$ O $complex$ O $complex$ O $complex$ O $complex$ O $any$ O O O O O O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $LatencyReport$ O $LatencyReport$ O O O O O O O O O $number$ O O O $number$ O O O O O O O O O O O $number$ O O O O O O O O O O O $number$ O O O $number$ O O O O O O O O O O O $number$ O O O $number$ O O O O O O O O O O O $number$ O O O $number$ O O O O O O O O O O O $number$ O O O $number$ O O O O O O O $any$ O $LatencyReport$ O $number$ O O $any$ O O O O $any$ O $LatencyReport$ O $number$ O O $any$ O O O O $any$ O $LatencyReport$ O $number$ O O $any$ O O O O $any$ O $LatencyReport$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $LatencyReport$ O $LatencyReport$ O O O O O $any$ O $LatencyReport$ O $number$ O O $any$ O O O O $any$ O $LatencyReport$ O $number$ O O $any$ O O O O $any$ O $LatencyReport$ O $number$ O O $any$ O O O O $any$ O $LatencyReport$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O $complex$ O O O O $any$ O $complex$ O $number$ O O $any$ O O O O $any$ O $complex$ O $number$ O O $any$ O O O O $any$ O $complex$ O $number$ O O $any$ O O O O $any$ O $complex$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $complex$ O $complex$ O O O O $Ping$ O $complex$ O O O O O $complex$ O $complex$ O $complex$ O O O O O $Ping$ O $complex$ O O O O $any$ O $Ping$ O $Ping$ O O O O $any$ O O O O $any$ O $Ping$ O $Ping$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $PingDictionary$ O O O O O O O O O $number$ O O O $number$ O O O O O O O $complex$ O $complex$ O $complex$ O O O O $any$ O $complex$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O $complex$ O O O O $any$ O $complex$ O O O O O $any$ O O O $any$ O $complex$ O O O O O $any$ O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $complex$ O O O O O O O O O $number$ O O O O O $complex$ O $complex$ O $complex$ O O O O O $Ping$ O $complex$ O O O O $any$ O $Ping$ O $Ping$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $PingDictionary$ O O O O O O O O O $number$ O O O $number$ O O O O O O O $complex$ O $complex$ O $complex$ O O O O $any$ O $complex$ O O $any$ O $complex$ O O O O O O O O
jest . mock ( "s" , ( ) => { return { pingNO : jest . fn ( ) , dispatchQosStart : jest . fn ( ) } ; } ) ; import { sendOutboundPing } from "s" ; import { DeepPartial } from "s" ; import { Farmbot } from "s" ; import { pingNO } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( done ) => { const fakeBot < Farmbot > = { ping : jest . fn ( ( ) => Promise . reject ( ) ) } ; expect ( pingNO ) . not . toHaveBeenCalled ( ) ; sendOutboundPing ( fakeBot as Farmbot ) . then ( fail , ( ) => { expect ( pingNO ) . toHaveBeenCalled ( ) ; done ( ) ; } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O $DeepPartial$ O $any$ O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $void$ O O $any$ O O O $any$ O O O O O O O O O O O O
import { browserToMQTT , botToMQTT , botToAPI , botToFirmware , browserToAPI } from "s" ; import moment from "s" ; import { ConnectionStatus } from "s" ; import { betterMerge } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = botToAPI ( moment ( ) . subtract ( 0 , "s" ) . toJSON ( ) ) ; expect ( result . connectionStatus ) . toBeTruthy ( ) ; expect ( result . children ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const result = botToAPI ( moment ( ) . subtract ( 0 , "s" ) . toJSON ( ) ) ; expect ( result . connectionStatus ) . toBeFalsy ( ) ; expect ( result . children ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const result = botToAPI ( undefined , ( new Date ( ) ) . getTime ( ) ) ; expect ( result . connectionStatus ) . toBeFalsy ( ) ; expect ( result . children ) . toContain ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { const DEFAULT_STATE = { at : new Date ( "s" ) . getTime ( ) , state : "s" } ; function stat ( input < ConnectionStatus > = { } ) { return betterMerge ( DEFAULT_STATE , input as ConnectionStatus ) ; } it ( "s" , ( ) => { const input = stat ( ) ; const result = botToMQTT ( input ) ; expect ( result . connectionStatus ) . toBeTruthy ( ) ; expect ( result . children ) . toContain ( "s" ) ; expect ( result . children ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const result = botToMQTT ( undefined ) ; expect ( result . connectionStatus ) . toBeFalsy ( ) ; expect ( result . children ) . toContain ( "s" ) ; } ) ; } ) ; const NOW = ( new Date ( ) ) . getTime ( ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const output = browserToMQTT ( { state : "s" , at : NOW } ) ; expect ( output . connectionStatus ) . toBe ( true ) ; expect ( output . children ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const output = browserToMQTT ( undefined ) ; expect ( output . connectionStatus ) . toBe ( undefined ) ; expect ( output . children ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const output = browserToMQTT ( { state : "s" , at : NOW } ) ; expect ( output . connectionStatus ) . toBe ( false ) ; expect ( output . children ) . toContain ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const output = botToFirmware ( "s" ) ; expect ( output . connectionStatus ) . toBe ( true ) ; expect ( output . to ) . toContain ( "s" ) ; expect ( output . children ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( botToFirmware ( "s" ) . to ) . toContain ( "s" ) ; expect ( botToFirmware ( "s" ) . to ) . toContain ( "s" ) ; expect ( botToFirmware ( "s" ) . to ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const output = botToFirmware ( undefined ) ; expect ( output . to ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const output = botToFirmware ( "s" ) ; expect ( output . connectionStatus ) . toBe ( false ) ; expect ( output . children ) . toContain ( "s" ) ; expect ( botToFirmware ( "s" ) . children ) . toContain ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = browserToAPI ( { state : "s" , at : ( new Date ) . getTime ( ) } ) ; expect ( result . connectionStatus ) . toBeTruthy ( ) ; expect ( result . children ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const result = browserToAPI ( { state : "s" , at : ( new Date ) . getTime ( ) } ) ; expect ( result . connectionStatus ) . toBeFalsy ( ) ; expect ( result . children ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const result = browserToAPI ( undefined ) ; expect ( result . connectionStatus ) . toBeFalsy ( ) ; expect ( result . children ) . toContain ( "s" ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $undefined$ O O O $DateConstructor$ O O O O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $ConnectionStatus$ O O $number$ O O $DateConstructor$ O O O O $number$ O O O O O O O O O $ConnectionStatus$ O $Partial$ O $any$ O O O O O O O $complex$ O $ConnectionStatus$ O $Partial<ConnectionStatus>$ O $any$ O O O $any$ O O O O O O O O $ConnectionStatus$ O $ConnectionStatus$ O O O O $any$ O $any$ O $ConnectionStatus$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O O $number$ O O O $DateConstructor$ O O O O $number$ O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O $number$ O $number$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O $number$ O $number$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O $number$ O O O $DateConstructor$ O O $number$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O $number$ O O O $DateConstructor$ O O $number$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { TaggedDevice } from "s" ; import { BotState } from "s" ; import { DiagnosisName , DiagnosisProps } from "s" ; import { StatusRowProps } from "s" ; import { browserToMQTT , browserToAPI , botToMQTT , botToAPI , botToFirmware } from "s" ; interface ConnectivityDataProps { bot : BotState ; device : TaggedDevice ; } export const connectivityData = ( props ) => { const fwVersion = props . bot . hardware . informational_settings . firmware_version ; const data < DiagnosisName , StatusRowProps > = { userMQTT : browserToMQTT ( props . bot . connectivity . uptime [ "s" ] ) , userAPI : browserToAPI ( props . bot . connectivity . uptime [ "s" ] ) , botMQTT : botToMQTT ( props . bot . connectivity . uptime [ "s" ] ) , botAPI : botToAPI ( props . device . body . last_saw_api ) , botFirmware : botToFirmware ( fwVersion ) , } ; const flags = { userMQTT : ! ! data . userMQTT . connectionStatus , userAPI : ! ! data . userAPI , botMQTT : ! ! data . botMQTT . connectionStatus , botAPI : ! ! data . botAPI . connectionStatus , botFirmware : ! ! data . botFirmware . connectionStatus , } ; const rowData : StatusRowProps [ ] = [ data . userAPI , data . userMQTT , data . botMQTT , data . botAPI , data . botFirmware , ] ; return { data , flags , rowData } ; } ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $BotState$ O $any$ O $any$ O $any$ O O O O $complex$ O O $ConnectivityDataProps$ O O O O $any$ O $ConnectivityDataProps$ O $BotState$ O $any$ O $any$ O $any$ O O $Record$ O $any$ O $any$ O O O $any$ O $any$ O $ConnectivityDataProps$ O $BotState$ O $ConnectionState$ O $complex$ O O O O O $any$ O $any$ O $ConnectivityDataProps$ O $BotState$ O $ConnectionState$ O $complex$ O O O O O $any$ O $any$ O $ConnectivityDataProps$ O $BotState$ O $ConnectionState$ O $complex$ O O O O O $any$ O $any$ O $ConnectivityDataProps$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $DiagnosisProps$ O O $boolean$ O O O $complex$ O $any$ O $any$ O $boolean$ O O O $complex$ O $any$ O $boolean$ O O O $complex$ O $any$ O $any$ O $boolean$ O O O $complex$ O $any$ O $any$ O $boolean$ O O O $complex$ O $any$ O $any$ O O O O $any[]$ O $any$ O O O O $complex$ O $any$ O $complex$ O $any$ O $complex$ O $any$ O $complex$ O $any$ O $complex$ O $any$ O O O O O $complex$ O $any$ O $any[]$ O O O O
import { Dictionary } from "s" ; import { DiagnosticMessages } from "s" ; export const TRUTH_TABLE < Dictionary < string | undefined > > = { [ 0 ] : DiagnosticMessages . TOTAL_BREAKAGE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . WIFI_OR_CONFIG , [ 0 ] : DiagnosticMessages . WIFI_OR_CONFIG , [ 0 ] : DiagnosticMessages . WIFI_OR_CONFIG , [ 0 ] : DiagnosticMessages . WIFI_OR_CONFIG , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . REMOTE_FIREWALL , [ 0 ] : DiagnosticMessages . REMOTE_FIREWALL , [ 0 ] : DiagnosticMessages . REMOTE_FIREWALL , [ 0 ] : DiagnosticMessages . REMOTE_FIREWALL , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . ARDUINO_DISCONNECTED , [ 0 ] : DiagnosticMessages . ARDUINO_DISCONNECTED , [ 0 ] : DiagnosticMessages . INACTIVE , [ 0 ] : DiagnosticMessages . INACTIVE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . NO_WS_AVAILABLE , [ 0 ] : DiagnosticMessages . ARDUINO_DISCONNECTED , [ 0 ] : DiagnosticMessages . ARDUINO_DISCONNECTED , [ 0 ] : DiagnosticMessages . OK } ;	O O $any$ O O O O O O $any$ O O O O O O $Readonly$ O $any$ O O O O O O O O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O O O O $any$ O $string$ O O
import { ResourceIndex } from "s" ; import { PinBindingType , PinBindingSpecialAction } from "s" ; export interface PinBindingsProps { dispatch : Function ; resources : ResourceIndex ; } export interface PinBindingListItems { pin_number : number , sequence_id : number | undefined , special_action ? : PinBindingSpecialAction | undefined , binding_type ? : PinBindingType , uuid ? : string } export interface PinBindingsListProps { pinBindings : PinBindingListItems [ ] ; resources : ResourceIndex ; dispatch : Function ; } export interface PinBindingInputGroupProps { dispatch : Function ; resources : ResourceIndex ; pinBindings : PinBindingListItems [ ] ; } export interface PinBindingInputGroupState { isEditing : boolean ; pinNumberInput : number | undefined ; sequenceIdInput : number | undefined ; specialActionInput : PinBindingSpecialAction | undefined ; bindingType : PinBindingType ; }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $Function$ O $FunctionConstructor$ O $ResourceIndex$ O $any$ O O O O $any$ O $number$ O O O $number$ O O O O O $any$ O O $any$ O O O $any$ O O $any$ O $string$ O O O O O O $any$ O $PinBindingListItems[]$ O $any$ O O O $ResourceIndex$ O $any$ O $Function$ O $FunctionConstructor$ O O O O $any$ O $Function$ O $FunctionConstructor$ O $ResourceIndex$ O $any$ O $PinBindingListItems[]$ O $any$ O O O O O O $any$ O $boolean$ O O O $number$ O O O O O $number$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O
import { TRANSLATORS , DEFAULT_FORMATTER } from "s" ; import { WDENVKey } from "s" ; export function formatEnvKey ( key , value ) { return ( TRANSLATORS [ key ] || DEFAULT_FORMATTER ) . format ( key , value ) ; } export function parseEnvKey ( key , value ) { return ( TRANSLATORS [ key ] || DEFAULT_FORMATTER ) . parse ( key , value ) ; }	O O O O $Translation$ O O O O O O $any$ O O O O O O O O $WDENVKey$ O $number$ O O O O O O O O O $Translation$ O O $FormatterFn$ O O O $number$ O O O O O O O $WDENVKey$ O $string$ O O O O O O O O O $Translation$ O O $ParserFn$ O O O $string$ O O O
import { WDENVKey , WD_ENV } from "s" ; import { WD_KEY_DEFAULTS , EVERY_WD_KEY } from "s" ; import { defensiveClone , betterParseNum } from "s" ; import { parseEnvKey } from "s" ; import { isNumber , isString } from "s" ; import { UserEnv } from "s" ; export function prepopulateEnv ( env ) { const output = defensiveClone ( WD_KEY_DEFAULTS ) ; EVERY_WD_KEY . map ( key => { const initial = env [ key ] ; let val ; if ( isString ( initial ) ) { val = initial ; } else { val = "s" + WD_KEY_DEFAULTS [ key ] ; } output [ key ] = parseEnvKey ( key , val ) ; } ) ; return output ; } export function envGet ( key , env < WD_ENV > ) { return betterParseNum ( JSON . stringify ( isNumber ( env [ key ] ) ? env [ key ] : "s" ) , WD_KEY_DEFAULTS [ key ] ) ; }	O O $any$ O $any$ O O O O O O O O O O O O O O O $T$ O $number$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $WD_ENV$ O $UserEnv$ O O O O O $T$ O O O O O O O O O O O O $string$ O $complex$ O O O O O $string$ O O O $any$ O $string$ O O O $string$ O $string$ O O O O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $number$ O $WDENVKey$ O $Partial$ O $any$ O O O O $number$ O $JSON$ O $complex$ O $any$ O O O O O O O O O O O O O O O O O O O O O O
import { FarmwareManifestInfo } from "s" ; import { LegacyFarmwareManifest as 0 , FarmwareManifest as 0 , } from "s" ; import { t } from "s" ; const addMinorAndPatchZeros = ( version : string | undefined ) : string => version ? "s" + version + "s" : "s" ; export const manifestInfo = ( manifest ) : FarmwareManifestInfo => { if ( manifest . farmware_manifest_version ) { const fw = manifest ; return { name : fw . package , installation_pending : false , url : fw . url , config : Object . values ( fw . config ) , meta : { fbos_version : fw . farmbot_os_version_requirement , farmware_tools_version : fw . farmware_tools_version_requirement , description : fw . description , language : fw . language , version : fw . package_version , author : fw . author , } } ; } else { const fw = manifest ; return { name : fw . name , installation_pending : false , url : fw . url , config : fw . config , meta : { fbos_version : addMinorAndPatchZeros ( fw . meta . min_os_version_major ) , farmware_tools_version : fw . farmware_tools_version || "s" , description : fw . meta . description , language : fw . meta . language , version : fw . meta . version , author : fw . meta . author , } } ; } } ; export const manifestInfoPending = ( name , url ) => ( { name , installation_pending : true , url , config : [ ] , meta : { fbos_version : "s" , farmware_tools_version : "s" , description : t ( "s" ) , language : "s" , version : "s" , author : "s" , } } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O $string$ O O $string$ O O O O O O O O $string$ O O O $string$ O O O O O O O $FarmwareManifestInfo$ O O $any$ O O $any$ O O O O $any$ O $any$ O O O $FarmwareManifestV2$ O $any$ O O O $any$ O $any$ O $any$ O $false$ O O O $any$ O $any$ O $any$ O $any[]$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $FarmwareManifestV1$ O $any$ O O O $any$ O $any$ O $any$ O $false$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O $string$ O $string$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $complex$ O O $string$ O $string$ O O O O $string$ O $boolean$ O O O $string$ O $undefined[]$ O O O O $complex$ O O $string$ O O O $string$ O O O $any$ O $any$ O O O O $string$ O O O $string$ O O O $string$ O O O O O O O
import { Everything } from "s" ; import { selectAllImages , maybeGetDevice , maybeGetTimeSettings } from "s" ; import { FarmwareProps , Feature , SaveFarmwareEnv , UserEnv } from "s" ; import { prepopulateEnv } from "s" ; import { selectAllFarmwareEnvs , selectAllFarmwareInstallations } from "s" ; import { determineInstalledOsVersion , createShouldDisplayFn as shouldDisplayFunc , betterCompact } from "s" ; import { ResourceIndex } from "s" ; import { TaggedFarmwareEnv , JobProgress } from "s" ; import { save , edit , initSave } from "s" ; import { chain } from "s" ; import { FarmwareManifestInfo , Farmwares } from "s" ; import { manifestInfo , manifestInfoPending } from "s" ; import { t } from "s" ; import { getStatus } from "s" ; import { DevSettings } from "s" ; import { getWebAppConfigValue } from "s" ; export const saveOrEditFarmwareEnv = ( ri ) : SaveFarmwareEnv => ( key , value ) => ( dispatch ) => { const fwEnvLookup < string , TaggedFarmwareEnv > = { } ; selectAllFarmwareEnvs ( ri ) . map ( x => { fwEnvLookup [ x . body . key ] = x ; } ) ; if ( Object . keys ( fwEnvLookup ) . includes ( key ) ) { const fwEnv = fwEnvLookup [ key ] ; dispatch ( edit ( fwEnv , { value } ) ) ; dispatch ( save ( fwEnv . uuid ) ) ; } else { dispatch ( initSave ( "s" , { key , value } ) ) ; } } ; export const isPendingInstallation = ( farmware : FarmwareManifestInfo | undefined ) => ! farmware || farmware . installation_pending ; export const reduceFarmwareEnv = ( ri ) : UserEnv => { const farmwareEnv = { } ; selectAllFarmwareEnvs ( ri ) . map ( x => { farmwareEnv [ x . body . key ] = "s" + x . body . value ; } ) ; return farmwareEnv ; } ; export function mapStateToProps ( props ) { const images = chain ( selectAllImages ( props . resources . index ) ) . sortBy ( x => x . body . id ) . reverse ( ) . value ( ) ; const firstImage = images [ 0 ] ; const currentImage = images . filter ( i => i . uuid === props . resources . consumers . farmware . currentImage ) [ 0 ] || firstImage ; const botStateFarmwares = props . bot . hardware . process_info . farmwares ; const { currentFarmware , firstPartyFarmwareNames , infoOpen } = props . resources . consumers . farmware ; const installedOsVersion = determineInstalledOsVersion ( props . bot , maybeGetDevice ( props . resources . index ) ) ; const fbosVersionOverride = DevSettings . overriddenFbosVersion ( ) ; const shouldDisplay = shouldDisplayFunc ( installedOsVersion , props . bot . minOsFeatureData , fbosVersionOverride ) ; const env = shouldDisplay ( Feature . api_farmware_env ) ? reduceFarmwareEnv ( props . resources . index ) : props . bot . hardware . user_env ; const taggedFarmwareInstallations = selectAllFarmwareInstallations ( props . resources . index ) ; const namePendingInstall = ( packageName : string | undefined , id : number | undefined ) : string => { const nameBase = packageName || `template` ; const pendingInstall = `template` ; return nameBase + pendingInstall ; } ; const farmwares = { } ; Object . values ( botStateFarmwares ) . map ( ( fm ) => { const info = manifestInfo ( fm ) ; farmwares [ info . name ] = manifestInfo ( fm ) ; } ) ; shouldDisplay ( Feature . api_farmware_installations ) && taggedFarmwareInstallations . map ( x => { const name = namePendingInstall ( x . body . package , x . body . id ) ; const alreadyAdded = Object . keys ( farmwares ) . includes ( x . body . package || name ) ; const alreadyInstalled = Object . values ( farmwares ) . map ( fw => fw . url ) . includes ( x . body . url ) ; if ( x . body . id && ! alreadyAdded && ! alreadyInstalled ) { farmwares [ name ] = manifestInfoPending ( name , x . body . url ) ; } } ) ; const jobs = props . bot . hardware . jobs || { } ; const imageJobNames = Object . keys ( jobs ) . filter ( x => x != "s" ) ; const imageJobs : JobProgress [ ] = chain ( betterCompact ( imageJobNames . map ( x => jobs [ x ] ) ) ) . sortBy ( "s" ) . reverse ( ) . value ( ) ; const botToMqttStatus = getStatus ( props . bot . connectivity . uptime [ "s" ] ) ; const syncStatus = props . bot . hardware . informational_settings . sync_status ; return { timeSettings : maybeGetTimeSettings ( props . resources . index ) , currentFarmware , farmwares , botToMqttStatus , env : prepopulateEnv ( env ) , user_env : env , dispatch : props . dispatch , currentImage , images , syncStatus , getConfigValue : getWebAppConfigValue ( ( ) => props ) , firstPartyFarmwareNames , shouldDisplay , saveFarmwareEnv : saveOrEditFarmwareEnv ( props . resources . index ) , taggedFarmwareInstallations , imageJobs , infoOpen , } ; }	O O $any$ O O O O O O $any[]$ O $any$ O $TimeSettings$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any[]$ O $any[]$ O O O O O O $string$ O $boolean$ O $boolean$ O $T[]$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $ReduxAction<EditResourceParams>$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $FarmwareManifestInfo$ O $complex$ O O O O O O $any$ O O O O O O $NetworkState$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $SaveFarmwareEnv$ O O $ResourceIndex$ O O $any$ O O $string$ O $string$ O O O $Function$ O O O O $Record$ O O O $any$ O O O O O $any[]$ O $ResourceIndex$ O O $U[]$ O $any$ O O $complex$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $ObjectConstructor$ O $complex$ O $complex$ O O $boolean$ O $string$ O O O O $any$ O $complex$ O $string$ O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O O $string$ O O O O $Function$ O $any$ O $any$ O $any$ O O O O O O $Function$ O $any$ O O O O $string$ O $string$ O O O O O O O O O $boolean$ O O $FarmwareManifestInfo$ O $any$ O O O O O $FarmwareManifestInfo$ O $FarmwareManifestInfo$ O $boolean$ O O O $complex$ O O $ResourceIndex$ O O $any$ O O O $UserEnv$ O O O O $any[]$ O $ResourceIndex$ O O $U[]$ O $any$ O O $complex$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $complex$ O O O O O $FarmwareProps$ O $Everything$ O O O $any$ O $any$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $Everything$ O $RestResources$ O $complex$ O $FarmwareState$ O $string$ O O O O O $any$ O O $any$ O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O O O $string$ O $string[]$ O $boolean$ O O $Everything$ O $RestResources$ O $complex$ O $FarmwareState$ O O $string$ O $string$ O $Everything$ O $BotState$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $string$ O $any$ O $string$ O O O O $boolean$ O $boolean$ O $string$ O $Everything$ O $BotState$ O $complex$ O $string$ O O O $any$ O $boolean$ O $any$ O $Feature.api_farmware_env$ O O $complex$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $Everything$ O $BotState$ O $any$ O $any$ O O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $string$ O O $string$ O O O O O $number$ O O O O O O O O O O $string$ O $string$ O O O O $string$ O O O O $string$ O $string$ O O O O $Farmwares$ O O O O $ObjectConstructor$ O $complex$ O $any$ O O $U[]$ O O $unknown$ O O O O $FarmwareManifestInfo$ O $FarmwareManifestInfo$ O $unknown$ O O $any$ O $FarmwareManifestInfo$ O $string$ O O $FarmwareManifestInfo$ O $unknown$ O O O O O $boolean$ O $any$ O $Feature.api_farmware_installations$ O O $any[]$ O $U[]$ O $any$ O O O $string$ O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O $ObjectConstructor$ O $complex$ O $any$ O O $boolean$ O $any$ O $any$ O $any$ O $string$ O O O $boolean$ O $ObjectConstructor$ O $complex$ O $any$ O O $U[]$ O $unknown$ O $unknown$ O $any$ O O $boolean$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $boolean$ O O $boolean$ O O $any$ O $string$ O O $complex$ O $string$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $Everything$ O $BotState$ O $any$ O $any$ O O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $any$ O O $complex$ O $string$ O $string$ O O O O O $any[]$ O $any$ O O O $any$ O $T[]$ O $string[]$ O $U[]$ O $string$ O $any$ O $string$ O O O O O $any$ O O O O $any$ O O O $any$ O O O O $NetworkState$ O $NetworkState$ O $Everything$ O $BotState$ O $ConnectionState$ O $complex$ O O O O O O $any$ O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O O O $TimeSettings$ O $TimeSettings$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $string$ O $any$ O $NetworkState$ O O O O O $any$ O O $any$ O $any$ O $Function$ O $Everything$ O $Function$ O $any$ O $any$ O $any$ O $complex$ O $complex$ O O O O $Everything$ O O $string[]$ O $boolean$ O $SaveFarmwareEnv$ O $SaveFarmwareEnv$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $any[]$ O $any[]$ O $boolean$ O O O O
import { Everything } from "s" ; import { MessagesProps , AlertReducerState } from "s" ; import { validFbosConfig , betterCompact } from "s" ; import { getFbosConfig } from "s" ; import { sourceFbosConfigValue } from "s" ; import { selectAllAlerts , maybeGetTimeSettings , findResourceById } from "s" ; import { isFwHardwareValue } from "s" ; import { ResourceIndex , UUID } from "s" ; import { Alert } from "s" ; export const mapStateToProps = ( props ) : MessagesProps => { const { hardware } = props . bot ; const fbosConfig = validFbosConfig ( getFbosConfig ( props . resources . index ) ) ; const sourceFbosConfig = sourceFbosConfigValue ( fbosConfig , hardware . configuration ) ; const apiFirmwareValue = sourceFbosConfig ( "s" ) . value ; const findApiAlertById = ( id ) : UUID => findResourceById ( props . resources . index , "s" , id ) ; return { alerts : getAllAlerts ( props . resources ) , apiFirmwareValue : isFwHardwareValue ( apiFirmwareValue ) ? apiFirmwareValue : undefined , timeSettings : maybeGetTimeSettings ( props . resources . index ) , dispatch : props . dispatch , findApiAlertById , } ; } ; export const getAllAlerts = ( resources : Everything [ "s" ] ) => ( [ ... getApiAlerts ( resources . index ) , ... getLocalAlerts ( resources . consumers . alerts ) , ] ) ; const getApiAlerts = ( resourceIndex ) : Alert [ ] => selectAllAlerts ( resourceIndex ) . map ( x => x . body ) ; const getLocalAlerts = ( { alerts } ) : Alert [ ] => betterCompact ( Object . values ( alerts ) ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $T[]$ O O O O O O $any$ O O O O O O $SourceFbosConfig$ O O O O O O $any[]$ O $TimeSettings$ O $any$ O O O O O O $complex$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $MessagesProps$ O O $Everything$ O O $any$ O O O O $any$ O O $Everything$ O $BotState$ O O $any$ O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $SourceFbosConfig$ O $SourceFbosConfig$ O $any$ O $any$ O $any$ O O O $complex$ O $SourceFbosConfig$ O O O O $complex$ O O $string$ O O $number$ O O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $number$ O O O O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O O $complex$ O $complex$ O $complex$ O O $complex$ O $undefined$ O $TimeSettings$ O $TimeSettings$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $Function$ O $Everything$ O $Function$ O $string$ O O O O O O O $any[]$ O O $RestResources$ O $any$ O O O O O O O O $any[]$ O $RestResources$ O $ResourceIndex$ O O O $any[]$ O $RestResources$ O $complex$ O $AlertReducerState$ O O O O O O $any[]$ O O $ResourceIndex$ O O $any$ O O O $any[]$ O $ResourceIndex$ O O $U[]$ O $any$ O $any$ O $any$ O O O $any[]$ O O O $any$ $AlertReducerState$ O O $any$ O O O $T[]$ O $ObjectConstructor$ O $complex$ O $any$ O O O
import { Everything } from "s" ; import { Props , Feature } from "s" ; import { selectAllImages , getDeviceAccountSettings , maybeGetDevice , maybeGetTimeSettings , } from "s" ; import { sourceFbosConfigValue , sourceFwConfigValue } from "s" ; import { determineInstalledOsVersion , validFwConfig , validFbosConfig , createShouldDisplayFn as shouldDisplayFunc } from "s" ; import { saveOrEditFarmwareEnv , reduceFarmwareEnv } from "s" ; import { getFbosConfig , getFirmwareConfig } from "s" ; import { DevSettings } from "s" ; import { getAllAlerts } from "s" ; export function mapStateToProps ( props ) { const { hardware } = props . bot ; const fbosConfig = validFbosConfig ( getFbosConfig ( props . resources . index ) ) ; const firmwareConfig = validFwConfig ( getFirmwareConfig ( props . resources . index ) ) ; const installedOsVersion = determineInstalledOsVersion ( props . bot , maybeGetDevice ( props . resources . index ) ) ; const fbosVersionOverride = DevSettings . overriddenFbosVersion ( ) ; const shouldDisplay = shouldDisplayFunc ( installedOsVersion , props . bot . minOsFeatureData , fbosVersionOverride ) ; const env = shouldDisplay ( Feature . api_farmware_env ) ? reduceFarmwareEnv ( props . resources . index ) : props . bot . hardware . user_env ; return { userToApi : props . bot . connectivity . uptime [ "s" ] , userToMqtt : props . bot . connectivity . uptime [ "s" ] , botToMqtt : props . bot . connectivity . uptime [ "s" ] , deviceAccount : getDeviceAccountSettings ( props . resources . index ) , auth : props . auth , bot : props . bot , dispatch : props . dispatch , images : selectAllImages ( props . resources . index ) , resources : props . resources . index , sourceFbosConfig : sourceFbosConfigValue ( fbosConfig , hardware . configuration ) , sourceFwConfig : sourceFwConfigValue ( firmwareConfig , hardware . mcu_params ) , shouldDisplay , firmwareConfig , isValidFbosConfig : ! ! fbosConfig , env , saveFarmwareEnv : saveOrEditFarmwareEnv ( props . resources . index ) , timeSettings : maybeGetTimeSettings ( props . resources . index ) , alerts : getAllAlerts ( props . resources ) , } ; }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any[]$ O $any$ O $any$ O $TimeSettings$ O O O O O O O $SourceFbosConfig$ O $SourceFwConfig$ O O O O O O $string$ O $any$ O $any$ O $boolean$ O $boolean$ O O O O O O $SaveFarmwareEnv$ O $complex$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any[]$ O O O O O O $Props$ O $Everything$ O O O O $any$ O O $Everything$ O $BotState$ O O $any$ O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $any$ O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $string$ O $string$ O $Everything$ O $BotState$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $string$ O $any$ O $string$ O O O O $boolean$ O $boolean$ O $string$ O $Everything$ O $BotState$ O $complex$ O $string$ O O O $any$ O $boolean$ O $any$ O $Feature.api_farmware_env$ O O $complex$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $Everything$ O $BotState$ O $any$ O $any$ O O O $ConnectionStatus$ O $Everything$ O $BotState$ O $ConnectionState$ O $complex$ O O O O $ConnectionStatus$ O $Everything$ O $BotState$ O $ConnectionState$ O $complex$ O O O O $ConnectionStatus$ O $Everything$ O $BotState$ O $ConnectionState$ O $complex$ O O O O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $AuthState$ O $Everything$ O $AuthState$ O $BotState$ O $Everything$ O $BotState$ O $Function$ O $Everything$ O $Function$ O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $ResourceIndex$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $SourceFbosConfig$ O $SourceFbosConfig$ O $any$ O $any$ O $any$ O O $SourceFwConfig$ O $SourceFwConfig$ O $any$ O $any$ O $any$ O O $boolean$ O $any$ O $boolean$ O O O $any$ O $any$ O $SaveFarmwareEnv$ O $SaveFarmwareEnv$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $TimeSettings$ O $TimeSettings$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O O O O O
import { isString } from "s" ; import { TaggedDevice } from "s" ; import { edit , save } from "s" ; const maybeResolveTZ = ( ) : string | undefined => Intl && Intl . DateTimeFormat && Intl . DateTimeFormat ( ) . resolvedOptions ( ) . timeZone ; export const inferTimezone = ( current : string | undefined ) : string => current || maybeResolveTZ ( ) || "s" ; export function timezoneMismatch ( botTime : string | undefined , userTime : string | undefined = maybeResolveTZ ( ) ) { if ( isString ( botTime ) && isString ( userTime ) ) { return botTime . toUpperCase ( ) !== userTime . toUpperCase ( ) ; } else { return false ; } } export function maybeSetTimezone ( dispatch , device ) { if ( ! device . body . timezone ) { dispatch ( edit ( device , { timezone : inferTimezone ( undefined ) } ) ) ; dispatch ( save ( device . uuid ) ) ; } }	O O $any$ O O O O O O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O $any$ O O O O O $string$ O O O O O O O O $any$ O $any$ O $complex$ O $any$ O $complex$ O O O $ResolvedDateTimeFormatOptions$ O O O $string$ O O O $string$ O O $string$ O O O O O O O O $string$ O $string$ O O O O O O O $boolean$ O $string$ O O O O O $string$ O O O O O $string$ O O O O O O $any$ O $string$ O O $any$ O $string$ O O O O $string$ O $string$ O O O $string$ O $string$ O O O O O O O O O O O O O $void$ O $Function$ O $TaggedDevice$ O O O O O $any$ O $any$ O $any$ O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O O $string$ O $string$ O $undefined$ O O O O O $Function$ O $any$ O $any$ O $any$ O O O O O
import { inferTimezone } from "s" ; import { get , set } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const tz = "s" ; expect ( inferTimezone ( tz ) ) . toBe ( tz ) ; } ) ; it ( "s" , ( ) => { const oldIntl = get ( window , "s" , undefined ) ; set ( window , "s" , undefined ) ; expect ( inferTimezone ( undefined ) ) . toBe ( "s" ) ; set ( window , "s" , oldIntl ) ; } ) ; } ) ;	O O $string$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O $any$ O $string$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $complex$ O O O $undefined$ O O $any$ O $complex$ O O O $undefined$ O O $any$ O $string$ O $undefined$ O O O $any$ O O O O $any$ O $complex$ O O O $any$ O O O O O O O O
export let list = [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ;	O O $string[]$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { list } from "s" ; test ( "s" , ( ) => { expect ( list . length ) . toBe ( 0 ) ; } ) ;	O O $string[]$ O O O O $any$ O O O O O O O $any$ O $string[]$ O $number$ O O $any$ O O O O O O O
import { TransferProps } from "s" ; import axios from "s" ; import { API } from "s" ; export async function createTransferCert ( input ) < string > { const { email , password } = input ; const params = { email , password } ; const { data } = await axios . post < string > ( API . current . transferCertPath , params ) ; return Promise . resolve ( data ) ; }	O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $Promise$ O $TransferProps$ O O O O O O O $string$ O $string$ O O $TransferProps$ O O $complex$ O O $string$ O $string$ O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $API$ O $string$ O $complex$ O O O $PromiseConstructor$ O $complex$ O $any$ O O O
import { Farmbot } from "s" ; import { createTransferCert } from "s" ; import { toPairs } from "s" ; import { getDevice } from "s" ; export interface TransferProps { email : string ; password : string ; device : Farmbot ; } export async function transferOwnership ( input ) < void > { const { email , device } = input ; try { const secret = await createTransferCert ( input ) ; const body = toPairs ( { email , secret } ) ; await device . send ( getDevice ( ) . rpcShim ( [ { kind : "s" , args : { } , body } ] ) ) ; return Promise . resolve ( ) ; } catch ( error ) { return Promise . reject ( error ) ; } }	O O $any$ O O O O O O $Promise<string>$ O O O O O O $any[]$ O O O O O O $any$ O O O O O O $any$ O $string$ O O O $string$ O O O $any$ O $any$ O O O O O $Promise$ O $TransferProps$ O O O O O O O $string$ O $any$ O O $TransferProps$ O O O O $string$ O O $Promise<string>$ O $TransferProps$ O O O $any[]$ O $any[]$ O O $string$ O $string$ O O O O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O O O ${}$ O O O O $any[]$ O O O O O O $PromiseConstructor$ O $complex$ O O O O O O $any$ O O O $PromiseConstructor$ O $Promise<T>$ O $any$ O O O O
const mockDevice = { send : jest . fn ( ( ) => { return Promise . resolve ( ) ; } ) } ; jest . mock ( "s" , ( ) => ( { getDevice : ( ) => ( mockDevice ) } ) ) ; jest . mock ( "s" , ( ) => { return { post : jest . fn ( ( ) => { return Promise . reject ( "s" ) ; } ) } ; } ) ; import { transferOwnership } from "s" ; import { getDevice } from "s" ; import { submitOwnershipChange } from "s" ; import { API } from "s" ; import { error } from "s" ; API . setBaseUrl ( "s" ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const p = { email : "s" , password : "s" , server : "s" , device : getDevice ( ) } ; try { await transferOwnership ( p ) ; fail ( "s" ) ; } catch ( error ) { expect ( error ) . toEqual ( "s" ) ; } } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await submitOwnershipChange ( { email : "s" , password : "s" } ) ; expect ( error ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ;	O $complex$ O O $any$ O $any$ O $any$ O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O $complex$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O O O O O O O O O $Promise<void>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O $any$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $any$ O $any$ O O O O O O O $Promise<void>$ O $complex$ O O $any$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $string$ O O O $string$ O O O O O $any$ O $void$ O O $any$ O O O O O O O O O O
const mockDevice = { moveRelative : jest . fn ( ( ) => { return Promise . resolve ( ) ; } ) , } ; jest . mock ( "s" , ( ) => ( { getDevice : ( ) => ( mockDevice ) } ) ) ; jest . mock ( "s" , ( ) => { return { post : jest . fn ( ( ) => ( { data : "s" } ) ) } ; } ) ; import { createTransferCert } from "s" ; import { getDevice } from "s" ; import axios from "s" ; import { API } from "s" ; API . setBaseUrl ( "s" ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const p = { email : "s" , password : "s" , server : "s" , device : getDevice ( ) } ; const x = await createTransferCert ( p ) ; expect ( x ) . toBe ( "s" ) ; expect ( axios . post ) . toHaveBeenCalled ( ) ; const url = "s" ; const data = { "s" : "s" , "s" : "s" } ; expect ( axios . post ) . toHaveBeenCalledWith ( url , data ) ; } ) ; } ) ;	O $complex$ O O $any$ O $any$ O $any$ O O O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O $complex$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O O O O O O O O O O $Promise<string>$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $any$ O $any$ O O O O O $string$ O O $Promise<string>$ O $complex$ O O $any$ O $string$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O $complex$ O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $complex$ O O O O O O O O
const mockDevice = { send : jest . fn ( ( ) => Promise . resolve ( ) ) , rpcShim : jest . fn ( ( ) => Promise . resolve ( ) ) , } ; jest . mock ( "s" , ( ) => ( { getDevice : ( ) => ( mockDevice ) } ) ) ; jest . mock ( "s" , ( ) => { return { post : jest . fn ( ( ) => ( { data : "s" } ) ) } ; } ) ; import { transferOwnership } from "s" ; import { getDevice } from "s" ; import { API } from "s" ; API . setBaseUrl ( "s" ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const p = { email : "s" , password : "s" , server : "s" , device : getDevice ( ) } ; const x = await transferOwnership ( p ) ; expect ( x ) . toBe ( undefined ) ; expect ( mockDevice . send ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	O $complex$ O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O $complex$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O O O O O O O O O O O O $Promise<void>$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $any$ O $any$ O O O O O $void$ O O $Promise<void>$ O $complex$ O O $any$ O $void$ O O $any$ O $undefined$ O O $any$ O $complex$ O $any$ O O $any$ O O O O O O O O O
import { DataXfer , DataXferIntent , DataXferBase } from "s" ; import { SequenceBodyItem as Step , uuid as id } from "s" ; import { Everything } from "s" ; import { ReduxAction } from "s" ; import * as React from "s" ; import { Actions } from "s" ; export const STEP_DATATRANSFER_IDENTIFER = "s" ; export function stepPut ( value , ev : React . DragEvent < HTMLElement > , intent , draggerId ) < DataXferBase > { const uuid = id ( ) ; ev . dataTransfer . setData ( STEP_DATATRANSFER_IDENTIFER , uuid ) ; return { type : Actions . PUT_DATA_XFER , payload : { intent , uuid , value , draggerId } } ; } export function stepGet ( uuid ) { return function ( dispatch , getState : ( ) => Everything ) : DataXfer { const obj = getState ( ) . draggable . dataTransfer [ uuid ] ; if ( obj && obj . intent ) { dispatch ( { type : Actions . DROP_DATA_XFER , payload : uuid } ) ; return obj ; } else { throw new Error ( `template` ) ; } } ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O O O O O O O O O $ReduxAction$ O $Step$ O $any$ O $any$ O $any$ O $complex$ O O $DataXferIntent$ O $number$ O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O $Actions.PUT_DATA_XFER$ O $any$ O $Actions.PUT_DATA_XFER$ O $complex$ O O $DataXferIntent$ O $any$ O $any$ O $number$ O O O O O O $DataXfer$ O $string$ O O O O O $Function$ O $Everything$ O O O O $any$ O O $any$ O O $DataXfer$ O $Everything$ O O O $DraggableState$ O $complex$ O $string$ O O O O $DataXfer$ O $DataXfer$ O $DataXferIntent$ O O $Function$ O O $Actions$ O $any$ O $Actions.DROP_DATA_XFER$ O $string$ O $string$ O O O O $DataXfer$ O O O O O O $ErrorConstructor$ O O O O O O O O
import { stepGet } from "s" ; import { fakeState } from "s" ; import { DataXfer } from "s" ; describe ( "s" , ( ) => { const state = fakeState ( ) ; const dataXferObj = { draggerId : 0 , uuid : "s" , intent : "s" , value : { kind : "s" , args : { } } } ; state . draggable . dataTransfer = { "s" : dataXferObj } ; it ( "s" , ( ) => { const step = stepGet ( "s" ) ( jest . fn ( ) , ( ) => state ) ; expect ( step ) . toEqual ( dataXferObj ) ; } ) ; it ( "s" , ( ) => { const badUuid = ( ) => stepGet ( "s" ) ( jest . fn ( ) , ( ) => state ) ; expect ( badUuid ) . toThrow ( "s" ) ; } ) ; } ) ;	O O $DataXfer$ O O O O O O $Everything$ O O O O O O $any$ O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $DataXfer$ O O $number$ O O O $string$ O O O O O O O $complex$ O O $string$ O O O ${}$ O O O O O O $Everything$ O $DraggableState$ O $complex$ O O O O $StepSpliceDataXfer$ O O $any$ O O O O O O O O $DataXfer$ O $DataXfer$ O O O O $any$ O $any$ O O O O O O $Everything$ O O $any$ O $DataXfer$ O O $any$ O $StepSpliceDataXfer$ O O O O O $any$ O O O O O O O O $DataXfer$ O O O O $DataXfer$ O O O O $any$ O $any$ O O O O O O $Everything$ O O $any$ O $DataXfer$ O O $any$ O O O O O O O O O O
import { draggableReducer } from "s" ; import { DraggableState } from "s" ; import { Actions } from "s" ; describe ( "s" , ( ) => { function emptyState ( ) { return { dataTransfer : { "s" : { draggerId : 0 , value : { kind : "s" , args : { milliseconds : 0 } } , uuid : "s" , intent : "s" } } } ; } it ( "s" , ( ) => { const payload = { uuid : "s" } ; const action = { type : Actions . PUT_DATA_XFER , payload } ; const nextState = draggableReducer ( emptyState ( ) , action ) ; const dt = nextState . dataTransfer ; expect ( Object . keys ( dt ) ) . toContain ( payload . uuid ) ; const entry = dt [ payload . uuid ] ; expect ( entry && entry . uuid ) . toEqual ( payload . uuid ) ; } ) ; it ( "s" , ( ) => { const payload = "s" ; const action = { type : Actions . DROP_DATA_XFER , payload } ; const nextState = draggableReducer ( emptyState ( ) , action ) ; expect ( Object . keys ( nextState . dataTransfer ) . length ) . toEqual ( 0 ) ; } ) ; } ) ;	O O $generateReducer<DraggableState>.GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $DraggableState$ O O O O O $complex$ O O O O O $number$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O $complex$ O O $Actions$ O $any$ O $Actions.PUT_DATA_XFER$ O $complex$ O O O $DraggableState$ O $generateReducer<DraggableState>.GeneratedReducer$ O $DraggableState$ O O O $complex$ O O O $complex$ O $DraggableState$ O $complex$ O $any$ O $ObjectConstructor$ O $complex$ O $complex$ O O O $any$ O $complex$ O $string$ O O O $DataXfer$ O $complex$ O $complex$ O $string$ O O $any$ O $DataXfer$ O $DataXfer$ O $string$ O O $any$ O $complex$ O $string$ O O O O O $any$ O O O O O O O O O O O O O $complex$ O O $Actions$ O $any$ O $Actions.DROP_DATA_XFER$ O $string$ O O O $DraggableState$ O $generateReducer<DraggableState>.GeneratedReducer$ O $DraggableState$ O O O $complex$ O O $any$ O $ObjectConstructor$ O $complex$ O $DraggableState$ O $complex$ O O $number$ O O $any$ O O O O O O O O O O
const BASE = "s" ; export const DATA_URI = "s" ; export const DEFAULT_ICON = "s" ; export interface OFCropAttrs { svg_icon ? : string | undefined ; spread ? : number | undefined ; slug : string ; } export interface OFCropResponse { id ? : undefined ; data ? : { attributes ? : OFCropAttrs | undefined ; } ; } export namespace OpenFarmAPI { export let OFBaseURL = BASE ; } export function svgToUrl ( xml : string | undefined ) { return xml ? ( DATA_URI + encodeURIComponent ( xml ) ) : DEFAULT_ICON ; }	O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O $number$ O O O O O O $string$ O O O O O O $any$ O $undefined$ O O O O $complex$ O O O $OFCropAttrs$ O O $any$ O O O O O O O O $any$ O O O $string$ O O O O O O $string$ O $string$ O O O O O O O $string$ O O O O $string$ O $string$ O O O O O O
import { BotOriginQuadrant , isBotOriginQuadrant } from "s" ; import { McuParams } from "s" ; import { StepsPerMmXY } from "s" ; import { CheckedAxisLength , AxisNumberProperty , BotSize , MapTransformProps , Mode } from "s" ; import { trim } from "s" ; import { history , getPathArray } from "s" ; import { savedGardenOpen } from "s" ; const SNAP = 0 ; export function round ( num ) { return ( Math . round ( num / SNAP ) * SNAP ) ; } export enum MapPanelStatus { open = "s" , closed = "s" , short = "s" , } export const getPanelStatus = ( ) : MapPanelStatus => { if ( history . getCurrentLocation ( ) . pathname === "s" ) { return MapPanelStatus . closed ; } const mode = getMode ( ) ; if ( window . innerWidth <= 0 && ( mode === Mode . moveTo || mode === Mode . clickToAdd ) ) { return MapPanelStatus . short ; } return MapPanelStatus . open ; } ; export const mapPanelClassName = ( ) => { switch ( getPanelStatus ( ) ) { case MapPanelStatus . short : return "s" ; case MapPanelStatus . closed : return "s" ; case MapPanelStatus . open : default : return "s" ; } } ; const getMapPadding = ( panelStatus ) : { left : number , top : number } => { switch ( panelStatus ) { case MapPanelStatus . short : return { left : 0 , top : 0 } ; case MapPanelStatus . closed : return { left : 0 , top : 0 } ; case MapPanelStatus . open : default : return { left : 0 , top : 0 } ; } } ; const leftOrTop < "s" | "s" , "s" | "s" > = { x : "s" , y : "s" } ; type XYCoordinate = { x : number , y : number } ; export interface ScreenToGardenParams { page : XYCoordinate ; scroll : { left : number , top : number } ; zoomLvl : number ; mapTransformProps : MapTransformProps ; gridOffset : AxisNumberProperty ; panelStatus : MapPanelStatus ; } export function translateScreenToGarden ( params ) { const { page , scroll , zoomLvl , mapTransformProps , gridOffset , panelStatus } = params ; const { xySwap } = mapTransformProps ; const mapPadding = getMapPadding ( panelStatus ) ; const screenXY = page ; const mapXY = [ "s" , "s" ] . reduce < XYCoordinate > ( ( result , axis : "s" | "s" ) => { const unscrolled = screenXY [ axis ] + scroll [ leftOrTop [ axis ] ] ; const map = unscrolled - mapPadding [ leftOrTop [ axis ] ] ; const grid = map - gridOffset [ axis ] * zoomLvl ; const unscaled = round ( grid / zoomLvl ) ; result [ axis ] = unscaled ; return result ; } , { x : 0 , y : 0 } ) ; const coordinate = xySwap ? { x : mapXY . y , y : mapXY . x } : mapXY ; const gardenXY = transformXY ( coordinate . x , coordinate . y , mapTransformProps ) ; return xySwap ? { x : gardenXY . qy , y : gardenXY . qx } : { x : gardenXY . qx , y : gardenXY . qy } ; } const NORMAL_QUADRANTS < "s" | "s" , BotOriginQuadrant [ ] > = { x : [ 0 , 0 ] , y : [ 0 , 0 ] } ; const MIRRORED_QUADRANTS < "s" | "s" , BotOriginQuadrant [ ] > = { x : [ 0 , 0 ] , y : [ 0 , 0 ] } ; interface QuadTransformParams { coordinate : XYCoordinate ; mapTransformProps : MapTransformProps ; } function quadTransform ( params ) { const { coordinate , mapTransformProps } = params ; const { gridSize , quadrant } = mapTransformProps ; if ( isBotOriginQuadrant ( quadrant ) ) { return [ "s" , "s" ] . reduce < XYCoordinate > ( ( result , axis : "s" | "s" ) => { switch ( quadrant ) { case MIRRORED_QUADRANTS [ axis ] [ 0 ] : case MIRRORED_QUADRANTS [ axis ] [ 0 ] : result [ axis ] = gridSize [ axis ] - coordinate [ axis ] ; return result ; case NORMAL_QUADRANTS [ axis ] [ 0 ] : case NORMAL_QUADRANTS [ axis ] [ 0 ] : result [ axis ] = coordinate [ axis ] ; return result ; default : throw new Error ( `template` ) ; } } , { x : 0 , y : 0 } ) ; } else { throw new Error ( "s" ) ; } } export function transformXY ( x , y , rawMapTransformProps ) : { qx : number , qy : number } { const { quadrant , gridSize , xySwap } = rawMapTransformProps ; const coordinate = { x : xySwap ? y : x , y : xySwap ? x : y , } ; const transformed = quadTransform ( { coordinate , mapTransformProps : { quadrant , gridSize : { x : xySwap ? gridSize . y : gridSize . x , y : xySwap ? gridSize . x : gridSize . y , } , xySwap } } ) ; return { qx : transformed . x , qy : transformed . y } ; } export function getBotSize ( botMcuParams , stepsPerMmXY , defaultLength ) { const stopAtMaxXY = { x : ! ! botMcuParams . movement_stop_at_max_x , y : ! ! botMcuParams . movement_stop_at_max_y } ; const axisLengthXY = { x : botMcuParams . movement_axis_nr_steps_x || 0 , y : botMcuParams . movement_axis_nr_steps_y || 0 } ; const getAxisLength = ( axis : "s" | "s" ) : CheckedAxisLength => { const axisStepsPerMm = stepsPerMmXY [ axis ] ; if ( axisStepsPerMm && axisLengthXY [ axis ] !== 0 && stopAtMaxXY [ axis ] ) { return { value : axisLengthXY [ axis ] / axisStepsPerMm , isDefault : false } ; } else { return { value : defaultLength [ axis ] , isDefault : true } ; } } ; return { x : getAxisLength ( "s" ) , y : getAxisLength ( "s" ) } ; } export function getMapSize ( mapTransformProps , gridOffset ) : { w : number , h : number } { const { gridSize , xySwap } = mapTransformProps ; const mapSize = { x : gridSize . x + gridOffset . x * 0 , y : gridSize . y + gridOffset . y * 0 } ; return { w : xySwap ? mapSize . y : mapSize . x , h : xySwap ? mapSize . x : mapSize . y } ; } export const transformForQuadrant = ( mapTransformProps ) : string => { const quadrantFlips = ( ) => { switch ( mapTransformProps . quadrant ) { case 0 : return { x : - 0 , y : 0 } ; case 0 : return { x : 0 , y : 0 } ; case 0 : return { x : 0 , y : - 0 } ; case 0 : return { x : - 0 , y : - 0 } ; default : return { x : 0 , y : 0 } ; } } ; const origin = transformXY ( 0 , 0 , mapTransformProps ) ; const flip = quadrantFlips ( ) ; const translate = { x : flip . x * origin . qx , y : flip . y * origin . qy } ; return trim ( `template` ) ; } ; export const getMode = ( ) : Mode => { const pathArray = getPathArray ( ) ; if ( pathArray ) { if ( ( pathArray [ 0 ] === "s" ) && pathArray [ 0 ] ) { return Mode . addPointToGroup ; } if ( pathArray [ 0 ] === "s" ) { return Mode . clickToAdd ; } if ( ! isNaN ( parseInt ( pathArray . slice ( - 0 ) [ 0 ] ) ) ) { return Mode . editPlant ; } if ( pathArray [ 0 ] === "s" ) { return Mode . editPlant ; } if ( pathArray [ 0 ] === "s" ) { return Mode . editPlant ; } if ( pathArray [ 0 ] === "s" ) { return Mode . boxSelect ; } if ( pathArray [ 0 ] === "s" ) { return Mode . addPlant ; } if ( pathArray [ 0 ] === "s" ) { return Mode . moveTo ; } if ( pathArray [ 0 ] === "s" ) { if ( pathArray [ 0 ] === "s" ) { return Mode . createPoint ; } return Mode . points ; } if ( savedGardenOpen ( pathArray ) ) { return Mode . templateView ; } } return Mode . none ; } ; export const getGardenCoordinates = ( props : { mapTransformProps : MapTransformProps , gridOffset : AxisNumberProperty , pageX : number , pageY : number , } ) : AxisNumberProperty | undefined => { const el = document . querySelector ( "s" ) ; const map = document . querySelector ( "s" ) ; const page = document . querySelector ( "s" ) ; if ( el && map && page ) { const zoomLvl = parseFloat ( window . getComputedStyle ( map ) . zoom || "s" ) ; const params = { page : { x : props . pageX , y : props . pageY } , scroll : { left : page . scrollLeft , top : map . scrollTop * zoomLvl } , mapTransformProps : props . mapTransformProps , gridOffset : props . gridOffset , zoomLvl , panelStatus : getPanelStatus ( ) , } ; return translateScreenToGarden ( params ) ; } else { return undefined ; } } ; export const maybeNoPointer = ( defaultStyle : React . CSSProperties ) : React . SVGProps < SVGGElement > [ "s" ] => { switch ( getMode ( ) ) { case Mode . boxSelect : case Mode . clickToAdd : case Mode . moveTo : case Mode . points : case Mode . createPoint : return { "s" : "s" } ; default : return defaultStyle ; } } ;	O O $any$ O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O $number$ O $number$ O O O O $Math$ O $number$ O $number$ O O O O O O O O O O $any$ O $MapPanelStatus.open$ O O O $MapPanelStatus.closed$ O O O $MapPanelStatus.short$ O O O O O O $MapPanelStatus$ O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O O $any$ O $MapPanelStatus.closed$ O O O $Mode$ O $Mode$ O O O O O $complex$ O $number$ O O O O $Mode$ O $any$ O $Mode.moveTo$ O $complex$ O $any$ O $Mode.clickToAdd$ O O O O $any$ O $MapPanelStatus.short$ O O O $any$ O $MapPanelStatus.open$ O O O O O $complex$ O O O O O O O $MapPanelStatus$ O O O O O $any$ O $MapPanelStatus.short$ O O O O O $any$ O $MapPanelStatus.closed$ O O O O O $any$ O $MapPanelStatus.open$ O O O O O O O O O O $complex$ O O $MapPanelStatus$ O O O $number$ O O O $number$ O O O O O O O $MapPanelStatus$ O O O $any$ O $MapPanelStatus.short$ O O O $number$ O O O $number$ O O O O O $any$ O $MapPanelStatus.closed$ O O O $number$ O O O $number$ O O O O O $any$ O $MapPanelStatus.open$ O O O O O $number$ O O O $number$ O O O O O O O O $Record$ O O O O O O O O O O O O O O O O O O O O O $any$ O O $number$ O O O $number$ O O O O O O $any$ O $XYCoordinate$ O $any$ O $complex$ O O $number$ O O O $number$ O O O O $number$ O O O $MapTransformProps$ O $any$ O $complex$ O $any$ O $MapPanelStatus$ O $any$ O O O O $XYCoordinate$ O $ScreenToGardenParams$ O O O O $XYCoordinate$ O $complex$ O $number$ O $MapTransformProps$ O $complex$ O $MapPanelStatus$ O O $ScreenToGardenParams$ O O O $boolean$ O O $MapTransformProps$ O O $complex$ O $complex$ O $MapPanelStatus$ O O O $XYCoordinate$ O $XYCoordinate$ O O $XYCoordinate$ O O O O O O O $complex$ O $any$ O O O $XYCoordinate$ O O O O O O O O O O $number$ O $XYCoordinate$ O O O O $complex$ O $complex$ O O O O O O $number$ O $number$ O $complex$ O $complex$ O O O O O O $number$ O $number$ O $complex$ O O O O $number$ O O $number$ O $number$ O $number$ O $number$ O O $XYCoordinate$ O O O O $number$ O O $XYCoordinate$ O O O O $number$ O O O $number$ O O O O O O $XYCoordinate$ O $boolean$ O O $number$ O $XYCoordinate$ O $number$ O $number$ O $XYCoordinate$ O $number$ O O $XYCoordinate$ O O $complex$ O $complex$ O $XYCoordinate$ O $number$ O $XYCoordinate$ O $number$ O $MapTransformProps$ O O O $boolean$ O O $number$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O O O $number$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O O O O $Record$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $Record$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $any$ O $XYCoordinate$ O $any$ O $MapTransformProps$ O $any$ O O O $XYCoordinate$ O $QuadTransformParams$ O O O O $XYCoordinate$ O $MapTransformProps$ O O $QuadTransformParams$ O O O $complex$ O $BotOriginQuadrant$ O O $MapTransformProps$ O O O $complex$ O $BotOriginQuadrant$ O O O O O O O O O O $complex$ O $any$ O O O $XYCoordinate$ O O O O O O O O O O O $BotOriginQuadrant$ O O O $complex$ O O O O O O O O $complex$ O O O O O O O $XYCoordinate$ O O O O $complex$ O O O O $XYCoordinate$ O O O O O $XYCoordinate$ O O $complex$ O O O O O O O O $complex$ O O O O O O O $XYCoordinate$ O O O O $XYCoordinate$ O O O O O $XYCoordinate$ O O O O O $ErrorConstructor$ O O O O O O O O $number$ O O O $number$ O O O O O O O O O O $ErrorConstructor$ O O O O O O O O $complex$ O $number$ O $number$ O $MapTransformProps$ O O O $number$ O O O $number$ O O O O O O $BotOriginQuadrant$ O $complex$ O $boolean$ O O $MapTransformProps$ O O $complex$ O O $number$ O $boolean$ O $number$ O $number$ O $number$ O $boolean$ O $number$ O $number$ O O O O $XYCoordinate$ O $XYCoordinate$ O O $complex$ O $complex$ O O $BotOriginQuadrant$ O $complex$ O O $number$ O $boolean$ O $complex$ O $number$ O $complex$ O $number$ O $number$ O $boolean$ O $complex$ O $number$ O $complex$ O $number$ O O O $boolean$ O O O O O O $number$ O $XYCoordinate$ O $number$ O $number$ O $XYCoordinate$ O $number$ O O O O O $BotSize$ O $McuParams$ O $StepsPerMmXY$ O $AxisNumberProperty$ O O O $complex$ O O $boolean$ O O O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $CheckedAxisLength$ O O O O O O O O O $any$ O O O $number$ O $complex$ O O O O O O $number$ O $complex$ O O O O O O $complex$ O O O O O O O $number$ O $complex$ O O O O $number$ O $false$ O O O O O O O O O $number$ O $complex$ O O O O $true$ O O O O O O O O O $CheckedAxisLength$ O $CheckedAxisLength$ O O O O $CheckedAxisLength$ O $CheckedAxisLength$ O O O O O O O O $complex$ O $MapTransformProps$ O $AxisNumberProperty$ O O O $number$ O O O $number$ O O O O O O $complex$ O $boolean$ O O $MapTransformProps$ O O $complex$ O O $number$ O $complex$ O $number$ O $complex$ O $number$ O O O $number$ O $complex$ O $number$ O $complex$ O $number$ O O O O O O $number$ O $boolean$ O $complex$ O $number$ O $complex$ O $number$ O $number$ O $boolean$ O $complex$ O $number$ O $complex$ O $number$ O O O O O $string$ O O $MapTransformProps$ O O O O O O $complex$ O O O O O O O $MapTransformProps$ O $BotOriginQuadrant$ O O O O O O O $number$ O O O O $number$ O O O O O O O O O $number$ O O O $number$ O O O O O O O O O $number$ O O O $number$ O O O O O O O O O O $number$ O O O O $number$ O O O O O O O O O $number$ O O O $number$ O O O O O O O O $complex$ O $complex$ O O O O O $MapTransformProps$ O O O $complex$ O $complex$ O O O O $complex$ O O $number$ O $complex$ O $number$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O $complex$ O $number$ O O O $string$ O O O O O O O O $Mode$ O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O $Mode.addPointToGroup$ O O O O $any$ O O O O O O O O $any$ O $Mode.clickToAdd$ O O O O O $boolean$ O $number$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $Mode.editPlant$ O O O O $any$ O O O O O O O O $any$ O $Mode.editPlant$ O O O O $any$ O O O O O O O O $any$ O $Mode.editPlant$ O O O O $any$ O O O O O O O O $any$ O $Mode.boxSelect$ O O O O $any$ O O O O O O O O $any$ O $Mode.addPlant$ O O O O $any$ O O O O O O O O $any$ O $Mode.moveTo$ O O O O $any$ O O O O O O O O O $any$ O O O O O O O O $any$ O $Mode.createPoint$ O O O $any$ O $Mode.points$ O O O O $any$ O $any$ O O O O $any$ O $Mode.templateView$ O O O O $any$ O $Mode.none$ O O O O O $complex$ O O $complex$ O O $MapTransformProps$ O $any$ O $complex$ O $any$ O $number$ O O O $number$ O O O O O O $any$ O O O O O $Element$ O $Document$ O O O O O O O $Element$ O $Document$ O O O O O O O $Element$ O $Document$ O O O O O O O O $Element$ O $Element$ O $Element$ O O O $number$ O $number$ O $complex$ O $CSSStyleDeclaration)$ O $Element$ O O $string$ O O O O O $ScreenToGardenParams$ O O $complex$ O O $number$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O O $complex$ O O $number$ O $Element$ O $number$ O $number$ O $Element$ O $number$ O $number$ O O $MapTransformProps$ O $complex$ O $MapTransformProps$ O $complex$ O $complex$ O $complex$ O $number$ O $MapPanelStatus$ O $MapPanelStatus$ O O O O O O $XYCoordinate$ O $ScreenToGardenParams$ O O O O O O $undefined$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $complex$ O O O O O O O O $Mode$ O O O O O $any$ O $Mode.boxSelect$ O O $any$ O $Mode.clickToAdd$ O O $any$ O $Mode.moveTo$ O O $any$ O $Mode.points$ O O $any$ O $Mode.createPoint$ O O O O O O O O O O O $any$ O O O O
import { MovePlantProps , DraggableEvent } from "s" ; import { defensiveClone } from "s" ; import { edit , overwrite } from "s" ; import { history } from "s" ; import { Actions } from "s" ; import { svgToUrl , DEFAULT_ICON } from "s" ; import { Mode } from "s" ; import { clamp , uniq } from "s" ; import { GetState } from "s" ; import { fetchGroupFromUrl } from "s" ; import { TaggedPoint } from "s" ; import { getMode } from "s" ; export function movePlant ( payload ) { const tr = payload . plant ; const update = defensiveClone ( payload . plant ) . body ; update . x += payload . deltaX ; update . y += payload . deltaY ; update . x = clamp ( update . x , 0 , payload . gridSize . x ) ; update . y = clamp ( update . y , 0 , payload . gridSize . y ) ; return edit ( tr , update ) ; } export const selectPlant = ( payload : string [ ] | undefined ) => { return { type : Actions . SELECT_PLANT , payload } ; } ; export const toggleHoveredPlant = ( plantUUID : string | undefined , icon ) => { return { type : Actions . TOGGLE_HOVERED_PLANT , payload : { plantUUID , icon } } ; } ; export const clickMapPlant = ( clickedPlantUuid , icon ) => { return ( dispatch , getState ) => { dispatch ( selectPlant ( [ clickedPlantUuid ] ) ) ; dispatch ( toggleHoveredPlant ( clickedPlantUuid , icon ) ) ; const isEditingGroup = getMode ( ) === Mode . addPointToGroup ; if ( isEditingGroup ) { const { resources } = getState ( ) ; const group = fetchGroupFromUrl ( resources . index ) ; const point = resources . index . references [ clickedPlantUuid ] as TaggedPoint | undefined ; if ( group && point && point . body . id ) { type Body = ( typeof group ) [ "s" ] ; const nextGroup = ( { ... group . body , point_ids : [ ... group . body . point_ids ] } ) ; nextGroup . point_ids . push ( point . body . id ) ; nextGroup . point_ids = uniq ( nextGroup . point_ids ) ; dispatch ( overwrite ( group , nextGroup ) ) ; } } } ; } ; export const unselectPlant = ( dispatch ) => ( ) => { dispatch ( selectPlant ( undefined ) ) ; dispatch ( toggleHoveredPlant ( undefined , "s" ) ) ; dispatch ( { type : Actions . HOVER_PLANT_LIST_ITEM , payload : undefined } ) ; } ; export const closePlantInfo = ( dispatch ) => ( ) => { const mode = getMode ( ) ; if ( mode == Mode . editPlant || mode == Mode . boxSelect ) { unselectPlant ( dispatch ) ( ) ; history . push ( "s" ) ; } } ; export const setDragIcon = ( icon : string | undefined ) => ( e ) => { const dragImg = new Image ( ) ; dragImg . src = icon ? svgToUrl ( icon ) : DEFAULT_ICON ; const width = dragImg . naturalWidth ; const height = dragImg . naturalHeight ; e . dataTransfer . setDragImage && e . dataTransfer . setDragImage ( dragImg , width / 0 , height / 0 ) ; } ;	O O $any$ O $any$ O O O O O O $T$ O O O O O O $ReduxAction<EditResourceParams>$ O $ReduxAction<EditResourceParams>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Mode$ O O O O O O $ReduxAction<EditResourceParams>$ O $MovePlantProps$ O O O $any$ O $MovePlantProps$ O $any$ O O $any$ O $T$ O $MovePlantProps$ O $any$ O O $any$ O $any$ O $any$ O $MovePlantProps$ O $number$ O $any$ O $any$ O $MovePlantProps$ O $number$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $MovePlantProps$ O $complex$ O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $MovePlantProps$ O $complex$ O $number$ O O O $ReduxAction<EditResourceParams>$ O $any$ O $any$ O O O O O $complex$ O O $string[]$ O O O O O O O O O O O $Actions$ O $any$ O $Actions.SELECT_PLANT$ O $string[]$ O O O O O O $complex$ O O $string$ O O O O O $string$ O O O O O $Actions$ O $any$ O $Actions.TOGGLE_HOVERED_PLANT$ O $complex$ O O $string$ O $string$ O O O O O O O $void$ O O $string$ O $string$ O O O O O $Function$ O $GetState$ O O O $Function$ O $complex$ O O $string$ O O O O $Function$ O $complex$ O $string$ O $string$ O O O O $boolean$ O $Mode$ O O O $any$ O $Mode.addPointToGroup$ O O O $boolean$ O O O O $RestResources$ O O $GetState$ O O O O $any$ O $any$ O $RestResources$ O $ResourceIndex$ O O O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $string$ O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O O O O O $Body$ O O O O $any$ O $any$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O $any$ O O O O O O O O O O O $void$ O O $Function$ O O O O O O $Function$ O $complex$ O $undefined$ O O O $Function$ O $complex$ O $undefined$ O O O O O $Function$ O O $Actions$ O $any$ O $Actions.HOVER_PLANT_LIST_ITEM$ O $undefined$ O $undefined$ O O O O O O O $void$ O O $Function$ O O O O O O O $Mode$ O $Mode$ O O O O O $Mode$ O $any$ O $Mode.editPlant$ O $complex$ O $any$ O $Mode.boxSelect$ O O $void$ O $Function$ O O O O $any$ O $any$ O O O O O O O O O $void$ O O $string$ O O O O O O O $DraggableEvent$ O O O O $HTMLImageElement$ O O $HTMLImageElement$ O O O $HTMLImageElement$ O $string$ O $string$ O $string$ O $string$ O O O O O $number$ O $HTMLImageElement$ O $number$ O O $number$ O $HTMLImageElement$ O $number$ O $DraggableEvent$ O $complex$ O $Function$ O $DraggableEvent$ O $complex$ O $Function$ O $HTMLImageElement$ O $number$ O O O $number$ O O O O O O
let mockPath = "s" ; jest . mock ( "s" , ( ) => ( { history : { push : jest . fn ( ) } , getPathArray : jest . fn ( ( ) => { return mockPath . split ( "s" ) ; } ) } ) ) ; jest . mock ( "s" , ( ) => ( { edit : jest . fn ( ) } ) ) ; import { movePlant , closePlantInfo , setDragIcon } from "s" ; import { MovePlantProps } from "s" ; import { fakePlant } from "s" ; import { edit } from "s" ; import { Actions } from "s" ; import { DEFAULT_ICON , svgToUrl } from "s" ; import { history } from "s" ; describe ( "s" , ( ) => { function movePlantTest ( caseDescription , attempted : { x : number , y : number } , expected : { x : number , y : number } ) { it ( `template` , ( ) => { const payload = { deltaX : attempted . x , deltaY : attempted . y , plant : fakePlant ( ) , gridSize : { x : 0 , y : 0 } } ; movePlant ( payload ) ; expect ( edit ) . toHaveBeenCalledWith ( expect . objectContaining ( { body : expect . objectContaining ( { x : 0 , y : 0 } ) } ) , expect . objectContaining ( { x : expected . x , y : expected . y } ) ) ; } ) ; } movePlantTest ( "s" , { x : 0 , y : 0 } , { x : 0 , y : 0 } ) ; movePlantTest ( "s" , { x : 0 , y : 0 } , { x : 0 , y : 0 } ) ; movePlantTest ( "s" , { x : - 0 , y : - 0 } , { x : 0 , y : 0 } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { mockPath = "s" ; const dispatch = jest . fn ( ) ; closePlantInfo ( dispatch ) ( ) ; expect ( history . push ) . not . toHaveBeenCalled ( ) ; expect ( dispatch ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { mockPath = "s" ; const dispatch = jest . fn ( ) ; closePlantInfo ( dispatch ) ( ) ; expect ( history . push ) . toHaveBeenCalledWith ( "s" ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : undefined , type : Actions . SELECT_PLANT } ) ; } ) ; it ( "s" , ( ) => { mockPath = "s" ; const dispatch = jest . fn ( ) ; closePlantInfo ( dispatch ) ( ) ; expect ( history . push ) . toHaveBeenCalledWith ( "s" ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : undefined , type : Actions . SELECT_PLANT } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const setDragImage = jest . fn ( ) ; const e = { currentTarget : new Image ( ) , dataTransfer : { setDragImage } } ; setDragIcon ( "s" ) ( e ) ; const img = new Image ( ) ; img . src = svgToUrl ( "s" ) ; expect ( setDragImage ) . toHaveBeenCalledWith ( img , 0 , 0 ) ; } ) ; it ( "s" , ( ) => { const setDragImage = jest . fn ( ) ; const e = { currentTarget : new Image ( ) , dataTransfer : { setDragImage } } ; setDragIcon ( undefined ) ( e ) ; const img = new Image ( ) ; img . src = DEFAULT_ICON ; expect ( setDragImage ) . toHaveBeenCalledWith ( img , 0 , 0 ) ; } ) ; } ) ;	O $string$ O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $string$ O $complex$ O O O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $ReduxAction<EditResourceParams>$ O $void$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O O O O O O $any$ O O O O O O O O $string$ O O O O O O $any$ O O O O $any$ O O O O O O O O $void$ O $string$ O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O O $any$ O O O O O O O O $MovePlantProps$ O O $number$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O $any$ O $any$ O O O $complex$ O O $number$ O O O $number$ O O O O O $ReduxAction<EditResourceParams>$ O $MovePlantProps$ O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $number$ O O O $number$ O O O O O O O $any$ O $any$ O O $number$ O $complex$ O $number$ O $number$ O $complex$ O $number$ O O O O O O O O $void$ O O O O $number$ O O O $number$ O O O O O $number$ O O O $number$ O O O O O $void$ O O O O $number$ O O O $number$ O O O O O $number$ O O O $number$ O O O O O $void$ O O O O $number$ O O O O $number$ O O O O O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $string$ O O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $string$ O O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $undefined$ O $undefined$ O $Actions$ O $any$ O $Actions.SELECT_PLANT$ O O O O O O $any$ O O O O O O O $string$ O O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $undefined$ O $undefined$ O $Actions$ O $any$ O $Actions.SELECT_PLANT$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O $HTMLImageElement$ O O $HTMLImageElement$ O O O $complex$ O O $any$ O O O $void$ O O O O $complex$ O O O $HTMLImageElement$ O O $HTMLImageElement$ O O O $HTMLImageElement$ O $string$ O $string$ O O O O $any$ O $any$ O O $any$ O $HTMLImageElement$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O $HTMLImageElement$ O O $HTMLImageElement$ O O O $complex$ O O $any$ O O O $void$ O $undefined$ O O $complex$ O O O $HTMLImageElement$ O O $HTMLImageElement$ O O O $HTMLImageElement$ O $string$ O O O $any$ O $any$ O O $any$ O $HTMLImageElement$ O O O O O O O O O O O O
jest . mock ( "s" , ( ) => ( { fetchGroupFromUrl : jest . fn ( ( ) => mockGroup ) } ) ) ; jest . mock ( "s" , ( ) => ( { overwrite : jest . fn ( ) , edit : jest . fn ( ) , } ) ) ; let mockMode = "s" ; jest . mock ( "s" , ( ) => ( { getMode : jest . fn ( ( ) => mockMode ) } ) ) ; import { fakePlant , fakePointGroup } from "s" ; import { fakeState } from "s" ; import { GetState } from "s" ; import { clickMapPlant , selectPlant , toggleHoveredPlant } from "s" ; import { buildResourceIndex } from "s" ; import { overwrite } from "s" ; const mockGroup = fakePointGroup ( ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = fakeState ( ) ; const dispatch = jest . fn ( ) ; const getState = jest . fn ( ( ) => state ) ; clickMapPlant ( "s" , "s" ) ( dispatch , getState ) ; expect ( dispatch ) . toHaveBeenCalledWith ( selectPlant ( [ "s" ] ) ) ; expect ( dispatch ) . toHaveBeenCalledWith ( toggleHoveredPlant ( "s" , "s" ) ) ; expect ( dispatch ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; it ( "s" , ( ) => { mockMode = "s" ; const state = fakeState ( ) ; const plant = fakePlant ( ) ; plant . body . id = 0 ; state . resources = buildResourceIndex ( [ plant ] ) ; const dispatch = jest . fn ( ) ; const getState = jest . fn ( ( ) => state ) ; clickMapPlant ( plant . uuid , "s" ) ( dispatch , getState ) ; expect ( dispatch ) . toHaveBeenCalledWith ( selectPlant ( [ plant . uuid ] ) ) ; expect ( dispatch ) . toHaveBeenCalledWith ( toggleHoveredPlant ( plant . uuid , "s" ) ) ; const xp = expect . objectContaining ( { name : "s" , point_ids : [ 0 ] } ) ; expect ( overwrite ) . toHaveBeenCalledWith ( mockGroup , xp ) ; expect ( dispatch ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $string$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $string$ O O O O O O O $any$ O $any$ O O O O O O $Everything$ O O O O O O $any$ O O O O O O $void$ O $complex$ O $complex$ O O O O O O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O O O O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O $any$ O O O O $GetState$ O $any$ O $any$ O O O O $Everything$ O O $void$ O O O O O O $any$ O $GetState$ O O $any$ O $any$ O O $any$ O $complex$ O O O O O O O $any$ O $any$ O O $any$ O $complex$ O O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $string$ O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $GetState$ O $any$ O $any$ O O O O $Everything$ O O $void$ O $any$ O $any$ O O O O $any$ O $GetState$ O O $any$ O $any$ O O $any$ O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $complex$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $string$ O O O $number[]$ O O O O O O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O
import { getDefaultAxisLength , getGridSize } from "s" ; import { WebAppConfig } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const axes = getDefaultAxisLength ( ( ) => false ) ; expect ( axes ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const grid = getGridSize ( k => ( { dynamic_map : false } as WebAppConfig ) [ k ] , { x : { value : 0 , isDefault : false } , y : { value : 0 , isDefault : false } } ) ; expect ( grid ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; it ( "s" , ( ) => { const grid = getGridSize ( k => ( { dynamic_map : false , map_size_x : 0 , map_size_y : 0 } as WebAppConfig ) [ k ] , { x : { value : 0 , isDefault : false } , y : { value : 0 , isDefault : false } } ) ; expect ( grid ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; it ( "s" , ( ) => { const grid = getGridSize ( k => ( { dynamic_map : true } as WebAppConfig ) [ k ] , { x : { value : 0 , isDefault : false } , y : { value : 0 , isDefault : false } } ) ; expect ( grid ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O O $number$ O O O $number$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $boolean$ O O O O $any$ O O $any$ O O O $complex$ O O $number$ O O O $boolean$ O O O O $complex$ O O $number$ O O O $boolean$ O O O O O O $any$ O $any$ O O $any$ O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $boolean$ O O O $number$ O O O $number$ O O O O $any$ O O $any$ O O O $complex$ O O $number$ O O O $boolean$ O O O O $complex$ O O $number$ O O O $boolean$ O O O O O O $any$ O $any$ O O $any$ O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $boolean$ O O O O $any$ O O $any$ O O O $complex$ O O $number$ O O O $boolean$ O O O O $complex$ O O $number$ O O O $boolean$ O O O O O O $any$ O $any$ O O $any$ O O $number$ O O O $number$ O O O O O O O O O O O
import { designer } from "s" ; import { Actions } from "s" ; import { ReduxAction } from "s" ; import { HoveredPlantPayl , CurrentPointPayl , CropLiveSearchResult } from "s" ; import { BotPosition } from "s" ; import { fakeCropLiveSearchResult } from "s" ; import { fakeDesignerState } from "s" ; describe ( "s" , ( ) => { const oldState = fakeDesignerState ; it ( "s" , ( ) => { const action < string > = { type : Actions . SEARCH_QUERY_CHANGE , payload : "s" } ; const newState = designer ( oldState ( ) , action ) ; expect ( newState . cropSearchQuery ) . toEqual ( "s" ) ; expect ( newState . cropSearchInProgress ) . toEqual ( true ) ; } ) ; it ( "s" , ( ) => { const action < string [ ] > = { type : Actions . SELECT_PLANT , payload : [ "s" ] } ; const newState = designer ( oldState ( ) , action ) ; expect ( newState . selectedPlants ) . toEqual ( [ "s" ] ) ; } ) ; it ( "s" , ( ) => { const action < HoveredPlantPayl > = { type : Actions . TOGGLE_HOVERED_PLANT , payload : { icon : "s" , plantUUID : "s" } } ; const newState = designer ( oldState ( ) , action ) ; expect ( newState . hoveredPlant ) . toEqual ( { icon : "s" , plantUUID : "s" } ) ; } ) ; it ( "s" , ( ) => { const action < string > = { type : Actions . HOVER_PLANT_LIST_ITEM , payload : "s" } ; const newState = designer ( oldState ( ) , action ) ; expect ( newState . hoveredPlantListItem ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const action < BotPosition > = { type : Actions . CHOOSE_LOCATION , payload : { x : 0 , y : 0 , z : 0 } } ; const newState = designer ( oldState ( ) , action ) ; expect ( newState . chosenLocation ) . toEqual ( { x : 0 , y : 0 , z : 0 } ) ; } ) ; it ( "s" , ( ) => { const action < CurrentPointPayl > = { type : Actions . SET_CURRENT_POINT_DATA , payload : { cx : 0 , cy : 0 , r : 0 , color : "s" } } ; const newState = designer ( oldState ( ) , action ) ; expect ( newState . currentPoint ) . toEqual ( { cx : 0 , cy : 0 , r : 0 , color : "s" } ) ; } ) ; it ( "s" , ( ) => { const payload = "s" ; const action < string | undefined > = { type : Actions . CHOOSE_SAVED_GARDEN , payload } ; const newState = designer ( oldState ( ) , action ) ; expect ( newState . openedSavedGarden ) . toEqual ( payload ) ; } ) ; it ( "s" , ( ) => { const payload : CropLiveSearchResult [ ] = [ fakeCropLiveSearchResult ( ) , ] ; const action < typeof payload > = { type : Actions . OF_SEARCH_RESULTS_OK , payload } ; const newState = designer ( oldState ( ) , action ) ; expect ( newState . cropSearchResults ) . toEqual ( payload ) ; expect ( newState . cropSearchInProgress ) . toEqual ( false ) ; } ) ; it ( "s" , ( ) => { const action < undefined > = { type : Actions . OF_SEARCH_RESULTS_START , payload : undefined } ; const newState = designer ( oldState ( ) , action ) ; expect ( newState . cropSearchInProgress ) . toEqual ( true ) ; } ) ; it ( "s" , ( ) => { const state = oldState ( ) ; state . cropSearchInProgress = true ; const action < undefined > = { type : Actions . OF_SEARCH_RESULTS_NO , payload : undefined } ; const newState = designer ( state , action ) ; expect ( newState . cropSearchInProgress ) . toEqual ( false ) ; } ) ; } ) ;	O O $generateReducer<DesignerState>.GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $CropLiveSearchResult$ O O O O O O $DesignerState$ O O O O $any$ O O O O O O O O $DesignerState$ O $DesignerState$ O $any$ O O O O O O O O $ReduxAction$ O O O O O $Actions.SEARCH_QUERY_CHANGE$ O $any$ O $Actions.SEARCH_QUERY_CHANGE$ O $string$ O O O O O $DesignerState$ O $generateReducer<DesignerState>.GeneratedReducer$ O $DesignerState$ O O O $ReduxAction<string>$ O O $any$ O $DesignerState$ O $string$ O O $any$ O O O O $any$ O $DesignerState$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $ReduxAction$ O O O O O O O $Actions.SELECT_PLANT$ O $any$ O $Actions.SELECT_PLANT$ O $string[]$ O O O O O O O $DesignerState$ O $generateReducer<DesignerState>.GeneratedReducer$ O $DesignerState$ O O O $ReduxAction<string[]>$ O O $any$ O $DesignerState$ O $string[]$ O O $any$ O O O O O O O O O $any$ O O O O O O O O $ReduxAction$ O $any$ O O O $Actions.TOGGLE_HOVERED_PLANT$ O $any$ O $Actions.TOGGLE_HOVERED_PLANT$ O $complex$ O O $string$ O O O $string$ O O O O O O $DesignerState$ O $generateReducer<DesignerState>.GeneratedReducer$ O $DesignerState$ O O O $ReduxAction<HoveredPlantPayl>$ O O $any$ O $DesignerState$ O $HoveredPlantPayl$ O O $any$ O O $string$ O O O $string$ O O O O O O O O $any$ O O O O O O O O $ReduxAction$ O O O O O $Actions.HOVER_PLANT_LIST_ITEM$ O $any$ O $Actions.HOVER_PLANT_LIST_ITEM$ O $string$ O O O O O $DesignerState$ O $generateReducer<DesignerState>.GeneratedReducer$ O $DesignerState$ O O O $ReduxAction<string>$ O O $any$ O $DesignerState$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $ReduxAction$ O $any$ O O O $Actions.CHOOSE_LOCATION$ O $any$ O $Actions.CHOOSE_LOCATION$ O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O $DesignerState$ O $generateReducer<DesignerState>.GeneratedReducer$ O $DesignerState$ O O O $complex$ O O $any$ O $DesignerState$ O $complex$ O O $any$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O O $ReduxAction$ O $any$ O O O $Actions.SET_CURRENT_POINT_DATA$ O $any$ O $Actions.SET_CURRENT_POINT_DATA$ O $complex$ O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O O O O $DesignerState$ O $generateReducer<DesignerState>.GeneratedReducer$ O $DesignerState$ O O O $ReduxAction<CurrentPointPayl>$ O O $any$ O $DesignerState$ O $CurrentPointPayl$ O O $any$ O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O O O O O O $any$ O O O O O O O O O O O O O $ReduxAction$ O O O O O O O $Actions.CHOOSE_SAVED_GARDEN$ O $any$ O $Actions.CHOOSE_SAVED_GARDEN$ O $string$ O O O $DesignerState$ O $generateReducer<DesignerState>.GeneratedReducer$ O $DesignerState$ O O O $ReduxAction<string>$ O O $any$ O $DesignerState$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $CropLiveSearchResult[]$ O $any$ O O O O $CropLiveSearchResult$ O O O O O O $ReduxAction$ O O $CropLiveSearchResult[]$ O O O $Actions.OF_SEARCH_RESULTS_OK$ O $any$ O $Actions.OF_SEARCH_RESULTS_OK$ O $CropLiveSearchResult[]$ O O O $DesignerState$ O $generateReducer<DesignerState>.GeneratedReducer$ O $DesignerState$ O O O $ReduxAction<CropLiveSearchResult[]>$ O O $any$ O $DesignerState$ O $CropLiveSearchResult[]$ O O $any$ O $CropLiveSearchResult[]$ O O $any$ O $DesignerState$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $ReduxAction$ O O O O O $Actions.OF_SEARCH_RESULTS_START$ O $any$ O $Actions.OF_SEARCH_RESULTS_START$ O $undefined$ O $undefined$ O O O $DesignerState$ O $generateReducer<DesignerState>.GeneratedReducer$ O $DesignerState$ O O O $ReduxAction<undefined>$ O O $any$ O $DesignerState$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $DesignerState$ O $DesignerState$ O O O $DesignerState$ O $boolean$ O O O O $ReduxAction$ O O O O O $Actions.OF_SEARCH_RESULTS_NO$ O $any$ O $Actions.OF_SEARCH_RESULTS_NO$ O $undefined$ O $undefined$ O O O $DesignerState$ O $generateReducer<DesignerState>.GeneratedReducer$ O $DesignerState$ O $ReduxAction<undefined>$ O O $any$ O $DesignerState$ O $boolean$ O O $any$ O O O O O O O O O O
import { CropLiveSearchResult } from "s" ; import { DEFAULT_ICON } from "s" ; import { startCase , find } from "s" ; import { t } from "s" ; export function findBySlug ( crops : CropLiveSearchResult [ ] , slug ? ) { const crop = find ( crops , result => result . crop . slug === slug ) ; return crop || { crop : { name : startCase ( ( slug || t ( "s" ) ) . split ( "s" ) . join ( "s" ) ) , slug : "s" , binomial_name : t ( "s" ) , common_names : [ t ( "s" ) ] , description : t ( "s" ) , sun_requirements : t ( "s" ) , sowing_method : t ( "s" ) , processing_pictures : 0 } , image : DEFAULT_ICON } ; }	O O $any$ O O O O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $CropLiveSearchResult$ O $CropLiveSearchResult[]$ O $any$ O O O $string$ $string$ O O O $any$ O $any$ O $CropLiveSearchResult[]$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O O $complex$ O O $any$ O $any$ O O $string$ O $any$ O O O O O $any$ O O O O $any$ O O O O O $string$ O O O $any$ O $any$ O O O O $any[]$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $number$ O O O O $string$ O O O O O
import { findBySlug } from "s" ; import { DEFAULT_ICON } from "s" ; import { fakeCropLiveSearchResult } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = findBySlug ( [ fakeCropLiveSearchResult ( ) ] , "s" ) ; expect ( result ) . toEqual ( { crop : expect . objectContaining ( { name : "s" } ) , image : DEFAULT_ICON } ) ; } ) ; it ( "s" , ( ) => { const result = findBySlug ( [ fakeCropLiveSearchResult ( ) ] ) ; expect ( result ) . toEqual ( { crop : expect . objectContaining ( { name : "s" } ) , image : DEFAULT_ICON } ) ; } ) ; it ( "s" , ( ) => { const result = findBySlug ( [ fakeCropLiveSearchResult ( ) ] , "s" ) ; expect ( result ) . toEqual ( { crop : expect . objectContaining ( { name : "s" } ) , image : "s" } ) ; } ) ; } ) ;	O O $CropLiveSearchResult$ O O O O O O O O O O O O O $CropLiveSearchResult$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $CropLiveSearchResult$ O $CropLiveSearchResult$ O O $CropLiveSearchResult$ O O O O O O O $any$ O $CropLiveSearchResult$ O O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O O O $string$ O O O O O O O O $any$ O O O O O O O O $CropLiveSearchResult$ O $CropLiveSearchResult$ O O $CropLiveSearchResult$ O O O O O $any$ O $CropLiveSearchResult$ O O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O O O $string$ O O O O O O O O $any$ O O O O O O O O $CropLiveSearchResult$ O $CropLiveSearchResult$ O O $CropLiveSearchResult$ O O O O O O O $any$ O $CropLiveSearchResult$ O O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O O O $string$ O O O O O O O O O O O
import axios , { AxiosPromise } from "s" ; import { OpenFarm , CropSearchResult } from "s" ; import { DEFAULT_ICON } from "s" ; import { Actions } from "s" ; import { ExecutableType } from "s" ; import { get } from "s" ; const url = ( q ) => `template` ; const openFarmSearchQuery = ( q ) : AxiosPromise < CropSearchResult > => axios . get < CropSearchResult > ( url ( q ) ) ; interface IdURL { id : string ; url : string ; } const FALLBACK : OpenFarm . Included [ ] = [ ] ; export let OFSearch = ( searchTerm ) => ( dispatch ) => { dispatch ( { type : Actions . OF_SEARCH_RESULTS_START , payload : undefined } ) ; openFarmSearchQuery ( searchTerm ) . then ( resp => { const images : { [ key ] : string } = { } ; get ( resp , "s" , FALLBACK ) . map ( ( item : OpenFarm . Included ) => { return { id : item . id , url : item . attributes . thumbnail_url } ; } ) . map ( ( val ) => images [ val . id ] = val . url ) ; const payload = resp . data . data . map ( datum => { const crop = datum . attributes ; const id = get ( datum , "s" , "s" ) ; return { crop , image : ( images [ id ] || DEFAULT_ICON ) } ; } ) ; dispatch ( { type : Actions . OF_SEARCH_RESULTS_OK , payload } ) ; } ) . catch ( ( ) => dispatch ( { type : Actions . OF_SEARCH_RESULTS_NO , payload : undefined } ) ) ; } ; function isExecutableType ( x ? ) : x is ExecutableType { const EXECUTABLES : ExecutableType [ ] = [ "s" , "s" ] ; return ! ! EXECUTABLES . includes ( x as ExecutableType ) ; } export function executableType ( input ? ) { if ( isExecutableType ( input ) ) { return input ; } else { throw new Error ( "s" + input ) ; } }	O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $string$ O O $string$ O O O O O $any$ O O $string$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $string$ O $string$ O O O O $any$ O $string$ O O O $string$ O O O O O $Included[]$ O $any$ O $any$ O O O O O O O O $void$ O O $string$ O O O $Function$ O O O $Function$ O O $Actions$ O $any$ O $Actions.OF_SEARCH_RESULTS_START$ O $undefined$ O $undefined$ O O O $any$ O $string$ O O $any$ O $any$ O O O $complex$ O O O $string$ O O O O O O O O $any$ O $any$ O O O $Included[]$ O O $any$ O O $Included$ O $any$ O $any$ O O O O O $string$ O $Included$ O $string$ O $string$ O $Included$ O $ImageAttrs$ O $string$ O O O O O $any$ O O $IdURL$ O O $complex$ O $IdURL$ O $string$ O O $IdURL$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $string$ O O $complex$ O $any$ O O O O O O O O O $Function$ O O $Actions$ O $any$ O $Actions.OF_SEARCH_RESULTS_OK$ O $any$ O O O O O O $any$ O O O O $Function$ O O $Actions$ O $any$ O $Actions.OF_SEARCH_RESULTS_NO$ O $undefined$ O $undefined$ O O O O O O O $complex$ O $string$ $string$ O O $string$ O $any$ O O $any[]$ O $any$ O O O O O O O O O O O O $any[]$ O $boolean$ O $string$ O $any$ O O O O O $ExecutableType$ O $string$ $string$ O O O O $complex$ O $string$ O O O O $string$ O O O O O O $ErrorConstructor$ O O O $never$ O O O O
let mockPromise < { } | void > = Promise . resolve ( ) ; jest . mock ( "s" , ( ) => ( { get : ( ) => mockPromise } ) ) ; import { executableType , OFSearch } from "s" ; import { Actions } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( executableType ( "s" ) ) . toEqual ( "s" ) ; expect ( executableType ( "s" ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( ( ) => executableType ( "s" ) ) . toThrowError ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { const START = expect . objectContaining ( { type : Actions . OF_SEARCH_RESULTS_START } ) ; const NO = expect . objectContaining ( { type : Actions . OF_SEARCH_RESULTS_NO } ) ; it ( "s" , async ( ) => { mockPromise = Promise . resolve ( { data : { data : [ { attributes : { } } ] } } ) ; const dispatch = jest . fn ( ) ; await OFSearch ( "s" ) ( dispatch ) ; expect ( dispatch ) . toHaveBeenCalledWith ( START ) ; await expect ( dispatch ) . toHaveBeenCalledWith ( { type : Actions . OF_SEARCH_RESULTS_OK , payload : [ { crop : { } , image : "s" } ] } ) ; await expect ( dispatch ) . not . toHaveBeenCalledWith ( NO ) ; } ) ; it ( "s" , async ( ) => { mockPromise = Promise . resolve ( { data : { included : [ { id : 0 , attributes : { thumbnail_url : "s" } } ] , data : [ { attributes : { } , relationships : { pictures : { data : [ { id : 0 } ] } } } ] } } ) ; const dispatch = jest . fn ( ) ; await OFSearch ( "s" ) ( dispatch ) ; expect ( dispatch ) . toHaveBeenCalledWith ( START ) ; await expect ( dispatch ) . toHaveBeenCalledWith ( { type : Actions . OF_SEARCH_RESULTS_OK , payload : [ { crop : { } , image : "s" } ] } ) ; await expect ( dispatch ) . not . toHaveBeenCalledWith ( NO ) ; } ) ; it ( "s" , async ( ) => { mockPromise = Promise . reject ( ) ; const dispatch = jest . fn ( ) ; await OFSearch ( "s" ) ( dispatch ) ; expect ( dispatch ) . toHaveBeenCalledWith ( START ) ; await expect ( dispatch ) . not . toHaveBeenCalledWith ( expect . objectContaining ( { type : Actions . OF_SEARCH_RESULTS_OK } ) ) ; await expect ( dispatch ) . toHaveBeenCalledWith ( NO ) ; } ) ; } ) ;	O $Promise$ O O O O O O O $PromiseConstructor$ O $complex$ O O O $any$ O $any$ O O O O O O O O $complex$ O O O O $complex$ O O O O O O $any$ O $void$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O O O O O $any$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $Actions$ O $any$ O $Actions.OF_SEARCH_RESULTS_START$ O O O O $any$ O $any$ O $any$ O O $Actions$ O $any$ O $Actions.OF_SEARCH_RESULTS_NO$ O O O $any$ O O O O O O O O $complex$ O $PromiseConstructor$ O $complex$ O O $complex$ O O $complex$ O O O ${}$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O $void$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions.OF_SEARCH_RESULTS_OK$ O $complex$ O O O ${}$ O O O O $string$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $complex$ O $PromiseConstructor$ O $complex$ O O $complex$ O O $complex$ O O O $number$ O O O $complex$ O O $string$ O O O O O O $complex$ O O O ${}$ O O O O $complex$ O O $complex$ O O $complex$ O O O $number$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $void$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions.OF_SEARCH_RESULTS_OK$ O $complex$ O O O ${}$ O O O O $string$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $complex$ O $PromiseConstructor$ O $Promise<T>$ O O O O $any$ O $any$ O $any$ O O O O $void$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $Actions$ O $any$ O $Actions.OF_SEARCH_RESULTS_OK$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O
import { AddEditFarmEventProps } from "s" ; import { Everything , TimeSettings } from "s" ; import moment from "s" ; import { history , getPathArray } from "s" ; import { selectAllFarmEvents , indexRegimenById , indexSequenceById , indexFarmEventById , findFarmEventById , selectAllRegimens , selectAllSequences , findSequenceById , findRegimenById , getDeviceAccountSettings , maybeGetDevice , maybeGetTimeSettings } from "s" ; import { TaggedFarmEvent , TaggedSequence , TaggedRegimen } from "s" ; import { DropDownItem } from "s" ; import { validFbosConfig , createShouldDisplayFn as shouldDisplayFunc , determineInstalledOsVersion } from "s" ; import { sourceFbosConfigValue } from "s" ; import { hasId } from "s" ; import { ExecutableType } from "s" ; import { getFbosConfig } from "s" ; import { t } from "s" ; import { DevSettings } from "s" ; export let formatTime = ( input , timeSettings ) => { const iso = new Date ( input ) . toISOString ( ) ; return moment ( iso ) . utcOffset ( timeSettings . utcOffset ) . format ( "s" ) ; } ; export let formatDate = ( input , timeSettings ) => { const iso = new Date ( input ) . toISOString ( ) ; return moment ( iso ) . utcOffset ( timeSettings . utcOffset ) . format ( "s" ) ; } ; export let repeatOptions = [ { label : t ( "s" ) , value : "s" , name : "s" } , { label : t ( "s" ) , value : "s" , name : "s" } , { label : t ( "s" ) , value : "s" , name : "s" } , { label : t ( "s" ) , value : "s" , name : "s" } , { label : t ( "s" ) , value : "s" , name : "s" } , { label : t ( "s" ) , value : "s" , name : "s" } ] ; const handleTime = ( e : React . SyntheticEvent < HTMLInputElement > , currentISO ) => { const incomingTime = e . currentTarget . value . split ( "s" ) ; const hours = parseInt ( incomingTime [ 0 ] ) || 0 ; const minutes = parseInt ( incomingTime [ 0 ] ) || 0 ; switch ( e . currentTarget . name ) { case "s" : const currentStartISO = new Date ( ( currentISO || "s" ) . toString ( ) ) . toISOString ( ) ; const newStartISO = moment ( currentStartISO ) . set ( "s" , hours ) . set ( "s" , minutes ) . toISOString ( ) ; return newStartISO ; case "s" : const currentEndISO = new Date ( ( currentISO || "s" ) . toString ( ) ) . toISOString ( ) ; const newEndISO = moment ( currentEndISO ) . set ( "s" , hours ) . set ( "s" , minutes ) . toISOString ( ) ; return newEndISO ; default : throw new Error ( "s" ) ; } } ; const addExecutables = ( resource : ( TaggedSequence | TaggedRegimen ) [ ] ) : DropDownItem [ ] => { const d : DropDownItem [ ] = [ ] ; resource . map ( r => { if ( r . body . id ) { d . push ( { label : r . body . name , headingId : r . kind , value : r . body . id } ) ; } } ) ; return d ; } ; export function mapStateToPropsAddEdit ( props ) { const executableList : DropDownItem [ ] = [ { label : t ( "s" ) , heading : true , value : 0 , headingId : "s" } , ... addExecutables ( selectAllSequences ( props . resources . index ) ) , { label : t ( "s" ) , heading : true , value : 0 , headingId : "s" } , ... addExecutables ( selectAllRegimens ( props . resources . index ) ) , ] ; const regimensById = indexRegimenById ( props . resources . index ) ; const sequencesById = indexSequenceById ( props . resources . index ) ; const farmEventsById = indexFarmEventById ( props . resources . index ) ; const farmEvents = selectAllFarmEvents ( props . resources . index ) ; const findFarmEventByUuid = ( uuid : string | undefined ) : TaggedFarmEvent | undefined => uuid ? farmEvents . filter ( x => x . uuid === uuid ) [ 0 ] : undefined ; const getFarmEvent = ( ) : TaggedFarmEvent | undefined => { const id = parseInt ( getPathArray ( ) [ 0 ] ) ; if ( id && hasId ( props . resources . index , "s" , id ) ) { return findFarmEventById ( props . resources . index , id ) ; } else { history . push ( "s" ) ; } } ; const findExecutable = ( kind , id ) : TaggedSequence | TaggedRegimen => { switch ( kind ) { case "s" : return findSequenceById ( props . resources . index , id ) ; case "s" : return findRegimenById ( props . resources . index , id ) ; } } ; const dev = getDeviceAccountSettings ( props . resources . index ) ; const { configuration } = props . bot . hardware ; const fbosConfig = validFbosConfig ( getFbosConfig ( props . resources . index ) ) ; const autoSyncEnabled = ! ! sourceFbosConfigValue ( fbosConfig , configuration ) ( "s" ) . value ; const installedOsVersion = determineInstalledOsVersion ( props . bot , maybeGetDevice ( props . resources . index ) ) ; const fbosVersionOverride = DevSettings . overriddenFbosVersion ( ) ; const shouldDisplay = shouldDisplayFunc ( installedOsVersion , props . bot . minOsFeatureData , fbosVersionOverride ) ; return { deviceTimezone : dev . body . timezone , dispatch : props . dispatch , regimensById , sequencesById , farmEventsById , executableOptions : executableList , repeatOptions , handleTime , farmEvents , getFarmEvent , findFarmEventByUuid , findExecutable , timeSettings : maybeGetTimeSettings ( props . resources . index ) , autoSyncEnabled , resources : props . resources . index , shouldDisplay , } ; }	O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $any[]$ O $Indexer<any>$ O $Indexer<any>$ O $Indexer<any>$ O $any$ O $any[]$ O $any[]$ O $any$ O $any$ O $any$ O $any$ O $TimeSettings$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $boolean$ O $boolean$ O $string$ O O O O O O $SourceFbosConfig$ O O O O O O $boolean$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O $string$ O $TimeSettings$ O O O O $string$ O O $DateConstructor$ O $string$ O O $string$ O O O O $any$ O $string$ O O $any$ O $TimeSettings$ O $number$ O O $any$ O O O O O O O O $any$ O O $string$ O $TimeSettings$ O O O O $string$ O O $DateConstructor$ O $string$ O O $string$ O O O O $any$ O $string$ O O $any$ O $TimeSettings$ O $number$ O O $any$ O O O O O O O O $complex$ O O O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $complex$ O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $number$ O $number$ O $any$ O O O O O O O O $number$ O $number$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O O $DateConstructor$ O O $string$ O O O O $string$ O O O O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O O O $number$ O O $any$ O O O $number$ O O $any$ O O O O $any$ O O O O O $string$ O O $DateConstructor$ O O $string$ O O O O $string$ O O O O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O O O $number$ O O $any$ O O O $number$ O O $any$ O O O O $any$ O O O O O $ErrorConstructor$ O O O O O O O O $DropDownItem[]$ O O $any[]$ O O $any$ O $any$ O O O O O $any$ O O O O O $DropDownItem[]$ O $any$ O O O O O O $any[]$ O $U[]$ O $any$ O O O O $any$ O $any$ O $any$ O O $DropDownItem[]$ O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $DropDownItem[]$ O O O O O $AddEditFarmEventProps$ O $Everything$ O O O $DropDownItem[]$ O $any$ O O O O O $any$ O $any$ O O O O $true$ O O O $number$ O O O $string$ O O O O O $DropDownItem[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $any$ O $any$ O O O O $true$ O O O $number$ O O O $string$ O O O O O $DropDownItem[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O O O $IndexLookupDictionary<any>$ O $Indexer<any>$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $IndexLookupDictionary<any>$ O $Indexer<any>$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $IndexLookupDictionary<any>$ O $Indexer<any>$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $any$ O O $string$ O O O O O O $any$ O O O $string$ O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $string$ O O O O O $undefined$ O O $any$ O O O O $any$ O O O O O $number$ O $number$ O $any$ O O O O O O O O O $number$ O $boolean$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $number$ O O O O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $number$ O O O O O $any$ O $any$ O O O O O O O O $any$ O O $ExecutableType$ O $number$ O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $number$ O O O O O O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $number$ O O O O O O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $any$ O O $Everything$ O $BotState$ O $any$ O O $any$ O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $boolean$ O O O $SourceFbosConfig$ O $any$ O $any$ O O O O O $complex$ O O $string$ O $string$ O $Everything$ O $BotState$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $string$ O $any$ O $string$ O O O O $boolean$ O $boolean$ O $string$ O $Everything$ O $BotState$ O $complex$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $Function$ O $Everything$ O $Function$ O $IndexLookupDictionary<any>$ O $IndexLookupDictionary<any>$ O $IndexLookupDictionary<any>$ O $DropDownItem[]$ O $DropDownItem[]$ O $complex$ O $any$ O $any[]$ O $any$ O $any$ O $any$ O $TimeSettings$ O $TimeSettings$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $boolean$ O $ResourceIndex$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $boolean$ O O O O
let mockPath = "s" ; jest . mock ( "s" , ( ) => ( { getPathArray : jest . fn ( ( ) => { return mockPath . split ( "s" ) ; } ) , history : { push : jest . fn ( ) } } ) ) ; import { mapStateToPropsAddEdit } from "s" ; import { fakeState } from "s" ; import { buildResourceIndex , fakeDevice } from "s" ; import { fakeSequence , fakeRegimen , fakeFarmEvent } from "s" ; import { history } from "s" ; describe ( "s" , ( ) => { describe ( "s" , ( ) => { const { handleTime } = mapStateToPropsAddEdit ( fakeState ( ) ) ; it ( "s" , ( ) => { const e = { currentTarget : { value : "s" , name : "s" } } as React . SyntheticEvent < HTMLInputElement > ; const result = handleTime ( e , "s" ) ; expect ( result ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const e = { currentTarget : { value : "s" , name : "s" } } as React . SyntheticEvent < HTMLInputElement > ; const result = handleTime ( e , "s" ) ; expect ( result ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const e = { currentTarget : { value : "s" , name : "s" } } as React . SyntheticEvent < HTMLInputElement > ; const boom = ( ) => handleTime ( e , "s" ) ; expect ( boom ) . toThrowError ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { const state = fakeState ( ) ; const s = fakeSequence ( ) ; s . body . name = "s" ; s . body . id = 0 ; const r = fakeRegimen ( ) ; r . body . name = "s" ; r . body . id = 0 ; state . resources = buildResourceIndex ( [ s , r , fakeDevice ( ) ] ) ; const { executableOptions } = mapStateToPropsAddEdit ( state ) ; it ( "s" , ( ) => { expect ( executableOptions ) . toEqual ( expect . arrayContaining ( [ { headingId : "s" , label : "s" , value : 0 } , { headingId : "s" , label : "s" , value : 0 } ] ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = fakeState ( ) ; const fe = fakeFarmEvent ( "s" , - 0 ) ; state . resources = buildResourceIndex ( [ fe , fakeDevice ( ) ] ) ; mockPath = "s" + fe . body . id ; const { getFarmEvent } = mapStateToPropsAddEdit ( state ) ; expect ( getFarmEvent ( ) ) . toEqual ( expect . objectContaining ( { kind : "s" , body : expect . objectContaining ( { id : fe . body . id } ) } ) ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; state . resources = buildResourceIndex ( [ fakeDevice ( ) ] ) ; mockPath = "s" ; const { getFarmEvent } = mapStateToPropsAddEdit ( state ) ; getFarmEvent ( ) ; expect ( history . push ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = fakeState ( ) ; const s = fakeSequence ( ) ; s . body . id = 0 ; state . resources = buildResourceIndex ( [ s , fakeDevice ( ) ] ) ; const { findExecutable } = mapStateToPropsAddEdit ( state ) ; expect ( findExecutable ( "s" , s . body . id ) ) . toEqual ( expect . objectContaining ( { kind : "s" , body : expect . objectContaining ( { id : s . body . id } ) } ) ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; const r = fakeRegimen ( ) ; r . body . id = 0 ; state . resources = buildResourceIndex ( [ r , fakeDevice ( ) ] ) ; const { findExecutable } = mapStateToPropsAddEdit ( state ) ; expect ( findExecutable ( "s" , r . body . id ) ) . toEqual ( expect . objectContaining ( { kind : "s" , body : expect . objectContaining ( { id : r . body . id } ) } ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = fakeState ( ) ; const farmEvent = fakeFarmEvent ( "s" , 0 ) ; state . resources = buildResourceIndex ( [ farmEvent , fakeDevice ( ) ] ) ; const { findFarmEventByUuid } = mapStateToPropsAddEdit ( state ) ; const result = findFarmEventByUuid ( farmEvent . uuid ) ; expect ( result ) . toEqual ( farmEvent ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; state . resources = buildResourceIndex ( [ fakeDevice ( ) ] ) ; const { findFarmEventByUuid } = mapStateToPropsAddEdit ( state ) ; const result = findFarmEventByUuid ( "s" ) ; expect ( result ) . toEqual ( undefined ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; state . resources = buildResourceIndex ( [ fakeDevice ( ) ] ) ; const { findFarmEventByUuid } = mapStateToPropsAddEdit ( state ) ; const result = findFarmEventByUuid ( undefined ) ; expect ( result ) . toEqual ( undefined ) ; } ) ; } ) ; } ) ;	O $string$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $string$ O $complex$ O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O $AddEditFarmEventProps$ O O O O O O $Everything$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $string$ O O $AddEditFarmEventProps$ O $Everything$ O O O O $any$ O O O O O O O O $any$ O O $complex$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O $complex$ O O O $string$ O $string$ O $any$ O O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $complex$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O $complex$ O O O $string$ O $string$ O $any$ O O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $complex$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O $complex$ O O O $string$ O O O O $string$ O $any$ O O O O $any$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $DropDownItem[]$ O O $AddEditFarmEventProps$ O $Everything$ O O $any$ O O O O O O O $any$ O $DropDownItem[]$ O O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O O O $number$ O O O O O $string$ O O O $string$ O O O $number$ O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O O O O O $Everything$ O $RestResources$ O $any$ O O $any$ O $any$ O O O O O $string$ O O O $any$ O $any$ O $any$ O O O $any$ O O $AddEditFarmEventProps$ O $Everything$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O O $string$ O O O O O $any$ O O $AddEditFarmEventProps$ O $Everything$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O $any$ O O O O O O O $ExecutableQuery$ O O $AddEditFarmEventProps$ O $Everything$ O O $any$ O $ExecutableQuery$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O $any$ O O O O O O O $ExecutableQuery$ O O $AddEditFarmEventProps$ O $Everything$ O O $any$ O $ExecutableQuery$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O O O O $Everything$ O $RestResources$ O $any$ O O $any$ O $any$ O O O O O O O $any$ O O $AddEditFarmEventProps$ O $Everything$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O O O O $any$ O O $AddEditFarmEventProps$ O $Everything$ O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $undefined$ O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O O O O $any$ O O $AddEditFarmEventProps$ O $Everything$ O O O $any$ O $any$ O $undefined$ O O $any$ O $any$ O O $any$ O $undefined$ O O O O O O O O O O O
import { FarmEventWithExecutable } from "s" ; import { ResourceIndex } from "s" ; import { selectAllFarmEvents , indexSequenceById , indexRegimenById } from "s" ; import { betterCompact } from "s" ; import { TaggedFarmEvent } from "s" ; export function joinFarmEventsToExecutable ( input ) : FarmEventWithExecutable [ ] { const farmEvents : TaggedFarmEvent [ ] = selectAllFarmEvents ( input ) ; const sequenceById = indexSequenceById ( input ) ; const regimenById = indexRegimenById ( input ) ; return betterCompact ( farmEvents . map ( function ( fe ) { const body = fe . body ; const id = fe . body . executable_id ; if ( id ) { switch ( body . executable_type ) { case "s" : const 0 = sequenceById [ id ] ; if ( 0 ) { return { ... body , executable_type : body . executable_type , executable : 0 . body } ; } break ; case "s" : const 0 = regimenById [ id ] ; if ( 0 ) { return { ... body , executable_type : body . executable_type , executable : 0 . body } ; } } } throw new Error ( "s" ) ; } ) ) ; }	O O $any$ O O O O O O $any$ O O O O O O $any[]$ O $Indexer<any>$ O $Indexer<any>$ O O O O O O $T[]$ O O O O O O $any$ O O O O O O $FarmEventWithExecutable[]$ O $ResourceIndex$ O O $any$ O O O O $any[]$ O $any$ O O O $any[]$ O $ResourceIndex$ O O O $IndexLookupDictionary<any>$ O $Indexer<any>$ O $ResourceIndex$ O O O $IndexLookupDictionary<any>$ O $Indexer<any>$ O $ResourceIndex$ O O O $T[]$ O $any[]$ O $U[]$ O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $IndexLookupDictionary<any>$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $IndexLookupDictionary<any>$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O O O O
import { Dictionary } from "s" ; import { CalendarOccurrence , CalendarDay } from "s" ; import moment from "s" ; import { sortBy } from "s" ; export class Calendar { static SORT_KEY : keyof CalendarDay = "s" ; static DATE_FORMAT = "s" ; static MONTHS : Readonly < Dictionary < string > > = { "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" } ; constructor ( public value < CalendarOccurrence [ ] > = { } ) { } insert ( occur ) { const k = occur . mmddyy ; this . value [ k ] = this . value [ k ] || [ ] ; this . value [ k ] . push ( occur ) ; } getAll ( ) : CalendarDay [ ] { const all = Object . keys ( this . value ) . map ( x => this . value [ x ] ) . filter ( x => ! ! x ) . filter ( x => ! ! x . length ) . map ( ( items ) : CalendarDay => { const item = items [ 0 ] ; return { sortKey : item . sortKey , year : parseInt ( item . mmddyy . slice ( 0 , 0 ) ) , month : Calendar . MONTHS [ item . mmddyy . slice ( 0 , 0 ) ] || "s" , day : parseInt ( item . mmddyy . slice ( 0 , 0 ) ) , items : sortBy ( items , Calendar . SORT_KEY ) } ; } ) ; return sortBy ( all , Calendar . SORT_KEY ) ; } findByDate ( m : moment . Moment ) : CalendarOccurrence [ ] { return this . value [ this . fmtDate ( m ) ] || [ ] ; } fmtDate = ( m : moment . Moment ) => { return m . format ( Calendar . DATE_FORMAT ) ; } }	O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O $string$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Dictionary$ O $any$ O O O O O O O O O $void$ O $CalendarOccurrence$ O O O $string$ O $CalendarOccurrence$ O $string$ O O O $any$ O $string$ O O O O $any$ O $string$ O O O O O O O $any$ O $string$ O O $any$ O $CalendarOccurrence$ O O O $CalendarDay[]$ O O O $any$ O O O O $CalendarDay[]$ O $ObjectConstructor$ O $complex$ O O O $any$ O O $U[]$ O $string$ O O O $any$ O $string$ O O O $complex$ O $any$ O O O $any$ O O $complex$ O $any$ O O O $any$ O $any$ O O $U[]$ O O $any$ O O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $number$ O $number$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $number$ O $number$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $CalendarDay[]$ O $any$ O O O O O $CalendarOccurrence[]$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O O O
import moment from "s" ; import { CalendarOccurrence } from "s" ; import { FarmEventWithExecutable } from "s" ; import { Calendar } from "s" ; import { TimeSettings } from "s" ; import { timeFormatString } from "s" ; export function occurrence ( m : moment . Moment , fe , timeSettings , modifiers ? : { numHidden ? : number , empty ? : boolean } ) { const normalHeading = fe . executable . name || fe . executable_type ; const heading = ( ) => { if ( modifiers && modifiers . empty ) { return "s" ; } if ( modifiers && modifiers . numHidden ) { return `template` + normalHeading ; } return normalHeading ; } ; const { utcOffset } = timeSettings ; return { mmddyy : m . utcOffset ( utcOffset ) . format ( Calendar . DATE_FORMAT ) , sortKey : m . unix ( ) , timeStr : m . clone ( ) . utcOffset ( utcOffset ) . format ( timeFormatString ( timeSettings ) ) , heading : heading ( ) , executableId : fe . executable_id || 0 , id : fe . id || 0 , } ; }	O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $string$ O O O O O O $CalendarOccurrence$ O $any$ O $any$ O $any$ O $FarmEventWithExecutable$ O $TimeSettings$ O $complex$ O O O $number$ O O O O $boolean$ O O O O O O O $string$ O $FarmEventWithExecutable$ O $complex$ O $string$ O $FarmEventWithExecutable$ O O O O $string$ O O O O O O O $complex$ O $complex$ O $boolean$ O O O O O O O O $complex$ O $complex$ O $number$ O O O O O $string$ O O O $string$ O O O O O $number$ O O $TimeSettings$ O O O $any$ O $any$ O $any$ O $number$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $number$ O O $any$ O $string$ O $TimeSettings$ O O O $string$ O $string$ O O O $any$ O $FarmEventWithExecutable$ O $any$ O O O $any$ O $FarmEventWithExecutable$ O $any$ O O O O O O
import moment from "s" ; import { Moment , unitOfTime } from "s" ; import { range } from "s" ; import { NEVER } from "s" ; import { TimeUnit } from "s" ; interface SchedulerProps { startTime : Moment ; currentTime : Moment ; endTime : Moment ; intervalSeconds : number ; } const nextYear = ( ) => moment ( moment ( ) . add ( 0 , "s" ) ) ; export const maxDisplayItems = 0 ; export const gracePeriodSeconds = 0 ; export function scheduler ( { startTime , currentTime , endTime , intervalSeconds } ) : { items : Moment [ ] , shortenedBy : number } { const eventStartTime = startTime . unix ( ) ; const eventEndTime = endTime . unix ( ) ; const cutoffTime = currentTime . unix ( ) - gracePeriodSeconds ; const timeSinceStart = cutoffTime - eventStartTime ; const itemsMissed = Math . ceil ( timeSinceStart / intervalSeconds ) ; const nextItemTime = timeSinceStart > 0 ? eventStartTime + itemsMissed * intervalSeconds : eventStartTime ; const itemEndTime = nextItemTime + maxDisplayItems * intervalSeconds ; const lastItemTime = itemEndTime < eventEndTime ? itemEndTime : eventEndTime ; const shortenedBy = Math . ceil ( Math . abs ( eventEndTime - lastItemTime ) / intervalSeconds ) ; const items = range ( nextItemTime , lastItemTime , intervalSeconds ) . map ( x => moment . unix ( x ) ) ; return { items , shortenedBy } ; } const LOOKUP < TimeUnit , unitOfTime . Base > = { "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , } ; export function farmEventIntervalSeconds ( repeat , unit ) { const momentUnit = LOOKUP [ unit ] ; if ( ( unit === NEVER ) || ! ( momentUnit ) ) { return 0 ; } else { return moment . duration ( repeat , momentUnit ) . asSeconds ( ) ; } } export interface TimeLine { repeat ? : number | undefined ; time_unit : TimeUnit ; start_time : string ; end_time ? : string | undefined ; current_time ? : string ; } export function scheduleForFarmEvent ( { start_time , end_time , repeat , time_unit } , timeNow = moment ( ) ) : { items : Moment [ ] , shortenedBy : number } { const interval = repeat && farmEventIntervalSeconds ( repeat , time_unit ) ; const gracePeriod = timeNow . clone ( ) . subtract ( gracePeriodSeconds , "s" ) ; if ( moment ( end_time ) . isBefore ( gracePeriod ) ) { return { items : [ ] , shortenedBy : 0 } ; } if ( interval && ( time_unit !== NEVER ) ) { const schedule = scheduler ( { startTime : moment ( start_time ) , currentTime : timeNow , endTime : end_time ? moment ( end_time ) : nextYear ( ) , intervalSeconds : interval } ) ; return { items : schedule . items , shortenedBy : schedule . shortenedBy } ; } else { return { items : [ moment ( start_time ) ] , shortenedBy : 0 } ; } }	O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $number$ O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O $number$ $SchedulerProps$ O O O $any[]$ O $any$ O O O $number$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $number$ O $any$ O $any$ O O O O O O $number$ O $number$ O $any$ O O $number$ O $Math$ O $number$ O $number$ O $number$ O O O $any$ O $number$ O O O $any$ O $number$ O $number$ O $any$ O O $any$ O $any$ O O O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $number$ O $Math$ O $number$ O $Math$ O $number$ O $any$ O $any$ O O $number$ O O O $any$ O $any$ O $any$ O $any$ O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $number$ O O O O $Record$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $number$ O $TimeUnit$ O O O $any$ O $complex$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O O O $any$ O $any$ O $number$ O $any$ O O $any$ O O O O O O O $any$ O $number$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O O O O $string$ O O O O O O O $complex$ O O $string$ O $string$ O $number$ O $any$ $TimeLine$ O $any$ O $any$ O O O O O $any[]$ O $any$ O O O $number$ O O O O O $any$ O $number$ O $any$ O $number$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O $string$ O O $any$ O $any$ O O O O O $undefined[]$ O O O O $number$ O O O O O O O $any$ O O $any$ O $any$ O O O O $complex$ O $complex$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $string$ O $any$ O $string$ O O $any$ O O O $any$ O $any$ O O O O O $any[]$ O $complex$ O $any[]$ O $number$ O $complex$ O $number$ O O O O O O O $any[]$ O O $any$ O $string$ O O O $number$ O O O O O O
import { Everything , TimeSettings } from "s" ; import moment from "s" ; import { FarmEventProps } from "s" ; import { joinFarmEventsToExecutable } from "s" ; import { Calendar } from "s" ; import { occurrence } from "s" ; import { findSequenceById , maybeGetDevice , maybeGetTimeSettings , } from "s" ; import { ResourceIndex } from "s" ; import { FarmEventWithRegimen , FarmEventWithSequence } from "s" ; import { scheduleForFarmEvent } from "s" ; import { last } from "s" ; import { RegimenItem } from "s" ; export function mapStateToProps ( state ) { const timeSettings = maybeGetTimeSettings ( state . resources . index ) ; const calendar = mapResourcesToCalendar ( state . resources . index , timeSettings , moment ( ) ) ; const calendarRows = calendar . getAll ( ) ; const dev = maybeGetDevice ( state . resources . index ) ; const timezoneIsSet = ! ! ( dev && ( dev . body . timezone ) ) ; return { calendarRows , timezoneIsSet } ; } export function mapResourcesToCalendar ( ri , timeSettings , now = moment ( ) ) { const x = joinFarmEventsToExecutable ( ri ) ; const calendar = new Calendar ( ) ; const addRegimenToCalendar = regimenCalendarAdder ( ri , timeSettings ) ; x . map ( function ( fe ) { switch ( fe . executable_type ) { case "s" : return addRegimenToCalendar ( fe , calendar , now ) ; case "s" : return addSequenceToCalendar ( fe , calendar , timeSettings , now ) ; } } ) ; return calendar ; } const fromEpoch = ( ms , start_time , timeSettings ) => moment ( start_time ) . utcOffset ( timeSettings . utcOffset ) . startOf ( "s" ) . add ( ms , "s" ) ; const itemGracePeriod = ( now : moment . Moment ) => now . clone ( ) . subtract ( 0 , "s" ) ; export const nextRegItemTimes = ( regimenItems : RegimenItem [ ] , startTime , now : moment . Moment , timeSettings ) : moment . Moment [ ] => { const times = regimenItems . map ( ri => fromEpoch ( ri . time_offset , startTime , timeSettings ) ) ; return times . filter ( time => time . isSameOrAfter ( itemGracePeriod ( now ) ) && time . isSameOrAfter ( moment ( startTime ) ) ) ; } ; export let regimenCalendarAdder = ( index , timeSettings ) => ( f , c , now = moment ( ) ) => { const { regimen_items } = f . executable ; const gracePeriod = itemGracePeriod ( now ) ; const lastRI = last ( regimen_items ) ; const lastRITime = lastRI && fromEpoch ( lastRI . time_offset , f . start_time , timeSettings ) ; if ( lastRITime && lastRITime . isSameOrAfter ( gracePeriod ) ) { const o = occurrence ( moment ( f . start_time ) , f , timeSettings ) ; o . heading = f . executable . name ; o . subheading = "s" ; c . insert ( o ) ; } regimen_items . map ( ri => { const time = fromEpoch ( ri . time_offset , f . start_time , timeSettings ) ; if ( time . isSameOrAfter ( gracePeriod ) && time . isSameOrAfter ( moment ( f . start_time ) ) ) { const oo = occurrence ( time , f , timeSettings ) ; const seq = findSequenceById ( index , ri . sequence_id ) ; oo . heading = f . executable . name ; oo . subheading = seq . body . name ; c . insert ( oo ) ; } } ) ; if ( f . end_time && Object . keys ( c . value ) . length === 0 ) { c . insert ( occurrence ( moment ( f . end_time ) , f , timeSettings , { empty : true } ) ) ; } } ; export let addSequenceToCalendar = ( f , c , timeSettings , now = moment ( ) ) => { const schedule = scheduleForFarmEvent ( f , now ) ; if ( f . end_time && schedule . items . length === 0 ) { c . insert ( occurrence ( moment ( f . end_time ) , f , timeSettings , { empty : true } ) ) ; } const lastItem = schedule . items . pop ( ) ; schedule . items . map ( m => c . insert ( occurrence ( m , f , timeSettings ) ) ) ; if ( schedule . shortenedBy > 0 ) { lastItem && c . insert ( occurrence ( lastItem , f , timeSettings , { numHidden : schedule . shortenedBy } ) ) ; } else { lastItem && c . insert ( occurrence ( lastItem , f , timeSettings ) ) ; } } ;	O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $FarmEventWithExecutable[]$ O O O O O O $any$ O O O O O O $CalendarOccurrence$ O O O O O O $any$ O $any$ O $TimeSettings$ O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $FarmEventProps$ O $Everything$ O O O $TimeSettings$ O $TimeSettings$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $Calendar$ O $Calendar$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $TimeSettings$ O $any$ O O O O O $CalendarDay[]$ O $Calendar$ O $CalendarDay[]$ O O O O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $boolean$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $CalendarDay[]$ O $boolean$ O O O O O $Calendar$ O $ResourceIndex$ O $TimeSettings$ O $any$ O $any$ O O O O O $FarmEventWithExecutable[]$ O $FarmEventWithExecutable[]$ O $ResourceIndex$ O O O $Calendar$ O O $any$ O O O O $void$ O $void$ O $ResourceIndex$ O $TimeSettings$ O O $FarmEventWithExecutable[]$ O $U[]$ O O O $FarmEventWithExecutable$ O O O O $FarmEventWithExecutable$ O O O O O O O O $void$ O $FarmEventWithRegimen$ O $Calendar$ O $any$ O O O O O O $void$ O $FarmEventWithSequence$ O $Calendar$ O $TimeSettings$ O $any$ O O O O O O O $Calendar$ O O O $any$ O O $number$ O $string$ O $TimeSettings$ O O $any$ O $string$ O O $any$ O $TimeSettings$ O $number$ O O $any$ O O O O $any$ O $number$ O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O O O $any[]$ O O $RegimenItem[]$ O $any$ O O O $string$ O $any$ O $any$ O $any$ O $TimeSettings$ O O $any$ O $any$ O O O O O $any[]$ O $RegimenItem[]$ O $U[]$ O $RegimenItem$ O $any$ O $RegimenItem$ O $number$ O $string$ O $TimeSettings$ O O O O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O O O O O O O $void$ O O $ResourceIndex$ O $TimeSettings$ O O O $FarmEventWithRegimen$ O $Calendar$ O $any$ O $any$ O O O O O O O $RegimenItem[]$ O O $FarmEventWithRegimen$ O $Regimen$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $RegimenItem[]$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $FarmEventWithRegimen$ O $any$ O $TimeSettings$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $CalendarOccurrence$ O $CalendarOccurrence$ O $any$ O $FarmEventWithRegimen$ O $any$ O O $FarmEventWithRegimen$ O $TimeSettings$ O O $CalendarOccurrence$ O $string$ O $FarmEventWithRegimen$ O $Regimen$ O $string$ O $CalendarOccurrence$ O $string$ O O O $Calendar$ O $void$ O $CalendarOccurrence$ O O O $RegimenItem[]$ O $U[]$ O $RegimenItem$ O O O $any$ O $any$ O $RegimenItem$ O $number$ O $FarmEventWithRegimen$ O $any$ O $TimeSettings$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $FarmEventWithRegimen$ O $any$ O O O O O $CalendarOccurrence$ O $CalendarOccurrence$ O $any$ O $FarmEventWithRegimen$ O $TimeSettings$ O O O $any$ O $any$ O $ResourceIndex$ O $RegimenItem$ O $number$ O O $CalendarOccurrence$ O $string$ O $FarmEventWithRegimen$ O $Regimen$ O $string$ O $CalendarOccurrence$ O $string$ O $any$ O $any$ O $any$ O $Calendar$ O $void$ O $CalendarOccurrence$ O O O O O O O O $FarmEventWithRegimen$ O $any$ O $ObjectConstructor$ O $complex$ O $Calendar$ O $any$ O O $number$ O O O O $Calendar$ O $void$ O $CalendarOccurrence$ O $any$ O $FarmEventWithRegimen$ O $any$ O O $FarmEventWithRegimen$ O $TimeSettings$ O O $true$ O O O O O O O O O O O $void$ O O $FarmEventWithSequence$ O $Calendar$ O $TimeSettings$ O $any$ O $any$ O O O O O O $complex$ O $complex$ O $FarmEventWithSequence$ O $any$ O O O O $FarmEventWithSequence$ O $any$ O $complex$ O $any[]$ O $number$ O O O O $Calendar$ O $void$ O $CalendarOccurrence$ O $any$ O $FarmEventWithSequence$ O $any$ O O $FarmEventWithSequence$ O $TimeSettings$ O O $true$ O O O O O O O O $any$ O $complex$ O $any[]$ O $any$ O O O $complex$ O $any[]$ O $U[]$ O $any$ O $Calendar$ O $void$ O $CalendarOccurrence$ O $any$ O $FarmEventWithSequence$ O $TimeSettings$ O O O O O O $complex$ O $number$ O O O O $any$ O $Calendar$ O $void$ O $CalendarOccurrence$ O $any$ O $FarmEventWithSequence$ O $TimeSettings$ O O $number$ O $complex$ O $number$ O O O O O O O $any$ O $Calendar$ O $void$ O $CalendarOccurrence$ O $any$ O $FarmEventWithSequence$ O $TimeSettings$ O O O O O O
import { mapStateToProps , mapResourcesToCalendar } from "s" ; import { fakeState } from "s" ; import { fakeSequence , fakeRegimen , fakeFarmEvent } from "s" ; import { buildResourceIndex } from "s" ; import moment from "s" ; import { countBy } from "s" ; import { TimeUnit } from "s" ; import { fakeTimeSettings } from "s" ; describe ( "s" , ( ) => { function testState ( ) { const sequence = fakeSequence ( ) ; sequence . body . id = 0 ; sequence . body . body = [ { kind : "s" , args : { } } ] ; const regimen = fakeRegimen ( ) ; regimen . body . id = 0 ; regimen . body . regimen_items = [ { sequence_id : 0 , time_offset : 0 } ] ; const sequenceFarmEvent = fakeFarmEvent ( "s" , sequence . body . id ) ; sequenceFarmEvent . body . id = 0 ; sequenceFarmEvent . body . start_time = "s" ; sequenceFarmEvent . body . end_time = "s" ; const regimenFarmEvent = fakeFarmEvent ( "s" , sequence . body . id ) ; regimenFarmEvent . body . id = 0 ; regimenFarmEvent . body . start_time = "s" ; regimenFarmEvent . body . end_time = "s" ; const fakeResources = [ sequence , regimen , sequenceFarmEvent , regimenFarmEvent ] ; const state = fakeState ( ) ; state . resources = buildResourceIndex ( fakeResources ) ; return state ; } it ( "s" , ( ) => { const { calendarRows } = mapStateToProps ( testState ( ) ) ; expect ( calendarRows ) . toEqual ( [ { day : 0 , items : [ { executableId : 0 , heading : "s" , id : 0 , mmddyy : "s" , sortKey : 0 , timeStr : "s" } ] , month : "s" , sortKey : 0 , year : 0 } , { day : 0 , items : [ { executableId : 0 , heading : "s" , id : 0 , mmddyy : "s" , sortKey : 0 , subheading : "s" , timeStr : "s" } , { executableId : 0 , heading : "s" , id : 0 , mmddyy : "s" , sortKey : 0 , subheading : "s" , timeStr : "s" } ] , month : "s" , sortKey : 0 , year : 0 } ] ) ; } ) ; } ) ; describe ( "s" , ( ) => { interface EventData { start_time : string ; end_time : string ; repeat ? : number ; time_unit ? : TimeUnit ; } function fakeSeqFEResources ( props ) { const sequence = fakeSequence ( ) ; sequence . body . id = 0 ; sequence . body . body = [ { kind : "s" , args : { } } ] ; const sequenceFarmEvent = fakeFarmEvent ( "s" , sequence . body . id ) ; sequenceFarmEvent . body . id = 0 ; sequenceFarmEvent . body . start_time = props . start_time ; sequenceFarmEvent . body . end_time = props . end_time ; sequenceFarmEvent . body . repeat = props . repeat || 0 ; sequenceFarmEvent . body . time_unit = props . time_unit || "s" ; return buildResourceIndex ( [ sequence , sequenceFarmEvent ] ) ; } const fakeSequenceFE = [ { day : expect . any ( Number ) , items : [ { executableId : 0 , heading : "s" , id : 0 , mmddyy : expect . stringContaining ( "s" ) , sortKey : expect . any ( Number ) , timeStr : expect . stringContaining ( "s" ) } ] , month : "s" , sortKey : expect . any ( Number ) , year : 0 } ] ; it ( "s" , ( ) => { const eventData = { start_time : "s" , end_time : "s" } ; const testTime = moment ( "s" ) ; const calendar = mapResourcesToCalendar ( fakeSeqFEResources ( eventData ) . index , fakeTimeSettings ( ) , testTime ) ; expect ( calendar . getAll ( ) ) . toEqual ( fakeSequenceFE ) ; } ) ; it ( "s" , ( ) => { const eventData = { start_time : "s" , end_time : "s" , repeat : 0 , time_unit : "s" } ; const testTime = moment ( "s" ) ; const calendar = mapResourcesToCalendar ( fakeSeqFEResources ( eventData ) . index , fakeTimeSettings ( ) , testTime ) ; const dayOneItems = calendar . getAll ( ) [ 0 ] . items ; expect ( countBy ( dayOneItems , "s" ) ) . toEqual ( { "s" : 0 , "s" : 0 } ) ; } ) ; it ( "s" , ( ) => { const eventData = { start_time : "s" , end_time : "s" , repeat : 0 , time_unit : "s" } ; const testTime = moment ( "s" ) ; const calendar = mapResourcesToCalendar ( fakeSeqFEResources ( eventData ) . index , fakeTimeSettings ( ) , testTime ) ; const dayOneItems = calendar . getAll ( ) [ 0 ] . items ; expect ( countBy ( dayOneItems , "s" ) ) . toEqual ( { "s" : 0 } ) ; } ) ; } ) ; describe ( "s" , ( ) => { function fakeRegFEResources ( ) { const sequence = fakeSequence ( ) ; sequence . body . id = 0 ; sequence . body . body = [ { kind : "s" , args : { } } ] ; const regimen = fakeRegimen ( ) ; regimen . body . id = 0 ; regimen . body . regimen_items = [ { sequence_id : 0 , time_offset : 0 } ] ; const regimenFarmEvent = fakeFarmEvent ( "s" , sequence . body . id ) ; regimenFarmEvent . body . id = 0 ; regimenFarmEvent . body . start_time = "s" ; regimenFarmEvent . body . end_time = "s" ; return buildResourceIndex ( [ sequence , regimen , regimenFarmEvent ] ) ; } const fakeRegimenFE = [ { day : expect . any ( Number ) , items : [ { executableId : 0 , heading : "s" , subheading : "s" , id : 0 , mmddyy : expect . stringContaining ( "s" ) , sortKey : expect . any ( Number ) , timeStr : expect . stringContaining ( "s" ) } ] , month : "s" , sortKey : expect . any ( Number ) , year : 0 } , { day : expect . any ( Number ) , items : [ { executableId : 0 , heading : "s" , subheading : "s" , id : 0 , mmddyy : expect . stringContaining ( "s" ) , sortKey : expect . any ( Number ) , timeStr : expect . stringContaining ( "s" ) } ] , month : "s" , sortKey : expect . any ( Number ) , year : 0 } ] ; it ( "s" , ( ) => { const testTime = moment ( "s" ) ; const calendar = mapResourcesToCalendar ( fakeRegFEResources ( ) . index , fakeTimeSettings ( ) , testTime ) ; expect ( calendar . getAll ( ) ) . toEqual ( fakeRegimenFE ) ; } ) ; it ( `template` , ( ) => { const testTime = moment ( "s" ) ; const calendar = mapResourcesToCalendar ( fakeRegFEResources ( ) . index , fakeTimeSettings ( ) , testTime ) ; expect ( calendar . getAll ( ) ) . toEqual ( [ { "s" : expect . any ( Number ) , "s" : [ expect . objectContaining ( { "s" : "s" } ) ] , "s" : "s" , "s" : expect . any ( Number ) , "s" : 0 } ] ) ; } ) ; } ) ;	O O $FarmEventProps$ O $Calendar$ O O O O O O $Everything$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $TimeSettings$ O O O O $any$ O O O O O O O O $Everything$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $string$ O O O ${}$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $number$ O O O $number$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $any$ O $any[]$ O O O $Everything$ O O $any$ O O O O O O O O O $CalendarDay[]$ O O $FarmEventProps$ O $Everything$ O O O O $any$ O $CalendarDay[]$ O O $any$ O O O $number$ O O O $complex$ O O O $number$ O O O $string$ O O O $number$ O O O $string$ O O O $number$ O O O $string$ O O O O O $string$ O O O $number$ O O O $number$ O O O O O $number$ O O O $complex$ O O O $number$ O O O $string$ O O O $number$ O O O $string$ O O O $number$ O O O $string$ O O O $string$ O O O O O $number$ O O O $string$ O O O $number$ O O O $string$ O O O $number$ O O O $string$ O O O $string$ O O O O O $string$ O O O $number$ O O O $number$ O O O O O O O O O O O O $any$ O O O O O O O O $any$ O $string$ O O O $string$ O O O $number$ O O O O $any$ O O $any$ O O O $any$ O $EventData$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $string$ O O O ${}$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $EventData$ O $string$ O $any$ O $any$ O $any$ O $EventData$ O $string$ O $any$ O $any$ O $any$ O $EventData$ O $number$ O O O $any$ O $any$ O $any$ O $EventData$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O O $complex$ O O O $any$ O $any$ O $any$ O $NumberConstructor$ O O $complex$ O O O $number$ O O O $string$ O O O $number$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $NumberConstructor$ O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $any$ O $any$ O $any$ O $NumberConstructor$ O O $number$ O O O O O $any$ O O O O O O O O $EventData$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O O O O O $Calendar$ O $Calendar$ O $any$ O $EventData$ O O $any$ O $TimeSettings$ O O O $any$ O O $any$ O $Calendar$ O $CalendarDay[]$ O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $EventData$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O O $any$ O $any$ O O O O O $Calendar$ O $Calendar$ O $any$ O $EventData$ O O $any$ O $TimeSettings$ O O O $any$ O O O $CalendarOccurrence[]$ O $Calendar$ O $CalendarDay[]$ O O O O O O $CalendarOccurrence[]$ O $any$ O $any$ O $CalendarOccurrence[]$ O O O O O $any$ O O O O O O O O O O O O O O O $any$ O O O O O O O O $EventData$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O O $any$ O $any$ O O O O O $Calendar$ O $Calendar$ O $any$ O $EventData$ O O $any$ O $TimeSettings$ O O O $any$ O O O $CalendarOccurrence[]$ O $Calendar$ O $CalendarDay[]$ O O O O O O $CalendarOccurrence[]$ O $any$ O $any$ O $CalendarOccurrence[]$ O O O O O $any$ O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $string$ O O O ${}$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $number$ O O O $number$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $complex$ O O O $any$ O $any$ O $any$ O $NumberConstructor$ O O $complex$ O O O $number$ O O O $string$ O O O $string$ O O O $number$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $NumberConstructor$ O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $any$ O $any$ O $any$ O $NumberConstructor$ O O $number$ O O O O O $any$ O $any$ O $any$ O $NumberConstructor$ O O $complex$ O O O $number$ O O O $string$ O O O $string$ O O O $number$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $NumberConstructor$ O O $any$ O $any$ O $any$ O O O O O O $string$ O O O $any$ O $any$ O $any$ O $NumberConstructor$ O O $number$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $Calendar$ O $Calendar$ O $any$ O O O $any$ O $TimeSettings$ O O O $any$ O O $any$ O $Calendar$ O $CalendarDay[]$ O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $Calendar$ O $Calendar$ O $any$ O O O $any$ O $TimeSettings$ O O O $any$ O O $any$ O $Calendar$ O $CalendarDay[]$ O O O O $any$ O O O O O $any$ O $any$ O $NumberConstructor$ O O O O O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O $NumberConstructor$ O O O O O O O O O O O O O O O
import { TaggedFarmEvent } from "s" ; import moment from "s" ; export function maybeWarnAboutMissedTasks ( tfe , cb , now = moment ( ) ) { return function ( ) { const fe = tfe . body ; if ( fe . executable_type === "s" ) { const NOW = now ; const START_TIME = moment ( fe . start_time ) ; const TIMEFMT = "s" ; ( START_TIME . format ( TIMEFMT ) === NOW . format ( TIMEFMT ) ) && cb ( ) ; } } ; }	O O $any$ O O O O O $any$ O O O O O $void$ O $TaggedFarmEvent$ O $Function$ O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $Function$ O O O O O O O
import { maybeWarnAboutMissedTasks } from "s" ; import { fakeFarmEvent } from "s" ; import moment from "s" ; import { ExecutableType } from "s" ; describe ( "s" , ( ) => { function testWarn ( time , executableType = "s" ) : ( ) => void { const callback = jest . fn ( ) ; const fe = fakeFarmEvent ( executableType , 0 ) ; fe . body . start_time = "s" ; maybeWarnAboutMissedTasks ( fe , ( ) => callback ( "s" ) , moment ( time ) ) ( ) ; return callback ; } it ( "s" , ( ) => { const cb = testWarn ( "s" ) ; expect ( cb ) . toHaveBeenCalledWith ( "s" ) ; } ) ; it ( "s" , ( ) => { const cb = testWarn ( "s" ) ; expect ( cb ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const cb = testWarn ( "s" , "s" ) ; expect ( cb ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ;	O O $void$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O O O O $void$ O $string$ O $ExecutableType$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O O O O $any$ O O O O $any$ O $string$ O O O O O O $any$ O O $any$ O O O O O O O O $void$ O $void$ O O O O $any$ O $void$ O O $any$ O O O O O O O $any$ O O O O O O O O $void$ O $void$ O O O O $any$ O $void$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $void$ O $void$ O O O O O O $any$ O $void$ O O $any$ O $any$ O O O O O O O O O
import { Calendar } from "s" ; import { occurrence } from "s" ; import { TIME , fakeFarmEventWithExecutable } from "s" ; import moment from "s" ; import { fakeTimeSettings } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const calendar = new Calendar ( ) ; expect ( calendar . getAll ( ) . length ) . toEqual ( 0 ) ; expect ( calendar . value ) . toEqual ( { } ) ; } ) ; it ( "s" , ( ) => { const calendar = new Calendar ( ) ; calendar . insert ( occurrence ( TIME . MONDAY , fakeFarmEventWithExecutable ( ) , fakeTimeSettings ( ) ) ) ; calendar . insert ( occurrence ( TIME . TUESDAY , fakeFarmEventWithExecutable ( ) , fakeTimeSettings ( ) ) ) ; expect ( calendar . value ) . toEqual ( expect . objectContaining ( { "s" : expect . any ( Array ) , "s" : expect . any ( Array ) } ) ) ; } ) ; it ( "s" , ( ) => { const calendar = new Calendar ( ) ; const wow = occurrence ( TIME . MONDAY , fakeFarmEventWithExecutable ( ) , fakeTimeSettings ( ) ) ; calendar . insert ( wow ) ; expect ( calendar . findByDate ( TIME . FRIDAY ) ) . toBeInstanceOf ( Array ) ; expect ( calendar . findByDate ( TIME . MONDAY ) ) . toContain ( wow ) ; } ) ; it ( "s" , ( ) => { const calendar = new Calendar ( ) ; const earlyDay = moment ( "s" ) ; const lateDay = moment ( "s" ) ; calendar . insert ( occurrence ( lateDay , fakeFarmEventWithExecutable ( ) , fakeTimeSettings ( ) ) ) ; calendar . insert ( occurrence ( earlyDay , fakeFarmEventWithExecutable ( ) , fakeTimeSettings ( ) ) ) ; const items = calendar . getAll ( ) [ 0 ] . items ; expect ( items [ 0 ] . sortKey < items [ 0 ] . sortKey ) . toBeTruthy ( ) ; } ) ; it ( "s" , ( ) => { const calendar = new Calendar ( ) ; calendar . insert ( occurrence ( TIME . MONDAY , fakeFarmEventWithExecutable ( ) , fakeTimeSettings ( ) ) ) ; const day = calendar . getAll ( ) [ 0 ] ; expect ( day ) . toEqual ( expect . objectContaining ( { day : 0 , month : "s" , year : 0 , sortKey : expect . any ( Number ) , items : expect . any ( Array ) } ) ) ; } ) ; } ) ;	O O $any$ O O O O O O $CalendarOccurrence$ O O O O O O $complex$ O $FarmEventWithExecutable$ O O O O O $any$ O O O O O $TimeSettings$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Calendar$ O O $any$ O O O $any$ O $Calendar$ O $CalendarDay[]$ O O O $number$ O O $any$ O O O O $any$ O $Calendar$ O $any$ O O $any$ O O O O O O O O $any$ O O O O O O O O $Calendar$ O O $any$ O O O $Calendar$ O $void$ O $CalendarOccurrence$ O $complex$ O $any$ O $FarmEventWithExecutable$ O O O $TimeSettings$ O O O O O $Calendar$ O $void$ O $CalendarOccurrence$ O $complex$ O $any$ O $FarmEventWithExecutable$ O O O $TimeSettings$ O O O O O $any$ O $Calendar$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $ArrayConstructor$ O O O O $any$ O $any$ O $ArrayConstructor$ O O O O O O O O $any$ O O O O O O O O $Calendar$ O O $any$ O O O O $CalendarOccurrence$ O $CalendarOccurrence$ O $complex$ O $any$ O $FarmEventWithExecutable$ O O O $TimeSettings$ O O O O $Calendar$ O $void$ O $CalendarOccurrence$ O O $any$ O $Calendar$ O $CalendarOccurrence[]$ O $complex$ O $any$ O O O $any$ O $ArrayConstructor$ O O $any$ O $Calendar$ O $CalendarOccurrence[]$ O $complex$ O $any$ O O O $any$ O $CalendarOccurrence$ O O O O O $any$ O O O O O O O O $Calendar$ O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $Calendar$ O $void$ O $CalendarOccurrence$ O $any$ O $FarmEventWithExecutable$ O O O $TimeSettings$ O O O O O $Calendar$ O $void$ O $CalendarOccurrence$ O $any$ O $FarmEventWithExecutable$ O O O $TimeSettings$ O O O O O O $CalendarOccurrence[]$ O $Calendar$ O $CalendarDay[]$ O O O O O O $CalendarOccurrence[]$ O $any$ O $CalendarOccurrence[]$ O O O O $number$ O $CalendarOccurrence[]$ O O O O $number$ O O $any$ O O O O O O $any$ O O O O O O O O $Calendar$ O O $any$ O O O $Calendar$ O $void$ O $CalendarOccurrence$ O $complex$ O $any$ O $FarmEventWithExecutable$ O O O $TimeSettings$ O O O O O O $CalendarDay$ O $Calendar$ O $CalendarDay[]$ O O O O O O $any$ O $CalendarDay$ O O $any$ O $any$ O $any$ O O $number$ O O O $string$ O O O $number$ O O O $any$ O $any$ O $any$ O $NumberConstructor$ O O $any$ O $any$ O $any$ O $ArrayConstructor$ O O O O O O O O O O O
import { occurrence } from "s" ; import moment from "s" ; import { TIME , fakeFarmEventWithExecutable } from "s" ; import { fakeTimeSettings } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const fe = fakeFarmEventWithExecutable ( ) ; const t = occurrence ( TIME . MONDAY , fe , fakeTimeSettings ( ) ) ; expect ( t . executableId ) . toBe ( fe . executable_id ) ; expect ( t . mmddyy ) . toBe ( "s" ) ; expect ( t . sortKey ) . toBe ( moment ( TIME . MONDAY ) . unix ( ) ) ; expect ( t . heading ) . toBe ( fe . executable . name ) ; expect ( t . id ) . toBe ( fe . id ) ; } ) ; it ( "s" , ( ) => { const fe = fakeFarmEventWithExecutable ( ) ; fe . executable . name = "s" ; const t = occurrence ( TIME . MONDAY , fe , fakeTimeSettings ( ) , { numHidden : 0 } ) ; expect ( t . heading ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { const fe = fakeFarmEventWithExecutable ( ) ; const t = occurrence ( TIME . MONDAY , fe , fakeTimeSettings ( ) , { empty : true } ) ; expect ( t . heading ) . toBe ( "s" ) ; } ) ; } ) ;	O O $CalendarOccurrence$ O O O O O $any$ O O O O O $complex$ O $FarmEventWithExecutable$ O O O O O O $TimeSettings$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $FarmEventWithExecutable$ O $FarmEventWithExecutable$ O O O O $CalendarOccurrence$ O $CalendarOccurrence$ O $complex$ O $any$ O $FarmEventWithExecutable$ O $TimeSettings$ O O O O $any$ O $CalendarOccurrence$ O $number$ O O $any$ O $FarmEventWithExecutable$ O $any$ O O $any$ O $CalendarOccurrence$ O $string$ O O $any$ O O O O $any$ O $CalendarOccurrence$ O $number$ O O $any$ O $any$ O $complex$ O $any$ O O $any$ O O O O $any$ O $CalendarOccurrence$ O $string$ O O $any$ O $FarmEventWithExecutable$ O $complex$ O $string$ O O $any$ O $CalendarOccurrence$ O $number$ O O $any$ O $FarmEventWithExecutable$ O $any$ O O O O O $any$ O O O O O O O O $FarmEventWithExecutable$ O $FarmEventWithExecutable$ O O O $FarmEventWithExecutable$ O $complex$ O $string$ O O O O $CalendarOccurrence$ O $CalendarOccurrence$ O $complex$ O $any$ O $FarmEventWithExecutable$ O $TimeSettings$ O O O O $number$ O O O O O $any$ O $CalendarOccurrence$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $FarmEventWithExecutable$ O $FarmEventWithExecutable$ O O O O $CalendarOccurrence$ O $CalendarOccurrence$ O $complex$ O $any$ O $FarmEventWithExecutable$ O $TimeSettings$ O O O O $true$ O O O O O $any$ O $CalendarOccurrence$ O $string$ O O $any$ O O O O O O O O O O
import { scheduler , scheduleForFarmEvent , TimeLine , farmEventIntervalSeconds , maxDisplayItems , gracePeriodSeconds } from "s" ; import moment from "s" ; import { Moment } from "s" ; import { range , padStart } from "s" ; import { TimeUnit } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const monday = moment ( ) . add ( 0 , "s" ) . startOf ( "s" ) . startOf ( "s" ) . add ( 0 , "s" ) ; const tuesday = monday . clone ( ) . add ( 0 , "s" ) ; const thursday = monday . clone ( ) . add ( 0 , "s" ) . add ( 0 , "s" ) ; const interval = moment . duration ( 0 , "s" ) . asSeconds ( ) ; const 0 = scheduler ( { currentTime : monday , intervalSeconds : interval , startTime : tuesday , endTime : thursday } ) ; expect ( 0 . items [ 0 ] . format ( "s" ) ) . toEqual ( "s" ) ; expect ( 0 . items [ 0 ] . hour ( ) ) . toEqual ( 0 ) ; expect ( 0 . items . length ) . toEqual ( 0 ) ; const EXPECTED = [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ; const REALITY = 0 . items . map ( x => x . format ( "s" ) ) ; EXPECTED . map ( x => expect ( REALITY ) . toContain ( x ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { interface TestScheduleProps { description : string ; fakeEvent : TimeLine ; timeNow : Moment ; expected : Moment [ ] ; shortenedBy : number ; } function testSchedule ( props ) { const { description , fakeEvent , timeNow , expected , shortenedBy } = props ; it ( description , ( ) => { const result = scheduleForFarmEvent ( fakeEvent , timeNow ) ; expect ( result . items . length ) . toEqual ( expected . length ) ; expected . map ( ( expectation , index ) => { expect ( result . items [ index ] ) . toBeSameTimeAs ( expectation ) ; } ) ; expect ( result . shortenedBy ) . toEqual ( shortenedBy ) ; } ) ; } const singleFarmEvent = { start_time : "s" , end_time : "s" , repeat : 0 , time_unit : "s" } ; const scheduleTestData : TestScheduleProps [ ] = [ { description : "s" , fakeEvent : { start_time : "s" , end_time : "s" , repeat : 0 , time_unit : "s" } , timeNow : moment ( "s" ) , expected : [ moment ( "s" ) , moment ( "s" ) , moment ( "s" ) ] , shortenedBy : 0 } , { description : "s" , fakeEvent : { start_time : "s" , end_time : "s" , repeat : 0 , time_unit : "s" } , timeNow : moment ( "s" ) , expected : [ moment ( "s" ) ] , shortenedBy : 0 } , { description : "s" , fakeEvent : { start_time : "s" , end_time : "s" , repeat : 0 , time_unit : "s" } , timeNow : moment ( "s" ) , expected : [ moment ( "s" ) , moment ( "s" ) ] , shortenedBy : 0 } , { description : "s" , fakeEvent : singleFarmEvent , timeNow : moment ( "s" ) , expected : [ moment ( "s" ) ] , shortenedBy : 0 } , { description : `template` , fakeEvent : { start_time : "s" , end_time : "s" , repeat : 0 , time_unit : "s" } , timeNow : moment ( "s" ) . add ( gracePeriodSeconds / 0 , "s" ) , expected : [ moment ( "s" ) , moment ( "s" ) , moment ( "s" ) ] , shortenedBy : 0 } , { description : `template` , fakeEvent : singleFarmEvent , timeNow : moment ( "s" ) . add ( gracePeriodSeconds / 0 , "s" ) , expected : [ moment ( "s" ) ] , shortenedBy : 0 } , { description : "s" , fakeEvent : { start_time : "s" , end_time : "s" , repeat : 0 , time_unit : "s" } , timeNow : moment ( "s" ) , expected : [ ] , shortenedBy : 0 } , { description : "s" , fakeEvent : singleFarmEvent , timeNow : moment ( "s" ) , expected : [ ] , shortenedBy : 0 } , { description : `template` , fakeEvent : { start_time : "s" , end_time : "s" , repeat : 0 , time_unit : "s" } , timeNow : moment ( "s" ) , expected : range ( 0 , maxDisplayItems ) . map ( ( x ) => moment ( `template` ) ) , shortenedBy : 0 - maxDisplayItems } , { description : `template` , fakeEvent : { start_time : "s" , end_time : "s" , repeat : 0 , time_unit : "s" } , timeNow : moment ( "s" ) . add ( gracePeriodSeconds , "s" ) , expected : range ( 0 , maxDisplayItems ) . map ( ( x ) => moment ( `template` ) ) , shortenedBy : 0 - maxDisplayItems } , { description : "s" , fakeEvent : { start_time : "s" , end_time : "s" , repeat : 0 , time_unit : "s" } , timeNow : moment ( "s" ) , expected : [ moment ( "s" ) , moment ( "s" ) ] , shortenedBy : 0 } , { description : `template` , fakeEvent : { start_time : "s" , end_time : "s" , repeat : 0 , time_unit : "s" } , timeNow : moment ( "s" ) . add ( gracePeriodSeconds , "s" ) , expected : [ moment ( "s" ) , moment ( "s" ) ] , shortenedBy : 0 } , ] ; scheduleTestData . map ( testCaseData => testSchedule ( testCaseData ) ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { interface TestBarage { count : number ; result : number ; unit : TimeUnit ; } const tests : TestBarage [ ] = [ { count : 0 , unit : "s" , result : 0 } , { count : 0 , unit : "s" , result : 0 } , { count : 0 , unit : "s" , result : 0 } , { count : 0 , unit : "s" , result : 0 } , { count : 0 , unit : "s" , result : 0 } , { count : 0 , unit : "s" , result : 0 } , { count : 0 , unit : "s" , result : 0 } ] ; tests . forEach ( ( T ) => { expect ( farmEventIntervalSeconds ( T . count , T . unit ) ) . toEqual ( T . result ) ; } ) ; } ) ; } ) ;	O O $complex$ O $complex$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O $complex$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $complex$ O $any[]$ O O O O $any$ O O O O O $any$ O O O O $any$ O $complex$ O $any[]$ O O O O $any$ O O O O $any$ O O O O $any$ O $complex$ O $any[]$ O $number$ O O $any$ O O O O O $string[]$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any[]$ O $complex$ O $any[]$ O $U[]$ O $any$ O $any$ O $any$ O O O O O $string[]$ O $U[]$ O $string$ O $any$ O $any[]$ O O $any$ O $string$ O O O O O O O O O $any$ O O O O O O O O $any$ O $string$ O O O $TimeLine$ O $any$ O $any$ O $any$ O $any[]$ O $any$ O O O $number$ O O O O O $void$ O $TestScheduleProps$ O O O O $string$ O $TimeLine$ O $any$ O $any[]$ O $number$ O O $TestScheduleProps$ O $any$ O $string$ O O O O O O $complex$ O $complex$ O $TimeLine$ O $any$ O O $any$ O $complex$ O $any[]$ O $number$ O O $any$ O $any[]$ O $number$ O O $any[]$ O $U[]$ O O $any$ O $number$ O O O $any$ O $complex$ O $any[]$ O $number$ O O O $any$ O $any$ O O O O O $any$ O $complex$ O $number$ O O $any$ O $number$ O O O O O O O $TimeLine$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O O $TestScheduleProps[]$ O $any$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O $any$ O $any$ O O O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O O $number$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O $any$ O $any$ O O O O $any[]$ O O $any$ O O O O O $number$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O $any$ O $any$ O O O O $any[]$ O O $any$ O O O O $any$ O O O O O $number$ O O O O O $string$ O O O $TimeLine$ O $TimeLine$ O $any$ O $any$ O O O O $any[]$ O O $any$ O O O O O $number$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O O $number$ O O O O O $string$ O O O $TimeLine$ O $TimeLine$ O $any$ O $any$ O O O O $any$ O O O O O O O O $any[]$ O O $any$ O O O O O $number$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O $any$ O $any$ O O O O $undefined[]$ O O O O $number$ O O O O O $string$ O O O $TimeLine$ O $TimeLine$ O $any$ O $any$ O O O O $undefined[]$ O O O O $number$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O $number$ O O $any$ O O O O O $number$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $number$ O O $any$ O O O O O $number$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O $any$ O $any$ O O O O $any[]$ O O $any$ O O O O $any$ O O O O O $number$ O O O O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $string$ O O O O $any$ O $any$ O O O O $any$ O O O O O O $any[]$ O O $any$ O O O O $any$ O O O O O $number$ O O O O O O $TestScheduleProps[]$ O $U[]$ O $TestScheduleProps$ O $void$ O $TestScheduleProps$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $number$ O O O $number$ O O O $any$ O $any$ O O O $TestBarage[]$ O $any$ O O O O O $number$ O O O $string$ O O O $number$ O O O O O $number$ O O O $string$ O O O $number$ O O O O O $number$ O O O $string$ O O O $number$ O O O O O $number$ O O O $string$ O O O $number$ O O O O O $number$ O O O $string$ O O O $number$ O O O O O $number$ O O O $string$ O O O $number$ O O O O O $number$ O O O $string$ O O O $number$ O O O O O $TestBarage[]$ O $void$ O O $TestBarage$ O O O $any$ O $any$ O $TestBarage$ O $number$ O $TestBarage$ O $any$ O O O $any$ O $TestBarage$ O $number$ O O O O O O O O O O O
let mockPath = "s" ; jest . mock ( "s" , ( ) => ( { getPathArray : jest . fn ( ( ) => mockPath . split ( "s" ) ) , history : { getCurrentLocation : ( ) => ( { pathname : mockPath } ) } } ) ) ; jest . mock ( "s" , ( ) => ( { savedGardenOpen : ( ) => true , } ) ) ; import { round , translateScreenToGarden , getBotSize , getMapSize , transformXY , transformForQuadrant , getGardenCoordinates , MapPanelStatus , mapPanelClassName , getMode , } from "s" ; import { McuParams } from "s" ; import { AxisNumberProperty , BotSize , MapTransformProps , Mode } from "s" ; import { StepsPerMmXY } from "s" ; import { fakeMapTransformProps } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( round ( 0 ) ) . toEqual ( 0 ) ; expect ( round ( 0 ) ) . toEqual ( 0 ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = translateScreenToGarden ( { mapTransformProps : fakeMapTransformProps ( ) , page : { x : 0 , y : 0 } , scroll : { left : 0 , top : 0 } , zoomLvl : 0 , gridOffset : { x : 0 , y : 0 } , panelStatus : MapPanelStatus . open , } ) ; expect ( result ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; it ( "s" , ( ) => { const result = translateScreenToGarden ( { mapTransformProps : fakeMapTransformProps ( ) , page : { x : 0 , y : 0 } , scroll : { left : 0 , top : 0 } , zoomLvl : 0 , gridOffset : { x : 0 , y : 0 } , panelStatus : MapPanelStatus . open , } ) ; expect ( result ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; it ( "s" , ( ) => { const result = translateScreenToGarden ( { mapTransformProps : fakeMapTransformProps ( ) , page : { x : 0 , y : 0 } , scroll : { left : 0 , top : 0 } , zoomLvl : 0 , gridOffset : { x : 0 , y : 0 } , panelStatus : MapPanelStatus . open , } ) ; expect ( result ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; it ( "s" , ( ) => { const mapTransformProps = fakeMapTransformProps ( ) ; mapTransformProps . quadrant = 0 ; mapTransformProps . gridSize = { x : 0 , y : 0 } ; const result = translateScreenToGarden ( { mapTransformProps , page : { x : 0 , y : 0 } , scroll : { left : 0 , top : 0 } , zoomLvl : 0 , gridOffset : { x : 0 , y : 0 } , panelStatus : MapPanelStatus . open , } ) ; expect ( result ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; it ( "s" , ( ) => { const mapTransformProps = fakeMapTransformProps ( ) ; mapTransformProps . xySwap = true ; mapTransformProps . quadrant = 0 ; mapTransformProps . gridSize = { x : 0 , y : 0 } ; const result = translateScreenToGarden ( { mapTransformProps , page : { x : 0 , y : 0 } , scroll : { left : 0 , top : 0 } , zoomLvl : 0 , gridOffset : { x : 0 , y : 0 } , panelStatus : MapPanelStatus . open , } ) ; expect ( result ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; it ( "s" , ( ) => { const result = translateScreenToGarden ( { mapTransformProps : fakeMapTransformProps ( ) , page : { x : 0 , y : 0 } , scroll : { left : 0 , top : 0 } , zoomLvl : 0 , gridOffset : { x : 0 , y : 0 } , panelStatus : MapPanelStatus . closed , } ) ; expect ( result ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; it ( "s" , ( ) => { const result = translateScreenToGarden ( { mapTransformProps : fakeMapTransformProps ( ) , page : { x : 0 , y : 0 } , scroll : { left : 0 , top : 0 } , zoomLvl : 0 , gridOffset : { x : 0 , y : 0 } , panelStatus : MapPanelStatus . short , } ) ; expect ( result ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; } ) ; describe ( "s" , ( ) => { function fakeProps ( ) { const botMcuParams = { movement_stop_at_max_x : undefined , movement_stop_at_max_y : undefined , movement_axis_nr_steps_x : undefined , movement_axis_nr_steps_y : undefined } ; const stepsPerMmXY = { x : undefined , y : undefined } ; const defaultLength = { x : 0 , y : 0 } ; return { botMcuParams , stepsPerMmXY , defaultLength } ; } function expectDefaultSize ( botSize ) { expect ( botSize ) . toEqual ( { x : { value : 0 , isDefault : true } , y : { value : 0 , isDefault : true } } ) ; } it ( "s" , ( ) => { const p = fakeProps ( ) ; const botSize = getBotSize ( p . botMcuParams , p . stepsPerMmXY , p . defaultLength ) ; expectDefaultSize ( botSize ) ; } ) ; it ( "s" , ( ) => { const p = fakeProps ( ) ; p . botMcuParams = { movement_stop_at_max_x : 0 , movement_stop_at_max_y : 0 , movement_axis_nr_steps_x : 0 , movement_axis_nr_steps_y : 0 } ; const botSize = getBotSize ( p . botMcuParams , p . stepsPerMmXY , p . defaultLength ) ; expectDefaultSize ( botSize ) ; } ) ; it ( "s" , ( ) => { const p = fakeProps ( ) ; p . botMcuParams = { movement_stop_at_max_x : 0 , movement_stop_at_max_y : 0 , movement_axis_nr_steps_x : 0 , movement_axis_nr_steps_y : 0 } ; const botSize = getBotSize ( p . botMcuParams , p . stepsPerMmXY , p . defaultLength ) ; expectDefaultSize ( botSize ) ; } ) ; it ( "s" , ( ) => { const p = fakeProps ( ) ; p . botMcuParams = { movement_stop_at_max_x : 0 , movement_stop_at_max_y : 0 , movement_axis_nr_steps_x : 0 , movement_axis_nr_steps_y : 0 } ; p . stepsPerMmXY = { x : 0 , y : 0 } ; const botSize = getBotSize ( p . botMcuParams , p . stepsPerMmXY , p . defaultLength ) ; expectDefaultSize ( botSize ) ; } ) ; it ( "s" , ( ) => { const p = fakeProps ( ) ; p . botMcuParams = { movement_stop_at_max_x : 0 , movement_stop_at_max_y : 0 , movement_axis_nr_steps_x : 0 , movement_axis_nr_steps_y : 0 } ; p . stepsPerMmXY = { x : 0 , y : 0 } ; const botSize = getBotSize ( p . botMcuParams , p . stepsPerMmXY , p . defaultLength ) ; expect ( botSize ) . toEqual ( { x : { value : 0 , isDefault : false } , y : { value : 0 , isDefault : false } } ) ; } ) ; it ( "s" , ( ) => { const p = fakeProps ( ) ; p . botMcuParams = { movement_stop_at_max_x : 0 , movement_stop_at_max_y : 0 , movement_axis_nr_steps_x : 0 , movement_axis_nr_steps_y : 0 } ; p . stepsPerMmXY = { x : 0 , y : 0 } ; const botSize = getBotSize ( p . botMcuParams , p . stepsPerMmXY , p . defaultLength ) ; expect ( botSize ) . toEqual ( { x : { value : 0 , isDefault : true } , y : { value : 0 , isDefault : false } } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const mapSize = getMapSize ( fakeMapTransformProps ( ) , { x : 0 , y : 0 } ) ; expect ( mapSize ) . toEqual ( { h : 0 , w : 0 } ) ; } ) ; it ( "s" , ( ) => { const fakeMPT = fakeMapTransformProps ( ) ; fakeMPT . xySwap = true ; const mapSize = getMapSize ( fakeMPT , { x : 0 , y : 0 } ) ; expect ( mapSize ) . toEqual ( { h : 0 , w : 0 } ) ; } ) ; } ) ; describe ( "s" , ( ) => { const mapTransformProps = fakeMapTransformProps ( ) ; mapTransformProps . gridSize = { x : 0 , y : 0 } ; type QXY = { qx : number , qy : number } ; const transformCheck = ( original , transformed , transformProps ) => { transformProps . xySwap = false ; expect ( transformXY ( original . qx , original . qy , transformProps ) ) . toEqual ( transformed ) ; expect ( transformXY ( transformed . qx , transformed . qy , transformProps ) ) . toEqual ( original ) ; transformProps . xySwap = true ; const transformedYX = { qx : transformed . qy , qy : transformed . qx } ; expect ( transformXY ( original . qx , original . qy , transformProps ) ) . toEqual ( transformedYX ) ; expect ( transformXY ( transformed . qx , transformed . qy , transformProps ) ) . toEqual ( { qx : original . qy , qy : original . qx } ) ; } ; it ( "s" , ( ) => { const original = { qx : 0 , qy : 0 } ; const transformed = { qx : 0 , qy : 0 } ; mapTransformProps . quadrant = 0 ; transformCheck ( original , transformed , mapTransformProps ) ; } ) ; it ( "s" , ( ) => { const original = { qx : 0 , qy : 0 } ; const transformed = { qx : 0 , qy : 0 } ; mapTransformProps . quadrant = 0 ; transformCheck ( original , transformed , mapTransformProps ) ; } ) ; it ( "s" , ( ) => { const original = { qx : 0 , qy : 0 } ; const transformed = { qx : - 0 , qy : - 0 } ; mapTransformProps . quadrant = 0 ; transformCheck ( original , transformed , mapTransformProps ) ; } ) ; } ) ; describe ( "s" , ( ) => { const mapTransformProps = fakeMapTransformProps ( ) ; mapTransformProps . gridSize = { x : 0 , y : 0 } ; it ( "s" , ( ) => { mapTransformProps . quadrant = 0 ; expect ( transformForQuadrant ( mapTransformProps ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { mapTransformProps . quadrant = 0 ; expect ( transformForQuadrant ( mapTransformProps ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { mapTransformProps . quadrant = 0 ; expect ( transformForQuadrant ( mapTransformProps ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { mapTransformProps . quadrant = 0 ; expect ( transformForQuadrant ( mapTransformProps ) ) . toEqual ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { mockPath = "s" ; expect ( getMode ( ) ) . toEqual ( Mode . clickToAdd ) ; mockPath = "s" ; expect ( getMode ( ) ) . toEqual ( Mode . editPlant ) ; mockPath = "s" ; expect ( getMode ( ) ) . toEqual ( Mode . editPlant ) ; mockPath = "s" ; expect ( getMode ( ) ) . toEqual ( Mode . editPlant ) ; mockPath = "s" ; expect ( getMode ( ) ) . toEqual ( Mode . editPlant ) ; mockPath = "s" ; expect ( getMode ( ) ) . toEqual ( Mode . boxSelect ) ; mockPath = "s" ; expect ( getMode ( ) ) . toEqual ( Mode . addPlant ) ; mockPath = "s" ; expect ( getMode ( ) ) . toEqual ( Mode . moveTo ) ; mockPath = "s" ; expect ( getMode ( ) ) . toEqual ( Mode . createPoint ) ; mockPath = "s" ; expect ( getMode ( ) ) . toEqual ( Mode . templateView ) ; mockPath = "s" ; expect ( getMode ( ) ) . toEqual ( Mode . addPointToGroup ) ; } ) ; } ) ; describe ( "s" , ( ) => { beforeEach ( ( ) => { Object . defineProperty ( document , "s" , { value : ( ) => ( { scrollLeft : 0 , scrollTop : 0 } ) , configurable : true } ) ; Object . defineProperty ( window , "s" , { value : ( ) => ( { zoom : 0 } ) , configurable : true } ) ; } ) ; const fakeProps = ( ) => ( { mapTransformProps : fakeMapTransformProps ( ) , gridOffset : { x : 0 , y : 0 } , pageX : 0 , pageY : 0 , } ) ; it ( "s" , ( ) => { const result = getGardenCoordinates ( fakeProps ( ) ) ; expect ( result ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; it ( "s" , ( ) => { Object . defineProperty ( window , "s" , { value : ( ) => ( { zoom : undefined } ) , configurable : true } ) ; const result = getGardenCoordinates ( fakeProps ( ) ) ; expect ( result ) . toEqual ( { x : 0 , y : 0 } ) ; } ) ; it ( "s" , ( ) => { Object . defineProperty ( document , "s" , { value : ( ) => { } , configurable : true } ) ; const result = getGardenCoordinates ( fakeProps ( ) ) ; expect ( result ) . toEqual ( undefined ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { Object . defineProperty ( window , "s" , { value : 0 , configurable : true } ) ; mockPath = "s" ; expect ( mapPanelClassName ( ) ) . toEqual ( "s" ) ; mockPath = "s" ; expect ( mapPanelClassName ( ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { Object . defineProperty ( window , "s" , { value : 0 , configurable : true } ) ; mockPath = "s" ; expect ( mapPanelClassName ( ) ) . toEqual ( "s" ) ; mockPath = "s" ; expect ( mapPanelClassName ( ) ) . toEqual ( "s" ) ; } ) ; } ) ;	O $string$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $string$ O $complex$ O O O O O $complex$ O O $complex$ O O O O O O $string$ O $string$ O O O O O O O $any$ O $any$ O O O O O O O O $boolean$ O O O O O O O O O O O O $number$ O $XYCoordinate$ O $complex$ O $complex$ O $complex$ O $string$ O $complex$ O $any$ O $complex$ O $Mode$ O O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $MapTransformProps$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $number$ O O O O O $any$ O O O O $any$ O $number$ O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $XYCoordinate$ O $XYCoordinate$ O O $MapTransformProps$ O $MapTransformProps$ O O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O $number$ O O O $complex$ O O $number$ O O O $number$ O O O O $MapPanelStatus.open$ O $any$ O $MapPanelStatus.open$ O O O O $any$ O $XYCoordinate$ O O $any$ O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O O $XYCoordinate$ O $XYCoordinate$ O O $MapTransformProps$ O $MapTransformProps$ O O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O $number$ O O O $complex$ O O $number$ O O O $number$ O O O O $MapPanelStatus.open$ O $any$ O $MapPanelStatus.open$ O O O O $any$ O $XYCoordinate$ O O $any$ O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O O $XYCoordinate$ O $XYCoordinate$ O O $MapTransformProps$ O $MapTransformProps$ O O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O $number$ O O O $complex$ O O $number$ O O O $number$ O O O O $MapPanelStatus.open$ O $any$ O $MapPanelStatus.open$ O O O O $any$ O $XYCoordinate$ O O $any$ O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O O $MapTransformProps$ O $MapTransformProps$ O O O $MapTransformProps$ O $BotOriginQuadrant$ O O O $MapTransformProps$ O $complex$ O O $number$ O O O $number$ O O O O O $XYCoordinate$ O $XYCoordinate$ O O $MapTransformProps$ O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O $number$ O O O $complex$ O O $number$ O O O $number$ O O O O $MapPanelStatus.open$ O $any$ O $MapPanelStatus.open$ O O O O $any$ O $XYCoordinate$ O O $any$ O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O O $MapTransformProps$ O $MapTransformProps$ O O O $MapTransformProps$ O $boolean$ O O O $MapTransformProps$ O $BotOriginQuadrant$ O O O $MapTransformProps$ O $complex$ O O $number$ O O O $number$ O O O O O $XYCoordinate$ O $XYCoordinate$ O O $MapTransformProps$ O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O $number$ O O O $complex$ O O $number$ O O O $number$ O O O O $MapPanelStatus.open$ O $any$ O $MapPanelStatus.open$ O O O O $any$ O $XYCoordinate$ O O $any$ O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O O $XYCoordinate$ O $XYCoordinate$ O O $MapTransformProps$ O $MapTransformProps$ O O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O $number$ O O O $complex$ O O $number$ O O O $number$ O O O O $MapPanelStatus.closed$ O $any$ O $MapPanelStatus.closed$ O O O O $any$ O $XYCoordinate$ O O $any$ O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O O $XYCoordinate$ O $XYCoordinate$ O O $MapTransformProps$ O $MapTransformProps$ O O O $complex$ O O $number$ O O O $number$ O O O O $complex$ O O $number$ O O O $number$ O O O O $number$ O O O $complex$ O O $number$ O O O $number$ O O O O $MapPanelStatus.short$ O $any$ O $MapPanelStatus.short$ O O O O $any$ O $XYCoordinate$ O O $any$ O O $number$ O O O $number$ O O O O O O O O O O O $any$ O O O O O O O O $complex$ O O O O $McuParams$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O $StepsPerMmXY$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O $AxisNumberProperty$ O O $number$ O O O $number$ O O O O O O $any$ O $complex$ O $complex$ O O O O $void$ O $BotSize$ O O $any$ O $complex$ O O $any$ O O $complex$ O O $number$ O O O $boolean$ O O O O $complex$ O O $number$ O O O $boolean$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O O $complex$ O $complex$ O $complex$ O $any$ O $complex$ O $complex$ O $complex$ O $complex$ O O $void$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $complex$ O $any$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O $complex$ O $complex$ O $complex$ O $any$ O $complex$ O $complex$ O $complex$ O $complex$ O O $void$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $complex$ O $any$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O $complex$ O $complex$ O $complex$ O $any$ O $complex$ O $complex$ O $complex$ O $complex$ O O $void$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $complex$ O $any$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O $complex$ O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O $complex$ O $complex$ O $any$ O $complex$ O $complex$ O $complex$ O $complex$ O O $void$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $complex$ O $any$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O $complex$ O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O $complex$ O $complex$ O $any$ O $complex$ O $complex$ O $complex$ O $complex$ O O $any$ O $complex$ O O $any$ O O $complex$ O O $number$ O O O $boolean$ O O O O $complex$ O O $number$ O O O $boolean$ O O O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $complex$ O $any$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O $complex$ O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O $complex$ O $complex$ O $any$ O $complex$ O $complex$ O $complex$ O $complex$ O O $any$ O $complex$ O O $any$ O O $complex$ O O $number$ O O O $boolean$ O O O O $complex$ O O $number$ O O O $boolean$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O $MapTransformProps$ O O O O $number$ O O O $number$ O O O O O $any$ O $complex$ O O $any$ O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O O $MapTransformProps$ O $MapTransformProps$ O O O $MapTransformProps$ O $boolean$ O O O O $complex$ O $complex$ O $MapTransformProps$ O O $number$ O O O $number$ O O O O O $any$ O $complex$ O O $any$ O O $number$ O O O $number$ O O O O O O O O O O O $any$ O O O O O O O O $MapTransformProps$ O $MapTransformProps$ O O O $MapTransformProps$ O $complex$ O O $number$ O O O $number$ O O O O O $any$ O O $number$ O O O $number$ O O O O O $void$ O O $QXY$ O $QXY$ O $MapTransformProps$ O O O $MapTransformProps$ O $boolean$ O O O $any$ O $complex$ O $QXY$ O $number$ O $QXY$ O $number$ O $MapTransformProps$ O O O $any$ O $QXY$ O O $any$ O $complex$ O $QXY$ O $number$ O $QXY$ O $number$ O $MapTransformProps$ O O O $any$ O $QXY$ O O $MapTransformProps$ O $boolean$ O O O O $complex$ O O $number$ O $QXY$ O $number$ O $number$ O $QXY$ O $number$ O O $any$ O $complex$ O $QXY$ O $number$ O $QXY$ O $number$ O $MapTransformProps$ O O O $any$ O $complex$ O O $any$ O $complex$ O $QXY$ O $number$ O $QXY$ O $number$ O $MapTransformProps$ O O O $any$ O O $number$ O $QXY$ O $number$ O $number$ O $QXY$ O $number$ O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O $MapTransformProps$ O $BotOriginQuadrant$ O O O $void$ O $complex$ O $complex$ O $MapTransformProps$ O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O $number$ O O O O $MapTransformProps$ O $BotOriginQuadrant$ O O O $void$ O $complex$ O $complex$ O $MapTransformProps$ O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O O O $complex$ O O $number$ O O O O $number$ O O O O O $MapTransformProps$ O $BotOriginQuadrant$ O O O $void$ O $complex$ O $complex$ O $MapTransformProps$ O O O O O O O O $any$ O O O O O O O O $MapTransformProps$ O $MapTransformProps$ O O O $MapTransformProps$ O $complex$ O O $number$ O O O $number$ O O O O $any$ O O O O O O O $MapTransformProps$ O $BotOriginQuadrant$ O O O $any$ O $string$ O $MapTransformProps$ O O O $any$ O O O O O O O $any$ O O O O O O O $MapTransformProps$ O $BotOriginQuadrant$ O O O $any$ O $string$ O $MapTransformProps$ O O O $any$ O O O O O O O $any$ O O O O O O O $MapTransformProps$ O $BotOriginQuadrant$ O O O $any$ O $string$ O $MapTransformProps$ O O O $any$ O O O O O O O $any$ O O O O O O O $MapTransformProps$ O $BotOriginQuadrant$ O O O $any$ O $string$ O $MapTransformProps$ O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $string$ O O O $any$ O $Mode$ O O O O $any$ O $any$ O $Mode.clickToAdd$ O O $string$ O O O $any$ O $Mode$ O O O O $any$ O $any$ O $Mode.editPlant$ O O $string$ O O O $any$ O $Mode$ O O O O $any$ O $any$ O $Mode.editPlant$ O O $string$ O O O $any$ O $Mode$ O O O O $any$ O $any$ O $Mode.editPlant$ O O $string$ O O O $any$ O $Mode$ O O O O $any$ O $any$ O $Mode.editPlant$ O O $string$ O O O $any$ O $Mode$ O O O O $any$ O $any$ O $Mode.boxSelect$ O O $string$ O O O $any$ O $Mode$ O O O O $any$ O $any$ O $Mode.addPlant$ O O $string$ O O O $any$ O $Mode$ O O O O $any$ O $any$ O $Mode.moveTo$ O O $string$ O O O $any$ O $Mode$ O O O O $any$ O $any$ O $Mode.createPoint$ O O $string$ O O O $any$ O $Mode$ O O O O $any$ O $any$ O $Mode.templateView$ O O $string$ O O O $any$ O $Mode$ O O O O $any$ O $any$ O $Mode.addPointToGroup$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O $ObjectConstructor$ O $any$ O $Document$ O O O O $complex$ O O O O O O $number$ O O O $number$ O O O O O $true$ O O O O O $ObjectConstructor$ O $any$ O $complex$ O O O O $complex$ O O O O O O $number$ O O O O O $true$ O O O O O O O O O $complex$ O O O O O O $MapTransformProps$ O $MapTransformProps$ O O O $complex$ O O $number$ O O O $number$ O O O O $number$ O O O $number$ O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O $complex$ O O O O $any$ O $complex$ O O $any$ O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O $ObjectConstructor$ O $any$ O $complex$ O O O O $complex$ O O O O O O $undefined$ O $undefined$ O O O $true$ O O O O O O $complex$ O $complex$ O $complex$ O O O O $any$ O $complex$ O O $any$ O O $number$ O O O $number$ O O O O O O O O $any$ O O O O O O O $ObjectConstructor$ O $any$ O $Document$ O O O O $void$ O O O O O O O $true$ O O O O O O $complex$ O $complex$ O $complex$ O O O O $any$ O $complex$ O O $any$ O $undefined$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $ObjectConstructor$ O $any$ O $complex$ O O O O $number$ O O O $true$ O O O O O $string$ O O O $any$ O $complex$ O O O O $any$ O O O O $string$ O O O $any$ O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O O $ObjectConstructor$ O $any$ O $complex$ O O O O $number$ O O O $true$ O O O O O $string$ O O O $any$ O $complex$ O O O O $any$ O O O O $string$ O O O $any$ O $complex$ O O O O $any$ O O O O O O O O O O
import { NumericSetting } from "s" ; import { findIndex , isNumber , clamp } from "s" ; import { setWebAppConfigValue , GetWebAppConfigValue } from "s" ; const zoomLevels = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; const foundIndex = findIndex ( zoomLevels , ( x ) => x === 0 ) ; const 0 = foundIndex === - 0 ? 0 : foundIndex ; const zoomLevelsCount = zoomLevels . length ; export const maxZoomIndex = zoomLevelsCount - 0 ; const clampZoom = ( index ) : number => clamp ( index , 0 , maxZoomIndex ) ; export const maxZoomLevel = zoomLevelsCount - 0 ; export const minZoomLevel = 0 - 0 ; export function atMaxZoom ( getConfigValue ) { return getZoomLevelIndex ( getConfigValue ) >= maxZoomIndex ; } export function atMinZoom ( getConfigValue ) { return getZoomLevelIndex ( getConfigValue ) <= 0 ; } export function getZoomLevelIndex ( getConfigValue ) { const savedValue = getConfigValue ( NumericSetting . zoom_level ) ; if ( ! isNumber ( savedValue ) ) { return 0 ; } const zoomLevelIndex = savedValue + 0 - 0 ; return clampZoom ( zoomLevelIndex ) ; } export function saveZoomLevelIndex ( dispatch , index ) { const payload = index - 0 + 0 ; dispatch ( setWebAppConfigValue ( NumericSetting . zoom_level , payload ) ) ; } export function calcZoomLevel ( index ) { return zoomLevels [ clampZoom ( index ) ] ; }	O O $complex$ O O O O O O $any$ O $any$ O $any$ O O O O O O $void$ O $any$ O O O O O $number[]$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $number[]$ O O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O $number$ O $number[]$ O $number$ O O O $number$ O $number$ O O O O $number$ O O $number$ O O O O $any$ O $number$ O O O $number$ O O O O $number$ O $number$ O $any$ O O O $number$ O O O $any$ O O O $boolean$ O $GetWebAppConfigValue$ O O O $number$ O $GetWebAppConfigValue$ O O $number$ O O O O $boolean$ O $GetWebAppConfigValue$ O O O $number$ O $GetWebAppConfigValue$ O O O O O O O $number$ O $GetWebAppConfigValue$ O O O $complex$ O $GetWebAppConfigValue$ O $complex$ O $any$ O O O O O $any$ O $complex$ O O O O $any$ O O O $number$ O $complex$ O $any$ O O O O $number$ O $number$ O O O O O $void$ O $Function$ O $number$ O O O $number$ O $number$ O $any$ O O O $Function$ O $void$ O $complex$ O $any$ O $number$ O O O O O O $number$ O $number$ O O O $number[]$ O $number$ O $number$ O O O O
jest . mock ( "s" , ( ) => ( { setWebAppConfigValue : jest . fn ( ) } ) ) ; import * as ZoomUtils from "s" ; import { setWebAppConfigValue } from "s" ; import { NumericSetting } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( ZoomUtils . getZoomLevelIndex ( ( ) => undefined ) ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { ZoomUtils . saveZoomLevelIndex ( jest . fn ( ) , 0 ) ; expect ( setWebAppConfigValue ) . toHaveBeenCalledWith ( NumericSetting . zoom_level , 0 ) ; } ) ; it ( "s" , ( ) => { expect ( ZoomUtils . calcZoomLevel ( 0 ) ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { expect ( ZoomUtils . atMaxZoom ( ( ) => 0 ) ) . toBeFalsy ( ) ; expect ( ZoomUtils . atMinZoom ( ( ) => 0 ) ) . toBeFalsy ( ) ; } ) ; it ( "s" , ( ) => { expect ( ZoomUtils . atMaxZoom ( ( ) => ZoomUtils . maxZoomLevel ) ) . toBeTruthy ( ) ; expect ( ZoomUtils . atMinZoom ( ( ) => ZoomUtils . maxZoomLevel ) ) . toBeFalsy ( ) ; } ) ; it ( "s" , ( ) => { const result = ZoomUtils . getZoomLevelIndex ( ( ) => 0 ) ; expect ( result ) . toEqual ( ZoomUtils . maxZoomIndex ) ; } ) ; it ( "s" , ( ) => { expect ( ZoomUtils . atMaxZoom ( ( ) => ZoomUtils . minZoomLevel ) ) . toBeFalsy ( ) ; expect ( ZoomUtils . atMinZoom ( ( ) => ZoomUtils . minZoomLevel ) ) . toBeTruthy ( ) ; } ) ; it ( "s" , ( ) => { const result = ZoomUtils . getZoomLevelIndex ( ( ) => - 0 ) ; expect ( result ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { const defaultZoom = ZoomUtils . calcZoomLevel ( ZoomUtils . getZoomLevelIndex ( ( ) => undefined ) ) ; expect ( defaultZoom ) . toEqual ( 0 ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O $void$ O O O O O O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $number$ O O O O $undefined$ O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $void$ O $any$ O $any$ O O O O O O $any$ O $void$ O O $any$ O $complex$ O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $number$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O $any$ O O O $any$ O $any$ O $boolean$ O O O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $number$ O O O $any$ O O O $any$ O $any$ O $boolean$ O O O O $any$ O $number$ O O O $any$ O O O O O O $any$ O O O O O O O O $number$ O $any$ O $number$ O O O O O O O $any$ O $number$ O O $any$ O $any$ O $number$ O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O $any$ O $number$ O O O $any$ O O O $any$ O $any$ O $boolean$ O O O O $any$ O $number$ O O O $any$ O O O O O O $any$ O O O O O O O O $number$ O $any$ O $number$ O O O O O O O O $any$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $number$ O $any$ O $number$ O $any$ O $number$ O O O O $undefined$ O O O $any$ O $number$ O O $any$ O O O O O O O O O O
export * from "s" ; export * from "s" ;	O O O O O O O O O O
export * from "s" ; export * from "s" ;	O O O O O O O O O O
export enum EggKeys { BRING_ON_THE_BUGS = "s" , BUGS_ARE_STILL_ALIVE = "s" , LAST_BUG_TIME = "s" , } export function getEggStatus ( key ) { return localStorage . getItem ( key ) || "s" ; } export function setEggStatus ( key , value ) { localStorage . setItem ( key , value ) ; }	O O $any$ O $EggKeys.BRING_ON_THE_BUGS$ O O O $EggKeys.BUGS_ARE_STILL_ALIVE$ O O O $EggKeys.LAST_BUG_TIME$ O O O O O O $string$ O $EggKeys$ O O O $Storage$ O $string$ O $EggKeys$ O O O O O O O $void$ O $EggKeys$ O $string$ O O $Storage$ O $void$ O $EggKeys$ O $string$ O O O
import { isNumber } from "s" ; import { BotPosition } from "s" ; export function botPositionLabel ( position ) { const show = ( n : number | undefined ) => isNumber ( n ) ? n : "s" ; return `template` ; }	O O $any$ O O O O O O $any$ O O O O O O $string$ O $BotPosition$ O O O $complex$ O O $number$ O O O O O O $any$ O $number$ O O $number$ O O O O O O O
import { botPositionLabel } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const position = { x : 0 , y : 0 , z : 0 } ; expect ( botPositionLabel ( position ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const position = { x : 0 , y : 0 , z : undefined } ; expect ( botPositionLabel ( position ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const position = { x : undefined , y : undefined , z : undefined } ; expect ( botPositionLabel ( position ) ) . toEqual ( "s" ) ; } ) ; } ) ;	O O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O $any$ O $string$ O $complex$ O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O $undefined$ O $undefined$ O O $any$ O $string$ O $complex$ O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O $any$ O $string$ O $complex$ O O O $any$ O O O O O O O O O O
export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { textAnchorPosition } from "s" ; describe ( "s" , ( ) => { const START = { anchor : "s" , x : 0 , y : 0 } ; const END = { anchor : "s" , x : - 0 , y : 0 } ; const MIDDLE_TOP = { anchor : "s" , x : 0 , y : 0 } ; const MIDDLE_BOTTOM = { anchor : "s" , x : 0 , y : - 0 } ; it ( "s" , ( ) => { expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( END ) ; expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( START ) ; expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( START ) ; expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( END ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( MIDDLE_TOP ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( MIDDLE_TOP ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( MIDDLE_BOTTOM ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( MIDDLE_BOTTOM ) ; } ) ; it ( "s" , ( ) => { expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( START ) ; expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( END ) ; expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( END ) ; expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( START ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( MIDDLE_BOTTOM ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( MIDDLE_BOTTOM ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( MIDDLE_TOP ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( MIDDLE_TOP ) ; } ) ; it ( "s" , ( ) => { expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( MIDDLE_TOP ) ; expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( MIDDLE_TOP ) ; expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( MIDDLE_BOTTOM ) ; expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( MIDDLE_BOTTOM ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( END ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( START ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( START ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( END ) ; } ) ; it ( "s" , ( ) => { expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( MIDDLE_BOTTOM ) ; expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( MIDDLE_BOTTOM ) ; expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( MIDDLE_TOP ) ; expect ( textAnchorPosition ( 0 , 0 , false ) ) . toEqual ( MIDDLE_TOP ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( START ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( END ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( END ) ; expect ( textAnchorPosition ( 0 , 0 , true ) ) . toEqual ( START ) ; } ) ; } ) ;	O O $any$ O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $number$ O O O $number$ O O O O O $complex$ O O $string$ O O O $number$ O O O O $number$ O O O O O $complex$ O O $string$ O O O $number$ O O O $number$ O O O O O $complex$ O O $string$ O O O $number$ O O O $number$ O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O O O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O O O O O O O O O $any$ O $complex$ O O O O O O O O
import { PlantOptions } from "s" ; import { PlantPointer } from "s" ; export const DEFAULT_PLANT_RADIUS = 0 ; export function Plant ( options ) { const openfarm_slug = options . openfarm_slug || "s" ; return { id : options . id , pointer_type : "s" , created_at : ( options . created_at || "s" ) , name : ( options . name || "s" ) , meta : { } , x : ( options . x || 0 ) , y : ( options . y || 0 ) , z : 0 , radius : ( options . radius || DEFAULT_PLANT_RADIUS ) , openfarm_slug , plant_stage : "s" } ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O $PlantPointer$ O $PlantOptions$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $string$ O O O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O ${}$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $number$ O O O $any$ O O $any$ O $any$ O O O O $any$ O $string$ O O O O O
import { mapStateToProps } from "s" ; import { fakeState } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const props = mapStateToProps ( fakeState ( ) ) ; expect ( props . cropSearchInProgress ) . toEqual ( false ) ; } ) ; } ) ;	O O $any$ O O O O O O $Everything$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $Everything$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { mapStateToProps } from "s" ; import { fakeState } from "s" ; import { buildResourceIndex } from "s" ; import { fakePlant , fakePlantTemplate } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = fakeState ( ) ; const plant = fakePlant ( ) ; plant . body . id = 0 ; state . resources = buildResourceIndex ( [ plant ] ) ; const uuid = Object . keys ( state . resources . index . all ) [ 0 ] ; const result = mapStateToProps ( state ) ; expect ( result . findPlant ( undefined ) ) . toEqual ( undefined ) ; expect ( result . findPlant ( "s" ) ) . toEqual ( expect . objectContaining ( { uuid } ) ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; const template = fakePlantTemplate ( ) ; template . body . id = 0 ; state . resources = buildResourceIndex ( [ template ] ) ; const uuid = Object . keys ( state . resources . index . all ) [ 0 ] ; state . resources . consumers . farm_designer . openedSavedGarden = "s" ; const result = mapStateToProps ( state ) ; expect ( result . findPlant ( "s" ) ) . toEqual ( expect . objectContaining ( { uuid } ) ) ; } ) ; } ) ;	O O $any$ O O O O O O $Everything$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O $string$ O $ObjectConstructor$ O $complex$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $complex$ O O O O O O $any$ O $any$ O $Everything$ O O $any$ O $any$ O $any$ O $undefined$ O O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $string$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O $string$ O $ObjectConstructor$ O $complex$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $complex$ O O O O O $Everything$ O $RestResources$ O $complex$ O $DesignerState$ O $string$ O O O O $any$ O $any$ O $Everything$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $string$ O O O O O O O O O O
import { betterCompact } from "s" ; import { PointGroup } from "s" ; import { init , save } from "s" ; import { history } from "s" ; import { GetState } from "s" ; import { findPointGroup } from "s" ; import { t } from "s" ; const UNTITLED = ( ) => t ( "s" ) ; interface CreateGroupProps { points : string [ ] ; name ? : string ; } export const createGroup = ( { points , name } ) => { return function ( dispatch , getState ) { const { references } = getState ( ) . resources . index ; const possiblyNil = points . map ( x => references [ x ] ) . map ( x => x ? x . body . id : undefined ) ; const point_ids = betterCompact ( possiblyNil ) ; const group = ( { name : name || UNTITLED ( ) , point_ids , sort_type : "s" } ) ; const action = init ( "s" , group ) ; dispatch ( action ) ; return dispatch ( save ( action . payload . uuid ) ) . then ( ( ) => { const pg = findPointGroup ( getState ( ) . resources . index , action . payload . uuid ) ; const { id } = pg . body ; history . push ( "s" + ( id ? id : "s" ) ) ; } ) ; } ; } ;	O O $T[]$ O O O O O O $any$ O O O O O O $ReduxAction<any>$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O $any$ O $string[]$ O O O O O $string$ O O O O O O O $any$ O O O $string[]$ O $string$ $CreateGroupProps$ O O O O O O $Function$ O $GetState$ O O O O $any$ O O $GetState$ O O O $RestResources$ O $ResourceIndex$ O O $any[]$ O $string[]$ O $U[]$ O $string$ O $any$ O $string$ O O O $U[]$ O $any$ O $any$ O $any$ O $any$ O $any$ O $undefined$ O O O $any[]$ O $T[]$ O $any[]$ O O O $PointGroup$ O O O $any$ O $string$ O $any$ O O O $any[]$ O $string$ O O O O O O $ReduxAction<any>$ O $ReduxAction<any>$ O O O $any$ O O $Function$ O $ReduxAction<any>$ O O O $Function$ O $any$ O $ReduxAction<any>$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $GetState$ O O O $RestResources$ O $ResourceIndex$ O $ReduxAction<any>$ O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O
jest . mock ( "s" , ( ) => { return { init : jest . fn ( ( ) => ( { payload : { uuid : "s" } } ) ) , save : jest . fn ( ) } ; } ) ; jest . mock ( "s" , ( ) => { return { history : { push : jest . fn ( ) } } ; } ) ; jest . mock ( "s" , ( ) => ( { findPointGroup : jest . fn ( ( ) => ( { body : { id : 0 } } ) ) , selectAllRegimens : jest . fn ( ) } ) ) ; import { createGroup } from "s" ; import { init , save } from "s" ; import { history } from "s" ; import { buildResourceIndex } from "s" ; import { fakePoint , fakePlant , fakeToolSlot } from "s" ; import { DeepPartial } from "s" ; import { Everything } from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const fakePoints = [ fakePoint ( ) , fakePlant ( ) , fakeToolSlot ( ) ] ; const resources = buildResourceIndex ( fakePoints ) ; const points = fakePoints . map ( x => x . uuid ) ; const fakeS < Everything > = { resources } ; const dispatch = jest . fn ( ( ) => Promise . resolve ( ) ) ; const thunk = createGroup ( { points , name : "s" } ) ; await thunk ( dispatch , ( ) => fakeS as Everything ) ; expect ( init ) . toHaveBeenCalledWith ( "s" , { name : "s" , point_ids : [ 0 , 0 ] , sort_type : "s" } ) ; expect ( save ) . toHaveBeenCalledWith ( "s" ) ; expect ( history . push ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $complex$ O O $number$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O $ReduxAction<any>$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any[]$ O O $any$ O O O $any$ O O O $any$ O O O O O $any$ O $any$ O $any[]$ O O O $any[]$ O $any[]$ O $U[]$ O $any$ O $any$ O $any$ O O O $DeepPartial$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $any$ O O $any[]$ O $string$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $ReduxAction<any>$ O O $any$ O O O O $string$ O O O $number[]$ O O O O O O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
const mockId = 0 ; jest . mock ( "s" , ( ) => ( { getPathArray : jest . fn ( ( ) => [ mockId ] ) } ) ) ; import { fetchGroupFromUrl } from "s" ; import { fakePointGroup } from "s" ; import { buildResourceIndex } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const group = fakePointGroup ( ) ; group . body . id = mockId ; const result = fetchGroupFromUrl ( buildResourceIndex ( [ group ] ) . index ) ; expect ( result ) . toEqual ( group ) ; } ) ; it ( "s" , ( ) => { const group = fakePointGroup ( ) ; group . body . id = 0 ; const result = fetchGroupFromUrl ( buildResourceIndex ( [ group ] ) . index ) ; expect ( result ) . toEqual ( undefined ) ; } ) ; } ) ;	O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O $undefined$ O O O O O O O O
import axios from "s" ; import { API } from "s" ; import { success , info } from "s" ; import { history } from "s" ; import { Actions } from "s" ; import { destroy , initSave , initSaveGetId } from "s" ; import { unpackUUID } from "s" ; import { isString } from "s" ; import { TaggedSavedGarden , TaggedPlantTemplate } from "s" ; import { t } from "s" ; import { stopTracking } from "s" ; export const snapshotGarden = ( name ? : string | undefined ) => axios . post < void > ( API . current . snapshotPath , name ? { name } : { } ) . then ( ( ) => success ( t ( "s" ) ) ) ; export const unselectSavedGarden = { type : Actions . CHOOSE_SAVED_GARDEN , payload : undefined } ; export const applyGarden = ( gardenId ) => ( dispatch ) => axios . patch < void > ( API . current . applyGardenPath ( gardenId ) ) . then ( data => { stopTracking ( data . headers [ "s" ] ) ; history . push ( "s" ) ; dispatch ( unselectSavedGarden ) ; const busyToastTitle = t ( "s" ) ; info ( t ( "s" ) , busyToastTitle , "s" ) ; } ) ; export const destroySavedGarden = ( uuid ) => ( dispatch ) => { dispatch ( destroy ( uuid ) ) . then ( dispatch ( unselectSavedGarden ) ) . catch ( ( ) => { } ) ; } ; export const closeSavedGarden = ( ) => { history . push ( "s" ) ; return ( dispatch ) => dispatch ( unselectSavedGarden ) ; } ; export const openSavedGarden = ( savedGarden ) => { history . push ( "s" + unpackUUID ( savedGarden ) . remoteId ) ; return ( dispatch ) => dispatch ( { type : Actions . CHOOSE_SAVED_GARDEN , payload : savedGarden } ) ; } ; export const openOrCloseGarden = ( props : { savedGarden : string | undefined , gardenIsOpen : boolean , dispatch : Function } ) => ( ) => ! props . gardenIsOpen && isString ( props . savedGarden ) ? props . dispatch ( openSavedGarden ( props . savedGarden ) ) : props . dispatch ( closeSavedGarden ( ) ) ; export const newSavedGarden = ( name ) => ( dispatch ) => { dispatch ( initSave ( "s" , { name : name || "s" } ) ) ; } ; const newPTBody = ( source , newSGId ) : TaggedPlantTemplate [ "s" ] => ( { name : source . body . name , openfarm_slug : source . body . openfarm_slug , saved_garden_id : newSGId , radius : source . body . radius , x : source . body . x , y : source . body . y , z : source . body . z , } ) ; export const copySavedGarden = ( { newSGName , savedGarden , plantTemplates } : { newSGName : string , savedGarden : TaggedSavedGarden , plantTemplates : TaggedPlantTemplate [ ] } ) => ( dispatch ) => { const sourceSavedGardenId = savedGarden . body . id ; const name = newSGName || `template` ; dispatch ( initSaveGetId ( savedGarden . kind , { name } ) ) . then ( ( newSGId ) => plantTemplates . filter ( x => x . body . saved_garden_id === sourceSavedGardenId ) . map ( x => dispatch ( initSave ( x . kind , newPTBody ( x , newSGId ) ) ) ) ) ; } ;	O $any$ O O O O O $any$ O O O O O O $void$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $BetterUUID$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O $string$ O O O O O O O $any$ O $any$ O O O O $any$ O $API$ O $string$ O $string$ O O $string$ O O O O O O $any$ O O O O $void$ O $any$ O O O O O O O O $complex$ O O $Actions$ O $any$ O $Actions.CHOOSE_SAVED_GARDEN$ O $undefined$ O $undefined$ O O O O $any$ O O $number$ O O O $Function$ O O $any$ O $any$ O O O O $any$ O $API$ O $string$ O $number$ O O O $any$ O $any$ O O $void$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O $Function$ O $complex$ O O O $any$ O $any$ O O O O $void$ O $any$ O O O O $any$ O O O O O O O O O $void$ O O $string$ O O O $Function$ O O O $Function$ O $any$ O $string$ O O O $any$ O $Function$ O $complex$ O O O $any$ O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O $Function$ O O $Function$ O $complex$ O O O O O O $any$ O O $string$ O O O $any$ O $any$ O O O $BetterUUID$ O $string$ O O $number$ O O O O $Function$ O O $Function$ O O $Actions$ O $any$ O $Actions.CHOOSE_SAVED_GARDEN$ O $string$ O $string$ O O O O O O O $any$ O O $complex$ O O $string$ O O O O O $boolean$ O O O $Function$ O $FunctionConstructor$ O O O O O O O $complex$ O $boolean$ O $any$ O $complex$ O $string$ O O $complex$ O $Function$ O $any$ O $complex$ O $string$ O O O $complex$ O $Function$ O $any$ O O O O O O $void$ O O $string$ O O O $Function$ O O O $Function$ O $any$ O O O O $string$ O $string$ O O O O O O O O O $any$ O O $TaggedPlantTemplate$ O $number$ O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $number$ O $number$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $void$ O O O $string$ O $any$ O $any[]$ O O O $string$ O O O $any$ O $any$ O $any[]$ O $any$ O O O O O O $Function$ O O O O $any$ O $any$ O $any$ O $any$ O O $string$ O $string$ O O O $Function$ O $any$ O $any$ O $any$ O O $string$ O O O O $any$ O O $number$ O O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $U[]$ O $any$ O $Function$ O $any$ O $any$ O $any$ O $any$ O $any$ O $number$ O O O O O O O O
jest . mock ( "s" , ( ) => ( { post : jest . fn ( ( ) => Promise . resolve ( ) ) , patch : jest . fn ( ( ) => Promise . resolve ( { headers : { "s" : "s" } } ) ) , } ) ) ; jest . mock ( "s" , ( ) => ( { history : { push : jest . fn ( ) } } ) ) ; jest . mock ( "s" , ( ) => ( { destroy : jest . fn ( ) , initSave : jest . fn ( ) , initSaveGetId : jest . fn ( ) , } ) ) ; import { API } from "s" ; import axios from "s" ; import { snapshotGarden , applyGarden , destroySavedGarden , closeSavedGarden , openSavedGarden , openOrCloseGarden , newSavedGarden , unselectSavedGarden , copySavedGarden } from "s" ; import { history } from "s" ; import { Actions } from "s" ; import { destroy , initSave , initSaveGetId } from "s" ; import { fakeSavedGarden , fakePlantTemplate } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { API . setBaseUrl ( "s" ) ; snapshotGarden ( ) ; expect ( axios . post ) . toHaveBeenCalledWith ( API . current . snapshotPath , { } ) ; } ) ; it ( "s" , ( ) => { snapshotGarden ( "s" ) ; expect ( axios . post ) . toHaveBeenCalledWith ( API . current . snapshotPath , { name : "s" } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { API . setBaseUrl ( "s" ) ; const dispatch = jest . fn ( ) ; await applyGarden ( 0 ) ( dispatch ) ; expect ( axios . patch ) . toHaveBeenCalledWith ( API . current . applyGardenPath ( 0 ) ) ; expect ( history . push ) . toHaveBeenCalledWith ( "s" ) ; expect ( dispatch ) . toHaveBeenCalledWith ( unselectSavedGarden ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dispatch = jest . fn ( ( ) => Promise . resolve ( ) ) ; destroySavedGarden ( "s" ) ( dispatch ) ; expect ( destroy ) . toHaveBeenCalledWith ( "s" ) ; expect ( dispatch ) . toHaveBeenLastCalledWith ( unselectSavedGarden ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; closeSavedGarden ( ) ( dispatch ) ; expect ( history . push ) . toHaveBeenCalledWith ( "s" ) ; expect ( dispatch ) . toHaveBeenCalledWith ( unselectSavedGarden ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const uuid = "s" ; openSavedGarden ( uuid ) ( dispatch ) ; expect ( history . push ) . toHaveBeenCalledWith ( "s" ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { type : Actions . CHOOSE_SAVED_GARDEN , payload : uuid } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const props = { savedGarden : "s" , dispatch : jest . fn ( ) , gardenIsOpen : false , } ; openOrCloseGarden ( props ) ( ) ; expect ( history . push ) . toHaveBeenCalledWith ( "s" ) ; } ) ; it ( "s" , ( ) => { const props = { savedGarden : "s" , dispatch : jest . fn ( ) , gardenIsOpen : true , } ; openOrCloseGarden ( props ) ( ) ; expect ( history . push ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { newSavedGarden ( "s" ) ( jest . fn ( ) ) ; expect ( initSave ) . toHaveBeenCalledWith ( "s" , { name : "s" } ) ; } ) ; it ( "s" , ( ) => { newSavedGarden ( "s" ) ( jest . fn ( ) ) ; expect ( initSave ) . toHaveBeenCalledWith ( "s" , { name : "s" } ) ; } ) ; } ) ; describe ( "s" , ( ) => { const fakeProps = ( ) => { const fakeSG = fakeSavedGarden ( ) ; fakeSG . body . id = 0 ; const fakePT = fakePlantTemplate ( ) ; fakePT . body . saved_garden_id = fakeSG . body . id ; return { newSGName : "s" , savedGarden : fakeSG , plantTemplates : [ fakePT ] , } ; } ; it ( "s" , async ( ) => { await copySavedGarden ( fakeProps ( ) ) ( jest . fn ( ( ) => Promise . resolve ( 0 ) ) ) ; expect ( initSaveGetId ) . toHaveBeenCalledWith ( "s" , { name : "s" } ) ; await expect ( initSave ) . toHaveBeenCalledWith ( "s" , expect . objectContaining ( { saved_garden_id : 0 } ) ) ; } ) ; it ( "s" , ( ) => { const p = fakeProps ( ) ; p . newSGName = "s" ; copySavedGarden ( p ) ( jest . fn ( ( ) => Promise . resolve ( ) ) ) ; expect ( initSaveGetId ) . toHaveBeenCalledWith ( "s" , { name : p . newSGName } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O $complex$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $void$ O $any$ O $any$ O $any$ O $void$ O $complex$ O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $void$ O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $API$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $API$ O $string$ O O $string$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $API$ O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O $void$ O O O O $any$ O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions.CHOOSE_SAVED_GARDEN$ O $string$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $any$ O $any$ O $any$ O O O $boolean$ O O O O O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $any$ O $any$ O $any$ O O O $boolean$ O O O O O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $void$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $string$ O O O O O O O O $any$ O O O O O O O $void$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $string$ O O O O O O O O O O O $any$ O O O O O O O O $complex$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O $any[]$ O O $any$ O O O O O O $any$ O O O O O O O O O $void$ O $complex$ O O O O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $any$ O $any$ O O $any$ O O O O $string$ O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $number$ O O O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $complex$ O $string$ O O O $void$ O $complex$ O O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O $any$ O $any$ O O $any$ O O O O $string$ O $complex$ O $string$ O O O O O O O O O
import { Everything } from "s" ; import { selectAllGenericPointers , selectAllPlantPointers , selectAllCrops , joinToolsAndSlot , selectAllImages , selectAllPeripherals , selectAllPlantTemplates , selectAllSensorReadings , selectAllSensors , maybeGetDevice , maybeGetTimeSettings } from "s" ; import { validBotLocationData , validFwConfig , unpackUUID , createShouldDisplayFn as shouldDisplayFunc , determineInstalledOsVersion } from "s" ; import { getWebAppConfigValue } from "s" ; import { Props } from "s" ; import { TaggedPlant } from "s" ; import { RestResources } from "s" ; import { isString , uniq , chain } from "s" ; import { BooleanSetting } from "s" ; import { Feature } from "s" ; import { reduceFarmwareEnv } from "s" ; import { getFirmwareConfig } from "s" ; import { DevSettings } from "s" ; import { calcMicrostepsPerMm } from "s" ; const plantFinder = ( plants : TaggedPlant [ ] ) => ( uuid : string | undefined ) : TaggedPlant => plants . filter ( x => x . uuid === uuid ) [ 0 ] ; export const getPlants = ( resources ) => { const onlyPlants = selectAllPlantPointers ( resources . index ) ; const plantTemplates = selectAllPlantTemplates ( resources . index ) ; const { openedSavedGarden } = resources . consumers . farm_designer ; return isString ( openedSavedGarden ) ? plantTemplates . filter ( x => x . body . saved_garden_id === unpackUUID ( openedSavedGarden ) . remoteId ) : onlyPlants ; } ; export function mapStateToProps ( props ) { const plants = getPlants ( props . resources ) ; const findPlant = plantFinder ( plants ) ; const { selectedPlants } = props . resources . consumers . farm_designer ; const selectedPlant = selectedPlants ? findPlant ( selectedPlants [ 0 ] ) : undefined ; const { plantUUID } = props . resources . consumers . farm_designer . hoveredPlant ; const hoveredPlant = findPlant ( plantUUID ) ; const getConfigValue = getWebAppConfigValue ( ( ) => props ) ; const allPoints = selectAllGenericPointers ( props . resources . index ) ; const points = getConfigValue ( BooleanSetting . show_historic_points ) ? allPoints : allPoints . filter ( x => ! x . body . discarded_at ) ; const fwConfig = validFwConfig ( getFirmwareConfig ( props . resources . index ) ) ; const { mcu_params } = props . bot . hardware ; const firmwareSettings = fwConfig || mcu_params ; const fw = firmwareSettings ; const stepsPerMmXY = { x : calcMicrostepsPerMm ( fw . movement_step_per_mm_x , fw . movement_microsteps_x ) , y : calcMicrostepsPerMm ( fw . movement_step_per_mm_y , fw . movement_microsteps_y ) , } ; const peripherals = uniq ( selectAllPeripherals ( props . resources . index ) ) . map ( x => { const label = x . body . label ; const pinStatus = x . body . pin ? props . bot . hardware . pins [ x . body . pin ] : undefined ; const value = pinStatus ? pinStatus . value > 0 : false ; return { label , value } ; } ) ; const latestImages = chain ( selectAllImages ( props . resources . index ) ) . sortBy ( x => x . body . id ) . reverse ( ) . value ( ) ; const installedOsVersion = determineInstalledOsVersion ( props . bot , maybeGetDevice ( props . resources . index ) ) ; const fbosVersionOverride = DevSettings . overriddenFbosVersion ( ) ; const shouldDisplay = shouldDisplayFunc ( installedOsVersion , props . bot . minOsFeatureData , fbosVersionOverride ) ; const env = shouldDisplay ( Feature . api_farmware_env ) ? reduceFarmwareEnv ( props . resources . index ) : props . bot . hardware . user_env ; const cameraCalibrationData = { scale : env [ "s" ] , rotation : env [ "s" ] , offset : { x : env [ "s" ] , y : env [ "s" ] } , origin : env [ "s" ] , calibrationZ : env [ "s" ] , } ; const sensorReadings = chain ( selectAllSensorReadings ( props . resources . index ) ) . sortBy ( x => x . body . created_at ) . reverse ( ) . take ( 0 ) . reverse ( ) . value ( ) ; return { crops : selectAllCrops ( props . resources . index ) , dispatch : props . dispatch , selectedPlant , designer : props . resources . consumers . farm_designer , points , toolSlots : joinToolsAndSlot ( props . resources . index ) , hoveredPlant , plants , botLocationData : validBotLocationData ( props . bot . hardware . location_data ) , botMcuParams : firmwareSettings , stepsPerMmXY , peripherals , eStopStatus : props . bot . hardware . informational_settings . locked , latestImages , cameraCalibrationData , timeSettings : maybeGetTimeSettings ( props . resources . index ) , getConfigValue , sensorReadings , sensors : selectAllSensors ( props . resources . index ) , } ; }	O O $any$ O O O O O O $any[]$ O $any[]$ O $any[]$ O $SlotWithTool[]$ O $any[]$ O $any[]$ O $any[]$ O $any[]$ O $any[]$ O $any$ O $TimeSettings$ O O O O O O $complex$ O $any$ O $BetterUUID$ O $boolean$ O $boolean$ O $string$ O O O O O O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $complex$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $number$ O O O O O $any$ O O $any[]$ O $any$ O O O O O $string$ O O O O O O $any$ O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $string$ O O O O O O O $any[]$ O O $RestResources$ O O O O $any[]$ O $any[]$ O $RestResources$ O $ResourceIndex$ O O O $any[]$ O $any[]$ O $RestResources$ O $ResourceIndex$ O O O O $string$ O O $RestResources$ O $complex$ O $DesignerState$ O O $any$ O $string$ O O $any[]$ O $complex$ O $any$ O $any$ O $any$ O $any$ O $BetterUUID$ O $string$ O O $number$ O O $any[]$ O O O O O $Props$ O $Everything$ O O O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O O O $any$ O $any$ O $any[]$ O O O O $string[]$ O O $Everything$ O $RestResources$ O $complex$ O $DesignerState$ O O $any$ O $string[]$ O $any$ O $string[]$ O O O O O $undefined$ O O O $string$ O O $Everything$ O $RestResources$ O $complex$ O $DesignerState$ O $HoveredPlantPayl$ O O $any$ O $any$ O $string$ O O O $complex$ O $complex$ O O O O $Everything$ O O O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $any[]$ O $complex$ O $complex$ O $any$ O O $any[]$ O $any[]$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O O $any$ O O $Everything$ O $BotState$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $complex$ O O $number$ O $number$ O $any$ O $any$ O $any$ O $any$ O O $number$ O $number$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $undefined$ O O $boolean$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $boolean$ O O O O O O $any$ O $any$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O $string$ O $string$ O $Everything$ O $BotState$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $string$ O $any$ O $string$ O O O O $boolean$ O $boolean$ O $string$ O $Everything$ O $BotState$ O $complex$ O $string$ O O O $any$ O $boolean$ O $any$ O $Feature.api_farmware_env$ O O $complex$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $Everything$ O $BotState$ O $any$ O $any$ O O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O O O $any$ O O O $any$ O O O O O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $Function$ O $Everything$ O $Function$ O $any$ O $DesignerState$ O $Everything$ O $RestResources$ O $complex$ O $DesignerState$ O $any[]$ O $SlotWithTool[]$ O $SlotWithTool[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $any$ O $any[]$ O $complex$ O $complex$ O $Everything$ O $BotState$ O $any$ O $any$ O O $any$ O $any$ O $complex$ O $any$ O $any$ O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $TimeSettings$ O $TimeSettings$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $complex$ O $any$ O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O O
jest . mock ( "s" , ( ) => ( { get : jest . fn ( ( ) => { return Promise . resolve ( { data : [ { manifest : "s" , name : "s" } , { manifest : "s" , name : "s" } ] } ) ; } ) , post : jest . fn ( ( ) => Promise . resolve ( ) ) , } ) ) ; import { getFirstPartyFarmwareList , retryFetchPackageName } from "s" ; import { Actions } from "s" ; import axios from "s" ; import { API } from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const dispatch = jest . fn ( ) ; await getFirstPartyFarmwareList ( ) ( dispatch ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { type : Actions . FETCH_FIRST_PARTY_FARMWARE_NAMES_OK , payload : [ "s" , "s" ] } ) ; } ) ; } ) ; describe ( "s" , ( ) => { API . setBaseUrl ( "s" ) ; it ( "s" , ( ) => { retryFetchPackageName ( 0 ) ; expect ( axios . post ) . toHaveBeenCalledWith ( "s" ) ; } ) ; it ( "s" , ( ) => { retryFetchPackageName ( undefined ) ; expect ( axios . post ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $PromiseConstructor$ O $complex$ O O $complex$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O O $void$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions.FETCH_FIRST_PARTY_FARMWARE_NAMES_OK$ O $string[]$ O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $undefined$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O
import { manifestInfo , manifestInfoPending } from "s" ; import { 0 , 0 } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const manifest = 0 ( ) ; manifest . name = "s" ; const info = manifestInfo ( manifest ) ; expect ( info ) . toEqual ( expect . objectContaining ( { name : manifest . name , installation_pending : false , meta : expect . objectContaining ( { version : "s" } ) } ) ) ; } ) ; it ( "s" , ( ) => { const manifest = 0 ( ) ; manifest . package = "s" ; const info = manifestInfo ( manifest ) ; expect ( info ) . toEqual ( expect . objectContaining ( { name : manifest . package , installation_pending : false , meta : expect . objectContaining ( { version : "s" } ) } ) ) ; } ) ; it ( "s" , ( ) => { const manifest = 0 ( ) ; manifest . name = "s" ; manifest . meta . min_os_version_major = "s" ; const info = manifestInfo ( manifest ) ; expect ( info ) . toEqual ( expect . objectContaining ( { name : manifest . name , installation_pending : false , meta : expect . objectContaining ( { fbos_version : "s" } ) } ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const info = manifestInfoPending ( "s" , "s" ) ; expect ( info ) . toEqual ( expect . objectContaining ( { name : "s" , installation_pending : true , meta : expect . objectContaining ( { version : "s" } ) } ) ) ; } ) ; } ) ;	O O $FarmwareManifestInfo$ O $complex$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $FarmwareManifestInfo$ O $FarmwareManifestInfo$ O $any$ O O $any$ O $FarmwareManifestInfo$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O $any$ O O $string$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $FarmwareManifestInfo$ O $FarmwareManifestInfo$ O $any$ O O $any$ O $FarmwareManifestInfo$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O $any$ O O $string$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $FarmwareManifestInfo$ O $FarmwareManifestInfo$ O $any$ O O $any$ O $FarmwareManifestInfo$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O $any$ O O $string$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O O O O $any$ O $complex$ O O $any$ O $any$ O $any$ O O $string$ O O O $boolean$ O O O $any$ O $any$ O $any$ O O $string$ O O O O O O O O O O O O O O
import { farmwareReducer } from "s" ; import { FarmwareState } from "s" ; import { Actions } from "s" ; import { fakeImage , fakeFarmwareInstallation } from "s" ; describe ( "s" , ( ) => { const fakeState = ( ) : FarmwareState => { return { currentFarmware : undefined , currentImage : undefined , firstPartyFarmwareNames : [ ] , infoOpen : false , } ; } ; it ( "s" , ( ) => { const image = fakeImage ( ) ; const oldState = fakeState ( ) ; oldState . currentImage = image . uuid ; const newState = farmwareReducer ( oldState , { type : Actions . DESTROY_RESOURCE_OK , payload : image } ) ; expect ( oldState . currentImage ) . not . toEqual ( newState . currentImage ) ; expect ( newState . currentImage ) . toBeUndefined ( ) ; } ) ; it ( "s" , ( ) => { const image = fakeImage ( ) ; const oldState = fakeState ( ) ; const newState = farmwareReducer ( oldState , { type : Actions . SELECT_IMAGE , payload : image . uuid } ) ; expect ( oldState . currentImage ) . not . toEqual ( newState . currentImage ) ; expect ( newState . currentImage ) . not . toBeUndefined ( ) ; expect ( newState . currentImage ) . toBe ( image . uuid ) ; } ) ; it ( "s" , ( ) => { const oldState = fakeState ( ) ; const newState = farmwareReducer ( oldState , { type : Actions . SELECT_FARMWARE , payload : "s" } ) ; expect ( oldState . currentFarmware ) . not . toEqual ( newState . currentFarmware ) ; expect ( newState . currentFarmware ) . not . toBeUndefined ( ) ; expect ( newState . currentFarmware ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { const image = fakeImage ( ) ; const oldState = fakeState ( ) ; const newState = farmwareReducer ( oldState , { type : Actions . INIT_RESOURCE , payload : image } ) ; expect ( oldState . currentImage ) . not . toEqual ( newState . currentImage ) ; expect ( newState . currentImage ) . not . toBeUndefined ( ) ; expect ( newState . currentImage ) . toBe ( image . uuid ) ; } ) ; it ( "s" , ( ) => { const nonimage = fakeFarmwareInstallation ( ) ; const oldState = fakeState ( ) ; const newState = farmwareReducer ( oldState , { type : Actions . INIT_RESOURCE , payload : nonimage } ) ; expect ( oldState . currentImage ) . toEqual ( newState . currentImage ) ; expect ( newState . currentImage ) . toBeUndefined ( ) ; } ) ; it ( "s" , ( ) => { const FARMWARE_NAMES = [ "s" , "s" ] ; const oldState = fakeState ( ) ; const newState = farmwareReducer ( oldState , { type : Actions . FETCH_FIRST_PARTY_FARMWARE_NAMES_OK , payload : [ "s" , "s" ] } ) ; expect ( oldState . firstPartyFarmwareNames ) . not . toEqual ( newState . firstPartyFarmwareNames ) ; expect ( newState . firstPartyFarmwareNames ) . toEqual ( FARMWARE_NAMES ) ; } ) ; it ( "s" , ( ) => { const oldState = fakeState ( ) ; const newState = farmwareReducer ( oldState , { type : Actions . SET_FARMWARE_INFO_STATE , payload : true } ) ; expect ( oldState . infoOpen ) . toBeFalsy ( ) ; expect ( newState . infoOpen ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $generateReducer<FarmwareState>.GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $FarmwareState$ O O O O $any$ O O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined[]$ O O O O $false$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $FarmwareState$ O $FarmwareState$ O O O $FarmwareState$ O $string$ O $any$ O $any$ O O $FarmwareState$ O $generateReducer<FarmwareState>.GeneratedReducer$ O $FarmwareState$ O O $Actions.DESTROY_RESOURCE_OK$ O $any$ O $Actions.DESTROY_RESOURCE_OK$ O $any$ O $any$ O O O $any$ O $FarmwareState$ O $string$ O O $any$ O $any$ O $FarmwareState$ O $string$ O O $any$ O $FarmwareState$ O $string$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $FarmwareState$ O $FarmwareState$ O O O O $FarmwareState$ O $generateReducer<FarmwareState>.GeneratedReducer$ O $FarmwareState$ O O $Actions.SELECT_IMAGE$ O $any$ O $Actions.SELECT_IMAGE$ O $any$ O $any$ O $any$ O O O $any$ O $FarmwareState$ O $string$ O O $any$ O $any$ O $FarmwareState$ O $string$ O O $any$ O $FarmwareState$ O $string$ O O $any$ O $any$ O O O $any$ O $FarmwareState$ O $string$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $FarmwareState$ O $FarmwareState$ O O O O $FarmwareState$ O $generateReducer<FarmwareState>.GeneratedReducer$ O $FarmwareState$ O O $Actions.SELECT_FARMWARE$ O $any$ O $Actions.SELECT_FARMWARE$ O $string$ O O O O O $any$ O $FarmwareState$ O $string$ O O $any$ O $any$ O $FarmwareState$ O $string$ O O $any$ O $FarmwareState$ O $string$ O O $any$ O $any$ O O O $any$ O $FarmwareState$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $FarmwareState$ O $FarmwareState$ O O O O $FarmwareState$ O $generateReducer<FarmwareState>.GeneratedReducer$ O $FarmwareState$ O O $Actions.INIT_RESOURCE$ O $any$ O $Actions.INIT_RESOURCE$ O $any$ O $any$ O O O $any$ O $FarmwareState$ O $string$ O O $any$ O $any$ O $FarmwareState$ O $string$ O O $any$ O $FarmwareState$ O $string$ O O $any$ O $any$ O O O $any$ O $FarmwareState$ O $string$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $FarmwareState$ O $FarmwareState$ O O O O $FarmwareState$ O $generateReducer<FarmwareState>.GeneratedReducer$ O $FarmwareState$ O O $Actions.INIT_RESOURCE$ O $any$ O $Actions.INIT_RESOURCE$ O $any$ O $any$ O O O $any$ O $FarmwareState$ O $string$ O O $any$ O $FarmwareState$ O $string$ O O $any$ O $FarmwareState$ O $string$ O O $any$ O O O O O O $any$ O O O O O O O O $string[]$ O O O O O O O O $FarmwareState$ O $FarmwareState$ O O O O $FarmwareState$ O $generateReducer<FarmwareState>.GeneratedReducer$ O $FarmwareState$ O O $Actions.FETCH_FIRST_PARTY_FARMWARE_NAMES_OK$ O $any$ O $Actions.FETCH_FIRST_PARTY_FARMWARE_NAMES_OK$ O $string[]$ O O O O O O O O O $any$ O $FarmwareState$ O $string[]$ O O $any$ O $any$ O $FarmwareState$ O $string[]$ O O $any$ O $FarmwareState$ O $string[]$ O O $any$ O $string[]$ O O O O O $any$ O O O O O O O O $FarmwareState$ O $FarmwareState$ O O O O $FarmwareState$ O $generateReducer<FarmwareState>.GeneratedReducer$ O $FarmwareState$ O O $Actions.SET_FARMWARE_INFO_STATE$ O $any$ O $Actions.SET_FARMWARE_INFO_STATE$ O $boolean$ O O O O O $any$ O $FarmwareState$ O $boolean$ O O $any$ O O O $any$ O $FarmwareState$ O $boolean$ O O $any$ O O O O O O O O O
import { store } from "s" ; import { lastUrlChunk } from "s" ; import { Actions } from "s" ; import { farmwareUrlFriendly } from "s" ; export function setActiveFarmwareByName ( farmwareNames : ( string | undefined ) [ ] ) { const chunk = farmwareUrlFriendly ( lastUrlChunk ( ) ) ; if ( chunk == "s" ) { return ; } farmwareNames . map ( payload => { if ( payload ) { const urlName = farmwareUrlFriendly ( payload ) ; const directMatch = chunk === urlName ; const altMatch = chunk === "s" && urlName === "s" ; const match = directMatch || altMatch ; match && store . dispatch ( { type : Actions . SELECT_FARMWARE , payload } ) ; } } ) ; }	O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O $string[]$ O O O O O O O O O O O $any$ O $any$ O $string$ O O O O O O $any$ O O O O O O O $string[]$ O $U[]$ O $string$ O O O O $string$ O O O $any$ O $any$ O $string$ O O O $boolean$ O $any$ O $any$ O O $boolean$ O $any$ O O O $any$ O O O O $boolean$ O $boolean$ O $boolean$ O $boolean$ O $any$ O $any$ O O $Actions$ O $any$ O $Actions.SELECT_FARMWARE$ O $string$ O O O O O O O O
let mockLastUrlChunk = "s" ; jest . mock ( "s" , ( ) => { return { urlFriendly : jest . fn ( x => x ) , lastUrlChunk : jest . fn ( ( ) => mockLastUrlChunk ) } ; } ) ; jest . mock ( "s" , ( ) => ( { store : { dispatch : jest . fn ( ) } } ) ) ; import { setActiveFarmwareByName } from "s" ; import { store } from "s" ; import { Actions } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { mockLastUrlChunk = "s" ; setActiveFarmwareByName ( [ ] ) ; expect ( store . dispatch ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { mockLastUrlChunk = "s" ; setActiveFarmwareByName ( [ ] ) ; expect ( store . dispatch ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { mockLastUrlChunk = "s" ; setActiveFarmwareByName ( [ "s" ] ) ; expect ( store . dispatch ) . toHaveBeenCalledWith ( { type : Actions . SELECT_FARMWARE , payload : "s" } ) ; } ) ; it ( "s" , ( ) => { mockLastUrlChunk = "s" ; setActiveFarmwareByName ( [ "s" ] ) ; expect ( store . dispatch ) . toHaveBeenCalledWith ( { type : Actions . SELECT_FARMWARE , payload : "s" } ) ; } ) ; it ( "s" , ( ) => { mockLastUrlChunk = "s" ; setActiveFarmwareByName ( [ undefined ] ) ; expect ( store . dispatch ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ;	O $string$ O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $string$ O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O $void$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $string$ O O O $void$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $string$ O O O $void$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $string$ O O O $void$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions.SELECT_FARMWARE$ O $string$ O O O O O O O O $any$ O O O O O O O $string$ O O O $void$ O O O O O O $any$ O $any$ O $any$ O O $any$ O O $Actions$ O $any$ O $Actions.SELECT_FARMWARE$ O $string$ O O O O O O O O $any$ O O O O O O O $string$ O O O $void$ O O $undefined$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O
import { getDevice } from "s" ; import { toPairs } from "s" ; import { commandErr } from "s" ; export function calibrate ( ) { return function ( ) { getDevice ( ) . execScript ( "s" ) . catch ( commandErr ( "s" ) ) ; } ; } export function scanImage ( imageId ) { const p = toPairs ( { "s" : ( "s" + imageId ) } ) ; return function ( ) { getDevice ( ) . execScript ( "s" , p ) . catch ( commandErr ( "s" ) ) ; } ; }	O O $any$ O O O O O O $any[]$ O O O O O O $void$ O O O O O O $void$ O O O O O O O O $any$ O O O $any$ O O O O $any$ O $void$ O O O O O O O O O O $void$ O $number$ O O O $any[]$ O $any[]$ O O O O O O O $number$ O O O O O O O O O $any$ O O O $any$ O O O $any[]$ O O $any$ O $void$ O O O O O O O O
const mockDevice = { execScript : jest . fn ( ( ) => Promise . resolve ( { } ) ) } ; jest . mock ( "s" , ( ) => ( { getDevice : ( ) => ( mockDevice ) } ) ) ; import { calibrate , scanImage } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const thunk = scanImage ( 0 ) ; thunk ( ) ; expect ( mockDevice . execScript ) . toHaveBeenCalledWith ( "s" , [ { args : { label : "s" , value : "s" } , kind : "s" } ] ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const thunk = calibrate ( ) ; thunk ( ) ; expect ( mockDevice . execScript ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ;	O $complex$ O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O $complex$ O O O O O O O $void$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $void$ O $void$ O O O O $void$ O O O $any$ O $complex$ O $any$ O O $any$ O O O O O $complex$ O O $string$ O O O $string$ O O O O $string$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $void$ O $void$ O O O $void$ O O O $any$ O $complex$ O $any$ O O $any$ O O O O O O O O O O
import { Actions } from "s" ; export function selectImage ( uuid : string | undefined ) { return { type : Actions . SELECT_IMAGE , payload : uuid } ; }	O O $any$ O O O O O O $complex$ O $string$ O O O O O O O O $Actions$ O $any$ O $Actions.SELECT_IMAGE$ O $string$ O $string$ O O O
import { selectImage } from "s" ; import { Actions } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const payload = "s" ; const result = selectImage ( payload ) ; expect ( result . type ) . toEqual ( Actions . SELECT_IMAGE ) ; expect ( result . payload ) . toEqual ( payload ) ; } ) ; it ( "s" , ( ) => { const payload = undefined ; const result = selectImage ( payload ) ; expect ( result . type ) . toEqual ( Actions . SELECT_IMAGE ) ; expect ( result . payload ) . toEqual ( payload ) ; } ) ; } ) ;	O O $complex$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $complex$ O $complex$ O O O O $any$ O $complex$ O $Actions$ O O $any$ O $any$ O $Actions.SELECT_IMAGE$ O O $any$ O $complex$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $undefined$ O O $complex$ O $complex$ O $any$ O O $any$ O $complex$ O $Actions$ O O $any$ O $any$ O $Actions.SELECT_IMAGE$ O O $any$ O $complex$ O $string$ O O $any$ O $any$ O O O O O O O O
const mockDevice = { setUserEnv : jest . fn ( ( ) => Promise . resolve ( { } ) ) , execScript : jest . fn ( ( ) => Promise . resolve ( { } ) ) } ; jest . mock ( "s" , ( ) => { return { getDevice : ( ) => ( mockDevice ) } ; } ) ; let mockData = [ { id : 0 } , { id : 0 } , { id : 0 } ] ; let mockDelete = Promise . resolve ( ) ; jest . mock ( "s" , ( ) => ( { post : jest . fn ( ( ) => Promise . resolve ( { data : mockData } ) ) , delete : jest . fn ( ( ) => mockDelete ) , } ) ) ; const mockInc = jest . fn ( ) ; const mockFinish = jest . fn ( ) ; jest . mock ( "s" , ( ) => ( { Progress : ( ) => ( { inc : mockInc , finish : mockFinish } ) , trim : jest . fn ( x => x ) , } ) ) ; import { deletePoints } from "s" ; import { scanImage , test } from "s" ; import axios from "s" ; import { API } from "s" ; import { times } from "s" ; import { Actions } from "s" ; import { error , success } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const thunk = scanImage ( 0 ) ; thunk ( ) ; expect ( mockDevice . execScript ) . toHaveBeenCalledWith ( "s" , [ { args : { label : "s" , value : "s" } , kind : "s" } ] ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const thunk = test ( ) ; thunk ( ) ; expect ( mockDevice . execScript ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { API . setBaseUrl ( "s" ) ; it ( "s" , async ( ) => { mockDelete = Promise . resolve ( ) ; mockData = [ { id : 0 } , { id : 0 } , { id : 0 } ] ; const dispatch = jest . fn ( ) ; await deletePoints ( "s" , "s" ) ( dispatch , jest . fn ( ) ) ; expect ( axios . post ) . toHaveBeenCalledWith ( "s" , { meta : { created_by : "s" } } ) ; await expect ( axios . delete ) . toHaveBeenCalledWith ( "s" ) ; await expect ( error ) . not . toHaveBeenCalled ( ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : [ 0 , 0 , 0 ] , type : Actions . DELETE_POINT_OK } ) ; expect ( mockInc ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockFinish ) . toHaveBeenCalledTimes ( 0 ) ; expect ( success ) . toHaveBeenCalledWith ( "s" ) ; } ) ; it ( "s" , async ( ) => { mockDelete = Promise . reject ( "s" ) ; mockData = [ { id : 0 } , { id : 0 } , { id : 0 } ] ; const dispatch = jest . fn ( ) ; await deletePoints ( "s" , "s" ) ( dispatch , jest . fn ( ) ) ; expect ( axios . post ) . toHaveBeenCalledWith ( "s" , { meta : { created_by : "s" } } ) ; await expect ( axios . delete ) . toHaveBeenCalledWith ( "s" ) ; await expect ( dispatch ) . not . toHaveBeenCalled ( ) ; await expect ( mockInc ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockFinish ) . toHaveBeenCalledTimes ( 0 ) ; expect ( success ) . not . toHaveBeenCalledWith ( ) ; expect ( error ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; expect ( error ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; } ) ; it ( "s" , async ( ) => { mockDelete = Promise . resolve ( ) ; mockData = times ( 0 , ( ) => ( { id : 0 } ) ) ; const dispatch = jest . fn ( ) ; await deletePoints ( "s" , "s" ) ( dispatch , jest . fn ( ) ) ; expect ( axios . post ) . toHaveBeenCalledWith ( "s" , { meta : { created_by : "s" } } ) ; await expect ( axios . delete ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; await expect ( error ) . not . toHaveBeenCalled ( ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : expect . arrayContaining ( [ 0 ] ) , type : Actions . DELETE_POINT_OK } ) ; expect ( mockInc ) . toHaveBeenCalledTimes ( 0 ) ; expect ( mockFinish ) . toHaveBeenCalledTimes ( 0 ) ; expect ( success ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ;	O $complex$ O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O $any$ O $any$ O O O O O O O O O $complex$ O O O O O $complex$ O O O O O O O $complex$ O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O O $Promise<void>$ O $PromiseConstructor$ O $complex$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O $complex$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $Promise<void>$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O $complex$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O $complex$ O $any$ O O $any$ O O O O O $complex$ O O $string$ O O O $string$ O O O O $string$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $complex$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O $void$ O O O O $any$ O O O O O O O O $Promise<void>$ O $PromiseConstructor$ O $complex$ O O O $complex$ O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $number[]$ O O O O O O O O O $Actions$ O $any$ O $Actions.DELETE_POINT_OK$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $void$ O O $any$ O O O O O O O $any$ O O O O O O O O $Promise<void>$ O $PromiseConstructor$ O $Promise<T>$ O O O O $complex$ O O O $number$ O O O O O $number$ O O O O O $number$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $void$ O O $any$ O $any$ O $any$ O O O O O $any$ O $void$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $Promise<void>$ O $PromiseConstructor$ O $complex$ O O O $complex$ O $any$ O O O O O O O O $number$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O $void$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O $Actions$ O $any$ O $Actions.DELETE_POINT_OK$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $void$ O O $any$ O O O O O O O O O O
import { DropDownItem } from "s" ; import { SPECIAL_VALUES } from "s" ; import { t } from "s" ; export const SPECIAL_VALUE_DDI : { [ index ] : DropDownItem } = { [ SPECIAL_VALUES . X ] : { label : "s" , value : SPECIAL_VALUES . X } , [ SPECIAL_VALUES . Y ] : { label : "s" , value : SPECIAL_VALUES . Y } , [ SPECIAL_VALUES . TOP_LEFT ] : { label : t ( "s" ) , value : SPECIAL_VALUES . TOP_LEFT } , [ SPECIAL_VALUES . TOP_RIGHT ] : { label : t ( "s" ) , value : SPECIAL_VALUES . TOP_RIGHT } , [ SPECIAL_VALUES . BOTTOM_LEFT ] : { label : t ( "s" ) , value : SPECIAL_VALUES . BOTTOM_LEFT } , [ SPECIAL_VALUES . BOTTOM_RIGHT ] : { label : t ( "s" ) , value : SPECIAL_VALUES . BOTTOM_RIGHT } , } ; export const CALIBRATION_DROPDOWNS : DropDownItem [ ] = [ SPECIAL_VALUE_DDI [ SPECIAL_VALUES . X ] , SPECIAL_VALUE_DDI [ SPECIAL_VALUES . Y ] ] ; export const ORIGIN_DROPDOWNS : DropDownItem [ ] = [ SPECIAL_VALUE_DDI [ SPECIAL_VALUES . TOP_LEFT ] , SPECIAL_VALUE_DDI [ SPECIAL_VALUES . TOP_RIGHT ] , SPECIAL_VALUE_DDI [ SPECIAL_VALUES . BOTTOM_LEFT ] , SPECIAL_VALUE_DDI [ SPECIAL_VALUES . BOTTOM_RIGHT ] , ] ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O $number$ O O $any$ O O O O $any$ O $SPECIAL_VALUES.X$ O O O $string$ O O O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.X$ O O O $any$ O $SPECIAL_VALUES.Y$ O O O $string$ O O O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.Y$ O O O $any$ O $SPECIAL_VALUES.TOP_LEFT$ O O O $any$ O $any$ O O O O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.TOP_LEFT$ O O O $any$ O $SPECIAL_VALUES.TOP_RIGHT$ O O O $any$ O $any$ O O O O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.TOP_RIGHT$ O O O $any$ O $SPECIAL_VALUES.BOTTOM_LEFT$ O O O $any$ O $any$ O O O O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.BOTTOM_LEFT$ O O O $any$ O $SPECIAL_VALUES.BOTTOM_RIGHT$ O O O $any$ O $any$ O O O O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.BOTTOM_RIGHT$ O O O O O O $DropDownItem[]$ O $any$ O O O O $complex$ O $any$ O $SPECIAL_VALUES.X$ O O $complex$ O $any$ O $SPECIAL_VALUES.Y$ O O O O O $DropDownItem[]$ O $any$ O O O O $complex$ O $any$ O $SPECIAL_VALUES.TOP_LEFT$ O O $complex$ O $any$ O $SPECIAL_VALUES.TOP_RIGHT$ O O $complex$ O $any$ O $SPECIAL_VALUES.BOTTOM_LEFT$ O O $complex$ O $any$ O $SPECIAL_VALUES.BOTTOM_RIGHT$ O O O O
import { DropDownItem , NULL_CHOICE } from "s" ; import { SPECIAL_VALUE_DDI } from "s" ; import { WD_ENV } from "s" ; import { envGet } from "s" ; export let translateSpecialValue = ( input ) : DropDownItem => { return SPECIAL_VALUE_DDI [ input ] || NULL_CHOICE ; } ; export let getDropdownSelection = ( env < WD_ENV > ) => ( key : keyof WD_ENV ) : DropDownItem => { return translateSpecialValue ( envGet ( key , env ) ) ; } ;	O O $any$ O $Readonly<NullChoice>$ O O O O O O $complex$ O O O O O O $any$ O O O O O O O O O O O O O $DropDownItem$ O O $number$ O O $any$ O O O $complex$ O $number$ O O $Readonly<NullChoice>$ O O O O O O O O $Partial$ O $any$ O O O O O O O $any$ O O $any$ O O O $DropDownItem$ O O O O O O O O O O O
import { translateSpecialValue } from "s" ; import { NULL_CHOICE } from "s" ; import { SPECIAL_VALUES } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = translateSpecialValue ( SPECIAL_VALUES . X ) ; expect ( result . label ) . toEqual ( "s" ) ; expect ( result . value ) . toEqual ( SPECIAL_VALUES . X ) ; } ) ; it ( "s" , ( ) => { const result = translateSpecialValue ( 0 ) ; expect ( result ) . toEqual ( NULL_CHOICE ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { } ) ; } ) ;	O O $DropDownItem$ O O O O O O $Readonly<NullChoice>$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $DropDownItem$ O $DropDownItem$ O $any$ O $SPECIAL_VALUES.X$ O O $any$ O $DropDownItem$ O $string$ O O $any$ O O O O $any$ O $DropDownItem$ O $complex$ O O $any$ O $any$ O $SPECIAL_VALUES.X$ O O O O O $any$ O O O O O O O O $DropDownItem$ O $DropDownItem$ O O O O $any$ O $DropDownItem$ O O $any$ O $Readonly<NullChoice>$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O
import { getDevice } from "s" ; import { WDENVKey } from "s" ; import { formatEnvKey } from "s" ; export function envSave ( key , value ) { getDevice ( ) . setUserEnv ( { [ key ] : JSON . stringify ( formatEnvKey ( key , value ) ) } ) . catch ( ( ) => { } ) ; }	O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O $WDENVKey$ O $number$ O O $any$ O O O $any$ O O O O O O $JSON$ O $complex$ O O O O O $number$ O O O O O $any$ O O O O O O O O O
jest . mock ( "s" , ( ) => { const mock = { setUserEnv : jest . fn ( ( ) => Promise . resolve ( ) ) } ; return { getDevice : ( ) => mock } ; } ) ; import { envSave } from "s" ; import { getDevice } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { envSave ( "s" , 0 ) ; expect ( getDevice ( ) . setUserEnv ) . toHaveBeenCalledTimes ( 0 ) ; expect ( getDevice ( ) . setUserEnv ) . toHaveBeenLastCalledWith ( { "s" : "s" } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O $complex$ O O O O $complex$ O O O O O O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O O O $any$ O O $any$ O O O O O O O O O O O O O O
import { DEFAULT_FORMATTER } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( ( ) => { DEFAULT_FORMATTER . parse ( "s" , "s" ) ; } ) . toThrow ( ) ; } ) ; it ( "s" , ( ) => { expect ( ( ) => { DEFAULT_FORMATTER . parse ( "s" , JSON . stringify ( { } ) ) ; } ) . toThrow ( ) ; } ) ; it ( "s" , ( ) => { const result = DEFAULT_FORMATTER . parse ( "s" , "s" ) ; expect ( result ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { const result = DEFAULT_FORMATTER . parse ( "s" , "s" ) ; expect ( result ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { const result = DEFAULT_FORMATTER . format ( "s" , 0 ) ; expect ( result ) . toEqual ( 0 ) ; } ) ; } ) ;	O O $Translation$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O O $Translation$ O $ParserFn$ O O O O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O O O $Translation$ O $ParserFn$ O O O $JSON$ O $complex$ O O O O O O O O O $any$ O O O O O O $any$ O O O O O O O O $number$ O $Translation$ O $ParserFn$ O O O O O O $any$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $number$ O $Translation$ O $ParserFn$ O O O O O O $any$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $Translation$ O $FormatterFn$ O O O O O O $any$ O $complex$ O O $any$ O O O O O O O O O O
import { prepopulateEnv , envGet } from "s" ; import { WD_KEY_DEFAULTS } from "s" ; import { WD_ENV } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const env = { CAMERA_CALIBRATION_calibration_object_separation : "s" } ; const result = prepopulateEnv ( env ) ; expect ( result . CAMERA_CALIBRATION_calibration_object_separation ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { const result = prepopulateEnv ( { } ) ; const actual = result . CAMERA_CALIBRATION_calibration_object_separation ; const expected = WD_KEY_DEFAULTS . CAMERA_CALIBRATION_calibration_object_separation ; expect ( actual ) . toEqual ( expected ) ; } ) ; } ) ; describe ( "s" , ( ) => { const myEnv < WD_ENV > = { "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 } ; it ( "s" , ( ) => { const result = envGet ( "s" , myEnv ) ; expect ( result ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { const result = envGet ( "s" , myEnv ) ; expect ( result ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { myEnv . CAMERA_CALIBRATION_morph = undefined ; const result = envGet ( "s" , myEnv ) ; expect ( result ) . toEqual ( 0 ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O O O O O O $complex$ O O $any$ O O O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O $number$ O O O $number$ O O $number$ O O O $number$ O $any$ O $number$ O O $any$ O $number$ O O O O O O O O $any$ O O O O O O O O $Partial$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O $number$ O O O O O O O O $any$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $number$ O O O O O O O O $any$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O O $number$ O $undefined$ O O $number$ O O O O O O O O $any$ O $number$ O O $any$ O O O O O O O O O O
import { formatEnvKey , parseEnvKey } from "s" ; import { SPECIAL_VALUES , getSpecialValue } from "s" ; import { WDENVKey } from "s" ; import { getDropdownSelection } from "s" ; import { prepopulateEnv } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( getSpecialValue ( JSON . stringify ( "s" ) ) ) . toEqual ( SPECIAL_VALUES . TRUE ) ; expect ( getSpecialValue ( JSON . stringify ( "s" ) ) ) . toEqual ( SPECIAL_VALUES . FALSE ) ; expect ( getSpecialValue ( JSON . stringify ( "s" ) ) ) . toEqual ( SPECIAL_VALUES . BOTTOM_LEFT ) ; expect ( getSpecialValue ( JSON . stringify ( "s" ) ) ) . toEqual ( SPECIAL_VALUES . TOP_LEFT ) ; } ) ; it ( "s" , ( ) => { expect ( ( ) => { getSpecialValue ( "s" ) ; } ) . toThrow ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { [ { k : "s" , v : SPECIAL_VALUES . TRUE , r : "s" } , { k : "s" , v : SPECIAL_VALUES . FALSE , r : "s" } , { k : "s" , v : SPECIAL_VALUES . X , r : "s" } , { k : "s" , v : SPECIAL_VALUES . Y , r : "s" } , { k : "s" , v : SPECIAL_VALUES . TOP_LEFT , r : "s" } ] . map ( t => { expect ( formatEnvKey ( t . k as WDENVKey , t . v ) ) . toEqual ( t . r ) ; } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const val = "s" ; const r = parseEnvKey ( "s" , val ) ; expect ( r ) . toEqual ( SPECIAL_VALUES . Y ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const key = "s" ; const stubs = { [ key ] : "s" } ; const fakeEnv = prepopulateEnv ( stubs ) ; expect ( fakeEnv [ key ] ) . toEqual ( SPECIAL_VALUES . Y ) ; const finder = getDropdownSelection ( fakeEnv ) ; const result = finder ( key ) ; expect ( result . value ) . toEqual ( SPECIAL_VALUES . Y ) ; } ) ; } ) ;	O O O O O O O O O O O $any$ O $SPECIAL_VALUES$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $SPECIAL_VALUES$ O $JSON$ O $complex$ O O O O O O $any$ O $any$ O $SPECIAL_VALUES.TRUE$ O O $any$ O $SPECIAL_VALUES$ O $JSON$ O $complex$ O O O O O O $any$ O $any$ O $SPECIAL_VALUES.FALSE$ O O $any$ O $SPECIAL_VALUES$ O $JSON$ O $complex$ O O O O O O $any$ O $any$ O $SPECIAL_VALUES.BOTTOM_LEFT$ O O $any$ O $SPECIAL_VALUES$ O $JSON$ O $complex$ O O O O O O $any$ O $any$ O $SPECIAL_VALUES.TOP_LEFT$ O O O O O $any$ O O O O O O O $any$ O O O O O $SPECIAL_VALUES$ O O O O O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $string$ O O O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.TRUE$ O $string$ O O O O O $string$ O O O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.FALSE$ O $string$ O O O O O $string$ O O O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.X$ O $string$ O O O O O $string$ O O O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.Y$ O $string$ O O O O O $string$ O O O $SPECIAL_VALUES$ O $any$ O $SPECIAL_VALUES.TOP_LEFT$ O $string$ O O O O O $U[]$ O $complex$ O O $any$ O O O $complex$ O $string$ O $any$ O $complex$ O $SPECIAL_VALUES$ O O O $any$ O $complex$ O $string$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $number$ O O O O O O O O $any$ O $number$ O O $any$ O $any$ O $SPECIAL_VALUES.Y$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $WDENVKey$ O O O O $complex$ O O O O O O O O O O O O O O $complex$ O O $any$ O O O O O O O $any$ O $any$ O $SPECIAL_VALUES.Y$ O O O O O O O O O O O $DropDownItem$ O O O O O O $any$ O $DropDownItem$ O $complex$ O O $any$ O $any$ O $SPECIAL_VALUES.Y$ O O O O O O O O
function flunk ( ) { const READ_THE_COMMENT_ABOVE = "s" ; alert ( READ_THE_COMMENT_ABOVE ) ; window . location . assign ( "s" ) ; } const REQUIRED_GLOBALS = [ "s" , "s" , "s" , "s" , "s" ] ; const REQUIRED_ARRAY_METHODS = [ "s" , "s" , "s" ] ; export function stopIE ( ) { try { for ( let i = 0 ; i < REQUIRED_GLOBALS . length ; i ++ ) { if ( ! window . hasOwnProperty ( REQUIRED_GLOBALS [ i ] ) ) { flunk ( ) ; } } for ( let i = 0 ; i < REQUIRED_ARRAY_METHODS . length ; i ++ ) { if ( ! Array . prototype . hasOwnProperty ( REQUIRED_ARRAY_METHODS [ i ] ) ) { flunk ( ) ; } } if ( ! Object . entries ) { flunk ( ) ; } } catch ( error ) { flunk ( ) ; } }	O $void$ O O O O O O O O $void$ O O O O $complex$ O $Location$ O $void$ O O O O O O $string[]$ O O O O O O O O O O O O O O $string[]$ O O O O O O O O O O O $void$ O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O O O $complex$ O $boolean$ O $string[]$ O $number$ O O O O $void$ O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O O O $ArrayConstructor$ O $any[]$ O $boolean$ O $string[]$ O $number$ O O O O $void$ O O O O O O O O $ObjectConstructor$ O $complex$ O O $void$ O O O O O O O $any$ O O $void$ O O O O O
jest . mock ( "s" , ( ) => { return { detectLanguage : jest . fn ( ( ) => Promise . resolve ( ) ) } ; } ) ; jest . mock ( "s" , ( ) => { return { stopIE : jest . fn ( ) } ; } ) ; jest . mock ( "s" , ( ) => ( { attachToRoot : jest . fn ( ) , trim : ( s ) => s } ) ) ; import { detectLanguage } from "s" ; import { stopIE } from "s" ; import { attachToRoot } from "s" ; import { FrontPage , attachFrontPage } from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await import ( "s" ) ; expect ( detectLanguage ) . toHaveBeenCalled ( ) ; expect ( stopIE ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { attachFrontPage ( ) ; expect ( attachToRoot ) . toHaveBeenCalledWith ( FrontPage , { } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $string$ O O $string$ O O $string$ O O O O O O $any$ O O O O O O $void$ O O O O O O $void$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $void$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O O O $any$ O $void$ O O $any$ O $any$ O O O O O O O O O O O
import { helpReducer , HelpState } from "s" ; import { Actions } from "s" ; describe ( "s" , ( ) => { const fakeState = ( ) : HelpState => ( { currentTour : undefined , } ) ; it ( "s" , ( ) => { const oldState = fakeState ( ) ; oldState . currentTour = "s" ; const newState = helpReducer ( oldState , { type : Actions . START_TOUR , payload : undefined } ) ; expect ( oldState . currentTour ) . not . toEqual ( newState . currentTour ) ; expect ( newState . currentTour ) . toBeUndefined ( ) ; } ) ; } ) ;	O O $generateReducer<HelpState>.GeneratedReducer$ O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $HelpState$ O O O O $any$ O O O $undefined$ O $undefined$ O O O O $any$ O O O O O O O O $HelpState$ O $HelpState$ O O O $HelpState$ O $string$ O O O O $HelpState$ O $generateReducer<HelpState>.GeneratedReducer$ O $HelpState$ O O $Actions.START_TOUR$ O $any$ O $Actions.START_TOUR$ O $undefined$ O $undefined$ O O O $any$ O $HelpState$ O $string$ O O $any$ O $any$ O $HelpState$ O $string$ O O $any$ O $HelpState$ O $string$ O O $any$ O O O O O O O O O
import { history } from "s" ; import { Step as TourStep } from "s" ; import { TourContent } from "s" ; import { t } from "s" ; export enum Tours { gettingStarted = "s" , monitoring = "s" , funStuff = "s" , } export const tourNames = ( ) => [ { name : Tours . gettingStarted , description : t ( "s" ) } , { name : Tours . monitoring , description : t ( "s" ) } , { name : Tours . funStuff , description : t ( "s" ) } , ] ; export const TOUR_STEPS = ( ) : { [ x ] : TourStep [ ] } => ( { [ Tours . gettingStarted ] : [ { target : "s" , content : TourContent . ADD_PLANTS , title : t ( "s" ) , } , { target : "s" , content : TourContent . ADD_TOOLS , title : t ( "s" ) , } , { target : "s" , content : TourContent . ADD_TOOLS_SLOTS , title : t ( "s" ) , } , { target : "s" , content : TourContent . ADD_PERIPHERALS , title : t ( "s" ) , } , { target : "s" , content : TourContent . ADD_SEQUENCES , title : t ( "s" ) , } , { target : "s" , content : TourContent . ADD_REGIMENS , title : t ( "s" ) , } , { target : "s" , content : TourContent . ADD_FARM_EVENTS , title : t ( "s" ) , } , ] , [ Tours . monitoring ] : [ { target : "s" , content : TourContent . LOCATION_GRID , title : t ( "s" ) , } , { target : "s" , content : TourContent . VIRTUAL_FARMBOT , title : t ( "s" ) , } , { target : "s" , content : TourContent . LOGS_TABLE , title : t ( "s" ) , } , { target : "s" , content : TourContent . PHOTOS , title : t ( "s" ) , } , ] , [ Tours . funStuff ] : [ { target : "s" , content : TourContent . APP_SETTINGS , title : t ( "s" ) , } , ] , } ) ; export const tourPageNavigation = ( nextStepTarget : string | HTMLElement ) => { switch ( nextStepTarget ) { case "s" : history . push ( "s" ) ; break ; case "s" : history . push ( "s" ) ; break ; case "s" : history . push ( "s" ) ; break ; case "s" : case "s" : history . push ( "s" ) ; break ; case "s" : history . push ( "s" ) ; break ; case "s" : history . push ( "s" ) ; break ; case "s" : history . push ( "s" ) ; break ; case "s" : case "s" : history . push ( "s" ) ; break ; case "s" : history . push ( "s" ) ; break ; case "s" : history . push ( "s" ) ; break ; case "s" : history . push ( "s" ) ; break ; } } ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $Tours.gettingStarted$ O O O $Tours.monitoring$ O O O $Tours.funStuff$ O O O O O O $complex$ O O O O O O $Tours$ O $any$ O $Tours.gettingStarted$ O $any$ O $any$ O O O O O O $Tours$ O $any$ O $Tours.monitoring$ O $any$ O $any$ O O O O O O $Tours$ O $any$ O $Tours.funStuff$ O $any$ O $any$ O O O O O O O O O $complex$ O O O O O O $string$ O O $any$ O O O O O O O $any$ O $Tours.gettingStarted$ O O O O $string$ O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O O O O $string$ O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O O O O $string$ O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O O O O $string$ O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O O O O $string$ O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O O O O $string$ O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O O O O $string$ O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O O O O O O $any$ O $Tours.monitoring$ O O O O $string$ O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O O O O $string$ O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O O O O $string$ O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O O O O $string$ O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O O O O O O $any$ O $Tours.funStuff$ O O O O $string$ O O O $string$ O $any$ O $string$ O $any$ O $any$ O O O O O O O O O O O O O $void$ O O $complex$ O O O $complex$ O O O O O $complex$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O O
jest . mock ( "s" , ( ) => ( { history : { push : jest . fn ( ) } } ) ) ; import { tourPageNavigation } from "s" ; import { history } from "s" ; describe ( "s" , ( ) => { const testCase = ( el ) => { tourPageNavigation ( el ) ; expect ( history . push ) . toHaveBeenCalled ( ) ; } ; it ( "s" , ( ) => { testCase ( "s" ) ; testCase ( "s" ) ; testCase ( "s" ) ; testCase ( "s" ) ; testCase ( "s" ) ; testCase ( "s" ) ; testCase ( "s" ) ; testCase ( "s" ) ; testCase ( "s" ) ; testCase ( "s" ) ; testCase ( "s" ) ; testCase ( "s" ) ; testCase ( "s" ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O $void$ O O O O O O $any$ O O O O $any$ O O O O O O O O $void$ O O $string$ O O O $void$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O O O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O $void$ O O O O O O O O O O
import { Everything } from "s" ; import { selectAllLogs , maybeGetTimeSettings , maybeGetDevice } from "s" ; import { LogsProps } from "s" ; import { sourceFbosConfigValue } from "s" ; import { validFbosConfig , determineInstalledOsVersion , createShouldDisplayFn as shouldDisplayFunc } from "s" ; import { ResourceIndex } from "s" ; import { TaggedLog } from "s" ; import { getWebAppConfigValue } from "s" ; import { getFbosConfig } from "s" ; import { chain } from "s" ; import { DevSettings } from "s" ; export function takeSortedLogs ( numberOfLogs , ri ) : TaggedLog [ ] { return chain ( selectAllLogs ( ri ) ) . sortBy ( "s" ) . reverse ( ) . take ( numberOfLogs ) . value ( ) ; } export function mapStateToProps ( props ) { const { hardware } = props . bot ; const fbosConfig = validFbosConfig ( getFbosConfig ( props . resources . index ) ) ; const sourceFbosConfig = sourceFbosConfigValue ( fbosConfig , hardware . configuration ) ; const installedOsVersion = determineInstalledOsVersion ( props . bot , maybeGetDevice ( props . resources . index ) ) ; const fbosVersionOverride = DevSettings . overriddenFbosVersion ( ) ; const shouldDisplay = shouldDisplayFunc ( installedOsVersion , props . bot . minOsFeatureData , fbosVersionOverride ) ; return { dispatch : props . dispatch , sourceFbosConfig , logs : takeSortedLogs ( 0 , props . resources . index ) , timeSettings : maybeGetTimeSettings ( props . resources . index ) , getConfigValue : getWebAppConfigValue ( ( ) => props ) , shouldDisplay , } ; }	O O $any$ O O O O O O $any[]$ O $TimeSettings$ O $any$ O O O O O O $any$ O O O O O O $SourceFbosConfig$ O O O O O O $any$ O $string$ O $boolean$ O $boolean$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any[]$ O $number$ O $ResourceIndex$ O O $any$ O O O O $any$ O $any[]$ O $ResourceIndex$ O O O $any$ O O O O $any$ O O O $any$ O $number$ O O $any$ O O O O O O $LogsProps$ O $Everything$ O O O O $any$ O O $Everything$ O $BotState$ O O $any$ O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $SourceFbosConfig$ O $SourceFbosConfig$ O $any$ O $any$ O $any$ O O O $string$ O $string$ O $Everything$ O $BotState$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $string$ O $any$ O $string$ O O O O $boolean$ O $boolean$ O $string$ O $Everything$ O $BotState$ O $complex$ O $string$ O O O O $Function$ O $Everything$ O $Function$ O $SourceFbosConfig$ O $any[]$ O $any[]$ O O O $Everything$ O $RestResources$ O $ResourceIndex$ O O $TimeSettings$ O $TimeSettings$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $complex$ O $complex$ O O O O $Everything$ O O $boolean$ O O O O
import { mapStateToProps } from "s" ; import { fakeState } from "s" ; import { buildResourceIndex } from "s" ; import { TaggedLog } from "s" ; import { times } from "s" ; import { fakeFbosConfig , fakeLog } from "s" ; describe ( "s" , ( ) => { function fakeLogs ( count ) : TaggedLog [ ] { return times ( count , fakeLog ) ; } it ( "s" , ( ) => { const state = fakeState ( ) ; state . resources = buildResourceIndex ( fakeLogs ( 0 ) ) ; const props = mapStateToProps ( state ) ; expect ( props . logs . length ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; state . bot . hardware . configuration . sequence_init_log = false ; const fakeApiConfig = fakeFbosConfig ( ) ; fakeApiConfig . body . sequence_init_log = true ; fakeApiConfig . body . api_migrated = true ; state . resources = buildResourceIndex ( [ fakeApiConfig ] ) ; const props = mapStateToProps ( state ) ; expect ( props . sourceFbosConfig ( "s" ) ) . toEqual ( { value : true , consistent : false } ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; state . bot . hardware . configuration . sequence_init_log = false ; const fakeApiConfig = fakeFbosConfig ( ) ; fakeApiConfig . body . sequence_init_log = true ; fakeApiConfig . body . api_migrated = false ; state . resources = buildResourceIndex ( [ fakeApiConfig ] ) ; const props = mapStateToProps ( state ) ; expect ( props . sourceFbosConfig ( "s" ) ) . toEqual ( { value : false , consistent : true } ) ; } ) ; } ) ;	O O $LogsProps$ O O O O O O $Everything$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O $any[]$ O $number$ O O $any$ O O O O $any$ O $number$ O $any$ O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $any$ O $any[]$ O O O O O O $LogsProps$ O $LogsProps$ O $Everything$ O O $any$ O $LogsProps$ O $any[]$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O $LogsProps$ O $LogsProps$ O $Everything$ O O $any$ O $LogsProps$ O $SourceFbosConfig$ O O O O O $any$ O O $boolean$ O O O $boolean$ O O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O $LogsProps$ O $LogsProps$ O $Everything$ O O $any$ O $LogsProps$ O $SourceFbosConfig$ O O O O O $any$ O O $boolean$ O O O $boolean$ O O O O O O O O O O O
import axios from "s" ; import { API } from "s" ; import { Bulletin } from "s" ; import { DropDownItem } from "s" ; import { UnsafeError } from "s" ; import { toastErrors } from "s" ; import { info } from "s" ; import { t } from "s" ; const url = ( slug ) => `template` ; export const fetchBulletinContent = ( slug ) : Promise < Bulletin | undefined > => { return axios . get < Bulletin > ( url ( slug ) ) . then ( response => Promise . resolve ( response . data ) ) ; } ; export const seedAccount = ( onClick : ( ) => void ) => ( ddi ) => axios . post ( API . current . accountSeedPath , { product_line : ddi . value } ) . then ( ( ) => { info ( t ( "s" ) , "s" ) ; onClick ( ) ; } , ( err ) => toastErrors ( { err } ) ) ;	O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $void$ O O O O O O $any$ O O O O O $string$ O O $string$ O O O O O O $Promise<Bulletin>$ O O $string$ O O $PromiseConstructor$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $string$ O $string$ O O O $any$ O $any$ O $PromiseConstructor$ O $complex$ O $any$ O $any$ O O O O O O O $any$ O O $void$ O O O O O O O O $DropDownItem$ O O $any$ O $any$ O $any$ O $API$ O $string$ O O $complex$ O $DropDownItem$ O $complex$ O O O $any$ O O O O O $void$ O $any$ O O O O O O O $void$ O O O O O O $UnsafeError$ O O $void$ O O $any$ O O O O
let mockPostResponse = Promise . resolve ( { data : { foo : "s" } } ) ; jest . mock ( "s" , ( ) => ( { get : jest . fn ( ( ) => Promise . resolve ( { data : { foo : "s" } } ) ) , post : jest . fn ( ( ) => mockPostResponse ) , } ) ) ; jest . mock ( "s" , ( ) => ( { API : { current : { globalBulletinPath : "s" , accountSeedPath : "s" } } } ) ) ; import axios from "s" ; import { fetchBulletinContent , seedAccount } from "s" ; import { info , error } from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { expect ( await fetchBulletinContent ( "s" ) ) . toEqual ( { foo : "s" } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const dismiss = jest . fn ( ) ; await seedAccount ( dismiss ) ( { label : "s" , value : "s" } ) ; expect ( axios . post ) . toHaveBeenCalledWith ( "s" , { product_line : "s" } ) ; expect ( info ) . toHaveBeenCalledWith ( "s" , "s" ) ; expect ( dismiss ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , async ( ) => { mockPostResponse = Promise . reject ( { response : { data : [ "s" ] } } ) ; const dismiss = jest . fn ( ) ; await seedAccount ( dismiss ) ( { label : "s" , value : "s" } ) ; expect ( axios . post ) . toHaveBeenCalledWith ( "s" , { product_line : "s" } ) ; expect ( error ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; expect ( dismiss ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ;	O $complex$ O $PromiseConstructor$ O $complex$ O O $complex$ O O $string$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O O O O O $any$ O $any$ O O O O O O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O O O O O $any$ O O O O O $Promise<Bulletin>$ O $any$ O O O O O O $void$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $Promise<Bulletin>$ O O O O O $any$ O O $string$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $string$ O O O O O $any$ O $void$ O O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $complex$ O $PromiseConstructor$ O $Promise<T>$ O O $complex$ O O $string[]$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O $string$ O O O O O $any$ O $void$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O
import { fakeFbosConfig } from "s" ; import { AlertReducerState } from "s" ; import { batchInitResources } from "s" ; import { alertsReducer } from "s" ; import { overwrite } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const c = fakeFbosConfig ( ) ; c . body . firmware_hardware = undefined as any ; const s = { alerts : { } } ; const { alerts } = alertsReducer ( s , batchInitResources ( [ c ] ) ) ; const results = Object . values ( alerts ) ; expect ( results [ 0 ] ) . toEqual ( { created_at : 0 , problem_tag : "s" , priority : 0 , slug : "s" , } ) ; } ) ; it ( "s" , ( ) => { const c = fakeFbosConfig ( ) ; const s = { alerts : { } } ; const action = overwrite ( c , { ... c . body , firmware_hardware : "s" } ) ; const { alerts } = alertsReducer ( s , action ) ; const results = Object . values ( alerts ) ; expect ( results [ 0 ] ) . toEqual ( undefined ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $ReduxAction<any[]>$ O O O O O O $generateReducer<AlertReducerState>.GeneratedReducer$ O O O O O O $ReduxAction<EditResourceParams>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $undefined$ O O O O $AlertReducerState$ O O ${}$ O O O O O O O $any$ O O $generateReducer<AlertReducerState>.GeneratedReducer$ O $AlertReducerState$ O $ReduxAction<any[]>$ O O $any$ O O O O O $unknown[]$ O $ObjectConstructor$ O $complex$ O $any$ O O $any$ O $unknown[]$ O O O O O $any$ O O $number$ O O O $string$ O O O $number$ O O O $string$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $AlertReducerState$ O O ${}$ O O O O O O $ReduxAction<EditResourceParams>$ O $ReduxAction<EditResourceParams>$ O $any$ O O O $any$ O $any$ O $string$ O O O O O O O $any$ O O $generateReducer<AlertReducerState>.GeneratedReducer$ O $AlertReducerState$ O $ReduxAction<EditResourceParams>$ O O O $unknown[]$ O $ObjectConstructor$ O $complex$ O $any$ O O $any$ O $unknown[]$ O O O O O $any$ O $undefined$ O O O O O O O O
import { fakeState } from "s" ; import { mapStateToProps } from "s" ; import { buildResourceIndex } from "s" ; import { fakeAlert , fakeFbosConfig } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = fakeState ( ) ; const alert = fakeAlert ( ) ; alert . body . problem_tag = "s" ; state . resources = buildResourceIndex ( [ alert ] ) ; const props = mapStateToProps ( state ) ; expect ( props . alerts ) . toEqual ( [ alert . body ] ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; const fbosConfig = fakeFbosConfig ( ) ; fbosConfig . body . api_migrated = true ; fbosConfig . body . firmware_hardware = "s" ; state . resources = buildResourceIndex ( [ fbosConfig ] ) ; const props = mapStateToProps ( state ) ; expect ( props . apiFirmwareValue ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; const alert = fakeAlert ( ) ; alert . body . id = 0 ; state . resources = buildResourceIndex ( [ alert ] ) ; const props = mapStateToProps ( state ) ; expect ( props . findApiAlertById ( 0 ) ) . toEqual ( alert . uuid ) ; } ) ; } ) ;	O O $Everything$ O O O O O O $MessagesProps$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O $MessagesProps$ O $MessagesProps$ O $Everything$ O O $any$ O $MessagesProps$ O $any[]$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O $MessagesProps$ O $MessagesProps$ O $Everything$ O O $any$ O $MessagesProps$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O $MessagesProps$ O $MessagesProps$ O $Everything$ O O $any$ O $MessagesProps$ O $string$ O O O O O $any$ O $any$ O $any$ O O O O O O O O
import { store } from "s" ; import { urlFriendly } from "s" ; import { LinkComputeFn } from "s" ; export const computeEditorUrlFromState = ( resource : "s" | "s" ) : LinkComputeFn => { return ( ) => { const { resources } = store . getState ( ) ; const current = resource === "s" ? resources . consumers . sequences . current : resources . consumers . regimens . currentRegimen ; const r = resources . index . references [ current || "s" ] ; const base = `template` ; if ( r && r . kind == resource ) { return base + urlFriendly ( r . body . name ) ; } else { return base ; } } ; } ; export const computeFarmwareUrlFromState = ( ) => { const current = store . getState ( ) . resources . consumers . farmware . currentFarmware ; const base = "s" ; return base + ( current ? urlFriendly ( current ) : "s" ) ; } ;	O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O O O O O $any$ O $any$ O $any$ O O O O O $string$ O $string$ O $any$ O $any$ O $any$ O O O O O O $string$ O O O O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O $string$ O $any$ O O O O O O O
const mockSeqUUID = "s" ; const mockSeqName = "s" ; const mockRegUUID = "s" ; const mockRegName = "s" ; const mockFarmwareName = "s" ; const mockState = { resources : { consumers : { sequences : { current : mockSeqUUID } , regimens : { currentRegimen : mockRegUUID } , farmware : { currentFarmware : mockFarmwareName } } , index : { references : { [ mockSeqUUID ] : { kind : "s" , body : { name : mockSeqName } } , [ mockRegUUID ] : { kind : "s" , body : { name : mockRegName } } } } } } ; jest . mock ( "s" , ( ) => { return { store : { getState : jest . fn ( ( ) => mockState ) } } ; } ) ; import { computeEditorUrlFromState , computeFarmwareUrlFromState } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { mockState . resources . consumers . sequences . current = "s" ; const result = computeEditorUrlFromState ( "s" ) ( "s" , "s" ) ; expect ( result ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { mockState . resources . consumers . sequences . current = mockSeqUUID ; const result = computeEditorUrlFromState ( "s" ) ( "s" , "s" ) ; expect ( result ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { mockState . resources . consumers . regimens . currentRegimen = "s" ; const result = computeEditorUrlFromState ( "s" ) ( "s" , "s" ) ; expect ( result ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { mockState . resources . consumers . regimens . currentRegimen = mockRegUUID ; const result = computeEditorUrlFromState ( "s" ) ( "s" , "s" ) ; expect ( result ) . toBe ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { mockState . resources . consumers . farmware . currentFarmware = "s" ; const result = computeFarmwareUrlFromState ( ) ; expect ( result ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { mockState . resources . consumers . farmware . currentFarmware = "s" ; const result = computeFarmwareUrlFromState ( ) ; expect ( result ) . toBe ( "s" ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O O $complex$ O O $string$ O O O O O $complex$ O O $complex$ O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O O O O O O O $any$ O $any$ O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $any$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O $complex$ O $complex$ O $string$ O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O $complex$ O $complex$ O $string$ O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O $complex$ O $complex$ O $string$ O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O $complex$ O $complex$ O $string$ O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O $complex$ O $complex$ O $string$ O O O O $string$ O $string$ O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O $complex$ O $complex$ O $string$ O O O O $string$ O $string$ O O O $any$ O $string$ O O $any$ O O O O O O O O O O
const mockResponse : { promise : Promise < { } > } = { promise : Promise . resolve ( { data : { id : 0 , data : { attributes : { svg_icon : "s" , slug : "s" } } } } ) } ; jest . mock ( "s" , ( ) => ( { get : ( ) => mockResponse . promise } ) ) ; jest . unmock ( "s" ) ; import { cachedCrop } from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const 0 = await cachedCrop ( "s" ) ; expect ( 0 . svg_icon ) . toContain ( "s" ) ; const 0 = await cachedCrop ( "s" ) ; expect ( 0 . slug ) . toBe ( 0 . slug ) ; expect ( 0 . svg_icon ) . toBe ( 0 . svg_icon ) ; expect ( 0 . spread ) . toBe ( undefined ) ; } ) ; it ( "s" , async ( ) => { const old = mockResponse . promise ; mockResponse . promise = Promise . resolve ( { data : { } } ) ; const radish = await cachedCrop ( "s" ) ; expect ( radish . spread ) . toBeUndefined ( ) ; expect ( radish . svg_icon ) . toBeUndefined ( ) ; mockResponse . promise = old ; } ) ; } ) ;	O $complex$ O O $Promise<{}>$ O $PromiseConstructor$ O O O O O O O $complex$ O $PromiseConstructor$ O $complex$ O O $complex$ O O $number$ O O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O O O O O O $any$ O $any$ O O O O O O O O $Promise<{}>$ O O O O $complex$ O $Promise<{}>$ O O O O $any$ O $any$ O O O O O O $Promise<Readonly<OFCropAttrs>>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $Readonly<OFCropAttrs>$ O O $Promise<Readonly<OFCropAttrs>>$ O O O O $any$ O $Readonly<OFCropAttrs>$ O $string$ O O $any$ O O O O O $Readonly<OFCropAttrs>$ O O $Promise<Readonly<OFCropAttrs>>$ O O O O $any$ O $Readonly<OFCropAttrs>$ O $string$ O O $any$ O $Readonly<OFCropAttrs>$ O $string$ O O $any$ O $Readonly<OFCropAttrs>$ O $string$ O O $any$ O $Readonly<OFCropAttrs>$ O $string$ O O $any$ O $Readonly<OFCropAttrs>$ O $number$ O O $any$ O $undefined$ O O O O O $any$ O O O O O O O O O $Promise<{}>$ O $complex$ O $Promise<{}>$ O $complex$ O $Promise<{}>$ O $PromiseConstructor$ O $complex$ O O ${}$ O O O O O O O $Readonly<OFCropAttrs>$ O O $Promise<Readonly<OFCropAttrs>>$ O O O O $any$ O $Readonly<OFCropAttrs>$ O $number$ O O $any$ O O O $any$ O $Readonly<OFCropAttrs>$ O $string$ O O $any$ O O O $complex$ O $Promise<{}>$ O $Promise<{}>$ O O O O O O O
import { OpenFarmAPI , svgToUrl } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( OpenFarmAPI . OFBaseURL ) . toContain ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( svgToUrl ( "s" ) ) . toEqual ( "s" ) ; } ) ; } ) ;	O O $any$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $string$ O O O O O $any$ O O O O O O O O O O
const mockFn = jest . fn ( ) ; jest . mock ( "s" , ( ) => { return { detectLanguage : jest . fn ( ( ) => Promise . resolve ( mockFn ) ) } ; } ) ; jest . mock ( "s" , ( ) => { return { init : jest . fn ( ) } ; } ) ; import { detectLanguage } from "s" ; import I from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await import ( "s" ) ; expect ( detectLanguage ) . toHaveBeenCalled ( ) ; expect ( I . init ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O
import I from "s" ; import _React , { createElement } from "s" ; import { render } from "s" ; import { PasswordReset } from "s" ; import { bail } from "s" ; export const MISSING_DIV = "s" ; export const onInit : I . Callback = async ( ) => { const node = document . createElement ( "s" ) ; node . id = "s" ; document . body . appendChild ( node ) ; const reactElem = createElement ( PasswordReset , { } ) ; const domElem = document . getElementById ( "s" ) ; return ( domElem ) ? render ( reactElem , domElem ) : bail ( MISSING_DIV ) ; } ;	O $any$ O O O O $any$ O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $never$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $HTMLElement$ O $Document$ O O O O O O $HTMLElement$ O $string$ O O O $Document$ O $HTMLElement$ O $T$ O $HTMLElement$ O O O $any$ O $any$ O $any$ O O O O O O $HTMLElement$ O $Document$ O $HTMLElement$ O O O O O O $HTMLElement$ O O $any$ O $any$ O $HTMLElement$ O O $never$ O O O O O O
jest . mock ( "s" , ( ) => ( { render : jest . fn ( ) } ) ) ; import { onInit } from "s" ; import { render } from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( done ) => { await onInit ( { } , jest . fn ( ) ) ; expect ( { } ) . toBeTruthy ( ) ; expect ( render ) . toHaveBeenCalled ( ) ; const [ calls ] = ( render as jest . Mock ) . mock . calls ; expect ( calls [ 0 ] . type . name ) . toBe ( "s" ) ; done ( ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O O O O O O O O O
import { buildResourceIndex } from "s" ; import { appIsReadonly } from "s" ; import { fakeWebAppConfig } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = appIsReadonly ( buildResourceIndex ( [ ] ) . index ) ; expect ( result ) . toBe ( true ) ; } ) ; it ( "s" , ( ) => { const conf = fakeWebAppConfig ( ) ; conf . body . user_interface_read_only_mode = true ; const result = appIsReadonly ( buildResourceIndex ( [ conf ] ) . index ) ; expect ( result ) . toBe ( true ) ; } ) ; it ( "s" , ( ) => { const conf = fakeWebAppConfig ( ) ; conf . body . user_interface_read_only_mode = false ; const result = appIsReadonly ( buildResourceIndex ( [ conf ] ) . index ) ; expect ( result ) . toBe ( false ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O
let mockReadonlyState = true ; jest . mock ( "s" , ( ) => ( { appIsReadonly : jest . fn ( ( ) => mockReadonlyState ) } ) ) ; import { DeepPartial } from "s" ; import { AxiosRequestConfig } from "s" ; import { readOnlyInterceptor } from "s" ; import { warning } from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const conf < AxiosRequestConfig > = { } ; const result = await readOnlyInterceptor ( conf as AxiosRequestConfig ) ; expect ( result ) . toBe ( conf ) ; } ) ; it ( "s" , ( done ) => { mockReadonlyState = true ; const conf < AxiosRequestConfig > = { method : "s" } ; readOnlyInterceptor ( conf as AxiosRequestConfig ) . then ( fail , ( result ) => { expect ( result ) . toBe ( conf ) ; expect ( warning ) . toHaveBeenCalledWith ( "s" ) ; done ( ) ; } ) ; } ) ; it ( "s" , ( done ) => { mockReadonlyState = true ; const conf < AxiosRequestConfig > = { method : "s" } ; readOnlyInterceptor ( conf as AxiosRequestConfig ) . then ( ( result ) => { expect ( result ) . toBe ( conf ) ; done ( ) ; } , fail ) ; } ) ; } ) ;	O $boolean$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $DeepPartial$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O $boolean$ O O O O $DeepPartial$ O $any$ O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $void$ O O $any$ O O O O $any$ O O O O O O O O O $any$ O O O O $any$ O O O $boolean$ O O O O $DeepPartial$ O $any$ O O O $string$ O O O O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O $any$ O O O O O O O O
jest . mock ( "s" , ( ) => { return { changeLastClientConnected : jest . fn ( ( ) => jest . fn ( ) ) } ; } ) ; jest . mock ( "s" , ( ) => { return { maybeGetDevice : jest . fn ( ( ) => ( { } ) ) } ; } ) ; import { createRefreshTrigger } from "s" ; import { changeLastClientConnected } from "s" ; import { maybeGetDevice } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const go = createRefreshTrigger ( ) ; go ( undefined ) ; go ( undefined ) ; go ( undefined ) ; expect ( changeLastClientConnected ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const go = createRefreshTrigger ( ) ; go ( { at : 0 , state : "s" } ) ; go ( { at : 0 , state : "s" } ) ; expect ( changeLastClientConnected ) . not . toHaveBeenCalled ( ) ; go ( { at : 0 , state : "s" } ) ; expect ( changeLastClientConnected ) . toHaveBeenCalled ( ) ; expect ( maybeGetDevice ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O $void$ O O O O O O $void$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $void$ O $void$ O O O $void$ O $undefined$ O O $void$ O $undefined$ O O $void$ O $undefined$ O O $any$ O $void$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $void$ O $void$ O O O $void$ O O $number$ O O O O O O O O O $void$ O O $number$ O O O O O O O O O $any$ O $void$ O O $any$ O $any$ O O O $void$ O O $number$ O O O O O O O O O $any$ O $void$ O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O
jest . mock ( "s" , ( ) => ( { throttledLogRefresh : jest . fn ( ) } ) ) ; import { refilterLogsMiddleware } from "s" ; import { throttledLogRefresh } from "s" ; import { Actions } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const fn = refilterLogsMiddleware . fn ( { } as any ) ( dispatch ) ; fn ( { type : "s" , payload : { } } as any ) ; expect ( throttledLogRefresh ) . not . toHaveBeenCalled ( ) ; fn ( { type : Actions . SAVE_RESOURCE_OK , payload : { kind : "s" } } ) ; expect ( throttledLogRefresh ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $MiddlewareConfig$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $void$ O $MiddlewareConfig$ O $MW$ O O O O O O O $any$ O O $void$ O O $string$ O O O ${}$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $void$ O O $Actions.SAVE_RESOURCE_OK$ O $any$ O $Actions.SAVE_RESOURCE_OK$ O $complex$ O O $string$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O
const mockGet = jest . fn ( ( ) => { return Promise . resolve ( { data : [ mockLog . body ] } ) ; } ) ; jest . mock ( "s" , ( ) => ( { get : mockGet } ) ) ; import { refreshLogs } from "s" ; import axios from "s" ; import { API } from "s" ; import { SyncResponse } from "s" ; import { fakeLog } from "s" ; import { TaggedLog } from "s" ; import { Actions } from "s" ; const mockLog = fakeLog ( ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const dispatch = jest . fn ( ) ; API . setBaseUrl ( "s" ) ; await refreshLogs ( dispatch ) ; expect ( axios . get ) . toHaveBeenCalled ( ) ; const lastCall < TaggedLog > = dispatch . mock . calls [ 0 ] [ 0 ] ; expect ( lastCall ) . toBeTruthy ( ) ; expect ( lastCall . type ) . toBe ( Actions . RESOURCE_READY ) ; expect ( lastCall . payload . body [ 0 ] . body ) . toEqual ( mockLog . body ) ; } ) ; } ) ;	O $any$ O $any$ O $any$ O O O O O O $PromiseConstructor$ O $complex$ O O $any[]$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $Promise<any>$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $void$ O O O O O $Promise<any>$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $SyncResponse$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $SyncResponse<any>$ O O $any$ O O O $any$ O $SyncResponse<any>$ O $Actions.RESOURCE_READY$ O O $any$ O $any$ O $Actions.RESOURCE_READY$ O O $any$ O $SyncResponse<any>$ O $SyncBodyContents<any>$ O $any[]$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O
jest . mock ( "s" , ( ) => { return { revertToEnglish : jest . fn ( ) } ; } ) ; import { revertToEnglishMiddleware } from "s" ; import { revertToEnglish } from "s" ; import { resourceReady , newTaggedResource } from "s" ; import { WebAppConfig } from "s" ; import { arrayUnwrap } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dispatch = jest . fn ( ( ) => ( { } ) ) ; const data = { 0 : true } as WebAppConfig ; const tr = arrayUnwrap ( newTaggedResource ( "s" , data ) ) ; const action = resourceReady ( "s" , tr ) ; expect ( revertToEnglish ) . not . toHaveBeenCalled ( ) ; revertToEnglishMiddleware . fn ( { } as any ) ( dispatch ) ( action ) ; expect ( revertToEnglish ) . toHaveBeenCalled ( ) ; expect ( revertToEnglishMiddleware . env ) . toBe ( "s" ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $MiddlewareConfig$ O O O O O O $Promise<void>$ O O O O O O $SyncResponse<T>$ O $T[]$ O O O O O O $any$ O O O O O O $T$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O O $boolean$ O O O O $any$ O O $any$ O $T$ O $T[]$ O O O $any$ O O O O $SyncResponse<any>$ O $SyncResponse<T>$ O O O $any$ O O $any$ O $Promise<void>$ O O $any$ O $any$ O O O $MiddlewareConfig$ O $MW$ O O O O O O O $any$ O O $SyncResponse<any>$ O O $any$ O $Promise<void>$ O O $any$ O O O $any$ O $MiddlewareConfig$ O $EnvName$ O O $any$ O O O O O O O O O O
import { configureStore } from "s" ; import { get , set } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const 0 = configureStore ( ) ; const old = get ( process . env , "s" , "s" ) ; set ( process . env , "s" , "s" ) ; const 0 = configureStore ( ) ; set ( process . env , "s" , old ) ; expect ( 0 ) . not . toBe ( 0 ) ; } ) ; it ( "s" , ( ) => { const old = get ( process . env , "s" , "s" ) ; set ( process . env , "s" , "s" ) ; const 0 = configureStore ( ) ; expect ( 0 ) . toEqual ( expect . objectContaining ( { getState : expect . anything ( ) } ) ) ; set ( process . env , "s" , old ) ; } ) ; it ( "s" , ( ) => { sessionStorage . setItem ( "s" , "s" ) ; const 0 = configureStore ( ) . getState ( ) ; expect ( 0 . auth ) . toBe ( null ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O $any$ O O O O O O O $Storage$ O $void$ O O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { unsavedCheck , stopThem , dontStopThem } from "s" ; import { buildResourceIndex } from "s" ; import { SpecialStatus , TaggedWebAppConfig } from "s" ; import { fakeState } from "s" ; import { fakeSequence } from "s" ; import { betterCompact } from "s" ; import { WebAppConfig } from "s" ; describe ( "s" , ( ) => { beforeEach ( ( ) => { localStorage . setItem ( "s" , "s" ) ; } ) ; function setItUp ( dirty < "s" | "s" , boolean > , body : Partial < WebAppConfig > | undefined , ) { const status = ( isDirty ) => isDirty ? SpecialStatus . DIRTY : SpecialStatus . SAVED ; const configStatus = status ( dirty . otherDirty ) ; const sequenceStatus = status ( dirty . seqDirty ) ; const config = { kind : "s" , uuid : "s" , specialStatus : configStatus , body : ( body as any ) } ; const output = fakeState ( ) ; const sequence = fakeSequence ( ) ; const resources = betterCompact ( [ sequence , body ? config : undefined ] ) ; output . resources = buildResourceIndex ( resources ) ; const configUuid = Object . keys ( output . resources . index . all ) . filter ( r => r . includes ( "s" ) ) [ 0 ] ; ( output . resources . index . references [ configUuid ] || { } as any ) . specialStatus = configStatus ; const sequenceUuid = Object . keys ( output . resources . index . all ) . filter ( r => r . includes ( "s" ) ) [ 0 ] ; ( output . resources . index . references [ sequenceUuid ] || { } as any ) . specialStatus = sequenceStatus ; return output ; } it ( "s" , ( ) => { localStorage . removeItem ( "s" ) ; unsavedCheck ( setItUp ( { seqDirty : true , otherDirty : true } , { discard_unsaved : false , discard_unsaved_sequences : false } ) ) ; expect ( window . onbeforeunload ) . toBe ( dontStopThem ) ; } ) ; it ( "s" , ( ) => { unsavedCheck ( setItUp ( { seqDirty : false , otherDirty : false } , { discard_unsaved : false , discard_unsaved_sequences : false } ) ) ; expect ( window . onbeforeunload ) . toBe ( dontStopThem ) ; } ) ; it ( "s" , ( ) => { unsavedCheck ( setItUp ( { seqDirty : true , otherDirty : true } , undefined ) ) ; expect ( window . onbeforeunload ) . toBe ( stopThem ) ; expect ( stopThem ( ) ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { unsavedCheck ( setItUp ( { seqDirty : true , otherDirty : true } , { discard_unsaved : true , discard_unsaved_sequences : false } ) ) ; expect ( window . onbeforeunload ) . toBe ( dontStopThem ) ; } ) ; it ( "s" , ( ) => { unsavedCheck ( setItUp ( { seqDirty : false , otherDirty : true } , { discard_unsaved : false , discard_unsaved_sequences : true } ) ) ; expect ( window . onbeforeunload ) . toBe ( stopThem ) ; } ) ; it ( "s" , ( ) => { unsavedCheck ( setItUp ( { seqDirty : true , otherDirty : true } , { discard_unsaved : false , discard_unsaved_sequences : true } ) ) ; expect ( window . onbeforeunload ) . toBe ( dontStopThem ) ; } ) ; it ( "s" , ( ) => { unsavedCheck ( setItUp ( { seqDirty : true , otherDirty : false } , { discard_unsaved : false , discard_unsaved_sequences : false } ) ) ; expect ( window . onbeforeunload ) . toBe ( stopThem ) ; } ) ; } ) ;	O O $void$ O $string$ O $void$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $Everything$ O O O O O O $any$ O O O O O O $T[]$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O $Storage$ O $void$ O O O O O O O O O O $Everything$ O $Record$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O $boolean$ O O $boolean$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $complex$ O $boolean$ O O O $any$ O $any$ O $complex$ O $boolean$ O O O $TaggedWebAppConfig$ O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O O $any[]$ O $T[]$ O O $any$ O $any$ O $any$ O $undefined$ O O O $Everything$ O $RestResources$ O $any$ O $any[]$ O O O $string$ O $ObjectConstructor$ O $complex$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $complex$ O O $complex$ O $string$ O $string$ O $boolean$ O O O O O O O O O $Everything$ O $RestResources$ O $ResourceIndex$ O $any$ O $string$ O O O O O O O O $any$ O $any$ O O $string$ O $ObjectConstructor$ O $complex$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $complex$ O O $complex$ O $string$ O $string$ O $boolean$ O O O O O O O O O $Everything$ O $RestResources$ O $ResourceIndex$ O $any$ O $string$ O O O O O O O O $any$ O $any$ O O $Everything$ O O $any$ O O O O O O O $Storage$ O $void$ O O O O $void$ O $Everything$ O O $true$ O O O $true$ O O O O O $boolean$ O O O $boolean$ O O O O O O $any$ O $complex$ O $any)$ O O $any$ O $void$ O O O O O $any$ O O O O O O O $void$ O $Everything$ O O $false$ O O O $false$ O O O O O $boolean$ O O O $boolean$ O O O O O O $any$ O $complex$ O $any)$ O O $any$ O $void$ O O O O O $any$ O O O O O O O $void$ O $Everything$ O O $true$ O O O $true$ O O O O $undefined$ O O O $any$ O $complex$ O $any)$ O O $any$ O $string$ O O $any$ O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O $void$ O $Everything$ O O $true$ O O O $true$ O O O O O $boolean$ O O O $boolean$ O O O O O O $any$ O $complex$ O $any)$ O O $any$ O $void$ O O O O O $any$ O O O O O O O $void$ O $Everything$ O O $false$ O O O $true$ O O O O O $boolean$ O O O $boolean$ O O O O O O $any$ O $complex$ O $any)$ O O $any$ O $string$ O O O O O $any$ O O O O O O O $void$ O $Everything$ O O $true$ O O O $true$ O O O O O $boolean$ O O O $boolean$ O O O O O O $any$ O $complex$ O $any)$ O O $any$ O $void$ O O O O O $any$ O O O O O O O $void$ O $Everything$ O O $true$ O O O $false$ O O O O O $boolean$ O O O $boolean$ O O O O O O $any$ O $complex$ O $any)$ O O $any$ O $string$ O O O O O O O O
import { info } from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { jest . resetAllMocks ( ) ; if ( ! globalConfig ) { throw new Error ( "s" ) ; } const old = globalConfig . FBOS_END_OF_LIFE_VERSION ; globalConfig . FBOS_END_OF_LIFE_VERSION = "s" ; const { createReminderFn } = await import ( "s" ) ; const ding = createReminderFn ( ) ; expect ( info ) . toHaveBeenCalledTimes ( 0 ) ; ding ( "s" ) ; expect ( info ) . toHaveBeenCalledTimes ( 0 ) ; ding ( "s" ) ; expect ( info ) . toHaveBeenCalledTimes ( 0 ) ; ding ( "s" ) ; expect ( info ) . toHaveBeenCalledTimes ( 0 ) ; ding ( "s" ) ; expect ( info ) . toHaveBeenCalledTimes ( 0 ) ; ding ( "s" ) ; expect ( info ) . toHaveBeenCalledTimes ( 0 ) ; globalConfig . FBOS_END_OF_LIFE_VERSION = old ; } ) ; } ) ;	O O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $complex$ O O O O $ErrorConstructor$ O O O O O O $string$ O $complex$ O $any$ O $complex$ O $any$ O O O O O $void$ O O O O O O O O O $void$ O $void$ O O O $any$ O $void$ O O $any$ O O O O $void$ O O O O $any$ O $void$ O O $any$ O O O O $void$ O O O O $any$ O $void$ O O $any$ O O O O $void$ O O O O $any$ O $void$ O O $any$ O O O O $void$ O O O O $any$ O $void$ O O $any$ O O O O $void$ O O O O $any$ O $void$ O O $any$ O O O O $complex$ O $any$ O $string$ O O O O O O O
import { fakeState } from "s" ; import { versionChangeMiddleware } from "s" ; import { buildResourceIndex , fakeDevice } from "s" ; import { MiddlewareAPI } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const before = window . Rollbar ; window . Rollbar = { configure : jest . fn ( ) } ; const state = fakeState ( ) ; state . resources = buildResourceIndex ( [ fakeDevice ( ) ] ) ; type Mw = MiddlewareAPI < any > ; const fakeStore < Mw > = { getState : ( ) => state } ; versionChangeMiddleware . fn ( fakeStore as Mw ) ( jest . fn ( ) ) ( { type : "s" , payload : { } } ) ; expect ( window . Rollbar . configure ) . toHaveBeenCalledWith ( { "s" : { "s" : "s" } } ) ; window . Rollbar = before ; } ) ; } ) ;	O O $Everything$ O O O O O O $complex$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Rollbar$ O $complex$ O $Rollbar$ O $complex$ O $Rollbar$ O O $any$ O $any$ O $any$ O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O O O O $any$ O $any$ O O O O O $Partial$ O $any$ O O O $Everything$ O O O O $Everything$ O O $complex$ O $MW$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O ${}$ O O O O O O $any$ O $complex$ O $Rollbar$ O $object$ O O $any$ O O O O O O O O O O O O $complex$ O $Rollbar$ O $Rollbar$ O O O O O O O
import { Regimen } from "s" ; import { edit } from "s" ; import { isTaggedRegimen } from "s" ; import { SelectRegimen } from "s" ; import { Actions } from "s" ; import { TaggedRegimen } from "s" ; export function editRegimen ( r : TaggedRegimen | undefined , update < Regimen > ) { return ( dispatch ) => { r && isTaggedRegimen ( r ) && dispatch ( edit ( r , update ) ) ; } ; } export function selectRegimen ( payload ) { if ( payload . startsWith ( "s" ) ) { return { type : Actions . SELECT_REGIMEN , payload } ; } else { throw new Error ( "s" ) ; } } export const unselectRegimen = ( ) => ( { type : Actions . SELECT_REGIMEN , payload : undefined } ) ;	O O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O O O O O O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O $any$ O $any$ O O O $Partial$ O $any$ O O O O O $Function$ O O O $any$ O $complex$ O $any$ O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O $Partial<Regimen>$ O O O O O O O O $SelectRegimen$ O $string$ O O O O $string$ O $boolean$ O O O O O O O $Actions.SELECT_REGIMEN$ O $any$ O $Actions.SELECT_REGIMEN$ O $string$ O O O O O O O $ErrorConstructor$ O O O O O O O O $complex$ O O O O O O $Actions$ O $any$ O $Actions.SELECT_REGIMEN$ O $undefined$ O $undefined$ O O O
import { editRegimen , selectRegimen , unselectRegimen } from "s" ; import { fakeRegimen } from "s" ; import { Actions } from "s" ; import { SpecialStatus } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; editRegimen ( undefined , { } ) ( dispatch ) ; expect ( dispatch ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const regimen = fakeRegimen ( ) ; regimen . uuid = "s" ; editRegimen ( regimen , { } ) ( dispatch ) ; expect ( dispatch ) . toHaveBeenCalledWith ( { payload : { update : { } , uuid : "s" , specialStatus : SpecialStatus . DIRTY } , type : Actions . EDIT_RESOURCE } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const action = selectRegimen ( "s" ) ; expect ( action ) . toEqual ( { payload : "s" , type : Actions . SELECT_REGIMEN } ) ; } ) ; it ( "s" , ( ) => { console . warn = jest . fn ( ) ; expect ( ( ) => selectRegimen ( "s" ) ) . toThrowError ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( unselectRegimen ( ) ) . toEqual ( { type : Actions . SELECT_REGIMEN , payload : undefined } ) ; } ) ; } ) ;	O O $void$ O $SelectRegimen$ O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $void$ O $undefined$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $void$ O $any$ O O O O O $any$ O O $any$ O $any$ O O $any$ O O $complex$ O O ${}$ O O O O $string$ O O O $any$ O $any$ O $any$ O O $Actions$ O $any$ O $Actions.EDIT_RESOURCE$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $SelectRegimen$ O $SelectRegimen$ O O O O $any$ O $SelectRegimen$ O O $any$ O O $string$ O O O $Actions$ O $any$ O $Actions.SELECT_REGIMEN$ O O O O O O $any$ O O O O O O O $Console$ O $void$ O $any$ O $any$ O O O $any$ O O O O $SelectRegimen$ O O O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $complex$ O O O O $any$ O O $Actions$ O $any$ O $Actions.SELECT_REGIMEN$ O $undefined$ O $undefined$ O O O O O O O O O
import { Week , DAYS } from "s" ; import { Sequence } from "s" ; import { RegimenItem } from "s" ; export function groupRegimenItemsByWeek ( weeks : Week [ ] , OFFSET , seq ) { const ONE_WEEK = 0 ; const ONE_DAY = 0 ; return weeks . map ( ( week ) => DAYS . map ( ( key ) => week . days [ key ] ) ) . map ( ( weekArray , weekNum ) => { const tweeks = ONE_WEEK * ( weekNum ) ; return weekArray . map ( ( shouldExecute , dayNum ) => { const days = ONE_DAY * dayNum ; return ( shouldExecute ) ? ( tweeks + days + OFFSET ) : - 0 ; } ) ; } ) . reduce ( ( arr , acc ) => acc . concat ( arr ) ) . filter ( ( i ) => i !== - 0 ) . sort ( function ( a , b ) { if ( a < b ) { return - 0 ; } return ( a > b ) ? 0 : 0 ; } ) . map < RegimenItem > ( time_offset => { return { time_offset , sequence_id : seq . id || - 0 } ; } ) ; }	O O $any$ O $WeekDay[]$ O O O O O O $any$ O O O O O O $any$ O O O O O O $RegimenItem[]$ O $Week[]$ O $any$ O O O $number$ O $Sequence$ O O O O O O O O O O O O O $Week[]$ O $U[]$ O O $Week$ O O $WeekDay[]$ O $U[]$ O O $WeekDay$ O O $Week$ O $complex$ O $WeekDay$ O O O O $U[]$ O O $boolean[]$ O $number$ O O O O $number$ O O O O $number$ O O O $boolean[]$ O $U[]$ O O $boolean$ O $number$ O O O O $number$ O O O $number$ O O O $boolean$ O O O $number$ O $number$ O $number$ O O O O O O O O O O O $complex$ O O $number[]$ O $number[]$ O O $number[]$ O $complex$ O $number[]$ O O O $complex$ O O $number$ O O $number$ O O O O O $number[]$ O O O $number$ O $number$ O O O O $number$ O $number$ O O O O O O O O O $number$ O $number$ O O O O O O O O O $U[]$ O $any$ O O $number$ O O O O $number$ O $number$ O $Sequence$ O $number$ O O O O O O O O O
import { VariableNameSet , ResourceIndex } from "s" ; import { ParameterApplication , Dictionary , VariableDeclaration , ParameterDeclaration } from "s" ; import { betterCompact } from "s" ; import { isParameterDeclaration } from "s" ; import { determineVector , determineDropdown } from "s" ; import { VariableNode } from "s" ; const createVariableDeclaration = ( parameter ) : VariableDeclaration => ( { kind : "s" , args : { label : parameter . args . label , data_value : parameter . args . default_value } } ) ; const createParameterApplication = ( parameter ) : ParameterApplication => ( { kind : "s" , args : { label : parameter . args . label , data_value : parameter . args . default_value } } ) ; const onlyParameterDeclarations = ( variableData : VariableNameSet | undefined ) => betterCompact ( Object . values ( variableData || { } ) . map ( v => v && isParameterDeclaration ( v . celeryNode ) ? v . celeryNode : undefined ) ) ; export const variableList = ( variableData : VariableNameSet | undefined ) : ParameterApplication [ ] | undefined => { const body = onlyParameterDeclarations ( variableData ) . map ( createParameterApplication ) ; return body . length > 0 ? body : undefined ; } ; export const varDeclarationList = ( variableData : VariableNameSet | undefined ) : VariableDeclaration [ ] | undefined => { const body = onlyParameterDeclarations ( variableData ) . map ( createVariableDeclaration ) ; return body . length > 0 ? body : undefined ; } ; export const addOrEditParamApps = ( variables : ParameterApplication [ ] , updatedItem ) : ParameterApplication [ ] => { const items = reduceVariables ( variables ) ; items [ updatedItem . args . label ] = updatedItem ; return Object . values ( items ) ; } ; export const reduceVariables = < T extends VariableNode > ( variables : T [ ] ) : Dictionary < T > => { const items < T > = { } ; variables . map ( d => items [ d . args . label ] = d ) ; return items ; } ; export const mergeVariables = < T extends VariableNode > ( varData : VariableNameSet | undefined , variables : T [ ] , newVariableKind : "s" | "s" ) : T [ ] => { const newVars = newVariableKind === "s" ? reduceVariables ( varDeclarationList ( varData ) || [ ] ) : reduceVariables ( variableList ( varData ) || [ ] ) ; const bodyVars = reduceVariables < T > ( variables ) ; Object . entries ( newVars ) . filter ( ( [ k , _ ] ) => ! Object . keys ( bodyVars ) . includes ( k ) ) . map ( ( [ k , v ] ) => bodyVars [ k ] = v ) ; return Object . values ( bodyVars ) ; } ; export const mergeParameterApplications = ( varData : VariableNameSet | undefined , bodyVariables : ParameterApplication [ ] ) : ParameterApplication [ ] => { return mergeVariables ( varData , bodyVariables , "s" ) ; } ; export const mergeDeclarations = ( varData : VariableNameSet | undefined , bodyVariables : VariableNode [ ] ) : VariableNode [ ] => { return mergeVariables ( varData , bodyVariables , "s" ) ; } ; export const getRegimenVariableData = ( bodyVariables : VariableNode [ ] , resources ) : VariableNameSet => { const varData = { } ; bodyVariables . map ( variable => { varData [ variable . args . label ] = { celeryNode : variable , vector : determineVector ( variable , resources ) , dropdown : determineDropdown ( variable , resources ) , } ; } ) ; return varData ; } ;	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $T[]$ O O O O O O $any$ O O O O O O $any$ O $DropDownItem$ O O O O O O $any$ O O O O O $any$ O O $ParameterDeclaration$ O O $any$ O O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $ParameterDeclaration$ O O $any$ O O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any[]$ O O $complex$ O $any$ O O O O $T[]$ O $ObjectConstructor$ O $complex$ O $complex$ O O O O O $U[]$ O $SequenceMeta$ O $SequenceMeta$ O $any$ O $SequenceMeta$ O $any$ O O $SequenceMeta$ O $any$ O $undefined$ O O O O O $any[]$ O O $complex$ O $any$ O O O O $any$ O O O O O O O $any[]$ O $any[]$ O $complex$ O O $U[]$ O $any$ O O O $any[]$ O $number$ O O O $any[]$ O $undefined$ O O O O O $any[]$ O O $complex$ O $any$ O O O O $any$ O O O O O O O $any[]$ O $any[]$ O $complex$ O O $U[]$ O $any$ O O O $any[]$ O $number$ O O O $any[]$ O $undefined$ O O O O O $any[]$ O O $any[]$ O $any$ O O O $ParameterApplication$ O O $any$ O O O O O $any$ O $any$ O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $ObjectConstructor$ O $complex$ O $any$ O O O O O O $any$ O O $any$ O $any$ O O $T[]$ O $any$ O O O O $any$ O $any$ O O O O $Dictionary$ O $any$ O O O O O $T[]$ O $U[]$ O $T$ O $any$ O $T$ O $any$ O $any$ O O $T$ O O O $any$ O O O O O $T[]$ O O $any$ O $any$ O O $complex$ O $any$ O O O $T[]$ O $any$ O O O O O O O O O O $any$ O O O O O $any$ O O O O O $any$ O $any[]$ O $complex$ O O O O O O $any$ O $any[]$ O $complex$ O O O O O O O $any$ O $any$ O $any$ O O $T[]$ O O $ObjectConstructor$ O $complex$ O $any$ O O $complex$ O O O $string$ O $unknown$ O O O O $ObjectConstructor$ O $complex$ O $any$ O O $boolean$ O $string$ O O O $U[]$ O O O $string$ O $unknown$ O O O $any$ O $string$ O O $unknown$ O O O $ObjectConstructor$ O $complex$ O $any$ O O O O O O $any[]$ O O $complex$ O $any$ O O O $any[]$ O $any$ O O O O $any$ O O O O O $T[]$ O $complex$ O $any[]$ O O O O O O O O $any[]$ O O $complex$ O $any$ O O O $any[]$ O $any$ O O O O $any$ O O O O O $T[]$ O $complex$ O $any[]$ O O O O O O O O $complex$ O O $any[]$ O $any$ O O O $ResourceIndex$ O O $any$ O O O $VariableNameSet$ O O O O $any[]$ O $U[]$ O $any$ O O $complex$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $ResourceIndex$ O O $DropDownItem$ O $DropDownItem$ O $any$ O $ResourceIndex$ O O O O O O O O $complex$ O O O
import { isNaN , isNumber } from "s" ; import { error , warning , success } from "s" ; import { ReduxAction , Thunk } from "s" ; import { ToggleDayParams } from "s" ; import { findSequence , findRegimen } from "s" ; import { groupRegimenItemsByWeek } from "s" ; import { defensiveClone } from "s" ; import { overwrite } from "s" ; import { Actions } from "s" ; import { assertUuid } from "s" ; import { mergeDeclarations } from "s" ; import { t } from "s" ; export function pushWeek ( ) { return { type : Actions . PUSH_WEEK , payload : undefined } ; } export function popWeek ( ) { return { type : Actions . POP_WEEK , payload : undefined } ; } export function deselectDays ( ) { return { type : Actions . DESELECT_ALL_DAYS , payload : undefined } ; } export function selectDays ( ) { return { type : Actions . SELECT_ALL_DAYS , payload : undefined } ; } export function setTimeOffset ( ms ) { if ( isNaN ( ms ) || ! isNumber ( ms ) ) { warning ( t ( "s" ) , t ( "s" ) ) ; throw new Error ( "s" + JSON . stringify ( ms ) ) ; } else { return { type : Actions . SET_TIME_OFFSET , payload : ms } ; } } export function toggleDay ( { week , day } ) { return { type : Actions . TOGGLE_DAY , payload : { week , day } } ; } export function setSequence ( uuid : string | "s" ) < string > { if ( uuid ) { assertUuid ( "s" , uuid ) ; } return { type : Actions . SET_SEQUENCE , payload : uuid } ; } export function commitBulkEditor ( ) { return function ( dispatch , getState ) { const resources = getState ( ) . resources ; const { weeks , dailyOffsetMs , selectedSequenceUUID , currentRegimen } = resources . consumers . regimens ; if ( currentRegimen ) { if ( selectedSequenceUUID ) { const sequence = findSequence ( resources . index , selectedSequenceUUID ) . body ; const groupedItems = weeks . length > 0 ? groupRegimenItemsByWeek ( weeks , dailyOffsetMs , sequence ) : undefined ; if ( groupedItems && groupedItems . length > 0 ) { const regimen = findRegimen ( resources . index , currentRegimen ) ; const clonedRegimen = defensiveClone ( regimen ) . body ; clonedRegimen . regimen_items = clonedRegimen . regimen_items . concat ( groupedItems ) ; const varData = resources . index . sequenceMetas [ selectedSequenceUUID ] ; clonedRegimen . body = mergeDeclarations ( varData , regimen . body . body ) ; console . log ( JSON . stringify ( clonedRegimen . body , undefined , 0 ) ) ; dispatch ( overwrite ( regimen , clonedRegimen ) ) ; success ( t ( "s" ) ) ; } else { return error ( t ( "s" ) ) ; } } else { return error ( t ( "s" ) ) ; } } else { return error ( t ( "s" ) ) ; } } ; }	O O $any$ O $any$ O O O O O O $void$ O $void$ O $void$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $RegimenItem[]$ O O O O O O $T$ O O O O O O $ReduxAction<EditResourceParams>$ O O O O O O $any$ O O O O O O $boolean$ O O O O O O $any[]$ O O O O O O $any$ O O O O O O $complex$ O O O O O $Actions$ O $any$ O $Actions.PUSH_WEEK$ O $undefined$ O $undefined$ O O O O O $complex$ O O O O O $Actions$ O $any$ O $Actions.POP_WEEK$ O $undefined$ O $undefined$ O O O O O $complex$ O O O O O $Actions$ O $any$ O $Actions.DESELECT_ALL_DAYS$ O $undefined$ O $undefined$ O O O O O $complex$ O O O O O $Actions$ O $any$ O $Actions.SELECT_ALL_DAYS$ O $undefined$ O $undefined$ O O O O O $complex$ O $number$ O O O O $any$ O $number$ O O O $any$ O $number$ O O O $void$ O $any$ O O O O $any$ O O O O O O O $ErrorConstructor$ O O O $JSON$ O $complex$ O $number$ O O O O O O O O $Actions$ O $any$ O $Actions.SET_TIME_OFFSET$ O $number$ O $number$ O O O O O O $complex$ O O $number$ O $number$ $ToggleDayParams$ O O O O $Actions$ O $any$ O $Actions.TOGGLE_DAY$ O $complex$ O O $number$ O $number$ O O O O O O $ReduxAction$ O $string$ O O O O O O O O O O O $string$ O O $boolean$ O O O $string$ O O O O O $Actions.SET_SEQUENCE$ O $any$ O $Actions.SET_SEQUENCE$ O $string$ O $string$ O O O O O $Thunk$ O O O O O O $Function$ O $GetState$ O O O $RestResources$ O $GetState$ O O O $RestResources$ O O O $Week[]$ O $number$ O $string$ O $string$ O O $RestResources$ O $complex$ O $RegimenState$ O O O $string$ O O O O $string$ O O O $any$ O $any$ O $RestResources$ O $ResourceIndex$ O $string$ O O $any$ O O $RegimenItem[]$ O $Week[]$ O $number$ O O O $RegimenItem[]$ O $Week[]$ O $number$ O $any$ O O $undefined$ O O O $RegimenItem[]$ O $RegimenItem[]$ O $number$ O O O O O $any$ O $any$ O $RestResources$ O $ResourceIndex$ O $string$ O O O $any$ O $T$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $RegimenItem[]$ O O O $complex$ O $RestResources$ O $ResourceIndex$ O $complex$ O $string$ O O $any$ O $any$ O $any[]$ O $complex$ O $any$ O $any$ O $any$ O O $Console$ O $void$ O $JSON$ O $complex$ O $any$ O $any$ O $undefined$ O O O O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O $any$ O O O $void$ O $any$ O O O O O O O O O $void$ O $any$ O O O O O O O O O O $void$ O $any$ O O O O O O O O O O $void$ O $any$ O O O O O O O O O
import { regimensReducer , RegimenState } from "s" ; import { Actions } from "s" ; import { popWeek , pushWeek , selectDays , deselectDays } from "s" ; import { defensiveClone } from "s" ; const STATE = { dailyOffsetMs : 0 , selectedSequenceUUID : "s" , currentRegimen : "s" , weeks : [ { "s" : { "s" : true , "s" : true , "s" : true , "s" : true , "s" : true , "s" : true , "s" : false } } ] , schedulerOpen : false , } ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const ACTION = { type : Actions . TOGGLE_DAY , payload : { week : 0 , day : 0 } } ; const nextState = regimensReducer ( STATE , ACTION ) ; expect ( nextState . weeks [ 0 ] . days [ "s" ] ) . toBeFalsy ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const nextState = regimensReducer ( STATE , selectDays ( ) ) ; expect ( nextState . weeks [ 0 ] . days [ "s" ] ) . toBeTruthy ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const nextState = regimensReducer ( STATE , deselectDays ( ) ) ; expect ( nextState . weeks [ 0 ] . days [ "s" ] ) . toBeFalsy ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const nextState = regimensReducer ( STATE , pushWeek ( ) ) ; expect ( nextState . weeks . length ) . toEqual ( 0 ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const nextState = regimensReducer ( STATE , popWeek ( ) ) ; expect ( nextState . weeks . length ) . toEqual ( 0 ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const uuid = STATE . selectedSequenceUUID ; if ( uuid ) { const action = { type : Actions . DESTROY_RESOURCE_OK , payload : { uuid } } ; const nextState = regimensReducer ( STATE , action ) ; expect ( nextState . selectedSequenceUUID ) . toBe ( undefined ) ; } else { fail ( ) ; } } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = defensiveClone ( STATE ) ; state . currentRegimen = undefined ; const action = { type : Actions . INIT_RESOURCE , payload : { uuid : "s" , kind : "s" } } ; const nextState = regimensReducer ( STATE , action ) ; expect ( nextState . currentRegimen ) . toBe ( action . payload . uuid ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = defensiveClone ( STATE ) ; state . currentRegimen = undefined ; const action = { type : Actions . SELECT_REGIMEN , payload : "s" } ; const nextState = regimensReducer ( STATE , action ) ; expect ( nextState . currentRegimen ) . toBe ( action . payload ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = defensiveClone ( STATE ) ; state . selectedSequenceUUID = undefined ; const action = { type : Actions . SET_SEQUENCE , payload : "s" } ; const nextState = regimensReducer ( STATE , action ) ; expect ( nextState . selectedSequenceUUID ) . toBe ( action . payload ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = defensiveClone ( STATE ) ; state . dailyOffsetMs = NaN ; const action = { type : Actions . SET_TIME_OFFSET , payload : 0 } ; const nextState = regimensReducer ( STATE , action ) ; expect ( nextState . dailyOffsetMs ) . toBe ( action . payload ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = defensiveClone ( STATE ) ; state . schedulerOpen = false ; const action = { type : Actions . SET_SCHEDULER_STATE , payload : true } ; const nextState = regimensReducer ( STATE , action ) ; expect ( nextState . schedulerOpen ) . toBe ( action . payload ) ; } ) ; } ) ;	O O $generateReducer<RegimenState>.GeneratedReducer$ O $any$ O O O O O O $any$ O O O O O O $complex$ O $complex$ O $complex$ O $complex$ O O O O O O $T$ O O O O O $RegimenState$ O O $number$ O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $false$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $Actions$ O $any$ O $Actions.TOGGLE_DAY$ O $complex$ O O $number$ O O O $number$ O O O O O O $RegimenState$ O $generateReducer<RegimenState>.GeneratedReducer$ O $RegimenState$ O $complex$ O O $any$ O $RegimenState$ O $Week[]$ O O O O $complex$ O O O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $RegimenState$ O $generateReducer<RegimenState>.GeneratedReducer$ O $RegimenState$ O $complex$ O O O O $any$ O $RegimenState$ O $Week[]$ O O O O $complex$ O O O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $RegimenState$ O $generateReducer<RegimenState>.GeneratedReducer$ O $RegimenState$ O $complex$ O O O O $any$ O $RegimenState$ O $Week[]$ O O O O $complex$ O O O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $RegimenState$ O $generateReducer<RegimenState>.GeneratedReducer$ O $RegimenState$ O $complex$ O O O O $any$ O $RegimenState$ O $Week[]$ O $number$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $RegimenState$ O $generateReducer<RegimenState>.GeneratedReducer$ O $RegimenState$ O $complex$ O O O O $any$ O $RegimenState$ O $Week[]$ O $number$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $string$ O $RegimenState$ O $string$ O O O $string$ O O O $complex$ O O $Actions$ O $any$ O $Actions.DESTROY_RESOURCE_OK$ O $complex$ O O $string$ O O O O $RegimenState$ O $generateReducer<RegimenState>.GeneratedReducer$ O $RegimenState$ O $complex$ O O $any$ O $RegimenState$ O $string$ O O $any$ O $undefined$ O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $RegimenState$ O $T$ O $RegimenState$ O O $RegimenState$ O $string$ O $undefined$ O O $complex$ O O $Actions$ O $any$ O $Actions.INIT_RESOURCE$ O $complex$ O O $string$ O O O $string$ O O O O O O $RegimenState$ O $generateReducer<RegimenState>.GeneratedReducer$ O $RegimenState$ O $complex$ O O $any$ O $RegimenState$ O $string$ O O $any$ O $complex$ O $complex$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $RegimenState$ O $T$ O $RegimenState$ O O $RegimenState$ O $string$ O $undefined$ O O $complex$ O O $Actions$ O $any$ O $Actions.SELECT_REGIMEN$ O $string$ O O O O O $RegimenState$ O $generateReducer<RegimenState>.GeneratedReducer$ O $RegimenState$ O $complex$ O O $any$ O $RegimenState$ O $string$ O O $any$ O $complex$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $RegimenState$ O $T$ O $RegimenState$ O O $RegimenState$ O $string$ O $undefined$ O O $complex$ O O $Actions$ O $any$ O $Actions.SET_SEQUENCE$ O $string$ O O O O O $RegimenState$ O $generateReducer<RegimenState>.GeneratedReducer$ O $RegimenState$ O $complex$ O O $any$ O $RegimenState$ O $string$ O O $any$ O $complex$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $RegimenState$ O $T$ O $RegimenState$ O O $RegimenState$ O $number$ O $number$ O O $complex$ O O $Actions$ O $any$ O $Actions.SET_TIME_OFFSET$ O $number$ O O O O O $RegimenState$ O $generateReducer<RegimenState>.GeneratedReducer$ O $RegimenState$ O $complex$ O O $any$ O $RegimenState$ O $number$ O O $any$ O $complex$ O $number$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $RegimenState$ O $T$ O $RegimenState$ O O $RegimenState$ O $boolean$ O O O O $complex$ O O $Actions$ O $any$ O $Actions.SET_SCHEDULER_STATE$ O $boolean$ O O O O O $RegimenState$ O $generateReducer<RegimenState>.GeneratedReducer$ O $RegimenState$ O $complex$ O O $any$ O $RegimenState$ O $boolean$ O O $any$ O $complex$ O $boolean$ O O O O O O O O
import { selectAllRegimens } from "s" ; import { store } from "s" ; import { urlFriendly , lastUrlChunk } from "s" ; import { selectRegimen } from "s" ; const setRegimen = ( uuid ) => store . dispatch ( selectRegimen ( uuid ) ) ; export function setActiveRegimenByName ( ) { if ( lastUrlChunk ( ) == "s" ) { return ; } selectAllRegimens ( store . getState ( ) . resources . index ) . map ( reg => { const name = urlFriendly ( reg . body . name ) ; ( lastUrlChunk ( ) === name ) && setRegimen ( reg . uuid ) ; } ) ; }	O O $any[]$ O O O O O O $any$ O O O O O O $string$ O $string$ O O O O O O $SelectRegimen$ O O O O O $any$ O O $string$ O O $any$ O $any$ O $SelectRegimen$ O $string$ O O O O O $void$ O O O O O $string$ O O O O O O O O O $any[]$ O $any$ O $any$ O O O $any$ O $any$ O O $U[]$ O $any$ O O O $string$ O $string$ O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O O $any$ O $any$ O $any$ O O O O O O
import { fakeRegimen } from "s" ; const mockData = { lastUrlChunk : "s" , fakeRegimens : [ fakeRegimen ( ) ] } ; jest . mock ( "s" , ( ) => { return { urlFriendly : jest . fn ( x => x ) , lastUrlChunk : jest . fn ( ( ) => mockData . lastUrlChunk ) } ; } ) ; jest . mock ( "s" , ( ) => ( { selectRegimen : jest . fn ( ) } ) ) ; jest . mock ( "s" , ( ) => { return { selectAllRegimens : jest . fn ( ( ) => { return mockData . fakeRegimens || [ ] ; } ) } ; } ) ; jest . mock ( "s" , ( ) => { return { store : { dispatch : jest . fn ( ) , getState : jest . fn ( ( ) => ( { resources : { index : { } } } ) ) } } ; } ) ; import { setActiveRegimenByName } from "s" ; import { selectRegimen } from "s" ; import { selectAllRegimens } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { mockData . lastUrlChunk = "s" ; setActiveRegimenByName ( ) ; expect ( selectRegimen ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const body = mockData . fakeRegimens [ 0 ] . body ; const name = "s" + body . name ; mockData . lastUrlChunk = name ; setActiveRegimenByName ( ) ; expect ( selectAllRegimens ) . toHaveBeenCalled ( ) ; expect ( selectRegimen ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const tr = mockData . fakeRegimens [ 0 ] ; const body = tr . body ; jest . clearAllTimers ( ) ; mockData . lastUrlChunk = body . name ; setActiveRegimenByName ( ) ; expect ( selectRegimen ) . toHaveBeenCalledWith ( tr . uuid ) ; } ) ; } ) ;	O O $any$ O O O O O $complex$ O O $string$ O O O $any[]$ O O $any$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $complex$ O $string$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $complex$ O $any[]$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $complex$ O O ${}$ O O O O O O O O O O O O O O O $void$ O O O O O O $SelectRegimen$ O O O O O O $any[]$ O O O O $any$ O O O O O O O $any$ O O O O O O O $complex$ O $string$ O O O $void$ O O O $any$ O $SelectRegimen$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $complex$ O $any[]$ O O O O $any$ O O $string$ O O O $any$ O $any$ O $complex$ O $string$ O $string$ O $void$ O O O $any$ O $any[]$ O O $any$ O O O $any$ O $SelectRegimen$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $complex$ O $any[]$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O $string$ O $any$ O $any$ O $void$ O O O $any$ O $SelectRegimen$ O O $any$ O $any$ O $any$ O O O O O O O O
import { Everything , TimeSettings } from "s" ; import { Props , RegimenItem , RegimenItemCalendarRow , CalendarRow } from "s" ; import { selectAllSequences , selectAllRegimens , maybeGetSequence , maybeGetRegimen , findId , findSequence , maybeGetDevice , findSequenceById , maybeGetTimeSettings } from "s" ; import { TaggedRegimen , TaggedSequence } from "s" ; import moment from "s" ; import { ResourceIndex , UUID , VariableNameSet } from "s" ; import { randomColor , determineInstalledOsVersion , createShouldDisplayFn as shouldDisplayFunc , timeFormatString } from "s" ; import { resourceUsageList } from "s" ; import { groupBy , chain , sortBy } from "s" ; import { DevSettings } from "s" ; export function mapStateToProps ( props ) { const { resources , dispatch , bot } = props ; const { weeks , dailyOffsetMs , selectedSequenceUUID , currentRegimen , schedulerOpen } = resources . consumers . regimens ; const { index } = resources ; const current = maybeGetRegimen ( index , currentRegimen ) ; const timeSettings = maybeGetTimeSettings ( props . resources . index ) ; const calendar = current ? generateCalendar ( current , index , dispatch , timeSettings ) : [ ] ; const installedOsVersion = determineInstalledOsVersion ( props . bot , maybeGetDevice ( props . resources . index ) ) ; const fbosVersionOverride = DevSettings . overriddenFbosVersion ( ) ; const shouldDisplay = shouldDisplayFunc ( installedOsVersion , props . bot . minOsFeatureData , fbosVersionOverride ) ; const calledSequences = ( ) : UUID [ ] => { if ( current ) { const sequenceIds = current . body . regimen_items . map ( x => x . sequence_id ) ; return Array . from ( new Set ( sequenceIds ) ) . map ( x => findSequenceById ( props . resources . index , x ) . uuid ) ; } return [ ] ; } ; const variableData = { } ; calledSequences ( ) . map ( uuid => Object . entries ( props . resources . index . sequenceMetas [ uuid ] || { } ) . map ( ( [ key , value ] ) => ! variableData [ key ] && ( variableData [ key ] = value ) ) ) ; return { dispatch : props . dispatch , sequences : selectAllSequences ( index ) , variableData , resources : index , auth : props . auth , current , regimens : selectAllRegimens ( index ) , selectedSequence : maybeGetSequence ( index , selectedSequenceUUID ) , dailyOffsetMs , weeks , bot , calendar , regimenUsageStats : resourceUsageList ( props . resources . index . inUse ) , shouldDisplay , schedulerOpen , } ; } const SORT_KEY : keyof RegimenItemCalendarRow = "s" ; function generateCalendar ( regimen , index , dispatch , timeSettings ) : CalendarRow [ ] { const mapper = createRows ( index , dispatch , regimen , timeSettings ) ; const rows = regimen . body . regimen_items . map ( mapper ) ; const dict = groupBy ( rows , "s" ) ; const makeRows = ( day ) : CalendarRow => ( { day : day , items : dict [ day ] } ) ; const days = chain ( dict ) . keys ( ) . map ( x => parseInt ( x ) ) . sort ( ( a , b ) => a - b ) . map ( x => "s" + x ) . value ( ) ; return days . map ( makeRows ) . map ( ( x ) => { x . items = sortBy ( x . items , SORT_KEY ) ; return x ; } ) ; } const createRows = ( index , dispatch , regimen , timeSettings ) => ( item ) : RegimenItemCalendarRow => { const uuid = findId ( index , "s" , item . sequence_id ) ; const sequence = findSequence ( index , uuid ) ; const variable = getParameterLabel ( sequence ) ; const { time_offset } = item ; const d = moment . duration ( time_offset ) ; const { name } = sequence . body ; const color = sequence . body . color || randomColor ( ) ; const FORMAT = timeFormatString ( timeSettings ) ; const hhmm = moment ( { hour : d . hours ( ) , minute : d . minutes ( ) } ) . format ( FORMAT ) ; const day = Math . floor ( moment . duration ( time_offset ) . asDays ( ) ) + 0 ; return { name , hhmm , color , day , dispatch , regimen , item , variable , sortKey : time_offset } ; } ; const getParameterLabel = ( sequence ) : string | undefined => ( sequence . body . args . locals . body || [ ] ) . filter ( variable => variable . kind === "s" ) . map ( variable => variable . args . label ) [ 0 ] ;	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any[]$ O $any[]$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $TimeSettings$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $string$ O $boolean$ O $boolean$ O $string$ O O O O O O $complex$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $Props$ O $Everything$ O O O O $RestResources$ O $Function$ O $BotState$ O O $Everything$ O O O $Week[]$ O $number$ O $string$ O $string$ O $boolean$ O O $RestResources$ O $complex$ O $RegimenState$ O O O $ResourceIndex$ O O $RestResources$ O O $any$ O $any$ O $ResourceIndex$ O $string$ O O O $TimeSettings$ O $TimeSettings$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $CalendarRow[]$ O $any$ O $CalendarRow[]$ O $any$ O $ResourceIndex$ O $Function$ O $TimeSettings$ O O O O O O $string$ O $string$ O $Everything$ O $BotState$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $string$ O $any$ O $string$ O O O O $boolean$ O $boolean$ O $string$ O $Everything$ O $BotState$ O $complex$ O $string$ O O O $string[]$ O O O O $any$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $ArrayConstructor$ O $complex$ O O $SetConstructor$ O $any$ O O O $U[]$ O $unknown$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $unknown$ O O $any$ O O O O O O O O O O $VariableNameSet$ O O O O $string[]$ O O O $U[]$ O $string$ O $ObjectConstructor$ O $complex$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $complex$ O $string$ O O O O O O $U[]$ O O O $string$ O $SequenceMeta$ O O O O $complex$ O $string$ O O O $complex$ O $string$ O O $SequenceMeta$ O O O O O O $Function$ O $Everything$ O $Function$ O $any[]$ O $any[]$ O $ResourceIndex$ O O $complex$ O $ResourceIndex$ O $ResourceIndex$ O $AuthState$ O $Everything$ O $AuthState$ O $any$ O $any[]$ O $any[]$ O $ResourceIndex$ O O $any$ O $any$ O $ResourceIndex$ O $string$ O O $number$ O $Week[]$ O $BotState$ O $CalendarRow[]$ O $complex$ O $complex$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $complex$ O O $boolean$ O $boolean$ O O O O O O O O $any$ O O O O $CalendarRow[]$ O $TaggedRegimen$ O $ResourceIndex$ O $Function$ O $TimeSettings$ O O $any$ O O O O $RegimenItemCalendarRow$ O $RegimenItemCalendarRow$ O $ResourceIndex$ O $Function$ O $any$ O $TimeSettings$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $RegimenItemCalendarRow$ O O O $any$ O $any$ O $any$ O O O O O $CalendarRow$ O O $string$ O O $any$ O O O $string$ O $string$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $number$ O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O O O O $any$ O $any$ O $CalendarRow$ O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O $RegimenItemCalendarRow$ O O $ResourceIndex$ O $Function$ O $TaggedRegimen$ O $TimeSettings$ O O O $RegimenItem$ O O $any$ O O O $any$ O $any$ O $ResourceIndex$ O O O $RegimenItem$ O $number$ O O O $any$ O $any$ O $ResourceIndex$ O $any$ O O O $string$ O $string$ O $any$ O O O O $number$ O O $RegimenItem$ O O $any$ O $any$ O $any$ O $number$ O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $string$ O $TimeSettings$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $string$ O O O $number$ O $Math$ O $number$ O $any$ O $any$ O $number$ O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $number$ O $Function$ O $any$ O $RegimenItem$ O $string$ O $number$ O $number$ O O O O O $string$ O O $TaggedSequence$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O
import { mapStateToProps } from "s" ; import { fakeState } from "s" ; import { TaggedResource } from "s" ; import { buildResourceIndex } from "s" ; import { newTaggedResource } from "s" ; import { selectAllRegimens } from "s" ; import { fakeVariableNameSet } from "s" ; import { fakeRegimen , fakeSequence } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const props = mapStateToProps ( fakeState ( ) ) ; expect ( props . current ) . toEqual ( undefined ) ; expect ( props . calendar ) . toEqual ( [ ] ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; const fakeResources : TaggedResource [ ] = [ ... newTaggedResource ( "s" , { id : 0 , name : "s" , color : "s" , regimen_items : [ { id : 0 , regimen_id : 0 , sequence_id : 0 , time_offset : 0 } ] } ) , ... newTaggedResource ( "s" , { id : 0 , name : "s" , color : "s" , body : [ { kind : "s" , args : { milliseconds : 0 } } ] , args : { "s" : 0 , "s" : { "s" : "s" , "s" : { } } , } , kind : "s" } ) ] ; const { index } = buildResourceIndex ( fakeResources ) ; state . resources . index = index ; const { uuid } = selectAllRegimens ( index ) [ 0 ] ; state . resources . consumers . regimens . currentRegimen = uuid ; const props = mapStateToProps ( state ) ; props . current ? expect ( props . current . uuid ) . toEqual ( uuid ) : fail ; expect ( props . calendar [ 0 ] . items [ 0 ] . item . time_offset ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { const reg = fakeRegimen ( ) ; const seq = fakeSequence ( ) ; reg . body . regimen_items = [ { sequence_id : seq . body . id || 0 , time_offset : 0 } ] ; const state = fakeState ( ) ; state . resources = buildResourceIndex ( [ reg , seq ] ) ; state . resources . consumers . regimens . currentRegimen = reg . uuid ; const varData = fakeVariableNameSet ( ) ; state . resources . index . sequenceMetas [ seq . uuid ] = varData ; const props = mapStateToProps ( state ) ; expect ( props . variableData ) . toEqual ( varData ) ; } ) ; it ( "s" , ( ) => { const reg = fakeRegimen ( ) ; const seq = fakeSequence ( ) ; seq . body . body = [ { kind : "s" , args : { location : { kind : "s" , args : { label : "s" } } , offset : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } , speed : 0 , } } ] ; seq . body . args . locals . body = [ { kind : "s" , args : { label : "s" , default_value : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } } } ] ; reg . body . regimen_items = [ { sequence_id : seq . body . id || 0 , time_offset : 0 } ] ; const state = fakeState ( ) ; state . resources = buildResourceIndex ( [ reg , seq ] ) ; state . resources . consumers . regimens . currentRegimen = reg . uuid ; const props = mapStateToProps ( state ) ; expect ( props . calendar ) . toEqual ( [ { day : "s" , items : [ expect . objectContaining ( { item : reg . body . regimen_items [ 0 ] , sortKey : 0 , variable : "s" } ) ] } ] ) ; } ) ; } ) ;	O O $Props$ O O O O O O $Everything$ O O O O O O $any$ O O O O O O $any$ O O O O O O $T[]$ O O O O O O $any[]$ O O O O O O $complex$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Props$ O $Props$ O $Everything$ O O O O $any$ O $Props$ O $any$ O O $any$ O $undefined$ O O $any$ O $Props$ O $CalendarRow[]$ O O $any$ O O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any[]$ O $any$ O O O O O $T[]$ O O O O $number$ O O O $string$ O O O $string$ O O O $complex$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O O O O $T[]$ O O O O $number$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $complex$ O O $number$ O O O O O O $complex$ O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O $any$ O O $any$ O $any[]$ O O $Everything$ O $RestResources$ O $ResourceIndex$ O $any$ O O O $any$ O O $any[]$ O $any$ O O O O O $Everything$ O $RestResources$ O $complex$ O $RegimenState$ O $string$ O $any$ O O $Props$ O $Props$ O $Everything$ O O $Props$ O $any$ O $any$ O $Props$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $Props$ O $CalendarRow[]$ O O O O $RegimenItemCalendarRow[]$ O O O O $RegimenItem$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $number$ O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O $any$ O O O $Everything$ O $RestResources$ O $complex$ O $RegimenState$ O $string$ O $any$ O $any$ O O $complex$ O $complex$ O O O $Everything$ O $RestResources$ O $ResourceIndex$ O $complex$ O $any$ O $any$ O O $complex$ O O $Props$ O $Props$ O $Everything$ O O $any$ O $Props$ O $complex$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O $number$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $number$ O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O $any$ O O O $Everything$ O $RestResources$ O $complex$ O $RegimenState$ O $string$ O $any$ O $any$ O O $Props$ O $Props$ O $Everything$ O O $any$ O $Props$ O $CalendarRow[]$ O O $any$ O O O $string$ O O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $number$ O O O $string$ O O O O O O O O O O O O O O O
jest . mock ( "s" , ( ) => ( { t : ( i ) => i } ) ) ; jest . mock ( "s" , ( ) => ( { overwrite : jest . fn ( ) } ) ) ; import { commitBulkEditor , setTimeOffset , toggleDay , setSequence } from "s" ; import { fakeState } from "s" ; import { buildResourceIndex } from "s" ; import { TaggedResource , TaggedSequence , TaggedRegimen , Coordinate } from "s" ; import { Actions } from "s" ; import { Everything } from "s" ; import { ToggleDayParams } from "s" ; import { newTaggedResource } from "s" ; import { arrayUnwrap } from "s" ; import { overwrite } from "s" ; import { fakeVariableNameSet } from "s" ; import { error , warning } from "s" ; const sequence_id = 0 ; const regimen_id = 0 ; describe ( "s" , ( ) => { function newFakeState ( ) { const state = fakeState ( ) ; const regBody : TaggedRegimen [ "s" ] = { id : regimen_id , name : "s" , color : "s" , regimen_items : [ { regimen_id , sequence_id , time_offset : 0 } ] , body : [ ] , } ; const reg = newTaggedResource ( "s" , regBody ) [ 0 ] ; const seqBody : TaggedSequence [ "s" ] = { id : sequence_id , name : "s" , color : "s" , body : [ { kind : "s" , args : { milliseconds : 0 } } ] , args : { "s" : { kind : "s" , args : { } } , "s" : 0 } , kind : "s" } ; const seq = arrayUnwrap ( newTaggedResource ( "s" , seqBody ) ) ; const regimenUuid = reg . uuid ; const sequenceUuid = seq . uuid ; const fakeResources : TaggedResource [ ] = [ reg , seq ] ; state . resources . index = buildResourceIndex ( fakeResources ) . index ; state . resources . consumers . regimens . currentRegimen = regimenUuid ; state . resources . consumers . regimens . selectedSequenceUUID = sequenceUuid ; state . resources . consumers . regimens . dailyOffsetMs = 0 ; state . resources . consumers . regimens . weeks = [ { days : { 0 : true , 0 : false , 0 : false , 0 : false , 0 : false , 0 : false , 0 : false } } ] ; return state ; } function returnsError ( state , message , title ? ) { const getState = ( ) => state ; const dispatch = jest . fn ( ) ; commitBulkEditor ( ) ( dispatch , getState ) ; expect ( dispatch ) . not . toHaveBeenCalled ( ) ; if ( title ) { expect ( error ) . toBeCalledWith ( message , title ) ; } else { expect ( error ) . toBeCalledWith ( message ) ; } } it ( "s" , ( ) => { const state = newFakeState ( ) ; state . resources . consumers . regimens . currentRegimen = undefined ; returnsError ( state , "s" ) ; } ) ; it ( "s" , ( ) => { const state = newFakeState ( ) ; state . resources . consumers . regimens . selectedSequenceUUID = undefined ; returnsError ( state , "s" ) ; } ) ; it ( "s" , ( ) => { const state = newFakeState ( ) ; state . resources . consumers . regimens . weeks [ 0 ] . days . 0 = false ; returnsError ( state , "s" ) ; } ) ; it ( "s" , ( ) => { const state = newFakeState ( ) ; state . resources . consumers . regimens . weeks = [ ] ; returnsError ( state , "s" ) ; } ) ; it ( "s" , ( ) => { console . log = jest . fn ( ) ; const state = newFakeState ( ) ; const getState = ( ) => state ; const dispatch = jest . fn ( ) ; commitBulkEditor ( ) ( dispatch , getState ) ; const expected = [ { regimen_id , sequence_id , time_offset : 0 } , { sequence_id , time_offset : 0 } ] ; expect ( overwrite ) . toHaveBeenCalledWith ( expect . any ( Object ) , expect . objectContaining ( { regimen_items : expect . arrayContaining ( expected ) } ) ) ; expect ( error ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { console . log = jest . fn ( ) ; const state = newFakeState ( ) ; const seqUUID = state . resources . consumers . regimens . selectedSequenceUUID ; const label = "s" ; const varData = fakeVariableNameSet ( label ) ; const variable = varData [ label ] ; const COORDINATE = ( { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } ) ; variable && ( variable . celeryNode = { kind : "s" , args : { label , default_value : COORDINATE } } ) ; state . resources . index . sequenceMetas [ seqUUID || "s" ] = varData ; const dispatch = jest . fn ( ) ; commitBulkEditor ( ) ( dispatch , ( ) => state ) ; expect ( overwrite ) . toHaveBeenCalledWith ( expect . any ( Object ) , expect . objectContaining ( { body : [ { kind : "s" , args : { label , data_value : COORDINATE } } ] } ) ) ; expect ( error ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const action = setTimeOffset ( 0 ) ; expect ( action ) . toEqual ( { payload : 0 , type : Actions . SET_TIME_OFFSET } ) ; } ) ; it ( "s" , ( ) => { expect ( ( ) => setTimeOffset ( NaN ) ) . toThrowError ( "s" ) ; expect ( warning ) . toBeCalledWith ( "s" , "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const params = { week : 0 , day : 0 } ; const action = toggleDay ( params ) ; expect ( action ) . toEqual ( { payload : { day : 0 , week : 0 } , type : Actions . TOGGLE_DAY } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const action = setSequence ( "s" ) ; expect ( action ) . toEqual ( { payload : "s" , type : Actions . SET_SEQUENCE } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $string$ O O $string$ O O $string$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $Thunk$ O $complex$ O $complex$ O $ReduxAction<string>$ O O O O O O $Everything$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $T[]$ O O O O O O $T$ O O O O O O $ReduxAction<EditResourceParams>$ O O O O O O $complex$ O O O O O O $void$ O $void$ O O O O O O O O O O O O O O $any$ O O O O O O O O $Everything$ O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O O O $number$ O O O $string$ O O O $string$ O O O $complex$ O O O $number$ O $number$ O $number$ O O O O O $undefined[]$ O O O O O O O $any$ O $T[]$ O O O $any$ O O O O O O $any$ O $any$ O O O O O $number$ O O O $string$ O O O $string$ O O O $complex$ O O O $string$ O O O $complex$ O O $number$ O O O O O O $complex$ O O O O O $string$ O O O ${}$ O O O O O O O O O O $string$ O O O O O $any$ O $T$ O $T[]$ O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any[]$ O $any$ O O O O $any$ O $any$ O O $Everything$ O $RestResources$ O $ResourceIndex$ O $any$ O $any[]$ O O $any$ O $Everything$ O $RestResources$ O $complex$ O $RegimenState$ O $string$ O $any$ O $Everything$ O $RestResources$ O $complex$ O $RegimenState$ O $string$ O $any$ O $Everything$ O $RestResources$ O $complex$ O $RegimenState$ O $number$ O O O $Everything$ O $RestResources$ O $complex$ O $RegimenState$ O $Week[]$ O O O O O O $true$ O O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O $false$ O O O O O O O $Everything$ O O O $void$ O $Everything$ O $string$ O $string$ $string$ O O O $Everything$ O O O O $Everything$ O O $any$ O $any$ O $any$ O O O $Thunk$ O O O $any$ O $Everything$ O O $any$ O $any$ O O $any$ O $any$ O O O O O $string$ O O $any$ O $void$ O O $any$ O $string$ O $string$ O O O O O $any$ O $void$ O O $any$ O $string$ O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $complex$ O $RegimenState$ O $string$ O $undefined$ O $void$ O $Everything$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $complex$ O $RegimenState$ O $string$ O $undefined$ O $void$ O $Everything$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $complex$ O $RegimenState$ O $Week[]$ O O O O $complex$ O $boolean$ O O O $void$ O $Everything$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $complex$ O $RegimenState$ O $Week[]$ O O O O $void$ O $Everything$ O O O O O O O $any$ O O O O O O O $Console$ O $void$ O $any$ O $any$ O O O O $Everything$ O $Everything$ O O O O $Everything$ O O O O $Everything$ O O $any$ O $any$ O $any$ O O O $Thunk$ O O O $any$ O $Everything$ O O O $complex$ O O O $number$ O $number$ O $number$ O O O O O $number$ O $number$ O O O O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O $any$ O $ObjectConstructor$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $complex$ O O O O O $any$ O $void$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $Console$ O $void$ O $any$ O $any$ O O O O $Everything$ O $Everything$ O O O O $string$ O $Everything$ O $RestResources$ O $complex$ O $RegimenState$ O $string$ O O O O O O O $complex$ O $complex$ O O O O O $SequenceMeta$ O $complex$ O O O O O $Coordinate$ O O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O $SequenceMeta$ O O $SequenceMeta$ O $any$ O O $string$ O O O $complex$ O O $string$ O $any$ O $any$ O O O O $Everything$ O $RestResources$ O $ResourceIndex$ O $complex$ O $string$ O O O O $complex$ O O $any$ O $any$ O $any$ O O O $Thunk$ O O O $any$ O O O O $Everything$ O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O $any$ O $ObjectConstructor$ O O $any$ O $any$ O O $complex$ O O O $string$ O O O $complex$ O O $string$ O $any$ O $any$ O O O O O O O $any$ O $void$ O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O O $any$ O $complex$ O O $any$ O O $number$ O O O $Actions$ O $any$ O $Actions.SET_TIME_OFFSET$ O O O O O O $any$ O O O O O O O $any$ O O O O $complex$ O $number$ O O O $any$ O O O O $any$ O $void$ O O $any$ O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $ToggleDayParams$ O O $number$ O O O $number$ O O O O O $complex$ O $complex$ O $ToggleDayParams$ O O $any$ O $complex$ O O $any$ O O $complex$ O O $number$ O O O $number$ O O O O $Actions$ O $any$ O $Actions.TOGGLE_DAY$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $ReduxAction<string>$ O $ReduxAction<string>$ O O O O $any$ O $ReduxAction<string>$ O O $any$ O O $string$ O O O $Actions$ O $any$ O $Actions.SET_SEQUENCE$ O O O O O O O O O
import { duration } from "s" ; import { isNumber , padStart } from "s" ; export function msToTime ( ms ) { if ( isNumber ( ms ) ) { const d = duration ( ms ) ; const h = padStart ( d . hours ( ) . toString ( ) , 0 , "s" ) ; const m = padStart ( d . minutes ( ) . toString ( ) , 0 , "s" ) ; return `template` ; } else { return "s" ; } } export function timeToMs ( input ) { const [ hours , minutes ] = input . split ( "s" ) . map ( ( n ) => parseInt ( n , 0 ) ) ; return ( ( hours * 0 ) + ( minutes ) ) * 0 * 0 ; }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $string$ O $number$ O O O O $any$ O $number$ O O O O $any$ O $any$ O $number$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O O O O O O O O O O O O O O $number$ O $string$ O O O O $number$ O $number$ O O $string$ O $complex$ O O O O $U[]$ O O $string$ O O $number$ O $string$ O O O O O O O O $number$ O O O O O $number$ O O O O O O O O
import { msToTime } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( msToTime ( "s" as any ) ) . toBe ( "s" ) ; } ) ; } ) ;	O O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $string$ O O O O O O O $any$ O O O O O O O O O O
jest . mock ( "s" , ( ) => { return { toastErrors : jest . fn ( ) } ; } ) ; import { generalizedError , GeneralizedError , saveOK , } from "s" ; import { fakeUser } from "s" ; import { Actions } from "s" ; import { toastErrors } from "s" ; import { SpecialStatus } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = saveOK ( fakeUser ( ) ) ; expect ( result ) . toBeDefined ( ) ; expect ( result . type ) . toEqual ( Actions . SAVE_RESOURCE_OK ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const payl = { err : { } , uuid : "s" , statusBeforeError : SpecialStatus . DIRTY } ; const result = generalizedError ( payl ) ; expect ( result ) . toBeDefined ( ) ; expect ( result . type ) . toEqual ( Actions . _RESOURCE_NO ) ; expect ( toastErrors ) . toHaveBeenCalledWith ( payl ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $complex$ O $any$ O $complex$ O O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O $any$ O O O O $any$ O $complex$ O O $any$ O O O $any$ O $complex$ O $Actions$ O O $any$ O $any$ O $Actions.SAVE_RESOURCE_OK$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $GeneralizedError$ O O ${}$ O O O O $string$ O O O $any$ O $any$ O $any$ O O O $complex$ O $complex$ O $GeneralizedError$ O O $any$ O $complex$ O O $any$ O O O $any$ O $complex$ O $Actions$ O O $any$ O $any$ O $Actions._RESOURCE_NO$ O O $any$ O $void$ O O $any$ O $GeneralizedError$ O O O O O O O O
import { beforeEach } from "s" ; import { ReduxAction } from "s" ; import { Actions } from "s" ; import { fakeWebAppConfig } from "s" ; import { buildResourceIndex } from "s" ; describe ( "s" , ( ) => { const emptyHandler = < T > ( s : T ) : T => s ; const readonlyState = ( ) => { const config = fakeWebAppConfig ( ) ; config . body . user_interface_read_only_mode = true ; return buildResourceIndex ( [ config ] ) ; } ; it ( "s" , ( ) => { const state = readonlyState ( ) ; const action < { } > = ( { type : Actions . EDIT_RESOURCE , payload : { uuid : "s" } } ) ; const handler = jest . fn ( emptyHandler ) ; beforeEach ( state , action , handler ) ; expect ( handler ) . toHaveBeenCalledWith ( state , action ) ; } ) ; it ( "s" , ( ) => { const state = readonlyState ( ) ; const action < { } > = ( { type : Actions . EDIT_RESOURCE , payload : { uuid : "s" } } ) ; const handler = jest . fn ( emptyHandler ) ; expect ( beforeEach ( state , action , handler ) ) . toBe ( state ) ; expect ( handler ) . not . toHaveBeenCalledWith ( state , action ) ; const entryList : [ Actions , boolean ] [ ] = [ [ Actions . SAVE_RESOURCE_START , true ] , [ Actions . REFRESH_RESOURCE_OK , true ] , [ Actions . BATCH_INIT , false ] , [ Actions . INIT_RESOURCE , false ] , [ Actions . OVERWRITE_RESOURCE , false ] , ] ; entryList . map ( ( [ type , shouldCall ] ) => { handler . mockClear ( ) ; const 0 = { ... action , type } ; expect ( beforeEach ( state , 0 , handler ) ) . toEqual ( state ) ; if ( shouldCall ) { expect ( handler ) . toHaveBeenCalledWith ( state , 0 ) ; } else { expect ( handler ) . not . toHaveBeenCalledWith ( state , 0 ) ; } } ) ; } ) ; } ) ;	O O $RestResources$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $T$ O O $any$ O O $T$ O $any$ O O $any$ O $T$ O O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $ReduxAction$ O O O O O O O $Actions.EDIT_RESOURCE$ O $any$ O $Actions.EDIT_RESOURCE$ O $complex$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O $T$ O O $RestResources$ O $any$ O $ReduxAction<{}>$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $ReduxAction<{}>$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $ReduxAction$ O O O O O O O $Actions.EDIT_RESOURCE$ O $any$ O $Actions.EDIT_RESOURCE$ O $complex$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O $T$ O O $any$ O $RestResources$ O $any$ O $ReduxAction<{}>$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $ReduxAction<{}>$ O O O $complex$ O O $any$ O O O O O O O O $any$ O $Actions.SAVE_RESOURCE_START$ O O O O O $any$ O $Actions.REFRESH_RESOURCE_OK$ O O O O O $any$ O $Actions.BATCH_INIT$ O O O O O $any$ O $Actions.INIT_RESOURCE$ O O O O O $any$ O $Actions.OVERWRITE_RESOURCE$ O O O O O O $complex$ O $U[]$ O O O $Actions$ O $boolean$ O O O O $any$ O $any$ O O O O $complex$ O O O $ReduxAction<{}>$ O $Actions$ O O $any$ O $RestResources$ O $any$ O $complex$ O $any$ O O O $any$ O $any$ O O O O $boolean$ O O $any$ O $any$ O O $any$ O $any$ O $complex$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $complex$ O O O O O O O O O O O O
import { TaggedResource , TaggedRegimen , TaggedSequence } from "s" ; import { ResourceIndex } from "s" ; import { buildResourceIndex } from "s" ; import { EVERY_USAGE_KIND , UsageIndex , resourceUsageList } from "s" ; import { DeepPartial } from "s" ; import { fakeSequence , fakeFarmEvent , fakeRegimen } from "s" ; import { resourceReducer } from "s" ; import { resourceReady , newTaggedResource } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const x = { "s" : { "s" : { "s" : true , "s" : true } } , "s" : { "s" : { "s" : true , "s" : true } } , "s" : { "s" : { "s" : true , "s" : true } } , "s" : { "s" : { "s" : true , "s" : true } } , "s" : { "s" : { "s" : true } } } ; const actual = Object . keys ( resourceUsageList ( x ) ) . sort ( ) ; const expected = [ "s" , "s" , "s" , "s" , "s" , ] . sort ( ) ; expect ( actual . length ) . toEqual ( expected . length ) ; expected . map ( y => expect ( actual ) . toContain ( y ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { function testCase ( sequences : TaggedResource [ ] ) { return resourceReducer ( buildResourceIndex ( sequences ) , resourceReady ( "s" , sequences ) ) . index ; } const assertShape = ( inUse , expected < UsageIndex > ) => { EVERY_USAGE_KIND . map ( kind => expect ( inUse [ kind ] ) . toEqual ( expected [ kind ] || { } ) ) ; } ; it ( "s" , ( ) => assertShape ( testCase ( [ ] ) . inUse , { } ) ) ; it ( "s" , ( ) => { const selfReferential = fakeSequence ( ) ; const sequence_id = selfReferential . body . id ; if ( sequence_id ) { selfReferential . body . body = [ { kind : "s" , args : { sequence_id } } ] ; const { inUse } = testCase ( [ selfReferential ] ) ; assertShape ( inUse , { } ) ; } else { fail ( "s" ) ; } } ) ; it ( "s" , ( ) => { const 0 = fakeSequence ( ) ; const 0 = 0 ; 0 . body . id = 0 ; const 0 = fakeSequence ( ) ; const 0 = 0 ; 0 . body . id = 0 ; const 0 = fakeSequence ( ) ; const 0 = 0 ; 0 . body . id = 0 ; 0 . body . body = [ { kind : "s" , args : { sequence_id : 0 } } , { kind : "s" , args : { sequence_id : 0 } } , ] ; const { inUse } = testCase ( [ 0 , 0 , 0 ] ) ; assertShape ( inUse , { "s" : { [ 0 . uuid ] : { [ 0 . uuid ] : true } , [ 0 . uuid ] : { [ 0 . uuid ] : true } , } } ) ; } ) ; it ( "s" , ( ) => { const theRegimen = fakeRegimen ( ) ; theRegimen . body . id = 0 ; const theFarmEvent = fakeFarmEvent ( "s" , theRegimen . body . id ) ; const { inUse } = testCase ( [ theRegimen , theFarmEvent ] ) ; assertShape ( inUse , { "s" : { [ theRegimen . uuid ] : { [ theFarmEvent . uuid ] : true } , } } ) ; } ) ; it ( "s" , ( ) => { const sequence_id = 0 ; const sequence = newTaggedResource < TaggedSequence > ( "s" , { name : "s" , kind : "s" , color : "s" , args : { version : 0 , locals : { kind : "s" , args : { } } } } ) [ 0 ] ; sequence . body . id = sequence_id ; const regimen = newTaggedResource < TaggedRegimen > ( "s" , { name : "s" , color : "s" , regimen_items : [ { sequence_id , time_offset : 0 } ] , body : [ ] , } ) [ 0 ] ; const ri = buildResourceIndex ( [ regimen , sequence ] ) ; expect ( resourceUsageList ( ri . index . inUse ) [ sequence . uuid ] ) . toBe ( true ) ; } ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $UsageKind[]$ O $any$ O $complex$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $generateReducer<RestResources>.GeneratedReducer$ O O O O O O $SyncResponse<T>$ O $T[]$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $complex$ O O O O O $string[]$ O O O O $string[]$ O O O O O O O O O O O O O O $string[]$ O O O $any$ O $string[]$ O $number$ O O $any$ O $string[]$ O $number$ O O $string[]$ O $U[]$ O $string$ O $any$ O $string[]$ O O $any$ O $string$ O O O O O O O O O $any$ O O O O O O O O $ResourceIndex$ O $any[]$ O $any$ O O O O O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O $any[]$ O O $SyncResponse<T>$ O O O $any[]$ O O O $ResourceIndex$ O O O $void$ O O $UsageIndex$ O $DeepPartial$ O $any$ O O O O $UsageKind[]$ O $U[]$ O $UsageKind$ O $any$ O $complex$ O $UsageKind$ O O O $any$ O $any$ O $UsageKind$ O O O O O O O O O $any$ O O O O O O $void$ O $ResourceIndex$ O O O O O $complex$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O $string$ O O O $complex$ O O $any$ O O O O O O $complex$ O O $ResourceIndex$ O O $any$ O O O $void$ O $complex$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $string$ O O O $complex$ O O $number$ O O O O O O $string$ O O O $complex$ O O $number$ O O O O O O O O O $complex$ O O $ResourceIndex$ O O $any$ O $any$ O $any$ O O O $void$ O $complex$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $complex$ O O $ResourceIndex$ O O $any$ O $any$ O O O $void$ O $complex$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O O O O O O O O $any$ O $T[]$ O $any$ O O O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $number$ O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $T[]$ O $any$ O O O O O $string$ O O O $string$ O O O $complex$ O O O $number$ O $number$ O O O O O $undefined[]$ O O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $complex$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O O O O O O O O O O
import { fakeState } from "s" ; import { overwrite , refreshStart , refreshOK , refreshNO } from "s" ; import { SpecialStatus , TaggedSequence , TaggedDevice , ResourceName , TaggedResource , TaggedTool } from "s" ; import { buildResourceIndex } from "s" ; import { GeneralizedError } from "s" ; import { Actions } from "s" ; import { fakeResource } from "s" ; import { resourceReducer } from "s" ; import { findByUuid } from "s" ; import { EditResourceParams } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = fakeState ( ) . resources ; const uuid = Object . keys ( state . index . byKind . Sequence ) [ 0 ] ; const sequence = state . index . references [ uuid ] as TaggedSequence ; expect ( sequence ) . toBeTruthy ( ) ; expect ( sequence . kind ) . toBe ( "s" ) ; const next = resourceReducer ( state , overwrite ( sequence , { kind : "s" , name : "s" , args : { version : - 0 , locals : { kind : "s" , args : { } } } , body : [ ] , color : "s" } ) ) ; const 0 = next . index . references [ uuid ] as TaggedSequence ; expect ( 0 . specialStatus ) . toBe ( SpecialStatus . DIRTY ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) . resources ; const uuid = Object . keys ( state . index . byKind . Device ) [ 0 ] ; const device = state . index . references [ uuid ] as TaggedDevice ; expect ( device ) . toBeTruthy ( ) ; expect ( device . kind ) . toBe ( "s" ) ; const afterStart = resourceReducer ( state , refreshStart ( device . uuid ) ) ; const 0 = afterStart . index . references [ uuid ] as TaggedDevice ; expect ( 0 . specialStatus ) . toBe ( SpecialStatus . SAVING ) ; const afterOk = resourceReducer ( afterStart , refreshOK ( device ) ) ; const 0 = afterOk . index . references [ uuid ] as TaggedDevice ; expect ( 0 . specialStatus ) . toBe ( SpecialStatus . SAVED ) ; const payl = { err : "s" , uuid : 0 . uuid , statusBeforeError : SpecialStatus . DIRTY } ; const afterNo = resourceReducer ( afterStart , refreshNO ( payl ) ) ; const 0 = afterNo . index . references [ uuid ] as TaggedDevice ; expect ( 0 . specialStatus ) . toBe ( SpecialStatus . SAVED ) ; } ) ; const TEST_RESOURCE_NAMES : TaggedResource [ "s" ] [ ] = [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" ] ; it ( "s" , ( ) => { const startingState = fakeState ( ) . resources ; const { index } = startingState ; const uuid = Object . keys ( index . byKind . Tool ) [ 0 ] ; const update < TaggedTool [ "s" ] > = { name : "s" } ; const payload = { uuid , update , specialStatus : SpecialStatus . SAVED } ; const action = { type : Actions . EDIT_RESOURCE , payload } ; const newState = resourceReducer ( startingState , action ) ; const oldTool = index . references [ uuid ] as TaggedTool ; const newTool = newState . index . references [ uuid ] as TaggedTool ; expect ( oldTool . body . name ) . not . toEqual ( "s" ) ; expect ( newTool . body . name ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const startingState = fakeState ( ) . resources ; const uuid = Object . keys ( startingState . index . byKind . Tool ) [ 0 ] ; const action = { type : Actions . _RESOURCE_NO , payload : { uuid , err : "s" , statusBeforeError : SpecialStatus . DIRTY } } ; const newState = resourceReducer ( startingState , action ) ; const tool = newState . index . references [ uuid ] as TaggedTool ; expect ( tool . specialStatus ) . toBe ( SpecialStatus . DIRTY ) ; } ) ; it ( "s" , ( ) => { const testResourceDestroy = ( kind ) => { const state = fakeState ( ) . resources ; const resource = fakeResource ( kind as TaggedResource [ "s" ] , { } ) ; const action = { type : Actions . DESTROY_RESOURCE_OK , payload : resource } ; const newState = resourceReducer ( state , action ) ; expect ( newState . index . references [ resource . uuid ] ) . toEqual ( undefined ) ; } ; TEST_RESOURCE_NAMES . concat ( [ "s" , "s" ] ) . map ( ( kind ) => testResourceDestroy ( kind ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( ( ) => findByUuid ( buildResourceIndex ( ) . index , "s" ) ) . toThrow ( ) ; } ) ; } ) ;	O O $Everything$ O O O O O O $ReduxAction<EditResourceParams>$ O $ReduxAction<string>$ O $ReduxAction<any>$ O $ReduxAction<GeneralizedError>$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $T$ O O O O O O $generateReducer<RestResources>.GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $RestResources$ O $Everything$ O O O $RestResources$ O O $string$ O $ObjectConstructor$ O $complex$ O $RestResources$ O $ResourceIndex$ O $complex$ O $any$ O O O O O O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $RestResources$ O $generateReducer<RestResources>.GeneratedReducer$ O $RestResources$ O $ReduxAction<EditResourceParams>$ O $any$ O O $string$ O O O $string$ O O O $complex$ O O $number$ O O O O $complex$ O O $string$ O O O ${}$ O O O O O O $undefined[]$ O O O O $string$ O O O O O O O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $RestResources$ O $Everything$ O O O $RestResources$ O O $string$ O $ObjectConstructor$ O $complex$ O $RestResources$ O $ResourceIndex$ O $complex$ O $any$ O O O O O O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O $RestResources$ O $generateReducer<RestResources>.GeneratedReducer$ O $RestResources$ O $ReduxAction<string>$ O $any$ O $any$ O O O O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $RestResources$ O $generateReducer<RestResources>.GeneratedReducer$ O $RestResources$ O $ReduxAction<any>$ O $any$ O O O O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O $GeneralizedError$ O O $string$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $RestResources$ O $generateReducer<RestResources>.GeneratedReducer$ O $RestResources$ O $ReduxAction<GeneralizedError>$ O $GeneralizedError$ O O O O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $any[]$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O $RestResources$ O $Everything$ O O O $RestResources$ O O O $ResourceIndex$ O O $RestResources$ O O $string$ O $ObjectConstructor$ O $complex$ O $ResourceIndex$ O $complex$ O $any$ O O O O O O $Partial$ O $any$ O O O O O O $string$ O O O O O $EditResourceParams$ O O $string$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O $Actions$ O $any$ O $Actions.EDIT_RESOURCE$ O $EditResourceParams$ O O O $RestResources$ O $generateReducer<RestResources>.GeneratedReducer$ O $RestResources$ O $complex$ O O O $any$ O $ResourceIndex$ O $any$ O $string$ O O $any$ O O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $RestResources$ O $Everything$ O O O $RestResources$ O O $string$ O $ObjectConstructor$ O $complex$ O $RestResources$ O $ResourceIndex$ O $complex$ O $any$ O O O O O O $complex$ O O $Actions$ O $any$ O $Actions._RESOURCE_NO$ O $complex$ O O $string$ O $string$ O O O $any$ O $any$ O $any$ O O O O $RestResources$ O $generateReducer<RestResources>.GeneratedReducer$ O $RestResources$ O $complex$ O O O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $void$ O O $ResourceName$ O O O O $RestResources$ O $Everything$ O O O $RestResources$ O O $any$ O $T$ O $any$ O $any$ O O O O O O O O O $complex$ O O $Actions$ O $any$ O $Actions.DESTROY_RESOURCE_OK$ O $any$ O $any$ O O O $RestResources$ O $generateReducer<RestResources>.GeneratedReducer$ O $RestResources$ O $complex$ O O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O $any$ O $any$ O O O $any$ O $undefined$ O O O O $any[]$ O $complex$ O O O O O O O O $U[]$ O O $ResourceName$ O O $void$ O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O O $any$ O O O O O O O O O
import { buildResourceIndex , fakeDevice } from "s" ; import * as Selector from "s" ; import { TaggedTool , TaggedToolSlotPointer , } from "s" ; import { saveOK } from "s" ; import { hasId , arrayUnwrap } from "s" ; import { fakeWebcamFeed , fakeSequence , fakePlant } from "s" ; import { resourceReducer } from "s" ; import { emptyState } from "s" ; import { resourceReady , newTaggedResource } from "s" ; import { chain } from "s" ; const TOOL_ID = 0 ; const SLOT_ID = 0 ; const fakeTool = arrayUnwrap ( newTaggedResource ( "s" , { name : "s" , id : TOOL_ID } ) ) ; const fakeSlot = arrayUnwrap ( newTaggedResource ( "s" , { tool_id : TOOL_ID , pointer_type : "s" , radius : 0 , x : 0 , y : 0 , z : 0 , name : "s" , pointer_id : SLOT_ID , meta : { } , pullout_direction : 0 , gantry_mounted : false , } ) ) ; const fakeIndex = buildResourceIndex ( ) . index ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const state = resourceReducer ( buildResourceIndex ( ) , saveOK ( fakeTool ) ) ; expect ( state . index . byKindAndId [ "s" + fakeTool . body . id ] ) ; const result = Selector . findSlotByToolId ( state . index , TOOL_ID ) ; expect ( result ) . toBeFalsy ( ) ; } ) ; it ( "s" , ( ) => { const initialState = buildResourceIndex ( ) ; const state = [ saveOK ( fakeTool ) , saveOK ( fakeSlot ) ] . reduce ( resourceReducer , initialState ) ; const result = Selector . findSlotByToolId ( state . index , TOOL_ID ) ; expect ( result ) . toBeTruthy ( ) ; if ( result ) { expect ( result . kind ) . toBe ( "s" ) ; } } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( Selector . selectAllWebcamFeeds ( emptyState ( ) . index ) . length ) . toBe ( 0 ) ; } ) ; it ( "s" , ( ) => { const feed = fakeWebcamFeed ( ) ; const state = [ resourceReady ( "s" , feed ) ] . reduce ( resourceReducer , emptyState ( ) ) ; expect ( Selector . selectAllWebcamFeeds ( state . index ) [ 0 ] . body ) . toEqual ( feed . body ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const results = Selector . selectAllLogs ( fakeIndex ) ; expect ( results . length ) . toBeGreaterThan ( 0 ) ; const kinds = chain ( results ) . map ( "s" ) . uniq ( ) . value ( ) ; expect ( kinds . length ) . toEqual ( 0 ) ; expect ( kinds [ 0 ] ) . toEqual ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const uuid = Selector . findResourceById ( fakeIndex , "s" , 0 ) ; expect ( uuid ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const findUuid = ( ) => Selector . findResourceById ( fakeIndex , "s" , NaN ) ; expect ( findUuid ) . toThrow ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const ret = Selector . isKind ( "s" ) ( fakeSequence ( ) ) ; expect ( ret ) . toBeTruthy ( ) ; } ) ; it ( "s" , ( ) => { const ret = Selector . isKind ( "s" ) ( fakeSequence ( ) ) ; expect ( ret ) . toBeFalsy ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const points = Selector . groupPointsByType ( fakeIndex ) ; const expectedKeys = [ "s" , "s" , "s" ] ; expect ( expectedKeys . every ( key => key in points ) ) . toBeTruthy ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const find = ( ) => Selector . findPointerByTypeAndId ( fakeIndex , "s" , 0 ) ; expect ( find ) . toThrow ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const find = ( ) => Selector . findToolSlot ( fakeIndex , "s" ) ; expect ( find ) . toThrow ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { console . warn = jest . fn ( ) ; const find = ( ) => Selector . findPlant ( fakeIndex , "s" ) ; expect ( find ) . toThrowError ( ) ; expect ( console . warn ) . toBeCalled ( ) ; } ) ; it ( "s" , ( ) => { const plant = fakePlant ( ) ; plant . body . id = 0 ; const result = Selector . findPlant ( buildResourceIndex ( [ plant ] ) . index , plant . uuid ) ; expect ( result . uuid ) . toBe ( plant . uuid ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const find = ( ) => Selector . selectCurrentToolSlot ( fakeIndex , "s" ) ; expect ( find ) . toThrowError ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { console . warn = jest . fn ( ) ; const find = ( ) => Selector . getSequenceByUUID ( fakeIndex , "s" ) ; expect ( find ) . toThrow ( "s" ) ; expect ( console . warn ) . toBeCalled ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const boom = ( ) => Selector . getUserAccountSettings ( buildResourceIndex ( [ ] ) . index ) ; expect ( boom ) . toThrow ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const i = buildResourceIndex ( [ ] ) ; const result = Selector . maybeGetSequence ( i . index , undefined ) ; expect ( result ) . toBe ( undefined ) ; } ) ; it ( "s" , ( ) => { const s = fakeSequence ( ) ; const i = buildResourceIndex ( [ s ] ) ; const result = Selector . maybeGetSequence ( i . index , s . uuid ) ; expect ( result ) . toBeTruthy ( ) ; result && expect ( result . uuid ) . toBe ( s . uuid ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = Selector . findAllById ( fakeIndex , [ 0 ] , "s" ) ; expect ( result . length ) . toEqual ( 0 ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const activeTools = Selector . toolsInUse ( fakeIndex ) ; expect ( activeTools . length ) . toBeGreaterThan ( 0 ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = hasId ( fakeIndex , "s" , 0 ) ; expect ( result ) . toBeTruthy ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const find = ( ) => Selector . findFarmEventById ( fakeIndex , 0 ) ; expect ( find ) . toThrow ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = Selector . maybeFindToolById ( fakeIndex , 0 ) ; expect ( result ) . toBeUndefined ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const find = ( ) => Selector . findToolById ( fakeIndex , 0 ) ; expect ( find ) . toThrow ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const find = ( ) => Selector . findSequenceById ( fakeIndex , 0 ) ; expect ( find ) . toThrow ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const find = ( ) => Selector . findRegimenById ( fakeIndex , 0 ) ; expect ( find ) . toThrow ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = Selector . maybeFindPlantById ( fakeIndex , 0 ) ; expect ( result ) . toBeUndefined ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { const 0 = fakeDevice ( ) ; 0 . uuid = "s" ; const 0 = fakeDevice ( ) ; 0 . uuid = "s" ; it ( "s" , ( ) => { const { index } = buildResourceIndex ( [ ] ) ; const kaboom = ( ) => Selector . getDeviceAccountSettings ( index ) ; expect ( kaboom ) . toThrowError ( ) ; } ) ; it ( "s" , ( ) => { const { index } = buildResourceIndex ( [ 0 , 0 ] ) ; const kaboom = ( ) => Selector . getDeviceAccountSettings ( index ) ; expect ( kaboom ) . toThrowError ( ) ; } ) ; it ( "s" , ( ) => { const { index } = buildResourceIndex ( [ 0 ] ) ; const result = Selector . getDeviceAccountSettings ( index ) ; expect ( result . kind ) . toBe ( "s" ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O $complex$ O O O O O O $boolean$ O $T$ O O O O O O $any$ O $any$ O $any$ O O O O O O $generateReducer<RestResources>.GeneratedReducer$ O O O O O O $RestResources$ O O O O O O $SyncResponse<T>$ O $T[]$ O O O O O O $any$ O O O O O O O O O O O O O O O $TaggedTool$ O $T$ O $T[]$ O O O O $string$ O O O $number$ O O O O O O O $TaggedToolSlotPointer$ O $T$ O $T[]$ O O O O $number$ O O O $string$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O $number$ O O O ${}$ O O O O $number$ O O O $boolean$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $RestResources$ O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O O O $complex$ O $any$ O O O $any$ O $RestResources$ O $ResourceIndex$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $RestResources$ O $ResourceIndex$ O O O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O O $complex$ O $any$ O O $complex$ O $any$ O O O $complex$ O $generateReducer<RestResources>.GeneratedReducer$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $any[]$ O $RestResources$ O O O $ResourceIndex$ O O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $RestResources$ O O $SyncResponse<T>$ O O O $any$ O O O $SyncResp...$ O $generateReducer<RestResources>.GeneratedReducer$ O $RestResources$ O O O O $any$ O $any$ O $any[]$ O $RestResources$ O $ResourceIndex$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any[]$ O $any$ O $any[]$ O $any$ O O $any$ O $any[]$ O $number$ O O $any$ O O O O O $any$ O $any$ O $any[]$ O O $any$ O O O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O $number$ O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $boolean$ O $any$ O $boolean$ O O O O $any$ O O O O $any$ O $boolean$ O O $any$ O O O O O O $any$ O O O O O O O O $boolean$ O $any$ O $boolean$ O O O O $any$ O O O O $any$ O $boolean$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $string[]$ O O O O O O O O O $any$ O $string[]$ O $boolean$ O $string$ O $string$ O $any$ O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $Console$ O $void$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $Console$ O $void$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $Console$ O $void$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $Console$ O $void$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $undefined$ O O $any$ O $any$ O O $any$ O $undefined$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any[]$ O $any$ O $any[]$ O $any$ O O O O O O O O $any$ O $any[]$ O $number$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any[]$ O $any$ O $any[]$ O $any$ O O $any$ O $any[]$ O $number$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $boolean$ O $boolean$ O $any$ O O O O O O $any$ O $boolean$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O O O O $any$ O O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O O $any$ O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { createSequenceMeta , determineDropdown , findVariableByName , determineVector , determineVarDDILabel } from "s" ; import { fakeSequence , fakePoint , fakeTool , fakeToolSlot , fakePointGroup } from "s" ; import { buildResourceIndex } from "s" ; import { sanitizeNodes } from "s" ; import { formatPoint , NO_VALUE_SELECTED_DDI , formatTool } from "s" ; import { Point , Tool } from "s" ; import { fakeVariableNameSet } from "s" ; import { NOTHING_SELECTED } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const baddata = { kind : "s" , args : { label : "s" , data_value : { kind : "s" , args : { resource_id : 0 } } } } ; const r = ( ) => determineDropdown ( baddata , buildResourceIndex ( [ ] ) . index ) ; expect ( r ) . toThrowError ( "s" ) ; } ) ; it ( "s" , ( ) => { const pg = fakePointGroup ( ) ; pg . body . id = 0 ; const r = determineDropdown ( { kind : "s" , args : { label : "s" , data_value : { kind : "s" , args : { point_group_id : 0 } } } } , buildResourceIndex ( [ pg ] ) . index ) ; expect ( r . label ) . toEqual ( pg . body . name ) ; expect ( r . value ) . toEqual ( pg . body . id ) ; } ) ; it ( "s" , ( ) => { const r = determineDropdown ( { kind : "s" , args : { label : "s" , default_value : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } } } , buildResourceIndex ( [ ] ) . index ) ; expect ( r . label ) . toBe ( "s" ) ; expect ( r . value ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { const r = determineDropdown ( { kind : "s" , args : { label : "s" , data_value : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } } } , buildResourceIndex ( [ ] ) . index ) ; expect ( r . label ) . toBe ( "s" ) ; expect ( r . value ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { const varData = fakeVariableNameSet ( "s" ) ; const ri = buildResourceIndex ( [ ] ) . index ; ri . sequenceMetas [ "s" ] = varData ; const r = determineDropdown ( { kind : "s" , args : { label : "s" , data_value : { kind : "s" , args : { label : "s" } } } } , ri , "s" ) ; expect ( r . label ) . toBe ( "s" ) ; expect ( r . value ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { const point = fakePoint ( ) ; const pointNode = { kind : "s" , args : { pointer_id : point . body . id || - 0 , pointer_type : "s" } } ; const r = determineDropdown ( { kind : "s" , args : { label : "s" , data_value : pointNode } } , buildResourceIndex ( [ point ] ) . index ) ; expect ( r . label ) . toBe ( formatPoint ( point ) . label ) ; expect ( r . value ) . toBe ( "s" + point . body . id ) ; } ) ; it ( "s" , ( ) => { const tool = fakeTool ( ) ; tool . body . id = 0 ; const toolNode = { kind : "s" , args : { tool_id : tool . body . id } } ; const toolSlot = fakeToolSlot ( ) ; toolSlot . body . tool_id = tool . body . id ; const r = determineDropdown ( { kind : "s" , args : { label : "s" , data_value : toolNode } } , buildResourceIndex ( [ tool , toolSlot ] ) . index ) ; expect ( r . label ) . toBe ( formatTool ( tool , toolSlot ) . label ) ; expect ( r . value ) . toBe ( "s" + tool . body . id ) ; } ) ; it ( "s" , ( ) => { const tool = fakeTool ( ) ; tool . body . id = 0 ; const toolNode = { kind : "s" , args : { tool_id : tool . body . id } } ; const r = determineDropdown ( { kind : "s" , args : { label : "s" , data_value : toolNode } } , buildResourceIndex ( [ tool ] ) . index ) ; expect ( r . label ) . toBe ( formatTool ( tool , undefined ) . label ) ; expect ( r . value ) . toBe ( "s" + tool . body . id ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const point = fakePoint ( ) ; const pointNode = { kind : "s" , args : { pointer_id : point . body . id || - 0 , pointer_type : "s" } } ; const v = determineVector ( { kind : "s" , args : { label : "s" , data_value : pointNode } } , buildResourceIndex ( [ point ] ) . index ) ; const { x , y , z } = point . body ; expect ( v ) . toEqual ( expect . objectContaining ( { x , y , z } ) ) ; } ) ; it ( "s" , ( ) => { const tool = fakeTool ( ) ; tool . body . id = 0 ; const toolNode = { kind : "s" , args : { tool_id : tool . body . id } } ; const toolSlot = fakeToolSlot ( ) ; toolSlot . body . tool_id = tool . body . id ; const v = determineVector ( { kind : "s" , args : { label : "s" , data_value : toolNode } } , buildResourceIndex ( [ tool , toolSlot ] ) . index ) ; const { x , y , z } = toolSlot . body ; expect ( v ) . toEqual ( expect . objectContaining ( { x , y , z } ) ) ; } ) ; it ( "s" , ( ) => { const vector = { x : 0 , y : 0 , z : 0 } ; const varData = fakeVariableNameSet ( "s" , vector ) ; const ri = buildResourceIndex ( [ ] ) . index ; ri . sequenceMetas [ "s" ] = varData ; const v = determineVector ( { kind : "s" , args : { label : "s" , data_value : { kind : "s" , args : { label : "s" } } } } , ri , "s" ) ; expect ( v ) . toEqual ( vector ) ; } ) ; } ) ; describe ( "s" , ( ) => { const s = fakeSequence ( ) ; s . body . body = [ { kind : "s" , args : { location : { kind : "s" , args : { label : "s" } } , offset : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } , speed : 0 } } ] ; s . body = sanitizeNodes ( s . body ) . thisSequence ; const ri = buildResourceIndex ( [ s ] ) ; it ( "s" , ( ) => { const result = createSequenceMeta ( ri . index , s ) ; const { parent } = result ; const extracted = findVariableByName ( ri . index , s . uuid , "s" ) ; expect ( parent ) . toBeTruthy ( ) ; if ( parent && extracted ) { expect ( parent . celeryNode . args . label ) . toEqual ( "s" ) ; expect ( parent . dropdown . label ) . toEqual ( NO_VALUE_SELECTED_DDI ( ) . label ) ; expect ( parent . vector ) . toEqual ( undefined ) ; expect ( extracted . celeryNode . args . label ) . toEqual ( "s" ) ; expect ( extracted . dropdown . label ) . toEqual ( NO_VALUE_SELECTED_DDI ( ) . label ) ; expect ( extracted . vector ) . toEqual ( undefined ) ; } } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const ri = buildResourceIndex ( ) . index ; const label = determineVarDDILabel ( { label : "s" , resources : ri , uuid : undefined } ) ; expect ( label ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const varData = fakeVariableNameSet ( "s" ) ; const data = Object . values ( varData ) [ 0 ] ; data && ( data . celeryNode = NOTHING_SELECTED ) ; const ri = buildResourceIndex ( ) . index ; ri . sequenceMetas = { "s" : varData } ; const label = determineVarDDILabel ( { label : "s" , resources : ri , uuid : "s" } ) ; expect ( label ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const varData = fakeVariableNameSet ( "s" ) ; const data = Object . values ( varData ) [ 0 ] ; data && ( data . celeryNode = { kind : "s" , args : { label : "s" , default_value : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } } } ) ; const ri = buildResourceIndex ( ) . index ; ri . sequenceMetas = { "s" : varData } ; const label = determineVarDDILabel ( { label : "s" , resources : ri , uuid : "s" } ) ; expect ( label ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const varData = fakeVariableNameSet ( "s" ) ; const data = Object . values ( varData ) [ 0 ] ; data && ( data . celeryNode . kind = "s" ) ; const ri = buildResourceIndex ( ) . index ; ri . sequenceMetas = { "s" : varData } ; const label = determineVarDDILabel ( { label : "s" , resources : ri , uuid : "s" } ) ; expect ( label ) . toEqual ( "s" ) ; } ) ; } ) ;	O O $complex$ O $DropDownItem$ O $SequenceMeta$ O $any$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $SanitizationResult$ O O O O O O $DropDownItem$ O $DropDownItem$ O $DropDownItem$ O O O O O O $any$ O $any$ O O O O O O $complex$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O O O O O O $DropDownItem$ O O O O $DropDownItem$ O $any$ O $any$ O O O O O $any$ O O $any$ O $DropDownItem$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $DropDownItem$ O $DropDownItem$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O O O O O $any$ O O $any$ O O O $any$ O O $any$ O $DropDownItem$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $DropDownItem$ O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $DropDownItem$ O $DropDownItem$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O $any$ O O O O O $any$ O O $any$ O $DropDownItem$ O $string$ O O $any$ O O O O $any$ O $DropDownItem$ O $complex$ O O $any$ O O O O O O O $any$ O O O O O O O O $DropDownItem$ O $DropDownItem$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O $any$ O O O O O $any$ O O $any$ O $DropDownItem$ O $string$ O O $any$ O O O O $any$ O $DropDownItem$ O $complex$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O $DropDownItem$ O $DropDownItem$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O O O $any$ O O O O $any$ O $DropDownItem$ O $string$ O O $any$ O O O O $any$ O $DropDownItem$ O $complex$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $Point$ O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O O $DropDownItem$ O $DropDownItem$ O O $string$ O O O $complex$ O O $string$ O O O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O O $any$ O $DropDownItem$ O $string$ O O $any$ O $DropDownItem$ O $any$ O O $string$ O O $any$ O $DropDownItem$ O $complex$ O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $Tool$ O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $DropDownItem$ O $DropDownItem$ O O $string$ O O O $complex$ O O $string$ O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O $any$ O O $any$ O $DropDownItem$ O $string$ O O $any$ O $DropDownItem$ O $any$ O $any$ O O $string$ O O $any$ O $DropDownItem$ O $complex$ O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $Tool$ O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O $DropDownItem$ O $DropDownItem$ O O $string$ O O O $complex$ O O $string$ O O O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O O $any$ O $DropDownItem$ O $string$ O O $any$ O $DropDownItem$ O $any$ O $undefined$ O O $string$ O O $any$ O $DropDownItem$ O $complex$ O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $Point$ O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O O O O $any$ O $any$ O O $string$ O O O $complex$ O O $string$ O O O $any$ O $any$ O O O $any$ O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $Tool$ O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $string$ O O O $complex$ O O $string$ O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O $complex$ O $complex$ O O O $complex$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O $complex$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O $number$ O O O O O O $any$ O $any$ O $SanitizationResult$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O $any$ O O O $any$ O O O O O O O O $complex$ O $complex$ O $any$ O $any$ O $any$ O O O O $SequenceMeta$ O O $complex$ O O $SequenceMeta$ O $SequenceMeta$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $SequenceMeta$ O O $any$ O O O O O $SequenceMeta$ O $SequenceMeta$ O O $any$ O $SequenceMeta$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $SequenceMeta$ O $DropDownItem$ O $string$ O O $any$ O $DropDownItem$ O O O $string$ O O $any$ O $SequenceMeta$ O $any$ O O $any$ O $undefined$ O O $any$ O $SequenceMeta$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $SequenceMeta$ O $DropDownItem$ O $string$ O O $any$ O $DropDownItem$ O O O $string$ O O $any$ O $SequenceMeta$ O $any$ O O $any$ O $undefined$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O $string$ O $string$ O O $string$ O O O $any$ O $any$ O $undefined$ O $undefined$ O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O O O $SequenceMeta$ O $ObjectConstructor$ O $complex$ O $complex$ O O O O O $SequenceMeta$ O O $SequenceMeta$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $complex$ O O O $string$ O $string$ O O $string$ O O O $any$ O $any$ O $string$ O O O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O O O $SequenceMeta$ O $ObjectConstructor$ O $complex$ O $complex$ O O O O O $SequenceMeta$ O O $SequenceMeta$ O $any$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $complex$ O O O $string$ O $string$ O O $string$ O O O $any$ O $any$ O $string$ O O O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O O O $SequenceMeta$ O $ObjectConstructor$ O $complex$ O $complex$ O O O O O $SequenceMeta$ O O $SequenceMeta$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $complex$ O O O $string$ O $string$ O O $string$ O O O $any$ O $any$ O $string$ O O O O O $any$ O $string$ O O $any$ O O O O O O O O O O
import { TaggedSequence , SpecialStatus } from "s" ; import { get } from "s" ; import { getStepTag , maybeTagStep } from "s" ; describe ( "s" , ( ) => { const UNTAGGED_SEQUENCE = { "s" : "s" , "s" : "s" , "s" : SpecialStatus . SAVED , "s" : { "s" : 0 , "s" : "s" , "s" : "s" , "s" : [ { "s" : "s" , "s" : { "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 } , } ] , "s" : { "s" : { kind : "s" , args : { } } , "s" : 0 } , "s" : "s" } , } ; it ( "s" , ( ) => { const body = UNTAGGED_SEQUENCE . body . body || [ ] ; expect ( body . length ) . toEqual ( 0 ) ; expect ( get ( body [ 0 ] , "s" ) ) . not . toBeDefined ( ) ; expect ( ( ) => { getStepTag ( body [ 0 ] ) ; } ) . toThrow ( ) ; maybeTagStep ( body [ 0 ] ) ; expect ( get ( body [ 0 ] , "s" ) ) . toBeDefined ( ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $string$ O $Traversable$ O O O O $any$ O O O O O O O O $TaggedSequence$ O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O ${}$ O O O O O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O O $string$ O $any$ O O O O O O O O $any$ O O O $Traversable$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O
import { fakeTool } from "s" ; import { getArrayStatus , sanityCheck } from "s" ; import { SpecialStatus } from "s" ; describe ( "s" , ( ) => { const toolArray = ( ) => [ fakeTool ( ) , fakeTool ( ) , fakeTool ( ) ] ; it ( "s" , ( ) => { const arr = toolArray ( ) ; arr [ 0 ] . specialStatus = SpecialStatus . SAVED ; arr [ 0 ] . specialStatus = SpecialStatus . DIRTY ; arr [ 0 ] . specialStatus = SpecialStatus . SAVING ; expect ( getArrayStatus ( arr ) ) . toBe ( SpecialStatus . SAVING ) ; } ) ; it ( "s" , ( ) => { const arr = toolArray ( ) ; arr [ 0 ] . specialStatus = SpecialStatus . SAVED ; arr [ 0 ] . specialStatus = SpecialStatus . DIRTY ; arr [ 0 ] . specialStatus = SpecialStatus . SAVED ; expect ( getArrayStatus ( arr ) ) . toBe ( SpecialStatus . DIRTY ) ; } ) ; it ( "s" , ( ) => { const arr = toolArray ( ) ; arr [ 0 ] . specialStatus = SpecialStatus . SAVED ; arr [ 0 ] . specialStatus = SpecialStatus . SAVED ; arr [ 0 ] . specialStatus = SpecialStatus . SAVED ; expect ( getArrayStatus ( arr ) ) . toBe ( SpecialStatus . SAVED ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { console . error = jest . fn ( ) ; expect ( ( ) => sanityCheck ( { } ) ) . toThrow ( "s" ) ; expect ( console . error ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $complex$ O O O O O O $any$ O O O O $any$ O O O O O O O O $any[]$ O O O O O $any$ O O O $any$ O O O $any$ O O O O $any$ O O O O O O O O $any[]$ O $any[]$ O O O $any[]$ O O O O $any$ O $any$ O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any[]$ O $any[]$ O O O $any[]$ O O O O $any$ O $any$ O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any[]$ O $any[]$ O O O $any[]$ O O O O $any$ O $any$ O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O $any[]$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any[]$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $Console$ O $void$ O $any$ O $any$ O O O $any$ O O O O $complex$ O O O O O O $any$ O O O O $any$ O $Console$ O $void$ O O $any$ O O O O O O O O O O
import { selectAllSequences } from "s" ; import { store } from "s" ; import { urlFriendly , lastUrlChunk } from "s" ; import { selectSequence } from "s" ; import { setMenuOpen } from "s" ; const setSequence = ( uuid ) => store . dispatch ( selectSequence ( uuid ) ) ; export function setActiveSequenceByName ( ) { store . dispatch ( setMenuOpen ( false ) ) ; if ( lastUrlChunk ( ) == "s" ) { return ; } selectAllSequences ( store . getState ( ) . resources . index ) . map ( seq => { const name = urlFriendly ( seq . body . name ) ; ( lastUrlChunk ( ) === name ) && setSequence ( seq . uuid ) ; } ) ; }	O O $any[]$ O O O O O O $any$ O O O O O O $string$ O $string$ O O O O O O $SelectSequence$ O O O O O O $any$ O O O O O $any$ O O $string$ O O $any$ O $any$ O $SelectSequence$ O $string$ O O O O O $void$ O O O $any$ O $any$ O $any$ O O O O O O O $string$ O O O O O O O O O $any[]$ O $any$ O $any$ O O O $any$ O $any$ O O $U[]$ O $any$ O O O $string$ O $string$ O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O O $any$ O $any$ O $any$ O O O O O O
import { SequenceBodyItem , TaggedSequence } from "s" ; import { SelectSequence } from "s" ; import { edit , init , overwrite } from "s" ; import { defensiveClone } from "s" ; import { push } from "s" ; import { urlFriendly } from "s" ; import { Actions } from "s" ; import { setActiveSequenceByName } from "s" ; import { t } from "s" ; import { isNumber } from "s" ; export function pushStep ( step , dispatch , sequence , index ? : number | undefined ) { const next = defensiveClone ( sequence ) ; next . body . body = next . body . body || [ ] ; next . body . body . splice ( isNumber ( index ) ? index : Infinity , 0 , defensiveClone ( step ) ) ; dispatch ( overwrite ( sequence , next . body ) ) ; } export function editCurrentSequence ( dispatch , seq , update < typeof seq . body > ) { dispatch ( edit ( seq , update ) ) ; } let count = 0 ; export const copySequence = ( payload ) => ( dispatch ) => { const copy = defensiveClone ( payload ) ; copy . body . id = undefined ; copy . body . name = copy . body . name + t ( "s" ) + ( count ++ ) ; dispatch ( init ( copy . kind , copy . body ) ) ; push ( "s" + urlFriendly ( copy . body . name ) ) ; setActiveSequenceByName ( ) ; } ; export function selectSequence ( uuid ) { return { type : Actions . SELECT_SEQUENCE , payload : uuid } ; } export const unselectSequence = ( ) => { push ( "s" ) ; return { type : Actions . SELECT_SEQUENCE , payload : undefined } ; } ; export const closeCommandMenu = ( ) => ( { type : Actions . SET_SEQUENCE_STEP_POSITION , payload : undefined , } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O $ReduxAction<any>$ O $ReduxAction<EditResourceParams>$ O O O O O O $T$ O O O O O O $any$ O O O O O O $string$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O $SequenceBodyItem$ O $Function$ O $TaggedSequence$ O $number$ O O O O O O O O $any$ O $T$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $number$ O O $number$ O $number$ O O O $T$ O $any$ O O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O $any$ O $any$ O O O O O O $void$ O $Function$ O $TaggedSequence$ O $Partial$ O O $any$ O $any$ O O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O $any$ O O O O O $number$ O O O O O $void$ O O $TaggedSequence$ O O O $Function$ O O O O $any$ O $T$ O $any$ O O $any$ O $any$ O $any$ O $undefined$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $number$ O O O $Function$ O $ReduxAction<any>$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O $any$ O $any$ O $any$ O O O $void$ O O O O O O O $SelectSequence$ O $string$ O O O O $Actions.SELECT_SEQUENCE$ O $any$ O $Actions.SELECT_SEQUENCE$ O $string$ O $string$ O O O O O $complex$ O O O O O $any$ O O O O O O $Actions$ O $any$ O $Actions.SELECT_SEQUENCE$ O $undefined$ O $undefined$ O O O O O O $complex$ O O O O O O $Actions$ O $any$ O $Actions.SET_SEQUENCE_STEP_POSITION$ O $undefined$ O $undefined$ O O O O
jest . mock ( "s" , ( ) => ( { push : jest . fn ( ) } ) ) ; jest . mock ( "s" , ( ) => ( { init : jest . fn ( ) , edit : jest . fn ( ) , overwrite : jest . fn ( ) , } ) ) ; jest . mock ( "s" , ( ) => ( { setActiveSequenceByName : jest . fn ( ) } ) ) ; import { copySequence , editCurrentSequence , selectSequence , pushStep } from "s" ; import { fakeSequence } from "s" ; import { init , edit , overwrite } from "s" ; import { push } from "s" ; import { Actions } from "s" ; import { setActiveSequenceByName } from "s" ; import { TakePhoto , Wait } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const sequence = fakeSequence ( ) ; sequence . body . body = [ { kind : "s" , args : { milliseconds : 0 } } ] ; const { body } = sequence . body ; copySequence ( sequence ) ( jest . fn ( ) ) ; expect ( init ) . toHaveBeenCalledWith ( "s" , expect . objectContaining ( { name : "s" , body } ) ) ; } ) ; it ( "s" , ( ) => { copySequence ( fakeSequence ( ) ) ( jest . fn ( ) ) ; expect ( push ) . toHaveBeenCalledWith ( "s" ) ; } ) ; it ( "s" , ( ) => { copySequence ( fakeSequence ( ) ) ( jest . fn ( ) ) ; expect ( setActiveSequenceByName ) . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const fake = fakeSequence ( ) ; editCurrentSequence ( jest . fn , fake , { color : "s" } ) ; expect ( edit ) . toHaveBeenCalledWith ( expect . objectContaining ( { uuid : fake . uuid } ) , { color : "s" } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( selectSequence ( "s" ) ) . toEqual ( { type : Actions . SELECT_SEQUENCE , payload : "s" } ) ; } ) ; } ) ; describe ( "s" , ( ) => { const step = ( n ) : Wait => ( { kind : "s" , args : { milliseconds : n } } ) ; const NEW_STEP = { kind : "s" , args : { } } ; it ( "s" , ( ) => { const sequence = fakeSequence ( ) ; sequence . body . body = [ step ( 0 ) , step ( 0 ) , step ( 0 ) , ] ; pushStep ( NEW_STEP , jest . fn ( ) , sequence , 0 ) ; expect ( overwrite ) . toHaveBeenCalledWith ( sequence , expect . objectContaining ( { body : [ step ( 0 ) , step ( 0 ) , NEW_STEP , step ( 0 ) , ] } ) ) ; } ) ; it ( "s" , ( ) => { const sequence = fakeSequence ( ) ; sequence . body . body = [ step ( 0 ) , step ( 0 ) , step ( 0 ) , ] ; pushStep ( NEW_STEP , jest . fn ( ) , sequence ) ; expect ( overwrite ) . toHaveBeenCalledWith ( sequence , expect . objectContaining ( { body : [ step ( 0 ) , step ( 0 ) , step ( 0 ) , NEW_STEP , ] } ) ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $void$ O $void$ O $SelectSequence$ O $void$ O O O O O O $any$ O O O O O O $ReduxAction<any>$ O $ReduxAction<EditResourceParams>$ O $ReduxAction<EditResourceParams>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $void$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $string$ O O O $complex$ O O $number$ O O O O O O O O $any$ O O $any$ O $any$ O $void$ O $any$ O O $any$ O $any$ O O O O $any$ O $ReduxAction<any>$ O O $any$ O O O $any$ O $any$ O O $string$ O O O $any$ O O O O O O O $any$ O O O O O O O $void$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O $void$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $void$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O $any$ O O $string$ O O O O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $string$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $SelectSequence$ O O O O O $any$ O O $Actions$ O $any$ O $Actions.SELECT_SEQUENCE$ O $string$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O O $number$ O O $any$ O O O $string$ O O O $complex$ O O $number$ O $number$ O O O O O $TakePhoto$ O O $string$ O O O ${}$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O O O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O O O O O O O O
import { sequenceReducer } from "s" ; import { Actions } from "s" ; import { fakeSequence } from "s" ; import { SequenceReducerState } from "s" ; describe ( "s" , ( ) => { function resourcePayload ( before : string | undefined , actionType , after : string | undefined ) { const sequence = fakeSequence ( ) ; sequence . uuid = "s" ; const state = { current : before , menuOpen : false , stepIndex : undefined } ; const action = { type : actionType , payload : sequence } ; const stateAfter = sequenceReducer ( state , action ) ; expect ( stateAfter . current ) . toBe ( after ) ; } it ( "s" , ( ) => { resourcePayload ( "s" , Actions . DESTROY_RESOURCE_OK , undefined ) ; } ) ; it ( "s" , ( ) => { const state = { current : undefined , menuOpen : false , stepIndex : undefined } ; const action = { type : Actions . SELECT_SEQUENCE , payload : "s" } ; const stateAfter = sequenceReducer ( state , action ) ; expect ( stateAfter . current ) . toBe ( "s" ) ; } ) ; it ( "s" , ( ) => { const state = { current : undefined , menuOpen : false , stepIndex : undefined } ; const action = { type : Actions . SET_SEQUENCE_STEP_POSITION , payload : 0 } ; const stateAfter = sequenceReducer ( state , action ) ; expect ( stateAfter . stepIndex ) . toBe ( 0 ) ; } ) ; } ) ;	O O $generateReducer<SequenceReducerState>.GeneratedReducer$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $void$ O $string$ O O O O O $Actions$ O $string$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $SequenceReducerState$ O O $string$ O $string$ O $false$ O O O $undefined$ O $undefined$ O O O $complex$ O O $Actions$ O $Actions$ O $any$ O $any$ O O O $SequenceReducerState$ O $generateReducer<SequenceReducerState>.GeneratedReducer$ O $SequenceReducerState$ O $complex$ O O $any$ O $SequenceReducerState$ O $string$ O O $any$ O $string$ O O O $any$ O O O O O O O $void$ O O O $any$ O $Actions.DESTROY_RESOURCE_OK$ O $undefined$ O O O O O $any$ O O O O O O O O $SequenceReducerState$ O O $undefined$ O $undefined$ O $false$ O O O $undefined$ O $undefined$ O O O $complex$ O O $Actions$ O $any$ O $Actions.SELECT_SEQUENCE$ O $string$ O O O O O $SequenceReducerState$ O $generateReducer<SequenceReducerState>.GeneratedReducer$ O $SequenceReducerState$ O $complex$ O O $any$ O $SequenceReducerState$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $SequenceReducerState$ O O $undefined$ O $undefined$ O $false$ O O O $undefined$ O $undefined$ O O O $complex$ O O $Actions$ O $any$ O $Actions.SET_SEQUENCE_STEP_POSITION$ O $number$ O O O O O $SequenceReducerState$ O $generateReducer<SequenceReducerState>.GeneratedReducer$ O $SequenceReducerState$ O $complex$ O O $any$ O $SequenceReducerState$ O $number$ O O $any$ O O O O O O O O O O
import { fakeSequence } from "s" ; const mockData = { lastUrlChunk : "s" , fakeSequences : [ fakeSequence ( ) ] } ; jest . mock ( "s" , ( ) => { return { urlFriendly : jest . fn ( x => x ) , lastUrlChunk : jest . fn ( ( ) => mockData . lastUrlChunk ) } ; } ) ; jest . mock ( "s" , ( ) => ( { selectSequence : jest . fn ( ) } ) ) ; jest . mock ( "s" , ( ) => { return { selectAllSequences : jest . fn ( ( ) => { return mockData . fakeSequences || [ ] ; } ) } ; } ) ; jest . mock ( "s" , ( ) => { return { store : { dispatch : jest . fn ( ) , getState : jest . fn ( ( ) => ( { resources : { index : { } } } ) ) } } ; } ) ; import { setActiveSequenceByName } from "s" ; import { selectSequence } from "s" ; import { selectAllSequences } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { mockData . lastUrlChunk = "s" ; setActiveSequenceByName ( ) ; expect ( selectSequence ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const body = mockData . fakeSequences [ 0 ] . body ; const name = "s" + body . name ; mockData . lastUrlChunk = name ; setActiveSequenceByName ( ) ; expect ( selectAllSequences ) . toHaveBeenCalled ( ) ; expect ( selectSequence ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const tr = mockData . fakeSequences [ 0 ] ; const body = tr . body ; jest . clearAllTimers ( ) ; mockData . lastUrlChunk = body . name ; setActiveSequenceByName ( ) ; expect ( selectSequence ) . toHaveBeenCalledWith ( tr . uuid ) ; } ) ; } ) ;	O O $any$ O O O O O $complex$ O O $string$ O O O $any[]$ O O $any$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $complex$ O $string$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O $complex$ O $any[]$ O O O O O O O O O O O $any$ O $any$ O O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O $complex$ O O ${}$ O O O O O O O O O O O O O O O $void$ O O O O O O $SelectSequence$ O O O O O O $any[]$ O O O O $any$ O O O O O O O $any$ O O O O O O O $complex$ O $string$ O O O $void$ O O O $any$ O $SelectSequence$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $complex$ O $any[]$ O O O O $any$ O O $string$ O O O $any$ O $any$ O $complex$ O $string$ O $string$ O $void$ O O O $any$ O $any[]$ O O $any$ O O O $any$ O $SelectSequence$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $complex$ O $any[]$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O $string$ O $any$ O $any$ O $void$ O O O $any$ O $SelectSequence$ O O $any$ O $any$ O $any$ O O O O O O O O
import { Everything } from "s" ; import { Props , HardwareFlags , FarmwareConfigs } from "s" ; import { selectAllSequences , findSequence , maybeGetDevice } from "s" ; import { getStepTag } from "s" ; import { enabledAxisMap } from "s" ; import { createShouldDisplayFn as shouldDisplayFunc , determineInstalledOsVersion , validFwConfig } from "s" ; import { BooleanSetting } from "s" ; import { getWebAppConfigValue } from "s" ; import { getFirmwareConfig } from "s" ; import { Farmwares } from "s" ; import { manifestInfo } from "s" ; import { DevSettings } from "s" ; import { calculateAxialLengths } from "s" ; export function mapStateToProps ( props ) { const uuid = props . resources . consumers . sequences . current ; const sequence = uuid ? findSequence ( props . resources . index , uuid ) : undefined ; sequence && ( sequence . body . body || [ ] ) . map ( x => getStepTag ( x ) ) ; const fwConfig = validFwConfig ( getFirmwareConfig ( props . resources . index ) ) ; const { mcu_params } = props . bot . hardware ; const firmwareSettings = fwConfig || mcu_params ; const hardwareFlags = ( ) : HardwareFlags => { return { findHomeEnabled : enabledAxisMap ( firmwareSettings ) , stopAtHome : { x : ! ! firmwareSettings . movement_stop_at_home_x , y : ! ! firmwareSettings . movement_stop_at_home_y , z : ! ! firmwareSettings . movement_stop_at_home_z } , stopAtMax : { x : ! ! firmwareSettings . movement_stop_at_max_x , y : ! ! firmwareSettings . movement_stop_at_max_y , z : ! ! firmwareSettings . movement_stop_at_max_z } , negativeOnly : { x : ! ! firmwareSettings . movement_home_up_x , y : ! ! firmwareSettings . movement_home_up_y , z : ! ! firmwareSettings . movement_home_up_z } , axisLength : calculateAxialLengths ( { firmwareSettings } ) , } ; } ; const botStateFarmwares = props . bot . hardware . process_info . farmwares ; const farmwares = { } ; Object . values ( botStateFarmwares ) . map ( ( fm ) => { const info = manifestInfo ( fm ) ; farmwares [ info . name ] = manifestInfo ( fm ) ; } ) ; const farmwareNames = Object . values ( farmwares ) . map ( fw => fw . name ) ; const { firstPartyFarmwareNames } = props . resources . consumers . farmware ; const getConfig = getWebAppConfigValue ( ( ) => props ) ; const showFirstPartyFarmware = ! ! getConfig ( BooleanSetting . show_first_party_farmware ) ; const farmwareConfigs = { } ; Object . values ( farmwares ) . map ( fw => farmwareConfigs [ fw . name ] = fw . config ) ; const installedOsVersion = determineInstalledOsVersion ( props . bot , maybeGetDevice ( props . resources . index ) ) ; const fbosVersionOverride = DevSettings . overriddenFbosVersion ( ) ; const shouldDisplay = shouldDisplayFunc ( installedOsVersion , props . bot . minOsFeatureData , fbosVersionOverride ) ; return { dispatch : props . dispatch , sequences : selectAllSequences ( props . resources . index ) , sequence : sequence , resources : props . resources . index , syncStatus : ( props . bot . hardware . informational_settings . sync_status || "s" ) , hardwareFlags : hardwareFlags ( ) , farmwareInfo : { farmwareNames , firstPartyFarmwareNames , showFirstPartyFarmware , farmwareConfigs , } , shouldDisplay , getWebAppConfigValue : getConfig , menuOpen : props . resources . consumers . sequences . menuOpen , stepIndex : props . resources . consumers . sequences . stepIndex , } ; }	O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any[]$ O $any$ O $any$ O O O O O O $string$ O O O O O O $complex$ O O O O O O $boolean$ O $boolean$ O $string$ O $any$ O O O O O O $complex$ O O O O O O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $FarmwareManifestInfo$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $Props$ O $Everything$ O O O $string$ O $Everything$ O $RestResources$ O $complex$ O $SequenceReducerState$ O $string$ O O $any$ O $string$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $string$ O O $undefined$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $string$ O $any$ O O O O $any$ O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O O $any$ O O $Everything$ O $BotState$ O $any$ O O $any$ O $any$ O $any$ O O $HardwareFlags$ O O O O $any$ O O O O $complex$ O $complex$ O $any$ O O $complex$ O O $boolean$ O O O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O O $complex$ O O $boolean$ O O O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O O $complex$ O O $boolean$ O O O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O $boolean$ O O O $any$ O $any$ O O $complex$ O $complex$ O O $any$ O O O O O O O O $any$ O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O O $Farmwares$ O O O O $ObjectConstructor$ O $complex$ O $any$ O O $U[]$ O O $unknown$ O O O O $FarmwareManifestInfo$ O $FarmwareManifestInfo$ O $unknown$ O O $any$ O $FarmwareManifestInfo$ O $string$ O O $FarmwareManifestInfo$ O $unknown$ O O O O O O $any[]$ O $ObjectConstructor$ O $complex$ O $any$ O O $U[]$ O $unknown$ O $unknown$ O $any$ O O O O $string[]$ O O $Everything$ O $RestResources$ O $complex$ O $FarmwareState$ O O $complex$ O $complex$ O O O O $Everything$ O O O $boolean$ O O O $complex$ O $complex$ O $any$ O O O $FarmwareConfigs$ O O O O $ObjectConstructor$ O $complex$ O $any$ O O $U[]$ O $unknown$ O $FarmwareConfigs$ O $unknown$ O $any$ O O $unknown$ O $any$ O O O $string$ O $string$ O $Everything$ O $BotState$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O O $string$ O $any$ O $string$ O O O O $boolean$ O $boolean$ O $string$ O $Everything$ O $BotState$ O $complex$ O $string$ O O O O $Function$ O $Everything$ O $Function$ O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O $any$ O $any$ O $ResourceIndex$ O $Everything$ O $RestResources$ O $ResourceIndex$ O $any$ O O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O O O O $HardwareFlags$ O $HardwareFlags$ O O O $complex$ O O $any[]$ O $string[]$ O $boolean$ O $FarmwareConfigs$ O O O $boolean$ O $complex$ O $complex$ O $boolean$ O $Everything$ O $RestResources$ O $complex$ O $SequenceReducerState$ O $boolean$ O $number$ O $Everything$ O $RestResources$ O $complex$ O $SequenceReducerState$ O $number$ O O O O
import { mapStateToProps } from "s" ; import { fakeState } from "s" ; import { Feature } from "s" ; import { 0 } from "s" ; import { fakeSequence , fakeWebAppConfig } from "s" ; import { buildResourceIndex } from "s" ; import { TaggedSequence } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const props = fakeState ( ) ; const returnedProps = mapStateToProps ( props ) ; expect ( returnedProps . sequence ) . toEqual ( undefined ) ; expect ( returnedProps . syncStatus ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; state . bot . hardware . informational_settings . controller_version = "s" ; state . bot . minOsFeatureData = { "s" : "s" } ; const props = mapStateToProps ( state ) ; expect ( props . shouldDisplay ( "s" as any ) ) . toBeFalsy ( ) ; expect ( props . shouldDisplay ( Feature . jest_feature ) ) . toBeTruthy ( ) ; } ) ; it ( "s" , ( ) => { const sequence = fakeSequence ( ) ; sequence . body . body = [ { kind : "s" , args : { milliseconds : 0 } } ] ; const state = fakeState ( ) ; state . resources = buildResourceIndex ( [ sequence ] ) ; state . resources . consumers . sequences . current = sequence . uuid ; expect ( ( ) => mapStateToProps ( state ) ) . not . toThrowError ( ) ; const props = mapStateToProps ( state ) ; expect ( props . sequence ) . toEqual ( expect . objectContaining ( { uuid : sequence . uuid , body : expect . objectContaining ( { body : [ expect . objectContaining ( { kind : "s" , args : { milliseconds : 0 } , uuid : expect . any ( String ) } ) ] } ) } ) ) ; } ) ; it ( "s" , ( ) => { const sequence = fakeSequence ( ) ; const state = fakeState ( ) ; state . resources = buildResourceIndex ( [ sequence ] ) ; state . resources . consumers . sequences . current = sequence . uuid ; ( state . resources . index . references [ sequence . uuid ] as TaggedSequence ) . body . body = [ { kind : "s" , args : { milliseconds : 0 } } ] ; expect ( ( ) => mapStateToProps ( state ) ) . toThrowError ( "s" ) ; } ) ; it ( "s" , ( ) => { const state = fakeState ( ) ; const conf = fakeWebAppConfig ( ) ; conf . body . show_first_party_farmware = true ; state . resources = buildResourceIndex ( [ conf ] ) ; state . resources . consumers . sequences . current = undefined ; state . bot . hardware . process_info . farmwares = { "s" : 0 ( ) } ; const props = mapStateToProps ( state ) ; expect ( props . farmwareInfo . farmwareNames ) . toEqual ( [ "s" ] ) ; expect ( props . farmwareInfo . showFirstPartyFarmware ) . toEqual ( true ) ; expect ( props . farmwareInfo . farmwareConfigs ) . toEqual ( { "s" : [ { name : "s" , label : "s" , value : "s" } ] } ) ; } ) ; } ) ;	O O $Props$ O O O O O O $Everything$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $Props$ O $Props$ O $Everything$ O O $any$ O $Props$ O $any$ O O $any$ O $undefined$ O O $any$ O $Props$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O O O $Everything$ O $BotState$ O $complex$ O O O O O O O O $Props$ O $Props$ O $Everything$ O O $any$ O $Props$ O $ShouldDisplay$ O O O O O O O $any$ O O O $any$ O $Props$ O $ShouldDisplay$ O $any$ O $Feature.jest_feature$ O O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $string$ O O O $complex$ O O $number$ O O O O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O $Everything$ O $RestResources$ O $complex$ O $SequenceReducerState$ O $string$ O $any$ O $any$ O $any$ O O O O $Props$ O $Everything$ O O O $any$ O $any$ O O O O $Props$ O $Props$ O $Everything$ O O $any$ O $Props$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $string$ O O O $complex$ O O $number$ O O O O $any$ O $any$ O $any$ O $StringConstructor$ O O O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $Everything$ O $Everything$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O $Everything$ O $RestResources$ O $complex$ O $SequenceReducerState$ O $string$ O $any$ O $any$ O O $Everything$ O $RestResources$ O $ResourceIndex$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O $string$ O O O $complex$ O O $number$ O O O O O O $any$ O O O O $Props$ O $Everything$ O O O $any$ O O O O O O O $any$ O O O O O O O O $Everything$ O $Everything$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $Everything$ O $RestResources$ O $any$ O O $any$ O O O $Everything$ O $RestResources$ O $complex$ O $SequenceReducerState$ O $string$ O $undefined$ O $Everything$ O $BotState$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $Props$ O $Props$ O $Everything$ O O $any$ O $Props$ O $FarmwareInfo$ O $string[]$ O O $any$ O O O O O O $any$ O $Props$ O $FarmwareInfo$ O $boolean$ O O $any$ O O O O $any$ O $Props$ O $FarmwareInfo$ O $FarmwareConfigs$ O O $any$ O O O O O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O O O
import { convertDDItoVariable , NOTHING_SELECTED } from "s" ; import { Point , Tool , Coordinate } from "s" ; import { NO_VALUE_SELECTED_DDI , COORDINATE_DDI } from "s" ; import { VariableNode , AllowedVariableNodes } from "s" ; const label = "s" ; const allowedVariableNodes = AllowedVariableNodes . variable ; const expectedVariable = ( data_value : Point | Tool | Coordinate ) => ( { kind : "s" , args : { label , data_value } } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = convertDDItoVariable ( { identifierLabel : "s" , allowedVariableNodes , dropdown : { headingId : "s" , label : "s" , value : 0 } } ) ; expect ( result ) . toEqual ( undefined ) ; } ) ; it ( "s" , ( ) => { const result = convertDDItoVariable ( { identifierLabel : "s" , allowedVariableNodes , dropdown : { headingId : "s" , label : "s" , value : 0 } } ) ; expect ( result ) . toEqual ( { kind : "s" , args : { label : "s" , data_value : { kind : "s" , args : { point_group_id : 0 } } } } ) ; } ) ; it ( "s" , ( ) => { const dropdown = ( { headingId : "s" , label : "s" , value : 0 } ) ; const variable = convertDDItoVariable ( { identifierLabel : label , allowedVariableNodes , dropdown } ) ; expect ( variable ) . toEqual ( expectedVariable ( { kind : "s" , args : { pointer_id : 0 , pointer_type : "s" } } ) ) ; } ) ; it ( "s" , ( ) => { const dropdown = { headingId : "s" , label : "s" , value : 0 } ; const variable = convertDDItoVariable ( { identifierLabel : label , allowedVariableNodes , dropdown } ) ; expect ( variable ) . toEqual ( expectedVariable ( { kind : "s" , args : { tool_id : 0 } } ) ) ; } ) ; it ( "s" , ( ) => { const dropdown = { headingId : "s" , label : "s" , value : 0 } ; const variable = convertDDItoVariable ( { identifierLabel : label , allowedVariableNodes , dropdown } ) ; expect ( variable ) . toEqual ( expectedVariable ( { kind : "s" , args : { pointer_id : 0 , pointer_type : "s" } } ) ) ; } ) ; it ( "s" , ( ) => { const variable = convertDDItoVariable ( { identifierLabel : label , allowedVariableNodes , dropdown : NO_VALUE_SELECTED_DDI ( ) } ) ; expect ( variable ) . toEqual ( expectedVariable ( NOTHING_SELECTED ) ) ; } ) ; it ( "s" , ( ) => { const expected = expectedVariable ( NOTHING_SELECTED ) ; expected . kind = "s" ; const variable = convertDDItoVariable ( { identifierLabel : label , allowedVariableNodes : AllowedVariableNodes . parameter , dropdown : NO_VALUE_SELECTED_DDI ( ) } ) ; expect ( variable ) . toEqual ( expected ) ; } ) ; it ( "s" , ( ) => { const variable = convertDDItoVariable ( { identifierLabel : label , allowedVariableNodes , dropdown : COORDINATE_DDI ( { x : 0 , y : 0 , z : 0 } ) } ) ; expect ( variable ) . toEqual ( expectedVariable ( { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } ) ) ; } ) ; it ( "s" , ( ) => { const variable = convertDDItoVariable ( { identifierLabel : label , allowedVariableNodes , dropdown : COORDINATE_DDI ( ) } ) ; expect ( variable ) . toEqual ( expectedVariable ( { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } ) ) ; } ) ; it ( "s" , ( ) => { const dropdown = ( { headingId : "s" , label : "s" , value : "s" } ) ; const variable = convertDDItoVariable ( { identifierLabel : "s" , allowedVariableNodes , dropdown } ) ; const expected = { kind : "s" , args : { label : "s" , default_value : NOTHING_SELECTED } } ; expect ( variable ) . toEqual ( expected ) ; } ) ; it ( "s" , ( ) => { const dropdown = ( { headingId : "s" , label : "s" , value : "s" } ) ; const variable = convertDDItoVariable ( { identifierLabel : "s" , allowedVariableNodes : AllowedVariableNodes . identifier , dropdown } ) ; const expected = { kind : "s" , args : { label : "s" , data_value : { kind : "s" , args : { label : "s" } } } } ; expect ( variable ) . toEqual ( expected ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $DropDownItem$ O $DropDownItem$ O O O O O O $any$ O $any$ O O O O O O O O O O $AllowedVariableNodes.variable$ O $any$ O $AllowedVariableNodes.variable$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $complex$ O O $string$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O $AllowedVariableNodes.variable$ O $complex$ O O $string$ O O O $string$ O O O $number$ O O O O O O $any$ O $any$ O O $any$ O $undefined$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O $AllowedVariableNodes.variable$ O $complex$ O O $string$ O O O $string$ O O O $number$ O O O O O O $any$ O $any$ O O $any$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O O O O O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $number$ O O O O O O $any$ O $any$ O O $string$ O O O $AllowedVariableNodes.variable$ O $complex$ O O O $any$ O $any$ O O $any$ O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $string$ O O O O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O O O $any$ O $any$ O O $string$ O O O $AllowedVariableNodes.variable$ O $complex$ O O O $any$ O $any$ O O $any$ O $complex$ O O $string$ O O O $complex$ O O $number$ O O O O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O O O $any$ O $any$ O O $string$ O O O $AllowedVariableNodes.variable$ O $complex$ O O O $any$ O $any$ O O $any$ O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $string$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O $AllowedVariableNodes.variable$ O $DropDownItem$ O $DropDownItem$ O O O O O $any$ O $any$ O O $any$ O $complex$ O $any$ O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O $any$ O O $complex$ O $string$ O O O O $any$ O $any$ O O $string$ O O O $AllowedVariableNodes.parameter$ O $any$ O $AllowedVariableNodes.parameter$ O $DropDownItem$ O $DropDownItem$ O O O O O $any$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O $AllowedVariableNodes.variable$ O $DropDownItem$ O $DropDownItem$ O O $number$ O O O $number$ O O O $number$ O O O O O O O $any$ O $any$ O O $any$ O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O $AllowedVariableNodes.variable$ O $DropDownItem$ O $DropDownItem$ O O O O O $any$ O $any$ O O $any$ O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O $string$ O O O $AllowedVariableNodes.variable$ O $complex$ O O O O $VariableNode$ O O $string$ O O O $complex$ O O $string$ O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O $string$ O O O $AllowedVariableNodes.identifier$ O $any$ O $AllowedVariableNodes.identifier$ O $complex$ O O O O $VariableNode$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O
import { TaggedSequence } from "s" ; export function isParameterized ( s : TaggedSequence [ "s" ] ) { const array = ( s . args . locals . body || [ ] ) ; const 0 = array . filter ( x => x . kind === "s" ) [ 0 ] ; return ! ! 0 ; }	O O $any$ O O O O O O $boolean$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O
import { fakeSequence } from "s" ; import { TaggedSequence } from "s" ; import { isParameterized } from "s" ; type Sequence = TaggedSequence [ "s" ] ; type Locals = Sequence [ "s" ] [ "s" ] [ "s" ] ; describe ( "s" , ( ) => { function sequence ( decl ) { const { body } = fakeSequence ( ) ; body . args . locals . body = decl ; return body ; } it ( "s" , ( ) => { const hasParent = sequence ( [ { kind : "s" , args : { label : "s" , default_value : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } } } ] ) ; expect ( isParameterized ( hasParent ) ) . toBeTruthy ( ) ; } ) ; it ( "s" , ( ) => { expect ( isParameterized ( sequence ( undefined ) ) ) . toBeFalsy ( ) ; expect ( isParameterized ( sequence ( [ ] ) ) ) . toBeFalsy ( ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $boolean$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O O $Sequence$ O $Locals$ O O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O O O O O O $any$ O $any$ O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O O $any$ O $boolean$ O $any$ O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $boolean$ O $any$ O $undefined$ O O O O $any$ O O O $any$ O $boolean$ O $any$ O O O O O O O $any$ O O O O O O O O O
import { localListCallback } from "s" ; import { fakeSequence } from "s" ; import { ParameterDeclaration , VariableDeclaration } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const sequence = fakeSequence ( ) ; const dispatch = jest . fn ( ) ; const cb = localListCallback ( { sequence , dispatch } ) ; const parameterDeclaration = { kind : "s" , args : { label : "s" , default_value : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } } } ; const variableDeclaration = { kind : "s" , args : { label : "s" , data_value : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } } } ; cb ( [ parameterDeclaration , variableDeclaration ] ) ( { kind : "s" , args : { label : "s" , data_value : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } } } ) ; const action = expect . objectContaining ( { type : "s" } ) ; expect ( dispatch ) . toHaveBeenCalledWith ( action ) ; expect ( dispatch ) . toHaveBeenCalledWith ( expect . objectContaining ( { payload : expect . objectContaining ( { uuid : sequence . uuid } ) } ) ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O O $ParameterDeclaration$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O $VariableDeclaration$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O $any$ O O $any$ O $any$ O O O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O
import { inputEvent } from "s" ; import { ParameterApplication } from "s" ; import { AxisEditProps , manuallyEditAxis } from "s" ; import { VariableNode } from "s" ; const isParameterApplication = ( x ) : x is ParameterApplication => x . kind === "s" ; describe ( "s" , ( ) => { const fakeProps = ( ) : AxisEditProps => ( { axis : "s" , onChange : jest . fn ( ) , editableVariable : { kind : "s" , args : { label : "s" , data_value : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } } } , } ) ; it ( "s" , ( ) => { const expected = fakeProps ( ) ; if ( isParameterApplication ( expected . editableVariable ) && expected . editableVariable . args . data_value . kind === "s" ) { expected . editableVariable . args . data_value . args . x = 0 ; } const p = fakeProps ( ) ; manuallyEditAxis ( p ) ( inputEvent ( "s" ) ) ; expect ( p . onChange ) . toHaveBeenCalledWith ( expected . editableVariable ) ; } ) ; it ( "s" , ( ) => { const p = fakeProps ( ) ; p . editableVariable . args = { label : "s" , data_value : { kind : "s" , args : { label : "s" } } } ; manuallyEditAxis ( p ) ( inputEvent ( "s" ) ) ; expect ( p . onChange ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $complex$ O O $VariableNode$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O O O O O $any$ O O O O $any$ O O O $string$ O O O $any$ O $any$ O $any$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $complex$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O
import { buildResourceIndex } from "s" ; import { ResourceIndex } from "s" ; import { TaggedResource } from "s" ; import { newTaggedResource } from "s" ; export function fakeResourceIndex ( ) { const fakeResources : TaggedResource [ ] = [ ... newTaggedResource ( "s" , { "s" : 0 , "s" : { } , "s" : "s" , "s" : "s" , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : "s" , "s" : "s" } ) , ... newTaggedResource ( "s" , { "s" : 0 , "s" : { } , "s" : "s" , "s" : "s" , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 } ) , ... newTaggedResource ( "s" , { "s" : 0 , "s" : { } , "s" : "s" , "s" : "s" , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , "s" : false , } ) , ... newTaggedResource ( "s" , { "s" : 0 , "s" : { } , "s" : "s" , "s" : "s" , "s" : "s" , "s" : "s" , "s" : 0 , "s" : 0 , "s" : 0 , "s" : 0 , } ) , ... newTaggedResource ( "s" , { "s" : 0 , "s" : "s" , "s" : "s" } ) ] ; return buildResourceIndex ( fakeResources ) . index ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $T[]$ O O O O O O $ResourceIndex$ O O O O $any[]$ O $any$ O O O O O $T[]$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $T[]$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $T[]$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $T[]$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $T[]$ O O O O O O O O O O O O O O O O O O O O $any$ O $any[]$ O O $any$ O O
import { locationFormList , dropDownName , formatTool , 0 } from "s" ; import { fakeResourceIndex } from "s" ; import { fakeToolSlot , fakeTool , fakePointGroup } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const items = locationFormList ( fakeResourceIndex ( ) , [ ] ) ; const coordinate = items [ 0 ] ; expect ( coordinate ) . toEqual ( { headingId : "s" , label : "s" , value : "s" , } ) ; const toolHeading = items [ 0 ] ; expect ( toolHeading ) . toEqual ( { headingId : "s" , label : "s" , value : 0 , heading : true , } ) ; const tool = items [ 0 ] ; expect ( tool ) . toEqual ( { headingId : "s" , label : "s" , value : "s" , } ) ; const plantHeading = items [ 0 ] ; expect ( plantHeading ) . toEqual ( { headingId : "s" , label : "s" , value : 0 , heading : true , } ) ; const plant = items [ 0 ] ; expect ( plant ) . toEqual ( { headingId : "s" , label : "s" , value : "s" } ) ; const pointHeading = items [ 0 ] ; expect ( pointHeading ) . toEqual ( { headingId : "s" , label : "s" , value : 0 , heading : true , } ) ; const point = items [ 0 ] ; expect ( point ) . toEqual ( { headingId : "s" , label : "s" , value : "s" } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const ddi = formatTool ( fakeTool ( ) , fakeToolSlot ( ) ) ; expect ( ddi . label ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const toolSlot = fakeToolSlot ( ) ; toolSlot . body . gantry_mounted = true ; const ddi = formatTool ( fakeTool ( ) , toolSlot ) ; expect ( ddi . label ) . toEqual ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const label = dropDownName ( "s" , { x : 0 , y : 0 , z : 0 } ) ; expect ( label ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const label = dropDownName ( "s" , { x : 0 , y : 0 , z : 0 } ) ; expect ( label ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const label = dropDownName ( "s" , { x : undefined , y : undefined , z : undefined } ) ; expect ( label ) . toEqual ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const fakes = [ fakePointGroup ( ) , fakePointGroup ( ) ] ; fakes [ 0 ] . body . id = 0 ; fakes [ 0 ] . body . id = undefined ; const result = 0 ( fakes ) ; expect ( result . length ) . toEqual ( 0 ) ; expect ( result [ 0 ] . label ) . toEqual ( fakes [ 0 ] . body . name ) ; expect ( result [ 0 ] . value ) . toEqual ( "s" ) ; } ) ; } ) ;	O O $DropDownItem[]$ O $any$ O $DropDownItem$ O $DropDownItem[]$ O O O O O O $ResourceIndex$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $DropDownItem[]$ O $DropDownItem[]$ O $ResourceIndex$ O O O O O O O O $DropDownItem$ O $DropDownItem[]$ O O O O $any$ O $DropDownItem$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $DropDownItem$ O $DropDownItem[]$ O O O O $any$ O $DropDownItem$ O O $any$ O O $string$ O O O $string$ O O O $number$ O O O $boolean$ O O O O O O O $DropDownItem$ O $DropDownItem[]$ O O O O $any$ O $DropDownItem$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $DropDownItem$ O $DropDownItem[]$ O O O O $any$ O $DropDownItem$ O O $any$ O O $string$ O O O $string$ O O O $number$ O O O $boolean$ O O O O O O O $DropDownItem$ O $DropDownItem[]$ O O O O $any$ O $DropDownItem$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O O $DropDownItem$ O $DropDownItem[]$ O O O O $any$ O $DropDownItem$ O O $any$ O O $string$ O O O $string$ O O O $number$ O O O $boolean$ O O O O O O O $DropDownItem$ O $DropDownItem[]$ O O O O $any$ O $DropDownItem$ O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $DropDownItem$ O $DropDownItem$ O $any$ O O O $any$ O O O O $any$ O $DropDownItem$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $DropDownItem$ O $DropDownItem$ O $any$ O O O $any$ O O $any$ O $DropDownItem$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $number$ O O O $number$ O O O $number$ O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $number$ O O O $number$ O O O $number$ O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any[]$ O O $any$ O O O $any$ O O O O $any[]$ O O O O $any$ O $any$ O O O $any[]$ O O O O $any$ O $any$ O $undefined$ O O $DropDownItem[]$ O $DropDownItem[]$ O $any[]$ O O $any$ O $DropDownItem[]$ O $number$ O O $any$ O O O O $any$ O $DropDownItem[]$ O O O O $string$ O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O $DropDownItem[]$ O O O O $complex$ O O $any$ O O O O O O O O O O
import { fakeSequence } from "s" ; import { MoveAbsolute } from "s" ; import { sanitizeNodes } from "s" ; import { get } from "s" ; describe ( "s" , ( ) => { const move_abs = { kind : "s" , args : { location : { kind : "s" , args : { label : "s" } } , offset : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } , speed : 0 } } ; it ( "s" , ( ) => { const unusedVar = fakeSequence ( ) . body ; expect ( unusedVar . args . locals . body ) . toBeUndefined ( ) ; unusedVar . body = [ ] ; unusedVar . args . locals = { kind : "s" , args : { } , body : [ { kind : "s" , args : { default_value : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } , label : "s" } } ] } ; const result = sanitizeNodes ( unusedVar ) ; const locals = result . thisSequence . args . locals . body ; if ( locals ) { expect ( locals [ 0 ] ) . not . toBeDefined ( ) ; } else { fail ( "s" ) ; } } ) ; it ( "s" , ( ) => { const missing_declaration = fakeSequence ( ) . body ; expect ( missing_declaration . args . locals . body ) . toBeUndefined ( ) ; missing_declaration . body = [ move_abs ] ; missing_declaration . args . locals = { kind : "s" , args : { } , body : [ ] } ; sanitizeNodes ( missing_declaration ) ; const locals = missing_declaration . args . locals . body ; if ( locals ) { expect ( locals [ 0 ] ) . toBeDefined ( ) ; expect ( get ( locals [ 0 ] , "s" ) ) . toBeDefined ( ) ; expect ( locals [ 0 ] . args . label ) . toEqual ( "s" ) ; } else { fail ( "s" ) ; } } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $SanitizationResult$ O O O O O O $any$ O O O O $any$ O O O O O O O O $MoveAbsolute$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O $number$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O O O ${}$ O O O O $complex$ O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O $string$ O O O O O O O O $SanitizationResult$ O $SanitizationResult$ O $any$ O O O $any$ O $SanitizationResult$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O $string$ O O O ${}$ O O O O $undefined[]$ O O O O O $SanitizationResult$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O
import { variableList , mergeParameterApplications , getRegimenVariableData } from "s" ; import { fakeVariableNameSet } from "s" ; import { ParameterApplication , ParameterDeclaration , ScopeDeclarationBodyItem , Coordinate , VariableDeclaration } from "s" ; import { cloneDeep } from "s" ; import { buildResourceIndex } from "s" ; const COORDINATE = { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } ; const coordinateVar = ( label ) : ParameterApplication => ( { kind : "s" , args : { label , data_value : COORDINATE } } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = variableList ( undefined ) ; expect ( result ) . toEqual ( undefined ) ; } ) ; it ( "s" , ( ) => { const result = variableList ( { 0 : { celeryNode : { kind : "s" , args : { label : "s" , default_value : COORDINATE } } , dropdown : { label : "s" , value : "s" } , vector : undefined , } , 0 : { celeryNode : coordinateVar ( "s" ) , dropdown : { label : "s" , value : "s" } , vector : COORDINATE . args , } } ) ; expect ( result ) . toEqual ( [ { kind : "s" , args : { label : "s" , data_value : COORDINATE } } ] ) ; } ) ; } ) ; describe ( "s" , ( ) => { const bodyVariables : ParameterApplication [ ] = [ coordinateVar ( "s" ) , coordinateVar ( "s" ) , ] ; it ( "s" , ( ) => { const varData = fakeVariableNameSet ( "s" ) ; const result = mergeParameterApplications ( varData , bodyVariables ) ; expect ( result ) . toEqual ( bodyVariables ) ; } ) ; it ( "s" , ( ) => { const varData = fakeVariableNameSet ( "s" ) ; const notAdded = "s" ; varData [ notAdded ] = fakeVariableNameSet ( notAdded ) [ notAdded ] ; const label = "s" ; const add = fakeVariableNameSet ( label ) [ label ] ; const addedNewDecl = { kind : "s" , args : { label , default_value : COORDINATE } } ; add && ( add . celeryNode = addedNewDecl ) ; varData [ label ] = add ; const expected = cloneDeep ( bodyVariables ) ; expected . push ( { kind : "s" , args : { label , data_value : COORDINATE } } ) ; const result = mergeParameterApplications ( varData , bodyVariables ) ; expect ( result ) . toEqual ( expected ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const varDeclaration = { kind : "s" , args : { label : "s" , data_value : COORDINATE } } ; const paramDeclaration = { kind : "s" , args : { label : "s" , default_value : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } } } ; const bodyVariables : ScopeDeclarationBodyItem [ ] = [ varDeclaration , paramDeclaration ] ; const result = getRegimenVariableData ( bodyVariables , buildResourceIndex ( ) . index ) ; expect ( result ) . toEqual ( { 0 : { celeryNode : paramDeclaration , dropdown : { label : "s" , value : "s" } , vector : undefined } , 0 : { celeryNode : varDeclaration , dropdown : { label : "s" , value : expect . any ( String ) , headingId : "s" , } , vector : COORDINATE . args } } ) ; } ) ; } ) ;	O O $any[]$ O $any[]$ O $complex$ O O O O O O $complex$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $Coordinate$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O $any$ O O $string$ O O $any$ O O O $string$ O O O $complex$ O O $string$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any[]$ O $any[]$ O $undefined$ O O $any$ O $any[]$ O O $any$ O $undefined$ O O O O O $any$ O O O O O O O O $any[]$ O $any[]$ O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $any$ O $any$ O O O $complex$ O O $string$ O O O $string$ O O O O $undefined$ O $undefined$ O O O $complex$ O O $any$ O $any$ O O O O $complex$ O O $string$ O O O $string$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any[]$ O O $any$ O O O $string$ O O O $complex$ O O $string$ O O O $any$ O $any$ O O O O O O O O O O O $any$ O O O O O O O O $any[]$ O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O O O $any[]$ O $any[]$ O $complex$ O $any[]$ O O $any$ O $any[]$ O O $any$ O $any[]$ O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O O O O O O O $complex$ O O O O $complex$ O O O O O O O O O O O O O $SequenceMeta$ O $complex$ O O O O O O O O $ParameterDeclaration$ O O $string$ O O O $complex$ O O $string$ O $any$ O $any$ O O O $SequenceMeta$ O O $SequenceMeta$ O $any$ O $any$ O O $complex$ O O O O $SequenceMeta$ O O $any$ O $any$ O $any[]$ O O $any$ O $any$ O O $string$ O O O $complex$ O O $string$ O $any$ O $any$ O O O O O $any[]$ O $any[]$ O $complex$ O $any[]$ O O $any$ O $any[]$ O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $VariableDeclaration$ O O $string$ O O O $complex$ O O $string$ O O O $any$ O $any$ O O O O $ParameterDeclaration$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O O $any[]$ O $any$ O O O O $any$ O $any$ O O O $complex$ O $complex$ O $any[]$ O $any$ O O O $any$ O O $any$ O $complex$ O O $any$ O O $complex$ O O $any$ O $any$ O $complex$ O O $string$ O O O $string$ O O O O $undefined$ O $undefined$ O O $complex$ O O $any$ O $any$ O $complex$ O O $string$ O O O $any$ O $any$ O $any$ O $StringConstructor$ O O $string$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O
jest . mock ( "s" , ( ) => ( { overwrite : jest . fn ( ) , } ) ) ; import { remove , move , splice , renderCeleryNode } from "s" ; import { fakeSequence } from "s" ; import { overwrite } from "s" ; import { Wait , If , ExecuteScript , Execute , FindHome , MoveAbsolute , SendMessage , TakePhoto , SetServoAngle , TogglePin , Zero , Calibrate , Home , Reboot , CheckUpdates , FactoryReset , Sync , DumpInfo , PowerOff , ReadStatus , EmergencyLock , EmergencyUnlock , InstallFirstPartyFarmware } from "s" ; import { mount } from "s" ; import { StepParams , MessageType } from "s" ; import { emptyState } from "s" ; describe ( "s" , ( ) => { const fakeProps = ( ) => ( { index : 0 , dispatch : jest . fn ( ) , sequence : fakeSequence ( ) , confirmStepDeletion : false , } ) ; it ( "s" , ( ) => { const p = fakeProps ( ) ; remove ( p ) ; expect ( p . dispatch ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const p = fakeProps ( ) ; p . confirmStepDeletion = true ; window . confirm = jest . fn ( ) ; remove ( p ) ; expect ( window . confirm ) . toHaveBeenCalledWith ( expect . stringContaining ( "s" ) ) ; expect ( p . dispatch ) . not . toHaveBeenCalled ( ) ; window . confirm = jest . fn ( ( ) => true ) ; remove ( p ) ; expect ( p . dispatch ) . toHaveBeenCalled ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { const sequence = fakeSequence ( ) ; const 0 = { kind : "s" , args : { milliseconds : 0 } } ; const 0 = { kind : "s" , args : { milliseconds : 0 } } ; sequence . body . body = [ 0 , 0 ] ; const fakeProps = ( ) => ( { step : 0 , sequence , to : 0 , from : 0 , } ) ; it ( "s" , ( ) => { const p = fakeProps ( ) ; p . from = 0 ; p . to = 0 ; move ( p ) ; expect ( overwrite ) . toHaveBeenCalledWith ( expect . any ( Object ) , expect . objectContaining ( { body : [ 0 , 0 ] } ) ) ; } ) ; it ( "s" , ( ) => { const p = fakeProps ( ) ; p . sequence . body . body = [ 0 , 0 ] ; p . from = 0 ; p . to = 0 ; move ( p ) ; expect ( overwrite ) . toHaveBeenCalledWith ( expect . any ( Object ) , expect . objectContaining ( { body : [ 0 , 0 ] } ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { const sequence = fakeSequence ( ) ; const step = { kind : "s" , args : { milliseconds : 0 } } ; const fakeProps = ( ) => ( { step , sequence , index : 0 , } ) ; it ( "s" , ( ) => { const p = fakeProps ( ) ; splice ( p ) ; expect ( overwrite ) . toHaveBeenCalledWith ( expect . any ( Object ) , expect . objectContaining ( { body : expect . any ( Array ) } ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { const currentStep = { kind : "s" , args : { milliseconds : 0 } } ; const fakeProps = ( ) : StepParams => ( { currentSequence : fakeSequence ( ) , currentStep : currentStep , dispatch : jest . fn ( ) , index : 0 , resources : emptyState ( ) . index , confirmStepDeletion : false , } ) ; const TEST_DATA = [ { node : { kind : "s" , args : { lhs : "s" , op : "s" , rhs : 0 , _then : { kind : "s" , args : { } } , _else : { kind : "s" , args : { } } } } as If , expected : "s" } , { node : { kind : "s" , args : { label : "s" } } as ExecuteScript , expected : "s" } , { node : { kind : "s" , args : { sequence_id : 0 } } as Execute , expected : "s" } , { node : { kind : "s" , args : { speed : 0 , axis : "s" } } as FindHome , expected : "s" } , { node : { kind : "s" , args : { location : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } , speed : 0 , offset : { kind : "s" , args : { x : 0 , y : 0 , z : 0 } } } } as MoveAbsolute , expected : "s" } , { node : { kind : "s" , args : { message : "s" , message_type : MessageType . info } } as SendMessage , expected : "s" } , { node : { kind : "s" , args : { } } as TakePhoto , expected : "s" } , { node : { kind : "s" , args : { milliseconds : 0 } } as Wait , expected : "s" } , { node : { kind : "s" , args : { pin_number : 0 , pin_value : 0 , } } as SetServoAngle , expected : "s" } , { node : { kind : "s" , args : { pin_number : 0 } } as TogglePin , expected : "s" } , { node : { kind : "s" , args : { axis : "s" } } as Zero , expected : "s" } , { node : { kind : "s" , args : { axis : "s" } } as Calibrate , expected : "s" } , { node : { kind : "s" , args : { axis : "s" , speed : 0 , } } as Home , expected : "s" } , { node : { kind : "s" , args : { package : "s" } } as Reboot , expected : "s" } , { node : { kind : "s" , args : { package : "s" } } as CheckUpdates , expected : "s" } , { node : { kind : "s" , args : { package : "s" } } as FactoryReset , expected : "s" } , { node : { kind : "s" , args : { } } as Sync , expected : "s" } , { node : { kind : "s" , args : { } } as DumpInfo , expected : "s" } , { node : { kind : "s" , args : { } } as PowerOff , expected : "s" } , { node : { kind : "s" , args : { } } as ReadStatus , expected : "s" } , { node : { kind : "s" , args : { } } as EmergencyLock , expected : "s" } , { node : { kind : "s" , args : { } } as EmergencyUnlock , expected : "s" } , { node : { kind : "s" , args : { } } as InstallFirstPartyFarmware , expected : "s" } , { node : { kind : "s" , args : { unknown : 0 } } as any , expected : "s" } , ] ; it ( "s" , ( ) => { TEST_DATA . map ( test => { const p = fakeProps ( ) ; p . currentStep = test . node ; const step = renderCeleryNode ( p ) ; expect ( mount ( step ) . text ( ) ) . toContain ( test . expected ) ; } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $RestResources$ O O O O $any$ O O O O O O O O $complex$ O O O O O O $number$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $boolean$ O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $any$ O $complex$ O O $any$ O $complex$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $complex$ O $boolean$ O O O $complex$ O $boolean)$ O $any$ O $any$ O O O $any$ O $complex$ O O $any$ O $complex$ O $boolean)$ O O $any$ O $any$ O $any$ O O O O O $any$ O $complex$ O $any$ O O $any$ O $any$ O O O $complex$ O $boolean)$ O $any$ O $any$ O O O O O O O $any$ O $complex$ O O $any$ O $complex$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $Wait$ O O $string$ O O O $complex$ O O $number$ O O O O O O $Wait$ O O $string$ O O O $complex$ O O $number$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $complex$ O O O O O O $any$ O $any$ O $any$ O $number$ O O O $number$ O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $complex$ O $number$ O O O $complex$ O $number$ O O O $any$ O $complex$ O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O $any$ O $ObjectConstructor$ O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $complex$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O $complex$ O $number$ O O O $complex$ O $number$ O O O $any$ O $complex$ O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O $any$ O $ObjectConstructor$ O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $Wait$ O O $string$ O O O $complex$ O O $number$ O O O O O O $complex$ O O O O O O $any$ O $any$ O $number$ O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O $any$ O $complex$ O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O $any$ O $ObjectConstructor$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O $ArrayConstructor$ O O O O O O O O O O O $any$ O O O O O O O O $Wait$ O O $string$ O O O $complex$ O O $number$ O O O O O O $StepParams$ O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $number$ O O O $ResourceIndex$ O $RestResources$ O O O $ResourceIndex$ O $false$ O O O O O O O $complex$ O O O $any$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $complex$ O O $string$ O O O ${}$ O O O O O $complex$ O O $string$ O O O ${}$ O O O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $string$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $number$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $number$ O O O $string$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O $number$ O O O $complex$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O $number$ O O O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $string$ O O O $MessageType$ O $any$ O $MessageType.info$ O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O ${}$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $number$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $number$ O O O $number$ O O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $number$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $string$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $string$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $string$ O O O $number$ O O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $string$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $string$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $string$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O ${}$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O ${}$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O ${}$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O ${}$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O ${}$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O ${}$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O ${}$ O O O O O $any$ O $string$ O O O O O $any$ O O $string$ O O O $complex$ O O $number$ O O O O O O O $string$ O O O O O O $any$ O O O O O O O $complex$ O $U[]$ O $complex$ O O O $StepParams$ O $StepParams$ O O O $StepParams$ O $any$ O $complex$ O $any$ O O $any$ O $any$ O $StepParams$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $complex$ O $string$ O O O O O O O O O O O
import { ResourceIndex } from "s" ; import { DropDownItem } from "s" ; import { ResourceUpdate , TaggedSequence } from "s" ; export type ListBuilder = ( i ) => DropDownItem [ ] ; export type ResourceUpdateArgs = Partial < ResourceUpdate [ "s" ] > ; export interface MarkAsEditProps { nextAction : DropDownItem ; nextResource : DropDownItem | undefined ; step : ResourceUpdate ; index : number ; sequence : TaggedSequence } export interface StepWithResourceIndex { step : ResourceUpdate ; resourceIndex : ResourceIndex ; } export interface DropDownPair { leftSide : DropDownItem ; rightSide : DropDownItem ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $ResourceIndex$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $DropDownItem$ O $any$ O $DropDownItem$ O $any$ O O O $any$ O $any$ O $number$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $ResourceIndex$ O $any$ O O O O $any$ O $DropDownItem$ O $any$ O $DropDownItem$ O $any$ O O
import { DropDownItem } from "s" ; import { t } from "s" ; export const MOUNTED_TO = t ( "s" ) ; export const DISMOUNT = { label : t ( "s" ) , value : 0 } ; export const POINT_OPTIONS : DropDownItem [ ] = [ { label : t ( "s" ) , value : "s" } ] ; export const PLANT_OPTIONS : DropDownItem [ ] = [ { label : t ( "s" ) , value : "s" } , { label : t ( "s" ) , value : "s" } , { label : t ( "s" ) , value : "s" } , { label : t ( "s" ) , value : "s" } , ] ; const value = 0 ; export const PLANT_HEADER = { headingId : "s" , label : t ( "s" ) , value , heading : true } ; export const POINT_HEADER = { headingId : "s" , label : t ( "s" ) , value , heading : true } ; export const TOP_HALF = [ { headingId : "s" , label : t ( "s" ) , value , heading : true , } , { headingId : "s" , label : t ( "s" ) , value } ] ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $DropDownItem$ O O $any$ O $any$ O O O O $number$ O O O O O O $DropDownItem[]$ O $any$ O O O O O $any$ O $any$ O O O O $string$ O O O O O O O $DropDownItem[]$ O $any$ O O O O O $any$ O $any$ O O O O $string$ O O O O O $any$ O $any$ O O O O $string$ O O O O O $any$ O $any$ O O O O $string$ O O O O O $any$ O $any$ O O O O $string$ O O O O O O O O O O O O O $DropDownItem$ O O $string$ O O O $any$ O $any$ O O O O $number$ O $true$ O O O O O O $DropDownItem$ O O $string$ O O O $any$ O $any$ O O O O $number$ O $true$ O O O O O O $complex$ O O O $string$ O O O $any$ O $any$ O O O O $number$ O $boolean$ O O O O O O $string$ O O O $any$ O $any$ O O O O $number$ O O O
import { Dictionary } from "s" ; import { DropDownItem } from "s" ; import { ListBuilder } from "s" ; import { ResourceIndex } from "s" ; import { ResourceUpdate } from "s" ; import { selectAllTools } from "s" ; import { MOUNTED_TO , DISMOUNT , PLANT_OPTIONS , POINT_OPTIONS } from "s" ; const allToolsAsDDI = ( i ) => { return selectAllTools ( i ) . filter ( x => ! ! x . body . id ) . map ( x => { return { label : `template` , value : x . body . id || 0 } ; } ) ; } ; const DEFAULT = "s" ; const ACTION_LIST < ListBuilder > = { "s" : ( i ) => [ DISMOUNT , ... allToolsAsDDI ( i ) ] , "s" : ( ) => PLANT_OPTIONS , "s" : ( ) => POINT_OPTIONS , [ DEFAULT ] : ( ) => [ ] } ; const getList = ( t = DEFAULT ) : ListBuilder => ( ACTION_LIST [ t ] || ACTION_LIST [ DEFAULT ] ) ; export const actionList = ( d : DropDownItem | undefined , r , i ) : DropDownItem [ ] => { return getList ( d ? d . headingId : r . args . resource_type ) ( i ) ; } ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any[]$ O O O O O O $any$ O $DropDownItem$ O $DropDownItem[]$ O $DropDownItem[]$ O O O O O $complex$ O O $ResourceIndex$ O O O O $any[]$ O $ResourceIndex$ O O $complex$ O $any$ O O O $any$ O $any$ O $any$ O O $U[]$ O $any$ O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $Dictionary$ O $any$ O O O O O O $any$ O O O $DropDownItem$ O O $complex$ O $any$ O O O O O O O O $DropDownItem[]$ O O O O O O $DropDownItem[]$ O O O O O O O O O O O O O $ListBuilder$ O O $string$ O O O O $any$ O O $any$ O $string$ O O $any$ O O O O O O O $DropDownItem[]$ O O $DropDownItem$ O $any$ O O O $ResourceUpdate$ O $ResourceIndex$ O O $any$ O O O O O $ListBuilder$ O $DropDownItem$ O $DropDownItem$ O $string$ O $any$ O $any$ O $any$ O O $ResourceIndex$ O O O O
import { ResourceUpdate , TaggedSequence , resource_type } from "s" ; import { buildResourceIndex } from "s" ; import { fakeTool , fakePlant , fakePoint , fakeSequence } from "s" ; import { betterMerge } from "s" ; import { MarkAs } from "s" ; import { ResourceUpdateArgs } from "s" ; export function resourceUpdate ( i ) { return { kind : "s" , args : { resource_type : "s" as resource_type , resource_id : 0 , label : "s" , value : "s" , ... i } } ; } export const markAsResourceFixture = ( ) => buildResourceIndex ( [ betterMerge ( fakeTool ( ) , { body : { name : "s" , id : 0 } } ) , fakePlant ( ) , betterMerge ( fakeTool ( ) , { body : { name : "s" , id : 0 } } ) , betterMerge ( fakePoint ( ) , { body : { name : "s" , id : 0 } } ) , betterMerge ( fakeTool ( ) , { body : { name : "s" , id : undefined } } ) , ] ) ; export function fakeMarkAsProps ( ) { const steps : TaggedSequence [ "s" ] [ "s" ] = [ { kind : "s" , args : { resource_type : "s" , resource_id : 0 , label : "s" , value : 0 } } ] ; const currentSequence = betterMerge ( fakeSequence ( ) , { body : { body : steps } } ) ; const props : MarkAs [ "s" ] = { currentSequence , dispatch : jest . fn ( ) , index : 0 , currentStep : steps [ 0 ] , resources : buildResourceIndex ( [ currentSequence ] ) . index , confirmStepDeletion : false } ; return props ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $complex$ O O O O O O $any$ O O O O O O $any$ O O O O O O $ResourceUpdate$ O $ResourceUpdateArgs$ O O O O $string$ O O O $any$ O O $any$ O O O $any$ O $number$ O O O $string$ O O O $string$ O O O O $any$ O O O O O O $any$ O O O O $any$ O O $complex$ O $any$ O O O O $complex$ O O $string$ O O O $number$ O O O O O O $any$ O O O $complex$ O $any$ O O O O $complex$ O O $string$ O O O $number$ O O O O O O $complex$ O $any$ O O O O $complex$ O O $string$ O O O $number$ O O O O O O $complex$ O $any$ O O O O $complex$ O O $string$ O O O $undefined$ O $undefined$ O O O O O O O O O $any$ O O O O $any$ O $any$ O O O O O O O O O $string$ O O O $complex$ O O $string$ O O O $number$ O O O $string$ O O O $number$ O O O O O O O $TaggedSequence$ O $complex$ O $any$ O O O O $complex$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O $number$ O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O $any$ O $boolean$ O O O O O $any$ O O
import { actionList } from "s" ; import { resourceUpdate , markAsResourceFixture } from "s" ; import { buildResourceIndex } from "s" ; import { PLANT_OPTIONS } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const step = resourceUpdate ( { resource_type : "s" } ) ; const { index } = markAsResourceFixture ( ) ; const result = actionList ( undefined , step , index ) ; expect ( result ) . toEqual ( PLANT_OPTIONS ) ; } ) ; it ( "s" , ( ) => { const ddi = { label : "s" , value : 0 , headingId : "s" } ; const step = resourceUpdate ( { } ) ; const { index } = markAsResourceFixture ( ) ; const result = actionList ( ddi , step , index ) ; expect ( result . length ) . toBe ( 0 ) ; const labels = result . map ( x => x . label ) ; expect ( labels ) . toContain ( "s" ) ; expect ( labels ) . toContain ( "s" ) ; expect ( labels ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const ddi = { label : "s" , value : 0 , headingId : "s" } ; const step = resourceUpdate ( { } ) ; const { index } = markAsResourceFixture ( ) ; const result = actionList ( ddi , step , index ) ; expect ( result . length ) . toBe ( 0 ) ; const labels = result . map ( x => x . label ) ; expect ( labels ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const ddi = { label : "s" , value : 0 , headingId : "s" } ; const step = resourceUpdate ( { } ) ; const { index } = buildResourceIndex ( [ ] ) ; const result = actionList ( ddi , step , index ) ; expect ( result . length ) . toBe ( 0 ) ; } ) ; } ) ;	O O $DropDownItem[]$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $DropDownItem[]$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O O O O O $any$ O O $any$ O O O O $DropDownItem[]$ O $DropDownItem[]$ O $undefined$ O $any$ O $any$ O O $any$ O $DropDownItem[]$ O O $any$ O $DropDownItem[]$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $number$ O O O $string$ O O O O O $any$ O $any$ O O O O O O O $any$ O O $any$ O O O O $DropDownItem[]$ O $DropDownItem[]$ O $complex$ O $any$ O $any$ O O $any$ O $DropDownItem[]$ O $number$ O O $any$ O O O O O $string[]$ O $DropDownItem[]$ O $U[]$ O $DropDownItem$ O $DropDownItem$ O $string$ O O $any$ O $string[]$ O O $any$ O O O O $any$ O $string[]$ O O $any$ O O O O $any$ O $string[]$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $number$ O O O $string$ O O O O O $any$ O $any$ O O O O O O O $any$ O O $any$ O O O O $DropDownItem[]$ O $DropDownItem[]$ O $complex$ O $any$ O $any$ O O $any$ O $DropDownItem[]$ O $number$ O O $any$ O O O O O $string[]$ O $DropDownItem[]$ O $U[]$ O $DropDownItem$ O $DropDownItem$ O $string$ O O $any$ O $string[]$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $number$ O O O $string$ O O O O O $any$ O $any$ O O O O O O O $any$ O O $any$ O O O O O O $DropDownItem[]$ O $DropDownItem[]$ O $complex$ O $any$ O $any$ O O $any$ O $DropDownItem[]$ O $number$ O O $any$ O O O O O O O O O O
import { ResourceUpdate , resource_type as RESOURCE_TYPE } from "s" ; import { DropDownItem } from "s" ; export const packStep = ( csNode , resourceDDI : DropDownItem | undefined , actionDDI ) : ResourceUpdate => { const resource_type = ( resourceDDI ? resourceDDI . headingId : csNode . args . resource_type ) as RESOURCE_TYPE ; const resource_id = ( resourceDDI ? resourceDDI . value : csNode . args . resource_id ) as number ; switch ( resource_type ) { case "s" : return { kind : "s" , args : { resource_id , resource_type , label : "s" , value : actionDDI . value } } ; default : const label = "s" + ( actionDDI . value == "s" ? "s" : "s" ) ; const value = "s" + ( label === "s" ? "s" : actionDDI . value ) ; return { kind : "s" , args : { resource_id , resource_type , label , value } } ; } } ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O $ResourceUpdate$ O $DropDownItem$ O $any$ O O O $DropDownItem$ O O $any$ O O O $any$ O O $DropDownItem$ O $DropDownItem$ O $string$ O $any$ O $any$ O $any$ O O $any$ O O $number$ O O $DropDownItem$ O $DropDownItem$ O $complex$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $string$ O O O $complex$ O O $number$ O $any$ O $string$ O O O $complex$ O $DropDownItem$ O $complex$ O O O O O O $string$ O O O O $DropDownItem$ O $complex$ O O O O O O O O O $string$ O O O O $string$ O O O O O $DropDownItem$ O $complex$ O O O O $string$ O O O $complex$ O O $number$ O $any$ O $string$ O $string$ O O O O O O
import { ResourceUpdate } from "s" ; import { editStep } from "s" ; import { packStep } from "s" ; import { MarkAsEditProps } from "s" ; export const commitStepChanges = ( p ) => { const { step , nextResource , nextAction , index , sequence } = p ; return editStep ( { step , index , sequence , executor ( c ) { c . args = packStep ( step , nextResource , nextAction ) . args ; } } ) ; } ;	O O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O O O O O O $any$ O O O O O O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O O $MarkAsEditProps$ O O O O O $any$ O $DropDownItem$ O $DropDownItem$ O $number$ O $any$ O O $MarkAsEditProps$ O O $ReduxAction<EditResourceParams>$ O O $any$ O $number$ O $any$ O $void$ O $ResourceUpdate$ O O $any$ O $any$ O $any$ O $any$ O $DropDownItem$ O $DropDownItem$ O O $any$ O O O O O O O
import { fakeMarkAsProps } from "s" ; import { commitStepChanges } from "s" ; import { ResourceUpdate , TaggedSequence } from "s" ; import { Actions } from "s" ; import { unpackUUID } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const p = fakeMarkAsProps ( ) ; const results = commitStepChanges ( { nextAction : { label : "s" , value : "s" } , nextResource : undefined , step : p . currentStep as ResourceUpdate , index : p . index , sequence : p . currentSequence } ) ; expect ( results . type ) . toBe ( Actions . OVERWRITE_RESOURCE ) ; const { payload } = results ; expect ( unpackUUID ( payload . uuid ) . kind ) . toBe ( "s" ) ; const s = payload . update as TaggedSequence [ "s" ] ; expect ( s . kind ) . toBe ( "s" ) ; const step = ( s . body || [ ] ) [ 0 ] as ResourceUpdate ; expect ( step . args . value ) . toBe ( "s" ) ; } ) ; } ) ;	O O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $BetterUUID$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $ReduxAction<EditResourceParams>$ O $ReduxAction<EditResourceParams>$ O O $complex$ O O $string$ O O O $string$ O O O O $undefined$ O $undefined$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $ReduxAction<EditResourceParams>$ O $Actions$ O O $any$ O $any$ O $Actions.OVERWRITE_RESOURCE$ O O O O $EditResourceParams$ O O $ReduxAction<EditResourceParams>$ O $any$ O $BetterUUID$ O $EditResourceParams$ O $string$ O O $any$ O O $any$ O O O O O $any$ O $EditResourceParams$ O $object$ O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { resourceUpdate } from "s" ; import { packStep } from "s" ; import { TOP_HALF } from "s" ; describe ( "s" , ( ) => { const plant = resourceUpdate ( { resource_type : "s" , resource_id : 0 } ) ; it ( "s" , ( ) => { const actionDDI = { value : "s" , label : "s" } ; const { args } = packStep ( plant , undefined , actionDDI ) ; expect ( args . label ) . toEqual ( "s" ) ; expect ( args . value ) . toEqual ( "s" ) ; expect ( args . resource_id ) . toEqual ( 0 ) ; expect ( args . resource_type ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const actionDDI = { value : "s" , label : "s" } ; const { args } = packStep ( plant , undefined , actionDDI ) ; expect ( args . label ) . toEqual ( "s" ) ; expect ( args . value ) . toEqual ( "s" ) ; expect ( args . resource_id ) . toEqual ( 0 ) ; expect ( args . resource_type ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const resourceDDI = TOP_HALF [ 0 ] ; const actionDDI = { value : 0 , label : "s" } ; const device = resourceUpdate ( { resource_type : "s" , resource_id : 0 } ) ; const { args } = packStep ( device , resourceDDI , actionDDI ) ; expect ( args . label ) . toEqual ( "s" ) ; expect ( args . resource_type ) . toEqual ( "s" ) ; expect ( args . resource_id ) . toEqual ( 0 ) ; expect ( args . value ) . toEqual ( 0 ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O $any$ O O O O O O O O $any$ O $any$ O O $string$ O O O $number$ O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O $any$ O O $any$ O $any$ O $undefined$ O $complex$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O O $any$ O O $any$ O $any$ O $undefined$ O $complex$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $complex$ O O O O O $complex$ O O $number$ O O O $string$ O O O O O $any$ O $any$ O O $string$ O O O $number$ O O O O O O O $any$ O O $any$ O $any$ O $complex$ O $complex$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O
import { ResourceIndex } from "s" ; import { DropDownItem } from "s" ; import { selectAllPoints } from "s" ; import { TaggedPoint , TaggedPlantPointer } from "s" ; import { GenericPointer } from "s" ; import { POINT_HEADER , PLANT_HEADER , TOP_HALF } from "s" ; const isRelevant = ( x ) => { const saved = ! ! x . body . id ; const notToolSlot = x . body . pointer_type !== "s" ; return saved && notToolSlot ; } ; const labelStr = ( n , x , y , z ) => `template` ; export const 0 = ( i ) : DropDownItem => { const { x , y , z , name } = i ; return { value : i . id as number , label : labelStr ( name , x , y , z ) , headingId : "s" } ; } ; export const 0 = ( i : TaggedPlantPointer [ "s" ] ) : DropDownItem => { const { x , y , z , name , id } = i ; return { value : id as number , label : labelStr ( name , x , y , z ) , headingId : "s" } ; } ; const pointList = ( input : TaggedPoint [ ] ) : DropDownItem [ ] => { const points : DropDownItem [ ] = [ POINT_HEADER ] ; const plants : DropDownItem [ ] = [ PLANT_HEADER ] ; input . map ( x => x . body ) . forEach ( body => { switch ( body . pointer_type ) { case "s" : return points . push ( 0 ( body ) ) ; case "s" : return plants . push ( 0 ( body ) ) ; } } ) ; return [ ... plants , ... points ] ; } ; export const resourceList = ( r ) : DropDownItem [ ] => { return [ ... TOP_HALF , ... pointList ( selectAllPoints ( r ) . filter ( isRelevant ) ) ] ; } ;	O O $any$ O O O O O O $any$ O O O O O O $any[]$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $DropDownItem$ O $DropDownItem$ O $complex$ O O O O O $boolean$ O O $TaggedPoint$ O O O O $boolean$ O O O $any$ O $any$ O $any$ O O $boolean$ O $any$ O $any$ O $any$ O O O O $boolean$ O $boolean$ O O O O $string$ O O $string$ O $number$ O $number$ O $number$ O O O O O O $DropDownItem$ O O $GenericPointer$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $number$ O $any$ O $any$ O O O $string$ O $string$ O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O O $DropDownItem$ O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $number$ O $any$ O O O $string$ O $string$ O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O $DropDownItem[]$ O O $any[]$ O $any$ O O O O $any$ O O O O O $DropDownItem[]$ O $any$ O O O O $DropDownItem$ O O O $DropDownItem[]$ O $any$ O O O O $DropDownItem$ O O $any[]$ O $U[]$ O $any$ O $any$ O $any$ O O $void$ O $any$ O O O O $any$ O $any$ O O O O O O $DropDownItem[]$ O $number$ O $DropDownItem$ O $any$ O O O O O O O $DropDownItem[]$ O $number$ O $DropDownItem$ O $any$ O O O O O O O O O O $DropDownItem[]$ O O $DropDownItem[]$ O O O O O O $DropDownItem[]$ O O $ResourceIndex$ O O $any$ O O O O O O O $complex$ O O $DropDownItem[]$ O $any[]$ O $ResourceIndex$ O O $complex$ O $boolean$ O O O O O O
import { resourceList } from "s" ; import { markAsResourceFixture } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const { index } = markAsResourceFixture ( ) ; const result = resourceList ( index ) ; expect ( result . length ) . toBeTruthy ( ) ; const headings = result . filter ( x => x . heading ) . map ( x => x . label ) ; expect ( headings ) . toContain ( "s" ) ; expect ( headings ) . toContain ( "s" ) ; expect ( headings ) . toContain ( "s" ) ; } ) ; } ) ;	O O $DropDownItem[]$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $any$ O O O O $DropDownItem[]$ O $DropDownItem[]$ O $any$ O O $any$ O $DropDownItem[]$ O $number$ O O $any$ O O O O $string[]$ O $DropDownItem[]$ O $complex$ O $DropDownItem$ O $DropDownItem$ O $boolean$ O O $U[]$ O $DropDownItem$ O $DropDownItem$ O $string$ O O $any$ O $string[]$ O O $any$ O O O O $any$ O $string[]$ O O $any$ O O O O $any$ O $string[]$ O O $any$ O O O O O O O O O O
import { DropDownItem } from "s" ; import { findToolById , findByKindAndId , findPointerByTypeAndId } from "s" ; import { 0 , 0 } from "s" ; import { GenericPointer } from "s" ; import { MOUNTED_TO } from "s" ; import { DropDownPair , StepWithResourceIndex } from "s" ; import { TaggedPoint , TaggedPlantPointer } from "s" ; export const TOOL_MOUNT = { label : "s" , value : "s" } ; const NOT_IN_USE = { label : "s" , value : 0 } ; export const DISMOUNTED = { leftSide : TOOL_MOUNT , rightSide : NOT_IN_USE } ; const DEFAULT_TOOL_NAME = "s" ; const REMOVED_ACTION = { label : "s" , value : "s" } ; const mountedTo = ( name = DEFAULT_TOOL_NAME ) : DropDownItem => ( { label : `template` , value : "s" } ) ; function mountTool ( i ) { const { value } = i . step . args ; if ( typeof value === "s" && value > 0 ) { try { const tool = findToolById ( i . resourceIndex , value as number ) ; return { leftSide : TOOL_MOUNT , rightSide : mountedTo ( tool . body . name ) } ; } catch { return { leftSide : TOOL_MOUNT , rightSide : mountedTo ( "s" ) } ; } } else { return DISMOUNTED ; } } function unknownOption ( i ) { const { resource_type , resource_id , label , value } = i . step . args ; return { leftSide : { label : resource_type , value : resource_id } , rightSide : { label : `template` , value : "s" + value } } ; } function discardPoint ( i ) { const { resource_id } = i . step . args ; const t = findPointerByTypeAndId ( i . resourceIndex , "s" , resource_id ) . body ; return { leftSide : 0 ( t as GenericPointer ) , rightSide : REMOVED_ACTION } ; } function plantStage ( i ) { const { resource_id , value } = i . step . args ; const r = findByKindAndId ( i . resourceIndex , "s" , resource_id ) ; return { leftSide : 0 ( r . body as TaggedPlantPointer [ "s" ] ) , rightSide : { label : ( "s" + value ) , value : ( "s" + value ) } } ; } export function unpackStep ( i ) { const { label } = i . step . args ; switch ( label ) { case "s" : return mountTool ( i ) ; case "s" : return discardPoint ( i ) ; case "s" : return plantStage ( i ) ; default : return unknownOption ( i ) ; } }	O O $any$ O O O O O O $any$ O $T$ O $any$ O O O O O O $DropDownItem$ O $DropDownItem$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $DropDownItem$ O O $string$ O O O $string$ O O O O O $DropDownItem$ O O $string$ O O O $number$ O O O O O O $DropDownPair$ O O $DropDownItem$ O $DropDownItem$ O $DropDownItem$ O $DropDownItem$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $DropDownItem$ O O $string$ O O O O $any$ O O O $string$ O O O $string$ O O O O O O $DropDownPair$ O $StepWithResourceIndex$ O O O O $any$ O O $StepWithResourceIndex$ O $any$ O $any$ O O O O $any$ O O O $number$ O O O O O O O $any$ O $any$ O $StepWithResourceIndex$ O $ResourceIndex$ O $number$ O O O O O O $DropDownItem$ O $DropDownItem$ O $DropDownItem$ O $DropDownItem$ O $any$ O $any$ O $any$ O O O O O O O O $DropDownItem$ O $DropDownItem$ O $DropDownItem$ O $DropDownItem$ O O O O O O O O O O $DropDownPair$ O O O O $DropDownPair$ O $StepWithResourceIndex$ O O O O $any$ O $any$ O $any$ O $any$ O O $StepWithResourceIndex$ O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $string$ O O O $string$ O O O $any$ O O O O O $DropDownPair$ O $StepWithResourceIndex$ O O O O $any$ O O $StepWithResourceIndex$ O $any$ O $any$ O O $any$ O $any$ O $StepWithResourceIndex$ O $ResourceIndex$ O O O $any$ O O $any$ O O O $DropDownItem$ O $DropDownItem$ O $any$ O $any$ O O $complex$ O $complex$ O O O O $DropDownPair$ O $StepWithResourceIndex$ O O O O $any$ O $any$ O O $StepWithResourceIndex$ O $any$ O $any$ O O $TaggedPoint$ O $T$ O $StepWithResourceIndex$ O $ResourceIndex$ O O O $any$ O O O O $DropDownItem$ O $DropDownItem$ O $any$ O $any$ O $any$ O O O O O $complex$ O O $string$ O O O O $any$ O O $string$ O O O O $any$ O O O O O O O $DropDownPair$ O $StepWithResourceIndex$ O O O O $any$ O O $StepWithResourceIndex$ O $any$ O $any$ O O O $any$ O O O O O O $DropDownPair$ O $StepWithResourceIndex$ O O O O O O $DropDownPair$ O $StepWithResourceIndex$ O O O O O O $DropDownPair$ O $StepWithResourceIndex$ O O O O O $DropDownPair$ O $StepWithResourceIndex$ O O O O
import { fakeResourceIndex } from "s" ; import { resourceUpdate } from "s" ; import { unpackStep , TOOL_MOUNT , DISMOUNTED } from "s" ; import { selectAllPlantPointers , selectAllTools , selectAllGenericPointers } from "s" ; import { DropDownPair } from "s" ; describe ( "s" , ( ) => { function assertGoodness ( result , action_label , action_value , resource_label , resource_value : string | number ) { expect ( result . rightSide . label ) . toBe ( action_label ) ; expect ( result . rightSide . value ) . toBe ( action_value ) ; expect ( result . leftSide . label ) . toBe ( resource_label ) ; expect ( result . leftSide . value ) . toBe ( resource_value ) ; } it ( "s" , ( ) => { const result = unpackStep ( { step : resourceUpdate ( { label : "s" , value : 0 } ) , resourceIndex : fakeResourceIndex ( ) } ) ; expect ( result ) . toEqual ( DISMOUNTED ) ; } ) ; it ( "s" , ( ) => { const resourceIndex = fakeResourceIndex ( ) ; const { body } = selectAllTools ( resourceIndex ) [ 0 ] ; expect ( body ) . toBeTruthy ( ) ; const result = unpackStep ( { step : resourceUpdate ( { label : "s" , value : body . id || NaN } ) , resourceIndex } ) ; const actionLabel = "s" ; const { label , value } = TOOL_MOUNT ; assertGoodness ( result , actionLabel , "s" , label , value ) ; } ) ; it ( "s" , ( ) => { const result = unpackStep ( { step : resourceUpdate ( { label : "s" , value : Infinity } ) , resourceIndex : fakeResourceIndex ( ) } ) ; const actionLabel = "s" ; const { label , value } = TOOL_MOUNT ; assertGoodness ( result , actionLabel , "s" , label , value ) ; } ) ; it ( "s" , ( ) => { const resourceIndex = fakeResourceIndex ( ) ; const { body } = selectAllGenericPointers ( resourceIndex ) [ 0 ] ; expect ( body . pointer_type ) . toBe ( "s" ) ; const result = unpackStep ( { step : resourceUpdate ( { resource_type : "s" , resource_id : body . id || - 0 , label : "s" , value : "s" } ) , resourceIndex } ) ; assertGoodness ( result , "s" , "s" , `template` , body . id || NaN ) ; } ) ; it ( "s" , ( ) => { const resourceIndex = fakeResourceIndex ( ) ; const plant = selectAllPlantPointers ( resourceIndex ) [ 0 ] ; expect ( plant ) . toBeTruthy ( ) ; const result = unpackStep ( { step : resourceUpdate ( { resource_type : "s" , resource_id : plant . body . id || - 0 , label : "s" , value : "s" } ) , resourceIndex } ) ; const { body } = plant ; const plantName = `template` ; assertGoodness ( result , "s" , "s" , plantName , body . id || NaN ) ; } ) ; it ( "s" , ( ) => { const result = unpackStep ( { step : resourceUpdate ( { } ) , resourceIndex : fakeResourceIndex ( ) } ) ; assertGoodness ( result , "s" , "s" , "s" , 0 ) ; } ) ; } ) ;	O O $ResourceIndex$ O O O O O O $any$ O O O O O O $DropDownPair$ O $DropDownItem$ O $DropDownPair$ O O O O O O $any[]$ O $any[]$ O $any[]$ O O O O O O $any$ O O O O $any$ O O O O O O O O $void$ O $DropDownPair$ O $string$ O $string$ O $string$ O $complex$ O O O O O O $any$ O $DropDownPair$ O $DropDownItem$ O $string$ O O $any$ O $string$ O O $any$ O $DropDownPair$ O $DropDownItem$ O $complex$ O O $any$ O $string$ O O $any$ O $DropDownPair$ O $DropDownItem$ O $string$ O O $any$ O $string$ O O $any$ O $DropDownPair$ O $DropDownItem$ O $complex$ O O $any$ O $complex$ O O O $any$ O O O O O O O O $DropDownPair$ O $DropDownPair$ O O $any$ O $any$ O O $string$ O O O $number$ O O O O O $ResourceIndex$ O $ResourceIndex$ O O O O O $any$ O $DropDownPair$ O O $any$ O $DropDownPair$ O O O O O $any$ O O O O O O O O $ResourceIndex$ O $ResourceIndex$ O O O O O $any$ O O $any[]$ O $ResourceIndex$ O O O O O $any$ O $any$ O O $any$ O O O O $DropDownPair$ O $DropDownPair$ O O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O $number$ O O O $ResourceIndex$ O O O O O O O O O O $string$ O $complex$ O O $DropDownItem$ O $void$ O $DropDownPair$ O O O O O $string$ O $complex$ O O O O O $any$ O O O O O O O O $DropDownPair$ O $DropDownPair$ O O $any$ O $any$ O O $string$ O O O $number$ O $number$ O O O $ResourceIndex$ O $ResourceIndex$ O O O O O O O O O O O O $string$ O $complex$ O O $DropDownItem$ O $void$ O $DropDownPair$ O O O O O $string$ O $complex$ O O O O O $any$ O O O O O O O O $ResourceIndex$ O $ResourceIndex$ O O O O O $any$ O O $any[]$ O $ResourceIndex$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $DropDownPair$ O $DropDownPair$ O O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $ResourceIndex$ O O O $void$ O $DropDownPair$ O O O O O O O $any$ O $any$ O $number$ O O O O O $any$ O O O O O O O O $ResourceIndex$ O $ResourceIndex$ O O O O $any$ O $any[]$ O $ResourceIndex$ O O O O O $any$ O $any$ O O $any$ O O O O $DropDownPair$ O $DropDownPair$ O O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O O $string$ O O O $string$ O O O O O $ResourceIndex$ O O O O O $any$ O O $any$ O O $string$ O O O $void$ O $DropDownPair$ O O O O O $string$ O $any$ O $any$ O $number$ O O O O O $any$ O O O O O O O O $DropDownPair$ O $DropDownPair$ O O $any$ O $any$ O O O O O $ResourceIndex$ O $ResourceIndex$ O O O O O $void$ O $DropDownPair$ O O O O O O O O O O O O O O O O
import { TaggedSequence , If , AllowedPinTypes } from "s" ; import { ResourceIndex } from "s" ; import { defensiveClone , bail } from "s" ; import { DropDownItem } from "s" ; import { overwrite } from "s" ; import { isString } from "s" ; import { PinGroupName } from "s" ; interface LhsUpdateProps { currentSequence : TaggedSequence ; currentStep : If ; dispatch : Function ; index : number ; resources : ResourceIndex ; } export const updateLhs = ( props ) => { const { currentStep , currentSequence , dispatch , index , resources } = props ; return ( e ) => { const stepCopy = defensiveClone ( currentStep ) ; const seqCopy = defensiveClone ( currentSequence ) . body ; const val = e . value ; seqCopy . body = seqCopy . body || [ ] ; if ( isString ( val ) ) { switch ( e . headingId ) { case PinGroupName . Peripheral : case PinGroupName . Sensor : const resource = resources . references [ e . value ] ; if ( ! resource ) { return bail ( "s" ) ; } stepCopy . args . lhs = { kind : "s" , args : { pin_type : resource . kind as AllowedPinTypes , pin_id : resource . body . id || 0 } } ; break ; case PinGroupName . Position : case PinGroupName . Pin : stepCopy . args . lhs = val ; break ; default : throw new Error ( `template` ) ; } } seqCopy . body [ index ] = stepCopy ; dispatch ( overwrite ( currentSequence , seqCopy ) ) ; } ; } ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $T$ O $never$ O O O O O O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $Function$ O $FunctionConstructor$ O $number$ O O O $ResourceIndex$ O $any$ O O O O $never$ O O $LhsUpdateProps$ O O O O O $any$ O $any$ O $Function$ O $number$ O $ResourceIndex$ O O $LhsUpdateProps$ O O O $DropDownItem$ O O O O $any$ O $T$ O $any$ O O O $any$ O $T$ O $any$ O O $any$ O O $complex$ O $DropDownItem$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $complex$ O O O O O $DropDownItem$ O $string$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $ResourceIndex$ O $any$ O $DropDownItem$ O $complex$ O O O O O $any$ O O O $never$ O O O O O $any$ O $any$ O $any$ O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O $number$ O O $any$ O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O $any$ O O O O O O O
import { NULL_CHOICE , DropDownItem } from "s" ; import { ResourceIndex } from "s" ; import { If } from "s" ; import { findByKindAndId } from "s" ; import { isString } from "s" ; interface DisplayLhsProps { currentStep : If ; resources : ResourceIndex ; lhsOptions : DropDownItem [ ] ; } const findDropdownByValue = ( needle , haystack : DropDownItem [ ] ) => haystack . filter ( x => x . value === needle ) [ 0 ] || NULL_CHOICE ; export function displayLhs ( props ) { const { lhs } = props . currentStep . args ; const { lhsOptions } = props ; if ( isString ( lhs ) ) { return findDropdownByValue ( lhs , lhsOptions ) ; } else { const { pin_id , pin_type } = lhs . args ; const kind = pin_type as "s" | "s" ; const id = pin_id || - 0 ; const { uuid } = findByKindAndId ( props . resources , kind , id ) ; return findDropdownByValue ( uuid , lhsOptions ) ; } }	O O $Readonly<NullChoice>$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $T$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $ResourceIndex$ O $any$ O $DropDownItem[]$ O $any$ O O O O O $DropDownItem$ O O $string$ O $DropDownItem[]$ O $any$ O O O O $DropDownItem[]$ O $complex$ O $DropDownItem$ O $DropDownItem$ O $complex$ O $string$ O O O O O $Readonly<NullChoice>$ O O O $DropDownItem$ O $DisplayLhsProps$ O O O O $any$ O O $DisplayLhsProps$ O $any$ O $any$ O O O $DropDownItem[]$ O O $DisplayLhsProps$ O O O $any$ O $any$ O O O O $DropDownItem$ O $any$ O $DropDownItem[]$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $T$ O $DisplayLhsProps$ O $ResourceIndex$ O O O $any$ O O O $DropDownItem$ O $any$ O $DropDownItem[]$ O O O O
import { buildResourceIndex } from "s" ; import { SpecialStatus , TaggedSequence , TaggedPeripheral , If , NamedPin , AllowedPinTypes , } from "s" ; import { selectAllSequences , selectAllPeripherals } from "s" ; import { updateLhs } from "s" ; import { PinGroupName } from "s" ; import { Actions } from "s" ; import { get } from "s" ; import { displayLhs } from "s" ; const ifStep = { kind : "s" , args : { lhs : "s" , op : "s" , rhs : 0 , _then : { kind : "s" , args : { } } , _else : { kind : "s" , args : { } } , } } ; const seedSequence = { kind : "s" , specialStatus : SpecialStatus . SAVED , uuid : "s" , body : { id : 0 , color : "s" , name : "s" , kind : "s" , args : { locals : { kind : "s" , args : { } } , version : 0 } , body : [ ifStep ] } } ; const peripheral = { kind : "s" , uuid : "s" , specialStatus : SpecialStatus . SAVED , body : { id : 0 , pin : 0 , label : "s" } } ; const resources = buildResourceIndex ( [ seedSequence , peripheral ] ) ; const currentSequence = selectAllSequences ( resources . index ) [ 0 ] ; const currentStep = ( currentSequence . body . body || [ ] ) [ 0 ] as If ; const index = 0 ; const path = "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const props = { currentStep , currentSequence , dispatch , index , resources : resources . index } ; const fn = updateLhs ( props ) ; fn ( { value : selectAllPeripherals ( resources . index ) [ 0 ] . uuid , label : "s" , headingId : PinGroupName . Sensor } ) ; expect ( dispatch ) . toHaveBeenCalled ( ) ; const expectedType = expect . objectContaining ( { type : Actions . OVERWRITE_RESOURCE } ) ; expect ( dispatch ) . toHaveBeenCalledWith ( expectedType ) ; expect ( get ( dispatch , path + "s" ) ) . toEqual ( "s" ) ; expect ( get ( dispatch , path + "s" ) ) . toEqual ( peripheral . body . id ) ; } ) ; it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const props = { currentStep , currentSequence , dispatch , index , resources : resources . index } ; const fn = updateLhs ( props ) ; fn ( { value : "s" , label : "s" , headingId : PinGroupName . Pin } ) ; expect ( dispatch ) . toHaveBeenCalled ( ) ; const expectedType = expect . objectContaining ( { type : Actions . OVERWRITE_RESOURCE } ) ; expect ( dispatch ) . toHaveBeenCalledWith ( expectedType ) ; expect ( get ( dispatch , path ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const dispatch = jest . fn ( ) ; const props = { currentStep , currentSequence , dispatch , index , resources : resources . index } ; const fn = updateLhs ( props ) ; expect ( ( ) => fn ( { value : "s" , label : "s" , headingId : "s" } ) ) . toThrowError ( ) ; expect ( ( ) => fn ( { value : "s" , label : "s" , headingId : PinGroupName . Peripheral } ) ) . toThrowError ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const p = resources . index . references [ Object . keys ( resources . index . byKind . Peripheral ) [ 0 ] ] ; if ( ! p ) { throw new Error ( "s" ) ; } const pin_id = p . body . id || NaN ; const namedPin = { kind : "s" , args : { pin_type : p . kind as AllowedPinTypes , pin_id } } ; const result = displayLhs ( { currentStep : { kind : "s" , args : { lhs : namedPin , op : "s" , rhs : 0 , _then : { kind : "s" , args : { } } , _else : { kind : "s" , args : { } } , } } , resources : resources . index , lhsOptions : [ { value : p . uuid , label : "s" , headingId : "s" } ] } ) ; expect ( result ) . toBeTruthy ( ) ; expect ( result . value ) . toEqual ( p . uuid ) ; expect ( result . label ) . toEqual ( "s" ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any[]$ O $any[]$ O O O O O O $never$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $DropDownItem$ O O O O O $If$ O O $string$ O O O $complex$ O O $string$ O O O $string$ O O O $number$ O O O $complex$ O O $string$ O O O ${}$ O O O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O O $TaggedSequence$ O O $string$ O O O $any$ O $any$ O $any$ O $string$ O O O $complex$ O O $number$ O O O $string$ O O O $string$ O O O $string$ O O O $complex$ O O $complex$ O O $string$ O O O ${}$ O O O O O $number$ O O O O $any[]$ O O $any$ O O O O O $TaggedPeripheral$ O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $complex$ O O $number$ O O O $number$ O O O $string$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any[]$ O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O $number$ O $any$ O $any$ O $any$ O O O $never$ O $never$ O $complex$ O O $never$ O O $any$ O $any[]$ O $any$ O $any$ O O O O O $any$ O $string$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $Actions$ O $any$ O $Actions.OVERWRITE_RESOURCE$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O $number$ O $any$ O $any$ O $any$ O O O $never$ O $never$ O $complex$ O O $never$ O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $Actions$ O $any$ O $Actions.OVERWRITE_RESOURCE$ O O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O $any$ O $any$ O $any$ O $number$ O $any$ O $any$ O $any$ O O O $never$ O $never$ O $complex$ O O $any$ O O O O $never$ O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O O O $any$ O O O O $never$ O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O $any$ O $any$ O $number$ O O $NamedPin$ O O $string$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $DropDownItem$ O $DropDownItem$ O O $complex$ O O $string$ O O O $complex$ O O $any$ O $any$ O $string$ O O O $number$ O O O $complex$ O O $string$ O O O ${}$ O O O O O $complex$ O O $string$ O O O ${}$ O O O O O O O O $any$ O $any$ O $any$ O $complex$ O O O $any$ O $any$ O $any$ O $string$ O O O $string$ O O O O O O O $any$ O $DropDownItem$ O O $any$ O O O $any$ O $DropDownItem$ O $complex$ O O $any$ O $any$ O $any$ O O $any$ O $DropDownItem$ O $string$ O O $any$ O O O O O O O O O O
jest . mock ( "s" , ( ) => ( { Session : { clear : jest . fn ( ) } } ) ) ; import { syncFail } from "s" ; import { Session } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const e = new Error ( "s" ) ; console . error = jest . fn ( ) ; expect ( ( ) => syncFail ( e ) ) . toThrowError ( e ) ; expect ( console . error ) . toHaveBeenCalledWith ( "s" ) ; expect ( Session . clear ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O O O $void$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Error$ O O $ErrorConstructor$ O O O O $Console$ O $void$ O $any$ O $any$ O O O $any$ O O O O $void$ O $Error$ O O O $any$ O $Error$ O O $any$ O $Console$ O $void$ O O $any$ O O O O $any$ O $any$ O $never$ O O $any$ O O O O O O O O O
import { FBToast } from "s" ; describe ( "s" , ( ) => { let count = 0 ; const newToast = ( ) : [ FBToast , HTMLDivElement ] => { const parent = document . createElement ( "s" ) ; const child = new FBToast ( parent , "s" , "s" + ( count ++ ) , "s" ) ; return [ child , parent ] ; } ; it ( "s" , ( ) => { const [ instance , parent ] = newToast ( ) ; expect ( instance . leftLoaderEl . tagName ) . toEqual ( "s" ) ; expect ( instance . loaderEl . tagName ) . toEqual ( "s" ) ; expect ( instance . messageEl . tagName ) . toEqual ( "s" ) ; expect ( instance . rightLoaderEl . tagName ) . toEqual ( "s" ) ; expect ( instance . titleEl . tagName ) . toEqual ( "s" ) ; expect ( instance . toastEl . tagName ) . toEqual ( "s" ) ; expect ( instance . spinnerLoaderEl . tagName ) . toEqual ( "s" ) ; expect ( instance . isHovered ) . toEqual ( false ) ; expect ( instance . intervalId ) . toEqual ( 0 ) ; expect ( instance . message ) . toEqual ( ( "s" + ( count - 0 ) ) ) ; expect ( instance . parent ) . toEqual ( parent ) ; expect ( instance . timeout ) . toEqual ( 0 ) ; } ) ; it ( "s" , ( ) => { const [ i ] = newToast ( ) ; i . isHovered = false ; const children = [ { style : { animationPlayState : "s" } } , { style : { animationPlayState : "s" } } , { style : { animationPlayState : "s" } } , ] ; const fakeEvent = { currentTarget : { children : [ { } , { } , { children } ] } } as any ; i . onEnter ( fakeEvent ) ; const playState = children . map ( x => x . style . animationPlayState ) ; expect ( playState ) . toEqual ( [ "s" , "s" , "s" ] ) ; } ) ; it ( "s" , ( ) => { const [ i ] = newToast ( ) ; i . isHovered = false ; const children = [ { style : { animationPlayState : "s" } } , { style : { animationPlayState : "s" } } , { style : { animationPlayState : "s" } } , ] ; const fakeEvent = { currentTarget : { children : [ { } , { } , { children } ] } } as any ; i . onLeave ( fakeEvent ) ; const playState = children . map ( x => x . style . animationPlayState ) ; expect ( playState ) . toEqual ( [ "s" , "s" , "s" ] ) ; } ) ; it ( "s" , ( done ) => { const [ i ] = newToast ( ) ; i . detach = jest . fn ( ) ; const e = ( { currentTarget : { classList : { add : jest . fn ( ) } } } ) ; i . onClick ( e as any ) ; expect ( e . currentTarget . classList . add ) . toHaveBeenCalledWith ( "s" ) ; setTimeout ( ( ) => { expect ( i . detach ) . toHaveBeenCalled ( ) ; done ( ) ; } , 0 * 0 ) ; } ) ; it ( "s" , ( ) => { const [ i , p ] = newToast ( ) ; p . appendChild = jest . fn ( ) ; i . run ( ) ; expect ( p . appendChild ) . toHaveBeenCalledWith ( i . toastEl ) ; expect ( i . intervalId ) . not . toBe ( 0 ) ; } ) ; it ( "s" , ( ) => { const [ i , p ] = newToast ( ) ; const { message } = i ; FBToast . everyMessage [ message ] = true ; p . removeChild = jest . fn ( ) ; i . isAttached = true ; i . detach ( ) ; expect ( FBToast . everyMessage [ message ] ) . toBeFalsy ( ) ; expect ( p . removeChild ) . toHaveBeenCalledWith ( i . toastEl ) ; } ) ; it ( "s" , ( ) => { const [ i ] = newToast ( ) ; i . isHovered = false ; i . timeout = 0 ; i . detach = jest . fn ( ) ; i . doPolling ( ) ; expect ( i . detach ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const [ i ] = newToast ( ) ; i . isHovered = false ; i . timeout = 0 ; i . detach = jest . fn ( ) ; i . doPolling ( ) ; expect ( i . detach ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const [ i ] = newToast ( ) ; i . isHovered = true ; i . timeout = 0 ; i . detach = jest . fn ( ) ; i . doPolling ( ) ; expect ( i . detach ) . not . toHaveBeenCalled ( ) ; } ) ; } ) ;	O O $any$ O O O O $any$ O O O O O O O O $number$ O O O O $complex$ O O O O O $any$ O $complex$ O O O O $HTMLDivElement$ O $Document$ O O O O O O O $FBToast$ O O $any$ O $HTMLDivElement$ O O O O O O $number$ O O O O O O O O $FBToast$ O $HTMLDivElement$ O O O O $any$ O O O O O O O O O $FBToast$ O $HTMLDivElement$ O O $complex$ O O O $any$ O $FBToast$ O $HTMLDivElement$ O $string$ O O $any$ O O O O $any$ O $FBToast$ O $HTMLDivElement$ O $string$ O O $any$ O O O O $any$ O $FBToast$ O $HTMLDivElement$ O $string$ O O $any$ O O O O $any$ O $FBToast$ O $HTMLDivElement$ O $string$ O O $any$ O O O O $any$ O $FBToast$ O $HTMLHeadingElement$ O $string$ O O $any$ O O O O $any$ O $FBToast$ O $HTMLDivElement$ O $string$ O O $any$ O O O O $any$ O $FBToast$ O $HTMLDivElement$ O $string$ O O $any$ O O O O $any$ O $FBToast$ O $boolean$ O O $any$ O O O O $any$ O $FBToast$ O $number$ O O $any$ O O O O $any$ O $FBToast$ O $string$ O O $any$ O O O O O $number$ O O O O O O $any$ O $FBToast$ O $Element$ O O $any$ O $HTMLDivElement$ O O $any$ O $FBToast$ O $number$ O O $any$ O O O O O O O $any$ O O O O O O O O O $FBToast$ O O $complex$ O O O $FBToast$ O $boolean$ O O O O $complex$ O O O $complex$ O O $string$ O O O O O O $complex$ O O $string$ O O O O O O $complex$ O O $string$ O O O O O O O O $MouseEvent$ O O $complex$ O O $complex$ O O O O O O O O O $complex$ O O O O O O O $FBToast$ O $void$ O $MouseEvent$ O O O $string[]$ O $complex$ O $U[]$ O $complex$ O $complex$ O $complex$ O $string$ O O $any$ O $string[]$ O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O $FBToast$ O O $complex$ O O O $FBToast$ O $boolean$ O O O O $complex$ O O O $complex$ O O $string$ O O O O O O $complex$ O O $string$ O O O O O O $complex$ O O $string$ O O O O O O O O $MouseEvent$ O O $complex$ O O $complex$ O O O O O O O O O $complex$ O O O O O O O $FBToast$ O $void$ O $MouseEvent$ O O O $string[]$ O $complex$ O $U[]$ O $complex$ O $complex$ O $complex$ O $string$ O O $any$ O $string[]$ O O $any$ O O O O O O O O O O O O O $any$ O O O O $any$ O O O O O $FBToast$ O O $complex$ O O O $FBToast$ O $void$ O $any$ O $any$ O O O O $complex$ O O O $complex$ O O $complex$ O O $any$ O $any$ O $any$ O O O O O O O $FBToast$ O $void$ O $complex$ O O O O $any$ O $complex$ O $complex$ O $complex$ O $any$ O O $any$ O O O O $number$ O O O O O $any$ O $FBToast$ O $void$ O O $any$ O O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O O O $FBToast$ O $HTMLDivElement$ O O $complex$ O O O $HTMLDivElement$ O $T$ O $any$ O $any$ O O O $FBToast$ O $void$ O O O $any$ O $HTMLDivElement$ O $T$ O O $any$ O $FBToast$ O $HTMLDivElement$ O O $any$ O $FBToast$ O $number$ O O $any$ O $any$ O O O O O O O $any$ O O O O O O O O O $FBToast$ O $HTMLDivElement$ O O $complex$ O O O O O $string$ O O $FBToast$ O $any$ O $complex$ O $string$ O O O O $HTMLDivElement$ O $T$ O $any$ O $any$ O O O $FBToast$ O $boolean$ O O O $FBToast$ O $void$ O O O $any$ O $any$ O $complex$ O $string$ O O O $any$ O O O $any$ O $HTMLDivElement$ O $T$ O O $any$ O $FBToast$ O $HTMLDivElement$ O O O O O $any$ O O O O O O O O O $FBToast$ O O $complex$ O O O $FBToast$ O $boolean$ O O O $FBToast$ O $number$ O O O $FBToast$ O $void$ O $any$ O $any$ O O O $FBToast$ O $void$ O O O $any$ O $FBToast$ O $void$ O O $any$ O O O O O O $any$ O O O O O O O O O $FBToast$ O O $complex$ O O O $FBToast$ O $boolean$ O O O $FBToast$ O $number$ O O O $FBToast$ O $void$ O $any$ O $any$ O O O $FBToast$ O $void$ O O O $any$ O $FBToast$ O $void$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O $FBToast$ O O $complex$ O O O $FBToast$ O $boolean$ O O O $FBToast$ O $number$ O O O $FBToast$ O $void$ O $any$ O $any$ O O O $FBToast$ O $void$ O O O $any$ O $FBToast$ O $void$ O O $any$ O $any$ O O O O O O O O O
const mockRun = jest . fn ( ) ; class MockFBToast { static everyMessage : Record < string , boolean > = { } ; run = mockRun ; } jest . mock ( "s" , ( ) => { return { FBToast : MockFBToast } ; } ) ; import { FBToast } from "s" ; import { createToastOnce , createToast } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const msg = "s" ; const fallback = jest . fn ( ) ; const container = document . createElement ( "s" ) ; container . className = "s" ; document . body . appendChild ( container ) ; createToastOnce ( msg , "s" , "s" , fallback ) ; expect ( FBToast . everyMessage [ msg ] ) . toBe ( true ) ; expect ( fallback ) . not . toHaveBeenCalled ( ) ; expect ( mockRun ) . toHaveBeenCalled ( ) ; createToastOnce ( msg , "s" , "s" , fallback ) ; expect ( fallback ) . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { document . body . innerHTML = "s" ; expect ( ( ) => createToast ( "s" , "s" , "s" ) ) . toThrow ( ) ; } ) ; } ) ;	O $any$ O $any$ O $any$ O O O O $any$ O O $complex$ O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O O O $void$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $HTMLElement$ O $Document$ O O O O O O $HTMLElement$ O $string$ O O O $Document$ O $HTMLElement$ O $T$ O $HTMLElement$ O O $void$ O O O O O O O $any$ O O $any$ O $any$ O $complex$ O O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O $void$ O O O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O $Document$ O $HTMLElement$ O $string$ O O O $any$ O O O O $void$ O O O O O O O O O $any$ O O O O O O O O O
jest . mock ( "s" , ( ) => { return { createToast : jest . fn ( ) , createToastOnce : jest . fn ( ) } ; } ) ; import { createToastOnce , createToast } from "s" ; const { warning , error , success , info , fun , init , busy , } : typeof import ( "s" ) = jest . requireActual ( "s" ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { warning ( "s" ) ; expect ( createToastOnce ) . toHaveBeenCalledWith ( "s" , "s" , "s" , console . warn ) ; } ) ; it ( "s" , ( ) => { warning ( "s" , "s" , "s" ) ; expect ( createToastOnce ) . toHaveBeenCalledWith ( "s" , "s" , "s" , console . warn ) ; } ) ; it ( "s" , ( ) => { error ( "s" ) ; expect ( createToastOnce ) . toHaveBeenCalledWith ( "s" , "s" , "s" , console . error ) ; } ) ; it ( "s" , ( ) => { error ( "s" , "s" , "s" ) ; expect ( createToastOnce ) . toHaveBeenCalledWith ( "s" , "s" , "s" , console . error ) ; } ) ; it ( "s" , ( ) => { success ( "s" ) ; expect ( createToast ) . toHaveBeenCalledWith ( "s" , "s" , "s" ) ; } ) ; it ( "s" , ( ) => { success ( "s" , "s" , "s" ) ; expect ( createToast ) . toHaveBeenCalledWith ( "s" , "s" , "s" ) ; } ) ; it ( "s" , ( ) => { info ( "s" ) ; expect ( createToast ) . toHaveBeenCalledWith ( "s" , "s" , "s" ) ; } ) ; it ( "s" , ( ) => { info ( "s" , "s" , "s" ) ; expect ( createToast ) . toHaveBeenCalledWith ( "s" , "s" , "s" ) ; } ) ; it ( "s" , ( ) => { busy ( "s" ) ; expect ( createToast ) . toHaveBeenCalledWith ( "s" , "s" , "s" ) ; } ) ; it ( "s" , ( ) => { busy ( "s" , "s" , "s" ) ; expect ( createToast ) . toHaveBeenCalledWith ( "s" , "s" , "s" ) ; } ) ; it ( "s" , ( ) => { fun ( "s" ) ; expect ( createToast ) . toHaveBeenCalledWith ( "s" , "s" , "s" ) ; } ) ; it ( "s" , ( ) => { fun ( "s" , "s" , "s" ) ; expect ( createToast ) . toHaveBeenCalledWith ( "s" , "s" , "s" ) ; } ) ; it ( "s" , ( ) => { const 0 = document . querySelectorAll ( "s" ) . item . length ; expect ( 0 ) . toEqual ( 0 ) ; init ( ) ; const 0 = document . querySelectorAll ( "s" ) . item . length ; expect ( 0 ) . toEqual ( 0 ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $void$ O $void$ O O O O O O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O $void$ O O O O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $void$ O O O O $any$ O $void$ O O $any$ O O O O O O O $Console$ O $void$ O O O O O $any$ O O O O O O O $void$ O O O O O O O O $any$ O $void$ O O $any$ O O O O O O O $Console$ O $void$ O O O O O $any$ O O O O O O O $void$ O O O O $any$ O $void$ O O $any$ O O O O O O O $Console$ O $void$ O O O O O $any$ O O O O O O O $void$ O O O O O O O O $any$ O $void$ O O $any$ O O O O O O O $Console$ O $void$ O O O O O $any$ O O O O O O O $void$ O O O O $any$ O $void$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $void$ O O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $void$ O O O O $any$ O $void$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $void$ O O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $void$ O O O O $any$ O $void$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $void$ O O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $void$ O O O O $any$ O $void$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O $void$ O O O O O O O O $any$ O $void$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $number$ O $Document$ O O O O O O $Element$ O $number$ O $any$ O $number$ O O $any$ O O O O $void$ O O O O $number$ O $Document$ O O O O O O $Element$ O $number$ O $any$ O $number$ O O $any$ O O O O O O O O O O
import { Everything } from "s" ; import { Props } from "s" ; import { selectAllToolSlotPointers , selectAllTools , currentToolInSlot , } from "s" ; import { isTaggedTool } from "s" ; import { edit } from "s" ; import { DropDownItem , NULL_CHOICE } from "s" ; import { validBotLocationData } from "s" ; import { TaggedTool , TaggedToolSlotPointer } from "s" ; import { isNumber , noop , compact } from "s" ; export function mapStateToProps ( props ) { const toolSlots = selectAllToolSlotPointers ( props . resources . index ) ; const tools = selectAllTools ( props . resources . index ) ; const getToolSlots = ( ) => toolSlots ; const getToolOptions = ( ) => { return compact ( tools . map ( tool => ( { label : tool . body . name || "s" , value : tool . body . id || 0 , } ) ) . filter ( ddi => isNumber ( ddi . value ) && ddi . value > 0 ) ) ; } ; const activeTools = compact ( toolSlots . map ( x => x . body . tool_id ) ) ; const isActive = ( t ) => ! ! ( t . body . id && activeTools . includes ( t . body . id ) ) ; const getToolByToolSlotUUID = currentToolInSlot ( props . resources . index ) ; const getChosenToolOption = ( toolSlotUUID : string | undefined ) => { const chosenTool = toolSlotUUID && getToolByToolSlotUUID ( toolSlotUUID ) ; return ( chosenTool && isTaggedTool ( chosenTool ) && chosenTool . body . id ) ? { label : chosenTool . body . name || "s" , value : chosenTool . uuid } : NULL_CHOICE ; } ; const changeToolSlot = ( t , dispatch ) => ( d ) => { const tool_id = d . value ? d . value : ( null as any ) ; dispatch ( edit ( t , { tool_id } ) ) ; } ; const botPosition = validBotLocationData ( props . bot . hardware . location_data ) . position ; return { toolSlots , tools , getToolSlots , getToolOptions , getChosenToolOption , getToolByToolSlotUUID , changeToolSlot , isActive , dispatch : noop , botPosition , } ; }	O O $any$ O O O O O O $any$ O O O O O O $any[]$ O $any[]$ O $any$ O O O O O O O $complex$ O O O O O O $ReduxAction<EditResourceParams>$ O O O O O O $any$ O $Readonly<NullChoice>$ O O O O O O $complex$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $Props$ O $Everything$ O O O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $any[]$ O $any[]$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $any[]$ O O O O $any[]$ O O $any$ O O O O O O $any$ O $any[]$ O $U[]$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O $complex$ O $any$ O $complex$ O $any$ O O $complex$ O $any$ O O O O O O O O $any$ O $any$ O $any[]$ O $U[]$ O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O O $TaggedTool$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $Everything$ O $RestResources$ O $ResourceIndex$ O O O $complex$ O O $string$ O O O O O O O O $any$ O $string$ O $any$ O $string$ O O O O $any$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $Readonly<NullChoice>$ O O O O $void$ O O $TaggedToolSlotPointer$ O $Function$ O O O $DropDownItem$ O O O O $any$ O $DropDownItem$ O $complex$ O $DropDownItem$ O $complex$ O O O O O O O $Function$ O $ReduxAction<EditResourceParams>$ O $any$ O O $any$ O O O O O O O $complex$ O $complex$ O $Everything$ O $BotState$ O $any$ O $any$ O O $any$ O O O $any[]$ O $any[]$ O $any[]$ O $any$ O $complex$ O $any$ O $void$ O $boolean$ O $any$ O $any$ O $complex$ O O O O
jest . mock ( "s" , ( ) => ( { edit : jest . fn ( ) } ) ) ; import { mapStateToProps } from "s" ; import { fakeState } from "s" ; import { NULL_CHOICE } from "s" ; import { fakeToolSlot } from "s" ; import { edit } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const props = mapStateToProps ( fakeState ( ) ) ; const result = props . getChosenToolOption ( undefined ) ; expect ( result ) . toEqual ( NULL_CHOICE ) ; } ) ; it ( "s" , ( ) => { const props = mapStateToProps ( fakeState ( ) ) ; const tool = fakeToolSlot ( ) ; props . changeToolSlot ( tool , jest . fn ( ) ) ( { label : "s" , value : "s" } ) ; expect ( edit ) . toHaveBeenCalledWith ( tool , { tool_id : null } ) ; } ) ; it ( "s" , ( ) => { const props = mapStateToProps ( fakeState ( ) ) ; const tool = fakeToolSlot ( ) ; props . changeToolSlot ( tool , jest . fn ( ) ) ( { label : "s" , value : 0 } ) ; expect ( edit ) . toHaveBeenCalledWith ( tool , { tool_id : 0 } ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $Props$ O O O O O O $Everything$ O O O O O O $Readonly<NullChoice>$ O O O O O O $any$ O O O O O O $ReduxAction<EditResourceParams>$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $Props$ O $Props$ O $Everything$ O O O O O $DropDownItem$ O $Props$ O $DropDownItem$ O $undefined$ O O $any$ O $DropDownItem$ O O $any$ O $Readonly<NullChoice>$ O O O O O $any$ O O O O O O O O $Props$ O $Props$ O $Everything$ O O O O O $any$ O $any$ O O O $Props$ O $void$ O $any$ O $any$ O $any$ O O O O O $string$ O O O $string$ O O O O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O O $null$ O O O O O O O O $any$ O O O O O O O O $Props$ O $Props$ O $Everything$ O O O O O $any$ O $any$ O O O $Props$ O $void$ O $any$ O $any$ O $any$ O O O O O $string$ O O O $number$ O O O O O $any$ O $ReduxAction<EditResourceParams>$ O O $any$ O $any$ O O $number$ O O O O O O O O O O O
import { ToolSlotPointer } from "s" ; export const emptyToolSlotBody = ( ) : ToolSlotPointer => ( { x : 0 , y : 0 , z : 0 , radius : 0 , pointer_type : "s" , meta : { } , tool_id : undefined , name : "s" , pullout_direction : 0 , gantry_mounted : false , } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O ${}$ O O O O $undefined$ O $undefined$ O $string$ O O O $number$ O O O $boolean$ O O O O O O
export * from "s" ; export * from "s" ; export * from "s" ; export * from "s" ;	O O O O O O O O O O O O O O O O O O O O
jest . mock ( "s" , ( ) => ( { init : jest . fn ( ( _ , ok ) => ok ( ) ) } ) ) ; jest . mock ( "s" , ( ) => ( { render : jest . fn ( ) } ) ) ; jest . mock ( "s" , ( ) => ( { detectLanguage : jest . fn ( ( ) => Promise . resolve ( ) ) } ) ) ; import { detectLanguage } from "s" ; import { render } from "s" ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await import ( "s" ) ; expect ( detectLanguage ) . toHaveBeenCalled ( ) ; expect ( document . getElementById ( "s" ) ) . toBeTruthy ( ) ; expect ( render ) . toHaveBeenCalled ( ) ; } ) ; } ) ;	$any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O $any$ O $any$ O O $any$ O O O $any$ O $Document$ O $HTMLElement$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O O O
import { docLink , BASE_URL } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( docLink ( ) ) . toEqual ( BASE_URL ) ; expect ( docLink ( "s" ) ) . toEqual ( BASE_URL + "s" ) ; } ) ; } ) ;	O O $string$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $string$ O O O O $any$ O O O O $any$ O $string$ O O O O O $any$ O O O O O O O O O O O O
import { Markdown } from "s" ; import { mount } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = mount ( Markdown ( { children : "s" } ) ) ; expect ( result . html ( ) ) . toContain ( "s" ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O
import { Page } from "s" ; import { mount } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = mount ( Page ( { children : "s" } ) ) ; expect ( result . html ( ) ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const result = mount ( Page ( { className : "s" } ) ) ; const div = result . find ( "s" ) . first ( ) ; expect ( div . hasClass ( "s" ) ) . toBeTruthy ( ) ; expect ( div . hasClass ( "s" ) ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O
import { Saucer } from "s" ; import { mount } from "s" ; describe ( "s" , ( ) => { const params = { color : "s" , active : true } ; it ( "s" , ( ) => { const result = mount ( Saucer ( params ) ) ; expect ( result . find ( "s" ) . hasClass ( "s" ) ) . toBeTruthy ( ) ; expect ( result . find ( "s" ) . hasClass ( "s" ) ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $boolean$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $complex$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O O O O O O O
import { isUndefined } from "s" ; interface Props { xs ? : number ; sm ? : number ; md ? : number ; lg ? : number ; xl ? : number ; xsOffset ? : number ; smOffset ? : number ; mdOffset ? : number ; lgOffset ? : number ; xlOffset ? : number ; } export function parseClassNames ( props , base ? ) { const classNames : string [ ] = [ ] ; if ( base ) { classNames . push ( base ) ; } if ( props . xs ) { classNames . push ( `template` ) ; } if ( props . sm ) { classNames . push ( `template` ) ; } if ( props . md ) { classNames . push ( `template` ) ; } if ( props . lg ) { classNames . push ( `template` ) ; } const { xsOffset , smOffset , mdOffset , lgOffset } = props ; if ( ! isUndefined ( xsOffset ) ) { classNames . push ( `template` ) ; } if ( ! isUndefined ( smOffset ) ) { classNames . push ( `template` ) ; } if ( ! isUndefined ( mdOffset ) ) { classNames . push ( `template` ) ; } if ( ! isUndefined ( lgOffset ) ) { classNames . push ( `template` ) ; } return classNames . join ( "s" ) ; }	O O $any$ O O O O O $any$ O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O $number$ O O O O O O O $string$ O $Props$ O $string$ $string$ O O O $string[]$ O O O O O O O O O O $string$ O O $string[]$ O $number$ O $string$ O O O O O $Props$ O $number$ O O $string[]$ O $number$ O O O O O O O $Props$ O $number$ O O $string[]$ O $number$ O O O O O O O $Props$ O $number$ O O $string[]$ O $number$ O O O O O O O $Props$ O $number$ O O $string[]$ O $number$ O O O O O O O $number$ O $number$ O $number$ O $number$ O O $Props$ O O O O $any$ O $number$ O O O $string[]$ O $number$ O O O O O O O O $any$ O $number$ O O O $string[]$ O $number$ O O O O O O O O $any$ O $number$ O O O $string[]$ O $number$ O O O O O O O O $any$ O $number$ O O O $string[]$ O $number$ O O O O O O $string[]$ O $string$ O O O O O
import { parseClassNames } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const base = "s" ; const results = parseClassNames ( { xs : 0 , sm : 0 , md : 0 , lg : 0 , xsOffset : 0 , smOffset : 0 , mdOffset : 0 , lgOffset : 0 , } , base ) ; [ base , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , ] . map ( string => expect ( results ) . toContain ( string ) ) ; } ) ; } ) ;	O O $string$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $string$ O $string$ O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $U[]$ O $string$ O $any$ O $string$ O O $any$ O $string$ O O O O O O O O O
import { WidgetFooter } from "s" ; import { mount } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = mount ( WidgetFooter ( { children : "s" } ) ) ; expect ( result . html ( ) ) . toContain ( "s" ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O
import { WidgetHeader } from "s" ; import { mount } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const wrapper = mount ( WidgetHeader ( { title : "s" } ) ) ; expect ( wrapper . html ( ) ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const wrapper = mount ( WidgetHeader ( { title : "s" , children : "s" } ) ) ; expect ( wrapper . html ( ) ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const wrapper = mount ( WidgetHeader ( { title : "s" , helpText : "s" } ) ) ; expect ( wrapper . html ( ) ) . toContain ( "s" ) ; expect ( wrapper . find ( "s" ) . html ( ) ) . toContain ( "s" ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O O O O O O O O O
import { Widget } from "s" ; import { mount } from "s" ; describe ( "s" , ( ) => { const params = { children : "s" , className : "s" } ; const result = mount ( Widget ( params ) ) ; it ( "s" , ( ) => { expect ( result . html ( ) ) . toContain ( "s" ) ; } ) ; it ( "s" , ( ) => { const element = result . find ( "s" ) ; expect ( element . hasClass ( "s" ) ) . toBeTruthy ( ) ; expect ( element . hasClass ( "s" ) ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O O $any$ O $any$ O $any$ O $complex$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O
import { prettyPrintApiErrors , catchErrors } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = prettyPrintApiErrors ( { response : { data : { email : "s" } } } ) ; expect ( result ) . toEqual ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const e = new Error ( "s" ) ; expect ( ( ) => catchErrors ( e ) ) . toThrow ( "s" ) ; } ) ; } ) ;	O O $any$ O $void$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O $complex$ O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $Error$ O O $ErrorConstructor$ O O O O $any$ O O O O $void$ O $Error$ O O O $any$ O O O O O O O O O O
import { IntegerSize , clampUnsignedInteger } from "s" ; describe ( "s" , ( ) => { function clampTest ( input , output : number | undefined , message , size ) { it ( `template` , ( ) => { const result = clampUnsignedInteger ( input , size ) ; expect ( result . outcome ) . toEqual ( message ) ; expect ( result . result ) . toEqual ( output ) ; } ) ; } clampTest ( "s" , undefined , "s" , "s" ) ; clampTest ( "s" , 0 , "s" , "s" ) ; clampTest ( "s" , 0 , "s" , "s" ) ; clampTest ( "s" , 0 , "s" , "s" ) ; clampTest ( "s" , 0 , "s" , "s" ) ; clampTest ( "s" , 0 , "s" , "s" ) ; } ) ;	O O $any$ O $ClampResult$ O O O O $any$ O O O O O O O O $void$ O $string$ O $number$ O O O O O $string$ O $IntegerSize$ O O $any$ O O O O O O O O $ClampResult$ O $ClampResult$ O $string$ O $IntegerSize$ O O $any$ O $ClampResult$ O O O O $any$ O $string$ O O $any$ O $ClampResult$ O $number$ O O $any$ O $number$ O O O O O O $void$ O O O $undefined$ O O O O O O $void$ O O O O O O O O O O $void$ O O O O O O O O O O $void$ O O O O O O O O O O $void$ O O O O O O O O O O $void$ O O O O O O O O O O O O O
import { move } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const fixture = [ 0 , 0 , 0 ] ; const 0 = move ( fixture , 0 , 0 ) ; expect ( 0 [ 0 ] ) . toEqual ( 0 ) ; expect ( 0 [ 0 ] ) . toEqual ( 0 ) ; expect ( 0 [ 0 ] ) . toEqual ( 0 ) ; const 0 = move ( fixture , 0 , 0 ) ; expect ( 0 [ 0 ] ) . toEqual ( 0 ) ; expect ( 0 [ 0 ] ) . toEqual ( 0 ) ; expect ( 0 [ 0 ] ) . toEqual ( 0 ) ; const 0 = move ( fixture , 0 , 0 ) ; expect ( 0 ) . toEqual ( fixture ) ; } ) ; } ) ;	O O $T[]$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $number[]$ O O O O O O O O O O $number[]$ O $T[]$ O $number[]$ O O O O O O $any$ O $number[]$ O O O O O $any$ O O O O $any$ O $number[]$ O O O O O $any$ O O O O $any$ O $number[]$ O O O O O $any$ O O O O O $number[]$ O $T[]$ O $number[]$ O O O O O O $any$ O $number[]$ O O O O O $any$ O O O O $any$ O $number[]$ O O O O O $any$ O O O O $any$ O $number[]$ O O O O O $any$ O O O O O $number[]$ O $T[]$ O $number[]$ O O O O O O $any$ O $number[]$ O O $any$ O $number[]$ O O O O O O O O
import { Progress } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const cb = jest . fn ( ) ; const counter = new Progress ( 0 , cb ) ; counter . inc ( ) ; expect ( cb ) . toHaveBeenCalledWith ( counter ) ; counter . inc ( ) ; counter . inc ( ) ; cb . mockClear ( ) ; counter . inc ( ) ; expect ( cb ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { const cb = jest . fn ( ) ; const counter = new Progress ( 0 , cb ) ; counter . finish ( ) ; expect ( cb ) . toHaveBeenCalled ( ) ; expect ( counter . isDone ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Progress$ O O $any$ O O O $any$ O O $Progress$ O $void$ O O O $any$ O $any$ O O $any$ O $Progress$ O O $Progress$ O $void$ O O O $Progress$ O $void$ O O O $any$ O $any$ O O O $Progress$ O $void$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $Progress$ O O $any$ O O O $any$ O O $Progress$ O $void$ O O O $any$ O $any$ O O $any$ O O O $any$ O $Progress$ O $boolean$ O O $any$ O O O O O O O O O
import { stopIE } from "s" ; describe ( "s" , ( ) => { beforeEach ( ( ) => { window . location . assign = jest . fn ( ) ; window . alert = jest . fn ( ) ; window . hasOwnProperty = ( ) => true ; Array . prototype . hasOwnProperty = ( ) => true ; Object . defineProperty ( Object , "s" , { value : true , configurable : true } ) ; } ) ; const expectToHaveBeenStopped = ( ) => { expect ( window . alert ) . toHaveBeenCalledWith ( "s" ) ; expect ( window . location . assign ) . toHaveBeenCalledWith ( "s" ) ; } ; it ( "s" , ( ) => { stopIE ( ) ; expect ( window . alert ) . not . toHaveBeenCalled ( ) ; expect ( window . location . assign ) . not . toHaveBeenCalled ( ) ; } ) ; it ( "s" , ( ) => { Object . defineProperty ( Object , "s" , { value : undefined } ) ; stopIE ( ) ; expectToHaveBeenStopped ( ) ; } ) ; it ( "s" , ( ) => { window . hasOwnProperty = ( ) => false ; stopIE ( ) ; expectToHaveBeenStopped ( ) ; } ) ; it ( "s" , ( ) => { Array . prototype . hasOwnProperty = ( ) => false ; stopIE ( ) ; expectToHaveBeenStopped ( ) ; } ) ; it ( "s" , ( ) => { Array . prototype . hasOwnProperty = ( ) => { throw new Error ( ) ; } ; stopIE ( ) ; expectToHaveBeenStopped ( ) ; } ) ; } ) ;	O O $void$ O O O O $any$ O O O O O O O $any$ O O O O O $complex$ O $Location$ O $void$ O $any$ O $any$ O O O $complex$ O $void)$ O $any$ O $any$ O O O $complex$ O $boolean$ O O O O O O $ArrayConstructor$ O $any[]$ O $boolean$ O O O O O O $ObjectConstructor$ O $any$ O $ObjectConstructor$ O O O O $boolean$ O O O $true$ O O O O O O O O O $void$ O O O O O $any$ O $complex$ O $void)$ O O $any$ O O O O $any$ O $complex$ O $Location$ O $void$ O O $any$ O O O O O O $any$ O O O O O O O $void$ O O O $any$ O $complex$ O $void)$ O O $any$ O $any$ O O O $any$ O $complex$ O $Location$ O $void$ O O $any$ O $any$ O O O O O O $any$ O O O O O O O $ObjectConstructor$ O $any$ O $ObjectConstructor$ O O O O $undefined$ O $undefined$ O O O $void$ O O O $void$ O O O O O O $any$ O O O O O O O $complex$ O $boolean$ O O O O O O $void$ O O O $void$ O O O O O O $any$ O O O O O O O $ArrayConstructor$ O $any[]$ O $boolean$ O O O O O O $void$ O O O $void$ O O O O O O $any$ O O O O O O O $ArrayConstructor$ O $any[]$ O $boolean$ O O O O O O O $ErrorConstructor$ O O O O O $void$ O O O $void$ O O O O O O O O O
import * as Util from "s" ; import { times } from "s" ; import { fakeTimeSettings } from "s" ; describe ( "s" , ( ) => { describe ( "s" , ( ) => { const data = { "s" : null , "s" : undefined , "s" : 0 , "s" : "s" , "s" : false , "s" : ( ) => { "s" ; } } ; it ( "s" , ( ) => { expect ( Util . safeStringFetch ( data , "s" ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( Util . safeStringFetch ( data , "s" ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( Util . safeStringFetch ( data , "s" ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( Util . safeStringFetch ( data , "s" ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( Util . safeStringFetch ( data , "s" ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { expect ( ( ) => Util . safeStringFetch ( data , "s" ) ) . toThrow ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const before = [ { } , { } , undefined ] ; const after = Util . betterCompact ( before ) ; expect ( after . length ) . toBe ( 0 ) ; expect ( after ) . not . toContain ( undefined ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const origin = { a : "s" , c : 0 , d : [ { e : { f : "s" } } ] } ; const child = Util . defensiveClone ( origin ) ; origin . a = "s" ; origin . c = 0 ; origin . d [ 0 ] . e . f = "s" ; expect ( child ) . not . toBe ( origin ) ; expect ( child . a ) . toEqual ( "s" ) ; expect ( child . c ) . toEqual ( 0 ) ; expect ( child . d [ 0 ] . e . f ) . toEqual ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( Util . oneOf ( [ "s" ] , "s" ) ) . toBeTruthy ( ) ; expect ( Util . oneOf ( [ "s" , "s" ] , "s" ) ) . toBeTruthy ( ) ; } ) ; it ( "s" , ( ) => { expect ( Util . oneOf ( [ "s" ] , "s" ) ) . toBeFalsy ( ) ; expect ( Util . oneOf ( [ "s" , "s" ] , "s" ) ) . toBeFalsy ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const string = `template` ; const formattedString = Util . trim ( string ) ; expect ( formattedString ) . toEqual ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( Util . bitArray ( true ) ) . toBe ( 0 ) ; expect ( Util . bitArray ( true , false ) ) . toBe ( 0 ) ; expect ( Util . bitArray ( false , true ) ) . toBe ( 0 ) ; expect ( Util . bitArray ( true , true ) ) . toBe ( 0 ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { globalConfig . SHORT_REVISION = "s" ; const short = Util . shortRevision ( ) ; expect ( short ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { globalConfig . SHORT_REVISION = "s" ; const short = Util . shortRevision ( ) ; expect ( short ) . toEqual ( "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = Util . isUndefined ( undefined ) ; expect ( result ) . toBeTruthy ( ) ; } ) ; it ( "s" , ( ) => { const result = Util . isUndefined ( { } ) ; expect ( result ) . toBeFalsy ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { times ( Util . colors . length * 0 , ( ) => expect ( Util . colors ) . toContain ( Util . randomColor ( ) ) ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const result = Util . validBotLocationData ( undefined ) ; expect ( result ) . toEqual ( { position : { x : undefined , y : undefined , z : undefined } , scaled_encoders : { x : undefined , y : undefined , z : undefined } , raw_encoders : { x : undefined , y : undefined , z : undefined } } ) ; } ) ; it ( "s" , ( ) => { const result = Util . validBotLocationData ( { raw_encoders : { x : 0 } } as any ) ; expect ( result ) . toEqual ( { position : { x : undefined , y : undefined , z : undefined } , scaled_encoders : { x : undefined , y : undefined , z : undefined } , raw_encoders : { x : 0 , y : undefined , z : undefined } } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const test = { testing : "s" } ; console . log = jest . fn ( ) ; const result = Util . fancyDebug ( test ) ; expect ( result ) . toBe ( test ) ; expect ( console . log ) . toHaveBeenCalledWith ( "s" ) ; } ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( Util . parseIntInput ( "s" ) ) . toEqual ( - 0 ) ; expect ( Util . parseIntInput ( "s" ) ) . toEqual ( 0 ) ; expect ( Util . parseIntInput ( "s" ) ) . toEqual ( 0 ) ; expect ( Util . parseIntInput ( "s" ) ) . toEqual ( 0 ) ; expect ( Util . parseIntInput ( "s" ) ) . toEqual ( 0 ) ; expect ( Util . parseIntInput ( "s" ) ) . toEqual ( NaN ) ; expect ( Util . parseIntInput ( "s" ) ) . toEqual ( NaN ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { const timeSettings = fakeTimeSettings ( ) ; timeSettings . 0 = false ; expect ( Util . timeFormatString ( timeSettings ) ) . toEqual ( "s" ) ; } ) ; it ( "s" , ( ) => { const timeSettings = fakeTimeSettings ( ) ; timeSettings . 0 = true ; expect ( Util . timeFormatString ( timeSettings ) ) . toEqual ( "s" ) ; } ) ; } ) ;	O O O $any$ O O O O O $any$ O O O O O O $TimeSettings$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O O O O O O O $undefined$ O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O $any$ O $string$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $string$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $string$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $string$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $string$ O $complex$ O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O O O O $any$ O $string$ O $complex$ O O O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O ${}[]$ O O O O O O O O $undefined$ O O O ${}[]$ O $any$ O $T[]$ O ${}[]$ O O $any$ O ${}[]$ O $number$ O O $any$ O O O O $any$ O ${}[]$ O O $any$ O $any$ O $undefined$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O $number$ O O O $complex$ O O O $complex$ O O $string$ O O O O O O O O $complex$ O $any$ O $T$ O $complex$ O O $complex$ O $string$ O O O $complex$ O $number$ O O O $complex$ O $complex$ O O O O $complex$ O $string$ O O O $any$ O $complex$ O O $any$ O $any$ O $complex$ O O $any$ O $complex$ O $string$ O O $any$ O O O O $any$ O $complex$ O $number$ O O $any$ O O O O $any$ O $complex$ O $complex$ O O O O $complex$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O O O $any$ O $any$ O $boolean$ O O O O O O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O $boolean$ O O O O O O O O O $any$ O O O $any$ O $any$ O $boolean$ O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $string$ O $any$ O $string$ O O O O $any$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $number$ O O O O O $any$ O O O O $any$ O $any$ O $number$ O O O O O O O $any$ O O O O $any$ O $any$ O $number$ O O O O O O O $any$ O O O O $any$ O $any$ O $number$ O O O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $complex$ O $any$ O O O O $string$ O $any$ O $string$ O O O $any$ O $string$ O O $any$ O O O O O O O $any$ O O O O O O O $complex$ O $any$ O O O O $string$ O $any$ O $string$ O O O $any$ O $string$ O O $any$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $boolean$ O $any$ O $complex$ O $undefined$ O O $any$ O $boolean$ O O $any$ O O O O O O $any$ O O O O O O O O $boolean$ O $any$ O $complex$ O O O O O $any$ O $boolean$ O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $any[]$ O $number$ O O O O O O $any$ O $any$ O $any[]$ O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $complex$ O $undefined$ O O $any$ O $complex$ O O $any$ O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $complex$ O O $complex$ O O $number$ O O O O O O O O $any$ O $complex$ O O $any$ O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O $complex$ O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O $complex$ O O $number$ O O O $undefined$ O $undefined$ O $undefined$ O $undefined$ O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O $Console$ O $void$ O $any$ O $any$ O O O O $complex$ O $any$ O $T$ O $complex$ O O $any$ O $complex$ O O $any$ O $complex$ O O $any$ O $Console$ O $void$ O O $any$ O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $any$ O $number$ O O O O O $any$ O O O O O $any$ O $any$ O $number$ O O O O O $any$ O O O O $any$ O $any$ O $number$ O O O O O $any$ O O O O $any$ O $any$ O $number$ O O O O O $any$ O O O O $any$ O $any$ O $number$ O O O O O $any$ O O O O $any$ O $any$ O $number$ O O O O O $any$ O $number$ O O $any$ O $any$ O $number$ O O O O O $any$ O $number$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $TimeSettings$ O $TimeSettings$ O O O $TimeSettings$ O $boolean$ O O O $any$ O $any$ O $string$ O $TimeSettings$ O O O $any$ O O O O O O O $any$ O O O O O O O O $TimeSettings$ O $TimeSettings$ O O O $TimeSettings$ O $boolean$ O O O $any$ O $any$ O $string$ O $TimeSettings$ O O O $any$ O O O O O O O O O O
import { semverCompare , SemverResult , minFwVersionCheck , createShouldDisplayFn , determineInstalledOsVersion , versionOK , } from "s" ; import { bot } from "s" ; import { fakeDevice } from "s" ; import { Feature } from "s" ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . RIGHT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . RIGHT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . RIGHT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . RIGHT_IS_GREATER ) ; } ) ; it ( "s" , ( ) => { expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . RIGHT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . RIGHT_IS_GREATER ) ; } ) ; it ( "s" , ( ) => { expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . RIGHT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . RIGHT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . RIGHT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . RIGHT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . RIGHT_IS_GREATER ) ; } ) ; it ( "s" , ( ) => { expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . LEFT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . LEFT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . LEFT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . LEFT_IS_GREATER ) ; } ) ; it ( "s" , ( ) => { expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . LEFT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . LEFT_IS_GREATER ) ; } ) ; it ( "s" , ( ) => { expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . LEFT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . LEFT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . LEFT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . LEFT_IS_GREATER ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . LEFT_IS_GREATER ) ; } ) ; it ( "s" , ( ) => { expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . EQUAL ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . EQUAL ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . EQUAL ) ; expect ( semverCompare ( "s" , "s" ) ) . toBe ( SemverResult . EQUAL ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( minFwVersionCheck ( "s" , "s" ) ) . toBeTruthy ( ) ; expect ( minFwVersionCheck ( "s" , "s" ) ) . toBeTruthy ( ) ; } ) ; it ( "s" , ( ) => { expect ( minFwVersionCheck ( "s" , "s" ) ) . toBeFalsy ( ) ; expect ( minFwVersionCheck ( undefined , "s" ) ) . toBeFalsy ( ) ; expect ( minFwVersionCheck ( "s" , "s" ) ) . toBeFalsy ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { const fakeMinOsData = { jest_feature : "s" } ; it ( "s" , ( ) => { expect ( createShouldDisplayFn ( "s" , fakeMinOsData , undefined ) ( Feature . jest_feature ) ) . toBeTruthy ( ) ; expect ( createShouldDisplayFn ( "s" , fakeMinOsData , undefined ) ( Feature . jest_feature ) ) . toBeTruthy ( ) ; expect ( createShouldDisplayFn ( "s" , { jest_feature : "s" } , undefined ) ( Feature . jest_feature ) ) . toBeTruthy ( ) ; } ) ; it ( "s" , ( ) => { expect ( createShouldDisplayFn ( "s" , fakeMinOsData , undefined ) ( Feature . jest_feature ) ) . toBeFalsy ( ) ; expect ( createShouldDisplayFn ( undefined , fakeMinOsData , undefined ) ( Feature . jest_feature ) ) . toBeFalsy ( ) ; const unknown_feature = "s" as any ; expect ( createShouldDisplayFn ( "s" , fakeMinOsData , undefined ) ( unknown_feature ) ) . toBeFalsy ( ) ; expect ( createShouldDisplayFn ( "s" , undefined , undefined ) ( unknown_feature ) ) . toBeFalsy ( ) ; expect ( createShouldDisplayFn ( "s" , "s" as any , undefined ) ( unknown_feature ) ) . toBeFalsy ( ) ; expect ( createShouldDisplayFn ( "s" , "s" as any , undefined ) ( unknown_feature ) ) . toBeFalsy ( ) ; expect ( createShouldDisplayFn ( "s" , "s" as any , undefined ) ( unknown_feature ) ) . toBeFalsy ( ) ; } ) ; } ) ; describe ( "s" , ( ) => { const checkVersionResult = ( fromBot : string | undefined , api : string | undefined , expected : string | undefined ) => { bot . hardware . informational_settings . controller_version = fromBot ; const d = fakeDevice ( ) ; d . body . fbos_version = api ; const result = determineInstalledOsVersion ( bot , d ) ; expect ( result ) . toEqual ( expected ) ; } ; it ( "s" , ( ) => { checkVersionResult ( undefined , undefined , undefined ) ; checkVersionResult ( "s" , undefined , "s" ) ; checkVersionResult ( undefined , "s" , "s" ) ; checkVersionResult ( "s" , undefined , undefined ) ; checkVersionResult ( undefined , "s" , undefined ) ; checkVersionResult ( "s" , "s" , "s" ) ; checkVersionResult ( "s" , "s" , "s" ) ; checkVersionResult ( "s" , "s" , "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , ( ) => { expect ( versionOK ( "s" , 0 , 0 ) ) . toBeTruthy ( ) ; expect ( versionOK ( "s" , 0 , 0 ) ) . toBeTruthy ( ) ; expect ( versionOK ( "s" , 0 , 0 ) ) . toBeTruthy ( ) ; expect ( versionOK ( "s" , 0 , 0 ) ) . toBeTruthy ( ) ; expect ( versionOK ( "s" , 0 , 0 ) ) . toBeTruthy ( ) ; expect ( versionOK ( "s" , 0 , 0 ) ) . toBeFalsy ( ) ; expect ( versionOK ( "s" , 0 , 0 ) ) . toBeFalsy ( ) ; expect ( versionOK ( "s" , 0 , 0 ) ) . toBeFalsy ( ) ; expect ( versionOK ( "s" , 0 , 0 ) ) . toBeFalsy ( ) ; } ) ; } ) ;	O O $SemverResult$ O $any$ O $boolean$ O $boolean$ O $string$ O $boolean$ O O O O O O O $BotState$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O O O O $any$ O O O O O O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O O O O $any$ O O O O O O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.RIGHT_IS_GREATER$ O O O O O $any$ O O O O O O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.LEFT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.LEFT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.LEFT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.LEFT_IS_GREATER$ O O O O O $any$ O O O O O O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.LEFT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.LEFT_IS_GREATER$ O O O O O $any$ O O O O O O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.LEFT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.LEFT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.LEFT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.LEFT_IS_GREATER$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.LEFT_IS_GREATER$ O O O O O $any$ O O O O O O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.EQUAL$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.EQUAL$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.EQUAL$ O O $any$ O $SemverResult$ O O O O O O O $any$ O $any$ O $SemverResult.EQUAL$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $boolean$ O O O O O O O $any$ O O O $any$ O $boolean$ O O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $boolean$ O O O O O O O $any$ O O O $any$ O $boolean$ O $undefined$ O O O O O $any$ O O O $any$ O $boolean$ O O O O O O O $any$ O O O O O O O O O $any$ O O O O O O O O $complex$ O O $string$ O O O O $any$ O O O O O O O $any$ O $boolean$ O O O $complex$ O $undefined$ O O $any$ O $Feature.jest_feature$ O O O $any$ O O O $any$ O $boolean$ O O O $complex$ O $undefined$ O O $any$ O $Feature.jest_feature$ O O O $any$ O O O $any$ O $boolean$ O O O O $string$ O O O O $undefined$ O O $any$ O $Feature.jest_feature$ O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $boolean$ O O O $complex$ O $undefined$ O O $any$ O $Feature.jest_feature$ O O O $any$ O O O $any$ O $boolean$ O $undefined$ O $complex$ O $undefined$ O O $any$ O $Feature.jest_feature$ O O O $any$ O O O O $any$ O O O O O $any$ O $boolean$ O O O $complex$ O $undefined$ O O $any$ O O O $any$ O O O $any$ O $boolean$ O O O $undefined$ O $undefined$ O O $any$ O O O $any$ O O O $any$ O $boolean$ O O O O O O O $undefined$ O O $any$ O O O $any$ O O O $any$ O $boolean$ O O O O O O O $undefined$ O O $any$ O O O $any$ O O O $any$ O $boolean$ O O O O O O O $undefined$ O O $any$ O O O $any$ O O O O O O O O O $any$ O O O O O O O O $void$ O O $string$ O O O O O $string$ O O O O O $string$ O O O O O O O $BotState$ O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $string$ O O $string$ O $string$ O $BotState$ O $any$ O O $any$ O $string$ O O $any$ O $string$ O O O O $any$ O O O O O O O $void$ O $undefined$ O $undefined$ O $undefined$ O O $void$ O O O $undefined$ O O O O $void$ O $undefined$ O O O O O O $void$ O O O $undefined$ O $undefined$ O O $void$ O $undefined$ O O O $undefined$ O O $void$ O O O O O O O O $void$ O O O O O O O O $void$ O O O O O O O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $boolean$ O O O O O O O O O $any$ O O O $any$ O $boolean$ O O O O O O O O O $any$ O O O $any$ O $boolean$ O O O O O O O O O $any$ O O O $any$ O $boolean$ O O O O O O O O O $any$ O O O $any$ O $boolean$ O O O O O O O O O $any$ O O O $any$ O $boolean$ O O O O O O O O O $any$ O O O $any$ O $boolean$ O O O O O O O O O $any$ O O O $any$ O $boolean$ O O O O O O O O O $any$ O O O $any$ O $boolean$ O O O O O O O O O $any$ O O O O O O O O O
'js' var HelperNamespace = ( function ( ) { function walkSync ( dir , filelist , ext ) { var path = path || require ( 's' ) ; var fs = fs || require ( 's' ) , files = fs . readdirSync ( dir ) ; filelist = filelist || [ ] ; files . forEach ( function ( file ) { if ( fs . statSync ( path . join ( dir , file ) ) . isDirectory ( ) ) { filelist = walkSync ( path . join ( dir , file ) , filelist , ext ) ; } else { if ( file . indexOf ( ext ) > 0 ) filelist . push ( path . join ( dir , file ) ) ; } } ) ; return filelist ; } function searchInFile ( path , regex ) { var fs = fs || require ( 's' ) ; var fileContent = fs . readFileSync ( path , 's' ) ; var strArray = [ ] ; var match = regex . exec ( fileContent ) ; while ( match != null ) { strArray . push ( match [ 0 ] . replace ( "s" , 's' ) ) ; match = regex . exec ( fileContent ) ; } return strArray ; } function localeSort ( a , b ) { return a . localeCompare ( b ) ; } var T_REGEX = "s" ; var C_REGEX = "s" ; var EXTRA_TAGS = [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , ] ; function getAllTags ( ) { var srcPath = __dirname + 's' ; var listFilteredFiles = walkSync ( srcPath , [ ] , 's' ) ; var allTags = listFilteredFiles . map ( function ( x ) { return searchInFile ( x , T_REGEX ) ; } ) ; var constantsTags = searchInFile ( srcPath + 's' , C_REGEX ) ; var flatAllTags = [ ] . concat . apply ( [ ] , allTags ) ; var flatConstantsTags = [ ] . concat . apply ( [ ] , constantsTags ) ; var flatExtraTags = [ ] . concat . apply ( [ ] , EXTRA_TAGS ) ; var flattenedTags = [ ] . concat . apply ( [ ] , [ flatAllTags , flatConstantsTags , flatExtraTags ] ) ; var uniq = Array . from ( new Set ( flattenedTags ) ) ; var sorted = uniq . sort ( localeSort ) ; return sorted ; } function logAllTags ( ) { console . dir ( getAllTags ( ) ) ; } function replaceWithDebugString ( key , debugString , debugStringOption ) { var debugChar = debugString [ 0 ] ; switch ( debugStringOption ) { case 's' : return debugString ; case 's' : return debugChar ; case 's' : return key . replace ( "s" , debugChar ) ; case 's' : return debugChar . repeat ( key . length ) ; default : return key ; } } var metrics = [ ] ; function generateMetrics ( ) { var languageCodes = walkSync ( __dirname , [ ] , 's' ) . filter ( function ( s ) { return ! s . includes ( 's' ) ; } ) . filter ( function ( s ) { return ! ( s . includes ( 's' ) || s . includes ( 's' ) ) ; } ) . map ( function ( s ) { return s . slice ( - 's' . length , - 's' . length ) ; } ) ; var fs = fs || require ( 's' ) ; var markdown = 's' ; languageCodes . map ( function ( lang ) { return createOrUpdateTranslationFile ( lang , true ) ; } ) ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' + metrics [ 0 ] . current + 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; metrics . map ( function ( langMetrics ) { markdown += 's' + langMetrics . language ; markdown += 's' + langMetrics . percent + 's' ; markdown += 's' + langMetrics . translated ; markdown += 's' + langMetrics . untranslated ; markdown += 's' + langMetrics . orphans ; markdown += 's' ; } ) ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; markdown += 's' ; fs . writeFileSync ( __dirname + 's' , markdown ) ; } function generateSummary ( args ) { var current = Object . keys ( args . foundTags ) . length ; var orphans = Object . keys ( args . unmatchedTags ) . length ; var untranslated = Object . keys ( args . untranslated ) . length ; var translated = Object . keys ( args . translated ) . length ; var total = untranslated + translated + orphans ; var percent = Math . round ( translated / current * 0 ) ; var existingUntranslated = args . countExisting - translated ; if ( ! args . metricsOnly ) { console . log ( current + 's' ) ; console . log ( 's' + args . countExisting + 's' ) ; console . log ( 's' + translated + 's' ) ; console . log ( 's' + existingUntranslated + 's' ) ; console . log ( 's' + ( current - args . countExisting ) + 's' ) ; console . log ( percent + 's' ) ; console . log ( orphans + 's' ) ; console . log ( 's' + args . langCode + 's' + total + 's' ) ; } return { percent : percent , orphans : orphans , total : total , untranslated : untranslated , current : current , translated : translated , language : args . langCode } ; } function createOrUpdateTranslationFile ( lang , metricsOnly ) { lang = lang || 's' ; var langFilePath = __dirname + 's' + lang + 's' ; var fs = fs || require ( 's' ) ; try { var columnsResult = HelperNamespace . getAllTags ( ) ; var jsonCurrentTagData = { } ; columnsResult . forEach ( function ( column ) { jsonCurrentTagData [ column ] = column ; } ) ; var ordered = { } ; var translatedKeys = [ ] ; var fileContent ; try { var stats = fs . statSync ( langFilePath ) ; fileContent = fs . readFileSync ( langFilePath , 's' ) ; if ( lang == 's' ) { console . log ( 's' + lang + 's' ) ; console . log ( fileContent ) ; console . log ( 's' ) ; console . log ( 's' ) ; if ( ! metricsOnly ) { generateMetrics ( ) ; } return ; } } catch ( e ) { if ( ! metricsOnly ) { console . log ( 's' + langFilePath ) ; } } try { if ( fileContent != undefined ) { var jsonParsed = JSON . parse ( fileContent ) ; translatedKeys . push . apply ( translatedKeys , Object . keys ( JSON . parse ( fileContent ) . translated ) ) ; var combinedContent = jsonParsed . translated ; if ( 's' in jsonParsed ) { for ( var untranslated_key in jsonParsed . untranslated ) { combinedContent [ untranslated_key ] = jsonParsed . untranslated [ untranslated_key ] ; } } if ( 's' in jsonParsed ) { for ( var other_key in jsonParsed . other_translations ) { combinedContent [ other_key ] = jsonParsed . other_translations [ other_key ] ; } } var count = Object . keys ( combinedContent ) . length ; if ( ! metricsOnly ) { console . log ( 's' + lang + 's' + count + 's' ) ; } Object . keys ( combinedContent ) . sort ( localeSort ) . forEach ( function ( key ) { ordered [ key ] = combinedContent [ key ] ; } ) ; } } catch ( e ) { if ( ! metricsOnly ) { console . log ( 's' + langFilePath + 's' + e ) ; } return ; } var debug = process . argv [ 0 ] ; var debugOption = process . argv [ 0 ] ; var untranslated = { } ; var translated = { } ; var other_translations = { } ; var existing = 0 ; Object . keys ( jsonCurrentTagData ) . sort ( localeSort ) . map ( function ( key ) { untranslated [ key ] = jsonCurrentTagData [ key ] ; if ( debug ) { untranslated [ key ] = replaceWithDebugString ( key , debug , debugOption ) ; } } ) ; for ( var key in ordered ) { if ( untranslated . hasOwnProperty ( key ) ) { existing ++ ; if ( ( key !== ordered [ key ] ) || translatedKeys . includes ( key ) ) { delete untranslated [ key ] ; translated [ key ] = ordered [ key ] ; if ( debug ) { translated [ key ] = replaceWithDebugString ( key , debug , debugOption ) ; } } } else { other_translations [ key ] = ordered [ key ] ; } } var summaryData = generateSummary ( { langCode : lang , untranslated : untranslated , foundTags : jsonCurrentTagData , unmatchedTags : other_translations , translated : translated , countExisting : existing , metricsOnly : metricsOnly } ) ; if ( metricsOnly ) { metrics . push ( summaryData ) ; } var jsonContent = { translated : translated , untranslated : untranslated , other_translations : other_translations , } ; var stringJson = JSON . stringify ( jsonContent , null , 0 ) ; stringJson += 's' ; if ( ! metricsOnly ) { fs . writeFileSync ( langFilePath , stringJson ) ; } } catch ( e ) { if ( ! metricsOnly ) { console . log ( 's' + langFilePath + 's' + e ) ; } } if ( ! metricsOnly ) { generateMetrics ( ) ; } } return { logAllTags : logAllTags , getAllTags : getAllTags , createOrUpdateTranslationFile : createOrUpdateTranslationFile } ; } ) ( ) ; var language = process . argv [ 0 ] ; HelperNamespace . createOrUpdateTranslationFile ( language , false ) ;	O O $complex$ O O O O O O O $any$ O $string$ O $any$ O $string$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O $any$ O $string$ O O O O O O O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $any$ O $any$ O $string$ O $any$ O O O O O O O O $any$ O O O $any[]$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any[]$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any[]$ O $number$ O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $RegExp$ O O O O $RegExp$ O O O O $string[]$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any[]$ O O O O $string$ O $any$ O O O O $any$ O $any$ O $string$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $any[]$ O $any$ O $RegExp$ O O O O O O $any[]$ O $any[]$ O $string$ O O O $RegExp$ O O O $any$ O O O O $complex$ O $any$ O O O O $any$ O O O $any$ O O O O $complex$ O $any$ O O O O $any[]$ O O O $any$ O O O O $complex$ O $any$ O O O O $string[]$ O O O $any$ O O O O $complex$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any[]$ O $ArrayConstructor$ O $complex$ O O $SetConstructor$ O $any$ O O O O $any[]$ O $any[]$ O $any[]$ O $any$ O O O $any[]$ O O O $void$ O O O $Console$ O $void$ O $any[]$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any[]$ O O O O O $void$ O O O O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O O O $any$ O O O $any$ O $any$ O O O O $number$ O O O O $number$ O O O O O O $any$ O $any$ O $any$ O O O O O $string$ O O O $any$ O $any$ O O O $any$ O O O $void$ O $any$ O O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $any[]$ O O O O $any$ O O O $string$ O O O $string$ O O O $string$ O O O $any[]$ O $U[]$ O O O $any$ O O $string$ O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O $string$ O O O $any$ O $any$ O $string$ O O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O O O $string$ O O O O $complex$ O $any$ O O O $number$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O O $number$ O O $number$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O O $number$ O O $number$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O O $number$ O O $number$ O $ObjectConstructor$ O $complex$ O $any$ O $any$ O O $number$ O O $number$ O $number$ O $number$ O $number$ O O $number$ O $Math$ O $number$ O $number$ O $number$ O O O O O $number$ O $any$ O $any$ O $number$ O O O O $any$ O $any$ O O $Console$ O $void$ O $number$ O O O O $Console$ O $void$ O O O $any$ O $any$ O O O O $Console$ O $void$ O O O $number$ O O O O $Console$ O $void$ O O O $number$ O O O O $Console$ O $void$ O O O O $number$ O $any$ O $any$ O O O O O $Console$ O $void$ O $number$ O O O O $Console$ O $void$ O $number$ O O O O $Console$ O $void$ O O O $any$ O $any$ O O O $number$ O O O O O O O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $number$ O $any$ O $any$ O $any$ O O O O $void$ O $string$ O $any$ O O $string$ O $string$ O O O O $string$ O $any$ O O O $string$ O O O O $any$ O $any$ O $any$ O O O O O O O $any[]$ O $complex$ O $any[]$ O O O O ${}$ O O O O $any[]$ O $void$ O O O $any$ O O ${}$ O $any$ O O $any$ O O O O O ${}$ O O O O O $any[]$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O $string$ O O O O O O $string$ O O O O $Console$ O $void$ O O O O O O O O $Console$ O $void$ O $any$ O O $Console$ O $void$ O O O O $Console$ O $void$ O O O O O O O $any$ O O $void$ O O O O O O O O O O $any$ O O O O O $any$ O O $Console$ O $void$ O O O $string$ O O O O O O O O $any$ O $undefined$ O O O $any$ O $JSON$ O $any$ O $any$ O O $any[]$ O $number$ O $any$ O $any[]$ O $ObjectConstructor$ O $complex$ O $JSON$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $string$ O $any$ O $any$ O O $any$ O $string$ O O $any$ O $any$ O $string$ O O O O O O O O $any$ O O O O O $string$ O $any$ O $any$ O O $any$ O $string$ O O $any$ O $any$ O $string$ O O O O O $number$ O $ObjectConstructor$ O $complex$ O $any$ O O $number$ O O O O $any$ O O $Console$ O $void$ O O O $string$ O O O $number$ O O O O O $ObjectConstructor$ O $complex$ O $any$ O O $string[]$ O $any$ O O $void$ O O O $string$ O O ${}$ O $string$ O O $any$ O $string$ O O O O O O O O O $any$ O O O O O $any$ O O $Console$ O $void$ O O O $string$ O O O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O ${}$ O O O O O ${}$ O O O O O ${}$ O O O O O $number$ O O O $ObjectConstructor$ O $complex$ O ${}$ O O $string[]$ O $any$ O O $U[]$ O O O $string$ O O ${}$ O $string$ O O ${}$ O $string$ O O O O $any$ O O ${}$ O $string$ O O $any$ O $string$ O $any$ O $any$ O O O O O O O O O $string$ O ${}$ O O O O ${}$ O $boolean$ O $string$ O O O $number$ O O O O O $string$ O ${}$ O $string$ O O O $any[]$ O $boolean$ O $string$ O O O O ${}$ O $string$ O O ${}$ O $string$ O O ${}$ O $string$ O O O O $any$ O O ${}$ O $string$ O O $any$ O $string$ O $any$ O $any$ O O O O O O O ${}$ O $string$ O O ${}$ O $string$ O O O O O $complex$ O $complex$ O O $string$ O $string$ O ${}$ O ${}$ O ${}$ O ${}$ O ${}$ O ${}$ O ${}$ O ${}$ O $number$ O $number$ O $any$ O $any$ O O O O O $any$ O O $any[]$ O $number$ O $complex$ O O O O $complex$ O O ${}$ O ${}$ O ${}$ O ${}$ O ${}$ O ${}$ O O O O $string$ O $JSON$ O $complex$ O $complex$ O O O O O O $string$ O O O O O O $any$ O O $any$ O $any$ O $string$ O $string$ O O O O O O $any$ O O O O O $any$ O O $Console$ O $void$ O O O $string$ O O O $any$ O O O O O O O $any$ O O $void$ O O O O O O O $void$ O $void$ O $any[]$ O $any[]$ O $void$ O $void$ O O O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O $void$ O $any$ O O O O