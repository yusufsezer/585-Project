'js' const { SpecReporter } = require ( 's' ) ; exports . config = { allScriptsTimeout : 0 , specs : [ 's' ] , capabilities : { chromeOptions : { args : [ "s" ] } , 's' : 's' } , directConnect : true , baseUrl : 's' , framework : 's' , jasmineNodeOpts : { showColors : true , defaultTimeoutInterval : 0 , print : function ( ) { } } , onPrepare ( ) { require ( 's' ) . register ( { project : require ( 's' ) . join ( __dirname , 's' ) } ) ; jasmine . getEnv ( ) . addReporter ( new SpecReporter ( { spec : { displayStacktrace : true } } ) ) ; } } ;	O O O $any$ O O $any$ O O O O $any$ O $any$ O O $number$ O O O $string[]$ O O O O O $complex$ O O $complex$ O O $string[]$ O O O O O O O O O O O $boolean$ O O O $string$ O O O $string$ O O O $complex$ O O $boolean$ O O O $number$ O O O $void$ O O O O O O O O $void$ O O O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O $any$ O O $complex$ O O $boolean$ O O O O O O O O O O
import { InjectionToken } from 's' ; export let ROUTES_CONFIG = new InjectionToken ( 's' ) ; const basePaths = { heroes : 's' , } ; const routesNames = { home : 's' , 0 : 's' , heroes : { basePath : basePaths . heroes } } ; export const RoutesConfig = { routesNames , routes : { home : `template` , 0 : `template` , heroes : { detail : getHeroDetail } } } ; export function getHeroDetail ( id ) { return `template` ; }	O O $any$ O O O O O O $any$ O O $any$ O O O O O $complex$ O O $string$ O O O O O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O $complex$ O $string$ O O O O O $any$ O O O O O O O $string$ O O O $string$ O O O $complex$ O O $string$ O $string$ O O O O O O $string$ O $any$ O O O O O O
import { browser , by , element } from 's' ; import { RoutesConfig } from 's' ; export class HeroesListPage { static navigateTo ( ) { return browser . get ( RoutesConfig . routesNames . heroes . basePath ) ; } static getNumberHeroes ( ) { return element . all ( by . css ( 's' ) ) . count ( ) ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O
import { HeroesListPage } from 's' ; import { browser } from 's' ; describe ( 's' , ( ) => { let page ; beforeEach ( ( ) => { page = new HeroesListPage ( ) ; } ) ; it ( 's' , ( ) => { HeroesListPage . navigateTo ( ) ; browser . driver . sleep ( 0 ) ; expect < any > ( HeroesListPage . getNumberHeroes ( ) ) . toBeGreaterThanOrEqual ( 0 ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O O O O O O O O O
import { browser , by , element } from 's' ; export class HomePage { static navigateTo ( ) { return browser . get ( 's' ) ; } static getNumberHeroes ( ) { return element . all ( by . css ( 's' ) ) . count ( ) ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O
import { InjectionToken } from 's' ; export let APP_CONFIG = new InjectionToken ( 's' ) ; export const AppConfig = { votesLimit : 0 , topHeroesLimit : 0 , snackBarDuration : 0 , repositoryURL : 's' , sentryDSN : 's' , cspDirectives : { defaultSrc : [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , ] , styleSrc : [ 's' , 's' , 's' ] , scriptSrc : [ 's' , 's' , 's' , 's' ] } } ;	O O $any$ O O O O O O $any$ O O $any$ O O O O O O $any$ O O $number$ O O O $number$ O O O $number$ O O O $string$ O O O $string$ O O O $complex$ O O $string[]$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string[]$ O O O O O O O O O $string[]$ O O O O O O O O O O O O O
import { HomePage } from 's' ; import { AppConfig } from 's' ; import { browser } from 's' ; describe ( 's' , ( ) => { let page ; beforeEach ( ( ) => { page = new HomePage ( ) ; } ) ; it ( 's' , ( ) => { HomePage . navigateTo ( ) ; browser . driver . sleep ( 0 ) ; expect < any > ( HomePage . getNumberHeroes ( ) ) . toBe ( AppConfig . topHeroesLimit ) ; } ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O
'js' 's' ; const webpack = require ( 's' ) ; module . exports = { plugins : [ new webpack . ContextReplacementPlugin ( "s" , "s" ) ] } ;	O O O O $any$ O $any$ O O O O $complex$ O $complex$ O O $any[]$ O O O $any$ O $any$ O O O O O O O O
import 's' ; import 's' ; import { enableProdMode } from 's' ; import * as express from 's' ; import * as helmet from 's' ; import { join } from 's' ; import { ngExpressEngine } from 's' ; import { provideModuleMap } from 's' ; import { AppConfig } from 's' ; enableProdMode ( ) ; ( global as any ) . XMLHttpRequest = require ( 's' ) . XMLHttpRequest ; const app = express ( ) ; const PORT = process . env . PORT || 0 ; const DIST_FOLDER = join ( process . cwd ( ) , 's' ) ; const routes = [ { path : 's' , view : 's' , bundle : require ( join ( DIST_FOLDER , 's' , 's' , 's' ) ) } , { path : 's' , view : 's' , bundle : require ( join ( DIST_FOLDER , 's' , 's' , 's' ) ) } ] ; app . use ( helmet ( ) ) ; app . use ( helmet . referrerPolicy ( { policy : 's' } ) ) ; app . use ( helmet . noCache ( ) ) ; app . use ( helmet . featurePolicy ( { features : { fullscreen : [ 's' ] , payment : [ 's' ] , syncXhr : [ 's' ] } } ) ) ; app . use ( helmet . contentSecurityPolicy ( { directives : AppConfig . cspDirectives } ) ) ; app . engine ( 's' , ( filePath , options , callback ) => { options . engine ( filePath , { req : options . req , res : options . res } , callback ) ; } ) ; app . set ( 's' , 's' ) ; app . set ( 's' , join ( DIST_FOLDER , 's' ) ) ; app . get ( 's' , express . static ( join ( DIST_FOLDER , 's' ) ) ) ; routes . forEach ( ( route ) => { app . get ( route . path , ( req , res ) => { res . render ( route . view , { req , res , engine : ngExpressEngine ( { bootstrap : route . bundle . AppServerModuleNgFactory , providers : [ provideModuleMap ( route . bundle . LAZY_MODULE_MAP ) ] } ) } ) ; } ) ; } ) ; app . listen ( PORT , ( ) => { console . log ( `template` ) ; } ) ; export default app ;	O O O O O O O O $any$ O O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $complex$ O O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $string$ O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $string[]$ O O O O O $string[]$ O O O O O $string[]$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O $complex$ O $void$ O O $complex$ O O O $any$ O $any$ O $complex$ O $string$ O O $any$ O $any$ O O O $any$ O $any$ O $complex$ O $string$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $complex$ O $any$ O $any$ O $any[]$ O O $any$ O $complex$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O $Console$ O $void$ O O O O O O O O O $any$ O
import * as functions from 's' ; import app from 's' ; export const ssr = functions . https . onRequest ( app ) ;	O O O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O
'js' module . exports = function ( config ) { config . set ( { basePath : 's' , frameworks : [ 's' , 's' ] , plugins : [ require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) ] , client : { clearContext : false } , coverageIstanbulReporter : { dir : require ( 's' ) . join ( __dirname , 's' ) , reports : [ 's' , 's' ] , fixWebpackSourcePaths : true } , reporters : [ 's' , 's' ] , mochaReporter : { output : 's' } , reportSlowerThan : 0 , port : 0 , colors : true , logLevel : config . LOG_INFO , autoWatch : true , singleRun : false , browsers : [ 's' ] , browserDisconnectTolerance : 0 , browserNoActivityTimeout : 0 , customLaunchers : { ChromeHeadlessNoSandbox : { base : 's' , flags : [ 's' ] } } , restartOnFileChange : true } ) ; } ;	O $void$ O $void$ O O O $any$ O O $any$ O $any$ O O $string$ O O O $string[]$ O O O O O O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $complex$ O O $boolean$ O O O O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O $string[]$ O O O O O O O $boolean$ O O O O $string[]$ O O O O O O O $complex$ O O $string$ O O O O $number$ O O O $number$ O O O $boolean$ O O O $any$ O $any$ O $any$ O $boolean$ O O O $boolean$ O O O $string[]$ O O O O O $number$ O O O $number$ O O O $complex$ O O $complex$ O O $string$ O O O $string[]$ O O O O O O O $boolean$ O O O O O O O
'js' module . exports = function ( config ) { config . set ( { basePath : 's' , frameworks : [ 's' , 's' ] , plugins : [ require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) ] , client : { captureConsole : false , clearContext : false } , coverageIstanbulReporter : { dir : require ( 's' ) . join ( __dirname , 's' ) , reports : [ 's' , 's' ] , fixWebpackSourcePaths : true } , reporters : [ 's' , 's' ] , mochaReporter : { output : 's' } , port : 0 , colors : true , logLevel : config . LOG_INFO , autoWatch : true , singleRun : false , browsers : [ 's' ] , customLaunchers : { ChromeHeadlessNoSandbox : { base : 's' , flags : [ 's' ] } } } ) ; } ;	O $void$ O $void$ O O O $any$ O O $any$ O $any$ O O $string$ O O O $string[]$ O O O O O O O $any[]$ O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $complex$ O O $boolean$ O O O $boolean$ O O O O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O $string[]$ O O O O O O O $boolean$ O O O O $string[]$ O O O O O O O $complex$ O O $string$ O O O O $number$ O O O $boolean$ O O O $any$ O $any$ O $any$ O $boolean$ O O O $boolean$ O O O $string[]$ O O O O O $complex$ O O $complex$ O O $string$ O O O $string[]$ O O O O O O O O O O O
import { Component , OnInit } from 's' ; import * as moment_ from 's' ; const moment = moment_ ; @ Component ( { selector : 's' , template : `template` } ) export class NgxExampleLibraryComponent implements OnInit { date : string ; constructor ( ) { } ngOnInit ( ) { this . date = moment ( ) . format ( 's' ) ; } }	O O $any$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $string$ O O O O O O O O $void$ O O O O O $string$ O $any$ O O O $any$ O O O O O O
import { ComponentFixture , TestBed } from 's' ; import { NgxExampleLibraryComponent } from 's' ; import { DebugElement } from 's' ; import { By } from 's' ; import { configureTestSuite } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < NgxExampleLibraryComponent > ; let debugElement ; let nativeElement ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { declarations : [ NgxExampleLibraryComponent ] } ) ; } ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( NgxExampleLibraryComponent ) ; component = fixture . componentInstance ; debugElement = fixture . debugElement . query ( By . css ( 's' ) ) ; nativeElement = debugElement . nativeElement ; } ) ; it ( 's' , ( ) => { fixture . detectChanges ( ) ; expect ( component ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { fixture . detectChanges ( ) ; const span = debugElement . nativeElement ; expect ( span . innerText ) . toBeDefined ( ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $NgxExampleLibraryComponent$ O O $ComponentFixture$ O $any$ O O O $DebugElement$ O O $HTMLElement$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $NgxExampleLibraryComponent$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $HTMLElement$ O $any$ O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $NgxExampleLibraryComponent$ O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O
import { Injectable } from 's' ; @ Injectable ( { providedIn : 's' } ) export class NgxExampleLibraryService { constructor ( ) { } }	O O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O O O O O O O
import { APP_INITIALIZER , InjectionToken , ModuleWithProviders , NgModule } from 's' ; import { NgxExampleLibraryComponent } from 's' ; import { NgxExampleLibraryService } from 's' ; export const OPTIONS = new InjectionToken < string > ( 's' ) ; export interface SampleModuleOptions { config : { } ; } export function initialize ( options ) { console . log ( 's' , options ) ; return ( ) => { } ; } @ NgModule ( { declarations : [ NgxExampleLibraryComponent ] , exports : [ NgxExampleLibraryComponent ] } ) export class NgxExampleLibraryModule { static forRoot ( options ? ) { return { ngModule : NgxExampleLibraryModule , providers : [ { provide : OPTIONS , useValue : options } , { provide : APP_INITIALIZER , useFactory : initialize , deps : [ OPTIONS ] , multi : true } , NgxExampleLibraryService ] } ; } }	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O $any$ O O O O O O O O O $any$ O ${}$ O O O O O O O $void$ O $any$ O O $Console$ O $void$ O O O $any$ O O O O O O O O O O O $any$ O O $complex$ O O $any$ O O $complex$ O O $any$ O O O O O $any$ O O $ModuleWithProviders$ O $SampleModuleOptions$ $SampleModuleOptions$ O O O O $any$ O $any$ O $complex$ O O O $any$ O $any$ O $SampleModuleOptions$ O $SampleModuleOptions$ O O O $any$ O $any$ O $void$ O $void$ O $any[]$ O O $any$ O O $boolean$ O O O O $any$ O O O O O
import { TestBed } from 's' ; import { NgxExampleLibraryService } from 's' ; import { configureTestSuite } from 's' ; describe ( 's' , ( ) => { let ngxExampleLibraryService ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { providers : [ NgxExampleLibraryService ] } ) ; } ) ; beforeEach ( ( ) => { ngxExampleLibraryService = TestBed . get ( NgxExampleLibraryService ) ; } ) ; it ( 's' , ( ( ) => { expect ( ngxExampleLibraryService ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $NgxExampleLibraryService$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O O O O $any$ O O O O O $NgxExampleLibraryService$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $NgxExampleLibraryService$ O O $any$ O O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O
import 's' ; import 's' ; import 's' ; import { getTestBed } from 's' ; import { BrowserDynamicTestingModule , platformBrowserDynamicTesting } from 's' ; declare const require ; getTestBed ( ) . initTestEnvironment ( BrowserDynamicTestingModule , platformBrowserDynamicTesting ( ) ) ; const context = require . context ( 's' , true , "s" ) ; context . keys ( ) . map ( context ) ;	O O O O O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O
import { Component } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class 0 { constructor ( ) { } }	O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O O O O O O O
export interface Deserializable { deserialize ( input ) : this ; }	O O $any$ O $this$ O $any$ O O O O O
import { Deserializable } from 's' ; export class Hero implements Deserializable { id : string ; name : string ; alterEgo : string ; likes : number ; default : boolean ; avatarUrl : string ; avatarBlurredUrl : string ; avatarThumbnailUrl : string ; constructor ( hero = { } ) { this . id = hero . id ; this . name = hero . name || 's' ; this . alterEgo = hero . alterEgo || 's' ; this . likes = hero . likes || 0 ; this . default = hero . default || false ; this . avatarUrl = hero . avatarUrl || 's' ; this . avatarBlurredUrl = hero . avatarBlurredUrl || 's' ; this . avatarThumbnailUrl = hero . avatarThumbnailUrl || 's' ; } like ( ) { this . likes += 0 ; } deserialize ( input ) { Object . assign ( this , input ) ; return this ; } }	O O $any$ O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $number$ O O O $boolean$ O O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O O O O O O O $string$ O $any$ O $any$ O O O $string$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O O O O O $number$ O $any$ O $any$ O O O O O $boolean$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O O O O $void$ O O O O O $number$ O O O O $this$ O $any$ O O $ObjectConstructor$ O O O O O $any$ O O O O O O O
import { Injectable } from 's' ; @ Injectable ( { providedIn : 's' } ) export class LoggerService { static log ( msg ) { console . log ( msg ) ; } static error ( msg , obj = { } ) { console . error ( msg , obj ) ; } }	O O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O O $void$ O $string$ O O $Console$ O $void$ O $string$ O O O O $void$ O $string$ O ${}$ O O O O O $Console$ O $void$ O $string$ O ${}$ O O O O
import { InjectionToken } from 's' ; export let ENDPOINTS_CONFIG = new InjectionToken ( 's' ) ; export const EndpointsConfig = { heroes : { list : 's' , detail : getHeroDetail } } ; export function getHeroDetail ( id ) { return `template` ; }	O O $any$ O O O O O O $any$ O O $any$ O O O O O O $any$ O O $complex$ O O $string$ O O O $string$ O $string$ O O O O O $string$ O $any$ O O O O O O
import { Observable , of } from 's' ; import { Injectable } from 's' ; import { Hero } from 's' ; import { catchError , map , tap } from 's' ; import { MatSnackBar , MatSnackBarConfig } from 's' ; import { LoggerService } from 's' ; import { AppConfig } from 's' ; import { AngularFirestore , AngularFirestoreCollection , DocumentReference } from 's' ; import { 0 } from 's' ; import { EndpointsConfig } from 's' ; import { CookieService } from 's' ; @ Injectable ( { providedIn : 's' } ) export class HeroService { private heroesCollection : AngularFirestoreCollection < Hero > ; constructor ( private afs , private snackBar , private 0 , private cookieService ) { this . heroesCollection = this . afs . collection < Hero > ( EndpointsConfig . heroes . list , ( hero ) => { return hero . orderBy ( 's' , 's' ) . orderBy ( 's' , 's' ) ; } ) ; } private static handleError < T > ( operation = 's' , result ? : T ) { return ( error ) : Observable < T > => { console . error ( error ) ; LoggerService . log ( `template` ) ; if ( error . status >= 0 ) { throw error ; } return of ( result ) ; } ; } checkIfUserCanVote ( ) { const votes = this . cookieService . get ( 's' ) ; return Number ( votes ? votes : 0 ) < AppConfig . votesLimit ; } getHeroes ( ) < Hero [ ] > { return this . heroesCollection . snapshotChanges ( ) . pipe ( map ( ( actions ) => { return actions . map ( ( action ) => { const data = action . payload . doc . data ( ) ; return new Hero ( { id : action . payload . doc . id , ... data } ) ; } ) ; } ) , tap ( ( ) => LoggerService . log ( `template` ) ) , catchError ( HeroService . handleError ( 's' , [ ] ) ) ) ; } getHero ( id ) < any > { return this . afs . doc ( EndpointsConfig . heroes . detail ( id ) ) . get ( ) . pipe ( map ( ( hero ) => { return new Hero ( { id , ... hero . data ( ) } ) ; } ) , tap ( ( ) => LoggerService . log ( `template` ) ) , catchError ( HeroService . handleError ( 's' , [ ] ) ) ) ; } createHero ( hero ) < DocumentReference > { return this . heroesCollection . add ( JSON . parse ( JSON . stringify ( hero ) ) ) ; } updateHero ( hero ) < void > { return this . afs . doc ( EndpointsConfig . heroes . detail ( hero . id ) ) . update ( JSON . parse ( JSON . stringify ( hero ) ) ) . then ( ( ) => { LoggerService . log ( `template` ) ; this . showSnackBar ( this . 0 ( { value : 's' , id : 's' } ) ) ; } ) ; } deleteHero ( id ) < void > { return this . afs . doc ( EndpointsConfig . heroes . detail ( id ) ) . delete ( ) ; } showSnackBar ( name ) { const config = new MatSnackBarConfig ( ) ; config . duration = AppConfig . snackBarDuration ; this . snackBar . open ( name , 's' , config ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $AngularFirestore$ O O $MatSnackBar$ O O $I18n$ O O $CookieService$ O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O O O O O $any$ O $any$ O O $string$ O O O $T$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O $Console$ O $void$ O $any$ O O $any$ O $void$ O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $T$ O O O O O $boolean$ O O O O $any$ O O O $any$ O $any$ O O O O O $NumberConstructor$ O $any$ O $any$ O O O O $any$ O $any$ O O $Observable$ O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O $any$ O O O O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $Observable$ O $string$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O O O $any$ O $any$ O O $any$ O O O O O $any$ O O $string$ O O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O $void$ O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $Promise$ O $Hero$ O O $any$ O O O O O $any$ O $any$ O $JSON$ O $any$ O $JSON$ O $complex$ O $Hero$ O O O O O $Promise$ O $Hero$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $Hero$ O $string$ O O O $any$ O $JSON$ O $any$ O $JSON$ O $complex$ O $Hero$ O O O O $any$ O O O O O $any$ O $void$ O O O O O O $void$ O O O $any$ O O $string$ O O O $string$ O O O O O O O O O O $Promise$ O $string$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O $any$ O O O O $void$ O $any$ O O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O O
import { Component , OnInit } from 's' ; import { Hero } from 's' ; import { HeroService } from 's' ; import { AppConfig } from 's' ; import { Observable } from 's' ; import { defaultIfEmpty , map } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class HomePageComponent implements OnInit { heroes$ : Observable < Hero [ ] > ; constructor ( private heroService ) { } ngOnInit ( ) { this . heroes$ = this . heroService . getHeroes ( ) . pipe ( map ( ( heroes ) => heroes . slice ( 0 , AppConfig . topHeroesLimit ) ) , defaultIfEmpty ( [ ] ) ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $HeroService$ O O O $void$ O O O O O $any$ O O O $HeroService$ O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O O O
import { Injectable } from 's' ; declare const require ; const bowser = require ( 's' ) ; @ Injectable ( { providedIn : 's' } ) export class UtilsHelperService { static isPalindrome ( str ) { const len = Math . floor ( str . length / 0 ) ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] !== str [ str . length - i - 0 ] ) { return false ; } } return true ; } static isBrowserValid ( ) { const browser = bowser . getParser ( window . navigator . userAgent ) ; return browser . satisfies ( { windows : { 's' : 's' , } , macos : { safari : 's' } , chrome : 's' , firefox : 's' , opera : 's' } ) ; } }	O O $any$ O O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O O $boolean$ O $any$ O O O $number$ O $Math$ O $number$ O $any$ O $any$ O O O O O O O $number$ O O O $number$ O $number$ O $number$ O O O O O $any$ O $number$ O O $any$ O $any$ O $any$ O $number$ O O O O O O O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $complex$ O $Navigator$ O $string$ O O O $any$ O $any$ O O $complex$ O O O O O O O O $complex$ O O $string$ O O O O $string$ O O O $string$ O O O $string$ O O O O O O O
import { Component } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , } ) export class HeroRemoveComponent { constructor ( ) { } }	O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O O O O O $any$ O O O O O O O
import { Component , Inject , OnInit , ViewChild } from 's' ; import { Hero } from 's' ; import { HeroService } from 's' ; import { FormBuilder , FormControl , FormGroup , Validators } from 's' ; import { MatDialog } from 's' ; import { MatSnackBar } from 's' ; import { Router } from 's' ; import { UtilsHelperService } from 's' ; import { HeroRemoveComponent } from 's' ; import { 0 } from 's' ; import { transition , trigger , useAnimation } from 's' ; import { fadeIn } from 's' ; import { ROUTES_CONFIG } from 's' ; import { CookieService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , animations : [ trigger ( 's' , [ transition ( 's' , useAnimation ( fadeIn , { params : { timing : 0 , delay : 0 } } ) ) ] ) ] } ) export class HeroesListPageComponent implements OnInit { heroes : Hero [ ] ; newHeroForm : FormGroup ; canVote = false ; error : boolean ; @ ViewChild ( 's' , { static : false } ) myNgForm ; constructor ( private heroService , private dialog , private snackBar , private router , private 0 , private formBuilder , private cookieService , @ Inject ( ROUTES_CONFIG ) public routesConfig ) { this . canVote = this . heroService . checkIfUserCanVote ( ) ; this . newHeroForm = this . formBuilder . group ( { name : new FormControl ( 's' , [ Validators . required , Validators . maxLength ( 0 ) ] ) , alterEgo : new FormControl ( 's' , [ Validators . required , Validators . maxLength ( 0 ) ] ) } ) ; this . onChanges ( ) ; } ngOnInit ( ) { this . heroService . getHeroes ( ) . subscribe ( ( heroes < Hero > ) => { this . heroes = heroes ; } ) ; } async createNewHero ( ) { if ( this . newHeroForm . valid ) { this . heroService . createHero ( new Hero ( this . newHeroForm . value ) ) . then ( ( ) => { this . myNgForm . resetForm ( ) ; this . snackBar . open ( this . 0 ( { value : 's' , id : 's' } ) , 's' , { duration : 0 } ) ; } , ( ) => { this . error = true ; } ) ; } } like ( hero ) { this . canVote = this . heroService . checkIfUserCanVote ( ) ; if ( this . canVote ) { hero . like ( ) ; this . cookieService . put ( 's' , 's' + ( Number ( this . cookieService . get ( 's' ) || 0 ) + 0 ) ) ; this . heroService . updateHero ( hero ) ; } else { this . snackBar . open ( this . 0 ( { value : 's' , id : 's' } ) , 's' , { duration : 0 } ) ; } } deleteHero ( hero ) { const dialogRef = this . dialog . open ( HeroRemoveComponent ) ; dialogRef . afterClosed ( ) . subscribe ( result => { if ( result ) { this . heroService . deleteHero ( hero . id ) . then ( ( ) => { this . heroService . showSnackBar ( this . 0 ( { value : 's' , id : 's' } ) ) ; } , ( ) => { this . error = true ; } ) ; } } ) ; } trackByFn ( index ) { return index ; } private onChanges ( ) { this . newHeroForm . get ( 's' ) . valueChanges . subscribe ( ( value ) => { if ( value && value . length >= 0 && UtilsHelperService . isPalindrome ( value ) ) { this . snackBar . open ( this . 0 ( { value : 's' , id : 's' } ) , 's' , { duration : 0 } ) ; } else { this . snackBar . dismiss ( ) ; } } ) ; } }	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any[]$ O O $any$ O O O O $any$ O O O $any$ O $any$ O O $complex$ O O $number$ O O O $number$ O O O O O O O O O O O O O $any$ O $any$ O $Hero[]$ O $any$ O O O $any$ O $any$ O $boolean$ O O O $boolean$ O O O O $any$ O O O O $boolean$ O O O O $any$ O O O O $HeroService$ O O $MatDialog$ O O $MatSnackBar$ O O $Router$ O O $I18n$ O O $FormBuilder$ O O $CookieService$ O O $any$ O $any$ O O $any$ O O O O $boolean$ O O O $HeroService$ O $boolean$ O O O O O $any$ O O O $any$ O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $void$ O O O O $void$ O O O O O $HeroService$ O $any$ O O O $any$ O O $Array$ O $any$ O O O O O O $Hero[]$ O $Hero[]$ O O O O O O $Promise<void>$ O O O O O O O $any$ O $any$ O O O O $HeroService$ O $Promise<any>$ O O $any$ O O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O O O $number$ O O O O O O O O O O O O O $boolean$ O O O O O O O O $void$ O $Hero$ O O O O $boolean$ O O O $HeroService$ O $boolean$ O O O O O O O $boolean$ O O $Hero$ O $void$ O O O O O $any$ O $any$ O O O O O O $NumberConstructor$ O O O $any$ O $any$ O O O O O O O O O O O O O $HeroService$ O $Promise<void>$ O $Hero$ O O O O O O O $any$ O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O O O $number$ O O O O O O O $void$ O $Hero$ O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $HeroService$ O $Promise<void>$ O $Hero$ O $string$ O O O O O O O O O O $HeroService$ O $void$ O O O $any$ O O $string$ O O O $string$ O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O $any$ O $any$ O O O $any$ O O O $void$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $boolean$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O O O $number$ O O O O O O O O O O $any$ O $any$ O O O O O O O O O
import { Component , OnInit } from 's' ; import { Hero } from 's' ; import { ActivatedRoute , Router } from 's' ; import { Location } from 's' ; import { transition , trigger , useAnimation } from 's' ; import { fadeIn } from 's' ; import { RoutesConfig } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , animations : [ trigger ( 's' , [ transition ( 's' , useAnimation ( fadeIn , { params : { timing : 0 , delay : 0 } } ) ) ] ) ] } ) export class HeroDetailPageComponent implements OnInit { hero : Hero ; constructor ( private location , private router , private activatedRoute ) { } ngOnInit ( ) { this . hero = this . activatedRoute . snapshot . data . hero ; } goBack ( ) { this . location . back ( ) ; } goToTheAnchor ( ) { this . router . navigate ( [ RoutesConfig . routes . heroes . detail ( this . hero . id ) ] , { fragment : 's' } ) ; } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any[]$ O O $any$ O O O O $any$ O O O $any$ O $any$ O O $complex$ O O $number$ O O O $number$ O O O O O O O O O O O O O $any$ O $any$ O $Hero$ O $any$ O O O O $Location$ O O $Router$ O O $ActivatedRoute$ O O O $void$ O O O O O $Hero$ O O O $any$ O $any$ O $any$ O $any$ O O $void$ O O O O O $any$ O $any$ O O O O $void$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $Hero$ O $string$ O O O O $string$ O O O O O O O
import { Injectable } from 's' ; import { ActivatedRouteSnapshot , Resolve } from 's' ; import { Hero } from 's' ; import { Observable } from 's' ; import { HeroService } from 's' ; @ Injectable ( ) export class HeroResolver implements Resolve < Observable < Hero > > { constructor ( private heroService ) { } resolve ( route ) { return this . heroService . getHero ( route . paramMap . get ( 's' ) ) ; } }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $HeroService$ O O O $any$ O $ActivatedRouteSnapshot$ O O O O O $HeroService$ O $any$ O $any$ O $any$ O $any$ O O O O O O O
import { NgModule } from 's' ; import { RouterModule , Routes } from 's' ; import { HeroesListPageComponent } from 's' ; import { HeroDetailPageComponent } from 's' ; import { HeroResolver } from 's' ; const heroesRoutes = [ { path : 's' , component : HeroesListPageComponent } , { path : 's' , component : HeroDetailPageComponent , resolve : { hero : HeroResolver } } ] ; @ NgModule ( { imports : [ RouterModule . forChild ( heroesRoutes ) ] , exports : [ RouterModule ] , providers : [ HeroResolver ] } ) export class HeroRoutingModule { }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $Routes$ O O O $string$ O O O $any$ O $any$ O O O $string$ O O O $any$ O $any$ O $complex$ O O $any$ O $any$ O O O O O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O O O $any[]$ O O $any$ O O $complex$ O O $any$ O O O O O $any$ O O
import { MatDialogModule } from 's' ; import { MatAutocompleteModule } from 's' ; import { MatButtonModule } from 's' ; import { MatCardModule } from 's' ; import { MatGridListModule } from 's' ; import { MatIconModule } from 's' ; import { MatInputModule } from 's' ; import { MatListModule } from 's' ; import { MatMenuModule } from 's' ; import { MatProgressBarModule } from 's' ; import { MatProgressSpinnerModule } from 's' ; import { MatSliderModule } from 's' ; import { MatSnackBarModule } from 's' ; import { MatTooltipModule } from 's' ; import { NgModule } from 's' ; @ NgModule ( { imports : [ MatButtonModule , MatMenuModule , MatIconModule , MatCardModule , MatSliderModule , MatProgressBarModule , MatAutocompleteModule , MatInputModule , MatGridListModule , MatSnackBarModule , MatProgressSpinnerModule , MatTooltipModule , MatListModule , MatDialogModule ] , exports : [ MatButtonModule , MatMenuModule , MatIconModule , MatCardModule , MatSliderModule , MatProgressBarModule , MatAutocompleteModule , MatInputModule , MatGridListModule , MatSnackBarModule , MatProgressSpinnerModule , MatTooltipModule , MatListModule , MatDialogModule ] , } ) export class MaterialModule { }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O
import { Component , OnInit } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class SpinnerComponent implements OnInit { constructor ( ) { } ngOnInit ( ) { } }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O $any$ O O O O O O $void$ O O O O O
import { Component , OnInit } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class FooterComponent implements OnInit { constructor ( ) { } ngOnInit ( ) { } }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O $any$ O O O O O O $void$ O O O O O
import { map , startWith } from 's' ; import { Component , Inject , OnInit } from 's' ; import { FormControl } from 's' ; import { Hero } from 's' ; import { HeroService } from 's' ; import { ROUTES_CONFIG } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class SearchBarComponent implements OnInit { defaultHeroes : Array < Hero > ; heroFormControl : FormControl ; filteredHeroes : any ; constructor ( private heroService , @ Inject ( ROUTES_CONFIG ) public routesConfig ) { this . defaultHeroes = [ ] ; this . heroFormControl = new FormControl ( ) ; } ngOnInit ( ) { this . heroService . getHeroes ( ) . subscribe ( ( heroes < Hero > ) => { this . defaultHeroes = heroes . filter ( hero => hero . default ) ; this . heroFormControl . valueChanges . pipe ( startWith ( null as string ) , map ( value => this . filterHeroes ( value ) ) ) . subscribe ( heroesFiltered => { this . filteredHeroes = heroesFiltered ; } ) ; } ) ; } filterHeroes ( val ) : Hero [ ] { return val ? this . defaultHeroes . filter ( hero => hero . name . toLowerCase ( ) . indexOf ( val . toLowerCase ( ) ) === 0 && hero . default ) : this . defaultHeroes ; } }	O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O $any$ O $Hero[]$ O $ArrayConstructor$ O $any$ O O $any$ O $any$ O $any$ O O O O O O $HeroService$ O O $any$ O $any$ O O $any$ O O O O $Hero[]$ O O O O O O $any$ O O $any$ O O O O $void$ O O O O O $HeroService$ O $any$ O O O $any$ O O $Array$ O $any$ O O O O O O $Hero[]$ O $Hero[]$ O $complex$ O $Hero$ O $Hero$ O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O $Hero[]$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $Hero[]$ O $string$ O O $any$ O O O O $string$ O O O $Hero[]$ O $complex$ O $Hero$ O $Hero$ O $string$ O $string$ O O O $number$ O $string$ O $string$ O O O O O O $Hero$ O $boolean$ O O O O $Hero[]$ O O O
import { EventEmitter , Injectable } from 's' ; @ Injectable ( { providedIn : 's' } ) export class ProgressBarService { private readonly updateProgressBar$ : EventEmitter < any > ; private requestsRunning = 0 ; constructor ( ) { this . updateProgressBar$ = new EventEmitter ( ) ; } public getUpdateProgressBar ( ) { return this . updateProgressBar$ ; } public list ( ) { return this . requestsRunning ; } public increase ( ) { this . requestsRunning ++ ; if ( this . requestsRunning === 0 ) { this . updateProgressBar$ . emit ( 's' ) ; } } public decrease ( ) { if ( this . requestsRunning > 0 ) { this . requestsRunning -- ; if ( this . requestsRunning === 0 ) { this . updateProgressBar$ . emit ( 's' ) ; } } } }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O O O $any$ O $any$ O O O O O $number$ O O O O O O O O O $any$ O O $any$ O O O O O $any$ O O O O O O $any$ O O O $number$ O O O O O O $number$ O O O $void$ O O O O O $number$ O O O O O O $number$ O O O O O O $any$ O $any$ O O O O O O O $void$ O O O O O O O $number$ O O O O O O $number$ O O O O O O $number$ O O O O O O $any$ O $any$ O O O O O O O O
import { Component , Inject , OnInit } from 's' ; import { APP_CONFIG } from 's' ; import { ProgressBarService } from 's' ; import { NavigationEnd , Router } from 's' ; import { CookieService } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class HeaderComponent implements OnInit { selectedLanguage : string ; progressBarMode : string ; currentUrl : string ; languages : any [ ] ; constructor ( @ Inject ( APP_CONFIG ) public appConfig , private progressBarService , private cookieService , private router ) { this . languages = [ { name : 's' , label : 's' } , { name : 's' , label : 's' } ] ; } ngOnInit ( ) { this . selectedLanguage = this . cookieService . get ( 's' ) || 's' ; this . progressBarService . getUpdateProgressBar ( ) . subscribe ( ( mode ) => { this . progressBarMode = mode ; } ) ; this . router . events . subscribe ( event => { if ( event instanceof NavigationEnd ) { this . currentUrl = event . url ; } } ) ; } changeLanguage ( language ) { this . cookieService . put ( 's' , language ) ; this . selectedLanguage = language ; } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O $any$ O $string$ O O O $string$ O O O $string$ O O O $any[]$ O O O O O O O O $any$ O $any$ O O $any$ O O $ProgressBarService$ O O $CookieService$ O O $Router$ O O O O $any[]$ O O O $string$ O O O $string$ O O O O O $string$ O O O $string$ O O O O O O $void$ O O O O O $string$ O O O $any$ O $any$ O O O O O O O O $ProgressBarService$ O $any$ O O O $any$ O O $string$ O O O O O $string$ O $string$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $string$ O $any$ O $any$ O O O O O O $void$ O $string$ O O O O $any$ O $any$ O O O $string$ O O O O $string$ O $string$ O O O
import { ChangeDetectionStrategy , Component , Inject , Input , OnInit , PLATFORM_ID } from 's' ; import { HeroService } from 's' ; import { Hero } from 's' ; import { Router } from 's' ; import { MatSnackBar } from 's' ; import { 0 } from 's' ; import { transition , trigger , useAnimation } from 's' ; import { fadeIn } from 's' ; import { ROUTES_CONFIG } from 's' ; import { CookieService } from 's' ; import { isPlatformBrowser } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] , changeDetection : ChangeDetectionStrategy . OnPush , animations : [ trigger ( 's' , [ transition ( 's' , useAnimation ( fadeIn , { params : { timing : 0 , delay : 0 } } ) ) ] ) ] } ) export class HeroCardComponent implements OnInit { @ Input ( ) hero : Hero ; canVote : boolean ; isBrowser : boolean ; constructor ( private heroService , private router , private snackBar , private 0 , private cookieService , @ Inject ( PLATFORM_ID ) private platformId , @ Inject ( ROUTES_CONFIG ) public routesConfig ) { this . isBrowser = isPlatformBrowser ( this . platformId ) ; } ngOnInit ( ) { this . canVote = this . heroService . checkIfUserCanVote ( ) ; } like ( hero ) < void > { if ( this . canVote ) { hero . like ( ) ; this . cookieService . put ( 's' , 's' + ( Number ( this . cookieService . get ( 's' ) || 0 ) + 0 ) ) ; return this . heroService . updateHero ( hero ) ; } else { this . snackBar . open ( this . 0 ( { value : 's' , id : 's' } ) , 's' , { duration : 0 } ) ; } } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O $any$ O $any$ O $any$ O $any[]$ O O $any$ O O O O $any$ O O O $any$ O $any$ O O $complex$ O O $number$ O O O $number$ O O O O O O O O O O O O O $any$ O $any$ O O $any$ O O $Hero$ O $any$ O $boolean$ O O O $boolean$ O O O O O O $HeroService$ O O $Router$ O O $MatSnackBar$ O O $I18n$ O O $CookieService$ O O $any$ O $any$ O O $object$ O O $any$ O $any$ O O $any$ O O O O $boolean$ O $any$ O O O $object$ O O O $void$ O O O O O $boolean$ O O O $HeroService$ O $boolean$ O O O O $Promise$ O $Hero$ O O O O O O O O O $boolean$ O O $Hero$ O $void$ O O O O O $any$ O $any$ O O O O O O $NumberConstructor$ O O O $any$ O $any$ O O O O O O O O O O O O O O $HeroService$ O $Promise<void>$ O $Hero$ O O O O O O O $any$ O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O O O $number$ O O O O O O O O
import { Component , OnInit } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class HeroLoadingComponent implements OnInit { constructor ( ) { } ngOnInit ( ) { } }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O $any$ O O O O O O $void$ O O O O O
import { Component , Input , OnInit } from 's' ; @ Component ( { selector : 's' , templateUrl : 's' , styleUrls : [ 's' ] } ) export class LoadingPlaceholderComponent implements OnInit { @ Input ( ) height : string ; @ Input ( ) width : string ; constructor ( ) { } ngOnInit ( ) { } }	O O $any$ O $any$ O $any$ O O O O O $any$ O O $string$ O O O $string$ O O O $string[]$ O O O O O O O O $any$ O $any$ O O $any$ O O $string$ O O O O $any$ O O $string$ O O O O O O O O $void$ O O O O O
import { Pipe , PipeTransform } from 's' ; @ Pipe ( { name : 's' } ) export class CapitalizeFirstPipe implements PipeTransform { transform ( value , args : any [ ] ) { if ( value === null ) { return 's' ; } return value . charAt ( 0 ) . toUpperCase ( ) + value . toLowerCase ( ) . slice ( 0 ) ; } }	O O $any$ O $any$ O O O O O $any$ O O $string$ O O O O O O $any$ O $any$ O $string$ O $string$ O $any[]$ O O O O O O O O $string$ O O O O O O O O O $string$ O $string$ O O O O $string$ O O O $string$ O $string$ O O O $string$ O O O O O O
import { NgModule } from 's' ; import { MaterialModule } from 's' ; import { FlexLayoutModule } from 's' ; import { CommonModule } from 's' ; import { SpinnerComponent } from 's' ; import { FooterComponent } from 's' ; import { SearchBarComponent } from 's' ; import { HeaderComponent } from 's' ; import { ReactiveFormsModule } from 's' ; import { RouterModule } from 's' ; import { HeroCardComponent } from 's' ; import { NgxExampleLibraryModule } from 's' ; import { HeroLoadingComponent } from 's' ; import { NgxScrollToFirstInvalidModule } from 's' ; import { LoadingPlaceholderComponent } from 's' ; import { CapitalizeFirstPipe } from 's' ; import { LazyLoadImageModule } from 's' ; @ NgModule ( { imports : [ CommonModule , MaterialModule , FlexLayoutModule , ReactiveFormsModule , RouterModule , NgxExampleLibraryModule , NgxScrollToFirstInvalidModule , LazyLoadImageModule ] , declarations : [ HeaderComponent , SearchBarComponent , FooterComponent , SpinnerComponent , HeroCardComponent , HeroLoadingComponent , LoadingPlaceholderComponent , CapitalizeFirstPipe ] , exports : [ CommonModule , MaterialModule , FlexLayoutModule , NgxExampleLibraryModule , HeaderComponent , SearchBarComponent , FooterComponent , SpinnerComponent , HeroCardComponent , HeroLoadingComponent , NgxScrollToFirstInvalidModule , LoadingPlaceholderComponent , CapitalizeFirstPipe , LazyLoadImageModule ] } ) export class SharedModule { }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O
import { NgModule } from 's' ; import { FormsModule , ReactiveFormsModule } from 's' ; import { HeroRoutingModule } from 's' ; import { SharedModule } from 's' ; import { HeroRemoveComponent } from 's' ; import { HeroesListPageComponent } from 's' ; import { HeroDetailPageComponent } from 's' ; @ NgModule ( { imports : [ FormsModule , ReactiveFormsModule , SharedModule , HeroRoutingModule ] , declarations : [ HeroesListPageComponent , HeroDetailPageComponent , HeroRemoveComponent ] , entryComponents : [ HeroRemoveComponent ] } ) export class HeroesModule { }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $any$ O $any$ O $any$ O O $complex$ O O $any$ O O O O O $any$ O O
import { NgModule } from 's' ; import { RouterModule , Routes } from 's' ; import { 0 } from 's' ; import { HomePageComponent } from 's' ; import { RoutesConfig } from 's' ; const routesNames = RoutesConfig . routesNames ; const routes = [ { path : routesNames . home , component : HomePageComponent , pathMatch : 's' } , { path : routesNames . heroes . basePath , loadChildren : ( ) => import ( 's' ) . then ( m => m . HeroesModule ) } , { path : routesNames . 0 , component : 0 } , { path : 's' , redirectTo : 's' } , { path : 's' , redirectTo : RoutesConfig . routes . 0 } ] ; @ NgModule ( { imports : [ RouterModule . forRoot ( routes , { initialNavigation : 's' , scrollPositionRestoration : 's' , anchorScrolling : 's' } ) ] , exports : [ RouterModule ] } ) export class AppRoutingModule { }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O O $Routes$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O O O O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O O $any[]$ O O $any$ O O O O O $any$ O O
import { tap } from 's' ; import { HttpEvent , HttpHandler , HttpInterceptor , HttpRequest , HttpResponse } from 's' ; import { Observable } from 's' ; import { LoggerService } from 's' ; export class TimingInterceptor implements HttpInterceptor { constructor ( ) { } intercept ( req < any > , next ) < HttpEvent < any > > { const started = Date . now ( ) ; return next . handle ( req ) . pipe ( tap ( event => { if ( event instanceof HttpResponse ) { const elapsed = Date . now ( ) - started ; LoggerService . log ( `template` ) ; } } ) ) ; } }	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $Observable$ O $HttpRequest$ O O O O $HttpHandler$ O O $any$ O O O O O O $number$ O $DateConstructor$ O $number$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $number$ O $DateConstructor$ O $number$ O O O $number$ O $any$ O $void$ O O O O O O O O O O O
import { tap } from 's' ; import { HttpEvent , HttpHandler , HttpInterceptor , HttpRequest , HttpResponse } from 's' ; import { Observable } from 's' ; import { ProgressBarService } from 's' ; export class ProgressInterceptor implements HttpInterceptor { constructor ( private progressBarService ) { } intercept ( req < any > , next ) < HttpEvent < any > > { this . progressBarService . increase ( ) ; return next . handle ( req ) . pipe ( tap ( event => { if ( event instanceof HttpResponse ) { this . progressBarService . decrease ( ) ; } } ) ) ; } }	O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $ProgressBarService$ O O O $Observable$ O $HttpRequest$ O O O O $HttpHandler$ O O $any$ O O O O O O O $ProgressBarService$ O $void$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $ProgressBarService$ O $void$ O O O O O O O O O O
import { NgModule , Optional , SkipSelf } from 's' ; import { ProgressBarService } from 's' ; import { TimingInterceptor } from 's' ; import { HTTP_INTERCEPTORS } from 's' ; import { ProgressInterceptor } from 's' ; import { BrowserModule } from 's' ; import { BrowserAnimationsModule } from 's' ; import { RouterModule } from 's' ; @ NgModule ( { imports : [ BrowserModule , BrowserAnimationsModule , RouterModule ] , exports : [ BrowserModule , BrowserAnimationsModule ] , providers : [ { provide : HTTP_INTERCEPTORS , useClass : ProgressInterceptor , multi : true , deps : [ ProgressBarService ] } , { provide : HTTP_INTERCEPTORS , useClass : TimingInterceptor , multi : true } ] } ) export class CoreModule { constructor ( @ Optional ( ) @ SkipSelf ( ) parentModule ) { if ( parentModule ) { throw new Error ( `template` ) ; } } }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O $complex$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O O O O O O $any$ O O O O $any$ O O O $any$ O O $CoreModule$ O O O O $CoreModule$ O O O O $ErrorConstructor$ O O O O O O O
import { Component , Inject , LOCALE_ID , OnInit , PLATFORM_ID , 0 } from 's' ; import { Meta , Title } from 's' ; import { NavigationEnd , Router } from 's' ; import { MatSnackBar } from 's' ; import { UtilsHelperService } from 's' ; import { DOCUMENT , isPlatformBrowser } from 's' ; import { 0 } from 's' ; import { RoutesConfig } from 's' ; declare const Modernizr ; @ Component ( { selector : 's' , templateUrl : 's' } ) export class AppComponent implements OnInit { isOnline : boolean ; constructor ( private title , private meta , private snackBar , private router , private 0 , private renderer , @ Inject ( DOCUMENT ) doc , @ Inject ( LOCALE_ID ) locale , @ Inject ( PLATFORM_ID ) private platformId ) { if ( isPlatformBrowser ( this . platformId ) ) { this . isOnline = navigator . onLine ; renderer . setAttribute ( doc . documentElement , 's' , locale ) ; } else { this . isOnline = true ; } } ngOnInit ( ) { this . title . setTitle ( this . 0 ( { value : 's' , id : 's' } ) ) ; this . onEvents ( ) ; this . checkBrowser ( ) ; } onEvents ( ) { this . router . events . subscribe ( ( event ) => { if ( event instanceof NavigationEnd ) { switch ( event . urlAfterRedirects ) { case 's' : this . meta . updateTag ( { name : 's' , content : this . 0 ( { value : 's' , id : 's' } ) } ) ; break ; case 's' + RoutesConfig . routesNames . heroes . basePath : this . title . setTitle ( 's' ) ; this . meta . updateTag ( { name : 's' , content : this . 0 ( { value : 's' , id : 's' } ) } ) ; break ; } } } ) ; } checkBrowser ( ) { if ( isPlatformBrowser ( this . platformId ) ) { if ( UtilsHelperService . isBrowserValid ( ) ) { this . checkBrowserFeatures ( ) ; } else { this . snackBar . open ( this . 0 ( { value : 's' , id : 's' } ) , 's' ) ; } } } checkBrowserFeatures ( ) { let supported = true ; for ( const feature in Modernizr ) { if ( Modernizr . hasOwnProperty ( feature ) && typeof Modernizr [ feature ] === 's' && Modernizr [ feature ] === false ) { supported = false ; break ; } } if ( ! supported ) { this . snackBar . open ( this . 0 ( { value : 's' , id : 's' } ) , 's' ) ; } return supported ; } }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O $any$ O $boolean$ O O O O O O $Title$ O O $Meta$ O O $MatSnackBar$ O O $Router$ O O $I18n$ O O $Renderer2$ O O $any$ O $any$ O $Document$ O O $any$ O $any$ O $string$ O O $any$ O $any$ O O $object$ O O O O $any$ O O O $object$ O O O O O $boolean$ O $Navigator$ O $boolean$ O $any$ O $any$ O $Document$ O $HTMLElement$ O O O $string$ O O O O O O O $boolean$ O O O O O $void$ O O O O O $any$ O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O O O $void$ O O O O O $void$ O O O O $void$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $string$ O O O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $string$ O O O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O O O O O O O O O O $void$ O O O O O $any$ O O O $object$ O O O O O $any$ O $any$ O O O O O O $boolean$ O O O O O O O O $any$ O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O O O O O O $boolean$ O O O O $boolean$ O O O O O O $string$ O $any$ O O O O $any$ O $any$ O $string$ O O O $any$ O $string$ O O O O $any$ O $string$ O O O O O $boolean$ O O O O O O O O O O $boolean$ O O O O $any$ O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O O O O O $boolean$ O O O
export const environment = { production : false , firebase : { apiKey : 's' , authDomain : 's' , databaseURL : 's' , projectId : 's' , storageBucket : 's' , messagingSenderId : 's' } } ;	O O $complex$ O O $boolean$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O
import { NgModule } from 's' ; import { AngularFireModule } from 's' ; import { AngularFirestoreModule , FirestoreSettingsToken } from 's' ; import { environment } from 's' ; @ NgModule ( { imports : [ AngularFireModule . initializeApp ( environment . firebase , 's' ) , AngularFirestoreModule , ] , exports : [ AngularFireModule , AngularFirestoreModule ] , providers : [ { provide : FirestoreSettingsToken , useValue : { } } ] } ) export class FirebaseModule { }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $complex$ O O O O O $any$ O O $any[]$ O O $any$ O $any$ O $complex$ O $complex$ O O O O $any$ O O O $any[]$ O O $any$ O $any$ O O $complex$ O O O $any$ O $any$ O ${}$ O O O O O O O O O $any$ O O
import * as Sentry from 's' ; import { ErrorHandler , Injectable } from 's' ; import { AppConfig } from 's' ; Sentry . init ( { dsn : AppConfig . sentryDSN } ) ; @ Injectable ( ) export class SentryErrorHandler implements ErrorHandler { constructor ( ) { } handleError ( error ) { Sentry . captureException ( error . originalError || error ) ; throw error ; } }	O O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O O $void$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O
import { APP_INITIALIZER , ErrorHandler , LOCALE_ID , NgModule , PLATFORM_ID , TRANSLATIONS } from 's' ; import { AppRoutingModule } from 's' ; import { CoreModule } from 's' ; import { AppComponent } from 's' ; import { APP_CONFIG , AppConfig } from 's' ; import { SharedModule } from 's' ; import { NgxExampleLibraryModule } from 's' ; import { FirebaseModule } from 's' ; import { SentryErrorHandler } from 's' ; import { BrowserModule , getDOM } from 's' ; import { 0 } from 's' ; import { HttpClientModule } from 's' ; import { DOCUMENT , isPlatformBrowser , registerLocaleData } from 's' ; import localeEs from 's' ; import { CookieModule } from 's' ; import { BrowserAnimationsModule } from 's' ; import { ROUTES_CONFIG , RoutesConfig } from 's' ; import { HomePageComponent } from 's' ; import { 0 } from 's' ; import { ENDPOINTS_CONFIG , EndpointsConfig } from 's' ; import { LazyLoadImageModule } from 's' ; import { RouterModule } from 's' ; import { PrebootModule } from 's' ; declare const require ; registerLocaleData ( localeEs , 's' ) ; export function appInitializer ( document , platformId ) { return ( ) => { if ( isPlatformBrowser ( platformId ) ) { const dom = getDOM ( ) ; const styles : any [ ] = Array . prototype . slice . apply ( dom . querySelectorAll ( document , `template` ) ) ; styles . forEach ( el => { el . removeAttribute ( 's' ) ; } ) ; document . addEventListener ( 's' , ( ) => { setTimeout ( ( ) => styles . forEach ( el => dom . remove ( el ) ) ) ; } ) ; } } ; } @ NgModule ( { imports : [ BrowserModule . withServerTransition ( { appId : 's' } ) , PrebootModule . withConfig ( { appRoot : 's' } ) , HttpClientModule , RouterModule , AppRoutingModule , BrowserAnimationsModule , CookieModule . forRoot ( ) , FirebaseModule , NgxExampleLibraryModule . forRoot ( { config : { say : 's' } } ) , LazyLoadImageModule . forRoot ( { } ) , CoreModule , SharedModule , ] , declarations : [ HomePageComponent , 0 , AppComponent ] , providers : [ { provide : APP_CONFIG , useValue : AppConfig } , { provide : ROUTES_CONFIG , useValue : RoutesConfig } , { provide : ENDPOINTS_CONFIG , useValue : EndpointsConfig } , { provide : ErrorHandler , useClass : SentryErrorHandler } , { provide : TRANSLATIONS , useFactory : ( locale ) => { locale = locale || 's' ; return require ( `template` ) ; } , deps : [ LOCALE_ID ] } , 0 , { provide : APP_INITIALIZER , useFactory : appInitializer , deps : [ DOCUMENT , PLATFORM_ID ] , multi : true } ] } ) export class AppModule { }	O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $void$ O $HTMLDocument$ O $object$ O O O O O O O O O $any$ O $object$ O O O O $any$ O $any$ O O O O $any[]$ O O O O O $ArrayConstructor$ O $any[]$ O $any[]$ O $any$ O $any$ O $any$ O $HTMLDocument$ O O O O O $any[]$ O $void$ O $any$ O O $any$ O $any$ O O O O O O O $HTMLDocument$ O O O O O O O O O $number$ O O O O $any[]$ O $void$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O O $any[]$ O O $any$ O $any$ O O $string$ O O O O O $any$ O $any$ O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $complex$ O O $string$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O $any[]$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O O $any$ O O O O O O $any[]$ O O $any$ O O O $any$ O O $any$ O $any$ O $void$ O $void$ O $any[]$ O O $any$ O $any$ O O $boolean$ O O O O O O O O $any$ O O
import { NgModule } from 's' ; import { REQUEST } from 's' ; import { AppModule } from 's' ; import { AppComponent } from 's' ; import { ServiceWorkerModule } from 's' ; import { environment } from 's' ; export function getRequest ( ) { return { headers : { cookie : document . cookie } } ; } @ NgModule ( { imports : [ AppModule , ServiceWorkerModule . register ( 's' , { enabled : environment . production } ) ] , providers : [ { provide : REQUEST , useFactory : getRequest } , { provide : 's' , useValue : location . origin } , ] , bootstrap : [ AppComponent ] } ) export class AppBrowserModule { }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $any$ O O O O O $complex$ O O $string$ O $Document$ O $string$ O O O O O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O O O O $boolean$ O $complex$ O $boolean$ O O O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O $string$ O O O $string$ O $Location$ O $string$ O O O O $complex$ O O $any$ O O O O O $any$ O O
import { ComponentFixture , TestBed } from 's' ; import { AppComponent } from 's' ; import { Meta , Title } from 's' ; import { configureTestSuite } from 's' ; import { NavigationEnd , Router } from 's' ; import { HeaderComponent } from 's' ; import { SearchBarComponent } from 's' ; import { FooterComponent } from 's' ; import { NgxExampleLibraryComponent } from 's' ; import { of } from 's' ; import { MockComponent } from 's' ; import { RouterTestingModule } from 's' ; import { 0 } from 's' ; import { LOCALE_ID , PLATFORM_ID } from 's' ; import { MatSnackBar } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < AppComponent > ; const matSnackBarSpy = jasmine . createSpyObj ( 's' , [ 's' ] ) ; const routerSpy = jasmine . createSpyObj ( 's' , [ 's' ] ) ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { imports : [ RouterTestingModule ] , declarations : [ MockComponent ( HeaderComponent ) , MockComponent ( SearchBarComponent ) , MockComponent ( FooterComponent ) , MockComponent ( NgxExampleLibraryComponent ) , AppComponent ] , providers : [ { provide : MatSnackBar , useValue : matSnackBarSpy } , { provide : Meta , useValue : { } } , { provide : 0 , useValue : ( ) => { } } , { provide : Title , useValue : { setTitle : ( ) => { } } } , { provide : PLATFORM_ID , useValue : 's' } , { provide : LOCALE_ID , useValue : 's' } ] } ) ; } ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( AppComponent ) ; component = fixture . debugElement . componentInstance ; routerSpy . events . and . returnValue ( of ( new NavigationEnd ( 0 , 's' , 's' ) ) ) ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ) ; it ( 's' , ( ( ) => { expect ( component . checkBrowserFeatures ( ) ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $AppComponent$ O O $ComponentFixture$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O O $any[]$ O O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O ${}$ O O O O O O $any$ O $any$ O $void$ O O O O O O O O O $any$ O $any$ O $complex$ O O $void$ O O O O O O O O O O $any$ O $any$ O $string$ O O O O O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $AppComponent$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $AppComponent$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $AppComponent$ O $boolean$ O O O O $any$ O O O O O O O O O O
import { NgModule } from 's' ; import { ServerModule , ServerTransferStateModule } from 's' ; import { AppModule } from 's' ; import { AppComponent } from 's' ; import { ModuleMapLoaderModule } from 's' ; import { FlexLayoutServerModule } from 's' ; import { CookieBackendService , CookieService } from 's' ; import { NoopAnimationsModule } from 's' ; @ NgModule ( { imports : [ AppModule , ServerModule , NoopAnimationsModule , FlexLayoutServerModule , ModuleMapLoaderModule ] , bootstrap : [ AppComponent ] , providers : [ { provide : CookieService , useClass : CookieBackendService } ] } ) export class AppServerModule { }	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $any$ O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O
import { HeroRemoveComponent } from 's' ; import { ComponentFixture , TestBed } from 's' ; import { configureTestSuite } from 's' ; import { MatDialogModule } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < HeroRemoveComponent > ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { imports : [ MatDialogModule ] , declarations : [ HeroRemoveComponent ] } ) ; } ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( HeroRemoveComponent ) ; component = fixture . debugElement . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $HeroRemoveComponent$ O O $ComponentFixture$ O $any$ O O $any$ O O O O O $any$ O $any$ O O $any[]$ O O $any$ O O $complex$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $HeroRemoveComponent$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $HeroRemoveComponent$ O O $any$ O O O O O O O O O O
import { ComponentFixture , TestBed } from 's' ; import { ActivatedRoute } from 's' ; import { HeroDetailPageComponent } from 's' ; import { configureTestSuite } from 's' ; import { HeroLoadingComponent } from 's' ; import { HeroCardComponent } from 's' ; import { MockComponent } from 's' ; import { HeroService } from 's' ; import { RouterTestingModule } from 's' ; import { Hero } from 's' ; import { of } from 's' ; import { NoopAnimationsModule } from 's' ; import { Location } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < HeroDetailPageComponent > ; const heroServiceSpy = jasmine . createSpyObj ( 's' , [ 's' ] ) ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { imports : [ RouterTestingModule , NoopAnimationsModule ] , declarations : [ MockComponent ( HeroLoadingComponent ) , MockComponent ( HeroCardComponent ) , HeroDetailPageComponent ] , providers : [ { provide : ActivatedRoute , useValue : { snapshot : { data : { hero : new Hero ( { id : 's' } ) } } } } , { provide : HeroService , useValue : heroServiceSpy } , { provide : Location , useValue : { back : ( ) => { } } } ] } ) ; } ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( HeroDetailPageComponent ) ; component = fixture . debugElement . componentInstance ; heroServiceSpy . getHero . and . returnValue ( of ( new Hero ( { id : 's' , name : 's' , default : true } ) ) ) ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ( ) => { expect ( component ) . toBeTruthy ( ) ; expect ( component . hero . id ) . toBe ( 's' ) ; } ) ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $HeroDetailPageComponent$ O O $ComponentFixture$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O $complex$ O O O $any$ O $any$ O $complex$ O O $complex$ O O $complex$ O O $Hero$ O O $any$ O O $string$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O $void$ O O O O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $HeroDetailPageComponent$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $string$ O O O $string$ O O O $boolean$ O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $HeroDetailPageComponent$ O O $any$ O O O $any$ O $HeroDetailPageComponent$ O $Hero$ O $string$ O O $any$ O O O O O O O O O O O
import { ComponentFixture , TestBed } from 's' ; import { HeroesListPageComponent } from 's' ; import { configureTestSuite } from 's' ; import { LoadingPlaceholderComponent } from 's' ; import { HeroService } from 's' ; import { Hero } from 's' ; import { of } from 's' ; import { FormControl , FormGroup , FormsModule , ReactiveFormsModule , Validators } from 's' ; import { HeroRemoveComponent } from 's' ; import { Router } from 's' ; import { MockComponent , MockModule } from 's' ; import { MatDialog } from 's' ; import { MatFormFieldModule , MatIconModule , MatInputModule , MatListModule } from 's' ; import { MatSnackBar } from 's' ; import { NgxScrollToFirstInvalidModule } from 's' ; import { RouterTestingModule } from 's' ; import { 0 } from 's' ; import { ROUTES_CONFIG , RoutesConfig } from 's' ; import { CookieService } from 's' ; import { NoopAnimationsModule } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < HeroesListPageComponent > ; let router ; let navigateSpy ; const matDialogSpy = jasmine . createSpyObj ( 's' , [ 's' ] ) ; const matSnackBarSpy = jasmine . createSpyObj ( 's' , [ 's' , 's' ] ) ; const heroServiceSpy = jasmine . createSpyObj ( 's' , [ 's' , 's' , 's' , 's' , 's' , 's' ] ) ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { imports : [ RouterTestingModule , FormsModule , ReactiveFormsModule , NoopAnimationsModule , MatListModule , MatIconModule , MatFormFieldModule , MatInputModule , MockModule ( NgxScrollToFirstInvalidModule ) ] , declarations : [ MockComponent ( HeroRemoveComponent ) , MockComponent ( LoadingPlaceholderComponent ) , HeroesListPageComponent ] , providers : [ { provide : MatSnackBar , useValue : matSnackBarSpy } , { provide : MatDialog , useValue : matDialogSpy } , { provide : HeroService , useValue : heroServiceSpy } , { provide : 0 , useValue : ( ) => { } } , { provide : ROUTES_CONFIG , useValue : RoutesConfig } , { provide : CookieService , useValue : { get : ( key ) => key , put : ( ) => true , } } ] } ) ; } ) ; beforeEach ( ( ) => { heroServiceSpy . checkIfUserCanVote . and . returnValue ( true ) ; fixture = TestBed . createComponent ( HeroesListPageComponent ) ; component = fixture . debugElement . componentInstance ; router = TestBed . get ( Router ) ; navigateSpy = spyOn ( router , 's' ) ; heroServiceSpy . getHeroes . and . returnValue ( of ( [ new Hero ( { is : 0 , name : 's' } ) ] ) ) ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ( ) => { expect ( component ) . toBeTruthy ( ) ; expect ( component . heroes . length ) . toBe ( 0 ) ; expect ( component . heroes [ 0 ] . name ) . toBe ( 's' ) ; } ) ) ; it ( 's' , ( ( ) => { const success = new Promise ( ( resolve ) => { resolve ( 's' ) ; } ) ; heroServiceSpy . createHero . and . returnValue ( success ) ; component . newHeroForm = new FormGroup ( { name : new FormControl ( 's' , [ Validators . required , Validators . maxLength ( 0 ) ] ) , alterEgo : new FormControl ( 's' , [ Validators . required , Validators . maxLength ( 0 ) ] ) } ) ; component . error = null ; component . createNewHero ( ) ; expect ( component . error ) . toBe ( null ) ; } ) ) ; it ( 's' , ( async ( ) => { const error = new Promise ( ( resolve , reject ) => { reject ( ) ; } ) ; heroServiceSpy . createHero . and . returnValue ( error ) ; component . newHeroForm = new FormGroup ( { name : new FormControl ( 's' , [ Validators . required , Validators . maxLength ( 0 ) ] ) , alterEgo : new FormControl ( 's' , [ Validators . required , Validators . maxLength ( 0 ) ] ) } ) ; component . error = false ; await component . createNewHero ( ) ; expect ( component . error ) . toBe ( true ) ; } ) ) ; it ( 's' , ( ( ) => { const hero = new Hero ( { likes : 0 } ) ; component . like ( hero ) ; expect ( hero . likes ) . toBe ( 0 ) ; } ) ) ; it ( 's' , ( ( ) => { const hero = new Hero ( { id : 's' } ) ; matDialogSpy . open . and . returnValue ( { afterClosed : ( ) => { return of ( true ) ; } } ) ; heroServiceSpy . deleteHero . and . returnValue ( new Promise ( ( ) => true ) ) ; component . deleteHero ( hero ) ; expect ( heroServiceSpy . deleteHero ) . toHaveBeenCalledWith ( 's' ) ; } ) ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $HeroesListPageComponent$ O O $ComponentFixture$ O $any$ O O O $Router$ O O $any$ O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $void$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O $any$ O O $any$ O O $any$ O $boolean$ O O O O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $HeroesListPageComponent$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $number$ O O O $string$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $HeroesListPageComponent$ O O $any$ O O O $any$ O $HeroesListPageComponent$ O $Hero[]$ O $number$ O O $any$ O O O O $any$ O $HeroesListPageComponent$ O $Hero[]$ O O O O $string$ O O $any$ O O O O O O O O $any$ O O O O O O O O O $Promise<unknown>$ O O $PromiseConstructor$ O O $void$ O O O $void$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $Promise<unknown>$ O O $HeroesListPageComponent$ O $any$ O O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $HeroesListPageComponent$ O $boolean$ O O O $HeroesListPageComponent$ O $Promise<void>$ O O O $any$ O $HeroesListPageComponent$ O $boolean$ O O $any$ O O O O O O O O $any$ O O O O O O O O O O $Promise<unknown>$ O O $PromiseConstructor$ O O $void$ O $void$ O O O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O $Promise<unknown>$ O O $HeroesListPageComponent$ O $any$ O O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $HeroesListPageComponent$ O $boolean$ O O O O $HeroesListPageComponent$ O $Promise<void>$ O O O $any$ O $HeroesListPageComponent$ O $false$ O O $any$ O O O O O O O O $any$ O O O O O O O O O $Hero$ O O $any$ O O $number$ O O O O O $HeroesListPageComponent$ O $void$ O $Hero$ O O $any$ O $Hero$ O $number$ O O $any$ O O O O O O O O $any$ O O O O O O O O O $Hero$ O O $any$ O O $string$ O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $PromiseConstructor$ O O O O O O O O $HeroesListPageComponent$ O $void$ O $Hero$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O O
import { TestBed } from 's' ; import { HeroService } from 's' ; import { configureTestSuite } from 's' ; import { HeroResolver } from 's' ; import { ActivatedRoute , convertToParamMap } from 's' ; import { Hero } from 's' ; import { of } from 's' ; describe ( 's' , ( ) => { let heroResolver ; let route ; const heroServiceSpy = jasmine . createSpyObj ( 's' , [ 's' ] ) ; const heroId = 's' ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { providers : [ { provide : HeroService , useValue : heroServiceSpy } , { provide : ActivatedRoute , useValue : { snapshot : { paramMap : convertToParamMap ( { id : heroId } ) } } } , HeroResolver ] } ) ; } ) ; beforeEach ( ( ) => { heroResolver = TestBed . get ( HeroResolver ) ; route = TestBed . get ( ActivatedRoute ) ; } ) ; it ( 's' , ( ( ) => { heroServiceSpy . getHero . and . returnValue ( of ( new Hero ( { id : heroId } ) ) ) ; heroResolver . resolve ( route . snapshot ) . subscribe ( ( hero ) => { expect ( hero . id ) . toBe ( heroId ) ; } ) ; } ) ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $HeroResolver$ O O $ActivatedRoute$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O $complex$ O O $any$ O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O $HeroResolver$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $string$ O O O O O O O $HeroResolver$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O
import { TestBed } from 's' ; import { HeroService } from 's' ; import { Hero } from 's' ; import { HttpErrorResponse } from 's' ; import { configureTestSuite } from 's' ; import { FirebaseModule } from 's' ; import { MatSnackBar } from 's' ; import { 0 } from 's' ; import { CookieService } from 's' ; import { AngularFirestore } from 's' ; import { of , throwError } from 's' ; describe ( 's' , ( ) => { const heroId = 's' ; let heroService ; const matSnackBarSpy = jasmine . createSpyObj ( 's' , [ 's' , 's' , 's' ] ) ; const afsSpy = jasmine . createSpyObj ( 's' , [ 's' , 's' , 's' ] ) ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { imports : [ FirebaseModule ] , providers : [ { provide : AngularFirestore , useValue : afsSpy } , { provide : MatSnackBar , useValue : matSnackBarSpy } , { provide : CookieService , useValue : { get : ( ) => 0 } } , { provide : 0 , useValue : ( ) => { } } , HeroService ] } ) ; } ) ; beforeEach ( ( ) => { afsSpy . doc . and . returnValue ( { update : ( ) => new Promise ( ( resolve ) => resolve ( ) ) , get : ( ) => of ( { data : ( ) => new Hero ( { id : heroId , name : 's' , alterEgo : 's' } ) } ) , delete : ( ) => new Promise ( ( resolve ) => resolve ( ) ) } ) ; afsSpy . collection . and . returnValue ( { add : ( ) => new Promise ( ( resolve ) => resolve ( ) ) , snapshotChanges : ( ) => of ( [ { payload : { doc : { id : 's' , data : ( ) => { return { id : 's' , name : 's' } ; } } } } ] ) } ) ; heroService = TestBed . get ( HeroService ) ; } ) ; it ( 's' + heroId , ( ( ) => { heroService . getHero ( heroId ) . subscribe ( ( hero ) => { expect ( hero . id ) . toEqual ( heroId ) ; } ) ; } ) ) ; it ( 's' , ( ( ) => { heroService . getHeroes ( ) . subscribe ( ( heroes : Hero [ ] ) => { expect ( heroes . length ) . toBe ( 0 ) ; } ) ; } ) ) ; it ( 's' , ( ( ) => { heroService . getHero ( 's' ) . subscribe ( ( ) => { } , ( error ) => { expect ( error ) . toEqual ( jasmine . any ( HttpErrorResponse ) ) ; } ) ; } ) ) ; it ( 's' , ( ( ) => { heroService . createHero ( new Hero ( { name : 's' , alterEgo : 's' } ) ) . then ( ( ) => { expect ( afsSpy . collection ) . toHaveBeenCalled ( ) ; } ) ; } ) ) ; it ( 's' , ( ( ) => { heroService . updateHero ( new Hero ( { name : 's' , alterEgo : 's' } ) ) . then ( ( ) => { expect ( afsSpy . doc ) . toHaveBeenCalled ( ) ; } ) ; } ) ) ; it ( 's' , ( ( ) => { heroService . deleteHero ( 's' ) . then ( ( ) => { expect ( afsSpy . doc ) . toHaveBeenCalled ( ) ; } ) ; } ) ) ; it ( 's' , ( ( ) => { expect ( heroService . checkIfUserCanVote ( ) ) . toBe ( true ) ; } ) ) ; it ( 's' , ( ( ) => { afsSpy . doc . and . returnValue ( { get : ( ) => throwError ( { message : 's' , status : 0 } ) } ) ; heroService . getHero ( 's' ) . subscribe ( ( ) => { } , ( error ) => { expect ( error . status ) . toBe ( 0 ) ; } ) ; afsSpy . doc . and . returnValue ( { get : ( ) => throwError ( { message : 's' , status : 0 } ) } ) ; heroService . getHero ( 's' ) . subscribe ( ( ) => { } , ( error ) => { expect ( error . status ) . toBe ( 0 ) ; } ) ; } ) ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O $any$ O O O O O O O O O O O O O $HeroService$ O O $any$ O $any$ O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $complex$ O O $number$ O O O O O O O O O $any$ O $any$ O $void$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O O $void$ O O $void$ O O O O $any$ O O O O $any$ O O $Hero$ O O O O O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O O $void$ O O $void$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $Promise<unknown>$ O O O O O $PromiseConstructor$ O O $void$ O O $void$ O O O O $any$ O O O O $any$ O O O $complex$ O O $complex$ O O $string$ O O O $complex$ O O O O O O O $string$ O O O $string$ O O O O O O O O O O O O O $HeroService$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O O O $HeroService$ O $any$ O O O O $any$ O O $Hero$ O O O $any$ O $Hero$ O $string$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $HeroService$ O $any$ O O O $any$ O O $Hero[]$ O $any$ O O O O O $any$ O $Hero[]$ O $number$ O O $any$ O O O O O O O O O O O $any$ O O O O O O O O $HeroService$ O $any$ O O O O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O O $HeroService$ O $Promise<any>$ O O $any$ O O $string$ O O O $string$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $HeroService$ O $Promise<void>$ O O $any$ O O $string$ O O O $string$ O O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $HeroService$ O $Promise<void>$ O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $HeroService$ O $boolean$ O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $string$ O O O $number$ O O O O O O O $HeroService$ O $any$ O O O O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $string$ O O O $number$ O O O O O O O $HeroService$ O $any$ O O O O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O O O O O
import { ComponentFixture , TestBed } from 's' ; import { 0 } from 's' ; import { configureTestSuite } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < 0 > ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { declarations : [ 0 ] } ) ; } ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( 0 ) ; component = fixture . debugElement . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $Error404PageComponent$ O O $ComponentFixture$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O $any$ O O O O O O O O O O
import { async , ComponentFixture , TestBed } from 's' ; import { HeroService } from 's' ; import { HomePageComponent } from 's' ; import { of } from 's' ; import { Hero } from 's' ; import { configureTestSuite } from 's' ; import { HeroLoadingComponent } from 's' ; import { HeroCardComponent } from 's' ; import { LoadingPlaceholderComponent } from 's' ; import { MockComponent } from 's' ; import { NoopAnimationsModule } from 's' ; import { By } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < HomePageComponent > ; const heroServiceSpy = jasmine . createSpyObj ( 's' , [ 's' ] ) ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { imports : [ NoopAnimationsModule ] , declarations : [ MockComponent ( HeroCardComponent ) , MockComponent ( HeroLoadingComponent ) , MockComponent ( LoadingPlaceholderComponent ) , HomePageComponent ] , providers : [ { provide : HeroService , useValue : heroServiceSpy } ] } ) ; } ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( HomePageComponent ) ; component = fixture . debugElement . componentInstance ; heroServiceSpy . getHeroes . and . returnValue ( of ( [ new Hero ( { name : 's' } ) ] ) ) ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ) ; it ( 's' , async ( ( ) => { fixture . whenStable ( ) . then ( ( ) => { expect ( fixture . debugElement . queryAll ( By . css ( 's' ) ) . length ) . toBe ( 0 ) ; } ) ; } ) ) ; } ) ;	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $HomePageComponent$ O O $ComponentFixture$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O O $any[]$ O O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O O $any$ O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $HomePageComponent$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $string$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $HomePageComponent$ O O $any$ O O O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O O O O O O O O O O O O O O
import { ComponentFixture , TestBed } from 's' ; import { FooterComponent } from 's' ; import { configureTestSuite } from 's' ; import { NgxExampleLibraryComponent } from 's' ; import { MockComponent } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < FooterComponent > ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { declarations : [ MockComponent ( NgxExampleLibraryComponent ) , FooterComponent ] } ) ; } ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( FooterComponent ) ; component = fixture . debugElement . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $FooterComponent$ O O $ComponentFixture$ O $any$ O O $any$ O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $FooterComponent$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $FooterComponent$ O O $any$ O O O O O O O O O O
import { ComponentFixture , TestBed } from 's' ; import { HeaderComponent } from 's' ; import { configureTestSuite } from 's' ; import { SearchBarComponent } from 's' ; import { MockComponent } from 's' ; import { APP_CONFIG , AppConfig } from 's' ; import { RouterTestingModule } from 's' ; import { MatButtonModule } from 's' ; import { MatIconModule } from 's' ; import { MatMenuModule } from 's' ; import { MatProgressBarModule } from 's' ; import { CookieService } from 's' ; import { ProgressBarService } from 's' ; import { of } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < HeaderComponent > ; const cookieServiceSpy = jasmine . createSpyObj ( 's' , [ 's' , 's' ] ) ; const progressBarServiceSpy = jasmine . createSpyObj ( 's' , [ 's' ] ) ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { imports : [ RouterTestingModule , MatButtonModule , MatMenuModule , MatIconModule , MatProgressBarModule ] , declarations : [ MockComponent ( SearchBarComponent ) , HeaderComponent ] , providers : [ { provide : APP_CONFIG , useValue : AppConfig } , { provide : ProgressBarService , useValue : progressBarServiceSpy } , { provide : CookieService , useValue : cookieServiceSpy } ] } ) ; } ) ; beforeEach ( ( ) => { cookieServiceSpy . get . and . returnValue ( 's' ) ; progressBarServiceSpy . getUpdateProgressBar . and . returnValue ( of ( 's' ) ) ; fixture = TestBed . createComponent ( HeaderComponent ) ; component = fixture . debugElement . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ) ; it ( 's' , ( ( ) => { cookieServiceSpy . put . and . returnValue ( true ) ; expect ( component . selectedLanguage ) . toBe ( 's' ) ; component . changeLanguage ( 's' ) ; expect ( component . selectedLanguage ) . toBe ( 's' ) ; } ) ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $HeaderComponent$ O O $ComponentFixture$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $HeaderComponent$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $HeaderComponent$ O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $HeaderComponent$ O $string$ O O $any$ O O O O $HeaderComponent$ O $void$ O O O O $any$ O $HeaderComponent$ O $string$ O O $any$ O O O O O O O O O O O
import { ComponentFixture , TestBed } from 's' ; import { HeroCardComponent } from 's' ; import { Hero } from 's' ; import { configureTestSuite } from 's' ; import { MatCardModule } from 's' ; import { MatIconModule } from 's' ; import { MatSnackBar } from 's' ; import { 0 } from 's' ; import { of } from 's' ; import { HeroService } from 's' ; import { RouterTestingModule } from 's' ; import { ROUTES_CONFIG , RoutesConfig } from 's' ; import { CookieService } from 's' ; import { PLATFORM_ID } from 's' ; import { LazyLoadImageModule } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < HeroCardComponent > ; const matSnackBarSpy = jasmine . createSpyObj ( 's' , [ 's' ] ) ; const heroServiceSpy = jasmine . createSpyObj ( 's' , [ 's' , 's' ] ) ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { imports : [ RouterTestingModule , MatCardModule , MatIconModule , LazyLoadImageModule ] , declarations : [ HeroCardComponent ] , providers : [ { provide : MatSnackBar , useValue : matSnackBarSpy } , { provide : HeroService , useValue : heroServiceSpy } , { provide : 0 , useValue : ( ) => { } } , { provide : CookieService , useValue : { } } , { provide : ROUTES_CONFIG , useValue : RoutesConfig } , { provide : PLATFORM_ID , useValue : 's' } ] } ) ; } ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( HeroCardComponent ) ; component = fixture . componentInstance ; heroServiceSpy . updateHero . and . returnValue ( of ( [ new Hero ( { name : 's' } ) ] ) ) ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; it ( 's' , ( ) => { const hero = new Hero ( { likes : 0 } ) ; hero . like ( ) ; expect ( hero . likes ) . toBe ( 0 ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $HeroCardComponent$ O O $ComponentFixture$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O $any$ O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $any$ O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $void$ O O O O O O O O O $any$ O $any$ O ${}$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $string$ O O O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $HeroCardComponent$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $string$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $HeroCardComponent$ O O $any$ O O O O O O $any$ O O O O O O O O $Hero$ O O $any$ O O $number$ O O O O O $Hero$ O $void$ O O O $any$ O $Hero$ O $number$ O O $any$ O O O O O O O O O O
import { ComponentFixture , TestBed } from 's' ; import { HeroLoadingComponent } from 's' ; import { configureTestSuite } from 's' ; import { LoadingPlaceholderComponent } from 's' ; import { MockComponent } from 's' ; import { MatCardModule } from 's' ; import { MatIconModule } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < HeroLoadingComponent > ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { imports : [ MatCardModule , MatIconModule ] , declarations : [ MockComponent ( LoadingPlaceholderComponent ) , HeroLoadingComponent ] } ) ; } ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( HeroLoadingComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $HeroLoadingComponent$ O O $ComponentFixture$ O $any$ O O $any$ O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $HeroLoadingComponent$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $HeroLoadingComponent$ O O $any$ O O O O O O O O O
import { ComponentFixture , TestBed } from 's' ; import { LoadingPlaceholderComponent } from 's' ; import { configureTestSuite } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < LoadingPlaceholderComponent > ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { declarations : [ LoadingPlaceholderComponent ] } ) ; } ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( LoadingPlaceholderComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $LoadingPlaceholderComponent$ O O $ComponentFixture$ O $any$ O O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $LoadingPlaceholderComponent$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $LoadingPlaceholderComponent$ O O $any$ O O O O O O O O O
import { ComponentFixture , TestBed } from 's' ; import { SearchBarComponent } from 's' ; import { HeroService } from 's' ; import { Hero } from 's' ; import { of } from 's' ; import { configureTestSuite } from 's' ; import { MockPipe } from 's' ; import { MatAutocompleteModule } from 's' ; import { MatFormFieldModule } from 's' ; import { ReactiveFormsModule } from 's' ; import { RouterTestingModule } from 's' ; import { CapitalizeFirstPipe } from 's' ; import { ROUTES_CONFIG , RoutesConfig } from 's' ; import { MatInputModule } from 's' ; import { NoopAnimationsModule } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < SearchBarComponent > ; const heroServiceSpy = jasmine . createSpyObj ( 's' , [ 's' ] ) ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { imports : [ ReactiveFormsModule , RouterTestingModule , NoopAnimationsModule , MatAutocompleteModule , MatFormFieldModule , MatInputModule ] , declarations : [ MockPipe ( CapitalizeFirstPipe ) , SearchBarComponent ] , providers : [ { provide : HeroService , useValue : heroServiceSpy } , { provide : ROUTES_CONFIG , useValue : RoutesConfig } ] } ) ; } ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( SearchBarComponent ) ; component = fixture . debugElement . componentInstance ; heroServiceSpy . getHeroes . and . returnValue ( of ( [ new Hero ( { name : 's' , default : true } ) ] ) ) ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ) ; it ( 's' , ( ( ) => { component . defaultHeroes = [ new Hero ( { id : 0 , name : 's' , default : true } ) , new Hero ( { id : 0 , name : 's' , default : false } ) ] ; expect ( component . filterHeroes ( 's' ) . length ) . toBe ( 0 ) ; expect ( component . filterHeroes ( 's' ) . length ) . toBe ( 0 ) ; expect ( component . filterHeroes ( 's' ) . length ) . toBe ( 0 ) ; } ) ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $SearchBarComponent$ O O $ComponentFixture$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O O $any$ O $any$ O O $any$ O O $complex$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $SearchBarComponent$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O O $string$ O O O $boolean$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O O O $any$ O $SearchBarComponent$ O O $any$ O O O O O O O $any$ O O O O O O O O $SearchBarComponent$ O $Hero[]$ O O O $any$ O O $number$ O O O $string$ O O O $boolean$ O O O O O O $any$ O O $number$ O O O $string$ O O O $boolean$ O O O O O O $any$ O $SearchBarComponent$ O $Hero[]$ O O O O $number$ O O $any$ O O O O $any$ O $SearchBarComponent$ O $Hero[]$ O O O O $number$ O O $any$ O O O O $any$ O $SearchBarComponent$ O $Hero[]$ O O O O $number$ O O $any$ O O O O O O O O O O O
import { ComponentFixture , TestBed } from 's' ; import { SpinnerComponent } from 's' ; import { configureTestSuite } from 's' ; describe ( 's' , ( ) => { let component ; let fixture < SpinnerComponent > ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { declarations : [ SpinnerComponent ] } ) ; } ) ; beforeEach ( ( ) => { fixture = TestBed . createComponent ( SpinnerComponent ) ; component = fixture . componentInstance ; fixture . detectChanges ( ) ; } ) ; it ( 's' , ( ) => { expect ( component ) . toBeTruthy ( ) ; } ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $SpinnerComponent$ O O $ComponentFixture$ O $any$ O O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $SpinnerComponent$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O O $any$ O $SpinnerComponent$ O O $any$ O O O O O O O O O
import { CapitalizeFirstPipe } from 's' ; describe ( 's' , ( ) => { const pipe = new CapitalizeFirstPipe ( ) ; it ( 's' , ( ) => { expect ( pipe . transform ( 's' , [ ] ) ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( pipe . transform ( 's' , [ ] ) ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( pipe . transform ( 's' , [ ] ) ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( pipe . transform ( 's' , [ ] ) ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( pipe . transform ( 's' , [ ] ) ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( pipe . transform ( 's' , [ ] ) ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( pipe . transform ( 's' , [ ] ) ) . toBe ( 's' ) ; } ) ; } ) ;	O O $any$ O O O O $any$ O O O O O O O O $CapitalizeFirstPipe$ O O $any$ O O O $any$ O O O O O O O $any$ O $CapitalizeFirstPipe$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $CapitalizeFirstPipe$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $CapitalizeFirstPipe$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $CapitalizeFirstPipe$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $CapitalizeFirstPipe$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $CapitalizeFirstPipe$ O $string$ O O O O O O O O $any$ O O O O O O O $any$ O O O O O O O $any$ O $CapitalizeFirstPipe$ O $string$ O O O O O O O O $any$ O O O O O O O O O O
import { TestBed } from 's' ; import { LoggerService } from 's' ; import { configureTestSuite } from 's' ; describe ( 's' , ( ) => { let loggerService ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { providers : [ LoggerService ] } ) ; loggerService = TestBed . get ( LoggerService ) ; } ) ; it ( 's' , ( ( ) => { expect ( LoggerService . error ( 's' ) ) . toBeUndefined ( ) ; expect ( LoggerService . log ( 's' ) ) . toBeUndefined ( ) ; } ) ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $LoggerService$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O $LoggerService$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $void$ O O O O O $any$ O O O $any$ O $any$ O $void$ O O O O O $any$ O O O O O O O O O O
import { TestBed } from 's' ; import { ProgressBarService } from 's' ; import { configureTestSuite } from 's' ; describe ( 's' , ( ) => { let progressBarService ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { providers : [ ProgressBarService , ] } ) ; progressBarService = TestBed . get ( ProgressBarService ) ; } ) ; it ( 's' , ( ( ) => { expect ( progressBarService . list ( ) ) . toBe ( 0 ) ; } ) ) ; it ( 's' , ( ( ) => { progressBarService . increase ( ) ; progressBarService . increase ( ) ; expect ( progressBarService . list ( ) ) . toBe ( 0 ) ; progressBarService . decrease ( ) ; expect ( progressBarService . list ( ) ) . toBe ( 0 ) ; progressBarService . decrease ( ) ; expect ( progressBarService . list ( ) ) . toBe ( 0 ) ; progressBarService . decrease ( ) ; expect ( progressBarService . list ( ) ) . toBe ( 0 ) ; } ) ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $ProgressBarService$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O O $ProgressBarService$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $ProgressBarService$ O $number$ O O O O $any$ O O O O O O O O $any$ O O O O O O O O $ProgressBarService$ O $void$ O O O $ProgressBarService$ O $void$ O O O $any$ O $ProgressBarService$ O $number$ O O O O $any$ O O O O $ProgressBarService$ O $void$ O O O $any$ O $ProgressBarService$ O $number$ O O O O $any$ O O O O $ProgressBarService$ O $void$ O O O $any$ O $ProgressBarService$ O $number$ O O O O $any$ O O O O $ProgressBarService$ O $void$ O O O $any$ O $ProgressBarService$ O $number$ O O O O $any$ O O O O O O O O O O O
import { TestBed } from 's' ; import { UtilsHelperService } from 's' ; import { configureTestSuite } from 's' ; describe ( 's' , ( ) => { let utilsHelperService ; configureTestSuite ( ( ) => { TestBed . configureTestingModule ( { providers : [ UtilsHelperService ] } ) ; utilsHelperService = TestBed . get ( UtilsHelperService ) ; } ) ; it ( 's' , ( ( ) => { expect ( UtilsHelperService . isPalindrome ( 's' ) ) . toBe ( true ) ; expect ( UtilsHelperService . isPalindrome ( 's' ) ) . toBe ( false ) ; expect ( UtilsHelperService . isPalindrome ( 's' ) ) . toBe ( false ) ; expect ( UtilsHelperService . isPalindrome ( 's' ) ) . toBe ( false ) ; expect ( UtilsHelperService . isPalindrome ( 's' ) ) . toBe ( true ) ; expect ( UtilsHelperService . isPalindrome ( 's' ) ) . toBe ( true ) ; expect ( UtilsHelperService . isPalindrome ( 's' ) ) . toBe ( true ) ; } ) ) ; it ( 's' , ( ( ) => { expect ( UtilsHelperService . isBrowserValid ( ) ) . toBe ( true ) ; } ) ) ; } ) ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $UtilsHelperService$ O $any$ O O O O O $any$ O $any$ O O $complex$ O O $any$ O O O O $UtilsHelperService$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O O O O $any$ O $any$ O $boolean$ O O O O O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O $any$ O O O O $any$ O $any$ O $boolean$ O O O O O $any$ O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O O O
'js' ( function ( w , d , s , l , i ) { w [ l ] = w [ l ] || [ ] ; w [ l ] . push ( { 's' : new Date ( ) . getTime ( ) , event : 's' } ) ; var f = d . getElementsByTagName ( s ) [ 0 ] , j = d . createElement ( s ) , dl = l != 's' ? 's' + l : 's' ; j . async = true ; j . src = 's' + i + dl ; f . parentNode . insertBefore ( j , f ) ; } ) ( window , document , 's' , 's' , 's' ) ;	O O O O $complex$ O $Document$ O $string$ O $string$ O $string$ O O $complex$ O $string$ O O $complex$ O $string$ O O O O O $complex$ O $string$ O O $any$ O O O O O $DateConstructor$ O O O $number$ O O O $string$ O O O O O O $Element$ O $Document$ O O O $string$ O O O O O $HTMLElement$ O $Document$ O O O $string$ O O $string$ O $string$ O O O O O $string$ O O O $HTMLElement$ O $any$ O O O $HTMLElement$ O $any$ O O O $string$ O $string$ O $Element$ O $complex$ O $T$ O $HTMLElement$ O $Element$ O O O O O $complex$ O $Document$ O O O O O O O O
'js' ! function ( e , n , s ) { function o ( e , n ) { return typeof e === n } function t ( ) { var e , n , s , t , a , l , c ; for ( var f in i ) if ( i . hasOwnProperty ( f ) ) { if ( e = [ ] , n = i [ f ] , n . name && ( e . push ( n . name . toLowerCase ( ) ) , n . options && n . options . aliases && n . options . aliases . length ) ) for ( s = 0 ; s < n . options . aliases . length ; s ++ ) e . push ( n . options . aliases [ s ] . toLowerCase ( ) ) ; for ( t = o ( n . fn , "s" ) ? n . fn ( ) : n . fn , a = 0 ; a < e . length ; a ++ ) l = e [ a ] , c = l . split ( "s" ) , 0 === c . length ? Modernizr [ c [ 0 ] ] = t : ( ! Modernizr [ c [ 0 ] ] || Modernizr [ c [ 0 ] ] instanceof Boolean || ( Modernizr [ c [ 0 ] ] = new Boolean ( Modernizr [ c [ 0 ] ] ) ) , Modernizr [ c [ 0 ] ] [ c [ 0 ] ] = t ) , r . push ( ( t ? "s" : "s" ) + c . join ( "s" ) ) } } function a ( e ) { var n = c . className , s = Modernizr . _config . classPrefix || "s" ; if ( f && ( n = n . baseVal ) , Modernizr . _config . enableJSClass ) { var o = new RegExp ( "s" + s + "s" ) ; n = n . replace ( o , "s" + s + "s" ) } Modernizr . _config . enableClasses && ( n += "s" + s + e . join ( "s" + s ) , f ? c . className . baseVal = n : c . className = n ) } var r = [ ] , i = [ ] , l = { _version : "s" , _config : { classPrefix : "s" , enableClasses : ! 0 , enableJSClass : ! 0 , usePrefixes : ! 0 } , _q : [ ] , on : function ( e , n ) { var s = this ; setTimeout ( function ( ) { n ( s [ e ] ) } , 0 ) } , addTest : function ( e , n , s ) { i . push ( { name : e , fn : n , options : s } ) } , addAsyncTest : function ( e ) { i . push ( { name : null , fn : e } ) } } , Modernizr = function ( ) { } ; Modernizr . prototype = l , Modernizr = new Modernizr , Modernizr . addTest ( "s" , "s" in e ) , Modernizr . addTest ( "s" , function ( ) { var e = "s" ; try { return localStorage . setItem ( e , e ) , localStorage . removeItem ( e ) , ! 0 } catch ( n ) { return ! 0 } } ) , Modernizr . addTest ( "s" , function ( ) { var e = "s" ; try { return sessionStorage . setItem ( e , e ) , sessionStorage . removeItem ( e ) , ! 0 } catch ( n ) { return ! 0 } } ) ; var c = n . documentElement , f = "s" === c . nodeName . toLowerCase ( ) ; Modernizr . addTest ( "s" , "s" in n && "s" in n ) , t ( ) , a ( r ) , delete l . addTest , delete l . addAsyncTest ; for ( var u = 0 ; u < Modernizr . _q . length ; u ++ ) Modernizr . _q [ u ] ( ) ; e . Modernizr = Modernizr } ( window , document ) ;	O O O O $complex$ O $Document$ O $any$ O O O $boolean$ O $any$ O $any$ O O O O $any$ O $any$ O O $void$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $string$ O $any[]$ O O O $any[]$ O $boolean$ O $string$ O O O O O $any$ O O O O $any$ O $any[]$ O $string$ O O $any$ O $any$ O O $any[]$ O $number$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $number$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any[]$ O $number$ O $any$ O $any$ O $any$ O $number$ O O $any$ O O O O O O $any$ O $boolean$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $number$ O $any[]$ O $number$ O $any$ O O $any$ O $any[]$ O $number$ O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $BooleanConstructor$ O O $any$ O $any$ O O O O O O $BooleanConstructor$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O $any[]$ O $number$ O O $any$ O O O O O O $any$ O $any$ O O O O O O O $void$ O $any$ O O O $string$ O $HTMLElement$ O $string$ O $any$ O $any$ O $any$ O $any$ O O O O O $boolean$ O O $string$ O $string$ O $any$ O O $any$ O $any$ O $any$ O O O $RegExp$ O O $RegExpConstructor$ O O O $any$ O O O O $string$ O $string$ O $complex$ O $RegExp$ O O O $any$ O O O O $any$ O $any$ O $any$ O O $string$ O O O $any$ O $any$ O $any$ O O O $any$ O O $boolean$ O $HTMLElement$ O $string$ O $any$ O $string$ O $HTMLElement$ O $string$ O $string$ O O O $any[]$ O O O O $any[]$ O O O O $complex$ O O $string$ O O O $complex$ O O $string$ O O O $boolean$ O O O O $boolean$ O O O O $boolean$ O O O O O $undefined[]$ O O O O $void$ O O O $any$ O $any$ O O O $complex$ O O O $number$ O O O O O $any$ O $complex$ O $any$ O O O O O O O O $void$ O O O $any$ O $any$ O $any$ O O $any[]$ O $number$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $void$ O O O $any$ O O $any[]$ O $number$ O O $null$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O $any$ O $complex$ O $complex$ O $any$ O O $any$ O $any$ O $any$ O O O O O $complex$ O O $any$ O $any$ O O O O O O O O $string$ O O O O O O $Storage$ O $void$ O $string$ O $string$ O O $Storage$ O $void$ O $string$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O O $string$ O O O O O O $Storage$ O $void$ O $string$ O $string$ O O $Storage$ O $void$ O $string$ O O O O O O O $any$ O O O O O O O O O O $HTMLElement$ O $Document$ O $HTMLElement$ O $boolean$ O O O $HTMLElement$ O $string$ O $string$ O O O $any$ O $any$ O O O O O $Document$ O O O $Document$ O O $void$ O O O $void$ O $any[]$ O O O $complex$ O $void$ O O $complex$ O $void$ O O O O $number$ O O O $number$ O $any$ O $any$ O $any$ O $number$ O O $any$ O $any$ O $number$ O O O O $complex$ O $any$ O $any$ O O $complex$ O $Document$ O O
export const environment = { production : true , firebase : { apiKey : 's' , authDomain : 's' , databaseURL : 's' , projectId : 's' , storageBucket : 's' , messagingSenderId : 's' } } ;	O O $complex$ O O $boolean$ O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O
import { enableProdMode , MissingTranslationStrategy } from 's' ; import { platformBrowserDynamic } from 's' ; import { AppBrowserModule } from 's' ; import { environment } from 's' ; if ( environment . production ) { enableProdMode ( ) ; } document . addEventListener ( 's' , ( ) => { platformBrowserDynamic ( ) . bootstrapModule ( AppBrowserModule , { missingTranslation : MissingTranslationStrategy . Error , } ) . then ( ( ) => { if ( 's' in navigator && environment . production ) { navigator . serviceWorker . register ( 's' ) ; } } ) . catch ( err => console . log ( err ) ) ; } ) ;	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $complex$ O $boolean$ O O $any$ O O O O $Document$ O O O O O O O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O O $Navigator$ O $complex$ O $boolean$ O O $Navigator$ O $ServiceWorkerContainer$ O $Promise<ServiceWorkerRegistration>$ O O O O O O O O $any$ O $any$ O $Console$ O $void$ O $any$ O O O O O O
import { enableProdMode } from 's' ; import { environment } from 's' ; if ( environment . production ) { enableProdMode ( ) ; } export { AppServerModule } from 's' ;	O O $any$ O O O O O O $complex$ O O O O O O $complex$ O $boolean$ O O $any$ O O O O O O $any$ O O O O
import 's' ; import 's' ; import 's' ;	O O O O O O O O O
import 's' ; import { getTestBed } from 's' ; import { BrowserDynamicTestingModule , platformBrowserDynamicTesting } from 's' ; declare const require ; getTestBed ( ) . initTestEnvironment ( BrowserDynamicTestingModule , platformBrowserDynamicTesting ( ) ) ; const context = require . context ( 's' , true , "s" ) ; context . keys ( ) . map ( context ) ;	O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O