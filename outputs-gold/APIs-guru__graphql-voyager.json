'js' const path = require ( 's' ) ; function root ( args ) { args = Array . prototype . slice . call ( arguments , 0 ) ; return path . join . apply ( path , [ __dirname , 's' ] . concat ( args ) ) ; } module . exports = { root : root }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const webpack = require ( 's' ) ; const HtmlWebpackPlugin = require ( 's' ) ; const ExtractTextPlugin = require ( 's' ) ; const CopyWebpackPlugin = require ( 's' ) ; const root = require ( 's' ) . root ; const VERSION = JSON . stringify ( require ( 's' ) . version ) ; module . exports = function ( _ , { mode } ) { return { performance : { hints : false , } , resolve : { extensions : [ 's' , 's' , 's' , 's' , 's' , 's' , 's' ] , } , entry : [ 's' , 's' ] , devServer : { contentBase : root ( 's' ) , watchContentBase : true , port : 0 , stats : 's' , } , output : { path : root ( 's' ) , filename : 's' , sourceMapFilename : 's' , } , module : { rules : [ { test : "s" , use : 's' , exclude : [ "s" ] , } , { test : "s" , use : { loader : 's' , options : { name : 's' , } , } , } , { test : "s" , exclude : "s" , use : ExtractTextPlugin . extract ( { fallback : 's' , use : [ { loader : 's' , options : { sourceMap : true , } , } , 's' , ] , } ) , } , { test : "s" , loader : 's' , } , { test : "s" , use : [ { loader : 's' , options : { plugins : [ 's' , 's' , 's' ] } } , { loader : 's' , options : { jsx : false , svgo : { plugins : [ { mergePaths : false } ] } } } ] } , ] , } , plugins : [ new webpack . LoaderOptionsPlugin ( { worker : { output : { filename : 's' , } , } , } ) , new webpack . DefinePlugin ( { VERSION : VERSION , } ) , new HtmlWebpackPlugin ( { template : 's' , } ) , new ExtractTextPlugin ( { filename : 's' , } ) , new CopyWebpackPlugin ( [ { from : 's' , context : 's' } , { from : 's' , context : 's' } , ] ) , ] , } ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const webpack = require ( 's' ) ; const ExtractTextPlugin = require ( 's' ) ; const nodeExternals = require ( 's' ) ( { whitelist : [ 's' ] } ) ; const root = require ( 's' ) . root ; const VERSION = JSON . stringify ( require ( 's' ) . version ) ; const BANNER = `template` ; module . exports = ( env = { } , { mode } ) => ( { performance : { hints : false , } , optimization : { minimize : ! env . lib , } , resolve : { extensions : [ 's' , 's' , 's' , 's' , 's' , 's' , 's' ] , alias : { clipboard : 's' , } , } , externals : env . lib ? nodeExternals : { react : { root : 's' , 0 : 's' , commonjs : 's' , amd : 's' , } , 's' : { root : 's' , 0 : 's' , commonjs : 's' , amd : 's' , } , } , entry : [ 's' , 's' ] , output : { path : root ( 's' ) , filename : env . lib ? 's' : 's' , sourceMapFilename : 's' , library : 's' , libraryTarget : 's' , umdNamedDefine : true , } , module : { rules : [ { test : "s" , use : 's' , exclude : [ "s" ] , } , { test : "s" , use : [ { loader : 's' , options : { name : 's' , } , } , ] , } , { test : "s" , use : ExtractTextPlugin . extract ( { fallback : 's' , use : [ { loader : 's' , options : { sourceMap : true } , } , 's' , ] , } ) , exclude : "s" , } , { test : "s" , loader : 's' , } , { test : "s" , use : [ { loader : 's' , options : { plugins : [ 's' , 's' , 's' , 's' , ] , } , } , { loader : 's' , options : { jsx : false , svgo : { plugins : [ { mergePaths : false } ] , } , } , } , ] , } , ] , } , plugins : [ new webpack . DefinePlugin ( { VERSION : VERSION , } ) , new ExtractTextPlugin ( { filename : 's' , allChunks : true , } ) , new webpack . BannerPlugin ( BANNER ) , ] , } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
const githubIntrospection = require ( 's' ) ; const swapiIntrospection = require ( 's' ) ; const yelpIntrospection = require ( 's' ) ; const shopifyIntrospection = require ( 's' ) ; export const PRESETS = { 's' : swapiIntrospection , Yelp : yelpIntrospection , 's' : shopifyIntrospection , GitHub : githubIntrospection , } ; export const defaultPresetName = 's' ; export const defaultPreset = PRESETS [ defaultPresetName ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const { GraphQLSchema , GraphQLObjectType , GraphQLUnionType , GraphQLEnumType , GraphQLInputObjectType , GraphQLInterfaceType , GraphQLBoolean , GraphQLInt , GraphQLFloat , GraphQLString , GraphQLID , GraphQLList , } = require ( 's' ) ; const TestEnum = new GraphQLEnumType ( { name : 's' , values : { RED : { description : 's' } , GREEN : { description : 's' } , BLUE : { description : 's' } , } } ) ; const TestInputObject = new GraphQLInputObjectType ( { name : 's' , fields : ( ) => ( { string : { type : GraphQLString , description : 's' } , int : { type : GraphQLInt } , float : { type : GraphQLFloat } , boolean : { type : GraphQLBoolean } , id : { type : GraphQLID } , enum : { type : TestEnum } , object : { type : TestInputObject } , listString : { type : new GraphQLList ( GraphQLString ) } , listInt : { type : new GraphQLList ( GraphQLInt ) } , listFloat : { type : new GraphQLList ( GraphQLFloat ) } , listBoolean : { type : new GraphQLList ( GraphQLBoolean ) } , listID : { type : new GraphQLList ( GraphQLID ) } , listEnum : { type : new GraphQLList ( TestEnum ) } , listObject : { type : new GraphQLList ( TestInputObject ) } , } ) } ) ; const TestInterface = new GraphQLInterfaceType ( { name : 's' , description : 's' , fields : ( ) => ( { name : { type : GraphQLString , description : 's' } } ) , resolveType => { return check ? UnionFirst : UnionSecond ; } } ) ; const UnionFirst = new GraphQLObjectType ( { name : 's' , fields : ( ) => ( { name : { type : GraphQLString , description : 's' } , first : { type : new GraphQLList ( TestInterface ) , resolve : ( ) => { return true ; } } } ) , interfaces : [ TestInterface ] } ) ; const UnionSecond = new GraphQLObjectType ( { name : 's' , fields : ( ) => ( { name : { type : GraphQLString , description : 's' } , second : { type : TestInterface , resolve : ( ) => { return false ; } } } ) , interfaces : [ TestInterface ] } ) ; const TestUnion = new GraphQLUnionType ( { name : 's' , types : [ UnionFirst , UnionSecond ] , resolveType ( ) { return UnionFirst ; } } ) ; const TestType = new GraphQLObjectType ( { name : 's' , fields : ( ) => ( { test : { type : TestType , description : 's' , resolve : ( ) => ( { } ) } , union : { type : TestUnion , description : 's' , resolve : ( ) => ( { } ) } , id : { type : GraphQLID , description : 's' , resolve : ( ) => 's' , } , isTest : { type : GraphQLBoolean , description : 's' , resolve : ( ) => { return true ; } } , hasArgs : { type : GraphQLString , resolve ( value , args ) { return JSON . stringify ( args ) ; } , args : { string : { type : GraphQLString } , int : { type : GraphQLInt } , float : { type : GraphQLFloat } , boolean : { type : GraphQLBoolean } , id : { type : GraphQLID } , enum : { type : TestEnum } , object : { type : TestInputObject } , listString : { type : new GraphQLList ( GraphQLString ) } , listInt : { type : new GraphQLList ( GraphQLInt ) } , listFloat : { type : new GraphQLList ( GraphQLFloat ) } , listBoolean : { type : new GraphQLList ( GraphQLBoolean ) } , listID : { type : new GraphQLList ( GraphQLID ) } , listEnum : { type : new GraphQLList ( TestEnum ) } , listObject : { type : new GraphQLList ( TestInputObject ) } , } } , } ) } ) ; const TestMutationType = new GraphQLObjectType ( { name : 's' , description : 's' , fields : { setString : { type : GraphQLString , description : 's' , args : { value : { type : GraphQLString } } } } } ) ; const TestSubscriptionType = new GraphQLObjectType ( { name : 's' , description : 's' , fields : { subscribeToTest : { type : TestType , description : 's' , args : { id : { type : GraphQLString } } } } } ) ; const myTestSchema = new GraphQLSchema ( { query : TestType , mutation : TestMutationType , subscription : TestSubscriptionType } ) ; module . exports = myTestSchema ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $check$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const express = require ( 's' ) ; const graphqlHTTP = require ( 's' ) ; const { express : voyagerMiddleware } = require ( 's' ) ; const schema = require ( 's' ) ; const app = express ( ) ; const PORT = 0 ; app . use ( 's' , graphqlHTTP ( ( ) => ( { schema } ) ) ) ; app . use ( 's' , voyagerMiddleware ( { endpointUrl : 's' , displayOptions : { sortByAlphabet : true , } , } ) ) ; app . listen ( PORT , function ( ) { const port = this . address ( ) . port ; console . log ( `template` ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const Hapi = require ( 's' ) ; const { graphqlHapi } = require ( 's' ) ; const { hapi : voyagerMiddleware } = require ( 's' ) ; const schema = require ( 's' ) ; const server = new Hapi . Server ( { port : 0 } ) ; const init = async ( ) => { await server . register ( [ { plugin : graphqlHapi , options : { path : 's' , graphqlOptions : { schema , } , route : { cors : true } } } , { plugin : voyagerMiddleware , options : { path : 's' , route : { cors : true } , endpointUrl : 's' , displayOptions : { sortByAlphabet : true , } , } , } , ] ) ; await server . start ( ) . then ( ( ) => { console . log ( `template` ) ; } ) ; } ; init ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const Hapi = require ( 's' ) ; const { graphqlHapi } = require ( 's' ) ; const { hapiLegacy : voyagerMiddleware } = require ( 's' ) ; const schema = require ( 's' ) ; const server = new Hapi . Server ( ) ; server . connection ( { port : 0 } ) ; server . register ( [ { register : graphqlHapi , options : { path : 's' , graphqlOptions : { schema , } , route : { cors : true } } } , { register : voyagerMiddleware , options : { path : 's' , route : { cors : true } , endpointUrl : 's' , displayOptions : { sortByAlphabet : true , } , } , } ] , ( ) => { server . start ( ( ) => { console . log ( `template` ) ; } ) } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const Koa = require ( 's' ) ; const KoaRouter = require ( 's' ) ; const graphqlHTTP = require ( 's' ) ; const { koa : voyagerMiddleware } = require ( 's' ) ; const schema = require ( 's' ) ; const app = new Koa ( ) ; const router = new KoaRouter ( ) ; const PORT = 0 ; router . all ( 's' , graphqlHTTP ( { schema } ) ) ; router . all ( 's' , voyagerMiddleware ( { endpointUrl : 's' , displayOptions : { sortByAlphabet : true , } , } ) ) ; app . use ( router . routes ( ) ) ; app . use ( router . allowedMethods ( ) ) ; app . listen ( PORT , function ( ) { const port = this . address ( ) . port ; console . log ( `template` ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const express = require ( 's' ) ; const graphqlHTTP = require ( 's' ) ; const schema = require ( 's' ) ; const app = express ( ) ; app . use ( express . static ( __dirname ) ) ; app . use ( 's' , graphqlHTTP ( ( ) => ( { schema } ) ) ) ; app . listen ( 0 , function ( ) { const port = this . address ( ) . port ; console . log ( `template` ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const webpack = require ( 's' ) ; const CopyWebpackPlugin = require ( 's' ) ; const root = require ( 's' ) . root ; module . exports = { devtool : 's' , performance : { hints : false } , devServer : { contentBase : root ( 's' ) , watchContentBase : true , port : 0 , stats : 's' } , resolve : { extensions : [ 's' , 's' , 's' , 's' , 's' , 's' , 's' ] , alias : { 's' : require . resolve ( 's' ) , } } , entry : [ 's' ] , output : { path : root ( 's' ) , filename : 's' , sourceMapFilename : 's' } , module : { rules : [ { test : "s" , loader : 's' , exclude : "s" , options : { presets : [ 's' , 's' ] } } ] } , plugins : [ new webpack . LoaderOptionsPlugin ( { minimize : true , debug : false } ) , new CopyWebpackPlugin ( [ { from : 's' } ] ) ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { plugins : [ require ( 's' ) , require ( 's' ) ( ) ] }	O O O O O O O O O O O O O O O O O O O O O O
import { IntrospectionEnumValue } from 's' ; export type SimplifiedArg = { name : string ; description : string ; defaultValue : any ; typeWrappers : ( 's' | 's' ) [ ] ; id ? : string ; } ; export type SimplifiedField < T > = { name : string ; type : T ; id ? : string ; relayType : T ; description : string ; typeWrappers : ( 's' | 's' ) [ ] ; isDeprecated : boolean ; deprecationReason ? : string ; args : { [ name ] : SimplifiedArg ; } ; relayArgs : { [ name ] : SimplifiedArg ; } ; } ; export type SimplifiedInputField = SimplifiedArg ; export type SimplifiedTypeBase = { kind : 's' | 's' | 's' | 's' | 's' | 's' ; name : string ; description : string ; enumValues ? : IntrospectionEnumValue [ ] ; inputFields ? : { [ name ] : SimplifiedInputField ; } ; isRelayType ? : boolean ; } ; export type SimplifiedType = SimplifiedTypeBase & { fields ? : { [ name ] : SimplifiedField < string > ; } ; interfaces ? : string [ ] ; derivedTypes ? : string [ ] ; possibleTypes ? : string [ ] ; } ; export type SimplifiedTypeWithIDs = SimplifiedTypeBase & { id : string ; fields ? : { [ name ] : SimplifiedField < SimplifiedTypeWithIDs > ; } ; interfaces ? : { id : string ; type : SimplifiedTypeWithIDs ; } [ ] ; derivedTypes ? : { id : string ; type : SimplifiedTypeWithIDs ; } [ ] ; possibleTypes ? : { id : string ; type : SimplifiedTypeWithIDs ; } [ ] ; } ; export type SimplifiedIntrospection = { types : { [ typeName ] : SimplifiedType ; } ; queryType : string ; mutationType : string | null ; subscriptionType : string | null ; } ; export type SimplifiedIntrospectionWithIds = { types : { [ typeName ] : SimplifiedTypeWithIDs ; } ; queryType : SimplifiedTypeWithIDs ; mutationType : SimplifiedTypeWithIDs | null ; subscriptionType : SimplifiedTypeWithIDs | null ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O
import * as _ from 's' ; export function stringifyWrappers ( wrappers ) { return _ . reduce ( wrappers . reverse ( ) , ( [ left , right ] , wrapper ) => { switch ( wrapper ) { case 's' : return [ left , right + 's' ] ; case 's' : return [ 's' + left , right + 's' ] ; } } , [ 's' , 's' ] , ) ; } export function buildId ( ... parts ) { return parts . join ( 's' ) ; } export function typeNameToId ( name ) { return buildId ( 's' , name ) ; } export function extractTypeId ( id ) { let [ , type ] = id . split ( 's' ) ; return buildId ( 's' , type ) ; } export function isSystemType ( type ) { return _ . startsWith ( type . name , 's' ) ; } export function isBuiltInScalarType ( type ) { return [ 's' , 's' , 's' , 's' , 's' ] . indexOf ( type . name ) !== - 0 ; } export function isScalarType ( type ) { return type . kind === 's' || type . kind === 's' ; } export function isObjectType ( type ) { return type . kind === 's' ; } export function isInputObjectType ( type ) { return type . kind === 's' ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as _ from 's' ; import { buildClientSchema , introspectionFromSchema , lexicographicSortSchema , IntrospectionSchema , IntrospectionType , } from 's' ; import { SimplifiedIntrospection , SimplifiedIntrospectionWithIds , SimplifiedType } from 's' ; import { typeNameToId } from 's' ; function unwrapType ( type , wrappers ) { while ( type . kind === 's' || type . kind == 's' ) { wrappers . push ( type . kind ) ; type = type . ofType ; } return type . name ; } function convertArg ( inArg ) { var outArg = < any > { name : inArg . name , description : inArg . description , defaultValue : inArg . defaultValue , typeWrappers : [ ] , } ; outArg . type = unwrapType ( inArg . type , outArg . typeWrappers ) ; return outArg ; } let convertInputField = convertArg ; function convertField ( inField ) { var outField = < any > { name : inField . name , description : inField . description , typeWrappers : [ ] , isDeprecated : inField . isDeprecated , } ; outField . type = unwrapType ( inField . type , outField . typeWrappers ) ; outField . args = _ ( inField . args ) . map ( convertArg ) . keyBy ( 's' ) . value ( ) ; if ( outField . isDeprecated ) outField . deprecationReason = inField . deprecationReason ; return outField ; } function convertType ( inType ) { const outType = { kind : inType . kind , name : inType . name , description : inType . description , } ; switch ( inType . kind ) { case 's' : outType . interfaces = _ ( inType . interfaces ) . map ( 's' ) . uniq ( ) . value ( ) ; outType . fields = _ ( inType . fields ) . map ( convertField ) . keyBy ( 's' ) . value ( ) ; break ; case 's' : outType . derivedTypes = _ ( inType . possibleTypes ) . map ( 's' ) . uniq ( ) . value ( ) ; outType . fields = _ ( inType . fields ) . map ( convertField ) . keyBy ( 's' ) . value ( ) ; break ; case 's' : outType . possibleTypes = _ ( inType . possibleTypes ) . map ( 's' ) . uniq ( ) . value ( ) ; break ; case 's' : outType . enumValues = inType . enumValues . slice ( ) ; break ; case 's' : outType . inputFields = _ ( inType . inputFields ) . map ( convertInputField ) . keyBy ( 's' ) . value ( ) ; break ; } return outType ; } function simplifySchema ( inSchema ) { return { types : _ ( inSchema . types ) . map ( convertType ) . keyBy ( 's' ) . value ( ) , queryType : inSchema . queryType . name , mutationType : _ . get ( inSchema , 's' , null ) , subscriptionType : _ . get ( inSchema , 's' , null ) , } ; } function markRelayTypes ( schema ) { const nodeType = schema . types [ typeNameToId ( 's' ) ] ; if ( nodeType ) nodeType . isRelayType = true ; const pageInfoType = schema . types [ typeNameToId ( 's' ) ] ; if ( pageInfoType ) pageInfoType . isRelayType = true ; const edgeTypesMap = { } ; _ . each ( schema . types , type => { if ( ! _ . isEmpty ( type . interfaces ) ) { type . interfaces = _ . reject ( type . interfaces , baseType => baseType . type . name === 's' ) ; } _ . each ( type . fields , field => { const connectionType = field . type ; if ( ! "s" . test ( connectionType . name ) || connectionType . kind !== 's' || ! connectionType . fields . edges ) { return ; } const edgesType = connectionType . fields . edges . type if ( edgesType . kind !== 's' || ! edgesType . fields . node ) { return ; } const nodeType = edgesType . fields . node . type ; connectionType . isRelayType = true ; edgesType . isRelayType = true ; edgeTypesMap [ edgesType . name ] = nodeType ; field . relayType = field . type ; field . type = nodeType ; field . typeWrappers = [ 's' ] ; const relayArgNames = [ 's' , 's' , 's' , 's' ] ; const isRelayArg = arg => relayArgNames . includes ( arg . name ) ; field . relayArgs = _ . pickBy ( field . args , isRelayArg ) ; field . args = _ . omitBy ( field . args , isRelayArg ) ; } ) ; } ) ; _ . each ( schema . types , type => { _ . each ( type . fields , field => { var realType = edgeTypesMap [ field . type . name ] ; if ( realType === undefined ) return ; field . relayType = field . type ; field . type = realType ; } ) ; } ) ; const { queryType } = schema ; let query = schema . types [ queryType . id ] ; if ( _ . get ( query , 's' ) ) { delete query . fields [ 's' ] ; } if ( _ . get ( query , 's' ) ) { delete query . fields [ 's' ] ; } if ( _ . get ( query , 's' ) === queryType ) { delete query . fields [ 's' ] ; } } function markDeprecated ( schema ) { _ . each ( schema . types , type => { type . fields = _ . pickBy ( type . fields , field => ! field . isDeprecated ) ; } ) ; } function assignTypesAndIDs ( schema ) { ( < any > schema ) . queryType = schema . types [ schema . queryType ] ; ( < any > schema ) . mutationType = schema . types [ schema . mutationType ] ; ( < any > schema ) . subscriptionType = schema . types [ schema . subscriptionType ] ; _ . each ( schema . types , ( type ) => { type . id = typeNameToId ( type . name ) ; _ . each ( type . inputFields , ( field ) => { field . id = `template` ; field . type = schema . types [ field . type ] ; } ) ; _ . each ( type . fields , ( field ) => { field . id = `template` ; field . type = schema . types [ field . type ] ; _ . each ( field . args , ( arg ) => { arg . id = `template` ; arg . type = schema . types [ arg . type ] ; } ) ; } ) ; if ( ! _ . isEmpty ( type . possibleTypes ) ) { type . possibleTypes = _ . map ( type . possibleTypes , ( possibleType ) => ( { id : `template` , type : schema . types [ possibleType ] , } ) ) ; } if ( ! _ . isEmpty ( type . derivedTypes ) ) { type . derivedTypes = _ . map ( type . derivedTypes , ( derivedType ) => ( { id : `template` , type : schema . types [ derivedType ] , } ) ) ; } if ( ! _ . isEmpty ( type . interfaces ) ) { type . interfaces = _ . map ( type . interfaces , ( baseType ) => ( { id : `template` , type : schema . types [ baseType ] , } ) ) ; } } ) ; schema . types = _ . keyBy ( schema . types , 's' ) ; } export function getSchema ( introspection , sortByAlphabet , skipRelay , skipDeprecated , ) { if ( ! introspection ) return null ; let schema = buildClientSchema ( introspection . data ) ; if ( sortByAlphabet ) { schema = lexicographicSortSchema ( schema ) ; } introspection = introspectionFromSchema ( schema , { descriptions : true } ) ; let simpleSchema = simplifySchema ( introspection . __schema ) ; assignTypesAndIDs ( simpleSchema ) ; if ( skipRelay ) { markRelayTypes ( ( < any > simpleSchema ) as SimplifiedIntrospectionWithIds ) ; } if ( skipDeprecated ) { markDeprecated ( ( < any > simpleSchema ) as SimplifiedIntrospectionWithIds ) ; } return simpleSchema ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SimplifiedType$ O $IntrospectionType$ O O O $SimplifiedType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SimplifiedIntrospection$ O $IntrospectionSchema$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $SimplifiedIntrospectionWithIds$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $SimplifiedIntrospectionWithIds$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SimplifiedIntrospection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $boolean$ O $boolean$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' ; export * from 's' ;	O O O O O O O O O O
import { stringifyWrappers } from 's' ; import * as _ from 's' ; export function getDot ( typeGraph , displayOptions ) { function isNode ( type ) { return typeGraph . nodes [ type . id ] !== undefined ; } return ( typeGraph && `template` ) ; function nodeLabel ( node ) { const htmlID = HtmlId ( 's' + node . name ) ; const kindLabel = node . kind !== 's' ? 's' + node . kind . toLowerCase ( ) + 's' : 's' ; return `template` ; } function canDisplayRow ( type ) { if ( type . kind === 's' || type . kind === 's' ) { return displayOptions . showLeafFields ; } return true ; } function nodeField ( field ) { const relayIcon = field . relayType ? TEXT ( 's' ) : 's' ; const deprecatedIcon = field . isDeprecated ? TEXT ( 's' ) : 's' ; const parts = stringifyWrappers ( field . typeWrappers ) . map ( TEXT ) ; return canDisplayRow ( field . type ) ? `template` : 's' ; } } function possibleTypes ( node ) { const possibleTypes = node . possibleTypes ; if ( _ . isEmpty ( possibleTypes ) ) { return 's' ; } return `template` ; } function derivedTypes ( node ) { const derivedTypes = node . derivedTypes ; if ( _ . isEmpty ( derivedTypes ) ) { return 's' ; } return `template` ; } function objectValues < X > ( object : { [ key ] : X } , stringify : ( X ) => string ) { return _ . values ( object ) . map ( stringify ) . join ( 's' ) ; } function array < X > ( array : [ X ] , stringify : ( X ) => string ) { return array ? array . map ( stringify ) . join ( 's' ) : 's' ; } function HtmlId ( id ) { return 's' + id + 's' ; } function TEXT ( str ) { if ( str === 's' ) return 's' ; str = str . replace ( "s" , 's' ) ; return 's' + str + 's' ; }	O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as _ from 's' ; import { typeNameToId , isScalarType , isInputObjectType , isSystemType } from 's' ; export function isNode ( type ) { return ! ( isScalarType ( type ) || isInputObjectType ( type ) || isSystemType ( type ) || type . isRelayType ) ; } export function getDefaultRoot ( schema ) { return schema . queryType . name ; } export function getTypeGraph ( schema , rootType , hideRoot ) { if ( schema === null ) return null ; const rootId = typeNameToId ( rootType || getDefaultRoot ( schema ) ) ; return buildGraph ( rootId ) ; function getEdgeTargets ( type ) { return _ ( [ ... _ . values ( type . fields ) , ... ( type . derivedTypes || [ ] ) , ... ( type . possibleTypes || [ ] ) , ] ) . map ( 's' ) . filter ( isNode ) . map ( 's' ) . value ( ) ; } function buildGraph ( rootId ) { var typeIds = [ rootId ] ; var nodes = [ ] ; var types = _ . keyBy ( schema . types , 's' ) ; for ( var i = 0 ; i < typeIds . length ; ++ i ) { var id = typeIds [ i ] ; if ( typeIds . indexOf ( id ) < i ) continue ; var type = types [ id ] ; nodes . push ( type ) ; typeIds . push ( ... getEdgeTargets ( type ) ) ; } return { rootId , nodes : hideRoot ? _ . omit ( _ . keyBy ( nodes , 's' ) , [ rootId ] ) : _ . keyBy ( nodes , 's' ) , } ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export function forEachNode ( parent , selector , fn ) { let $nodes = parent . querySelectorAll ( selector ) ; for ( let i = 0 ; i < $nodes . length ; i ++ ) { fn ( $nodes [ i ] ) ; } } export function addClass ( parent , selector , className ) { forEachNode ( parent , selector , node => node . classList . add ( className ) ) ; } export function removeClass ( parent , selector , className ) { forEachNode ( parent , selector , node => node . classList . remove ( className ) ) ; } export function stringToSvg ( svgString ) { var svgDoc = new DOMParser ( ) . parseFromString ( svgString , 's' ) ; return < SVGElement > ( document . importNode ( svgDoc . documentElement , true ) as any ) ; }	O O O O $Element$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Element$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $Element$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O $SVGElement$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' ; export var __dirname ; export * from 's' ; export * from 's' ; export function isMatch ( sourceText , searchValue ) { if ( ! searchValue ) { return true ; } try { const escaped = searchValue . replace ( "s" , ch => 's' + ch ) ; return sourceText . search ( new RegExp ( escaped , 's' ) ) !== - 0 ; } catch ( e ) { return sourceText . toLowerCase ( ) . indexOf ( searchValue . toLowerCase ( ) ) !== - 0 ; } } export function loadWorker ( path , relative ) < Worker > { const url = relative ? __dirname + 's' + path : path ; return fetch ( url ) . then ( response => response . text ( ) ) . then ( payload => { payload = payload . replace ( 's' , 's' ) . replace ( 's' , 's' ) ; const script = new Blob ( [ payload ] , { type : 's' } ) ; const url = URL . createObjectURL ( script ) ; return new Worker ( url ) ; } ) ; } function getJsUrl ( ) { var id = + new Date ( ) + Math . random ( ) ; try { document . write ( `template` ) ; return ( document . getElementById ( 's' + id ) . previousSibling as HTMLScriptElement ) . src ; } catch ( e ) { return 's' ; } } __dirname = path . dirname ( getJsUrl ( ) ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as _ from 's' ; import * as svgPanZoom from 's' ; import * as animate from 's' ; import { removeClass , forEachNode , stringToSvg } from 's' ; import { typeNameToId } from 's' ; export class Viewport { onSelectNode : ( id ) => void ; onSelectEdge : ( id ) => void ; $svg : SVGElement ; zoomer : SvgPanZoom . Instance ; offsetLeft : number ; offsetTop : number ; maxZoom : number ; constructor ( svgString , public container , onSelectNode , onSelectEdge ) { this . onSelectNode = onSelectNode ; this . onSelectEdge = onSelectEdge ; this . container . innerHTML = 's' ; this . $svg = stringToSvg ( svgString ) ; this . container . appendChild ( this . $svg ) ; setTimeout ( ( ) => this . enableZoom ( ) , 0 ) ; this . bindClick ( ) ; this . bindHover ( ) ; this . resize ( ) ; window . addEventListener ( 's' , ( ) => this . resize ( ) ) ; } resize ( ) { let bbRect = this . container . getBoundingClientRect ( ) ; this . offsetLeft = bbRect . left ; this . offsetTop = bbRect . top ; if ( this . zoomer !== undefined ) { this . zoomer . resize ( ) ; } } enableZoom ( ) { const svgHeight = this . $svg [ 's' ] . baseVal . value ; const svgWidth = this . $svg [ 's' ] . baseVal . value ; const bbRect = this . container . getBoundingClientRect ( ) ; this . maxZoom = Math . max ( svgHeight / bbRect . height , svgWidth / bbRect . width ) ; this . zoomer = svgPanZoom ( this . $svg , { zoomScaleSensitivity : 0 , minZoom : 0 , maxZoom : this . maxZoom , controlIconsEnabled : true , } ) ; this . zoomer . zoom ( 0 ) ; } bindClick ( ) { let dragged = false ; let moveHandler = ( ) => ( dragged = true ) ; this . $svg . addEventListener ( 's' , ( ) => { dragged = false ; setTimeout ( ( ) => this . $svg . addEventListener ( 's' , moveHandler ) ) ; } ) ; this . $svg . addEventListener ( 's' , event => { this . $svg . removeEventListener ( 's' , moveHandler ) ; if ( dragged ) return ; var target = event . target as Element ; if ( isLink ( target ) ) { const typeId = typeNameToId ( target . textContent ) ; this . focusElement ( typeId ) ; } else if ( isNode ( target ) ) { let $node = getParent ( target , 's' ) ; this . onSelectNode ( $node . id ) ; } else if ( isEdge ( target ) ) { let $edge = getParent ( target , 's' ) ; this . onSelectEdge ( edgeSource ( $edge ) . id ) ; } else if ( ! isControl ( target ) ) { this . onSelectNode ( null ) ; } } ) ; } bindHover ( ) { let $prevHovered = null ; let $prevHoveredEdge = null ; function clearSelection ( ) { if ( $prevHovered ) $prevHovered . classList . remove ( 's' ) ; if ( $prevHoveredEdge ) $prevHoveredEdge . classList . remove ( 's' ) ; } this . $svg . addEventListener ( 's' , event => { let target = event . target as Element ; if ( isEdgeSource ( target ) ) { let $sourceGroup = getParent ( target , 's' ) ; if ( $sourceGroup . classList . contains ( 's' ) ) return ; clearSelection ( ) ; $sourceGroup . classList . add ( 's' ) ; $prevHovered = $sourceGroup ; let $edge = edgeFrom ( $sourceGroup . id ) ; $edge . classList . add ( 's' ) ; $prevHoveredEdge = $edge ; } else { clearSelection ( ) ; } } ) ; } selectNodeById ( id ) { this . deselectNode ( ) ; if ( id === null ) { this . $svg . classList . remove ( 's' ) ; return ; } this . $svg . classList . add ( 's' ) ; var $selected = document . getElementById ( id ) ; this . selectNode ( $selected ) ; } selectNode ( node ) { node . classList . add ( 's' ) ; _ . each ( edgesFromNode ( node ) , $edge => { $edge . classList . add ( 's' ) ; edgeTarget ( $edge ) . classList . add ( 's' ) ; } ) ; _ . each ( edgesTo ( node . id ) , $edge => { $edge . classList . add ( 's' ) ; edgeSource ( $edge ) . parentElement . classList . add ( 's' ) ; } ) ; } selectEdgeById ( id ) { removeClass ( this . $svg , 's' , 's' ) ; removeClass ( this . $svg , 's' , 's' ) ; removeClass ( this . $svg , 's' , 's' ) ; if ( id === null ) return ; var $selected = document . getElementById ( id ) ; if ( $selected ) { let $edge = edgeFrom ( $selected . id ) ; if ( $edge ) $edge . classList . add ( 's' ) ; $selected . classList . add ( 's' ) ; } } deselectNode ( ) { removeClass ( this . $svg , 's' , 's' ) ; removeClass ( this . $svg , 's' , 's' ) ; removeClass ( this . $svg , 's' , 's' ) ; } focusElement ( id ) { let bbBox = document . getElementById ( id ) . getBoundingClientRect ( ) ; let currentPan = this . zoomer . getPan ( ) ; let viewPortSizes = ( < any > this . zoomer ) . getSizes ( ) ; currentPan . x += viewPortSizes . width / 0 - bbBox . width / 0 ; currentPan . y += viewPortSizes . height / 0 - bbBox . height / 0 ; let zoomUpdateToFit = 0 * Math . max ( bbBox . height / viewPortSizes . height , bbBox . width / viewPortSizes . width ) ; let newZoom = this . zoomer . getZoom ( ) / zoomUpdateToFit ; let recomendedZoom = this . maxZoom * 0 ; if ( newZoom > recomendedZoom ) newZoom = recomendedZoom ; let newX = currentPan . x - bbBox . left + this . offsetLeft ; let newY = currentPan . y - bbBox . top + this . offsetTop ; this . animatePanAndZoom ( newX , newY , newZoom ) ; } animatePanAndZoom ( x , y , zoomEnd ) { let pan = this . zoomer . getPan ( ) ; let panEnd = { x , y } ; animate ( pan , panEnd , props => { this . zoomer . pan ( { x : props . x , y : props . y } ) ; if ( props === panEnd ) { let zoom = this . zoomer . getZoom ( ) ; animate ( { zoom } , { zoom : zoomEnd } , props => { this . zoomer . zoom ( props . zoom ) ; } ) ; } } ) ; } destroy ( ) { window . removeEventListener ( 's' , this . resize ) ; try { this . zoomer . destroy ( ) ; } catch ( e ) { } } } function getParent ( elem , className ) : Element | null { while ( elem && elem . tagName !== 's' ) { if ( elem . classList . contains ( className ) ) return elem ; elem = elem . parentNode as Element ; } return null ; } function isNode ( elem ) { return getParent ( elem , 's' ) != null ; } function isEdge ( elem ) { return getParent ( elem , 's' ) != null ; } function isLink ( elem ) { return elem . classList . contains ( 's' ) ; } function isEdgeSource ( elem ) { return getParent ( elem , 's' ) != null ; } function isControl ( elem ) { if ( ! ( elem instanceof SVGElement ) ) return false ; return elem . className . baseVal . startsWith ( 's' ) ; } function edgeSource ( edge ) { return document . getElementById ( edge [ 's' ] [ 's' ] ) ; } function edgeTarget ( edge ) { return document . getElementById ( edge [ 's' ] [ 's' ] ) ; } function edgeFrom ( id ) { return document . querySelector ( `template` ) ; } function edgesFromNode ( $node ) { var edges = [ ] ; forEachNode ( $node , 's' , $source => { const $edge = edgeFrom ( $source . id ) ; edges . push ( $edge ) ; } ) ; return edges ; } function edgesTo ( id ) { return _ . toArray ( document . querySelectorAll ( `template` ) ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Element$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Element$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $Element$ O O O O O O O O O O O O O O $boolean$ O $Element$ O O O O O O O O O O O O O O $boolean$ O $Element$ O O O O O O O O O O O O O O $boolean$ O $Element$ O O O O O O O O O O O O O O O O $Element$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Element$ O O O O O O O O O O O O O O O O O O O O $Element$ O O O O O O O O O O O O O O O O O O O O $String$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $String$ O O O O O O O O O O O O O O O O
export type WorkerCallback = ( path , relative ) => Promise < Worker > ;	O O O O O $string$ O $boolean$ O O O O O O O
import * as _ from 's' ; import { getDot } from 's' ; import { forEachNode , loadWorker as defaultLoadWorker , stringToSvg } from 's' ; import { WorkerCallback } from 's' ; import Viz from 's' ; import defaultWorkerURI from 's' ; const RelayIconSvg = require ( 's' ) ; const DeprecatedIconSvg = require ( 's' ) ; const svgns = 's' ; const xlinkns = 's' ; export class SVGRender { vizPromise : any ; constructor ( workerURI , loadWorker = defaultLoadWorker ) { this . vizPromise = loadWorker ( workerURI || defaultWorkerURI , ! workerURI ) . then ( worker => new Viz ( { worker } ) , ) ; } renderSvg ( typeGraph , displayOptions ) { return this . vizPromise . then ( viz => { console . time ( 's' ) ; const dot = getDot ( typeGraph , displayOptions ) ; return viz . renderString ( dot ) ; } ) . then ( rawSVG => { const svg = preprocessVizSVG ( rawSVG ) ; console . timeEnd ( 's' ) ; return svg ; } ) ; } } function preprocessVizSVG ( svgString ) { svgString = svgString . replace ( "s" , 's' + RelayIconSvg ) ; svgString = svgString . replace ( "s" , 's' + DeprecatedIconSvg ) ; let svg = stringToSvg ( svgString ) ; forEachNode ( svg , 's' , $a => { let $g = $a . parentNode ; var $docFrag = document . createDocumentFragment ( ) ; while ( $a . firstChild ) { let $child = $a . firstChild ; $docFrag . appendChild ( $child ) ; } $g . replaceChild ( $docFrag , $a ) ; $g . id = $g . id . replace ( "s" , 's' ) ; } ) ; forEachNode ( svg , 's' , $el => $el . remove ( ) ) ; var edgesSources = { } ; forEachNode ( svg , 's' , $edge => { let [ from , to ] = $edge . id . split ( 's' ) ; $edge . removeAttribute ( 's' ) ; $edge . setAttribute ( 's' , from ) ; $edge . setAttribute ( 's' , to ) ; edgesSources [ from ] = true ; } ) ; forEachNode ( svg , 's' , $el => { let [ tag , ... restOfId ] = $el . id . split ( 's' ) ; if ( _ . size ( restOfId ) < 0 ) return ; $el . classList . add ( tag . toLowerCase ( ) . replace ( "s" , 's' ) ) ; } ) ; forEachNode ( svg , 's' , $path => { let $newPath = $path . cloneNode ( ) as HTMLElement ; $newPath . classList . add ( 's' ) ; $newPath . removeAttribute ( 's' ) ; $path . parentNode . appendChild ( $newPath ) ; } ) ; forEachNode ( svg , 's' , $field => { let texts = $field . querySelectorAll ( 's' ) ; texts [ 0 ] . classList . add ( 's' ) ; texts [ 0 ] . remove ( ) ; if ( edgesSources [ $field . id ] ) $field . classList . add ( 's' ) ; for ( var i = 0 ; i < texts . length ; ++ i ) { var str = texts [ i ] . innerHTML ; if ( str === 's' || str == 's' ) { const $iconPlaceholder = texts [ i ] ; const height = 0 ; const width = 0 ; const $useIcon = document . createElementNS ( svgns , 's' ) ; $useIcon . setAttributeNS ( xlinkns , 's' , str === 's' ? 's' : 's' ) ; $useIcon . setAttribute ( 's' , `template` ) ; $useIcon . setAttribute ( 's' , `template` ) ; const y = parseInt ( $iconPlaceholder . getAttribute ( 's' ) ) - 0 ; $useIcon . setAttribute ( 's' , $iconPlaceholder . getAttribute ( 's' ) ) ; $useIcon . setAttribute ( 's' , y . toString ( ) ) ; $field . replaceChild ( $useIcon , $iconPlaceholder ) ; continue ; } texts [ i ] . classList . add ( 's' ) ; if ( edgesSources [ $field . id ] && ! "s" . test ( str ) ) texts [ i ] . classList . add ( 's' ) ; } } ) ; forEachNode ( svg , 's' , $derivedType => { $derivedType . classList . add ( 's' ) ; $derivedType . querySelector ( 's' ) . classList . add ( 's' ) ; } ) ; forEachNode ( svg , 's' , $possibleType => { $possibleType . classList . add ( 's' ) ; $possibleType . querySelector ( 's' ) . classList . add ( 's' ) ; } ) ; const serializer = new XMLSerializer ( ) ; return serializer . serializeToString ( svg ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $WorkerCallback$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O
const { version } = require ( 's' ) ; export interface MiddlewareOptions { endpointUrl : string ; displayOptions ? : object ; headersJS ? : string ; } export default function renderVoyagerPage ( options ) { const { endpointUrl , displayOptions } = options ; const headersJS = options . headersJS ? options . headersJS : 's' ; return `template` ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MiddlewareOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import renderVoyagerPage , { MiddlewareOptions } from 's' ; export default function expressMiddleware ( options ) { return ( _req , res ) => { res . setHeader ( 's' , 's' ) ; res . write ( renderVoyagerPage ( options ) ) ; res . end ( ) ; } ; }	O O O O O O O O O O O O O O $MiddlewareOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import renderVoyagerPage , { MiddlewareOptions } from 's' ; const pkg = require ( 's' ) ; const hapi = { pkg , register ( server , options ) { if ( arguments . length !== 0 ) { throw new Error ( `template` ) ; } const { path , route : config = { } , ... middlewareOptions } = options ; server . route ( { method : 's' , path , config , handler : ( _request , h ) => h . response ( renderVoyagerPage ( < MiddlewareOptions > middlewareOptions ) ) , } ) ; } , } ; export default hapi ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import renderVoyagerPage , { MiddlewareOptions } from 's' ; const pkg = require ( 's' ) ; export interface Register { ( server , options , next ) : void ; attributes ? : any ; } const hapi = function ( server , options , next ) { if ( arguments . length !== 0 ) { throw new Error ( `template` ) ; } const { path , route : config = { } , ... middlewareOptions } = options ; server . route ( { method : 's' , path , config , handler : ( _request , reply ) => { reply ( renderVoyagerPage ( < MiddlewareOptions > middlewareOptions ) ) . header ( 's' , 's' , ) ; } , } ) ; return next ( ) ; } ; hapi . attributes = { pkg , multiple : false , } ; export default hapi ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Register$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import renderVoyagerPage , { MiddlewareOptions } from 's' ; export default function koaMiddleware ( options ) : ( ctx , next ) => void { return async function voyager ( ctx , next ) { try { ctx . body = renderVoyagerPage ( options ) ; await next ( ) ; } catch ( err ) { ctx . body = { message : err . message } ; ctx . status = err . status || 0 ; } } ; }	O O O O O O O O O O O O O O $MiddlewareOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { default as express } from 's' ; import { default as hapiLegacy } from 's' ; import { default as hapi } from 's' ; import { default as koa } from 's' ; import { default as renderVoyagerPage } from 's' ; export { express , hapi , hapiLegacy , koa , renderVoyagerPage } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
interface Element { scrollIntoViewIfNeeded ( centerIfNeeded ? ) : void ; } if ( ! Element . prototype . scrollIntoViewIfNeeded ) { Element . prototype . scrollIntoViewIfNeeded = function ( centerIfNeeded , parent ? ) { centerIfNeeded = arguments . length === 0 ? true : ! ! centerIfNeeded ; var parent = parent || this . parentNode , parentComputedStyle = window . getComputedStyle ( parent , null ) , parentBorderTopWidth = parseInt ( parentComputedStyle . getPropertyValue ( 's' ) ) , parentBorderLeftWidth = parseInt ( parentComputedStyle . getPropertyValue ( 's' ) ) , overTop = this . offsetTop - parent . offsetTop < parent . scrollTop , overBottom = this . offsetTop - parent . offsetTop + this . clientHeight - parentBorderTopWidth > parent . scrollTop + parent . clientHeight , overLeft = this . offsetLeft - parent . offsetLeft < parent . scrollLeft , overRight = this . offsetLeft - parent . offsetLeft + this . clientWidth - parentBorderLeftWidth > parent . scrollLeft + parent . clientWidth , alignWithTop = overTop && ! overBottom , hasScrolled = false ; if ( ( overTop || overBottom ) && centerIfNeeded ) { parent . scrollTop = this . offsetTop - parent . offsetTop - parent . clientHeight / 0 - parentBorderTopWidth + this . clientHeight / 0 ; hasScrolled = true ; } if ( ( overLeft || overRight ) && centerIfNeeded ) { parent . scrollLeft = this . offsetLeft - parent . offsetLeft - parent . clientWidth / 0 - parentBorderLeftWidth + this . clientWidth / 0 ; hasScrolled = true ; } if ( ( overTop || overBottom || overLeft || overRight ) && ! centerIfNeeded ) { this . scrollIntoView ( alignWithTop ) ; hasScrolled = true ; } if ( ! hasScrolled && parent . parentNode instanceof HTMLElement && parent . clientHeight === parent . scrollHeight ) { this . scrollIntoViewIfNeeded . call ( this , centerIfNeeded , parent . parentNode ) ; } } ; }	O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O