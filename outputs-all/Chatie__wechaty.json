'js' const rules = { } module . exports = { extends : 's' , rules , }	O O ${}$ O O O $complex$ O $complex$ O O $string$ O O O ${}$ O O
export const PUPPET_DEPENDENCIES = { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , } export type PuppetModuleName = keyof typeof PUPPET_DEPENDENCIES export const PUPPET_NAME_DEFAULT = 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O $PuppetModuleName$ O O
export const VERSION = 's'	O O O O O
import fs from 's' import os from 's' import path from 's' import qrImage from 's' import Raven from 's' import readPkgUp from 's' import { log } from 's' import { FileBox } from 's' import { PuppetModuleName , PUPPET_NAME_DEFAULT , } from 's' import { VERSION } from 's' const pkg = readPkgUp . sync ( { cwd : __dirname } ) ! . package Raven . disableConsoleAlerts ( ) Raven . config ( isProduction ( ) && 's' , { release : VERSION , tags : { git_commit : 's' , platform : process . env . WECHATY_DOCKER ? 's' : os . platform ( ) , } , } , ) . install ( ) const logLevel = process . env . WECHATY_LOG if ( logLevel ) { log . level ( logLevel . toLowerCase ( ) as any ) log . silly ( 's' , 's' , logLevel ) } if ( log . level ( ) === 's' || log . level ( ) === 's' ) { log . info ( 's' , 's' ) process . on ( 's' , ( reason , promise ) => { log . error ( 's' , 's' ) log . error ( 's' , 's' , reason , promise ) log . error ( 's' , 's' ) promise . catch ( err => { log . error ( 's' , 's' , err . message ) console . error ( 's' , err ) } ) } ) } export interface DefaultSetting { DEFAULT_HEAD : number , DEFAULT_PORT : number , DEFAULT_APIHOST : string , DEFAULT_TOKEN : string , DEFAULT_PROTOCOL : string , } const DEFAULT_SETTING = pkg . wechaty as DefaultSetting export class Config { public default = DEFAULT_SETTING public apihost = process . env . WECHATY_APIHOST || DEFAULT_SETTING . DEFAULT_APIHOST public head = ( 's' in process . env ) ? ( ! ! process . env . WECHATY_HEAD ) : ( ! ! ( DEFAULT_SETTING . DEFAULT_HEAD ) ) public systemPuppetName ( ) { return ( process . env . WECHATY_PUPPET || PUPPET_NAME_DEFAULT ) . toLowerCase ( ) as PuppetModuleName } public profile = process . env . WECHATY_PROFILE public name = process . env . WECHATY_NAME || process . env . WECHATY_PROFILE public token = process . env . WECHATY_TOKEN public debug = ! ! ( process . env . WECHATY_DEBUG ) public httpPort = process . env . PORT || process . env . WECHATY_PORT || DEFAULT_SETTING . DEFAULT_PORT public docker = ! ! ( process . env . WECHATY_DOCKER ) constructor ( ) { log . verbose ( 's' , 's' ) this . validApiHost ( this . apihost ) if ( this . profile ) { log . warn ( 's' , 's' ) } } public gitRevision ( ) : string | null { const dotGitPath = path . join ( __dirname , 's' , 's' ) const gitArgs = [ 's' , 's' ] try { fs . statSync ( dotGitPath ) . isDirectory ( ) const ss = require ( 's' ) . spawnSync ( 's' , gitArgs , { cwd : __dirname } ) if ( ss . status !== 0 ) { throw new Error ( ss . error ) } const revision = ss . stdout . toString ( ) . trim ( ) . slice ( 0 , 0 ) return revision } catch ( e ) { log . silly ( 's' , 's' , e . message ) return null } } public validApiHost ( apihost ) { if ( "s" . test ( apihost ) ) { return true } throw new Error ( 's' + apihost ) } } export const CHATIE_OFFICIAL_ACCOUNT_ID = 's' export function qrCodeForChatie ( ) { const CHATIE_OFFICIAL_ACCOUNT_QRCODE = 's' const name = 's' const type = 's' const qrStream = qrImage . image ( CHATIE_OFFICIAL_ACCOUNT_QRCODE , { type } ) return FileBox . fromStream ( qrStream , name ) } export const FOUR_PER_EM_SPACE = String . fromCharCode ( 0 ) export const AT_SEPRATOR_REGEX = "s" export function qrcodeValueToImageUrl ( qrcodeValue ) { return [ 's' , encodeURIComponent ( qrcodeValue ) , 's' , ] . join ( 's' ) } export function isProduction ( ) { return process . env . NODE_ENV === 's' || process . env . NODE_ENV === 's' } export { log , Raven , VERSION , } export const config = new Config ( )	O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ $any$ O $any$ O O $any$ O $any$ O $boolean$ O O O O O O $string$ O O O $complex$ O O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $Console$ O $void$ O O O $any$ O O O O O O O O $any$ O $number$ O O O $number$ O O O $string$ O O O $string$ O O O $string$ O O O O O $DefaultSetting$ O $any$ O $any$ O $any$ O O $any$ O O $DefaultSetting$ O $DefaultSetting$ O $any$ O $any$ O $any$ O $any$ O $DefaultSetting$ O $string$ O $boolean$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $DefaultSetting$ O $number$ O O O $PuppetModuleName$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $DefaultSetting$ O $number$ O $boolean$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $boolean$ O O O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O O O O $string$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $string[]$ O O O O O O O O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O O $any$ O O O $string[]$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $ErrorConstructor$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O O O O O O $any$ O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $boolean$ O $string$ O O O O O O $boolean$ O $string$ O O O O O O O O $ErrorConstructor$ O O O $string$ O O O O O O O O O O $FileBox$ O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O $string$ O O O $any$ O $any$ O $any$ O O O O O O $string$ O $StringConstructor$ O $string$ O O O O O $RegExp$ O O O O $string$ O $string$ O O O O O O $string$ O $string$ O O O O O O $string$ O O O O O O $boolean$ O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O $Config$ O O $any$ O O
import { createServer , Socket , } from 's' import { log , } from 's' export class Doctor { constructor ( ) { log . verbose ( 's' , 's' ) } public chromedriverVersion ( ) { const spawn = require ( 's' ) . spawnSync let version try { const cmd = spawn ( 's' , [ 's' ] ) version = cmd . error || cmd . stdout . toString ( ) || cmd . stderr . toString ( ) } catch ( e ) { version = e . message } return version } public testTcp ( ) < boolean > { log . verbose ( 's' , 's' ) return new Promise < boolean > ( async ( resolve , reject ) => { const server = createServer ( socket => socket . pipe ( socket ) ) server . on ( 's' , reject ) server . on ( 's' , ( ) => log . silly ( 's' , 's' ) ) server . listen ( 0 , 's' , ( ) => { const client = new Socket ( ) client . connect ( 0 , 's' , ( ) => { log . silly ( 's' , 's' ) client . write ( 's' ) } ) client . on ( 's' , ( ) => { resolve ( true ) client . destroy ( ) } ) client . on ( 's' , reject ) client . on ( 's' , ( ) => server . close ( ) ) } ) } ) } }	O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O O O O O O $string$ O O O O $any$ O $any$ O O O O $any$ O $string$ O O O $any$ O $any$ O O O O O O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O $string$ O $any$ O $any$ O O $string$ O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O $PromiseConstructor$ O O O O O O $void$ O $void$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $void$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O $any$ O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $void$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O O
import { EventEmitter } from 's' import { instanceToClass } from 's' import { log } from 's' import { Puppet } from 's' import { Wechaty } from 's' export const SYMBOL_NAME = Symbol ( 's' ) export const SYMBOL_COUNTER = Symbol ( 's' ) let COUNTER = 0 export abstract class Accessory extends EventEmitter { private [ SYMBOL_NAME ] : string private [ SYMBOL_COUNTER ] : number private static _puppet ? : Puppet private static _wechaty ? : Wechaty public static set puppet ( puppet ) { log . silly ( 's' , 's' , this . name , puppet , ) if ( this . _puppet ) { throw new Error ( 's' ) } this . _puppet = puppet } public static get puppet ( ) : Puppet { if ( this . _puppet ) { return this . _puppet } throw new Error ( [ 's' , this . name , 's' , 's' , ] . join ( 's' ) ) } public static set wechaty ( wechaty ) { log . silly ( 's' , 's' , this . name , wechaty , ) if ( this . _wechaty ) { throw new Error ( 's' ) } this . _wechaty = wechaty } public static get wechaty ( ) : Wechaty { if ( this . _wechaty ) { return this . _wechaty } throw new Error ( 's' + this . name ) } private _puppet ? : Puppet public set puppet ( puppet ) { log . silly ( 's' , 's' , this [ SYMBOL_NAME ] || this , puppet , ) if ( this . _puppet ) { throw new Error ( 's' ) } this . _puppet = puppet } public get puppet ( ) : Puppet { if ( this . _puppet ) { return this . _puppet } return instanceToClass ( this , Accessory ) . puppet } public get wechaty ( ) : Wechaty { return instanceToClass ( this , Accessory ) . wechaty } constructor ( name ? , ) { super ( ) this [ SYMBOL_NAME ] = name || this . toString ( ) this [ SYMBOL_COUNTER ] = COUNTER ++ log . silly ( 's' , 's' , this [ SYMBOL_COUNTER ] , this [ SYMBOL_NAME ] , name || 's' , ) } }	O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $any$ O O O O O $complex$ O $SymbolConstructor$ O O O O O $complex$ O $SymbolConstructor$ O O O O $number$ O O O O O $any$ O $any$ O O O $complex$ O O O O O $complex$ O O O O O $any$ O O $any$ O O $Wechaty$ O O $any$ O O O $any$ O $Puppet$ O O $any$ O $any$ O O O O O O O $string$ O $any$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O $any$ O O O O O $any$ O O O $ErrorConstructor$ O O O O O O $string$ O O O O O O O $string$ O O O O O O O O $Wechaty$ O $Wechaty$ O O $any$ O $any$ O O O O O O O $string$ O $Wechaty$ O O O O O O $Wechaty$ O O O O $ErrorConstructor$ O O O O O O $Wechaty$ O $Wechaty$ O O O O $Wechaty$ O O O $any$ O O O O O $Wechaty$ O O O O O $Wechaty$ O O O $ErrorConstructor$ O O O O O $string$ O O O $any$ O O $any$ O O $any$ O $Puppet$ O O $any$ O $any$ O O O O O O O $complex$ O O O O $any$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O $any$ O O O O O $any$ O O $any$ O O O $any$ O O $any$ O O O $Wechaty$ O O O $any$ O O $any$ O O O $any$ O O $any$ O O O $string$ $string$ O O O O O O O O $complex$ O O $string$ O O O $string$ O O O O $complex$ O O $number$ O $any$ O $any$ O O O O O O O $complex$ O O O O $complex$ O O $string$ O O O O O O
import { UrlLinkPayload , } from 's' import { log , } from 's' export class UrlLink { public static async create ( url ) < UrlLink > { log . verbose ( 's' , 's' , url ) const payload = { description : 's' , thumbnailUrl : 's' , title : 's' , url , } return new UrlLink ( payload ) } constructor ( public readonly payload , ) { log . verbose ( 's' , 's' ) } public toString ( ) { return `template` } public url ( ) { return this . payload . url } public title ( ) { return this . payload . title } public thumbnailUrl ( ) : undefined | string { return this . payload . thumbnailUrl } public description ( ) : undefined | string { return this . payload . description } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $Promise$ O $string$ O O $any$ O O $any$ O $any$ O O O O O $string$ O O $UrlLinkPayload$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O $any$ O $any$ O O O O O O $UrlLinkPayload$ O O O $any$ O $any$ O O O O O O O $string$ O O O O O O O $string$ O O O O O O $any$ O $any$ O O $string$ O O O O O O $any$ O $any$ O O $string$ O O O O O O O O O O $any$ O $any$ O O $string$ O O O O O O O O O O $any$ O $any$ O O
import { MiniProgramPayload , } from 's' import { log , } from 's' export class MiniProgram { public static async create ( ) < MiniProgram > { log . verbose ( 's' , 's' ) const payload = { appid : 's' , description : 's' , pagepath : 's' , thumbnailurl : 's' , title : 's' , username : 's' , } return new MiniProgram ( payload ) } constructor ( public readonly payload , ) { log . verbose ( 's' , 's' ) } public appid ( ) : undefined | string { return this . payload . appid } public title ( ) : undefined | string { return this . payload . title } public pagepath ( ) : undefined | string { return this . payload . pagepath } public username ( ) : undefined | string { return this . payload . username } public description ( ) : undefined | string { return this . payload . description } public thumbnailurl ( ) : undefined | string { return this . payload . thumbnailurl } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $Promise$ O O O $any$ O O $any$ O $any$ O O O O O O $MiniProgramPayload$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O $any$ O O O O O O $MiniProgramPayload$ O O O $any$ O $any$ O O O O O O O $string$ O O O O O O O O O O $any$ O $any$ O O $string$ O O O O O O O O O O $any$ O $any$ O O $string$ O O O O O O O O O O $any$ O $any$ O O $string$ O O O O O O O O O O $any$ O $any$ O O $string$ O O O O O O O O O O $any$ O $any$ O O $string$ O O O O O O O O O O $any$ O $any$ O O
import { instanceToClass } from 's' import { FileBox } from 's' import { ContactGender , ContactPayload , ContactQueryFilter , ContactType , } from 's' import { Accessory , } from 's' import { log , qrCodeForChatie , Raven , } from 's' import { Sayable , } from 's' import { UrlLink } from 's' import { MiniProgram } from 's' export const POOL = Symbol ( 's' ) export class Contact extends Accessory implements Sayable { public static Type = ContactType public static Gender = ContactGender protected static [ POOL ] : Map < string , Contact > protected static get pool ( ) { return this [ POOL ] } protected static set pool ( newPool < string , Contact > ) { if ( this === Contact ) { throw new Error ( 's' + 's' , ) } this [ POOL ] = newPool } public static load < T extends typeof Contact > ( this : T , id , ) : T [ 's' ] { if ( ! this . pool ) { log . verbose ( 's' , 's' , id ) this . pool = new Map < string , Contact > ( ) } if ( this === Contact ) { throw new Error ( 's' + 's' , ) } if ( this . pool === Contact . pool ) { throw new Error ( 's' ) } const existingContact = this . pool . get ( id ) if ( existingContact ) { return existingContact } const newContact = new ( this as any ) ( id ) as Contact this . pool . set ( id , newContact ) return newContact } public static async find < T extends typeof Contact > ( this : T , query : string | ContactQueryFilter , ) < T [ 's' ] | null > { log . verbose ( 's' , 's' , JSON . stringify ( query ) ) const contactList = await this . findAll ( query ) if ( ! contactList ) { return null } if ( contactList . length < 0 ) { return null } if ( contactList . length > 0 ) { log . warn ( 's' , 's' , contactList . length ) } let n = 0 for ( n = 0 ; n < contactList . length ; n ++ ) { const contact = contactList [ n ] const valid = await this . puppet . contactValidate ( contact . id ) if ( valid ) { log . verbose ( 's' , 's' , n , contact . id , ) return contact } else { log . verbose ( 's' , 's' , n , contact . id , ) } } log . warn ( 's' , 's' , contactList . length ) return null } public static async findAll < T extends typeof Contact > ( this : T , query ? : string | ContactQueryFilter , ) < Array < T [ 's' ] > > { log . verbose ( 's' , 's' , JSON . stringify ( query ) || 's' ) try { const contactIdList : string [ ] = await this . puppet . contactSearch ( query ) const contactList = contactIdList . map ( id => this . load ( id ) ) const BATCH_SIZE = 0 let batchIndex = 0 const invalidDict : { [ id ] : true } = { } while ( batchIndex * BATCH_SIZE < contactList . length ) { const batchContactList = contactList . slice ( BATCH_SIZE * batchIndex , BATCH_SIZE * ( batchIndex + 0 ) , ) await Promise . all ( batchContactList . map ( c => c . ready ( ) . catch ( e => { log . error ( 's' , 's' , e . message ) invalidDict [ c . id ] = true } ) , ) , ) batchIndex ++ } return contactList . filter ( contact => ! invalidDict [ contact . id ] ) } catch ( e ) { log . error ( 's' , 's' , e . message ) return [ ] } } public static async delete ( contact ) < void > { log . verbose ( 's' , 's' , contact . id ) } protected payload ? : ContactPayload constructor ( public readonly id , ) { super ( ) log . silly ( 's' , `template` ) const MyClass = instanceToClass ( this , Contact ) if ( MyClass === Contact ) { throw new Error ( 's' + 's' , ) } if ( ! this . puppet ) { throw new Error ( 's' ) } } public toString ( ) { if ( ! this . payload ) { return this . constructor . name } const identity = this . payload . alias || this . payload . name || this . id || 's' return `template` } public async say ( text ) < void > public async say ( contact ) < void > public async say ( file ) < void > public async say ( mini ) < void > public async say ( url ) < void > public async say ( something : string | Contact | FileBox | MiniProgram | UrlLink ) < void > { log . verbose ( 's' , 's' , something ) if ( typeof something === 's' ) { await this . puppet . messageSendText ( { contactId : this . id , } , something ) } else if ( something instanceof Contact ) { await this . puppet . messageSendContact ( { contactId : this . id , } , something . id ) } else if ( something instanceof FileBox ) { await this . puppet . messageSendFile ( { contactId : this . id , } , something ) } else if ( something instanceof UrlLink ) { await this . puppet . messageSendUrl ( { contactId : this . id , } , something . payload ) } else if ( something instanceof MiniProgram ) { await this . puppet . messageSendMiniProgram ( { contactId : this . id , } , something . payload ) } else { throw new Error ( 's' + something ) } } public name ( ) { return ( this . payload && this . payload . name ) || 's' } public async alias ( ) < null | string > public async alias ( newAlias ) < void > public async alias ( empty ) < void > public async alias ( newAlias ? : null | string ) < null | string | void > { log . silly ( 's' , 's' , newAlias === undefined ? 's' : newAlias , ) if ( ! this . payload ) { throw new Error ( 's' ) } if ( typeof newAlias === 's' ) { return this . payload . alias || null } try { await this . puppet . contactAlias ( this . id , newAlias ) await this . puppet . contactPayloadDirty ( this . id ) this . payload = await this . puppet . contactPayload ( this . id ) if ( newAlias && newAlias !== this . payload . alias ) { log . warn ( 's' , 's' , newAlias , newAlias , this . payload . alias , ) } } catch ( e ) { log . error ( 's' , 's' , newAlias , e . message ) Raven . captureException ( e ) } } public stranger ( ) : null | boolean { log . warn ( 's' , 's' ) if ( ! this . payload ) return null return ! this . friend ( ) } public friend ( ) : null | boolean { log . verbose ( 's' , 's' ) if ( ! this . payload ) { return null } return this . payload . friend || null } public official ( ) { log . warn ( 's' , 's' ) return ! ! this . payload && ( this . payload . type === ContactType . Official ) } public personal ( ) { log . warn ( 's' , 's' ) return ! ! this . payload && this . payload . type === ContactType . Personal } public type ( ) { if ( ! this . payload ) { throw new Error ( 's' ) } return this . payload . type } public star ( ) : null | boolean { if ( ! this . payload ) { return null } return this . payload . star === undefined ? null : this . payload . star } public gender ( ) { return this . payload ? this . payload . gender : ContactGender . Unknown } public province ( ) : null | string { return ( this . payload && this . payload . province ) || null } public city ( ) : null | string { return ( this . payload && this . payload . city ) || null } public async avatar ( ) < FileBox > { log . verbose ( 's' , 's' ) try { const fileBox = await this . puppet . contactAvatar ( this . id ) return fileBox } catch ( e ) { log . error ( 's' , 's' , e . message ) return qrCodeForChatie ( ) } } public refresh ( ) < void > { log . warn ( 's' , 's' ) return this . sync ( ) } public async sync ( ) < void > { await this . ready ( true ) } public async ready ( forceSync = false , ) < void > { log . silly ( 's' , 's' , this . puppet ) if ( ! forceSync && this . isReady ( ) ) { log . silly ( 's' , 's' ) return } try { if ( forceSync ) { await this . puppet . contactPayloadDirty ( this . id ) } this . payload = await this . puppet . contactPayload ( this . id ) } catch ( e ) { log . verbose ( 's' , `template` , this , e . message , ) Raven . captureException ( e ) throw e } } public isReady ( ) { return ! ! ( this . payload && this . payload . name ) } public self ( ) { const userId = this . puppet . selfId ( ) if ( ! userId ) { return false } return this . id === userId } public weixin ( ) : null | string { return ( this . payload && this . payload . weixin ) || null } }	O O $any$ O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $complex$ O $SymbolConstructor$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O $complex$ O O $MapConstructor$ O O O $any$ O O O O $complex$ O O O O O O $complex$ O O O O O $complex$ O $Map$ O O O $any$ O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O O $complex$ O O $complex$ O O O $T["prototype"]$ O $any$ O O $any$ O O $T$ O $any$ O $string$ O O O $any$ O O O O O O O O O $complex$ O O $any$ O $any$ O O O O O $string$ O O O $complex$ O O $MapConstructor$ O O O $any$ O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O O O O $complex$ O $any$ O $complex$ O O O O $ErrorConstructor$ O O O O O $Contact$ O O O $complex$ O $Contact$ O $string$ O O O $Contact$ O O O $Contact$ O O $Contact$ O O O O O O O O $string$ O O $any$ O O $complex$ O $complex$ O $string$ O $Contact$ O O $Contact$ O O O O $Promise$ O $any$ O O $any$ O O $T$ O $any$ O $any$ O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O O O O $JSON$ O $complex$ O $any$ O O O $T["prototype"][]$ O O O O $Promise<T["prototype"][]>$ O $any$ O O O O $T["prototype"][]$ O O O O O O O $T["prototype"][]$ O $number$ O O O O O O O O O $T["prototype"][]$ O $number$ O O O O $any$ O $any$ O O O O O $T["prototype"][]$ O $number$ O O O $number$ O O O O $number$ O O O $number$ O $T["prototype"][]$ O $number$ O $number$ O O O O $T["prototype"]$ O $T["prototype"][]$ O $number$ O O $any$ O O O O $any$ O $any$ O $T["prototype"]$ O $string$ O O O $any$ O O $any$ O $any$ O O O O O $number$ O $T["prototype"]$ O $string$ O O O $T["prototype"]$ O O O $any$ O $any$ O O O O O $number$ O $T["prototype"]$ O $string$ O O O O $any$ O $any$ O O O O O $T["prototype"][]$ O $number$ O O O O O O O $Promise$ O $any$ O O $any$ O O $T$ O $any$ O $any$ O O O O $any$ O O O $ArrayConstructor$ O $any$ O O O O O O $any$ O $any$ O O O O O $JSON$ O $complex$ O $any$ O O O O O O O $string[]$ O O O O O O O O $any$ O $any$ O $any$ O O $T["prototype"][]$ O $string[]$ O $U[]$ O $string$ O O O $T["prototype"]$ O $string$ O O O O O O O $number$ O O O $complex$ O O O $string$ O O O O O O O O O $number$ O O O $T["prototype"][]$ O $number$ O O O $T["prototype"][]$ O $T["prototype"][]$ O $T["prototype"][]$ O O O $number$ O O O O $number$ O O O O O O $PromiseConstructor$ O O O $T["prototype"][]$ O $U[]$ O $T["prototype"]$ O $T["prototype"]$ O $Promise<void>$ O O O $complex$ O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $complex$ O $T["prototype"]$ O $string$ O O O O O O O O O $number$ O O O $T["prototype"][]$ O $complex$ O $T["prototype"]$ O O $complex$ O $T["prototype"]$ O $string$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $Promise$ O $Contact$ O O O O O $any$ O $any$ O O O O O $Contact$ O $string$ O O O $any$ O O $any$ O O O O $string$ O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $string$ O O O O O O O O $any$ O O O O O $Function$ O $string$ O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $string$ O O O O O O O $Promise$ O $string$ O O O O O O $Promise$ O $Contact$ O O O O O O $Promise$ O $FileBox$ O O O O O O $Promise$ O $MiniProgram$ O O O O O O $Promise$ O $UrlLink$ O O O O O O $Promise$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $any$ O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $string$ O O O $string$ O O O $Contact$ O $string$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $string$ O O O $string$ O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $string$ O O O $string$ O O O $UrlLink$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $string$ O O O $string$ O O O $MiniProgram$ O $any$ O O O O O O $ErrorConstructor$ O O O $any$ O O O O $string$ O O O O O O O $any$ O O O $any$ O $any$ O O O O O O $Promise$ O O O O O O O O O $Promise$ O $string$ O O O O O O $Promise$ O $null$ O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O $any$ O $any$ O O O O O $string$ O $undefined$ O O O $string$ O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $string$ O O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $string$ O $string$ O O O O $any$ O $any$ O O O $string$ O O O $any$ O O O O $any$ O $any$ O O O $string$ O O O $string$ O $string$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O $string$ O $string$ O O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O O O O O $string$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $boolean$ O O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O $boolean$ O O O O $boolean$ O O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O O $boolean$ O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $boolean$ O O O $any$ O $any$ O O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $ContactType$ O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O O $boolean$ O O O O O O O O O O O O $any$ O O O O O O O O $any$ O $any$ O $undefined$ O O O O O $any$ O $any$ O O $ContactGender$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O O O O O $any$ O O O $any$ O $any$ O O O O O $string$ O O O O O O O O O O O $any$ O O O $any$ O $any$ O O O O O O $Promise$ O O O $any$ O O $any$ O $any$ O O O O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O $any$ O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O O $Promise<void>$ O O O O O $Promise$ O O O O O O O O O $Promise<void>$ O O O O O O $Promise$ O $boolean$ O O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O $boolean$ O O O $boolean$ O O O O $any$ O $any$ O O O O O O O O O O O $boolean$ O O O O O $any$ O $any$ O O O $string$ O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O O O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O $boolean$ O O O O O O O O O $any$ O O O $any$ O $any$ O O O $boolean$ O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O O O O O O O O $string$ O $any$ O O $string$ O O O O O O O O O O O $any$ O O O $any$ O $any$ O O O O O
import { FileBox } from 's' import { log , } from 's' import { Contact , } from 's' export class ContactSelf extends Contact { public async avatar ( ) < FileBox > public async avatar ( file ) < void > public async avatar ( file ? ) < void | FileBox > { log . verbose ( 's' , 's' , file ? file . name : 's' ) if ( ! file ) { const filebox = await super . avatar ( ) return filebox } if ( this . id !== this . puppet . selfId ( ) ) { throw new Error ( 's' ) } await this . puppet . contactAvatar ( this . id , file ) } public async qrcode ( ) < string > { log . verbose ( 's' , 's' ) let puppetId try { puppetId = this . puppet . selfId ( ) } catch ( e ) { throw Error ( 's' ) } if ( this . id !== puppetId ) { throw new Error ( 's' ) } const qrcodeValue = await this . puppet . contactSelfQrcode ( ) return qrcodeValue } public name ( ) public name ( name ) < void > public name ( name ? ) : string | Promise < void > { log . verbose ( 's' , 's' , name || 's' ) if ( typeof name === 's' ) { return super . name ( ) } let puppetId try { puppetId = this . puppet . selfId ( ) } catch ( e ) { throw Error ( 's' ) } if ( this . id !== puppetId ) { throw new Error ( 's' ) } return this . puppet . contactSelfName ( name ) . then ( this . sync . bind ( this ) ) } public async signature ( signature ) < void > { log . verbose ( 's' , 's' ) let puppetId try { puppetId = this . puppet . selfId ( ) } catch ( e ) { throw Error ( 's' ) } if ( this . id !== puppetId ) { throw new Error ( 's' ) } return this . puppet . contactSelfSignature ( signature ) . then ( this . sync . bind ( this ) ) } }	O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O $Promise$ O O O $any$ O O O $Promise$ O $FileBox$ O O O O O O $Promise$ O $any$ $FileBox$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O O O O $Promise<any>$ O O O $any$ O O O O O $string$ O O O $any$ O $any$ O O O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O O O $string$ O $any$ O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O $string$ O O $string$ O O O $any$ O $any$ O O O O O $any$ O O O $ErrorConstructor$ O O O O O O O O $string$ O $string$ O O O O $ErrorConstructor$ O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O $string$ O O O $complex$ O $Promise$ O O O O O $complex$ O $string$ $string$ O O O O $PromiseConstructor$ O O O O $any$ O $any$ O O O O O $string$ O O O O O O $string$ O O O O O O O $string$ O O O O $string$ O O $string$ O O O $any$ O $any$ O O O O O $any$ O O O $ErrorConstructor$ O O O O O O O O $string$ O $string$ O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O $string$ O O $any$ O O O $Promise<void>$ O $any$ O O O O O O O $Promise<void>$ O $Promise$ O O O O O $any$ O $any$ O O O O O O $string$ O O $string$ O O O $any$ O $any$ O O O O O $any$ O O O $ErrorConstructor$ O O O O O O O O $string$ O $string$ O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O $string$ O O $any$ O O O $Promise<void>$ O $any$ O O O O O O
export class Favorite { public static list ( ) : Favorite [ ] { return [ ] } constructor ( ) { } public tag ( ) { } }	O O $any$ O O O $Favorite[]$ O O O $any$ O O O O O O O O O O O O O $void$ O O O O O
import portfinder from 's' export async function getPort ( basePort ? , ) < number > { if ( basePort ) { portfinder . basePort = basePort } return portfinder . getPortPromise ( ) }	O $any$ O O O O O $Promise$ O $number$ $number$ O O O O O O O O $number$ O O $any$ O $any$ O $number$ O O $any$ O $any$ O O O
import cuid from 's' export function generateToken ( ) { const token = cuid ( ) . substr ( 0 ) + cuid ( ) . substr ( 0 ) return token . toUpperCase ( ) }	O $any$ O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O O O $any$ O O O $any$ O O O O $any$ O $any$ O O O
import promiseRetry from 's' import { OperationOptions } from 's' export async function tryWait < T > ( retryableFn : ( retry : ( error ) => never , attempt , ) => Promise < T > , ) < T > { const factor = 0 const minTimeout = 0 const maxTimeout = 0 * 0 const retries = 0 const retryOptions = { factor , maxTimeout , minTimeout , retries , } return promiseRetry ( retryOptions , retryableFn ) }	O $any$ O O O O $any$ O O O O O O $Promise$ O $any$ O O $Promise<T>$ O O $never$ O O $Error$ O O O O $number$ O O O $PromiseConstructor$ O $any$ O O O O $any$ O O O O O O O O O O O $number$ O O O O O O O O O $OperationOptions$ O O $number$ O $number$ O $number$ O $number$ O O O $any$ O $any$ O $Promise<T>$ O O
export function stripHtml ( html ? ) { if ( ! html ) { return 's' } return html . replace ( "s" , 's' ) } export function unescapeHtml ( str ? ) { if ( ! str ) { return 's' } return str . replace ( "s" , "s" ) . replace ( "s" , 's' ) . replace ( "s" , 's' ) . replace ( "s" , 's' ) . replace ( "s" , 's' ) } export function digestEmoji ( html ? ) { if ( ! html ) { return 's' } return html . replace ( "s" , 's' , ) . replace ( "s" , 's' , ) } export function unifyEmoji ( html ? ) { if ( ! html ) { return 's' } return html . replace ( "s" , 's' , ) . replace ( "s" , 's' , ) } export function stripEmoji ( html ? ) { if ( ! html ) { return 's' } return html . replace ( "s" , 's' , ) . replace ( "s" , 's' , ) } export function plainText ( html ? ) { if ( ! html ) { return 's' } return stripHtml ( unescapeHtml ( stripHtml ( digestEmoji ( html , ) , ) , ) , ) }	O O $string$ O $string$ $string$ O O O O O $string$ O O O O O O $string$ O $complex$ O O O O O O O O $string$ O $string$ $string$ O O O O O $string$ O O O O O O $string$ O $complex$ O O O O O O $complex$ O O O O O O $complex$ O O O O O O $complex$ O O O O O O $complex$ O O O O O O O O $string$ O $string$ $string$ O O O O O $string$ O O O O O O $string$ O $complex$ O O O O O O O $complex$ O O O O O O O O O $string$ O $string$ $string$ O O O O O $string$ O O O O O O $string$ O $complex$ O O O O O O O $complex$ O O O O O O O O O $string$ O $string$ $string$ O O O O O $string$ O O O O O O $string$ O $complex$ O O O O O O O $complex$ O O O O O O O O O $string$ O $string$ $string$ O O O O O $string$ O O O O O O $string$ O $string$ O $string$ O $string$ O $string$ O O O O O O O O O
export { getPort } from 's' export { generateToken } from 's' export { tryWait } from 's' export { digestEmoji , plainText , stripEmoji , stripHtml , unescapeHtml , unifyEmoji , } from 's'	O O $Promise<number>$ O O O O O $any$ O O O O O $Promise<T>$ O O O O O $string$ O $string$ O $string$ O $string$ O $string$ O $string$ O O O O
import { instanceToClass , } from 's' import { Accessory , } from 's' import { log , } from 's' import { tryWait , } from 's' import { FriendshipPayload , FriendshipType , } from 's' import { Acceptable , } from 's' import { Contact , } from 's' export class Friendship extends Accessory implements Acceptable { public static Type = FriendshipType public static load < T extends typeof Friendship > ( this : T , id , ) : T [ 's' ] { const newFriendship = new ( this as any ) ( id ) return newFriendship } public static async send ( contact , hello ) { log . warn ( 's' , 's' ) return this . add ( contact , hello ) } public static async add ( contact , hello , ) < void > { log . verbose ( 's' , 's' , contact . id , hello , ) await this . puppet . friendshipAdd ( contact . id , hello ) } public static async del ( contact , ) < void > { log . verbose ( 's' , 's' , contact . id ) throw new Error ( 's' ) } protected payload ? : FriendshipPayload constructor ( public readonly id , ) { super ( ) log . verbose ( 's' , 's' , id ) const MyClass = instanceToClass ( this , Friendship ) if ( MyClass === Friendship ) { throw new Error ( 's' ) } if ( ! this . puppet ) { throw new Error ( 's' ) } } public toString ( ) { if ( ! this . payload ) { return this . constructor . name } return [ 's' , FriendshipType [ this . payload . type ] , 's' , this . payload . contactId , 's' , ] . join ( 's' ) } public isReady ( ) { return ! ! this . payload && ( Object . keys ( this . payload ) . length > 0 ) } public async ready ( ) < void > { if ( this . isReady ( ) ) { return } this . payload = await this . puppet . friendshipPayload ( this . id ) if ( ! this . payload ) { throw new Error ( 's' ) } } public async accept ( ) < void > { log . verbose ( 's' , 's' ) if ( ! this . payload ) { throw new Error ( 's' ) } if ( this . payload . type !== Friendship . Type . Receive ) { throw new Error ( 's' + Friendship . Type [ this . payload . type ] ) } log . silly ( 's' , 's' , this . payload . contactId ) await this . puppet . friendshipAccept ( this . id ) const contact = this . contact ( ) await tryWait ( async ( retry , attempt ) => { log . silly ( 's' , 's' , attempt ) await contact . ready ( ) if ( contact . isReady ( ) ) { log . verbose ( 's' , 's' , contact . name ( ) ) return } retry ( new Error ( 's' ) ) } ) . catch ( ( e ) => { log . warn ( 's' , 's' , contact , ( e && e . message ) || e ) } ) await contact . sync ( ) } public hello ( ) { if ( ! this . payload ) { throw new Error ( 's' ) } return this . payload . hello || 's' } public contact ( ) { if ( ! this . payload ) { throw new Error ( 's' ) } const contact = this . wechaty . Contact . load ( this . payload . contactId ) return contact } public type ( ) { return this . payload ? this . payload . type : FriendshipType . Unknown } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $Promise<T>$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $T["prototype"]$ O $any$ O O $any$ O O $T$ O $any$ O $string$ O O O $any$ O O O O O $any$ O O O O O O O O $string$ O O $any$ O O O O $Promise<void>$ O $Contact$ O $string$ O O $any$ O $any$ O O O O O O O O $Promise<void>$ O $Contact$ O $string$ O O O O O $Promise$ O $Contact$ O $string$ O O O O O O $any$ O $any$ O O O O O $Contact$ O $string$ O $string$ O O O O O $any$ O $any$ O $Contact$ O $string$ O $string$ O O O O O $Promise$ O $Contact$ O O O O O O $any$ O $any$ O O O O O $Contact$ O $string$ O O O $ErrorConstructor$ O O O O O $any$ O O $any$ O O O O $string$ O O O O O O $any$ O $any$ O O O O O $string$ O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $string$ O O O O O O O O $any$ O O O O O $Function$ O $string$ O O O O O $any$ O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $string$ O O O O O $boolean$ O O O O O O O O $any$ O O $ObjectConstructor$ O $complex$ O O O $any$ O O $number$ O O O O O O $Promise$ O O O O O O O O O O $boolean$ O O O O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $ErrorConstructor$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O $string$ O O $Contact$ O O O $Contact$ O O O $Promise<T>$ O O O $never$ O $number$ O O O $any$ O $any$ O O O O O $number$ O O $Contact$ O $Promise<void>$ O O O O $Contact$ O $boolean$ O O O O $any$ O $any$ O O O O O $Contact$ O $string$ O O O O O $never$ O O $ErrorConstructor$ O O O O O O O $complex$ O O $Error$ O O O $any$ O $any$ O O O O O $Contact$ O O $Error$ O $Error$ O $string$ O O $Error$ O O O O $Contact$ O $Promise<void>$ O O O O $string$ O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O O O O $Contact$ O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O $Contact$ O O O $Wechaty$ O $any$ O $T["prototype"]$ O O O $any$ O $any$ O O $Contact$ O O $FriendshipType$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O
import { instanceToClass , } from 's' import { Accessory , } from 's' import { log , } from 's' import { Acceptable , } from 's' import { Contact , } from 's' export class RoomInvitation extends Accessory implements Acceptable { public static load < T extends typeof RoomInvitation > ( this : T , id , ) : T [ 's' ] { const newRoomInvitation = new ( this as any ) ( id ) return newRoomInvitation } constructor ( public readonly id , ) { super ( ) log . verbose ( 's' , 's' , id ) const MyClass = instanceToClass ( this , RoomInvitation ) if ( MyClass === RoomInvitation ) { throw new Error ( 's' ) } if ( ! this . puppet ) { throw new Error ( 's' ) } } public toString ( ) { return [ 's' , this . id || 's' , ] . join ( 's' ) } public async toStringAsync ( ) < string > { const payload = await this . puppet . roomInvitationPayload ( this . id ) return [ 's' , this . id , 's' , payload . roomTopic , 's' , payload . inviterId , 's' , ] . join ( 's' ) } public async accept ( ) < void > { log . verbose ( 's' , 's' ) await this . puppet . roomInvitationAccept ( this . id ) const inviter = await this . inviter ( ) const topic = await this . topic ( ) try { await inviter . ready ( ) log . verbose ( 's' , 's' , topic , inviter , ) return } catch ( e ) { log . warn ( 's' , 's' , inviter , ( e && e . message ) || e , ) } } public async inviter ( ) < Contact > { log . verbose ( 's' , 's' ) const payload = await this . puppet . roomInvitationPayload ( this . id ) const inviter = this . wechaty . Contact . load ( payload . inviterId ) return inviter } public async topic ( ) < string > { const payload = await this . puppet . roomInvitationPayload ( this . id ) return payload . roomTopic } public async roomTopic ( ) < string > { return this . topic ( ) } public async roomMemberCount ( ) < number > { log . verbose ( 's' , 's' ) const payload = await this . puppet . roomInvitationPayload ( this . id ) return payload . roomMemberCount } public async roomMemberList ( ) < Contact [ ] > { log . verbose ( 's' , 's' ) const payload = await this . puppet . roomInvitationPayload ( this . id ) const contactIdList = payload . roomMemberIdList const contactList = contactIdList . map ( id => this . wechaty . Contact . load ( id ) , ) await Promise . all ( contactList . map ( c => c . ready ( ) , ) , ) return contactList } public async date ( ) < Date > { log . verbose ( 's' , 's' ) const payload = await this . puppet . roomInvitationPayload ( this . id ) return new Date ( 0 * payload . timestamp ) } public async age ( ) < number > { const recvDate = await this . date ( ) const ageMilliseconds = Date . now ( ) - recvDate . getTime ( ) const ageSeconds = Math . floor ( ageMilliseconds / 0 ) return ageSeconds } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O $T["prototype"]$ O $any$ O O $any$ O O $T$ O $any$ O $string$ O O O $any$ O O O O O $any$ O O O O O O O O $string$ O O $any$ O O O O O $string$ O O O O O O $any$ O $any$ O O O O O $string$ O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $string$ O O O O O O O O O $string$ O O O O O $string$ O O O O O O $Promise$ O O O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O O O O O O $string$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $string$ O O O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $string$ O O $Contact$ O O O O $Promise<Contact>$ O O O $string$ O O O O $Promise<string>$ O O O O O $Contact$ O $Promise<void>$ O O $any$ O $any$ O O O O O $string$ O $Contact$ O O O O O O $any$ O O $any$ O $any$ O O O O O $Contact$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O $Promise$ O O O $any$ O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O $Contact$ O O O $Wechaty$ O $any$ O $T["prototype"]$ O $any$ O $any$ O O $Contact$ O O O $Promise$ O O O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O $any$ O $any$ O O O $Promise$ O O O O O O O O O $Promise<string>$ O O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O $any$ O $any$ O O O $Promise$ O O O $any$ O O O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $Wechaty$ O $any$ O $T["prototype"]$ O $any$ O O O O $PromiseConstructor$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O $Promise$ O O O $DateConstructor$ O O $any$ O $any$ O O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O O $DateConstructor$ O O O $any$ O $any$ O O O O $Promise$ O O O O O O O $Date$ O O O O $Promise<Date>$ O O O $number$ O $DateConstructor$ O $number$ O O O $Date$ O $number$ O O O $number$ O $Math$ O $number$ O $number$ O O O O $number$ O O
import { instanceToClass , } from 's' import { FileBox , } from 's' import { MessagePayload , MessageQueryFilter , MessageType , } from 's' import { Accessory , } from 's' import { AT_SEPRATOR_REGEX , log , Raven , } from 's' import { Sayable , } from 's' import { Contact , } from 's' import { Room , } from 's' import { UrlLink , } from 's' import { MiniProgram , } from 's' export interface MessageUserQueryFilter { from ? : Contact , text ? : string | RegExp room ? : Room type ? : MessageType to ? : Contact } export class Message extends Accessory implements Sayable { public static readonly Type = MessageType public static async find < T extends typeof Message > ( this : T , userQuery : string | MessageUserQueryFilter , ) < T [ 's' ] | null > { log . verbose ( 's' , 's' , JSON . stringify ( userQuery ) ) if ( typeof userQuery === 's' ) { userQuery = { text : userQuery } } const messageList = await this . findAll ( userQuery ) if ( messageList . length < 0 ) { return null } if ( messageList . length > 0 ) { log . warn ( 's' , 's' , messageList . length ) } return messageList [ 0 ] } public static async findAll < T extends typeof Message > ( this : T , userQuery ? , ) < Array < T [ 's' ] > > { log . verbose ( 's' , 's' , JSON . stringify ( userQuery ) || 's' ) let puppetQuery : undefined | MessageQueryFilter if ( userQuery ) { puppetQuery = { fromId : userQuery . from && userQuery . from . id , roomId : userQuery . room && userQuery . room . id , text : userQuery . text , toId : userQuery . to && userQuery . to . id , type : userQuery . type , } } const invalidDict : { [ id ] : true } = { } try { const MessageIdList = await this . puppet . messageSearch ( puppetQuery ) const messageList = MessageIdList . map ( id => this . load ( id ) ) await Promise . all ( messageList . map ( message => message . ready ( ) . catch ( e => { log . warn ( 's' , 's' , e ) invalidDict [ message . id ] = true } ) ) , ) return messageList . filter ( message => ! invalidDict [ message . id ] ) } catch ( e ) { log . warn ( 's' , 's' , e . message ) console . error ( e ) Raven . captureException ( e ) return [ ] } } public static load ( id ) { log . verbose ( 's' , 's' , id ) const msg = new this ( id ) return msg } public static create ( id ) { log . warn ( 's' , 's' , id ) return this . load ( id ) } protected payload ? : MessagePayload constructor ( public readonly id , ) { super ( ) log . verbose ( 's' , 's' , id || 's' , this . constructor . name , ) const MyClass = instanceToClass ( this , Message ) if ( MyClass === Message ) { throw new Error ( 's' ) } if ( ! this . puppet ) { throw new Error ( 's' ) } } public toString ( ) { if ( ! this . payload ) { return this . constructor . name } const msgStrList = [ 's' , `template` , 's' , this . from ( ) ? 's' + this . from ( ) : 's' , this . room ( ) ? 's' + this . room ( ) : 's' , 's' , ] if ( this . type ( ) === Message . Type . Text || this . type ( ) === Message . Type . Unknown ) { msgStrList . push ( `template` ) } else { log . silly ( 's' , 's' , Message . Type [ this . type ( ) ] , this . type ( ) ) if ( ! this . payload ) { throw new Error ( 's' ) } } return msgStrList . join ( 's' ) } public from ( ) : null | Contact { if ( ! this . payload ) { throw new Error ( 's' ) } const fromId = this . payload . fromId if ( ! fromId ) { return null } const from = this . wechaty . Contact . load ( fromId ) return from } public to ( ) : null | Contact { if ( ! this . payload ) { throw new Error ( 's' ) } const toId = this . payload . toId if ( ! toId ) { return null } const to = this . wechaty . Contact . load ( toId ) return to } public room ( ) : null | Room { if ( ! this . payload ) { throw new Error ( 's' ) } const roomId = this . payload . roomId if ( ! roomId ) { return null } const room = this . wechaty . Room . load ( roomId ) return room } public content ( ) { log . warn ( 's' , 's' ) return this . text ( ) } public text ( ) { if ( ! this . payload ) { throw new Error ( 's' ) } return this . payload . text || 's' } public async toRecalled ( ) < Message | null > { if ( this . type ( ) !== MessageType . Recalled ) { throw new Error ( 's' ) } const originalMessageId = this . text ( ) if ( ! originalMessageId ) { throw new Error ( 's' ) } try { const message = this . wechaty . Message . load ( originalMessageId ) await message . ready ( ) return message } catch ( e ) { log . verbose ( `template` ) return null } } public async say ( text , mention ? : Contact | Contact [ ] ) < void > public async say ( contact ) < void > public async say ( file ) < void > public async say ( url ) < void > public async say ( mini ) < void > public async say ( ... args : never [ ] ) < never > public async say ( textOrContactOrFileOrUrlOrMini : string | Contact | FileBox | UrlLink | MiniProgram , ) < void > { log . verbose ( 's' , 's' , textOrContactOrFileOrUrlOrMini ) const from = this . from ( ) const room = this . room ( ) if ( typeof textOrContactOrFileOrUrlOrMini === 's' ) { await this . puppet . messageSendText ( { contactId : ( from && from . id ) || undefined , roomId : ( room && room . id ) || undefined , } , textOrContactOrFileOrUrlOrMini ) } else if ( textOrContactOrFileOrUrlOrMini instanceof Contact ) { await this . puppet . messageSendContact ( { contactId : ( from && from . id ) || undefined , roomId : ( room && room . id ) || undefined , } , textOrContactOrFileOrUrlOrMini . id ) } else if ( textOrContactOrFileOrUrlOrMini instanceof FileBox ) { await this . puppet . messageSendFile ( { contactId : ( from && from . id ) || undefined , roomId : ( room && room . id ) || undefined , } , textOrContactOrFileOrUrlOrMini ) } else if ( textOrContactOrFileOrUrlOrMini instanceof UrlLink ) { await this . puppet . messageSendUrl ( { contactId : ( from && from . id ) || undefined , roomId : ( room && room . id ) || undefined , } , textOrContactOrFileOrUrlOrMini . payload ) } else if ( textOrContactOrFileOrUrlOrMini instanceof MiniProgram ) { await this . puppet . messageSendMiniProgram ( { contactId : ( from && from . id ) || undefined , roomId : ( room && room . id ) || undefined , } , textOrContactOrFileOrUrlOrMini . payload ) } else { throw new Error ( 's' + textOrContactOrFileOrUrlOrMini ) } } public type ( ) { if ( ! this . payload ) { throw new Error ( 's' ) } return this . payload . type || MessageType . Unknown } public self ( ) { const userId = this . puppet . selfId ( ) const from = this . from ( ) return ! ! from && from . id === userId } public async mention ( ) < Contact [ ] > { log . verbose ( 's' , 's' ) const room = this . room ( ) if ( this . type ( ) !== MessageType . Text || ! room ) { return [ ] } if ( this . payload && this . payload . mentionIdList ) { return Promise . all ( this . payload . mentionIdList . map ( async id => { const contact = this . wechaty . Contact . load ( id ) await contact . ready ( ) return contact } ) ) } const AT_SEPRATOR = AT_SEPRATOR_REGEX const atList = this . text ( ) . split ( AT_SEPRATOR ) if ( atList . length === 0 ) return [ ] const rawMentionList = atList . filter ( str => str . includes ( 's' ) ) . map ( str => multipleAt ( str ) ) function multipleAt ( str ) { str = str . replace ( "s" , 's' ) let name = 's' const nameList : string [ ] = [ ] str . split ( 's' ) . filter ( mentionName => ! ! mentionName ) . reverse ( ) . forEach ( mentionName => { name = mentionName + 's' + name nameList . push ( name . slice ( 0 , - 0 ) ) } ) return nameList } let mentionNameList : string [ ] = [ ] mentionNameList = mentionNameList . concat . apply ( [ ] , rawMentionList ) mentionNameList = mentionNameList . filter ( s => ! ! s ) log . verbose ( 's' , 's' , this . text ( ) , JSON . stringify ( mentionNameList ) , ) const contactListNested = await Promise . all ( mentionNameList . map ( name => room . memberAll ( name ) , ) , ) let contactList : Contact [ ] = [ ] contactList = contactList . concat . apply ( [ ] , contactListNested ) if ( contactList . length === 0 ) { log . silly ( 's' , `template` ) } return contactList } public async mentioned ( ) < Contact [ ] > { log . warn ( 's' , 's' ) return this . mention ( ) } public async mentionSelf ( ) < boolean > { const selfId = this . puppet . selfId ( ) const mentionList = await this . mention ( ) return mentionList . some ( contact => contact . id === selfId ) } public isReady ( ) { return ! ! this . payload } public async ready ( ) < void > { log . verbose ( 's' , 's' ) if ( this . isReady ( ) ) { return } this . payload = await this . puppet . messagePayload ( this . id ) if ( ! this . payload ) { throw new Error ( 's' ) } const fromId = this . payload . fromId const roomId = this . payload . roomId const toId = this . payload . toId if ( roomId ) { await this . wechaty . Room . load ( roomId ) . ready ( ) } if ( fromId ) { await this . wechaty . Contact . load ( fromId ) . ready ( ) } if ( toId ) { await this . wechaty . Contact . load ( toId ) . ready ( ) } } public async forward ( to : Room | Contact ) < void > { log . verbose ( 's' , 's' , to ) let roomId let contactId if ( to instanceof Room ) { roomId = to . id } else if ( to instanceof Contact ) { contactId = to . id } try { await this . puppet . messageForward ( { contactId , roomId , } , this . id , ) } catch ( e ) { log . error ( 's' , 's' , to , e ) throw e } } public date ( ) { if ( ! this . payload ) { throw new Error ( 's' ) } return new Date ( 0 * this . payload . timestamp ) } public age ( ) { const ageMilliseconds = Date . now ( ) - this . date ( ) . getTime ( ) const ageSeconds = Math . floor ( ageMilliseconds / 0 ) return ageSeconds } public async file ( ) < FileBox > { log . warn ( 's' , 's' ) return this . toFileBox ( ) } public async toFileBox ( ) < FileBox > { if ( this . type ( ) === Message . Type . Text ) { throw new Error ( 's' ) } const fileBox = await this . puppet . messageFile ( this . id ) return fileBox } public async toContact ( ) < Contact > { log . warn ( 's' , 's' ) if ( this . type ( ) === Message . Type . Contact ) { throw new Error ( 's' ) } const contact = this . wechaty . userSelf ( ) return contact } public async toUrlLink ( ) < UrlLink > { log . verbose ( 's' , 's' ) if ( ! this . payload ) { throw new Error ( 's' ) } if ( this . type ( ) !== Message . Type . Url ) { throw new Error ( 's' ) } const urlPayload = await this . puppet . messageUrl ( this . id ) if ( ! urlPayload ) { throw new Error ( `template` ) } return new UrlLink ( urlPayload ) } public async toMiniProgram ( ) < MiniProgram > { log . verbose ( 's' , 's' ) if ( ! this . payload ) { throw new Error ( 's' ) } if ( this . type ( ) !== Message . Type . MiniProgram ) { throw new Error ( 's' ) } const miniProgramPayload = await this . puppet . messageMiniProgram ( this . id ) if ( ! miniProgramPayload ) { throw new Error ( `template` ) } return new MiniProgram ( miniProgramPayload ) } }	O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $RegExp$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $Contact$ O O $any$ O $complex$ O O O O $RegExpConstructor$ $Room$ O O $any$ $any$ O O $any$ $Contact$ O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $Promise$ O $any$ O O $any$ O O $T$ O $any$ O $complex$ O O O $any$ O O O $any$ O O O O O O O $any$ O $any$ O O O O O $JSON$ O $complex$ O $complex$ O O O O O $complex$ O O O O $complex$ O O $string$ O $string$ O O O $T["prototype"][]$ O O O O $Promise<T["prototype"][]>$ O $MessageUserQueryFilter$ O O O $T["prototype"][]$ O $number$ O O O O O O O O O $T["prototype"][]$ O $number$ O O O O $any$ O $any$ O O O O O $T["prototype"][]$ O $number$ O O O $T["prototype"][]$ O O O O O O O $Promise$ O $any$ O O $any$ O O $T$ O $any$ O $MessageUserQueryFilter$ $MessageUserQueryFilter$ O O O $ArrayConstructor$ O $any$ O O O O O O $any$ O $any$ O O O O O $JSON$ O $complex$ O $MessageUserQueryFilter$ O O O O O $any$ O O O $any$ O O $MessageUserQueryFilter$ O O $any$ O O $string$ O $MessageUserQueryFilter$ O $Contact$ O $MessageUserQueryFilter$ O $Contact$ O $string$ O $string$ O $MessageUserQueryFilter$ O $Room$ O $MessageUserQueryFilter$ O $Room$ O $string$ O $complex$ O $MessageUserQueryFilter$ O $complex$ O $string$ O $MessageUserQueryFilter$ O $Contact$ O $MessageUserQueryFilter$ O $Contact$ O $string$ O $any$ O $MessageUserQueryFilter$ O $any$ O O O O $complex$ O O O $string$ O O O O O O O O O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $Message$ O $any$ O O O $PromiseConstructor$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O $complex$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O $complex$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $Console$ O $void$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $Message$ O $string$ O O $any$ O $any$ O O O O O $string$ O O $Message$ O O O O $string$ O O $Message$ O O O $Message$ O $string$ O O $any$ O $any$ O O O O O $string$ O O O O $Message$ O $string$ O O O $any$ O O $any$ O O O O $string$ O O O O O O $any$ O $any$ O O O O O $string$ O O O O O $Function$ O $string$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $string$ O O O O O O O O $any$ O O O O O $Function$ O $string$ O O $string[]$ O O O O O O O O O O $Contact$ O O O O O O O $Contact$ O O O O O O O $Room$ O O O O O O O $Room$ O O O O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O $string[]$ O $number$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O O O $any$ O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $string[]$ O $string$ O O O O O $Contact$ O O O O O $any$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O $Contact$ O O O $Wechaty$ O $any$ O $T["prototype"]$ O $any$ O O $Contact$ O O $Contact$ O O O O O $any$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O $Contact$ O O O $Wechaty$ O $any$ O $T["prototype"]$ O $any$ O O $Contact$ O O $Room$ O O O O O $any$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O $any$ O O O $any$ O $any$ O O O $any$ O O O O O O $Room$ O O O $Wechaty$ O $any$ O $T["prototype"]$ O $any$ O O $Room$ O O $string$ O O O $any$ O $any$ O O O O O O O O $string$ O O O O $string$ O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O O O O O $Promise$ O O O $any$ O O O O O O O O $any$ O O O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O $string$ O O O $string$ O O O O O $string$ O O O O $ErrorConstructor$ O O O O O O O $Message$ O O O $Wechaty$ O $any$ O $Message$ O $string$ O O $Message$ O $Promise<void>$ O O O $Message$ O O O $any$ O O $any$ O $any$ O O O O O O O O O $Promise$ O $string$ O $complex$ O O $any$ O $any$ O O O O O O O O $Promise$ O $Contact$ O O O O O O $Promise$ O $FileBox$ O O O O O O $Promise$ O $UrlLink$ O O O O O O $Promise$ O $MiniProgram$ O O O O O O $Promise$ O O $never[]$ O O O O O O O O O O $Promise$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O $Contact$ O O O $Contact$ O O O $Room$ O O O $Room$ O O O O O $any$ O O O O O O O $any$ O $any$ O O $string$ O O $Contact$ O $Contact$ O $string$ O O $undefined$ O $string$ O O $Room$ O $Room$ O $string$ O O $undefined$ O O O $string$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $string$ O O $Contact$ O $Contact$ O $string$ O O $undefined$ O $string$ O O $Room$ O $Room$ O $string$ O O $undefined$ O O O $Contact$ O $string$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $string$ O O $Contact$ O $Contact$ O $string$ O O $undefined$ O $string$ O O $Room$ O $Room$ O $string$ O O $undefined$ O O O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $string$ O O $Contact$ O $Contact$ O $string$ O O $undefined$ O $string$ O O $Room$ O $Room$ O $string$ O O $undefined$ O O O $UrlLink$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $string$ O O $Contact$ O $Contact$ O $string$ O O $undefined$ O $string$ O O $Room$ O $Room$ O $string$ O O $undefined$ O O O $MiniProgram$ O $any$ O O O O O O $ErrorConstructor$ O O O $any$ O O O O $MessageType$ O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O $any$ O O O $any$ O $any$ O O O $Contact$ O O O $Contact$ O O O O O $Contact$ O $Contact$ O $string$ O $any$ O O O $Promise$ O O O $any$ O O O O $any$ O $any$ O O O O O O $Room$ O O O $Room$ O O O O O O $any$ O O O $any$ O $any$ O O $Room$ O O O O O O O O O O $any$ O O O $any$ O $any$ O O O $PromiseConstructor$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O $Contact$ O O O $Wechaty$ O $any$ O $T["prototype"]$ O $any$ O O $Contact$ O $Promise<void>$ O O O $Contact$ O O O O O $RegExp$ O $RegExp$ O $string[]$ O O O $string$ O O O $complex$ O $RegExp$ O O O $string[]$ O $number$ O O O O O O O $string[][]$ O $string[]$ O $complex$ O $string$ O $string$ O $boolean$ O O O O O $U[]$ O $string$ O $string[]$ O $string$ O O O $string[]$ O $string$ O O $string$ O $string$ O $complex$ O O O O O O $string$ O O O $string[]$ O O O O O O O $string$ O $complex$ O O O O $complex$ O $string$ O O O $string$ O O $string[]$ O O O $void$ O $string$ O O $string$ O $string$ O O O $string$ $string[]$ O $number$ O $string$ O $string$ O O O O O O O O O O $string[]$ O O $string[]$ O O O O O O O $string[]$ O $string[]$ O $complex$ O $any$ O O O O $string[][]$ O $string[]$ O $string[]$ O $complex$ O $string$ O O O $string$ O $any$ O $any$ O O O O O O O $string$ O O O $JSON$ O $complex$ O $string[]$ O O O O $Contact[][]$ O O $PromiseConstructor$ O O O $string[]$ O $U[]$ O $string$ O $Room$ O $complex$ O $string$ O O O O O O $Contact[]$ O $any$ O O O O O $Contact[]$ O $Contact[]$ O $complex$ O $any$ O O O O $Contact[][]$ O O O $Contact[]$ O $number$ O O O O $any$ O $any$ O O O O O O O $Contact[]$ O O O $Promise$ O O O $any$ O O O O $any$ O $any$ O O O O O O O O $Promise<Contact[]>$ O O O O O $Promise$ O O O O O O O $any$ O O O $any$ O $any$ O O O $Contact[]$ O O O O $Promise<Contact[]>$ O O O $Contact[]$ O $boolean$ O $Contact$ O $Contact$ O $string$ O $any$ O O O $boolean$ O O O O O O O O $any$ O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O O O $boolean$ O O O O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O $Wechaty$ O $any$ O $T["prototype"]$ O $any$ O O $Promise<void>$ O O O O O $any$ O O O O O $Wechaty$ O $any$ O $T["prototype"]$ O $any$ O O $Promise<void>$ O O O O O $any$ O O O O O $Wechaty$ O $any$ O $T["prototype"]$ O $any$ O O $Promise<void>$ O O O O O O $Promise$ O $complex$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $complex$ O O $any$ O $any$ O O $complex$ O $any$ O O $any$ O $Room$ O $string$ O O O O $Contact$ O $any$ O O $any$ O $Contact$ O $string$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $string$ O O O O O $any$ O O $any$ O $any$ O O O O O $complex$ O $any$ O O $any$ O O O $Date$ O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $DateConstructor$ O O O O O $any$ O $any$ O O O $number$ O O O O $number$ O $DateConstructor$ O $number$ O O O O O $Date$ O O O $number$ O O O $number$ O $Math$ O $number$ O $number$ O O O O $number$ O O O $Promise$ O O O $any$ O O $any$ O $any$ O O O O O O O O $Promise<any>$ O O O O O $Promise$ O O O $any$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O $any$ O O O $Promise$ O O O $any$ O O $any$ O $any$ O O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O $ContactSelf$ O O O $Wechaty$ O $ContactSelf$ O O O $ContactSelf$ O O O $Promise$ O O O $any$ O O $any$ O $any$ O O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O O O O $Promise$ O O O $any$ O O $any$ O $any$ O O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O $ErrorConstructor$ O O O O O $any$ O O O O $any$ O $any$ O O O $string$ O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O O O
import { Contact } from 's' export class Moment { public static post ( ) { } public static timeline ( contact ) : Moment [ ] { if ( contact ) { } return [ ] } constructor ( ) { } }	O O $any$ O O O O O $any$ O O O $void$ O O O O O O $Moment[]$ O $Contact$ O O $any$ O O O O O $Contact$ O O O O O O O O O O O O O
export class Money { constructor ( ) { } }	O O $any$ O O O O O O O
export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's' export * from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Contact , } from 's' export type AnyFunction = ( ... args : any [ ] ) => any export interface Sayable { say ( text , replyTo ? : Contact | Contact [ ] ) : Promise < void > } export interface Acceptable { accept : ( ) => Promise < void > }	O O $any$ O O O O O O $any$ O O O $any[]$ O O O O O O O O O $any$ O $Promise<void>$ O $string$ O $complex$ O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O O O $any$ O $Promise<void>$ O O O O $PromiseConstructor$ O O O O
import { StateSwitch } from 's' import WebSocket from 's' import { Message , } from 's' import { PuppetQrcodeScanEvent , } from 's' import { config , log , } from 's' import { AnyFunction , } from 's' import { Wechaty , } from 's' export interface IoOptions { wechaty : Wechaty , token : string , apihost ? : string , protocol ? : string , } export const IO_EVENT_DICT = { botie : 's' , error : 's' , heartbeat : 's' , login : 's' , logout : 's' , message : 's' , raw : 's' , reset : 's' , scan : 's' , shutdown : 's' , sys : 's' , update : 's' , } type IoEventName = keyof typeof IO_EVENT_DICT interface IoEventScan { name : 's' , payload : PuppetQrcodeScanEvent , } interface IoEventAny { name : IoEventName , payload : any , } type IoEvent = IoEventScan | IoEventAny export class Io { private readonly id : string private readonly protocol : string private eventBuffer : IoEvent [ ] = [ ] private ws : undefined | WebSocket private readonly state = new StateSwitch ( 's' , log ) private reconnectTimer ? : NodeJS . Timer private reconnectTimeout ? : number private lifeTimer ? : NodeJS . Timer private onMessage : undefined | AnyFunction private scanPayload ? : PuppetQrcodeScanEvent constructor ( private options , ) { options . apihost = options . apihost || config . apihost options . protocol = options . protocol || config . default . DEFAULT_PROTOCOL this . id = options . wechaty . id this . protocol = options . protocol + 's' + options . wechaty . id log . verbose ( 's' , 's' , options . apihost , options . token , options . protocol , this . id , ) } public toString ( ) { return `template` } private connected ( ) { return this . ws && this . ws . readyState === WebSocket . OPEN } public async start ( ) < void > { log . verbose ( 's' , 's' ) if ( this . lifeTimer ) { throw new Error ( 's' ) } this . state . on ( 's' ) try { this . initEventHook ( ) this . ws = await this . initWebSocket ( ) this . options . wechaty . on ( 's' , ( qrcode , status ) => { this . scanPayload = { ... this . scanPayload , qrcode , status , } } ) this . lifeTimer = setInterval ( ( ) => { if ( this . ws && this . connected ( ) ) { log . silly ( 's' , 's' ) this . ws . ping ( ) } } , 0 * 0 ) this . state . on ( true ) return } catch ( e ) { log . warn ( 's' , 's' , e . message ) this . state . off ( true ) throw e } } private initEventHook ( ) { log . verbose ( 's' , 's' ) const wechaty = this . options . wechaty wechaty . on ( 's' , error => this . send ( { name : 's' , payload : error } ) ) wechaty . on ( 's' , data => this . send ( { name : 's' , payload : { cuid : this . id , data } } ) ) wechaty . on ( 's' , user => this . send ( { name : 's' , payload : user } ) ) wechaty . on ( 's' , user => this . send ( { name : 's' , payload : user } ) ) wechaty . on ( 's' , message => this . ioMessage ( message ) ) wechaty . on ( 's' , ( qrcode , status ) => this . send ( { name : 's' , payload : { qrcode , status } } as IoEventScan ) ) } private async initWebSocket ( ) < WebSocket > { log . verbose ( 's' , 's' ) const auth = 's' + this . options . token const headers = { Authorization : auth } if ( ! this . options . apihost ) { throw new Error ( 's' ) } let endpoint = 's' + this . options . apihost + 's' if ( ! "s" . test ( this . options . apihost ) ) { endpoint = 's' + this . options . apihost + 's' } const ws = this . ws = new WebSocket ( endpoint , this . protocol , { headers } ) ws . on ( 's' , ( ) => this . wsOnOpen ( ws ) ) ws . on ( 's' , data => this . wsOnMessage ( data ) ) ws . on ( 's' , e => this . wsOnError ( e ) ) ws . on ( 's' , ( code , reason ) => this . wsOnClose ( ws , code , reason ) ) await new Promise ( ( resolve , reject ) => { ws . once ( 's' , resolve ) ws . once ( 's' , reject ) ws . once ( 's' , reject ) } ) return ws } private async wsOnOpen ( ws ) < void > { if ( this . protocol !== ws . protocol ) { log . error ( 's' , 's' , this . protocol ) } log . verbose ( 's' , 's' , ws . protocol ) this . reconnectTimeout = undefined const name = 's' const payload = 's' + this . options . wechaty . version ( ) + `template` const initEvent = { name , payload , } await this . send ( initEvent ) } private async wsOnMessage ( data : WebSocket . Data ) { log . silly ( 's' , 's' , data ) if ( typeof data !== 's' ) { throw new Error ( 's' ) } const ioEvent = { name : 's' , payload : data , } try { const obj = JSON . parse ( data ) ioEvent . name = obj . name ioEvent . payload = obj . payload } catch ( e ) { log . verbose ( 's' , 's' , data ) } switch ( ioEvent . name ) { case 's' : const payload = ioEvent . payload if ( payload . onMessage ) { const script = payload . script try { const fn = eval ( script ) if ( typeof fn === 's' ) { this . onMessage = fn } else { log . warn ( 's' , 's' ) } } catch ( e ) { log . warn ( 's' , 's' , e ) this . options . wechaty . emit ( 's' , e ) } } break case 's' : log . verbose ( 's' , 's' , ioEvent . payload ) await this . options . wechaty . reset ( ioEvent . payload ) break case 's' : log . info ( 's' , 's' , ioEvent . payload ) process . exit ( 0 ) break case 's' : log . verbose ( 's' , 's' , ioEvent . payload ) const wechaty = this . options . wechaty if ( wechaty . logonoff ( ) ) { const loginEvent = { name : 's' , payload : { id : wechaty . userSelf ( ) . id , name : wechaty . userSelf ( ) . name ( ) , } , } await this . send ( loginEvent ) } if ( this . scanPayload ) { const scanEvent = { name : 's' , payload : this . scanPayload , } await this . send ( scanEvent ) } break case 's' : break case 's' : log . info ( 's' , 's' , ioEvent . payload ) await this . options . wechaty . logout ( ) break default : log . warn ( 's' , 's' , ioEvent . name , ioEvent . payload ) break } } private wsOnError ( e ? ) { log . warn ( 's' , 's' , e && e . message ) if ( ! e ) { return } this . options . wechaty . emit ( 's' , e ) } private wsOnClose ( ws , code , message , ) { if ( this . state . on ( ) ) { log . warn ( 's' , 's' , code , message ) ws . close ( ) this . reconnect ( ) } } private reconnect ( ) { log . verbose ( 's' , 's' ) if ( this . state . off ( ) ) { log . warn ( 's' , 's' ) return } if ( this . connected ( ) ) { log . warn ( 's' , 's' ) return } if ( this . reconnectTimer ) { log . warn ( 's' , 's' ) return } if ( ! this . reconnectTimeout ) { this . reconnectTimeout = 0 } else if ( this . reconnectTimeout < 0 * 0 ) { this . reconnectTimeout *= 0 } log . warn ( 's' , 's' , Math . floor ( this . reconnectTimeout / 0 ) ) this . reconnectTimer = setTimeout ( async ( ) => { this . reconnectTimer = undefined await this . initWebSocket ( ) } , this . reconnectTimeout ) } private async send ( ioEvent ? ) < void > { if ( ! this . ws ) { throw new Error ( 's' ) } const ws = this . ws if ( ioEvent ) { log . silly ( 's' , 's' , JSON . stringify ( ioEvent ) ) this . eventBuffer . push ( ioEvent ) } else { log . silly ( 's' , 's' ) } if ( ! this . connected ( ) ) { log . verbose ( 's' , 's' , this . eventBuffer . length ) return } const list < Promise < any > > = [ ] while ( this . eventBuffer . length ) { const data = JSON . stringify ( this . eventBuffer . shift ( ) , ) const p = new Promise ( ( resolve , reject ) => ws . send ( data , ( err : undefined | Error ) => { if ( err ) { reject ( err ) } else { resolve ( ) } } , ) ) list . push ( p ) } try { await Promise . all ( list ) } catch ( e ) { log . error ( 's' , 's' , e . stack ) throw e } } public async stop ( ) < void > { log . verbose ( 's' , 's' ) if ( ! this . ws ) { throw new Error ( 's' ) } this . state . off ( 's' ) await this . send ( ) this . eventBuffer = [ ] if ( this . reconnectTimer ) { clearTimeout ( this . reconnectTimer ) this . reconnectTimer = undefined } if ( this . lifeTimer ) { clearInterval ( this . lifeTimer ) this . lifeTimer = undefined } this . ws . close ( ) await new Promise ( resolve => { if ( this . ws ) { this . ws . once ( 's' , resolve ) } else { resolve ( ) } } ) this . ws = undefined this . state . off ( true ) } private async ioMessage ( m ) < void > { log . silly ( 's' , 's' ) if ( typeof this . onMessage === 's' ) { await this . onMessage ( m ) } } }	O O $any$ O O O O $any$ O O O O $any$ O O O O O O $any$ O O O O O O $Config$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $Wechaty$ O $any$ O $string$ O O O $string$ O O O O $string$ O O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $any$ O O O $complex$ O $any$ O O O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O O $string$ O O O O $string$ O O O $IoEvent[]$ O $any$ O O O O O O $any$ O O O $any$ O O $any$ O O $any$ O O O $any$ O O $any$ O O $any$ O $any$ O $number$ O O O O $any$ O O $any$ O $any$ O $AnyFunction$ O O O $any$ O $any$ O O $any$ O O O $IoOptions$ O O O $IoOptions$ O $string$ O $IoOptions$ O $string$ O $Config$ O $any$ $IoOptions$ O $string$ O $IoOptions$ O $string$ O $Config$ O $DefaultSetting$ O $string$ O O $string$ O $IoOptions$ O $Wechaty$ O $string$ O O $string$ O $IoOptions$ O $string$ O O O $IoOptions$ O $Wechaty$ O $string$ $any$ O $any$ O O O O O $IoOptions$ O $string$ O $IoOptions$ O $string$ O $IoOptions$ O $string$ O O O $string$ O O O O $string$ O O O O O O O $boolean$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O O O O O O O $void$ O O O O $any$ O O O O $Promise<any>$ O O O O $IoOptions$ O $Wechaty$ O $complex$ O O O O $string$ O $any$ O O O O O $any$ O O O O O $any$ O $string$ O $any$ O O O O O O $any$ O $number$ O O O O O O O O O $any$ O O O $boolean$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O $void$ O O O $any$ O $any$ O O O O O O $Wechaty$ O O O $IoOptions$ O $Wechaty$ $Wechaty$ O $complex$ O O O $Error$ O O O $Promise<void>$ O O O O O O $Error$ O $Error$ O O O $Wechaty$ O $complex$ O O O $any$ O O O $Promise<void>$ O O O O O O $complex$ O O $string$ O O O $string$ O $any$ O O O O $Wechaty$ O $complex$ O O O $ContactSelf$ O O O $Promise<void>$ O O O O O O $ContactSelf$ O $ContactSelf$ O O O $Wechaty$ O $complex$ O O O $ContactSelf$ O O O $Promise<void>$ O O O O O O $ContactSelf$ O $ContactSelf$ O O O $Wechaty$ O $complex$ O O O $Message$ O O O $Promise<void>$ O $Message$ O O $Wechaty$ O $complex$ O O O O $string$ O $any$ O O O O $Promise<void>$ O O O O O O $complex$ O O $string$ O $any$ O O O $any$ O O O O O $Promise$ O O O $any$ O O $any$ O $any$ O O O O O O $string$ O O O O O $IoOptions$ O $string$ O $complex$ O O $string$ O $string$ O O O O O O $IoOptions$ O $string$ O O O O $ErrorConstructor$ O O O O O $string$ O O O O O $IoOptions$ O $string$ O O O O O O O $boolean$ O O O $IoOptions$ O $string$ O O O $string$ O O O O O $IoOptions$ O $string$ O O O O $any$ O O O $any$ O O $any$ O $string$ O O O $string$ O O $complex$ O O $any$ O $any$ O O O O O O O O $Promise<void>$ O $any$ O O $any$ O $any$ O O O $any$ O O O $Promise<void>$ O $any$ O O $any$ O $any$ O O O $any$ O O O $void$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O $void$ O $any$ O $any$ O $any$ O O O O $PromiseConstructor$ O O $void$ O $void$ O O O $any$ O $any$ O O O $void$ O $any$ O $any$ O O O $void$ O $any$ O $any$ O O O $void$ O O O O $any$ O O O $Promise$ O $WebSocket$ O O O O O O O O O $string$ O $any$ O $any$ O O $any$ O $any$ O O O O O O O $string$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O $number$ O $undefined$ O O O O O $string$ O O O O O $IoOptions$ O $Wechaty$ O $string$ O O O O O $IoEvent$ O O O O $string$ O O O O O $Promise<void>$ O $IoEventAny$ O O O O $Promise<void>$ O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O O O O $ErrorConstructor$ O O O O O $IoEvent$ O O O O O O $string$ O $string$ O O O O O $any$ O $JSON$ O $any$ O $string$ O $IoEventAny$ O O O $any$ O $any$ $IoEventAny$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O O O $string$ O O O O $IoEventAny$ O O O O O O O O $any$ O $IoEventAny$ O $any$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O $AnyFunction$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O O O $IoOptions$ O $Wechaty$ O $complex$ O O O $any$ O O O O O O O $any$ O $any$ O O O O O $IoEventAny$ O $any$ O O O O $IoOptions$ O $Wechaty$ O $Promise<void>$ O $IoEventAny$ O $any$ O O O O O $any$ O $any$ O O O O O $IoEventAny$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $IoEventAny$ O $any$ O O $Wechaty$ O O O $IoOptions$ O $Wechaty$ O O $Wechaty$ O $boolean$ O O O O O $IoEvent$ O O O O O O $complex$ O O $string$ O $Wechaty$ O $ContactSelf$ O O O $string$ O $string$ O $Wechaty$ O $ContactSelf$ O O O $complex$ O O O O O O O O O $Promise<void>$ O $IoEventAny$ O O O O O O $any$ O O O $IoEventScan$ O O O O O O $any$ O O O $any$ O O O O O $Promise<void>$ O $IoEventScan$ O O O O O O O O O O $any$ O $any$ O O O O O $IoEventAny$ O $any$ O O O O $IoOptions$ O $Wechaty$ O $Promise<void>$ O O O O O $any$ O $any$ O O O O O $IoEventAny$ O O O $IoEventAny$ O $any$ O O O O O $void$ O $Error$ $Error$ O O $any$ O $any$ O O O O O $Error$ O $Error$ O $string$ O O O O $Error$ O O O O O O $IoOptions$ O $Wechaty$ O $complex$ O O O $Error$ O O O $void$ O $WebSocket$ O $number$ O $string$ O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O $number$ O $string$ O $any$ O $any$ O O O O $void$ O O O O O $void$ O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O $boolean$ O O O O $any$ O $any$ O O O O O O O O O O O $any$ O O $any$ O $any$ O O O O O O O O O O O O $number$ O O O O $number$ O O O O O O O O $number$ O O O O O O O O $number$ O O O $any$ O $any$ O O O O O $Math$ O $number$ O O O $number$ O O O O O O $any$ O $number$ O O O O O O O O $any$ O $undefined$ O O O $Promise<any>$ O O O O O O $number$ O O O O $Promise$ O $IoEvent$ $IoEvent$ O O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O $any$ O O O $any$ O O $IoEvent$ O O $any$ O $any$ O O O O O $JSON$ O $complex$ O $IoEvent$ O O O O $IoEvent[]$ O $number$ O $IoEvent$ O O O O $any$ O $any$ O O O O O O O O O O O $boolean$ O O O O $any$ O $any$ O O O O O O O $IoEvent[]$ O $number$ O O O O $Array$ O $PromiseConstructor$ O O O O O O O O O O O $IoEvent[]$ O $number$ O O O $string$ O $JSON$ O $complex$ O O O $IoEvent[]$ O $IoEvent$ O O O O O $Promise<unknown>$ O O $PromiseConstructor$ O O $void$ O $void$ O O $any$ O $any$ O $string$ O O $Error$ O O O $ErrorConstructor$ O O O O O $Error$ O O $void$ O $Error$ O O O O $void$ O O O O O O O $Promise<any>[]$ O $number$ O $Promise<unknown>$ O O O O O $PromiseConstructor$ O O O $Promise<any>[]$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O O O O O O $Promise<void>$ O O O O $IoEvent[]$ O O O O O O O $any$ O O $void$ O O O $any$ O O O $any$ O $undefined$ O O O O O $any$ O O $void$ O O O $any$ O O O $any$ O $undefined$ O O O $any$ O $any$ O O O O $PromiseConstructor$ O $void$ O O O O O O $any$ O O O O $any$ O $any$ O O O $void$ O O O O $void$ O O O O O O O $any$ O $undefined$ O O $any$ O $any$ O O O O O O $Promise$ O $Message$ O O O O O $any$ O $any$ O O O O O O O O O O $AnyFunction$ O O O O O O O $AnyFunction$ O $Message$ O O O O
import cuid from 's' import os from 's' import { cloneClass , } from 's' import { FileBox , } from 's' import { callerResolve , hotImport , } from 's' import { MemoryCard , } from 's' import { StateSwitch , } from 's' import { CHAT_EVENT_DICT , Puppet , PUPPET_EVENT_DICT , PuppetEventName , PuppetOptions , ScanStatus , } from 's' import { Accessory , } from 's' import { config , isProduction , log , Raven , VERSION , } from 's' import { AnyFunction , Sayable , } from 's' import { Io , } from 's' import { PuppetModuleName , } from 's' import { PuppetManager , } from 's' import { Contact , ContactSelf , Friendship , Message , Room , RoomInvitation , UrlLink , MiniProgram , } from 's' export const WECHATY_EVENT_DICT = { ... CHAT_EVENT_DICT , dong : 's' , error : `template` , heartbeat : 's' , ready : 's' , start : 's' , stop : 's' , } export type WechatyEventName = keyof typeof WECHATY_EVENT_DICT export interface WechatyOptions { memory ? : MemoryCard , name ? : string , profile ? : null | string , puppet ? : PuppetModuleName | Puppet , puppetOptions ? : PuppetOptions , ioToken ? : string , } const PUPPET_MEMORY_NAME = 's' export class Wechaty extends Accessory implements Sayable { public static readonly VERSION = VERSION public readonly state : StateSwitch private readonly readyState : StateSwitch private static globalInstance : Wechaty private memory ? : MemoryCard private lifeTimer ? : NodeJS . Timer private io ? : Io public readonly id : string public readonly Contact : typeof Contact public readonly ContactSelf : typeof ContactSelf public readonly Friendship : typeof Friendship public readonly Message : typeof Message public readonly RoomInvitation : typeof RoomInvitation public readonly Room : typeof Room public readonly UrlLink : typeof UrlLink public readonly MiniProgram : typeof MiniProgram public static instance ( options ? , ) { if ( options && this . globalInstance ) { throw new Error ( 's' ) } if ( ! this . globalInstance ) { this . globalInstance = new Wechaty ( options ) } return this . globalInstance } constructor ( private options = { } , ) { super ( ) log . verbose ( 's' , 's' ) if ( ! options . name && options . profile ) { log . verbose ( 's' , 's' ) options . name = options . profile } this . memory = this . options . memory this . id = cuid ( ) this . state = new StateSwitch ( 's' , log ) this . readyState = new StateSwitch ( 's' , log ) this . Contact = cloneClass ( Contact ) this . ContactSelf = cloneClass ( ContactSelf ) this . Friendship = cloneClass ( Friendship ) this . Message = cloneClass ( Message ) this . Room = cloneClass ( Room ) this . RoomInvitation = cloneClass ( RoomInvitation ) this . UrlLink = UrlLink this . MiniProgram = MiniProgram } public toString ( ) { if ( ! this . options ) { return this . constructor . name } return [ 's' , this . id , `template` , `template` , ] . join ( 's' ) } public emit ( event : 's' , data ? ) public emit ( event : 's' , error ) public emit ( event : 's' , friendship ) public emit ( event : 's' , data ) public emit ( event : 's' | 's' , user ) public emit ( event : 's' , message ) public emit ( event : 's' ) public emit ( event : 's' , roomInvitation ) public emit ( event : 's' , room , inviteeList : Contact [ ] , inviter , date ) public emit ( event : 's' , room , leaverList : Contact [ ] , remover , date ) public emit ( event : 's' , room , newTopic , oldTopic , changer , date ) public emit ( event : 's' , qrcode , status , data ? ) public emit ( event : 's' | 's' ) public emit ( event , listener ) public emit ( event , ... args : any [ ] ) { return super . emit ( event , ... args ) } public on ( event : 's' , listener : string | ( ( this , data ? ) => void ) ) : this public on ( event : 's' , listener : string | ( ( this , error ) => void ) ) : this public on ( event : 's' , listener : string | ( ( this , friendship ) => void ) ) : this public on ( event : 's' , listener : string | ( ( this , data ) => void ) ) : this public on ( event : 's' | 's' , listener : string | ( ( this , user ) => void ) ) : this public on ( event : 's' , listener : string | ( ( this , message ) => void ) ) : this public on ( event : 's' , listener : string | ( ( this ) => void ) ) : this public on ( event : 's' , listener : string | ( ( this , roomInvitation ) => void ) ) : this public on ( event : 's' , listener : string | ( ( this , room , inviteeList : Contact [ ] , inviter , date ? ) => void ) ) : this public on ( event : 's' , listener : string | ( ( this , room , leaverList : Contact [ ] , remover ? , date ? ) => void ) ) : this public on ( event : 's' , listener : string | ( ( this , room , newTopic , oldTopic , changer , date ? ) => void ) ) : this public on ( event : 's' , listener : string | ( ( this , qrcode , status , data ? ) => void ) ) : this public on ( event : 's' | 's' , listener : string | ( ( this ) => void ) ) : this public on ( event , listener ) public on ( event , listener : string | ( ( ... args : any [ ] ) => any ) ) : this { log . verbose ( 's' , 's' , event , typeof listener === 's' ? listener : typeof listener , ) if ( event as any === 's' ) { log . warn ( 's' , `template` ) if ( typeof listener === 's' ) { const oldListener = listener listener = ( ... args : any [ ] ) => { log . warn ( 's' , `template` ) oldListener . apply ( this , args ) } } } if ( typeof listener === 's' ) { this . addListenerFunction ( event , listener ) } else { this . addListenerModuleFile ( event , listener ) } return this } private addListenerModuleFile ( event , modulePath ) { const absoluteFilename = callerResolve ( modulePath , __filename ) log . verbose ( 's' , 's' , absoluteFilename ) hotImport ( absoluteFilename ) . then ( ( func ) => super . on ( event , ( ... args : any [ ] ) => { try { func . apply ( this , args ) } catch ( e ) { log . error ( 's' , 's' , event , modulePath , e , ) this . emit ( 's' , e ) } } ) ) . catch ( e => { log . error ( 's' , 's' , event , modulePath , e , ) this . emit ( 's' , e ) } ) if ( isProduction ( ) ) { log . verbose ( 's' , 's' ) hotImport ( absoluteFilename , false ) . catch ( e => log . error ( 's' , 's' , e ) ) } } private addListenerFunction ( event , listener ) { log . verbose ( 's' , 's' , event ) super . on ( event , ( ... args : any [ ] ) => { try { listener . apply ( this , args ) } catch ( e ) { log . error ( 's' , 's' , event , e ) this . emit ( 's' , e ) } } ) } private async initPuppet ( ) < void > { log . verbose ( 's' , 's' , this . options . puppet || 's' ) let inited = false try { inited = ! ! this . puppet } catch ( e ) { inited = false } if ( inited ) { log . verbose ( 's' , 's' , this . options . puppet ) return } if ( ! this . memory ) { throw new Error ( 's' ) } const puppet = this . options . puppet || config . systemPuppetName ( ) const puppetMemory = this . memory . multiplex ( PUPPET_MEMORY_NAME ) const puppetInstance = await PuppetManager . resolve ( { puppet , puppetOptions : this . options . puppetOptions , } ) puppetInstance . setMemory ( puppetMemory ) this . initPuppetEventBridge ( puppetInstance ) this . initPuppetAccessory ( puppetInstance ) } protected initPuppetEventBridge ( puppet ) { log . verbose ( 's' , 's' , puppet ) const eventNameList : PuppetEventName [ ] = Object . keys ( PUPPET_EVENT_DICT ) as PuppetEventName [ ] for ( const eventName of eventNameList ) { log . verbose ( 's' , 's' , eventName ) switch ( eventName ) { case 's' : puppet . on ( 's' , data => { this . emit ( 's' , data ) } ) break case 's' : puppet . on ( 's' , error => { this . emit ( 's' , new Error ( error ) ) } ) break case 's' : puppet . on ( 's' , data => { this . emit ( 's' , data ) } ) break case 's' : puppet . on ( 's' , async friendshipId => { const friendship = this . Friendship . load ( friendshipId ) await friendship . ready ( ) this . emit ( 's' , friendship ) friendship . contact ( ) . emit ( 's' , friendship ) this . emit ( 's' as any , friendship as any ) } ) break case 's' : puppet . on ( 's' , async contactId => { const contact = this . ContactSelf . load ( contactId ) await contact . ready ( ) this . emit ( 's' , contact ) } ) break case 's' : puppet . on ( 's' , async contactId => { const contact = this . ContactSelf . load ( contactId ) await contact . ready ( ) this . emit ( 's' , contact ) } ) break case 's' : puppet . on ( 's' , async messageId => { const msg = this . Message . load ( messageId ) await msg . ready ( ) this . emit ( 's' , msg ) } ) break case 's' : puppet . on ( 's' , ( ) => { log . silly ( 's' , 's' ) this . emit ( 's' ) this . readyState . on ( true ) } ) break case 's' : puppet . on ( 's' , async roomInvitationId => { const roomInvitation = this . RoomInvitation . load ( roomInvitationId ) this . emit ( 's' , roomInvitation ) } ) break case 's' : puppet . on ( 's' , async ( roomId , inviteeIdList , inviterId , timestamp ) => { const room = this . Room . load ( roomId ) await room . sync ( ) const inviteeList = inviteeIdList . map ( id => this . Contact . load ( id ) ) await Promise . all ( inviteeList . map ( c => c . ready ( ) ) ) const inviter = this . Contact . load ( inviterId ) await inviter . ready ( ) const date = new Date ( timestamp ) this . emit ( 's' , room , inviteeList , inviter , date ) room . emit ( 's' , inviteeList , inviter , date ) } ) break case 's' : puppet . on ( 's' , async ( roomId , leaverIdList , removerId , timestamp ) => { const room = this . Room . load ( roomId ) await room . sync ( ) const leaverList = leaverIdList . map ( id => this . Contact . load ( id ) ) await Promise . all ( leaverList . map ( c => c . ready ( ) ) ) const remover = this . Contact . load ( removerId ) await remover . ready ( ) const date = new Date ( timestamp ) this . emit ( 's' , room , leaverList , remover , date ) room . emit ( 's' , leaverList , remover , date ) if ( leaverIdList . includes ( this . puppet . selfId ( ) ) ) { await this . puppet . roomPayloadDirty ( roomId ) await this . puppet . roomMemberPayloadDirty ( roomId ) } } ) break case 's' : puppet . on ( 's' , async ( roomId , newTopic , oldTopic , changerId , timestamp ) => { const room = this . Room . load ( roomId ) await room . sync ( ) const changer = this . Contact . load ( changerId ) await changer . ready ( ) const date = new Date ( timestamp ) this . emit ( 's' , room , newTopic , oldTopic , changer , date ) room . emit ( 's' , newTopic , oldTopic , changer , date ) } ) break case 's' : puppet . on ( 's' , async ( qrcode , status , data ) => { this . emit ( 's' , qrcode , status , data ) } ) break case 's' : break default : throw new Error ( 's' + eventName + 's' ) } } } protected initPuppetAccessory ( puppet ) { log . verbose ( 's' , 's' , puppet ) this . Contact . wechaty = this this . ContactSelf . wechaty = this this . Friendship . wechaty = this this . Message . wechaty = this this . Room . wechaty = this this . RoomInvitation . wechaty = this this . Contact . puppet = puppet this . ContactSelf . puppet = puppet this . Friendship . puppet = puppet this . Message . puppet = puppet this . Room . puppet = puppet this . RoomInvitation . puppet = puppet this . puppet = puppet } public async init ( ) < void > { log . warn ( 's' , 's' ) return this . start ( ) } public async start ( ) < void > { log . info ( 's' , 's' , this . options . puppet || config . systemPuppetName ( ) , this . options . name || 's' , this . version ( ) , ) log . verbose ( 's' , 's' , this . options . puppet ) log . verbose ( 's' , 's' , this . options . name ) log . verbose ( 's' , 's' , this . id ) if ( this . state . on ( ) ) { log . silly ( 's' , 's' ) await this . state . ready ( 's' ) log . silly ( 's' , 's' ) return } this . readyState . off ( true ) if ( this . lifeTimer ) { throw new Error ( 's' ) } this . state . on ( 's' ) try { if ( ! this . memory ) { this . memory = new MemoryCard ( this . options . name ) } try { await this . memory . load ( ) } catch ( e ) { log . silly ( 's' , 's' ) } await this . initPuppet ( ) await this . puppet . start ( ) if ( this . options . ioToken ) { this . io = new Io ( { token : this . options . ioToken , wechaty : this , } ) await this . io . start ( ) } } catch ( e ) { console . error ( e ) log . error ( 's' , 's' , e && e . message ) Raven . captureException ( e ) this . emit ( 's' , e ) try { await this . stop ( ) } catch ( e ) { log . error ( 's' , 's' , e && e . message ) Raven . captureException ( e ) this . emit ( 's' , e ) } return } this . on ( 's' , ( ) => this . memoryCheck ( ) ) this . lifeTimer = setInterval ( ( ) => { log . silly ( 's' , 's' ) } , 0 * 0 * 0 ) this . state . on ( true ) this . emit ( 's' ) } public async stop ( ) < void > { log . info ( 's' , 's' , this . options . puppet || config . systemPuppetName ( ) , this . version ( ) , ) if ( this . state . off ( ) ) { log . silly ( 's' , 's' ) await this . state . ready ( 's' ) log . silly ( 's' , 's' ) return } this . readyState . off ( true ) this . state . off ( 's' ) if ( this . lifeTimer ) { clearInterval ( this . lifeTimer ) this . lifeTimer = undefined } try { await this . puppet . stop ( ) } catch ( e ) { log . warn ( 's' , 's' , e . message ) } try { if ( this . io ) { await this . io . stop ( ) this . io = undefined } } catch ( e ) { log . error ( 's' , 's' , e . message ) Raven . captureException ( e ) this . emit ( 's' , e ) } this . state . off ( true ) this . emit ( 's' ) } public async ready ( ) < void > { log . verbose ( 's' , 's' ) return this . readyState . ready ( 's' ) . then ( ( ) => { return log . silly ( 's' , 's' ) } ) } public async logout ( ) < void > { log . verbose ( 's' , 's' ) try { await this . puppet . logout ( ) } catch ( e ) { log . error ( 's' , 's' , e . message ) Raven . captureException ( e ) throw e } } public logonoff ( ) { return this . puppet . logonoff ( ) } public self ( ) { log . warn ( 's' , 's' ) return this . userSelf ( ) } public userSelf ( ) { const userId = this . puppet . selfId ( ) const user = this . ContactSelf . load ( userId ) return user } public async say ( text ) < void > public async say ( contact ) < void > public async say ( file ) < void > public async say ( mini ) < void > public async say ( url ) < void > public async say ( ... args : never [ ] ) < never > public async say ( something : string | Contact | FileBox | MiniProgram | UrlLink ) < void > { log . verbose ( 's' , 's' , something ) await this . userSelf ( ) . say ( something as any ) } public static version ( forceNpm = false ) { if ( ! forceNpm ) { const revision = config . gitRevision ( ) if ( revision ) { return `template` } } return VERSION } public version ( forceNpm = false ) { return Wechaty . version ( forceNpm ) } public static async sleep ( millisecond ) < void > { await new Promise ( resolve => { setTimeout ( resolve , millisecond ) } ) } public ding ( data ? ) { log . silly ( 's' , 's' , data || 's' ) try { this . puppet . ding ( data ) } catch ( e ) { log . error ( 's' , 's' , e . message ) Raven . captureException ( e ) throw e } } private memoryCheck ( minMegabyte = 0 ) { const freeMegabyte = Math . floor ( os . freemem ( ) / 0 / 0 ) log . silly ( 's' , 's' , freeMegabyte , minMegabyte , ) if ( freeMegabyte < minMegabyte ) { const e = new Error ( `template` ) log . warn ( 's' , 's' , e . message ) this . emit ( 's' , e ) } } public async reset ( reason ? ) < void > { log . verbose ( 's' , 's' , reason || 's' ) await this . puppet . stop ( ) await this . puppet . start ( ) } public unref ( ) { log . verbose ( 's' , 's' ) if ( this . lifeTimer ) { this . lifeTimer . unref ( ) } this . puppet . unref ( ) } }	O $any$ O O O $any$ O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $Config$ O $boolean$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O $any$ O O O $any$ O O $any$ O $any$ O O $any$ O $string$ O O O O $string$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O $string$ O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O $Wechaty$ O $any$ O $any$ O O $any$ O $any$ O O $any$ O $any$ O $Io$ O O $any$ O O $string$ O O O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $Wechaty$ O $WechatyOptions$ $WechatyOptions$ O O O O O $WechatyOptions$ O O O $Wechaty$ O O O O $ErrorConstructor$ O O O O O O O O O $Wechaty$ O O O O $Wechaty$ O O $any$ O $WechatyOptions$ O O O O O $Wechaty$ O O O O $WechatyOptions$ O O O O O O O O O $any$ O $any$ O O O O O O O O $WechatyOptions$ O $string$ O $WechatyOptions$ O $string$ O O $any$ O $any$ O O O O O $WechatyOptions$ O $string$ O $WechatyOptions$ O $string$ O O O $any$ O O O $WechatyOptions$ O $any$ O O $string$ O $any$ O O O O $any$ O O $any$ O O O $any$ O O O $any$ O O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O $string$ O O O O O O O O $WechatyOptions$ O O O O O $Function$ O $string$ O O O O O O O $string$ O O O O O O O $string$ O O O O O $boolean$ O O O O O $string$ $string$ O O $boolean$ O O O O O $Error$ O O $boolean$ O O O O O $Friendship$ O O $boolean$ O O O O O $any$ O O $boolean$ O O O O O O O $ContactSelf$ O O $boolean$ O O O O O $Message$ O O $boolean$ O O O O O O $boolean$ O O O O O $RoomInvitation$ O O $boolean$ O O O O O $Room$ O $Contact[]$ O $any$ O O O $Contact$ O $Date$ O O $boolean$ O O O O O $Room$ O $Contact[]$ O $any$ O O O $Contact$ O $Date$ O O $boolean$ O O O O O $Room$ O $string$ O $string$ O $Contact$ O $Date$ O O $boolean$ O O O O O $string$ O $ScanStatus$ O $string$ $string$ O O $boolean$ O O O O O O O O $never$ O $never$ O $never$ O O $boolean$ O $WechatyEventName$ O O $any[]$ O O O O O O O O O $any$ O $complex$ O O $any[]$ O O O $complex$ O O O O O $void)$ O O O O O $Wechaty$ O $string$ $string$ O O O O O O O O $complex$ O O O O O $void)$ O O O O O $Wechaty$ O $Error$ O O O O O O O O $complex$ O O O O O $void)$ O O O O O $Wechaty$ O $Friendship$ O O O O O O O O $complex$ O O O O O $void)$ O O O O O $Wechaty$ O $any$ O O O O O O O O $complex$ O O O O O O O $void)$ O O O O O $Wechaty$ O $ContactSelf$ O O O O O O O O $complex$ O O O O O $void)$ O O O O O $Wechaty$ O $Message$ O O O O O O O O $complex$ O O O O O $void)$ O O O O O $Wechaty$ O O O O O O O O $complex$ O O O O O $void)$ O O O O O $Wechaty$ O $RoomInvitation$ O O O O O O O O $complex$ O O O O O $void)$ O O O O O $Wechaty$ O $Room$ O $Contact[]$ O $any$ O O O $Contact$ O $Date$ $Date$ O O O O O O O O $complex$ O O O O O $void)$ O O O O O $Wechaty$ O $Room$ O $Contact[]$ O $any$ O O O $Contact$ $Contact$ O $Date$ $Date$ O O O O O O O O $complex$ O O O O O $void)$ O O O O O $Wechaty$ O $Room$ O $string$ O $string$ O $Contact$ O $Date$ $Date$ O O O O O O O O $complex$ O O O O O $void)$ O O O O O $Wechaty$ O $string$ O $ScanStatus$ O $string$ $string$ O O O O O O O O $complex$ O O O O O O O $void)$ O O O O O $Wechaty$ O O O O O O O O $never$ O $never$ O $never$ O O $complex$ O $WechatyEventName$ O $any)$ O O O O O O $any[]$ O O O O O O O O O O O O $any$ O $any$ O O O O O $complex$ O O $any)$ O O O $string$ O O $any$ O O O O $complex$ O O O O O O $any$ O $any$ O O O O O O O O $any)$ O O O O O $any$ O $any$ $any)$ O O O $any[]$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any[]$ O O O O O O O $any)$ O O O O O O $void$ O $complex$ O $any$ O O O O O O $void$ O $complex$ O $string$ O O O O O O $void$ O $WechatyEventName$ O $string$ O O O $any$ O $any$ O $string$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O O $AnyFunction$ O O O O $any$ O $complex$ O O O $any[]$ O O O O O O O O O $AnyFunction$ O $any$ O O O $any[]$ O O O O $any$ O O $any$ O $any$ O O O O O $complex$ O $string$ O $any$ O O O O $complex$ O O O $any$ O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $complex$ O $string$ O $any$ O O O O $complex$ O O O $any$ O O O O O $boolean$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $void$ O $WechatyEventName$ O $AnyFunction$ O O $any$ O $any$ O O O O O $complex$ O O O $any$ O $complex$ O O O $any[]$ O O O O O O O O O $AnyFunction$ O $any$ O O O $any[]$ O O O O $any$ O O $any$ O $any$ O O O O O $complex$ O $any$ O O O $complex$ O O O $any$ O O O O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O $WechatyOptions$ O $any$ O O O O $boolean$ O O O O $boolean$ O O O O O $any$ O O O $any$ O O $boolean$ O O O O O $boolean$ O O $any$ O $any$ O O O O O O O $WechatyOptions$ O $any$ O O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O $any$ O O O $WechatyOptions$ O $any$ O $Config$ O O O O O $any$ O O O $any$ O $any$ O O O O $any$ O O $any$ O $Promise<any>$ O O $any$ O $any$ O O O $WechatyOptions$ O $any$ O O O $any$ O $any$ O $any$ O O O $void$ O $any$ O O O $void$ O $any$ O O O $void$ O $Puppet$ O O $any$ O $any$ O O O O O $any$ O O $any[]$ O $any$ O O O $ObjectConstructor$ O $complex$ O $any$ O O $any$ O O O O O $any$ O $any[]$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O $any$ O O O O $complex$ O O O $any$ O O O O O O O $any$ O $any$ O O O $any$ O O O O $complex$ O O O O $ErrorConstructor$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O O O O $complex$ O O O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O O O $Friendship$ O O O $any$ O $T["prototype"]$ O $any$ O O $Friendship$ O $Promise<void>$ O O O O $complex$ O O O $Friendship$ O $Friendship$ O $Contact$ O O O $any$ O O O $Friendship$ O O O $complex$ O O O O O $Friendship$ O O O O O O O O O $any$ O $any$ O O O O $any$ O O O $ContactSelf$ O O O $any$ O $T["prototype"]$ O $any$ O O $ContactSelf$ O $Promise<void>$ O O O O $complex$ O O O $ContactSelf$ O O O O O O O $any$ O $any$ O O O O $any$ O O O $ContactSelf$ O O O $any$ O $T["prototype"]$ O $any$ O O $ContactSelf$ O $Promise<void>$ O O O O $complex$ O O O $ContactSelf$ O O O O O O O $any$ O $any$ O O O O $any$ O O O $Message$ O O O $any$ O $Message$ O $any$ O O $Message$ O $Promise<void>$ O O O O $complex$ O O O $Message$ O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O $complex$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O O O $RoomInvitation$ O O O $any$ O $T["prototype"]$ O $any$ O O O $complex$ O O O $RoomInvitation$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $Room$ O O O $any$ O $T["prototype"]$ O $any$ O O $Room$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $T["prototype"]$ O $any$ O O O $PromiseConstructor$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Contact$ O O O $any$ O $T["prototype"]$ O $any$ O O $Contact$ O $Promise<void>$ O O O $Date$ O O $DateConstructor$ O $any$ O O O $complex$ O O O $Room$ O $any$ O $Contact$ O $Date$ O $Room$ O $complex$ O O O $any$ O $Contact$ O $Date$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $Room$ O O O $any$ O $T["prototype"]$ O $any$ O O $Room$ O $Promise<void>$ O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $T["prototype"]$ O $any$ O O O $PromiseConstructor$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $Contact$ O O O $any$ O $T["prototype"]$ O $any$ O O $Contact$ O $Promise<void>$ O O O $Date$ O O $DateConstructor$ O $any$ O O O $complex$ O O O $Room$ O $any$ O $Contact$ O $Date$ O $Room$ O $complex$ O O O $any$ O $Contact$ O $Date$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $Room$ O O O $any$ O $T["prototype"]$ O $any$ O O $Room$ O $Promise<void>$ O O O $Contact$ O O O $any$ O $T["prototype"]$ O $any$ O O $Contact$ O $Promise<void>$ O O O $Date$ O O $DateConstructor$ O $any$ O O O $complex$ O O O $Room$ O $any$ O $any$ O $Contact$ O $Date$ O $Room$ O $complex$ O O O $any$ O $any$ O $Contact$ O $Date$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $complex$ O O O $any$ O $any$ O $any$ O O O O O O O O O O O O $ErrorConstructor$ O O O $any$ O O O O O O O $void$ O $Puppet$ O O $any$ O $any$ O O O O O $any$ O O O $any$ O $Wechaty$ O O O O $any$ O $Wechaty$ O O O O $any$ O $Wechaty$ O O O O $any$ O $Wechaty$ O O O O $any$ O $Wechaty$ O O O O $any$ O $Wechaty$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O O $Promise<void>$ O O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O $WechatyOptions$ O $any$ O $Config$ O O O O O O O $WechatyOptions$ O $string$ O O O O O $string$ O O O O $any$ O $any$ O O O O O O O $WechatyOptions$ O $any$ O $any$ O $any$ O O O O O O O $WechatyOptions$ O $string$ O $any$ O $any$ O O O O O O O $string$ O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O O O O $any$ O O $any$ O O O $WechatyOptions$ O $string$ O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O O O O O $Promise<void>$ O O O O O $any$ O $any$ O O O O O O $WechatyOptions$ O $string$ O O O O $Io$ O O $any$ O O $string$ O O O $WechatyOptions$ O $string$ O $this$ O O O O O O O O $Io$ O $Promise<void>$ O O O O O O $any$ O O $Console$ O $void$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O $any$ O O O O O O $Promise<void>$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O $any$ O O O O O O $complex$ O O O O O O O O $void$ O O O O O $any$ O $number$ O O O O O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O O $complex$ O O O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O $WechatyOptions$ O $any$ O $Config$ O O O O O O O $string$ O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O O $void$ O O O $any$ O O O $any$ O $undefined$ O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O $Io$ O O O O O $Io$ O $Promise<void>$ O O O O $Io$ O $undefined$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O $any$ O O O O $any$ O $any$ O O O O O $complex$ O O O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O O O O O O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $boolean$ O O O O O O $any$ O $any$ O O O O $Contact$ O O O $any$ O $any$ O O O O O O O O $ContactSelf$ O O O O $ContactSelf$ O O O O $any$ O O O $any$ O $any$ O O O $ContactSelf$ O O O $any$ O $T["prototype"]$ O $any$ O O $ContactSelf$ O O O $Promise$ O $string$ O O O O O O $Promise$ O $Contact$ O O O O O O $Promise$ O $FileBox$ O O O O O O $Promise$ O $MiniProgram$ O O O O O O $Promise$ O $UrlLink$ O O O O O O $Promise$ O O $never[]$ O O O O O O O O O O $Promise$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O O O $ContactSelf$ O O O $complex$ O $any$ O O O O O O $string$ O $boolean$ O O O O O O O $boolean$ O O O $string$ O $Config$ O $string$ O O O O $string$ O O O O O O O O O O $string$ O $boolean$ O O O O O $any$ O $string$ O $boolean$ O O O O O $Promise$ O $number$ O O O O O O O $PromiseConstructor$ O $void$ O O $number$ O $void$ O $number$ O O O O O $void$ O $string$ $string$ O O $any$ O $any$ O O O O O $string$ O O O O O O O $any$ O $any$ O $string$ O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $void$ O $number$ O O O O O $number$ O $Math$ O $number$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $number$ O $number$ O O O O $number$ O $number$ O O O $Error$ O O $ErrorConstructor$ O O O $any$ O $any$ O O O O O $Error$ O $string$ O O O $complex$ O O O $Error$ O O O O O $Promise$ O $string$ $string$ O O O O O $any$ O $any$ O O O O O $string$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $void$ O O O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O
import os from 's' import { config } from 's' import { Doctor } from 's' import { Wechaty } from 's' const wechaty = Wechaty . instance ( ) const doctor = new Doctor ( ) async function main ( ) { let ipcTestResult try { await doctor . testTcp ( ) ipcTestResult = 's' } catch ( err ) { console . info ( err ) ipcTestResult = 's' } console . info ( `template` ) } main ( ) . catch ( err => console . error ( 's' , err ) )	O $any$ O O O O $Config$ O O O O O $any$ O O O O O $any$ O O O O $Wechaty$ O $any$ O $Wechaty$ O O O $Doctor$ O O $any$ O O O O $Promise<void>$ O O O O $string$ O O O $Doctor$ O $Promise<boolean>$ O O $string$ O O O O O $any$ O O $Console$ O $void$ O $any$ O $string$ O O O $Console$ O $void$ O O O O $Promise<void>$ O O O $complex$ O $any$ O $Console$ O $void$ O O O $any$ O O
import { StateSwitch } from 's' import { Message } from 's' import { log , } from 's' import { Io } from 's' import { Wechaty } from 's' export interface IoClientOptions { token : string , wechaty : Wechaty , } export class IoClient { private io : Io private state : StateSwitch constructor ( public options , ) { log . verbose ( 's' , 's' , JSON . stringify ( options ) ) this . state = new StateSwitch ( 's' , log ) this . io = new Io ( { token : this . options . token , wechaty : this . options . wechaty , } ) } public async start ( ) < void > { log . verbose ( 's' , 's' ) if ( this . state . pending ( ) ) { log . warn ( 's' , 's' ) const e = new Error ( 's' ) throw e } this . state . on ( 's' ) try { await this . startIo ( ) await this . hookWechaty ( this . options . wechaty ) this . state . on ( true ) } catch ( e ) { log . error ( 's' , 's' , e . message ) this . state . off ( true ) throw e } } private async hookWechaty ( wechaty ) < void > { log . verbose ( 's' , 's' ) if ( this . state . off ( ) ) { const e = new Error ( 's' ) log . warn ( 's' , 's' , e . message ) throw e } wechaty . on ( 's' , user => log . info ( 's' , `template` ) ) . on ( 's' , user => log . info ( 's' , `template` ) ) . on ( 's' , ( url , code ) => log . info ( 's' , `template` ) ) . on ( 's' , msg => this . onMessage ( msg ) ) } private async startIo ( ) < void > { log . verbose ( 's' , 's' , this . options . token ) if ( this . state . off ( ) ) { const e = new Error ( 's' ) log . warn ( 's' , e . message ) throw e } try { await this . io . start ( ) } catch ( e ) { log . verbose ( 's' , 's' , e . message ) throw e } } private async onMessage ( msg ) { log . verbose ( 's' , 's' , msg ) } public async stop ( ) < void > { log . verbose ( 's' , 's' ) this . state . off ( 's' ) if ( ! this . io ) { log . warn ( 's' , 's' ) this . state . off ( true ) return } await this . io . stop ( ) this . state . off ( true ) } public async restart ( ) < void > { log . verbose ( 's' , 's' ) try { await this . stop ( ) await this . start ( ) } catch ( e ) { log . error ( 's' , 's' , e . message ) throw e } } public async quit ( ) < void > { log . verbose ( 's' , 's' ) if ( this . state . off ( ) === 's' ) { log . warn ( 's' , 's' ) throw new Error ( 's' ) } this . state . off ( 's' ) try { if ( this . options . wechaty ) { await this . options . wechaty . stop ( ) } else { log . warn ( 's' , 's' ) } if ( this . io ) { await this . io . stop ( ) } else { log . warn ( 's' , 's' ) } } catch ( e ) { log . error ( 's' , 's' , e . message ) throw e } finally { this . state . off ( true ) } } }	O O $any$ O O O O O $any$ O O O O O $any$ O O O O O O $any$ O O O O O $any$ O O O O O $any$ O $string$ O O O $Wechaty$ O $any$ O O O O $any$ O O $Io$ O $any$ O $any$ O $any$ O O O $IoClientOptions$ O O O $any$ O $any$ O O O O O $JSON$ O $complex$ O $IoClientOptions$ O O O O $any$ O O $any$ O O O $any$ O O O $Io$ O O $any$ O O $string$ O O O $IoClientOptions$ O $string$ O $Wechaty$ O O O $IoClientOptions$ O $Wechaty$ O O O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $Error$ O O $ErrorConstructor$ O O O O $Error$ O O O $any$ O $any$ O O O O O O O O $Promise<void>$ O O O O O $Promise<void>$ O O O $IoClientOptions$ O $Wechaty$ O O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $Promise$ O $Wechaty$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O $Error$ O O $ErrorConstructor$ O O O $any$ O $any$ O O O O O $Error$ O $string$ O O $Error$ O $Wechaty$ O $complex$ O O O $ContactSelf$ O $any$ O $any$ O O O O O O O $complex$ O O O $ContactSelf$ O $any$ O $any$ O O O O O O O $complex$ O O O O $string$ O $any$ O O $any$ O $any$ O O O O O O O $complex$ O O O $Message$ O O O $Promise<void>$ O $Message$ O O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O $IoClientOptions$ O $string$ O O O O O $any$ O $any$ O O O O O $Error$ O O $ErrorConstructor$ O O O $any$ O $any$ O O O $Error$ O $string$ O O $Error$ O O O O O O $Io$ O $Promise<void>$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O O $Promise<void>$ O $Message$ O O $any$ O $any$ O O O O O $Message$ O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $Io$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O O O $Io$ O $Promise<void>$ O O O O $any$ O $any$ O O O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O O O O $Promise<void>$ O O O O O $Promise<void>$ O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O O $Promise$ O O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $ErrorConstructor$ O O O O O O $any$ O $any$ O O O O O O O O O $IoClientOptions$ O $Wechaty$ O O O O O $IoClientOptions$ O $Wechaty$ O $Promise<void>$ O O O O O $any$ O $any$ O O O O O O O O O O $Io$ O O O O O $Io$ O $Promise<void>$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O O O O O O
import { config , log , } from 's' import { IoClient } from 's' import { Wechaty } from 's' const welcome = `template` let token = config . token if ( ! token ) { log . error ( 's' , 's' ) token = config . default . DEFAULT_TOKEN log . warn ( 's' , `template` ) } console . info ( welcome ) log . info ( 's' , 's' , token ) const client = new IoClient ( { token , wechaty : new Wechaty ( { name : token } ) , } ) client . start ( ) . catch ( onError . bind ( client ) ) async function onError ( this , e , ) { log . error ( 's' , 's' , e ) await this . quit ( ) process . exit ( - 0 ) }	O O $Config$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O O O O O $any$ O $Config$ O $any$ O O O $any$ O O $any$ O $any$ O O O O O $any$ O $Config$ O $DefaultSetting$ O $string$ $any$ O $any$ O O O O O O $Console$ O $void$ O O O $any$ O $any$ O O O O O $any$ O O $IoClient$ O O $any$ O O $any$ O $Wechaty$ O O $any$ O O $any$ O $any$ O O O O O $IoClient$ O $Promise<void>$ O O O $complex$ O $Promise<void>$ O $any$ O $IoClient$ O O O O $Promise<void>$ O $IoClient$ O $Error$ O O O $any$ O $any$ O O O O O $Error$ O O O O $Promise<void>$ O O $any$ O $any$ O O O O O
import { PuppetManager } from 's' PuppetManager . installAll ( ) . catch ( e => { console . error ( e ) process . exit ( 0 ) } )	O O $any$ O O O $any$ O $Promise<void>$ O O O $complex$ O $any$ O O $Console$ O $void$ O $any$ O $any$ O $any$ O O O O O
import { Wechaty } from 's' console . info ( Wechaty . version ( ) )	O O $any$ O O O $Console$ O $void$ O $any$ O $string$ O O O
export const WECHATY_DEPRECATED_HOLDER = 0	O O O O O
export { FileBox , } from 's' export { ScanStatus , } from 's' export { config , log , qrcodeValueToImageUrl , VERSION , } from 's' export { Wechaty , WechatyOptions , } from 's' export { PuppetModuleName , } from 's' export { Contact , Friendship , Favorite , Message , Moment , Money , Room , RoomInvitation , UrlLink , MiniProgram , } from 's' export { } from 's' export { IoClient } from 's'	O O $any$ O O O O O O $any$ O O O O O O $Config$ O $any$ O $string$ O O O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O $any$ O O O
import { Contact , Message , ScanStatus , Wechaty , } from 's' import { FileBox } from 's' import { generate } from 's' const bot = new Wechaty ( { name : 's' , } ) bot . on ( 's' , onLogout ) . on ( 's' , onLogin ) . on ( 's' , onScan ) . on ( 's' , onError ) . on ( 's' , onMessage ) bot . start ( ) . catch ( async e => { console . error ( 's' , e ) await bot . stop ( ) process . exit ( - 0 ) } ) function onScan ( qrcode , status ) { generate ( qrcode ) const qrcodeImageUrl = [ 's' , encodeURIComponent ( qrcode ) , ] . join ( 's' ) console . info ( 's' , ScanStatus [ status ] , status , qrcodeImageUrl ) } function onLogin ( user ) { console . info ( `template` ) bot . say ( 's' ) . catch ( console . error ) } function onLogout ( user ) { console . info ( `template` ) } function onError ( e ) { console . error ( 's' , e ) } async function onMessage ( msg ) { console . info ( msg . toString ( ) ) if ( msg . age ( ) > 0 * 0 ) { console . info ( 's' ) return } if ( msg . type ( ) !== bot . Message . Type . Text || ! "s" . test ( msg . text ( ) ) ) { console . info ( 's' ) return } await msg . say ( 's' ) console . info ( 's' ) const fileBox = FileBox . fromUrl ( 's' ) await msg . say ( fileBox ) console . info ( 's' , fileBox . toString ( ) ) await msg . say ( [ 's' , 's' , 's' , ] . join ( 's' ) ) } const welcome = `template` console . info ( welcome )	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O O $Wechaty$ O O $any$ O O $string$ O O O O O $Wechaty$ O $complex$ O O O $void$ O O $complex$ O O O $void$ O O $complex$ O O O $void$ O O $complex$ O O O $void$ O O $complex$ O O O $Promise<void>$ O $Wechaty$ O $Promise<void>$ O O O $complex$ O O $any$ O O $Console$ O $void$ O O O $any$ O O $Wechaty$ O $Promise<void>$ O O $any$ O $any$ O O O O O O O $void$ O $string$ O $ScanStatus$ O O $any$ O $string$ O O $string$ O O O O $string$ O $string$ O O O O $string$ O O O $Console$ O $void$ O O O $any$ O $any$ O O $any$ O $string$ O O O $void$ O $Contact$ O O $Console$ O $void$ O O O $Wechaty$ O $complex$ O O O O $complex$ O $Console$ O $void$ O O O $void$ O $Contact$ O O $Console$ O $void$ O O O O O $void$ O $Error$ O O $Console$ O $void$ O O O $Error$ O O O O $Promise<void>$ O $Message$ O O $Console$ O $void$ O $Message$ O $string$ O O O O O $Message$ O $number$ O O O O O O O O $Console$ O $void$ O O O O O O O $Message$ O $any$ O O O $Wechaty$ O $any$ O $any$ O $any$ O O O O $boolean$ O $Message$ O $string$ O O O O O $Console$ O $void$ O O O O O O $Message$ O $complex$ O O O $Console$ O $void$ O O O O $any$ O $any$ O $any$ O O O O $Message$ O $complex$ O $any$ O $Console$ O $void$ O O O $any$ O $any$ O O O O $Message$ O $complex$ O O O O O O O O O O $string$ O O O O O O $string$ O O $Console$ O $void$ O $string$ O
import { spawn } from 's' const MAX_RETRY_NUM = 0 async function main ( ) < number > { console . info ( 's' ) let round = 0 let succ = false do { console . info ( `template` ) succ = await unitTest ( ) if ( succ ) { console . info ( `template` ) return 0 } } while ( round ++ < MAX_RETRY_NUM ) return 0 } async function unitTest ( ) { const child = spawn ( 's' , [ 's' , 's' , ] , { shell : true , stdio : 's' , } , ) return new Promise < boolean > ( ( resolve , reject ) => { child . once ( 's' , code => code === 0 ? resolve ( true ) : resolve ( false ) , ) child . once ( 's' , reject ) } ) } main ( ) . then ( process . exit ) . catch ( e => { console . error ( e ) process . exit ( 0 ) } )	O O $any$ O O O O O O O O O $Promise$ O O O O O O $Console$ O $void$ O O O O $number$ O O O $boolean$ O O O O $Console$ O $void$ O O O $boolean$ O O $Promise<boolean>$ O O O O $boolean$ O O $Console$ O $void$ O O O O O O O O O $number$ O O O O O O O O O $Promise<boolean>$ O O O O $any$ O $any$ O O O O O O O O O O O $boolean$ O O O $string$ O O O O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $void$ O O O O $void$ O O O O O $any$ O $any$ O O O $void$ O O O O $Promise<number>$ O O O O O $any$ O $any$ O O $complex$ O $any$ O O $Console$ O $void$ O $any$ O $any$ O $any$ O O O O O
import * as readline from 's' const contributeMap : { [ contributor ] : string [ ] , } = { } function parseLine ( line ) : string [ ] | null { const regex = "s" const matches = regex . exec ( line ) if ( ! matches ) { return null } return matches } function processLine ( line ) { const matches = parseLine ( line ) if ( matches ) { const link = matches [ 0 ] + matches [ 0 ] const contributor = matches [ 0 ] if ( ! ( contributor in contributeMap ) ) { contributeMap [ contributor ] = [ ] } contributeMap [ contributor ] . push ( link ) } else { console . error ( 's' , line ) } } function outputContributorMd ( ) { const MIN_MAINTAINER_COMMIT_NUM = 0 function isMaintainer ( committer ) { return contributeMap [ committer ] . length >= MIN_MAINTAINER_COMMIT_NUM } const activeContributorList = Object . keys ( contributeMap ) . filter ( isMaintainer ) . sort ( desc ) function desc ( committerA , committerB ) { return contributeMap [ committerB ] . length - contributeMap [ committerA ] . length } console . info ( [ 's' , 's' , 's' , 's' , 's' , 's' , ] . join ( 's' ) ) for ( const contributor of activeContributorList ) { console . info ( `template` ) } console . info ( [ 's' , 's' , 's' , ] . join ( 's' ) ) const SKIP_NAME_LIST = [ 's' , 's' , ] const SKIP_REGEX = new RegExp ( SKIP_NAME_LIST . join ( 's' ) , 's' ) for ( const contributor of Object . keys ( contributeMap ) . sort ( desc ) ) { if ( SKIP_REGEX . test ( contributor ) ) { continue } if ( ! activeContributorList . includes ( contributor ) ) { console . info ( `template` ) } } console . info ( ) } async function main ( ) { const rl = readline . createInterface ( { input : process . stdin , output : process . stdout , terminal : false , } ) rl . on ( 's' , processLine ) await new Promise ( resolve => rl . on ( 's' , resolve ) ) outputContributorMd ( ) return 0 } main ( ) . then ( process . exit ) . catch ( e => { console . error ( e ) process . exit ( 0 ) } )	O O O $any$ O O O $complex$ O O O $string$ O O O O O O O O O O O $string[]$ O $string$ O O O O O O O O O $RegExp$ O O O $RegExpExecArray$ O $RegExp$ O $RegExpExecArray$ O $string$ O O O O $RegExpExecArray$ O O O O O O $RegExpExecArray$ O O $void$ O $string$ O O O $string[]$ O $string[]$ O $string$ O O O $string[]$ O O O $string$ O $string[]$ O O O O $string[]$ O O O O $string$ O $string[]$ O O O O O O O $string$ O $complex$ O O O $complex$ O $string$ O O O O O $complex$ O $string$ O O $number$ O $string$ O O O O $Console$ O $void$ O O O $string$ O O O O $void$ O O O O O O O O $boolean$ O $string$ O O O $complex$ O $string$ O O $number$ O O O O $string[]$ O $ObjectConstructor$ O $complex$ O $complex$ O O $complex$ O $boolean$ O O $string[]$ O $number$ O O $number$ O $string$ O $string$ O O O $complex$ O $string$ O O $number$ O $complex$ O $string$ O O $number$ O $Console$ O $void$ O O O O O O O O O O O O O O O O $string$ O O O O O O O $string$ O $string[]$ O O $Console$ O $void$ O O O O $Console$ O $void$ O O O O O O O O O O $string$ O O O O O $string[]$ O O O O O O O O $RegExp$ O O $RegExpConstructor$ O $string[]$ O $string$ O O O O O O O O O $string$ O $ObjectConstructor$ O $complex$ O $complex$ O O $string[]$ O $number$ O O O O O $RegExp$ O $boolean$ O $string$ O O O O O O O O $string[]$ O $boolean$ O $string$ O O O $Console$ O $void$ O O O O O $Console$ O $void$ O O O O O $Promise<number>$ O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $boolean$ O O O O O $any$ O $any$ O O O $void$ O O O $PromiseConstructor$ O $void$ O $any$ O $any$ O O O $void$ O O $void$ O O O O O $Promise<number>$ O O O O O $any$ O $any$ O O $complex$ O $any$ O O $Console$ O $void$ O $any$ O $any$ O $any$ O O O O O
import { createReadStream , createWriteStream , promises as fsPromises , } from 's' import { Transform , } from 's' import { promisify } from 's' import * as globCallback from 's' const LICENSE = `template` class LicenseTransformer extends Transform { private lineBuf = 's' private lineNum = 0 private updating = false private updated = false public _transform ( chunk , _ , done : ( ) => void ) { if ( this . updated ) { this . push ( chunk ) } else { const updatedChunk = this . updateChunk ( chunk ) this . push ( updatedChunk ) } done ( ) } private updateChunk ( chunk ) { const buffer = this . lineBuf + chunk . toString ( ) this . lineBuf = 's' if ( ! buffer ) { console . error ( 's' ) return 's' } const updatedLineList : string [ ] = [ ] buffer . split ( "s" ) . forEach ( line => { if ( this . lineNum === 0 && line . startsWith ( 's' ) ) { updatedLineList . push ( line ) } else if ( this . updated ) { updatedLineList . push ( line ) } else if ( this . updating ) { if ( "s" . test ( line ) ) { updatedLineList . push ( line . replace ( "s" , LICENSE ) ) this . updating = false this . updated = true } else { } } else { if ( ! line ) { updatedLineList . push ( line ) } else if ( "s" . test ( line ) ) { if ( "s" . test ( line ) ) { updatedLineList . push ( line . replace ( "s" , LICENSE ) ) this . updated = true } else { this . updating = true } } else { updatedLineList . push ( LICENSE ) updatedLineList . push ( line ) this . updated = true } } this . lineBuf = line this . lineNum ++ } ) return updatedLineList . join ( 's' ) } public _flush ( done : ( ) => void ) { if ( this . lineBuf ) { this . push ( this . lineBuf ) this . lineBuf = 's' } done ( ) } } async function updateLicense ( file ) < void > { const tmpFile = file + `template` const readStream = createReadStream ( file ) const writeStream = createWriteStream ( tmpFile ) const tranStream = new LicenseTransformer ( ) console . info ( `template` ) await new Promise < void > ( ( resolve , reject ) => { readStream . pipe ( tranStream ) . pipe ( writeStream ) . on ( 's' , resolve ) . on ( 's' , reject ) } ) await fsPromises . unlink ( file ) await fsPromises . link ( tmpFile , file ) await fsPromises . unlink ( tmpFile ) } async function glob ( pattern ) < string [ ] > { return promisify < string , string [ ] > ( globCallback as any ) ( pattern ) } async function main ( ) < number > { const pattern = 's' const srcFileList = await glob ( pattern ) const promiseList = srcFileList . map ( updateLicense ) await Promise . all ( promiseList ) return 0 } main ( ) . then ( process . exit ) . catch ( e => { console . error ( e ) process . exit ( 0 ) } )	O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O O $any$ O $any$ O O $string$ O O O $number$ O O O $boolean$ O O O $boolean$ O O O $void$ O $any$ O $string$ O $void$ O O O O O O O O O O O $boolean$ O O O O $any$ O $any$ O O O O O $string$ O O O $string$ O $any$ O O O $any$ O $string$ O O $void$ O O O O $string$ O $any$ O O O $string$ O O O $string$ O $any$ O $any$ O O O O $string$ O O O O O $string$ O O $Console$ O $void$ O O O O O O O $string[]$ O O O O O O O $string$ O $complex$ O O O O $void$ O $string$ O O O O O O $number$ O O O $string$ O $boolean$ O O O O O $string[]$ O $number$ O $string$ O O O O O O O $boolean$ O O $string[]$ O $number$ O $string$ O O O O O O O $boolean$ O O O O O O $boolean$ O $string$ O O O $string[]$ O $number$ O $string$ O $complex$ O O O O O O O O $boolean$ O O O O $boolean$ O O O O O O O O O O O O $string$ O O $string[]$ O $number$ O $string$ O O O O O O O $boolean$ O $string$ O O O O O O O $boolean$ O $string$ O O O $string[]$ O $number$ O $string$ O $complex$ O O O O O O O O $boolean$ O O O O O O O $boolean$ O O O O O O $string[]$ O $number$ O O O $string[]$ O $number$ O $string$ O O O $boolean$ O O O O O O $string$ O $string$ O O $number$ O O O O $string[]$ O $string$ O O O O O $void$ O $void$ O O O O O O O O O O O $string$ O O O O $any$ O O O $string$ O O O $string$ O O O $void$ O O O O O O $Promise$ O $string$ O O O O O O $string$ O $string$ O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O $LicenseTransformer$ O O $any$ O O $Console$ O $void$ O O O O O $PromiseConstructor$ O O O O O $void$ O $void$ O O O $any$ O $any$ O $LicenseTransformer$ O O $any$ O $any$ O O $any$ O O O $void$ O O $any$ O O O $void$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O $string$ O O $any$ O $any$ O $string$ O O O O $Promise$ O $string$ O O O O O O O O $any$ O O O O O O O O $any$ O O O O $string$ O O O O $Promise$ O O O O O O O O O O O $string[]$ O O $Promise<string[]>$ O O O O $Promise<void>[]$ O $string[]$ O $U[]$ O $Promise<void>$ O O $PromiseConstructor$ O O O $Promise<void>[]$ O O O O $Promise<number>$ O O O O O $any$ O $any$ O O $complex$ O $any$ O O $Console$ O $void$ O $any$ O $any$ O $any$ O O O O O
import test from 's' import { cloneClass , } from 's' import { Accessory , } from 's' import { Puppet } from 's' const 0 = { p : 0 } as any as Puppet const 0 = { p : 0 } as any as Puppet test ( 's' , async t => { class FixtureClass extends Accessory { } t . throws ( ( ) => FixtureClass . puppet , 's' ) const c = new FixtureClass ( ) t . throws ( ( ) => c . puppet , 's' ) FixtureClass . puppet = 0 t . equal ( FixtureClass . puppet , 0 , 's' ) t . equal ( c . puppet , 0 , 's' ) } ) test ( 's' , async t => { class FixtureClass extends Accessory { } const 0 = cloneClass ( FixtureClass ) const 0 = cloneClass ( FixtureClass ) 0 . puppet = 0 0 . puppet = 0 const 0 = new 0 ( ) const 0 = new 0 ( ) t . equal ( 0 . puppet , 0 , 's' ) t . equal ( 0 . puppet , 0 , 's' ) } ) test ( 's' , async t => { class FixtureClass extends Accessory { } const fixture = new FixtureClass ( ) t . doesNotThrow ( ( ) => { fixture . puppet = { } as any } , 's' ) t . throws ( ( ) => { fixture . puppet = { } as any } , 's' ) t . doesNotThrow ( ( ) => { FixtureClass . puppet = { } as any } , 's' ) t . throws ( ( ) => { FixtureClass . puppet = { } as any } , 's' ) } )	O $any$ O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O $number$ O O O O O O $any$ O $any$ O O $number$ O O O O O O $any$ $any$ O O O O $any$ O O O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O O O O $FixtureClass$ O O $any$ O O $any$ O $any$ O O O O $FixtureClass$ O $any$ O O O $any$ O $any$ O $any$ $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $FixtureClass$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O O O $FixtureClass$ O O $any$ O O $any$ O $any$ O O O O O $FixtureClass$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O $FixtureClass$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O O O O O
import test from 's' import { config } from 's' test ( 's' , async t => { t . true ( 's' in config , 's' ) t . true ( 's' in config , 's' ) t . true ( 's' in config , 's' ) t . ok ( config . default . DEFAULT_PROTOCOL , 's' ) t . ok ( config . default . DEFAULT_APIHOST , 's' ) } ) test ( 's' , async t => { const OK_APIHOSTS = [ 's' , 's' , ] const ERR_APIHOSTS = [ 's' , 's' , ] OK_APIHOSTS . forEach ( apihost => { t . doesNotThrow ( ( ) => { config . validApiHost ( apihost ) } ) } , 's' ) ERR_APIHOSTS . forEach ( apihost => { t . throws ( ( ) => { config . validApiHost ( apihost ) } ) } , 's' ) } ) test ( 's' , async t => { const WECHATY_PUPPET_ORIG = process . env . WECHATY_PUPPET delete process . env . WECHATY_PUPPET t . equal ( config . systemPuppetName ( ) , 's' , 's' ) process . env . WECHATY_PUPPET = 's' t . equal ( config . systemPuppetName ( ) , 's' , 's' ) process . env . WECHATY_PUPPET = WECHATY_PUPPET_ORIG } )	O $any$ O O O O $Config$ O O O $any$ O O O O $any$ O O $any$ O $any$ O O O $Config$ O O O $any$ O $any$ O O O $Config$ O O O $any$ O $any$ O O O $Config$ O O O $any$ O $any$ O $Config$ O $DefaultSetting$ O $string$ O O O $any$ O $any$ O $Config$ O $DefaultSetting$ O $string$ O O O O O $any$ O O O O $any$ O O O $string[]$ O O O O O O O O $string[]$ O O O O O O O $string[]$ O $void$ O $string$ O O $any$ O $any$ O O O O O $Config$ O $boolean$ O $string$ O O O O O O O $string[]$ O $void$ O $string$ O O $any$ O $any$ O O O O O $Config$ O $boolean$ O $string$ O O O O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ $any$ O $any$ O $Config$ O O O O O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O $Config$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O
import test from 's' import net from 's' import { getPort } from 's' test ( 's' , async t => { let port = await getPort ( ) let ttl = 0 const serverList = [ ] while ( ttl -- > 0 ) { try { const server = net . createServer ( socket => { console . info ( socket ) } ) await new Promise ( resolve => server . listen ( port , resolve ) ) serverList . push ( server ) port = await getPort ( ) } catch ( e ) { t . fail ( 's' + e . message + 's' + e . stack ) } } serverList . map ( server => server . close ( ) ) t . pass ( 's' ) } )	O $any$ O O O $any$ O O O O $Promise<number>$ O O O $any$ O O O O $any$ O O O $number$ O O $Promise<number>$ O O O $number$ O O O $any[]$ O O O O O $number$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O $Console$ O $void$ O $any$ O O O O O $PromiseConstructor$ O $void$ O $any$ O $any$ O $number$ O $void$ O O $any[]$ O $number$ O $any$ O $number$ O O $Promise<number>$ O O O O O $any$ O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any[]$ O $U[]$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O
import test from 's' import sinon from 's' import { tryWait } from 's' import promiseRetry = require ( 's' ) test ( 's' , async t => { const EXPECTED_RESOLVE = 's' const EXPECTED_REJECT = 's' function delayedFactory ( timeout ) { const startTime = Date . now ( ) return ( ) => { const nowTime = Date . now ( ) if ( nowTime - startTime > timeout ) { return Promise . resolve ( EXPECTED_RESOLVE ) } return Promise . reject ( EXPECTED_REJECT ) } } const thenSpy = sinon . spy ( ) const 0 = delayedFactory ( 0 ) await promiseRetry ( { minTimeout : 0 , retries : 0 , } , ( retry ) => { return 0 ( ) . catch ( retry ) } , ) . catch ( ( e ) => { thenSpy ( e ) } ) t . true ( thenSpy . withArgs ( EXPECTED_REJECT ) . calledOnce , 's' ) thenSpy . resetHistory ( ) const 0 = delayedFactory ( 0 ) await promiseRetry ( { minTimeout : 0 , retries : 0 , } , ( retry ) => { return 0 ( ) . catch ( retry ) } , ) . then ( ( r ) => { return thenSpy ( r ) } ) t . true ( thenSpy . withArgs ( EXPECTED_RESOLVE ) . calledOnce , 's' ) } ) test ( 's' , async t => { const EXPECTED_RESOLVE = 's' const EXPECTED_REJECT = 's' function delayedFactory ( timeout ) { const startTime = Date . now ( ) return ( ) => { const nowTime = Date . now ( ) if ( nowTime - startTime > timeout ) { return Promise . resolve ( EXPECTED_RESOLVE ) } return Promise . reject ( EXPECTED_REJECT ) } } const thenSpy = sinon . spy ( ) const 0 = delayedFactory ( 0 ) await tryWait ( ( retry ) => { return 0 ( ) . catch ( retry ) } , ) . then ( ( r ) => { return thenSpy ( r ) } ) t . true ( thenSpy . withArgs ( EXPECTED_RESOLVE ) . calledOnce , 's' ) } )	O $any$ O O O $any$ O O O O $Promise<T>$ O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O O O O O O O $Promise<string>$ O $number$ O O O $number$ O $DateConstructor$ O $number$ O O O O O O O O $number$ O $DateConstructor$ O $number$ O O O O $number$ O $number$ O $number$ O O O $PromiseConstructor$ O $complex$ O O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O O $any$ O $any$ O $any$ O O O $Promise<string>$ O $Promise<string>$ O O O O $any$ O O $number$ O O O $number$ O O O O O O $any$ O O O O $Promise<string>$ O O O $complex$ O $any$ O O O O O $any$ O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O $Promise<string>$ O $Promise<string>$ O O O O $any$ O O $number$ O O O $number$ O O O O O O $any$ O O O O $Promise<string>$ O O O $complex$ O $any$ O O O O O $any$ O O $string$ O O O O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O $any$ O O O O $any$ O O O O O O O O O O O $Promise<string>$ O $number$ O O O $number$ O $DateConstructor$ O $number$ O O O O O O O O $number$ O $DateConstructor$ O $number$ O O O O $number$ O $number$ O $number$ O O O $PromiseConstructor$ O $complex$ O O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O O $any$ O $any$ O $any$ O O O $Promise<string>$ O $Promise<string>$ O O O O $Promise<T>$ O O $never$ O O O O $Promise<string>$ O O O $complex$ O $never$ O O O O O O O O $string$ O O O O $any$ O $string$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O
import test from 's' import { digestEmoji , plainText , stripEmoji , stripHtml , unescapeHtml , unifyEmoji , } from 's' test ( 's' , async t => { const HTML_BEFORE_STRIP = 's' const HTML_AFTER_STRIP = 's' const strippedHtml = stripHtml ( HTML_BEFORE_STRIP ) t . is ( strippedHtml , HTML_AFTER_STRIP , 's' ) } ) test ( 's' , async t => { const HTML_BEFORE_UNESCAPE = 's' const HTML_AFTER_UNESCAPE = `template` const unescapedHtml = unescapeHtml ( HTML_BEFORE_UNESCAPE ) t . is ( unescapedHtml , HTML_AFTER_UNESCAPE , 's' ) } ) test ( 's' , async t => { const PLAIN_BEFORE = 's' const PLAIN_AFTER = 's' const text = plainText ( PLAIN_BEFORE ) t . is ( text , PLAIN_AFTER , 's' ) } ) test ( 's' , async t => { const EMOJI_XML = [ 's' , 's' , 's' , 's' , ] const EMOJI_AFTER_DIGEST = [ 's' , 's' , 's' , 's' , ] for ( let i = 0 ; i < EMOJI_XML . length ; i ++ ) { const emojiDigest = digestEmoji ( EMOJI_XML [ i ] ) t . is ( emojiDigest , EMOJI_AFTER_DIGEST [ i ] , 's' + i + 's' ) } } ) test ( 's' , async t => { const ORIGNAL_XML_LIST < [ string [ ] , string ] > = [ [ [ 's' , 's' , ] , 's' , ] , ] ORIGNAL_XML_LIST . forEach ( ( [ xmlList , expectedEmojiXml ] ) => { xmlList . forEach ( xml => { const unifiedXml = unifyEmoji ( xml ) t . is ( unifiedXml , expectedEmojiXml , 's' ) } ) } ) } ) test ( 's' , async t => { const EMOJI_STR = [ [ 's' , 's' , ] , [ 's' , 's' , ] , ] EMOJI_STR . forEach ( ( [ emojiStr , expectResult ] ) => { const result = stripEmoji ( emojiStr ) t . is ( result , expectResult , 's' ) } ) const empty = stripEmoji ( undefined ) t . is ( empty , 's' , 's' ) } )	O $any$ O O O O $string$ O $string$ O $string$ O $string$ O $string$ O $string$ O O O O $any$ O O O O $any$ O O O O O O O O O O O $string$ O $string$ O O O $any$ O $any$ O $string$ O O O O O O O $any$ O O O O $any$ O O O O O O O O O O O $string$ O $string$ O O O $any$ O $any$ O $string$ O O O O O O O $any$ O O O O $any$ O O O O O O O O O O O $string$ O $string$ O O O $any$ O $any$ O $string$ O O O O O O O $any$ O O O O $any$ O O O $string[]$ O O O O O O O O O O O O $string[]$ O O O O O O O O O O O O O O $number$ O O O $number$ O $string[]$ O $number$ O $number$ O O O O $string$ O $string$ O $string[]$ O $number$ O O $any$ O $any$ O $string$ O $string[]$ O $number$ O O O O $number$ O O O O O O $any$ O O O O $any$ O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O $complex$ O $void$ O O O $string[]$ O $string$ O O O O $string[]$ O $void$ O $string$ O O O $string$ O $string$ O $string$ O $any$ O $any$ O $string$ O $string$ O O O O O O O O O $any$ O O O O $any$ O O O $string[][]$ O O O O O O O O O O O O O O O O O $string[][]$ O $void$ O O O $string$ O $string$ O O O O O $string$ O $string$ O $string$ O $any$ O $any$ O $string$ O $string$ O O O O O O $string$ O $string$ O $undefined$ O $any$ O $any$ O $string$ O O O O O O O
import test from 's' import { Io } from 's' import { Wechaty } from 's' test ( 's' , async t => { const io = new Io ( { token : 's' , wechaty : new Wechaty ( ) , } ) try { for ( let i = 0 ; i < 0 ; i ++ ) { await io . start ( ) await io . stop ( ) t . pass ( 's' + i ) } t . pass ( 's' ) } catch ( e ) { t . fail ( e ) } } )	O $any$ O O O O $any$ O O O O O $any$ O O O $any$ O O O O $any$ O O O $Io$ O O $any$ O O $string$ O O O $Wechaty$ O O $any$ O O O O O O O O O O $number$ O O O $number$ O O O $number$ O O O O $Io$ O $Promise<void>$ O O O $Io$ O $Promise<void>$ O O $any$ O $any$ O O O $number$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O
import test from 's' import { PuppetManager , } from 's' test ( 's' , async t => { try { await PuppetManager . resolve ( 's' as any ) t . fail ( 's' ) } catch ( e ) { t . pass ( 's' + e ) } try { await PuppetManager . resolve ( { puppet : 's' as any } ) t . fail ( 's' ) } catch ( e ) { t . pass ( 's' + e ) } try { await PuppetManager . resolve ( { puppet : 's' } ) t . pass ( 's' ) } catch ( e ) { t . fail ( 's' ) } } )	O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O O $any$ O $Promise<any>$ O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $Promise<any>$ O O $any$ O O O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O $Promise<any>$ O O $string$ O O O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O O O O O O
import test from 's' import { cloneClass , } from 's' import { PuppetMock , } from 's' import { Contact as GlobalContact , } from 's' const Contact = cloneClass ( GlobalContact ) test ( 's' , async t => { const MyContact = cloneClass ( Contact ) t . throws ( ( ) => { const c = MyContact . load ( 's' ) t . fail ( c . name ( ) ) } , 's' ) t . throws ( ( ) => { const c = MyContact . load ( 's' ) t . fail ( c . name ( ) ) } , 's' ) } ) test ( 's' , async t => { const MyContact = cloneClass ( Contact ) t . throws ( ( ) => { const c = MyContact . load ( 's' ) t . fail ( c . name ( ) ) } , 's' ) t . throws ( ( ) => { const c = MyContact . load ( 's' ) t . fail ( c . name ( ) ) } , 's' ) } ) test ( 's' , async t => { const MyContact = cloneClass ( Contact ) MyContact . puppet = new PuppetMock ( ) t . doesNotThrow ( ( ) => { const c = MyContact . load ( 's' ) t . ok ( c , 's' ) } , 's' ) t . doesNotThrow ( ( ) => { const c = MyContact . load ( 's' ) t . ok ( c , 's' ) } , 's' ) } ) test ( 's' , async t => { t . throws ( ( ) => { const c = GlobalContact . load ( 's' ) t . fail ( 's' ) t . fail ( c . toString ( ) ) } , 's' ) } )	O $any$ O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O $Contact$ O $any$ O $T["prototype"]$ O O O $any$ O $any$ O O O $any$ O $any$ O $Contact$ O $string$ O O O O O O O O O
import test from 's' import sinon from 's' import { ContactPayload } from 's' import { PuppetMock } from 's' import { Wechaty } from 's' test ( 's' , async t => { const EXPECTED_CONTACT_ID = 's' const EXPECTED_CONTACT_NAME = 's' const EXPECTED_CONTACT_ID_LIST = [ EXPECTED_CONTACT_ID ] const sandbox = sinon . createSandbox ( ) const puppet = new PuppetMock ( ) const wechaty = new Wechaty ( { puppet } ) await wechaty . start ( ) sandbox . stub ( puppet , 's' ) . resolves ( EXPECTED_CONTACT_ID_LIST ) sandbox . stub ( puppet , 's' ) . callsFake ( async ( ) => { await new Promise ( resolve => setImmediate ( resolve ) ) return { name : EXPECTED_CONTACT_NAME , } as ContactPayload } ) const contactList = await wechaty . Contact . findAll ( ) t . equal ( contactList . length , 0 , 's' ) t . equal ( contactList [ 0 ] . name ( ) , EXPECTED_CONTACT_NAME , 's' ) await wechaty . stop ( ) } )	O $any$ O O O $any$ O O O O $any$ O O O O O $any$ O O O O O $any$ O O O $any$ O O O O $any$ O O O O O O O O O O O $string[]$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O $Wechaty$ O O $any$ O O $any$ O O O $Wechaty$ O $Promise<void>$ O O $any$ O $any$ O $any$ O O O O $any$ O $string[]$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $PromiseConstructor$ O $void$ O $any$ O $void$ O O O O $string$ O O O O O $any$ O O O $Contact[]$ O O $Wechaty$ O $any$ O $Promise<T["prototype"][]>$ O O $any$ O $any$ O $Contact[]$ O $number$ O O O O O $any$ O $any$ O $Contact[]$ O O O O $string$ O O O O O O O O $Wechaty$ O $Promise<void>$ O O O O
import test from 's' import sinon from 's' import { ContactPayload , MessagePayload , MessageType , RoomPayload , } from 's' import { PuppetMock } from 's' import { Wechaty } from 's' test ( 's' , async t => { const EXPECTED_RECALL_MESSAGE_ID = 's' const EXPECTED_RECALLED_MESSAGE_ID = 's' const EXPECTED_MESSAGE_TIMESTAMP = new Date ( ) . getTime ( ) const EXPECTED_ROOM_TOPIC = 's' const EXPECTED_ROOM_ID = 's' const EXPECTED_FROM_CONTACT_ID = 's' const EXPECTED_TO_CONTACT_ID = 's' const sandbox = sinon . createSandbox ( ) const puppet = new PuppetMock ( ) const wechaty = new Wechaty ( { puppet } ) await wechaty . start ( ) sandbox . stub ( puppet , 's' ) . callsFake ( async ( id ) => { await new Promise ( resolve => setImmediate ( resolve ) ) if ( id === EXPECTED_RECALL_MESSAGE_ID ) { return { id : EXPECTED_RECALL_MESSAGE_ID , text : EXPECTED_RECALLED_MESSAGE_ID , timestamp : EXPECTED_MESSAGE_TIMESTAMP , type : MessageType . Recalled , } as MessagePayload } else { return { fromId : EXPECTED_FROM_CONTACT_ID , id : EXPECTED_RECALLED_MESSAGE_ID , roomId : EXPECTED_ROOM_ID , text : 's' , timestamp : EXPECTED_MESSAGE_TIMESTAMP , toId : EXPECTED_TO_CONTACT_ID , type : MessageType . Text , } as MessagePayload } } ) sandbox . stub ( puppet , 's' ) . callsFake ( async ( ) => { await new Promise ( resolve => setImmediate ( resolve ) ) return { topic : EXPECTED_ROOM_TOPIC , } as RoomPayload } ) sandbox . stub ( puppet , 's' ) . callsFake ( async ( ) => { await new Promise ( ( resolve ) => setImmediate ( resolve ) ) return [ EXPECTED_FROM_CONTACT_ID , EXPECTED_TO_CONTACT_ID ] } ) sandbox . stub ( puppet , 's' ) . callsFake ( async ( id ) => { await new Promise ( resolve => setImmediate ( resolve ) ) return { id , name : id , } as ContactPayload } ) const message = wechaty . Message . load ( EXPECTED_RECALL_MESSAGE_ID ) await message . ready ( ) const recalledMessage = await message . toRecalled ( ) t . assert ( recalledMessage , 's' ) t . equal ( recalledMessage ! . id , EXPECTED_RECALLED_MESSAGE_ID , 's' ) t . equal ( recalledMessage ! . from ( ) ! . id , EXPECTED_FROM_CONTACT_ID , 's' ) t . equal ( recalledMessage ! . to ( ) ! . id , EXPECTED_TO_CONTACT_ID , 's' ) t . equal ( recalledMessage ! . room ( ) ! . id , EXPECTED_ROOM_ID , 's' ) await wechaty . stop ( ) } )	O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O $any$ O O O O $any$ O O O O O O O O O O O $number$ O O $DateConstructor$ O O O $number$ O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O $Wechaty$ O O $any$ O O $any$ O O O $Wechaty$ O $Promise<void>$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O $PromiseConstructor$ O $void$ O $any$ O $void$ O O O O $any$ O O O O O O $string$ O O O $string$ O O O $number$ O $number$ O $any$ O $any$ O $any$ O O O $any$ O O O O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O $number$ O $number$ O $string$ O O O $any$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $PromiseConstructor$ O $void$ O $any$ O $void$ O O O O $string$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $PromiseConstructor$ O O $void$ O O $any$ O $void$ O O O O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O O O O O $PromiseConstructor$ O $void$ O $any$ O $void$ O O O O $string$ O $string$ O $string$ O O O $any$ O O O $Message$ O $Wechaty$ O $any$ O $Message$ O O O O $Message$ O $Promise<void>$ O O O $Message$ O O $Message$ O $Promise<Message>$ O O $any$ O $any$ O $Message$ O O O $any$ O $any$ O $Message$ O O $string$ O O O O O $any$ O $any$ O $Message$ O O $Contact$ O O O O $string$ O O O O O $any$ O $any$ O $Message$ O O $Contact$ O O O O $string$ O O O O O $any$ O $any$ O $Message$ O O $Room$ O O O O $string$ O O O O O O $Wechaty$ O $Promise<void>$ O O O O
import test from 's' import sinon from 's' import { ContactPayload , RoomMemberPayload , RoomPayload , } from 's' import { PuppetMock } from 's' import { Wechaty } from 's' test ( 's' , async t => { const EXPECTED_ROOM_ID = 's' const EXPECTED_ROOM_TOPIC = 's' const EXPECTED_ROOM_ID_LIST = [ EXPECTED_ROOM_ID ] const sandbox = sinon . createSandbox ( ) const puppet = new PuppetMock ( ) const wechaty = new Wechaty ( { puppet } ) await wechaty . start ( ) sandbox . stub ( puppet , 's' ) . resolves ( EXPECTED_ROOM_ID_LIST ) sandbox . stub ( puppet , 's' ) . callsFake ( async ( ) => { await new Promise ( resolve => setImmediate ( resolve ) ) return { topic : EXPECTED_ROOM_TOPIC , } as RoomPayload } ) const roomList = await wechaty . Room . findAll ( ) t . equal ( roomList . length , 0 , 's' ) t . equal ( await roomList [ 0 ] . topic ( ) , EXPECTED_ROOM_TOPIC , 's' ) await wechaty . stop ( ) } ) test ( 's' , async ( ) => { const sandbox = sinon . createSandbox ( ) const callback = sinon . spy ( ) const puppet = new PuppetMock ( ) const wechaty = new Wechaty ( { puppet } ) await wechaty . start ( ) const EXPECTED_ROOM_ID = 's' const EXPECTED_ROOM_TOPIC = 's' const 0 = 's' const 0 = 's' const 0 = 's' const 0 = 's' const CONTACT_MAP : { [ contactId ] : string } = { } CONTACT_MAP [ 0 ] = 0 CONTACT_MAP [ 0 ] = 0 sandbox . stub ( puppet , 's' ) . callsFake ( async ( _ , contactId ) => { await new Promise ( resolve => setImmediate ( resolve ) ) return { id : contactId , roomAlias : CONTACT_MAP [ contactId ] , } as RoomMemberPayload } ) sandbox . stub ( puppet , 's' ) . callsFake ( async ( ) => { await new Promise ( resolve => setImmediate ( resolve ) ) return { topic : EXPECTED_ROOM_TOPIC , } as RoomPayload } ) sandbox . stub ( puppet , 's' ) . callsFake ( async ( contactId ) => { await new Promise ( resolve => setImmediate ( resolve ) ) return { id : contactId , } as ContactPayload } ) sandbox . stub ( puppet , 's' ) . callsFake ( callback ) const room = wechaty . Room . load ( EXPECTED_ROOM_ID ) const 0 = wechaty . Contact . load ( 0 ) const 0 = wechaty . Contact . load ( 0 ) await 0 . sync ( ) await 0 . sync ( ) await room . sync ( ) test ( 's' , async t => { callback . resetHistory ( ) await `template` t . deepEqual ( callback . getCall ( 0 ) . args , [ { contactId : 0 , roomId : EXPECTED_ROOM_ID } , 's' , [ 0 , 0 ] , ] , 's' ) } ) test ( 's' , async t => { callback . resetHistory ( ) await room . say ( 's' , 0 ) t . deepEqual ( callback . getCall ( 0 ) . args , [ { contactId : 0 , roomId : EXPECTED_ROOM_ID } , 's' , [ 0 ] , ] , 's' ) } ) test ( 's' , async t => { callback . resetHistory ( ) await room . say ( 's' , 0 , 0 ) t . deepEqual ( callback . getCall ( 0 ) . args , [ { contactId : 0 , roomId : EXPECTED_ROOM_ID } , 's' , [ 0 , 0 ] , ] , 's' ) } ) await wechaty . stop ( ) } )	O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O O O $any$ O O O O $any$ O O O O O O O O O O O $string[]$ O O O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O $Wechaty$ O O $any$ O O $any$ O O O $Wechaty$ O $Promise<void>$ O O $any$ O $any$ O $any$ O O O O $any$ O $string[]$ O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $PromiseConstructor$ O $void$ O $any$ O $void$ O O O O $string$ O O O O O $any$ O O O $Room[]$ O O $Wechaty$ O $any$ O $Promise<T["prototype"][]>$ O O $any$ O $any$ O $Room[]$ O $number$ O O O O O $any$ O $any$ O O $Room[]$ O O O O $complex$ O O O O O O O O $Wechaty$ O $Promise<void>$ O O O O $any$ O O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O $Wechaty$ O O $any$ O O $any$ O O O $Wechaty$ O $Promise<void>$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $complex$ O O O $string$ O O O O O O O $complex$ O O O O O $complex$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O O O $PromiseConstructor$ O $void$ O $any$ O $void$ O O O O $any$ O $any$ O $string$ O $complex$ O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O O O O O $PromiseConstructor$ O $void$ O $any$ O $void$ O O O O $string$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O $PromiseConstructor$ O $void$ O $any$ O $void$ O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $Room$ O $Wechaty$ O $any$ O $T["prototype"]$ O O O O $Contact$ O $Wechaty$ O $any$ O $T["prototype"]$ O O O O $Contact$ O $Wechaty$ O $any$ O $T["prototype"]$ O O O O $Contact$ O $Promise<void>$ O O O $Contact$ O $Promise<void>$ O O O $Room$ O $Promise<void>$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O O O $Room$ O $complex$ O O O $Contact$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O $any$ O O O O $any$ O O $any$ O $any$ O O O $Room$ O $complex$ O O O $Contact$ O $Contact$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $string$ O O O $string$ O O O O O O O O O O O O O O O O O O O $Wechaty$ O $Promise<void>$ O O O O
import test from 's' import { VERSION } from 's' test ( 's' , async ( t ) => { t . equal ( VERSION , 's' , 's' ) } )	O $any$ O O O O O O O O $any$ O O O O O $any$ O O O $any$ O $any$ O O O O O O O O O
import test from 's' import sinon from 's' import { PuppetMock } from 's' import { Wechaty , } from 's' import { config , Contact , Friendship , IoClient , log , Message , Room , } from 's' import { Puppet , } from 's' class WechatyTest extends Wechaty { public initPuppetAccessoryTest ( puppet ) { return this . initPuppetAccessory ( puppet ) } } test ( 's' , async t => { t . ok ( Contact , 's' ) t . ok ( Friendship , 's' ) t . ok ( IoClient , 's' ) t . ok ( Message , 's' ) t . ok ( Puppet , 's' ) t . ok ( Room , 's' ) t . ok ( Wechaty , 's' ) t . ok ( log , 's' ) } ) test ( 's' , async t => { t . true ( 's' in Wechaty , 's' ) } ) test ( 's' , async t => { t . ok ( config , 's' ) } ) test ( 's' , async t => { const wechaty = new Wechaty ( { puppet : 's' } ) const startSpy = sinon . spy ( ) const stopSpy = sinon . spy ( ) wechaty . on ( 's' , startSpy ) wechaty . on ( 's' , stopSpy ) await wechaty . start ( ) await wechaty . stop ( ) t . ok ( startSpy . calledOnce , 's' ) t . ok ( stopSpy . calledOnce , 's' ) } ) test ( 's' , async t => { const spy = sinon . spy ( ) const wechaty = Wechaty . instance ( ) const EXPECTED_ERROR = new Error ( 's' ) wechaty . on ( 's' , ( ) => { throw EXPECTED_ERROR } ) wechaty . on ( 's' , ( ) => 0 ) wechaty . on ( 's' , spy ) const messageFuture = new Promise ( resolve => wechaty . once ( 's' , resolve ) ) wechaty . emit ( 's' , { } as any ) await messageFuture await wechaty . stop ( ) t . ok ( spy . calledOnce , 's' ) t . equal ( spy . firstCall . args [ 0 ] , EXPECTED_ERROR , 's' ) } ) test ( 's' , async t => { const wechatyTest = new WechatyTest ( ) const puppet = new PuppetMock ( ) t . doesNotThrow ( ( ) => wechatyTest . initPuppetAccessoryTest ( puppet ) , 's' ) t . throws ( ( ) => wechatyTest . initPuppetAccessoryTest ( puppet ) , 's' ) } ) test ( 's' , async t => { const wechaty = new Wechaty ( { puppet : new PuppetMock ( ) , } ) try { for ( let i = 0 ; i < 0 ; i ++ ) { await wechaty . start ( ) await wechaty . stop ( ) t . pass ( 's' + i ) } t . pass ( 's' ) } catch ( e ) { t . fail ( e ) } } ) test ( 's' , async t => { const puppet = new PuppetMock ( ) const wechaty = new Wechaty ( { puppet } ) const sandbox = sinon . createSandbox ( ) const spy = sandbox . spy ( ) wechaty . on ( 's' , spy ) t . true ( spy . notCalled , 's' ) await wechaty . start ( ) t . true ( spy . notCalled , 's' ) puppet . emit ( 's' ) t . true ( spy . calledOnce , 's' ) await wechaty . stop ( ) await wechaty . start ( ) puppet . emit ( 's' ) t . true ( spy . calledTwice , 's' ) await wechaty . stop ( ) } ) test ( 's' , async t => { const puppet = new PuppetMock ( ) const wechaty = new Wechaty ( { puppet } ) const sandbox = sinon . createSandbox ( ) const spy = sandbox . spy ( ) wechaty . ready ( ) . then ( spy ) . catch ( e => t . fail ( 's' + e ) ) t . true ( spy . notCalled , 's' ) await wechaty . start ( ) t . true ( spy . notCalled , 's' ) puppet . emit ( 's' ) await new Promise ( resolve => setImmediate ( resolve ) ) t . true ( spy . calledOnce , 's' ) await wechaty . stop ( ) await wechaty . start ( ) wechaty . ready ( ) . then ( spy ) . catch ( e => t . fail ( 's' + e ) ) puppet . emit ( 's' ) await new Promise ( resolve => setImmediate ( resolve ) ) t . true ( spy . calledTwice , 's' ) await wechaty . stop ( ) } )	O $any$ O O O $any$ O O O O $any$ O O O O O $any$ O O O O O O $Config$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O $any$ O $any$ O O $void$ O $Puppet$ O O O O O $void$ O $any$ O O O $any$ O O O O $any$ O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O $any$ O $any$ O O O $any$ O O O O O $any$ O O O O $any$ O O $any$ O $any$ O $Config$ O O O O O $any$ O O O O $any$ O O O $Wechaty$ O O $any$ O O $string$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $Wechaty$ O $complex$ O O O $any$ O $Wechaty$ O $complex$ O O O $any$ O O $Wechaty$ O $Promise<void>$ O O O $Wechaty$ O $Promise<void>$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O O O $any$ O O O $any$ O $any$ O $any$ O O O $Wechaty$ O $any$ O $Wechaty$ O O O $Error$ O O $ErrorConstructor$ O O O $Wechaty$ O $complex$ O O O O O O O O $Error$ O O $Wechaty$ O $complex$ O O O O O O O O $Wechaty$ O $complex$ O O O $any$ O O $Promise<unknown>$ O O $PromiseConstructor$ O $void$ O $Wechaty$ O $any$ O O O $void$ O O $Wechaty$ O $complex$ O O O O O O O O O $Promise<unknown>$ O $Wechaty$ O $Promise<void>$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $Error$ O O O O O $any$ O O O O $any$ O O O $WechatyTest$ O O $any$ O O O $any$ O O $any$ O O $any$ O $any$ O O O O $WechatyTest$ O $void$ O $any$ O O O O $any$ O $any$ O O O O $WechatyTest$ O $void$ O $any$ O O O O O O $any$ O O O O $any$ O O O $Wechaty$ O O $any$ O O $any$ O O $any$ O O O O O O O O O O $number$ O O O $number$ O O O $number$ O O O O $Wechaty$ O $Promise<void>$ O O O $Wechaty$ O $Promise<void>$ O O $any$ O $any$ O O O $number$ O O $any$ O $any$ O O O O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O O O $any$ O O $any$ O O O $Wechaty$ O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $Wechaty$ O $complex$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $Wechaty$ O $Promise<void>$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $Wechaty$ O $Promise<void>$ O O O $Wechaty$ O $Promise<void>$ O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $Wechaty$ O $Promise<void>$ O O O O $any$ O O O O $any$ O O O $any$ O O $any$ O O O $Wechaty$ O O $any$ O O $any$ O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $Wechaty$ O $Promise<void>$ O O O O O $any$ O O $complex$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O $Wechaty$ O $Promise<void>$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O O O $PromiseConstructor$ O $void$ O $any$ O $void$ O O $any$ O $any$ O $any$ O $any$ O O O O $Wechaty$ O $Promise<void>$ O O O $Wechaty$ O $Promise<void>$ O O $Wechaty$ O $Promise<void>$ O O O O O $any$ O O $complex$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O $any$ O O O O O $PromiseConstructor$ O $void$ O $any$ O $void$ O O $any$ O $any$ O $any$ O $any$ O O O O $Wechaty$ O $Promise<void>$ O O O O
import test from 's' test ( 's' , async t => { t . true ( true , 's' ) } ) test . skip ( 's' , async t => { t . pass ( 's' ) } )	O $any$ O O $any$ O O O O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O $any$ O O $any$ O $any$ O O O O O
'js' import { Wechaty } from 's' console . log ( Wechaty . instance ( ) . version ( ) )	O O O $any$ O O O $Console$ O $void$ O $any$ O $any$ O O O $any$ O O O
import fs = require ( 's' ) fs . statSync ( 's' ) console . log ( 's' )	O $any$ O O O O O $any$ O $any$ O O O $Console$ O $void$ O O O
'js' const { Wechaty } = require ( 's' ) const bot = Wechaty . instance ( ) console . log ( bot . version ( ) )	O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $Console$ O $void$ O $any$ O $any$ O O O
'js' hello , I 's'	O $any$ O $any$ O
import { Wechaty } from 's' const bot = Wechaty . instance ( ) console . log ( bot . version ( ) )	O O $any$ O O O O $any$ O $any$ O $any$ O O $Console$ O $void$ O $any$ O $any$ O O O
let i = 0 i = "s" console . log ( i )	O $number$ O O $number$ O O $Console$ O $void$ O $number$ O
import { NotExist } from 's' const ne = new NotExist ( ) console . log ( ne )	O O $any$ O O O O $any$ O O $any$ O O $Console$ O $void$ O $any$ O
import { Brolog } from 's' const brolog = new Brolog ( ) brolog . info ( 's' , 's' )	O O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O O O O
'js' const { NotExist } = require ( 's' ) const ne = new NowExist ( ) console . log ( ne )	O O O $any$ O O $any$ O O O O $any$ O O $any$ O O $Console$ O $void$ O $any$ O
'js' const { Brolog } = require ( 's' ) const brolog = new Brolog ( ) brolog . info ( 's' , 's' )	O O O $any$ O O $any$ O O O O $any$ O O $any$ O O $any$ O $any$ O O O O O
const isPR = require ( 's' ) import { Wechaty , VERSION , } from 's' function getBotList ( ) : Wechaty [ ] { const botList = [ new Wechaty ( { puppet : 's' } ) , new Wechaty ( { puppet : 's' } ) , ] if ( ! isPR ) { botList . push ( new Wechaty ( { puppet : 's' , } ) ) } return botList } async function main ( ) { if ( VERSION === 's' ) { throw new Error ( 's' ) } const botList = getBotList ( ) try { await Promise . all ( botList . map ( bot => bot . start ( ) ) , ) botList . forEach ( bot => console . log ( `template` ) , ) } catch ( e ) { console . error ( e ) return 0 } finally { await Promise . all ( botList . map ( bot => bot . stop ( ) ) , ) } return 0 } main ( ) . then ( process . exit ) . catch ( e => { console . error ( e ) process . exit ( 0 ) } )	O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any[]$ O O O $any$ O O O O $any[]$ O O O $any$ O O $string$ O O O O O O $any$ O O $string$ O O O O O O O O O $any$ O O $any[]$ O $number$ O O $any$ O O $string$ O O O O O O O O $any[]$ O O O O O O O O O $any$ O O O O O O $ErrorConstructor$ O O O O O $any[]$ O $any[]$ O O O O O $PromiseConstructor$ O O O $any[]$ O $U[]$ O $any$ O $any$ O $any$ O O O O O $any[]$ O $void$ O $any$ O $Console$ O $void$ O O O O O O O O $any$ O O $Console$ O $void$ O $any$ O O O O O O O $PromiseConstructor$ O O O $any[]$ O $U[]$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O $any$ O $any$ O O O O $any$ O O $Console$ O $void$ O $any$ O $any$ O $any$ O O O O O
import test from 's' import { spy } from 's' test ( 's' , async t => { const DEFAULT_N = 0 const DEFAULT_S = 's' const paramSpy = spy ( ) function paramTest ( { n = DEFAULT_N , s = DEFAULT_S , } = { } ) { paramSpy ( n , s ) } paramSpy . resetHistory ( ) paramTest ( ) t . deepEqual ( paramSpy . args [ 0 ] , [ DEFAULT_N , DEFAULT_S ] , 's' ) paramSpy . resetHistory ( ) paramTest ( { n : 0 } ) t . deepEqual ( paramSpy . args [ 0 ] , [ 0 , DEFAULT_S ] , 's' ) paramSpy . resetHistory ( ) paramTest ( { s : 's' } ) t . deepEqual ( paramSpy . args [ 0 ] , [ DEFAULT_N , 's' ] , 's' ) } )	O $any$ O O O O $any$ O O O $any$ O O O O $any$ O O O O O O O O O O O $any$ O $any$ O O O $void$ O O $number$ O O O $string$ O O O O O O O O O $any$ O $number$ O $string$ O O $any$ O $any$ O O $void$ O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O $void$ O O $number$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O O $void$ O O $string$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O O O