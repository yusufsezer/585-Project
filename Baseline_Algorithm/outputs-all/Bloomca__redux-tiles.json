'js' export const get = ( url , params ) => { return new Promise ( res => { setTimeout ( ( ) => { res ( { amount : Math . floor ( Math . random ( ) * 0 ) + 0 } ) ; } , Math . floor ( Math . random ( ) * 0 ) ) ; } ) }	O O O $Promise<any>$ O O $any$ O $any$ O O O O O $PromiseConstructor$ O $void$ O O $number$ O O O O O $void$ O O $number$ O $Math$ O $number$ O $Math$ O $number$ O O O O O O O O O O O O $Math$ O $number$ O $Math$ O $number$ O O O O O O O O O O
'js' import { createTile , createSyncTile } from 's' ; const currentValuesTile = createSyncTile ( { type : [ 's' , 's' , 's' ] , initialState : { value : 0 } } ) ; const nextValuesTile = createSyncTile ( { type : [ 's' , 's' , 's' ] , } ) ; const calculateOfferRequest = createTile ( { type : [ 's' , 's' ] , fn : ( { api , params } ) => api . get ( 's' , params ) , nesting : ( { value } ) => { if ( ! value ) { return [ 's' ] ; } return [ value ] ; } , caching : true , } ) ; const calculateOffer = createTile ( { type : [ 's' , 's' ] , fn : async ( { params , dispatch , actions , selectors , getState } ) => { dispatch ( actions . calculator . values . next ( params ) ) ; await dispatch ( actions . api . offer ( params ) ) ; const nextValues = selectors . calculator . values . next ( getState ( ) ) ; if ( nextValues . value === params . value ) { dispatch ( actions . calculator . values . current ( params ) ) ; } } , } ) ; export default [ currentValuesTile , nextValuesTile , calculateOfferRequest , calculateOffer ] ;	O O O $any$ O $any$ O O O O O $any$ O $any$ O O $string[]$ O O O O O O O O O $complex$ O O $number$ O O O O O O O $any$ O $any$ O O $string[]$ O O O O O O O O O O O O O $any$ O $any$ O O $string[]$ O O O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O O $any[]$ O O O $any$ O O O O O O O $any$ O O O O O O O O O O $any$ O O O O $boolean$ O O O O O O O $any$ O $any$ O O $string[]$ O O O O O O O $Promise<void>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O
'js' import { createEntities , createMiddleware } from 's' ; import { createStore , applyMiddleware } from 's' ; import * as api from 's' ; import tiles from 's' ; const { actions , reducer , selectors } = createEntities ( tiles ) ; const { middleware , waitTiles } = createMiddleware ( { api , actions , selectors } ) ; const store = createStore ( reducer , applyMiddleware ( middleware ) ) ; export default { store , waitTiles , actions , selectors } ;	O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O $any[]$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O
'js' import app from 's' ; test ( 's' , ( ) => { const { value } = app . selectors . calculator . values . current ( app . store . getState ( ) ) ; expect ( value ) . toBe ( 0 ) ; } ) ; test ( 's' , async ( ) => { app . store . dispatch ( app . actions . calculator . calculateOffer ( { value : 0 } ) ) ; setTimeout ( ( ) => { const { value } = app . selectors . calculator . values . next ( app . store . getState ( ) ) ; expect ( value ) . toBe ( 0 ) ; } , 0 ) ; } ) ; test ( 's' , async ( ) => { await app . store . dispatch ( app . actions . calculator . calculateOffer ( { value : 0 } ) ) ; const { value } = app . selectors . calculator . values . current ( app . store . getState ( ) ) ; expect ( value ) . toBe ( 0 ) ; } ) ; test ( 's' , async ( ) => { await app . store . dispatch ( app . actions . calculator . calculateOffer ( { value : 0 } ) ) ; const { data } = app . selectors . api . offer ( app . store . getState ( ) , { value : 0 } ) ; expect ( typeof data . amount ) . toBe ( 's' ) ; } ) ;	O O $complex$ O O O $any$ O O O O O O O O O $any$ O O $complex$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O O $number$ O O O O O O $number$ O O O O O O O $any$ O O $complex$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O O O O O O $any$ O O O O O O O O O $complex$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O O $number$ O O O O O O O O $any$ O O $complex$ O $any$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $complex$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O O $number$ O O O O O O O O $any$ O O $complex$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O O O O $number$ O O O O O $any$ O O $any$ O $any$ O O $any$ O O O O O O O
'js' import axios from 's' ; const prefix = 's' ; const constructURL = ( url ) => `template` ; export const get = ( url , params ) => { return axios . get ( constructURL ( url ) , { headers : { Accept : 's' } , params } ) ; }	O O $any$ O O O O O O O O O $string$ O O $any$ O O O O O O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $string$ O $any$ O O O $complex$ O O $string$ O O O O $any$ O O O O
'js' export default function parseHeaders ( { link } ) { if ( ! link ) { return { end : true , } ; } const els = link . split ( 's' ) ; const pagination = els . reduce ( ( hash , str ) => { const rels = str . match ( "s" ) ; hash [ rels [ 0 ] ] = Number ( rels [ 0 ] ) ; return hash ; } , { } ) ; if ( ! pagination . last ) { pagination . end = true ; } return pagination ; }	O O O O $any$ O O $any$ O O O O O O $any$ O O O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O O $NumberConstructor$ O $any$ O O O O O O $any$ O O O O O O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O
'js' import { createTile } from 's' ; import parseHeaders from 's' ; export const usersTile = createTile ( { type : [ 's' , 's' ] , fn : ( { api , params } ) => api . get ( `template` ) . then ( ( { data } ) => data ) , nesting : ( { id } ) => [ id ] , caching : true , } ) ; export const repositoresTile = createTile ( { type : [ 's' , 's' ] , fn : ( { api , params : { type , id , pageSize = 0 , pageNumber = 0 } } ) => { return api . get ( `template` , { page : pageNumber , per_page : pageSize } ) . then ( x => { const pagination = parseHeaders ( x . headers ) ; return { items : x . data , pagination } ; } ) ; } , nesting : ( { type , id , pageSize = 0 , pageNumber = 0 } ) => [ type , id , pageNumber , pageSize ] , } ) ; export const drainRepositories = createTile ( { type : [ 's' , 's' ] , fn : async ( { actions , dispatch , params , selectors , getState } ) => { let pageNumber = 0 ; let repos = [ ] ; while ( true ) { const { data : { pagination : { end } , items } } = await dispatch ( actions . gh_api . repos ( { ... params , pageNumber } ) ) ; repos = repos . concat ( items ) ; pageNumber ++ ; if ( end ) { return repos ; } } } } ) ; export const userWithRepos = createTile ( { type : [ 's' , 's' ] , fn : async ( { dispatch , actions , params : { id } , selectors , getState } ) => { const reposParams = { type : 's' , id } ; const [ { data : user } , { data : repos } ] = await Promise . all ( [ dispatch ( actions . gh_api . users ( { id } ) ) , dispatch ( actions . gh_api . drainRepos ( reposParams ) ) ] ) ; return { user , repos } ; } , } ) ; export default [ usersTile , drainRepositories , repositoresTile , userWithRepos , ] ;	O O O $any$ O O O O O $any$ O O O O O $any$ O $any$ O O $string[]$ O O O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O O $any[]$ O O O $any$ O O O O $any$ O O $boolean$ O O O O O O O O $any$ O $any$ O O $string[]$ O O O O O O O $any$ O O O $any$ O $complex$ O O $any$ O $any$ O $number$ O O O $number$ O O O O O O O O $any$ O $any$ O O O O $number$ O $number$ O $number$ O $number$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any[]$ O O O $any$ O $any$ O $number$ O O O $number$ O O O O O O $any$ O $any$ O $number$ O $number$ O O O O O O O $any$ O $any$ O O $string[]$ O O O O O O O $Promise<any[]>$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $number$ O O O O $any[]$ O O O O O O O O O O O $any$ O O $any$ O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $number$ O O O O $any[]$ O $any[]$ O $complex$ O $any$ O O $number$ O O O O $any$ O O O $any[]$ O O O O O O O O O $any$ O $any$ O O $string[]$ O O O O O O O $complex$ O O O O $any$ O $any$ O $complex$ O O $any$ O O $any$ O $any$ O O O O O $complex$ O O $string$ O O O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O O $PromiseConstructor$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $complex$ O O O O O O O $any$ O $any$ O O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O
'js' import { createEntities , createMiddleware } from 's' ; import { createStore , applyMiddleware } from 's' ; import * as api from 's' ; import tiles from 's' ; const { actions , reducer , selectors } = createEntities ( tiles ) ; const { middleware , waitTiles } = createMiddleware ( { api , actions , selectors } ) ; const store = createStore ( reducer , applyMiddleware ( middleware ) ) ; export default { store , waitTiles , actions , selectors } ;	O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O $any$ O O O O $any[]$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O
'js' import app from 's' ; jasmine . DEFAULT_TIMEOUT_INTERVAL = 0 ; test ( 's' , async ( ) => { const params = { id : 's' } ; app . store . dispatch ( app . actions . gh_api . userWithRepos ( params ) ) ; await app . waitTiles ( ) ; const state = app . store . getState ( ) ; const { data } = app . selectors . gh_api . userWithRepos ( app . store . getState ( ) , params ) ; expect ( data . user . url ) . toBe ( 's' ) ; expect ( data . repos ) . toBeInstanceOf ( Array ) ; } ) ;	O O $complex$ O O O $any$ O $number$ O O O $any$ O O O O O O O O O $complex$ O O $string$ O O O O $complex$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O $complex$ O O O O $complex$ O $any$ O O O O $any$ O $complex$ O $any$ O $any$ O O O O O $any$ O O $complex$ O $any$ O $any$ O $any$ O $complex$ O $any$ O $any$ O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O $ArrayConstructor$ O O O O O
'js' import Firebase from 's' ; import Database from 's' ; const config = { databaseURL : 's' , } ; Firebase . initializeApp ( config ) ; const version = 's' ; const api = Firebase . database ( ) . ref ( version ) ; export default api ;	O O $any$ O O O O $any$ O O O O $complex$ O O $string$ O O O O O $any$ O $any$ O $complex$ O O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O O O $any$ O
'js' import { createTile } from 's' ; export const storiesTile = createTile ( { type : [ 's' , 's' ] , fn : ( { api , params } ) => api . child ( params . type ) . once ( 's' ) . then ( snapshot => snapshot . val ( ) ) , nesting : ( { type } ) => [ type ] , caching : true , } ) ; export const itemTile = createTile ( { type : [ 's' , 's' ] , fn : ( { api , params } ) => api . child ( `template` ) . once ( 's' ) . then ( snapshot => snapshot . val ( ) ) , nesting : ( { id } ) => [ id ] , caching : true , } ) ; export const itemsTile = createTile ( { type : [ 's' , 's' ] , fn : ( { dispatch , actions , params } ) => Promise . all ( params . ids . map ( id => dispatch ( actions . hn_api . item ( { id } ) ) ) ) } ) ; export const itemsByPageTile = createTile ( { type : [ 's' , 's' ] , fn : async ( { params : { type = 's' , pageNumber = 0 , pageSize = 0 } , selectors , getState , actions , dispatch } ) => { const { data } = await dispatch ( actions . hn_api . stories ( { type } ) ) ; const offset = pageNumber * pageSize ; const end = offset + pageSize ; const ids = data . slice ( offset , end ) ; await dispatch ( actions . hn_api . items ( { ids } ) ) ; return ids . map ( id => { return selectors . hn_api . item ( getState ( ) , { id } ) . data } ) ; } , nesting : ( { type = 's' , pageNumber = 0 , pageSize = 0 } ) => [ type , pageSize , pageNumber ] , } ) ; export const userTile = createTile ( { type : [ 's' , 's' ] , fn : ( { api , params } ) => api . child ( `template` ) . once ( 's' ) . then ( snapshot => snapshot . val ( ) ) , nesting : ( { id } ) => [ id ] , } ) ; export default [ storiesTile , itemTile , itemsTile , itemsByPageTile , userTile , ] ;	O O O $any$ O O O O O O $any$ O $any$ O O $string[]$ O O O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O O O $any$ O O O O $any$ O O $boolean$ O O O O O O O O $any$ O $any$ O O $string[]$ O O O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O O O $any$ O O O O $any$ O O $boolean$ O O O O O O O O $any$ O $any$ O O $string[]$ O O O O O O O $complex$ O O O $any$ O $any$ O $any$ O O O $PromiseConstructor$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O O O O O O $any$ O $any$ O O $string[]$ O O O O O O O $Promise<any>$ O O O O $complex$ O O $string$ O O O $number$ O O O $number$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O $number$ O $number$ O $number$ O O $number$ O $number$ O $number$ O O $any$ O $any$ O $any$ O $number$ O $number$ O O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O O O $complex$ O O O $string$ O O O $number$ O O O $number$ O O O O O O $string$ O $number$ O $number$ O O O O O O O $any$ O $any$ O O $string[]$ O O O O O O O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O $any[]$ O O O $any$ O O O O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O
'js' import { createEntities , createMiddleware } from 's' ; import { createStore , applyMiddleware } from 's' ; import api from 's' ; import tiles from 's' ; const { actions , reducer , selectors } = createEntities ( tiles ) ; const { middleware , waitTiles } = createMiddleware ( { api , actions , selectors } ) ; const store = createStore ( reducer , applyMiddleware ( middleware ) ) ; export default { store , waitTiles , actions , selectors } ;	O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O $any[]$ O O O O O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O $any$ O $any$ O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O O
'js' import app from 's' ; jasmine . DEFAULT_TIMEOUT_INTERVAL = 0 ; test ( 's' , async ( ) => { app . store . dispatch ( app . actions . hn_api . pages ( { type : 's' } ) ) ; await app . waitTiles ( ) ; const state = app . store . getState ( ) ; const { isPending } = app . selectors . hn_api . pages ( state , { type : 's' } ) ; expect ( isPending ) . toBe ( false ) ; } ) ; test ( 's' , async ( ) => { app . store . dispatch ( app . actions . hn_api . pages ( { type : 's' } ) ) ; await app . waitTiles ( ) ; const state = app . store . getState ( ) ; const { data } = app . selectors . hn_api . pages ( state , { type : 's' } ) ; expect ( data . filter ( Boolean ) . length ) . toBe ( 0 ) ; } ) ;	O O $complex$ O O O $any$ O $number$ O O O $any$ O O O O O O O O $complex$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O $complex$ O $any$ O O O O $any$ O $complex$ O $any$ O $any$ O O O O O $any$ O O $complex$ O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O $any$ O $any$ O $complex$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O $complex$ O $any$ O O O O $any$ O $complex$ O $any$ O $any$ O O O O O $any$ O O $complex$ O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O $any$ O $any$ O $any$ O $BooleanConstructor$ O O $any$ O O $any$ O O O O O O O
'js' import { createSyncTile } from 's' ; function createRandomChar ( ) { const number = 0 + Math . floor ( Math . random ( ) * 0 ) ; return String . fromCharCode ( number ) ; } function createId ( ) { let id = 's' ; for ( let i = 0 ; i < 0 ; i ++ ) { id += createRandomChar ( ) ; } return id ; } export const filterTile = createSyncTile ( { type : [ 's' , 's' ] , initialState : 's' , } ) ; export const todosTile = createSyncTile ( { type : [ 's' , 's' ] , fns : { add : ( { params , getData } ) => { const list = getData ( ) ; const newItem = { ... params , completed : false , id : createId ( ) } ; return list . concat ( newItem ) ; } , remove : ( { params , getData } ) => getData ( ) . filter ( item => item . id !== params . id ) , toggle : ( { params , getData } ) => getData ( ) . map ( todo => todo . id === params . id ? { ... todo , completed : ! todo . completed } : todo ) , clearCompleted : ( { params , getData } ) => getData ( ) . filter ( ( { completed } ) => completed === false ) } , initialState : [ ] , } ) ; export default [ todosTile , filterTile ] ;	O O O $any$ O O O O O $string$ O O O O $number$ O O O $Math$ O $number$ O $Math$ O $number$ O O O O O O O $StringConstructor$ O $string$ O $number$ O O O O $string$ O O O O $string$ O O O O O O $number$ O O O $number$ O O O $number$ O O O $string$ O $string$ O O O O O $string$ O O O O $any$ O $any$ O O $string[]$ O O O O O O O $string$ O O O O O O O O $any$ O $any$ O O $string[]$ O O O O O O O $complex$ O O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $any$ O O O $any$ O $boolean$ O O O $string$ O $string$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $boolean$ O O $any$ O $any$ O O $any$ O O $any$ O O O $any$ O $any$ O O O $any$ O O O $any$ O O O $any$ O O O $any$ O O O O O $undefined[]$ O O O O O O O O O O $any$ O $any$ O O
'js' import { createEntities , createMiddleware } from 's' ; import { createStore , applyMiddleware } from 's' ; import tiles from 's' ; export const { actions , reducer , selectors } = createEntities ( tiles ) ; const { middleware } = createMiddleware ( { actions , selectors } ) ; export default createStore ( reducer , applyMiddleware ( middleware ) ) ;	O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any[]$ O O O O O O $any$ O $any$ O $any$ O O $any$ O $any[]$ O O O O $any$ O O $any$ O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O
'js' const tsc = require ( 's' ) ; const tsConfig = require ( 's' ) ; module . exports = { process ( src , path ) { if ( path . endsWith ( 's' ) || path . endsWith ( 's' ) ) { return tsc . transpile ( src , tsConfig . compilerOptions , path , [ ] ) ; } return src ; } , } ;	O O $any$ O $any$ O O O O O $any$ O $any$ O O O O $complex$ O $complex$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $string$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O O O O O
'js' import nodeResolve from 's' ; import commonjs from 's' ; import babel from 's' ; import replace from 's' ; import uglify from 's' ; var env = process . env . NODE_ENV ; var config = { format : 's' , moduleName : 's' , plugins : [ nodeResolve ( { jsnext : true } ) , commonjs ( ) , babel ( { exclude : 's' , presets : 's' , } ) , replace ( { 's' : JSON . stringify ( env ) } ) ] } if ( env === 's' ) { config . plugins . push ( uglify ( { compress : { pure_getters : true , unsafe : true , unsafe_comps : true , warnings : false , 0 : false } , mangle : { 0 : false } , output : { 0 : false } } ) ) ; } export default config ;	O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $complex$ O O $string$ O O O $string$ O O O $any[]$ O O $any$ O O $boolean$ O O O O O $any$ O O O $any$ O O $string$ O O O $string$ O O O O O O $any$ O O O O $JSON$ O $complex$ O $any$ O O O O O O O $any$ O O O O $complex$ O $any[]$ O $number$ O $any$ O O O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O $boolean$ O O O O O O O $boolean$ O O O O O O O $boolean$ O O O O O O O O O O $complex$ O
export function isArray ( arrayToCheck ) { return Array . isArray ( arrayToCheck ) ; } export function isString ( stringToCheck ) { return typeof stringToCheck === "s" ; } export function isFunction ( functionToCheck ) { return typeof functionToCheck === "s" ; } export function get ( object , path : string [ ] ) { return path . reduce ( ( res , key ) => { if ( ! res ) { return undefined ; } return res [ key ] ; } , object ) ; } export function mapValues ( object , cb ) { return Object . keys ( object ) . reduce ( ( hash , key ) => { const value = object [ key ] ; hash [ key ] = cb ( value ) ; return hash ; } , { } ) ; }	O O $boolean$ O $any$ O O O $ArrayConstructor$ O $complex$ O $any$ O O O O O $boolean$ O $any$ O O O O $any$ O O O O O O $boolean$ O $any$ O O O O $any$ O O O O O O $any$ O $any$ O $string[]$ O O O O O O O $string[]$ O $complex$ O O $any$ O $string$ O O O O O O $any$ O O O $undefined$ O O O $any$ O $string$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $ObjectConstructor$ O $complex$ O $any$ O O $complex$ O O $any$ O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O $string$ O O $any$ O $any$ O O O $any$ O O O O O O O O
import { isArray , isString } from "s" ; export function ensureArray ( value : string | string [ ] ) : string [ ] { return isString ( value ) ? [ value as string ] : ( value as string [ ] ) ; } export function populateHash ( hash , path : string [ ] | string , value ) : { [ key ] : any } { if ( isString ( path ) ) { return populateHash ( hash , [ path as string ] , value ) ; } if ( path . length === 0 ) { hash [ path [ 0 ] ] = value ; return hash ; } const property = path [ 0 ] ; if ( ! hash [ property ] ) { hash [ property ] = { } ; } return populateHash ( hash [ property ] , path . slice ( 0 ) , value ) ; } export function iterate ( tiles : any [ ] | { [ key ] : any } ) : any [ ] { return isArray ( tiles ) ? ( tiles as any [ ] ) : Object . keys ( tiles ) . reduce ( ( arr : any [ ] , key ) => { const values = ( tiles as { [ key ] : any } ) [ key ] ; return arr . concat ( values ) ; } , [ ] ) ; } function capitalize ( str , i ) { if ( i === 0 ) { return str ; } return str [ 0 ] . toUpperCase ( ) + str . slice ( 0 ) ; } export function createType ( { type , path } : { type : string | string [ ] ; path ? : null | undefined | string [ ] ; } ) { const list : string [ ] = ensureArray ( type ) . concat ( path == null ? [ ] : path . map ( String ) ) ; return list . map ( capitalize ) . join ( "s" ) ; }	O O $boolean$ O $boolean$ O O O O O O $string[]$ O $complex$ O O O O O O O O O O O O O $boolean$ O $complex$ O O O $complex$ O O O O O $complex$ O O O O O O O O O $complex$ O $any$ O $complex$ O O O O O O O $any$ O O O O $string$ O O O O O O O $boolean$ O $complex$ O O O O $complex$ O $any$ O O $complex$ O O O O $any$ O O O O O $complex$ O $number$ O O O O $any$ O $complex$ O O O O O $any$ O O $any$ O O O $string$ O $complex$ O O O O O O O $any$ O $string$ O O O $any$ O $string$ O O O O O O O $complex$ O $any$ O $string$ O O $complex$ O $string[])$ O O O O $any$ O O O O O $any[]$ O $complex$ O O O O O O O $string$ O O O O O O O O O O O $boolean$ O $complex$ O O O $complex$ O O O O O O $ObjectConstructor$ O $complex$ O $complex$ O O $complex$ O O $any[]$ O O O O O $string$ O O O O $any$ O O $complex$ O O O $string$ O O O O O O $string$ O O O $any[]$ O $complex$ O $any$ O O O O O O O O O O $string$ O $string$ O $number$ O O O O $number$ O O O O O $string$ O O O $string$ O O O O $string$ O O O $string$ O $string$ O O O O O O O $string$ O O $complex$ O $string[]$ O O O $complex$ O O O O O O O $string[]$ O O O O O O O O O O O O O O $string[]$ O O O O O $string[]$ O $complex$ O O $complex$ O $string[]$ O O O O O O $string[]$ O $U[]$ O $StringConstructor$ O O O O $string[]$ O $U[]$ O $string$ O O $string$ O O O O O
export type ReducerObject = { [ key ] : Function | Object } ; export interface IOverloadedAction { ( params ? , additionalParams ? ) : any ; [ key ] : any ; } export interface ITile { tileName : string | string [ ] ; action : IOverloadedAction ; reducer : Function ; selectors : { get : Function ; getAll : Function ; } ; constants : { [ key ] : string ; } ; reflect : ITileParams | ISyncTileParams ; } export interface ITileParams { type : string | string [ ] ; fn : Function ; caching ? : boolean ; initialState ? : any ; nesting ? : ( ( params ) => string [ ] ) | undefined ; selectorFallback ? : any ; } export interface ISyncTileParams { type : string | string [ ] ; fn ? : Function ; fns ? : { [ key ] : ( params ? , additionalParams ? ) => any } ; nesting ? : ( ( params ) => string [ ] ) | undefined ; initialState ? : any ; selectorFallback ? : any ; } export interface IAsyncActionTypes { type : string | string [ ] ; START : string ; SUCCESS : string ; FAILURE : string ; fn : Function ; caching ? : boolean ; nesting ? : Function | undefined ; selectors : { get : Function ; } ; } export interface ISyncActionTypes { SET : string ; fn : Function ; nesting : ( ( params ) => string [ ] ) | undefined ; selector : Function ; } export interface IPromiseObject { [ key ] : Promise < any > | undefined ; } export interface ICreateSelectorsTypes { tileName : string | string [ ] ; nesting : ( ( params ) => string [ ] ) | undefined ; selectorFallback : any ; } export interface IData { isPending : boolean ; error : any ; data : any ; fetched : boolean ; } export type SyncData = any ; export interface ISelectors { get ( state , params ? ) : IData | SyncData ; getAll ( state ) : { } ; }	O O $any$ O O O $string$ O O $FunctionConstructor$ O $ObjectConstructor$ O O O O $any$ O O $any$ $any$ O $any$ $any$ O O O O O $string$ O O O O O O O $any$ O $complex$ O O O O O O O $IOverloadedAction$ O $any$ O $Function$ O $FunctionConstructor$ O $complex$ O O $Function$ O $FunctionConstructor$ O $Function$ O $FunctionConstructor$ O O O $complex$ O O O $string$ O O O O O O $complex$ O $any$ O $any$ O O O O $any$ O $complex$ O O O O O O O $Function$ O $FunctionConstructor$ O $boolean$ O O O O $any$ O O O O $string[]$ O O O O $any$ O O O O O O O O O $any$ O O O O O O O $any$ O $complex$ O O O O O O O $Function$ O O $FunctionConstructor$ O $complex$ O O O O $string$ O O O $any$ $any$ O $any$ $any$ O O O O O $string[]$ O O O O $any$ O O O O O O O O O $any$ O O O O $any$ O O O O O O O $any$ O $complex$ O O O O O O O $string$ O O O $string$ O O O $string$ O O O $Function$ O $FunctionConstructor$ O $boolean$ O O O O $Function$ O O $FunctionConstructor$ O O O $complex$ O O $Function$ O $FunctionConstructor$ O O O O O O $any$ O $string$ O O O $Function$ O $FunctionConstructor$ O $string[]$ O O O $any$ O O O O O O O O O $Function$ O $FunctionConstructor$ O O O O $any$ O O $string$ O O $PromiseConstructor$ O O O O O O O O O $any$ O $complex$ O O O O O O O $string[]$ O O O $any$ O O O O O O O O O $any$ O O O O O O $any$ O $boolean$ O O O $any$ O O O $any$ O O O $boolean$ O O O O O O $any$ O O O O O $any$ O $any$ O $any$ O $any$ $any$ O O $any$ O $any$ O ${}$ O $any$ O O O O O O
import { iterate , populateHash } from "s" ; import { IPromiseObject , ITile } from "s" ; import { isArray } from "s" ; export function createActions ( tiles : ITile [ ] ) { return iterate ( tiles ) . reduce ( ( hash , tile ) => { populateHash ( hash , tile . tileName , tile . action ) ; return hash ; } , { } ) ; }	O O $any[]$ O $complex$ O O O O O O $any$ O $any$ O O O O O O $boolean$ O O O O O O $any$ O $ITile[]$ O $any$ O O O O O $any[]$ O $ITile[]$ O O $complex$ O O $any$ O $ITile$ O O O $complex$ O $any$ O $ITile$ O $complex$ O $ITile$ O $IOverloadedAction$ O O O $any$ O O O O O O O O
import { createType , ensureArray } from "s" ; import { get , isString } from "s" ; import { ICreateSelectorsTypes , IData , ISelectors , SyncData } from "s" ; export let DEFAULT_REDUCER = "s" ; export function changeDefaultReducer ( newReducer ) { DEFAULT_REDUCER = newReducer ; } export function getTopReducer ( ) { return DEFAULT_REDUCER ; } function checkValue ( result , defaultValue ? ) : { } { return result === undefined || result === null ? defaultValue : result ; } interface ILookupParams { selectorFallback : any ; state : Object ; params : any ; nesting : ( ( params ) => string [ ] ) | undefined ; tileName : string | string [ ] ; } function lookup ( { state , params , nesting , tileName , selectorFallback } ) : IData | SyncData { let path : string [ ] = [ ] ; const topReducer = DEFAULT_REDUCER ; if ( nesting ) { path = nesting ( params ) ; } const nestedNames : string [ ] = ensureArray ( tileName ) ; const topReducerArray : string [ ] = Boolean ( topReducer ) ? [ topReducer ] : [ ] ; return checkValue ( get ( state , [ ... topReducerArray , ... nestedNames , ... path ] ) , selectorFallback ) ; } interface ICheckArgumentsParams { state : { } ; params : any ; tileName : string | string [ ] ; fn : Function ; } function checkArguments ( { state , params , tileName , fn } ) : { } { if ( ! state ) { throw new Error ( `template` ) ; } return fn ( state , params ) ; } export function createSelectors ( { tileName , nesting , selectorFallback } ) { const getAll = ( state ) : any => { const topReducerArray : string [ ] = Boolean ( DEFAULT_REDUCER ) ? [ DEFAULT_REDUCER ] : [ ] ; return checkValue ( get ( state , [ ... topReducerArray , ... ensureArray ( tileName ) ] ) ) ; } ; const getSpecific = ( state : { } , params ) : IData | SyncData => lookup ( { state , params , nesting , tileName , selectorFallback } ) ; return { getAll : ( state ) : { } => checkArguments ( { state , tileName , fn : getAll } as any ) , get : ( state , params ? ) : IData | SyncData => checkArguments ( { state , params , tileName , fn : getSpecific } ) } ; }	O O $string$ O $string[]$ O O O O O O $any$ O $boolean$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $string$ O O O O O $void$ O $string$ O O $string$ O $string$ O O O O $string$ O O O O $string$ O O O ${}$ O $any$ O $any$ $any$ O O O O O O $any$ O $undefined$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $Object$ O $ObjectConstructor$ O $any$ O O O $string[]$ O O O $any$ O O O O O O O O O $complex$ O O O O O O O O O $any$ O O $Object$ O $any$ O $string[]$ O $complex$ O $any$ $ILookupParams$ O O $any$ O $any$ O O $string[]$ O O O O O O O O O $string$ O $string$ O O O $string[]$ O O $string[]$ O $string[]$ O $any$ O O O O $string[]$ O O O O O $string[]$ O $complex$ O O O $string[]$ O O O O O $BooleanConstructor$ O $string$ O O O $string$ O O O O O O ${}$ O $any$ O $Object$ O O O $string[]$ O O $string[]$ O O $string[]$ O O O $any$ O O O O $any$ O ${}$ O O O O $any$ O O O $complex$ O O O O O O O $Function$ O $FunctionConstructor$ O O O ${}$ O O ${}$ O $any$ O $complex$ O $Function$ $ICheckArgumentsParams$ O O O O O O O O ${}$ O O O O $ErrorConstructor$ O O O O O O $Function$ O ${}$ O $any$ O O O O O $ISelectors$ O O $complex$ O $string[]$ O $any$ $ICreateSelectorsTypes$ O O O $Function$ O O $any$ O O O O O O $string[]$ O O O O O $BooleanConstructor$ O $string$ O O O $string$ O O O O O O ${}$ O $any$ O $any$ O O O $string[]$ O O $string[]$ O $complex$ O O O O O O O O $Function$ O O ${}$ O O O O $any$ O O $any$ O $any$ O $any$ O O ${}$ O $any$ O $string[]$ O $complex$ O $any$ O O O O O ${}$ O O $any$ O O O O O ${}$ O O $any$ O $complex$ O $Function$ O $Function$ O O O O O $any$ O O $any$ O $any$ $any$ O O $any$ O $any$ O ${}$ O O $any$ O $any$ O $complex$ O $Function$ O $Function$ O O O O O
import { combineReducers , Reducer } from "s" ; import { iterate , populateHash } from "s" ; import { changeDefaultReducer , DEFAULT_REDUCER } from "s" ; import { ITile } from "s" ; import { isFunction , isString } from "s" ; export function createNestedReducers ( value ) < any > { return combineReducers ( Object . keys ( value ) . reduce ( ( hash , key ) => { const elem : Function | { } = value [ key ] ; hash [ key ] = isFunction ( elem ) ? elem : createNestedReducers ( elem ) ; return hash ; } , { } ) ) ; } export function createReducers ( modules : ITile [ ] , topReducer = DEFAULT_REDUCER ) < any > { if ( topReducer !== DEFAULT_REDUCER ) { changeDefaultReducer ( topReducer ) ; } const nestedModules = iterate ( modules ) . reduce ( ( hash , module ) => { populateHash ( hash , module . tileName , module . reducer ) ; return hash ; } , { } ) ; return createNestedReducers ( nestedModules ) ; }	O O $any$ O $any$ O O O O O O $any[]$ O $complex$ O O O O O O $void$ O $string$ O O O O O O $any$ O O O O O O $boolean$ O $boolean$ O O O O O O $Reducer$ O $any$ O O O O O O $any$ O $ObjectConstructor$ O $complex$ O $any$ O O $complex$ O O $any$ O $string$ O O O O $complex$ O $FunctionConstructor$ O O O O $any$ O $string$ O O $any$ O $string$ O O $boolean$ O $complex$ O O $complex$ O $any$ O $complex$ O O O $any$ O O O O O O O O O O O $Reducer$ O $ITile[]$ O $any$ O O O $string$ O $string$ O O O O O O O $string$ O $string$ O O $void$ O $string$ O O O O $any$ O $any[]$ O $ITile[]$ O O $complex$ O O $any$ O $ITile$ O O O $complex$ O $any$ O $ITile$ O $complex$ O $ITile$ O $Function$ O O O $any$ O O O O O O O O $any$ O $any$ O O O
import { iterate , populateHash } from "s" ; import { ITile } from "s" ; export function createSelectors ( tiles : ITile [ ] | { [ key ] : ITile } ) { return iterate ( tiles ) . reduce ( ( hash , tile ) => { const selector = tile . selectors . get ; selector . getAll = tile . selectors . getAll ; populateHash ( hash , tile . tileName , selector ) ; return hash ; } , { } ) ; }	O O $any[]$ O $complex$ O O O O O O $any$ O O O O O O $any$ O $complex$ O $any$ O O O O O $string$ O O $any$ O O O O $any[]$ O $complex$ O O $complex$ O O $any$ O $ITile$ O O O O $any$ O $ITile$ O $complex$ O $Function$ O $any$ O $any$ O $ITile$ O $complex$ O $Function$ O $complex$ O $any$ O $ITile$ O $complex$ O $any$ O O O $any$ O O O O O O O O
import { createActions } from "s" ; import { createReducers } from "s" ; import { createSelectors } from "s" ; import { ITile } from "s" ; export function createEntities ( tiles : ITile [ ] , topReducer ? ) { return { actions : createActions ( tiles ) , reducer : createReducers ( tiles , topReducer ) , selectors : createSelectors ( tiles ) } ; }	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O $ITile[]$ O $any$ O O O $string$ $string$ O O O O $any$ O $any$ O $ITile[]$ O O $any$ O $any$ O $ITile[]$ O $string$ O O $any$ O $any$ O $ITile[]$ O O O O
import { IPromiseObject } from "s" ; export function waitTiles ( promisesStorage ) < any > { const promises : ( Promise < any > | undefined ) [ ] = Object . keys ( promisesStorage ) . map ( ( key ) => promisesStorage [ key ] ) . filter ( Boolean ) ; return Promise . all ( promises ) ; }	O O $any$ O O O O O O $Promise$ O $IPromiseObject$ O O O O O O $Promise<any>[]$ O O $PromiseConstructor$ O O O O O O O O O $ObjectConstructor$ O $complex$ O $IPromiseObject$ O O $U[]$ O O $string$ O O $IPromiseObject$ O $string$ O O O $complex$ O $BooleanConstructor$ O O O $PromiseConstructor$ O O O $Promise<any>[]$ O O O
import { Action , Dispatch , Middleware } from "s" ; import { IPromiseObject } from "s" ; import { waitTiles } from "s" ; export function createMiddleware ( paramsToInject = { } ) : { middleware : Middleware ; waitTiles : Function } { const promisesStorage = { } ; const middleware = ( { dispatch , getState } : { dispatch : Dispatch < any > ; getState ( ) : any ; } ) : ( ( next < any > ) => Dispatch < any > ) => ( next < any > ) : Dispatch < any > => ( action ) : any => { if ( typeof action === "s" ) { return action ( { dispatch , getState , promisesStorage , ... paramsToInject } ) ; } return next ( action ) ; } ; return { middleware , waitTiles : waitTiles . bind ( null , promisesStorage ) } ; }	O O $any$ O $any$ O $any$ O O O O O O $any$ O O O O O O $Promise<any>$ O O O O O O $complex$ O $any$ O O O O O O $any$ O $any$ O $Function$ O $FunctionConstructor$ O O O $IPromiseObject$ O O O O O $Middleware$ O O O $any$ O $any$ O O O $any$ O $any$ O O O O $any$ O O O O O O O O O O $Dispatch$ O O O O O $any$ O O O O O O $Dispatch$ O O O O O $any$ O O O O O $Action$ O O O O O O O O $any$ O O O O O $any$ O O $any$ O $any$ O $IPromiseObject$ O O $any$ O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $Promise<any>$ O $any$ O O O $IPromiseObject$ O O O O
import { Dispatch } from "s" ; import { createType , ensureArray } from "s" ; import { getTopReducer } from "s" ; import { IAsyncActionTypes , IPromiseObject , ISyncActionTypes } from "s" ; interface IProcessedMiddleware { dispatch : Dispatch < { } > ; getState ( ) : { } ; [ key ] : any ; } export type FnResult = ( params , additionalParams ? ) => any ; function proccessMiddleware ( args : any [ ] ) { if ( args . length === 0 ) { return { dispatch : args [ 0 ] , getState : args [ 0 ] , ... args [ 0 ] } ; } else if ( args . length === 0 ) { return { dispatch : args [ 0 ] , getState : args [ 0 ] } ; } else if ( args . length === 0 && typeof args [ 0 ] === "s" ) { return args [ 0 ] ; } throw new Error ( "s" ) ; } export function shouldBeFetched ( { isPending , fetched , error } ) { if ( isPending ) { return false ; } if ( fetched === false ) { return true ; } if ( error != null ) { return true ; } return false ; } function handleMiddleware ( fn ) { return ( fnParams , additionalParams ) : Function => ( ... args : any [ ] ) : any => fn ( proccessMiddleware ( args ) , fnParams , additionalParams ) ; } export function asyncAction ( { START , SUCCESS , FAILURE , fn , type , caching , nesting , selectors } ) { return handleMiddleware ( ( { dispatch , getState , promisesStorage = { } , ... middlewares } : { dispatch : Dispatch < { } > ; promisesStorage : IPromiseObject ; getState ( ) : { } ; } , params , { forceAsync } : { forceAsync ? : boolean } = { } ) => { const path : string [ ] | null = nesting ? nesting ( params ) : null ; const getIdentificator = createType ( { type , path } ) ; if ( caching ) { const activePromise : Promise < any > | undefined = promisesStorage [ getIdentificator ] ; if ( activePromise ) { return activePromise ; } } if ( caching && ! forceAsync ) { const { isPending , fetched , error , data } = selectors . get ( getState ( ) , params ) ; const isFetchingNeeded = shouldBeFetched ( { isPending , fetched , error } ) ; if ( ! isFetchingNeeded ) { return Promise . resolve ( { data , error , isPending } ) ; } } dispatch ( { type : START , payload : { path } , isPending : true } ) ; const promise < any > = fn ( { params , dispatch , getState , ... middlewares } ) . then ( ( data ) => { promisesStorage [ getIdentificator ] = undefined ; return dispatch ( { type : SUCCESS , payload : { path , data } , data , isPending : false } ) ; } ) . catch ( ( error ) => { promisesStorage [ getIdentificator ] = undefined ; return dispatch ( { error , type : FAILURE , payload : { path } , isPending : false } ) ; } ) ; promisesStorage [ getIdentificator ] = promise ; return promise ; } ) ; } export function createResetAction ( { type } : { type : string } ) { return handleMiddleware ( ( { dispatch } : { dispatch : Dispatch < any > } ) => dispatch ( { type } ) ) ; } export function syncAction ( { SET , fn , nesting , selector } ) { return handleMiddleware ( ( { dispatch , getState , ... middlewares } , params ) => { const path : string [ ] | null = nesting ? nesting ( params ) : null ; const getData = ( ) => selector ( getState ( ) , params ) ; const data = fn ( { params , dispatch , getState , getData , ... middlewares } ) ; return dispatch ( { type : SET , payload : { path , data } , data } ) ; } ) ; }	O O $any$ O O O O O O $string$ O $string[]$ O O O O O O $string$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O ${}$ O O O O O O O $string$ O O O O O O O $any$ O O $any$ O $any$ $any$ O O O O O $IProcessedMiddleware$ O $any[]$ O O O O O O O O $any[]$ O $number$ O O O O O O $any$ O $any[]$ O O O O $any$ O $any[]$ O O O O O $any[]$ O O O O O O O O O $any[]$ O $number$ O O O O O O $any$ O $any[]$ O O O O $any$ O $any[]$ O O O O O O O O O $any[]$ O $number$ O O O O $any[]$ O O O O O O O O $any[]$ O O O O O O O $ErrorConstructor$ O O O O O O O $boolean$ O O $any$ O $any$ O $any$ $any$ O O O O $any$ O O O O O O O O $any$ O O O O O O O O O O $any$ O O O O O O O O O O O O O $FnResult$ O $Function$ O O O O $any$ O $any$ O O $FunctionConstructor$ O O O $any[]$ O O O O O O O O $Function$ O $IProcessedMiddleware$ O $any[]$ O O $any$ O $any$ O O O O O $FnResult$ O O $string$ O $string$ O $string$ O $Function$ O $complex$ O $boolean$ O $Function$ O $complex$ $IAsyncActionTypes$ O O O $FnResult$ O O O $any$ O ${}$ O $IPromiseObject$ O O O O O ${}$ O O O $any$ O $any$ O O O O O $IPromiseObject$ O $any$ O ${}$ O O O O O O O O $any$ O O $boolean$ O O O $boolean$ O O O O O O O O O O O $string[]$ O O O O O O O $Function$ O $Function$ O $any$ O O O O O $string$ O $string$ O O $complex$ O $string[]$ O O O O O $boolean$ O O O $Promise<any>$ O $PromiseConstructor$ O O O O O O $IPromiseObject$ O $string$ O O O O $Promise<any>$ O O O $Promise<any>$ O O O O O $boolean$ O O $boolean$ O O O O $any$ O $any$ O $any$ O $any$ O O $complex$ O $Function$ O ${}$ O O O $any$ O O O $boolean$ O $boolean$ O O $any$ O $any$ O $any$ O O O O O O $boolean$ O O O $PromiseConstructor$ O $complex$ O O $any$ O $any$ O $any$ O O O O O $any$ O O $string$ O $string$ O $complex$ O O $string[]$ O O $boolean$ O O O O O O $Promise$ O O O O $Function$ O O $any$ O $any$ O ${}$ O O ${}$ O O O $any$ O O $any$ O O O $IPromiseObject$ O $string$ O O $undefined$ O O $any$ O O $string$ O $string$ O $complex$ O O $string[]$ O $any$ O O $any$ O $boolean$ O O O O O O O O $any$ O O $any$ O O O $IPromiseObject$ O $string$ O O $undefined$ O O $any$ O O $any$ O $string$ O $string$ O $complex$ O O $string[]$ O O $boolean$ O O O O O O O O $IPromiseObject$ O $string$ O O $Promise<any>$ O O $Promise<any>$ O O O O O O O $Function$ O O $string$ O O O $string$ O O O O O O $FnResult$ O O O $any$ O O O $any$ O $any$ O O O O O O $any$ O O $string$ O O O O O O O $FnResult$ O O $string$ O $Function$ O $string[]$ O $Function$ $ISyncActionTypes$ O O O $FnResult$ O O O $any$ O $any$ O O $any$ $any$ O $any$ O O O O $string[]$ O O O O O O O $string[]$ O $string[]$ O $any$ O O O O O $any$ O O O O $Function$ O $any$ O O O $any$ O O O $any$ O $Function$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O O $string$ O $string$ O $complex$ O O $string[]$ O $any$ O O $any$ O O O O O O O
import { Action , Reducer } from "s" ; import { get , isFunction , mapValues } from "s" ; import { ReducerObject } from "s" ; export function createReducerFromObject ( initialState , handlers ) < any > { return function reducer ( state : { } = initialState , action ) : { } { const handler : Function | { } = handlers [ action . type ] ; return typeof handler === "s" ? handler ( state , action ) : state ; } ; } export function createReducer ( initialState , handlers ) < any > { return createReducerFromObject ( initialState , mapValues ( handlers , ( value ) => ( state , action ) : any => reducerCreator ( { state , action , newValue : isFunction ( value ) ? value ( state , action ) : value } ) ) ) ; } export function reducerCreator ( { action , state , newValue } ) { const { path } = action . payload ; const hasNoNestInStore = ! path ; if ( hasNoNestInStore ) { return newValue ; } let result = { } ; let lookupPath : string [ ] ; const length = path . length ; for ( let i = length - 0 ; i >= 0 ; i = i - 0 ) { const el = path [ i ] ; const isLastItem = i === path . length - 0 ; const newNestedResult = { [ el ] : isLastItem ? newValue : result } ; lookupPath = path . slice ( 0 , i ) ; const oldState = get ( state , lookupPath ) || { } ; result = { ... oldState , ... newNestedResult } ; } return { ... state , ... result } ; }	O O $any$ O $any$ O O O O O O $any$ O $boolean$ O $any$ O O O O O O $any$ O O O O O O $Reducer$ O $any$ O $ReducerObject$ O O O O O O O ${}$ O ${}$ O O O O $any$ O $Action$ O O O O O O $complex$ O $FunctionConstructor$ O O O O $ReducerObject$ O $any$ O $any$ O O O O $complex$ O O O $Function$ O ${}$ O $any$ O O ${}$ O O O O O O $Reducer$ O $any$ O $ReducerObject$ O O O O O O $any$ O $any$ O $any$ O $ReducerObject$ O O $any$ O O O $any$ O $Action$ O O O O $any$ O O $any$ O $any$ O $any$ O $boolean$ O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O O $any$ O O $any$ O $any$ O $any$ $any$ O O O O $any$ O O $any$ O $any$ O O $boolean$ O O $any$ O O O $boolean$ O O O $any$ O O O $any$ O O O O O $string[]$ O O O O O O $number$ O $any$ O $any$ O O O O $number$ O $number$ O O O $number$ O O O $number$ O $number$ O O O O O $string$ O $any$ O $number$ O O O $boolean$ O $number$ O $any$ O $any$ O O O O $any$ O O O $string$ O O $boolean$ O $any$ O $any$ O O $string[]$ O $any$ O $any$ O O O $number$ O O O $any$ O $any$ O $any$ O $string[]$ O O O O O $any$ O O O $any$ O O $any$ O O O O O O $any$ O O $any$ O O O
import { Reducer } from "s" ; import { createType } from "s" ; import { asyncAction , createResetAction , syncAction } from "s" ; import { createReducer } from "s" ; import { createSelectors } from "s" ; import { IAsyncActionTypes , ICreateSelectorsTypes , IData , IOverloadedAction , ISelectors , ISyncActionTypes , ISyncTileParams , ITile , ITileParams , ReducerObject , SyncData } from "s" ; const prefix = "s" ; export interface ITypes { [ key ] : string ; } export interface IReducerAction { payload : { data : any } | undefined ; error : string | Object | undefined | null ; } export function createTile ( params ) { const { type , fn , caching , nesting , selectorFallback = null } = params ; const initialState = nesting ? { } : null ; const identificator = createType ( { type } ) ; const types = { START : `template` , SUCCESS : `template` , FAILURE : `template` , RESET : `template` } ; const selectorParams = { selectorFallback : { isPending : false , error : null , data : selectorFallback , fetched : false } , tileName : type , nesting } ; const selectors = createSelectors ( selectorParams ) ; const actionParams = { START : types . START , SUCCESS : types . SUCCESS , FAILURE : types . FAILURE , fn , type , caching , nesting , selectors } ; const action = asyncAction ( actionParams ) ; action . reset = createResetAction ( { type : types . RESET } ) ; const reducerObject = { [ types . START ] : { data : null , isPending : true , error : null , fetched : false } , [ types . FAILURE ] : ( _storeState : { } , storeAction ) : IData => ( { data : null , isPending : false , error : storeAction . error , fetched : true } ) , [ types . SUCCESS ] : ( _storeState : { } , storeAction ) : IData => ( { error : null , isPending : false , data : storeAction . payload && storeAction . payload . data , fetched : true } ) , [ types . RESET ] : initialState } ; const reducer < any > = createReducer ( initialState , reducerObject ) ; return { action , reducer , selectors , tileName : type , constants : types , reflect : params } ; } export function createSyncTile ( params ) { const { type , nesting , fn = ( fnParams ) : any => fnParams . params , fns , initialState = nesting ? { } : null , selectorFallback } = params ; const identificator = createType ( { type } ) ; const types = { SET : `template` , RESET : `template` } ; const selectorParams = { selectorFallback , tileName : type , nesting } ; const selectors = createSelectors ( selectorParams ) ; const actionParams = { SET : types . SET , nesting , fn , selector : selectors . get } ; const action = syncAction ( actionParams ) ; action . reset = createResetAction ( { type : types . RESET } ) ; if ( fns ) { Object . keys ( fns ) . forEach ( ( methodName ) => { const method = fns [ methodName ] ; const customActionParams = { ... actionParams , fn : method } ; action [ methodName ] = syncAction ( customActionParams ) ; } ) ; } const reducerObject = { [ types . SET ] : ( _storeState : { } , storeAction ) : SyncData => storeAction . payload && storeAction . payload . data , [ types . RESET ] : initialState } ; const reducer < any > = createReducer ( initialState , reducerObject ) ; return { action , selectors , reducer , tileName : type , constants : types , reflect : params } ; }	O O $any$ O O O O O O $string$ O O O O O O $FnResult$ O $Function$ O $FnResult$ O O O O O O $any$ O O O O O O $ISelectors$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $string$ O O O O O $any$ O O $string$ O O O O O O O $any$ O $complex$ O O $any$ O O O O O O $complex$ O O O $ObjectConstructor$ O O O O O O O O $ITile$ O $ITileParams$ O O O O $complex$ O $Function$ O $boolean$ O $string[]$ O $any$ O O O O $ITileParams$ O O $any$ O $string[]$ O O O O O O O $string$ O $string$ O O $complex$ O O O O $ITypes$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O $ICreateSelectorsTypes$ O O $complex$ O O $boolean$ O O O $null$ O O O $any$ O $any$ O $boolean$ O O O O $complex$ O $complex$ O $string[]$ O O O $ISelectors$ O $ISelectors$ O $ICreateSelectorsTypes$ O O O $IAsyncActionTypes$ O O $string$ O $ITypes$ O $any$ O $string$ O $ITypes$ O $any$ O $string$ O $ITypes$ O $any$ O $Function$ O $complex$ O $boolean$ O $string[]$ O $ISelectors$ O O O $IOverloadedAction$ O $FnResult$ O $IAsyncActionTypes$ O O $IOverloadedAction$ O $any$ O $Function$ O O $string$ O $ITypes$ O $any$ O O O O $ReducerObject$ O O O $ITypes$ O $any$ O O O $null$ O O O $boolean$ O O O $null$ O O O $boolean$ O O O O O $ITypes$ O $any$ O O O ${}$ O O O O $IReducerAction$ O O $any$ O O O $null$ O O O $false$ O O O $complex$ O $IReducerAction$ O $complex$ O $true$ O O O O O O $ITypes$ O $any$ O O O ${}$ O O O O $IReducerAction$ O O $any$ O O O $null$ O O O $false$ O O O $any$ O $IReducerAction$ O $complex$ O $IReducerAction$ O $complex$ O $any$ O $true$ O O O O O O $ITypes$ O $any$ O O $any$ O O O $Reducer$ O O O O $any$ O $any$ O $ReducerObject$ O O O O $IOverloadedAction$ O $any$ O $ISelectors$ O $complex$ O $complex$ O $ITypes$ O $ITypes$ O $ITileParams$ O $ITileParams$ O O O O O $ITile$ O $ISyncTileParams$ O O O O $complex$ O $string[]$ O $Function$ O O $any$ O O O O $any$ O $any$ O $complex$ O $any$ O $string[]$ O O O O O O $any$ O O $ISyncTileParams$ O O $string$ O $string$ O O $complex$ O O O O $ITypes$ O O $string$ O O O $string$ O O O O O $ICreateSelectorsTypes$ O O $any$ O $complex$ O $complex$ O $string[]$ O O O $ISelectors$ O $ISelectors$ O $ICreateSelectorsTypes$ O O O $ISyncActionTypes$ O O $string$ O $ITypes$ O $any$ O $string[]$ O $Function$ O $any$ O $ISelectors$ O $any$ O O O $IOverloadedAction$ O $FnResult$ O $ISyncActionTypes$ O O $IOverloadedAction$ O $any$ O $Function$ O O $string$ O $ITypes$ O $any$ O O O O O $complex$ O O $ObjectConstructor$ O $complex$ O $complex$ O O $void$ O O $string$ O O O O $any$ O $complex$ O $string$ O O O $ISyncActionTypes$ O O O $ISyncActionTypes$ O $any$ O $any$ O O $IOverloadedAction$ O $string$ O O $FnResult$ O $ISyncActionTypes$ O O O O O O O $ReducerObject$ O O O $ITypes$ O $any$ O O O ${}$ O O O O $IReducerAction$ O O $any$ O $IReducerAction$ O $complex$ O $IReducerAction$ O $complex$ O $any$ O O $ITypes$ O $any$ O O $any$ O O O $Reducer$ O O O O $any$ O $any$ O $ReducerObject$ O O O O $IOverloadedAction$ O $ISelectors$ O $any$ O $complex$ O $complex$ O $ITypes$ O $ITypes$ O $ISyncTileParams$ O $ISyncTileParams$ O O O
import { createActions } from "s" ; import { createEntities } from "s" ; import { createReducers } from "s" ; import { createSelectors } from "s" ; import { createMiddleware } from "s" ; import { createSyncTile , createTile } from "s" ; export { createTile , createSyncTile , createReducers , createActions , createSelectors , createMiddleware , createEntities } ;	O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O O $complex$ O O O O O O $ITile$ O $ITile$ O O O O O O $ITile$ O $ITile$ O $any$ O $any$ O $any$ O $complex$ O $any$ O O
import { spy , stub } from "s" ; import { createTile , createSyncTile } from "s" ; import { asyncAction , syncAction } from "s" ; test ( "s" , ( ) => { const tile = createTile ( { type : "s" } ) ; expect ( tile . action ) . toBeInstanceOf ( Function ) ; } ) ; test ( "s" , ( ) => { const fn = stub ( ) . returns ( Promise . resolve ( ) ) ; const tile = createTile ( { type : "s" , fn } ) ; const dispatch = ( ) => { } ; const getState = ( ) => { } ; const params = { } ; tile . action ( params ) ( dispatch , getState ) ; expect ( fn . calledWith ( { dispatch , getState , params } ) ) . toBe ( true ) ; } ) ; test ( "s" , ( ) => { const fn = stub ( ) . returns ( Promise . resolve ( ) ) ; const tile = createTile ( { type : "s" , fn } ) ; const dispatch = ( ) => { } ; const getState = ( ) => { } ; const params = { } ; const additionalParams = { some : true } ; tile . action ( params ) ( dispatch , getState , additionalParams ) ; expect ( fn . calledWith ( { dispatch , getState , params , some : true } ) ) . toBe ( true ) ; } ) ; test ( "s" , ( ) => { const fn = stub ( ) . returns ( Promise . resolve ( ) ) ; const tile = createTile ( { type : "s" , fn } ) ; const dispatch = ( ) => { } ; const getState = ( ) => { } ; const actions = { some : ( ) => { } } ; const params = { } ; tile . action ( params ) ( { dispatch , getState , actions } ) ; expect ( fn . calledWith ( { dispatch , getState , params , actions } ) ) . toBe ( true ) ; } ) ; test ( "s" , async ( ) => { const fn = stub ( ) ; fn . returns ( new Promise ( res => res ( { data : true } ) ) ) ; const START = "s" ; const SUCCESS = "s" ; const action = asyncAction ( { type : [ "s" ] , START , SUCCESS , fn } ) ; const dispatch = spy ( ) ; const getState = spy ( ) ; await action ( { id : 0 } ) ( { dispatch , getState } ) ; expect ( dispatch . calledTwice ) . toBe ( true ) ; expect ( dispatch . calledTwice ) . toBe ( true ) ; } ) ; test ( "s" , async ( ) => { const fn = stub ( ) ; fn . returns ( new Promise ( res => res ( { data : true } ) ) ) ; const START = "s" ; const SUCCESS = "s" ; const action = asyncAction ( { type : [ "s" ] , START , SUCCESS , fn } ) ; const dispatch = spy ( ) ; const getState = spy ( ) ; await action ( { id : 0 } ) ( { dispatch , getState } ) ; const firstDispatch = dispatch . getCall ( 0 ) ; const secondDispatch = dispatch . getCall ( 0 ) ; expect ( firstDispatch . args [ 0 ] . type ) . toBe ( START ) ; expect ( secondDispatch . args [ 0 ] . type ) . toBe ( SUCCESS ) ; } ) ; test ( "s" , async ( ) => { const fn = stub ( ) ; fn . returns ( new Promise ( ( res , reject ) => reject ( { error : "s" } ) ) ) ; const START = "s" ; const FAILURE = "s" ; const SUCCESS = "s" ; const action = asyncAction ( { type : [ "s" ] , START , FAILURE , SUCCESS , fn } ) ; const dispatch = spy ( ) ; const getState = spy ( ) ; await action ( { id : 0 } ) ( { dispatch , getState } ) ; const secondDispatch = dispatch . getCall ( 0 ) ; expect ( secondDispatch . args [ 0 ] . type ) . toBe ( FAILURE ) ; } ) ; test ( "s" , async ( ) => { const START = "s" ; const FAILURE = "s" ; const SUCCESS = "s" ; const action = asyncAction ( { type : "s" , START , FAILURE , SUCCESS , selectors : { get : ( ) => ( { isPending : true , error : null , fetched : false } ) } , fn : ( ) => Promise . resolve ( 0 ) , caching : true } ) ; const dispatch = spy ( ) ; const getState = spy ( ) ; await action ( { id : 0 } ) ( { dispatch , getState } ) ; expect ( dispatch . notCalled ) . toBe ( true ) ; } ) ; test ( "s" , async ( ) => { const START = "s" ; const FAILURE = "s" ; const SUCCESS = "s" ; const action = asyncAction ( { type : [ "s" ] , START , FAILURE , SUCCESS , selectors : { get : ( ) => ( { isPending : false , data : { a : "s" } } ) } , caching : true } ) ; const dispatch = spy ( ) ; const getState = spy ( ) ; await action ( { id : 0 } ) ( { dispatch , getState } ) ; expect ( dispatch . notCalled ) . toBe ( true ) ; } ) ; test ( "s" , async ( ) => { const START = "s" ; const FAILURE = "s" ; const SUCCESS = "s" ; const action = asyncAction ( { type : [ "s" ] , START , FAILURE , SUCCESS , selectors : { get : ( ) => ( { isLoading : false , data : { a : "s" } } ) } , fn : ( ) => Promise . resolve ( ) , caching : true } ) ; const dispatch = spy ( ) ; const getState = spy ( ) ; await action ( { id : 0 } , { forceAsync : true } ) ( { dispatch , getState } ) ; expect ( dispatch . callCount ) . toBe ( 0 ) ; } ) ; test ( "s" , ( ) => { const TYPE = "s" ; const params = { some : true } ; const action = syncAction ( { type : [ "s" ] , TYPE , fn : ( ) => params } ) ; const dispatch = spy ( ) ; const getState = ( ) => { } ; const selectors = { type : ( ) => { } } ; action ( params ) ( { dispatch , getState , selectors } ) ; const call = dispatch . getCall ( 0 ) ; expect ( call . args [ 0 ] . payload . data ) . toEqual ( params ) ; } ) ; test ( "s" , async ( ) => { const action = stub ( ) ; action . returns ( new Promise ( res => setTimeout ( ( ) => res ( { some : true } ) , 0 ) ) ) ; const tile = createTile ( { type : [ "s" , "s" , "s" ] , fn : action , nesting : ( { id } ) => [ id ] } ) ; const promisesStorage = { } ; const middlewares = { promisesStorage , dispatch : ( ) => { } } ; const 0 = tile . action ( { id : 0 } ) ( middlewares ) ; const 0 = tile . action ( { id : 0 } ) ( middlewares ) ; await Promise . all ( [ 0 , 0 ] ) ; expect ( action . calledTwice ) . toBe ( true ) ; } ) ; test ( "s" , ( ) => { const tile = createSyncTile ( { type : [ "s" ] , fns : { add : ( ) => { } } } ) ; expect ( tile . action . add ) . toBeInstanceOf ( Function ) ; } ) ; test ( "s" , ( ) => { const tile = createSyncTile ( { type : [ "s" ] , fns : { add : ( { params } ) => params } } ) ; const dispatch = spy ( ) ; const selectors = { some : ( ) => { } } ; const middlewares = { dispatch , selectors } ; const params = { some : 0 } ; tile . action . add ( params ) ( middlewares ) ; const arg = dispatch . getCall ( 0 ) . args [ 0 ] ; expect ( arg . payload . data ) . toBe ( params ) ; } ) ; test ( "s" , ( ) => { const tile = createSyncTile ( { type : [ "s" ] , fn : spy ( ) } ) ; const dispatch = ( ) => { } ; const getState = ( ) => ( { some : true } ) ; const middlewares = { dispatch , getState } ; const params = { some : 0 } ; tile . action ( params ) ( middlewares ) ; const arg = tile . reflect . fn . getCall ( 0 ) . args [ 0 ] ; const data = arg . getData ( ) ; expect ( data ) . toBe ( true ) ; } ) ; test ( "s" , ( ) => { const tile = createSyncTile ( { type : [ "s" , "s" ] , fn : spy ( ) } ) ; const dispatch = ( ) => { } ; const getState = ( ) => ( { some : { additional : "s" } } ) ; const middlewares = { dispatch , getState } ; const params = { some : 0 } ; tile . action ( params ) ( middlewares ) ; const arg = tile . reflect . fn . getCall ( 0 ) . args [ 0 ] ; const data = arg . getData ( ) ; expect ( data ) . toBe ( "s" ) ; } ) ;	O O $any$ O $any$ O O O O O O $ITile$ O $ITile$ O O O O O O $FnResult$ O $FnResult$ O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O O O $any$ O $ITile$ O $IOverloadedAction$ O O $any$ O $FunctionConstructor$ O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $PromiseConstructor$ O $complex$ O O O O O $ITile$ O $ITile$ O O $string$ O O O $any$ O O O O $void$ O O O O O O O O $void$ O O O O O O O O ${}$ O O O O $ITile$ O $IOverloadedAction$ O ${}$ O O $void$ O $void$ O O $any$ O $any$ O $any$ O O $void$ O $void$ O ${}$ O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $PromiseConstructor$ O $complex$ O O O O O $ITile$ O $ITile$ O O $string$ O O O $any$ O O O O $void$ O O O O O O O O $void$ O O O O O O O O ${}$ O O O O O $complex$ O O $boolean$ O O O O $ITile$ O $IOverloadedAction$ O ${}$ O O $void$ O $void$ O $complex$ O O $any$ O $any$ O $any$ O O $void$ O $void$ O ${}$ O $boolean$ O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $any$ O $any$ O O O $any$ O $PromiseConstructor$ O $complex$ O O O O O $ITile$ O $ITile$ O O $string$ O O O $any$ O O O O $void$ O O O O O O O O $void$ O O O O O O O O $complex$ O O $void$ O O O O O O O O O ${}$ O O O O $ITile$ O $IOverloadedAction$ O ${}$ O O O $void$ O $void$ O $complex$ O O O $any$ O $any$ O $any$ O O $void$ O $void$ O ${}$ O $complex$ O O O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $PromiseConstructor$ O $void$ O $void$ O O $boolean$ O O O O O O O O O O O O O O O O O O $FnResult$ O $FnResult$ O O $string[]$ O O O O O $string$ O $string$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $FnResult$ O O $number$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $PromiseConstructor$ O $void$ O $void$ O O $boolean$ O O O O O O O O O O O O O O O O O O $FnResult$ O $FnResult$ O O $string[]$ O O O O O $string$ O $string$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $FnResult$ O O $number$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $PromiseConstructor$ O O $void$ O $void$ O O $void$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $FnResult$ O $FnResult$ O O $string[]$ O O O O O $string$ O $string$ O $string$ O $any$ O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $FnResult$ O O $number$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O $FnResult$ O $FnResult$ O O $string$ O O O $string$ O $string$ O $string$ O $complex$ O O $complex$ O O O O O O $boolean$ O O O $null$ O O O $boolean$ O O O O O O $Promise<number>$ O O O O $PromiseConstructor$ O $complex$ O O O O $true$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $FnResult$ O O $number$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O $FnResult$ O $FnResult$ O O $string[]$ O O O O O $string$ O $string$ O $string$ O $complex$ O O $complex$ O O O O O O $boolean$ O O O $complex$ O O $string$ O O O O O O O $true$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $FnResult$ O O $number$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O $FnResult$ O $FnResult$ O O $string[]$ O O O O O $string$ O $string$ O $string$ O $complex$ O O $complex$ O O O O O O $boolean$ O O O $complex$ O O $string$ O O O O O O O $Promise<void>$ O O O O $PromiseConstructor$ O $complex$ O O O $true$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O $FnResult$ O O $number$ O O O O O $boolean$ O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O O O O O $complex$ O O $boolean$ O O O O O $FnResult$ O $FnResult$ O O $string[]$ O O O O O $string$ O $complex$ O O O O $complex$ O O O O $any$ O $any$ O O O O $void$ O O O O O O O O $complex$ O O $void$ O O O O O O O O $FnResult$ O $complex$ O O O $any$ O $void$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O $any$ O $any$ O O $PromiseConstructor$ O $void$ O $number$ O O O O $void$ O O $boolean$ O O O O O O O O O O O $ITile$ O $ITile$ O O $string[]$ O O O O O O O O O $any$ O $any$ O $any[]$ O O O $any$ O O O O $any$ O O O O O ${}$ O O O O O $complex$ O O ${}$ O $void$ O O O O O O O O O $any$ O $ITile$ O $IOverloadedAction$ O O $number$ O O O O O $complex$ O O O $any$ O $ITile$ O $IOverloadedAction$ O O $number$ O O O O O $complex$ O O O $PromiseConstructor$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string[]$ O O O O O $complex$ O O $void$ O O O O O O O O O O $any$ O $ITile$ O $IOverloadedAction$ O $any$ O O $any$ O $FunctionConstructor$ O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string[]$ O O O O O $complex$ O O $any$ O O O $any$ O O O $any$ O O O O O $any$ O $any$ O O O O $complex$ O O $void$ O O O O O O O O O $complex$ O O $any$ O $complex$ O O O $complex$ O O $number$ O O O O $ITile$ O $IOverloadedAction$ O $any$ O $complex$ O O $complex$ O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string[]$ O O O O O $any$ O $any$ O O O O O O $void$ O O O O O O O O $complex$ O O O O O O $boolean$ O O O O O O $complex$ O O $void$ O $complex$ O O O $complex$ O O $number$ O O O O $ITile$ O $IOverloadedAction$ O $complex$ O O $complex$ O O O $any$ O $ITile$ O $complex$ O $Function$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string[]$ O O O O O O O $any$ O $any$ O O O O O O $void$ O O O O O O O O $complex$ O O O O O O $complex$ O O $string$ O O O O O O O $complex$ O O $void$ O $complex$ O O O $complex$ O O $number$ O O O O $ITile$ O $IOverloadedAction$ O $complex$ O O $complex$ O O O $any$ O $ITile$ O $complex$ O $Function$ O $any$ O O O O $any$ O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O O $any$ O O O O O O O
import { createActions , createTile } from 's' ; import { stub } from 's' ; test ( 's' , ( ) => { const firstModule = createTile ( { type : [ 's' , 's' ] , fn : ( ) => Promise . resolve ( ) } ) ; const actions = createActions ( [ firstModule ] ) ; expect ( actions . some . module . reset ) . toBeInstanceOf ( Function ) ; } ) ;	O O $any$ O $ITile$ O O O O O O $any$ O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string[]$ O O O O O O O $Promise<void>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O $any$ O $any$ O O $ITile$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $FunctionConstructor$ O O O O O
import { createReducers , createNestedReducers } from 's' ; import { createTile , createSyncTile } from 's' ; test ( 's' , ( ) => { const firstModule = createTile ( { type : 's' , fn : ( ) => Promise . resolve ( 's' ) , } ) ; const reducer = createNestedReducers ( { some : firstModule . reducer } ) ; expect ( reducer ) . toBeInstanceOf ( Function ) ; } ) ; test ( 's' , ( ) => { const firstModule = createTile ( { type : [ 's' , 's' ] , fn : ( ) => Promise . resolve ( 's' ) , } ) ; const reducer = createNestedReducers ( { some : firstModule . reducer } ) ; expect ( reducer ) . toBeInstanceOf ( Function ) ; } ) ; test ( 's' , ( ) => { const firstModule = createTile ( { type : 's' , fn : ( ) => Promise . resolve ( 's' ) , } ) ; const secondModule = createTile ( { type : 's' , fn : ( ) => Promise . resolve ( 's' ) , } ) ; const reducer = createReducers ( [ firstModule , secondModule ] ) ; const newState = reducer ( { } , { type : firstModule . constants . START , payload : { } } ) ; expect ( newState ) . toEqual ( { some : { data : null , isPending : true , error : null , fetched : false } , another : null , } ) ; } ) ; test ( 's' , ( ) => { const firstModule = createSyncTile ( { type : 's' , fn : ( ) => 's' , initialState : { some : 0 } } ) ; const secondModule = createSyncTile ( { type : 's' , fn : ( ) => 's' , initialState : { another : false } } ) ; const reducer = createReducers ( [ firstModule , secondModule ] ) ; const newState = reducer ( { } , { type : 's' , payload : { } } ) ; expect ( newState ) . toEqual ( { some : { some : 0 } , another : { another : false } } ) ; } ) ; test ( 's' , ( ) => { const firstModule = createSyncTile ( { type : 's' , fn : ( ) => 's' , initialState : { some : 0 } } ) ; const reducer = createReducers ( [ firstModule ] ) ; const firstState = reducer ( { } , { type : firstModule . constants . SET , payload : { data : 's' } } ) ; const newState = reducer ( firstState , { type : firstModule . constants . RESET , payload : { } } ) ; expect ( newState ) . toEqual ( { some : { some : 0 } , } ) ; } ) ; test ( 's' , ( ) => { const firstModule = createTile ( { type : [ 's' , 's' ] , fn : ( ) => Promise . resolve ( 's' ) , } ) ; const secondModule = createTile ( { type : [ 's' , 's' ] , fn : ( ) => Promise . resolve ( 's' ) , } ) ; const thirdModule = createTile ( { type : [ 's' , 's' ] , fn : ( ) => Promise . resolve ( 's' ) , nesting : ( { id } ) => [ id ] , } ) ; const reducer = createReducers ( [ firstModule , secondModule , thirdModule ] ) ; const newState = reducer ( { } , { type : firstModule . constants . START , payload : { } } ) ; expect ( newState ) . toEqual ( { some : { nesting : { data : null , isPending : true , error : null , fetched : false } } , another : { nesting : null , withNesting : { } } } ) ; } ) ;	O O $any$ O $any$ O O O O O O $ITile$ O $ITile$ O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $Promise<string>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $any$ O $any$ O O $Function$ O $ITile$ O $Function$ O O O $any$ O $any$ O O $any$ O $FunctionConstructor$ O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string[]$ O O O O O O O $Promise<string>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $any$ O $any$ O O $Function$ O $ITile$ O $Function$ O O O $any$ O $any$ O O $any$ O $FunctionConstructor$ O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $Promise<string>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $Promise<string>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $any$ O $any$ O O $ITile$ O $ITile$ O O O O $any$ O $any$ O O O O O $string$ O $ITile$ O $complex$ O $any$ O ${}$ O O O O O O $any$ O $any$ O O $any$ O O $complex$ O O $null$ O O O $boolean$ O O O $null$ O O O $boolean$ O O O O $null$ O O O O O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $string$ O O O O O O $complex$ O O $number$ O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $string$ O O O O O O $complex$ O O $boolean$ O O O O O O O $any$ O $any$ O O $ITile$ O $ITile$ O O O O $any$ O $any$ O O O O O $string$ O O O ${}$ O O O O O O $any$ O $any$ O O $any$ O O $complex$ O O $number$ O O O O $complex$ O O $boolean$ O O O O O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $string$ O O O O O O $complex$ O O $number$ O O O O O O O $any$ O $any$ O O $ITile$ O O O O $any$ O $any$ O O O O O $string$ O $ITile$ O $complex$ O $any$ O $complex$ O O $string$ O O O O O O O $any$ O $any$ O $any$ O O $string$ O $ITile$ O $complex$ O $any$ O ${}$ O O O O O O $any$ O $any$ O O $any$ O O $complex$ O O $number$ O O O O O O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string[]$ O O O O O O O $Promise<string>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $ITile$ O $ITile$ O O $string[]$ O O O O O O O $Promise<string>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $ITile$ O $ITile$ O O $string[]$ O O O O O O O $Promise<string>$ O O O O $PromiseConstructor$ O $complex$ O O O O $any[]$ O O O $any$ O O O O $any$ O O O O O O $any$ O $any$ O O $ITile$ O $ITile$ O $ITile$ O O O O $any$ O $any$ O O O O O $string$ O $ITile$ O $complex$ O $any$ O ${}$ O O O O O O $any$ O $any$ O O $any$ O O $complex$ O O $complex$ O O $null$ O O O $boolean$ O O O $null$ O O O $boolean$ O O O O O $complex$ O O $null$ O O O ${}$ O O O O O O O O O O
import { createSelectors , createTile } from 's' ; import { changeDefaultReducer } from 's' ; test ( 's' , ( ) => { const module = createTile ( { type : 's' , fn : ( ) => Promise . resolve ( 's' ) , } ) ; const selectors = createSelectors ( [ module ] ) ; const state = { userAuth : { myData : 0 } } ; expect ( selectors . userAuth ( state ) ) . toEqual ( { myData : 0 } ) ; } ) ; test ( 's' , ( ) => { const module = createTile ( { type : [ 's' , 's' ] , fn : ( ) => Promise . resolve ( 's' ) , } ) ; changeDefaultReducer ( 's' ) ; const selectors = createSelectors ( [ module ] ) ; const state = { myTiles : { user : { auth : { myData : 0 } } } } ; expect ( selectors . user . auth ( state ) ) . toEqual ( { myData : 0 } ) ; } ) ;	O O $any$ O $ITile$ O O O O O O $void$ O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $Promise<string>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O O $any$ O $any$ O O $ITile$ O O O O $complex$ O O $complex$ O O $number$ O O O O O $any$ O $any$ O $any$ O $complex$ O O O $any$ O O $number$ O O O O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string[]$ O O O O O O O $Promise<string>$ O O O O $PromiseConstructor$ O $complex$ O O O O O O O $void$ O O O O O $any$ O $any$ O O $ITile$ O O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $number$ O O O O O O O $any$ O $any$ O $any$ O $any$ O $complex$ O O O $any$ O O $number$ O O O O O O O O
import { iterate , populateHash } from 's' ; test ( 's' , ( ) => { const tiles = { 0 : 's' , 0 : 's' } ; const processedArray = iterate ( tiles ) ; expect ( processedArray . includes ( 's' ) ) . toBe ( true ) ; expect ( processedArray . includes ( 's' ) ) . toBe ( true ) ; } ) ; test ( 's' , ( ) => { const obj = { } ; populateHash ( obj , [ 's' , 's' , 's' ] , 0 ) ; expect ( obj ) . toEqual ( { some : { way : { deep : 0 } } } ) ; } ) ; test ( 's' , ( ) => { const obj = { some : { way : { one : 0 } } } ; populateHash ( obj , [ 's' , 's' , 's' ] , 0 ) ; expect ( obj ) . toEqual ( { some : { way : { one : 0 , deep : 0 } } } ) ; } ) ;	O O $any[]$ O $complex$ O O O O $any$ O O O O O O O O O O O $string$ O O O $string$ O O O O O $any[]$ O $any[]$ O O O O $any$ O $any[]$ O $boolean$ O O O O O $any$ O O O O $any$ O $any[]$ O $boolean$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O ${}$ O O O O $complex$ O ${}$ O O O O O O O O O O O O $any$ O ${}$ O O $any$ O O $complex$ O O $complex$ O O $number$ O O O O O O O O O O $any$ O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $number$ O O O O O O $complex$ O $complex$ O O O O O O O O O O O O $any$ O $complex$ O O $any$ O O $complex$ O O $complex$ O O $number$ O O O $number$ O O O O O O O O O O
import { createMiddleware } from 's' ; import { spy } from 's' ; test ( 's' , ( ) => { const params = { some : 0 } ; const { middleware } = createMiddleware ( { params } ) ; const dispatch = ( ) => { } ; const getState = ( ) => { } ; const action = spy ( ) ; middleware ( { dispatch , getState } ) ( ( ) => { } ) ( action ) ; expect ( action . calledOnce ) . toBe ( true ) ; } ) ; test ( 's' , ( ) => { const params = { some : 0 } ; const { middleware } = createMiddleware ( { params } ) ; const dispatch = ( ) => { } ; const getState = ( ) => { } ; const action = ( ) => { } ; const next = spy ( ) ; middleware ( { dispatch , getState } ) ( next ) ( action ) ; expect ( next . notCalled ) . toBe ( true ) ; } ) ; test ( 's' , ( ) => { const params = { some : 0 } ; const { middleware } = createMiddleware ( { params } ) ; const dispatch = ( ) => { } ; const getState = ( ) => { } ; const action = { some : true } ; const next = spy ( ) ; middleware ( { dispatch , getState } ) ( next ) ( action ) ; expect ( next . calledOnce ) . toBe ( true ) ; } ) ; test ( 's' , ( ) => { const params = { some : 0 } ; const { middleware } = createMiddleware ( { params } ) ; const dispatch = ( ) => { } ; const getState = ( ) => { } ; const action = spy ( ) ; middleware ( { dispatch , getState } ) ( ( ) => { } ) ( action ) ; expect ( action . calledWith ( { dispatch , getState , params , promisesStorage : { } } ) ) . toBe ( true ) ; } ) ; test ( 's' , ( ) => { const params = { some : 0 } ; const { middleware } = createMiddleware ( { params } ) ; const dispatch = ( ) => { } ; const getState = ( ) => { } ; const next = spy ( ) ; middleware ( { dispatch , getState } ) ( next ) ( { type : 's' } ) ; expect ( next . calledWith ( { type : 's' } ) ) . toBe ( true ) ; } ) ;	O O $complex$ O O O O O O $any$ O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O O O O $any$ O O $complex$ O O $complex$ O O O O $void$ O O O O O O O O $void$ O O O O O O O O $any$ O $any$ O O O $any$ O O $void$ O $void$ O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O O O O $any$ O O $complex$ O O $complex$ O O O O $void$ O O O O O O O O $void$ O O O O O O O O $void$ O O O O O O O O $any$ O $any$ O O O $any$ O O $void$ O $void$ O O O $any$ O O $void$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O O O O $any$ O O $complex$ O O $complex$ O O O O $void$ O O O O O O O O $void$ O O O O O O O O $complex$ O O $boolean$ O O O O O $any$ O $any$ O O O $any$ O O $void$ O $void$ O O O $any$ O O $complex$ O O $any$ O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O O O O $any$ O O $complex$ O O $complex$ O O O O $void$ O O O O O O O O $void$ O O O O O O O O $any$ O $any$ O O O $any$ O O $void$ O $void$ O O O O O O O O O O $any$ O O $any$ O $any$ O $any$ O O $void$ O $void$ O $complex$ O ${}$ O O O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O O O O $any$ O O $complex$ O O $complex$ O O O O $void$ O O O O O O O O $void$ O O O O O O O O $any$ O $any$ O O O $any$ O O $void$ O $void$ O O O $any$ O O O $string$ O O O O O $any$ O $any$ O $any$ O O $string$ O O O O O O $any$ O O O O O O O
import * as tileReducer from 's' ; test ( 's' , ( ) => { const action = 's' ; const reducer = tileReducer . createReducer ( [ ] , { } ) ; const state = { some : { nested : true } } ; const result = reducer ( state , { type : action } ) ; expect ( result ) . toEqual ( state ) ; } ) ; test ( 's' , ( ) => { const action = 's' ; const reducer = tileReducer . createReducer ( [ ] , { [ action ] : ( ) => ( { success : true } ) } ) ; const result = reducer ( null , { type : action , payload : { } } ) ; expect ( result ) . toEqual ( { success : true } ) ; } ) ; test ( 's' , ( ) => { const newValue = { new : true } ; const action = { payload : { path : [ 's' ] } } ; const state = { some : { old : true } } ; const newState = tileReducer . reducerCreator ( { newValue , state , action } ) ; expect ( newState ) . toEqual ( { some : newValue } ) ; } ) ; test ( 's' , ( ) => { const newValue = { new : true } ; const action = { payload : { path : [ 's' , 's' ] } } ; const state = { first : { second : { old : true } } } ; const newState = tileReducer . reducerCreator ( { newValue , state , action } ) ; expect ( newState ) . toEqual ( { first : { second : newValue } } ) ; } ) ; test ( 's' , ( ) => { const newValue = { some : true } ; const action = { payload : { path : 's' . split ( 's' ) } } ; const state = { first : { second : { third : { some : false } } } } ; const newState = tileReducer . reducerCreator ( { newValue , state , action } ) ; expect ( newState ) . toEqual ( { first : { second : { third : newValue } } } ) ; } ) ;	O O O $any$ O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O $complex$ O O $complex$ O O $boolean$ O O O O O O $any$ O $any$ O $complex$ O O $string$ O O O O O $any$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O $boolean$ O O O O O O O O $any$ O $any$ O O O O $string$ O O O ${}$ O O O O O O $any$ O $any$ O O $any$ O O $boolean$ O O O O O O O O $any$ O O O O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $complex$ O O $string[]$ O O O O O O O O $complex$ O O $complex$ O O $boolean$ O O O O O O $any$ O $any$ O $any$ O O $complex$ O $complex$ O $complex$ O O O $any$ O $any$ O O $any$ O O $complex$ O $complex$ O O O O O O $any$ O O O O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $complex$ O O $string[]$ O O O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $boolean$ O O O O O O O $any$ O $any$ O $any$ O O $complex$ O $complex$ O $complex$ O O O $any$ O $any$ O O $any$ O O $complex$ O O $complex$ O $complex$ O O O O O O O $any$ O O O O O O O O $complex$ O O $boolean$ O O O O O $complex$ O O $complex$ O O $string[]$ O O O $complex$ O O O O O O O $complex$ O O $complex$ O O $complex$ O O $complex$ O O $boolean$ O O O O O O O O $any$ O $any$ O $any$ O O $complex$ O $complex$ O $complex$ O O O $any$ O $any$ O O $any$ O O $complex$ O O $complex$ O O $complex$ O $complex$ O O O O O O O O
import { createSelectors , DEFAULT_REDUCER } from 's' ; test ( 's' , ( ) => { const { get } = createSelectors ( { tileName : 's' , nesting : ( ) => [ 's' , 's' ] , selectorFallback : { some : 's' } } ) ; const result = get ( { } ) ; expect ( result ) . toEqual ( { some : 's' } ) ; } ) ; test ( 's' , ( ) => { const { get } = createSelectors ( { tileName : 's' , nesting : ( ) => [ 's' , 's' ] } ) ; const result = get ( { myTile : { some : { another : 0 } } } ) ; expect ( result ) . toBe ( 0 ) ; } ) ; test ( 's' , ( ) => { const { get } = createSelectors ( { tileName : [ 's' , 's' ] , nesting : ( ) => [ 's' , 's' ] } ) ; const result = get ( { myTile : { nested : { some : { another : 0 } } } } ) ; expect ( result ) . toBe ( 0 ) ; } ) ; test ( 's' , ( ) => { const { get } = createSelectors ( { tileName : [ 's' , 's' ] , nesting : ( { id , type } ) => [ id , type ] , } ) ; const result = get ( { myTile : { nested : { one : { two : 0 } } } } , { id : 's' , type : 's' } ) ; expect ( result ) . toBe ( 0 ) ; } ) ; test ( 's' , ( ) => { const { get } = createSelectors ( { tileName : [ 's' , 's' ] , nesting : ( { id , type } ) => [ id , type ] , } ) ; const result = get ( { myTile : { nested : { one : { two : false } } } } , { id : 's' , type : 's' } ) ; expect ( result ) . toBe ( false ) ; } ) ;	O O $ISelectors$ O $string$ O O O O $any$ O O O O O O O O O $any$ O O $ISelectors$ O O $string$ O O O $string[]$ O O O O O O O O O O $complex$ O O $string$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O $string$ O O O O O O O O $any$ O O O O O O O O O $any$ O O $ISelectors$ O O $string$ O O O $string[]$ O O O O O O O O O O O O O $any$ O $any$ O O $complex$ O O $complex$ O O $number$ O O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $ISelectors$ O O $string[]$ O O O O O O O $string[]$ O O O O O O O O O O O O O $any$ O $any$ O O $complex$ O O $complex$ O O $complex$ O O $number$ O O O O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $ISelectors$ O O $string[]$ O O O O O O O $any[]$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $complex$ O O $complex$ O O $complex$ O O $number$ O O O O O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $any$ O O $ISelectors$ O O $string[]$ O O O O O O O $any[]$ O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O $complex$ O O $complex$ O O $complex$ O O $boolean$ O O O O O O O O $string$ O O O $string$ O O O O O $any$ O $any$ O O $any$ O O O O O O O
import { shouldBeFetched } from 's' ; test ( 's' , ( ) => { const params = { isPending : false , fetched : false , error : null , } ; const result = shouldBeFetched ( params ) ; expect ( result ) . toBe ( true ) ; } ) ; test ( 's' , ( ) => { const params = { isPending : false , fetched : true , error : new Error ( 's' ) , } ; const result = shouldBeFetched ( params ) ; expect ( result ) . toBe ( true ) ; } ) ; test ( 's' , ( ) => { const params = { isPending : false , fetched : true , error : null , } ; const result = shouldBeFetched ( params ) ; expect ( result ) . toBe ( false ) ; } ) ; test ( 's' , ( ) => { const params = { isPending : true , fetched : false , error : null , } ; const result = shouldBeFetched ( params ) ; expect ( result ) . toBe ( false ) ; } ) ;	O O $boolean$ O O O O $any$ O O O O O O O O $complex$ O O $boolean$ O O O $boolean$ O O O $null$ O O O O O O $boolean$ O $boolean$ O $complex$ O O $any$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $boolean$ O O O $boolean$ O O O $Error$ O O $ErrorConstructor$ O O O O O O O $boolean$ O $boolean$ O $complex$ O O $any$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $boolean$ O O O $boolean$ O O O $null$ O O O O O O $boolean$ O $boolean$ O $complex$ O O $any$ O $boolean$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $boolean$ O O O $boolean$ O O O $null$ O O O O O O $boolean$ O $boolean$ O $complex$ O O $any$ O $boolean$ O O $any$ O O O O O O O
import { createTile , createSyncTile , createEntities , createMiddleware } from 's' ; import { createStore , applyMiddleware } from 's' ; import { sleep } from 's' ; import { spy } from 's' ; test ( 's' , ( ) => { const params = { type : [ 's' , 's' ] , fn : ( ) => Promise . reject ( 's' ) } ; const tile = createTile ( params ) ; expect ( params ) . toBe ( tile . reflect ) ; } ) ; test ( 's' , ( ) => { const params = { type : [ 's' , 's' ] , fn : ( ) => 's' } ; const syncTile = createSyncTile ( params ) ; expect ( params ) . toBe ( syncTile . reflect ) ; } ) ; test ( 's' , ( ) => { const params = { type : [ 's' , 's' ] , fn : ( ) => 's' } ; const syncTile = createTile ( params ) ; const data = syncTile . selectors . get ( { } ) ; expect ( data ) . toEqual ( { data : null , error : null , isPending : false , fetched : false } ) ; } ) ; test ( 's' , ( ) => { const params = { type : [ 's' , 's' ] , fn : ( ) => 's' , selectorFallback : { myProperty : true } } ; const tile = createTile ( params ) ; const data = tile . selectors . get ( { } ) ; expect ( data ) . toEqual ( { isPending : false , error : null , data : { myProperty : true } , fetched : false } ) ; } ) ; test ( 's' , ( ) => { const someTile = createTile ( { type : [ 's' ] , fn : ( ) => Promise . reject ( { some : 's' } ) } ) ; const error = new Error ( 's' ) ; const action = { type : someTile . constants . FAILURE , payload : { path : null } , error : new Error ( 's' ) } ; const newState : { } = someTile . reducer ( { } , action ) ; expect ( newState ) . toEqual ( { isPending : false , error , data : null , fetched : true , } ) ; } ) ; test ( 's' , ( ) => { const params = { type : [ 's' , 's' ] , fn : ( ) => 's' , selectorFallback : { myProperty : true } } ; const syncTile = createSyncTile ( params ) ; const data = syncTile . selectors . get ( { } ) ; expect ( data ) . toEqual ( { myProperty : true } ) ; } ) ; test ( 's' , ( ) => { const syncTile = createSyncTile ( { type : 's' } ) ; const params = { some : 0 } ; const dispatch = spy ( ) ; const selectors = { some : ( ) => { } } syncTile . action ( params ) ( { dispatch , selectors } ) ; const call = dispatch . getCall ( 0 ) ; const arg = call . args [ 0 ] ; const resultAction = { type : syncTile . constants . SET , payload : { path : null , data : params } , data : params } ; expect ( arg ) . toEqual ( resultAction ) ; } ) ; test ( 's' , ( ) => { const someTile = createSyncTile ( { type : 's' } ) ; const tiles = [ someTile ] ; const { reducer , actions , selectors } = createEntities ( tiles ) ; const { middleware } = createMiddleware ( { actions , selectors } ) ; const store = createStore ( reducer , applyMiddleware ( middleware ) ) ; const { data : result } = store . dispatch ( actions . some ( 's' ) ) ; expect ( result ) . toBe ( 's' ) ; } ) ; test ( 's' , async ( ) => { const someTile = createTile ( { type : 's' , fn : ( ) => Promise . resolve ( { some : true } ) , } ) ; const tiles = [ someTile ] ; const { reducer , actions , selectors } = createEntities ( tiles ) ; const { middleware } = createMiddleware ( ) ; const store = createStore ( reducer , applyMiddleware ( middleware ) ) ; const result = selectors . some ( store . getState ( ) ) ; expect ( result ) . toEqual ( { isPending : false , error : null , data : null , fetched : false } ) ; } ) ; test ( 's' , async ( ) => { const someTile = createTile ( { type : 's' , fn : ( ) => Promise . resolve ( { some : true } ) , } ) ; const tiles = [ someTile ] ; const { reducer , actions , selectors } = createEntities ( tiles ) ; const { middleware } = createMiddleware ( ) ; const store = createStore ( reducer , applyMiddleware ( middleware ) ) ; await store . dispatch ( actions . some ( 's' ) ) ; const result = selectors . some ( store . getState ( ) ) ; expect ( result ) . toEqual ( { isPending : false , error : null , data : { some : true } , fetched : true } ) ; } ) ; test ( 's' , async ( ) => { const someTile = createTile ( { type : 's' , fn : ( ) => Promise . resolve ( { some : true } ) , } ) ; const tiles = [ someTile ] ; const { reducer , actions , selectors } = createEntities ( tiles ) ; const { middleware } = createMiddleware ( ) ; const store = createStore ( reducer , applyMiddleware ( middleware ) ) ; const { data : result } = await store . dispatch ( actions . some ( 's' ) ) ; expect ( result ) . toEqual ( { some : true } ) ; } ) ; test ( 's' , async ( ) => { const someTile = createTile ( { type : 's' , fn : ( ) => Promise . resolve ( { some : true } ) , caching : true } ) ; const tiles = [ someTile ] ; const { reducer , actions , selectors } = createEntities ( tiles ) ; const { middleware } = createMiddleware ( ) ; const store = createStore ( reducer , applyMiddleware ( middleware ) ) ; await store . dispatch ( actions . some ( 's' ) ) ; const { data : result } = await store . dispatch ( actions . some ( 's' ) ) ; expect ( result ) . toEqual ( { some : true } ) ; } ) ; test ( 's' , async ( ) => { const someTile = createTile ( { type : 's' , fn : ( ) => Promise . reject ( { some : true } ) , } ) ; const tiles = [ someTile ] ; const { reducer , actions , selectors } = createEntities ( tiles ) ; const { middleware } = createMiddleware ( ) ; const store = createStore ( reducer , applyMiddleware ( middleware ) ) ; await store . dispatch ( actions . some ( 's' ) ) ; const result = selectors . some ( store . getState ( ) ) ; expect ( result ) . toEqual ( { isPending : false , data : null , error : { some : true } , fetched : true } ) ; } ) ; test ( 's' , async ( ) => { const someTile = createTile ( { type : 's' , fn : ( ) => Promise . reject ( { some : true } ) , } ) ; const tiles = [ someTile ] ; const { reducer , actions , selectors } = createEntities ( tiles ) ; const { middleware } = createMiddleware ( ) ; const store = createStore ( reducer , applyMiddleware ( middleware ) ) ; const { error : result } = await store . dispatch ( actions . some ( 's' ) ) ; expect ( result ) . toEqual ( { some : true } ) ; } ) ; test ( 's' , async ( ) => { const someTile = createTile ( { type : 's' , caching : true , fn : async ( ) => { await sleep ( 0 ) ; return { some : true } ; } } ) ; const tiles = [ someTile ] ; const { reducer , actions , selectors } = createEntities ( tiles ) ; const { middleware } = createMiddleware ( ) ; const store = createStore ( reducer , applyMiddleware ( middleware ) ) ; const 0 = store . dispatch ( actions . some ( 's' ) ) ; const 0 = store . dispatch ( actions . some ( 's' ) ) ; expect ( 0 ) . toBe ( 0 ) ; } ) ; test ( 's' , async ( ) => { const someTile = createTile ( { type : 's' , caching : true , fn : async ( ) => { await sleep ( 0 ) ; return { some : true } ; } } ) ; const tiles = [ someTile ] ; const { reducer , actions , selectors } = createEntities ( tiles ) ; const { middleware } = createMiddleware ( ) ; const store = createStore ( reducer , applyMiddleware ( middleware ) ) ; const 0 = store . dispatch ( actions . some ( 's' ) ) ; const 0 = store . dispatch ( actions . some ( 's' ) ) ; expect ( 0 ) . toBe ( 0 ) ; } ) ;	O O $ITile$ O $ITile$ O $any$ O $complex$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O $complex$ O O $string[]$ O O O O O O O $Promise<never>$ O O O O $PromiseConstructor$ O $Promise<T>$ O O O O O O $ITile$ O $ITile$ O $complex$ O O $any$ O $complex$ O O $any$ O $ITile$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string[]$ O O O O O O O $string$ O O O O O O O O $ITile$ O $ITile$ O $complex$ O O $any$ O $complex$ O O $any$ O $ITile$ O $complex$ O O O O O $any$ O O O O O O O O $complex$ O O $string[]$ O O O O O O O $string$ O O O O O O O O $ITile$ O $ITile$ O $complex$ O O O $any$ O $ITile$ O $complex$ O $Function$ O O O O O $any$ O $any$ O O $any$ O O $null$ O O O $null$ O O O $boolean$ O O O $boolean$ O O O O O O O O $any$ O O O O O O O O $complex$ O O $string[]$ O O O O O O O $string$ O O O O O O $complex$ O O $boolean$ O O O O O O $ITile$ O $ITile$ O $complex$ O O O $any$ O $ITile$ O $complex$ O $Function$ O O O O O $any$ O $any$ O O $any$ O O $boolean$ O O O $null$ O O O $complex$ O O $boolean$ O O O O $boolean$ O O O O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string[]$ O O O O O $Promise<never>$ O O O O $PromiseConstructor$ O $Promise<T>$ O O $string$ O O O O O O O O $Error$ O O $ErrorConstructor$ O O O O O $complex$ O O $string$ O $ITile$ O $complex$ O $any$ O $complex$ O O $null$ O O O O $Error$ O O $ErrorConstructor$ O O O O O O ${}$ O O O O $ITile$ O $Function$ O O O O $complex$ O O $any$ O ${}$ O O $any$ O O $boolean$ O O O $Error$ O $null$ O O O $boolean$ O O O O O O O O O $any$ O O O O O O O O $complex$ O O $string[]$ O O O O O O O $string$ O O O O O O $complex$ O O $boolean$ O O O O O O $ITile$ O $ITile$ O $complex$ O O O $any$ O $ITile$ O $complex$ O $Function$ O O O O O $any$ O $any$ O O $any$ O O $boolean$ O O O O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O O O O $complex$ O O $number$ O O O O O $any$ O $any$ O O O O $complex$ O O $void$ O O O O O O O $ITile$ O $IOverloadedAction$ O $complex$ O O O $any$ O $complex$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $complex$ O O $string$ O $ITile$ O $complex$ O $any$ O $complex$ O O $null$ O O O $complex$ O $complex$ O O $complex$ O $complex$ O O $any$ O $any$ O O $any$ O $complex$ O O O O O $any$ O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O O O O $ITile[]$ O O $ITile$ O O O O $any$ O $any$ O $any$ O O $any$ O $ITile[]$ O O O O $any$ O O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $complex$ O O O O $PromiseConstructor$ O $complex$ O O $true$ O O O O O O O O O $ITile[]$ O O $ITile$ O O O O $any$ O $any$ O $any$ O O $any$ O $ITile[]$ O O O O $any$ O O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O $boolean$ O O O $null$ O O O $null$ O O O $boolean$ O O O O O O O O $any$ O O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $complex$ O O O O $PromiseConstructor$ O $complex$ O O $true$ O O O O O O O O O $ITile[]$ O O $ITile$ O O O O $any$ O $any$ O $any$ O O $any$ O $ITile[]$ O O O O $any$ O O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O $boolean$ O O O $null$ O O O $complex$ O O $boolean$ O O O O $boolean$ O O O O O O O O $any$ O O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $complex$ O O O O $PromiseConstructor$ O $complex$ O O $true$ O O O O O O O O O $ITile[]$ O O $ITile$ O O O O $any$ O $any$ O $any$ O O $any$ O $ITile[]$ O O O O $any$ O O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O $boolean$ O O O O O O O O $any$ O O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $complex$ O O O O $PromiseConstructor$ O $complex$ O O $true$ O O O O O $true$ O O O O O O $ITile[]$ O O $ITile$ O O O O $any$ O $any$ O $any$ O O $any$ O $ITile[]$ O O O O $any$ O O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O $boolean$ O O O O O O O O $any$ O O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $Promise<never>$ O O O O $PromiseConstructor$ O $Promise<T>$ O O $boolean$ O O O O O O O O O $ITile[]$ O O $ITile$ O O O O $any$ O $any$ O $any$ O O $any$ O $ITile[]$ O O O O $any$ O O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O $any$ O O $boolean$ O O O $null$ O O O $complex$ O O $boolean$ O O O O $boolean$ O O O O O O O O $any$ O O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $Promise<never>$ O O O O $PromiseConstructor$ O $Promise<T>$ O O $boolean$ O O O O O O O O O $ITile[]$ O O $ITile$ O O O O $any$ O $any$ O $any$ O O $any$ O $ITile[]$ O O O O $any$ O O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O O $boolean$ O O O O O O O O $any$ O O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $true$ O O O $complex$ O O O O O O O $any$ O O O O O O $boolean$ O O O O O O O O O $ITile[]$ O O $ITile$ O O O O $any$ O $any$ O $any$ O O $any$ O $ITile[]$ O O O O $any$ O O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O $any$ O O O O O O O O O $ITile$ O $ITile$ O O $string$ O O O $true$ O O O $complex$ O O O O O O O $any$ O O O O O O $boolean$ O O O O O O O O O $ITile[]$ O O $ITile$ O O O O $any$ O $any$ O $any$ O O $any$ O $ITile[]$ O O O O $any$ O O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O $any$ O $any$ O O O O O
import { get , isArray , mapValues } from 's' ; test ( 's' , ( ) => { const array = [ 0 , 0 , 0 ] ; expect ( isArray ( array ) ) . toBe ( true ) ; } ) ; test ( 's' , ( ) => { const array = { some : true } ; expect ( isArray ( array ) ) . toBe ( false ) ; } ) ; test ( 's' , ( ) => { const array = 's' ; expect ( isArray ( array ) ) . toBe ( false ) ; } ) ; test ( 's' , ( ) => { const object = { some : { nested : { path : 's' } } } ; const path = [ 's' , 's' , 's' ] ; const result = get ( object , path ) ; expect ( result ) . toBe ( 's' ) ; } ) ; test ( 's' , ( ) => { const object = { some : { nested : { path : 's' } } } ; const path = [ 's' , 's' , 's' ] ; const result = get ( object , path ) ; expect ( result ) . toBe ( undefined ) ; } ) ; test ( 's' , ( ) => { const object = { a : 0 , b : 0 , } ; const cb = x => x * 0 ; const result = mapValues ( object , cb ) ; expect ( result ) . toEqual ( { a : 0 , b : 0 } ) ; } ) ;	O O $any$ O $boolean$ O $any$ O O O O $any$ O O O O O O O O $number[]$ O O O O O O O O O $any$ O $boolean$ O $number[]$ O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $boolean$ O O O O $any$ O $boolean$ O $complex$ O O O $any$ O O O O O O O $any$ O O O O O O O O O O O O $any$ O $boolean$ O O O O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O O O O O $string[]$ O O O O O O O O O O $any$ O $any$ O $complex$ O $string[]$ O O $any$ O $any$ O O $any$ O O O O O O O $any$ O O O O O O O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O O O O O $string[]$ O O O O O O O O O O $any$ O $any$ O $complex$ O $string[]$ O O $any$ O $any$ O O $any$ O $undefined$ O O O O O $any$ O O O O O O O O $complex$ O O $number$ O O O $number$ O O O O O O $number$ O $any$ O $any$ O O O O $any$ O $any$ O $complex$ O $number$ O O $any$ O $any$ O O $any$ O O $number$ O O O $number$ O O O O O O O O
import { createTile , createActions , createReducers , createMiddleware } from 's' ; import { createStore , applyMiddleware } from 's' ; import { sleep } from 's' ; import { get } from 's' ; function imitateStore ( { firstType , firstDelay , secondType , secondDelay } ) { const firstTile = createTile ( { type : firstType , fn : async ( ) => { await sleep ( firstDelay ) ; return { success : true } ; } , } ) ; const secondTile = createTile ( { type : secondType , fn : async ( ) => { await sleep ( secondDelay ) ; return { data : 's' } ; } , } ) ; const tiles = [ firstTile , secondTile ] ; const actions = createActions ( tiles ) ; const reducer = createReducers ( tiles ) ; const { middleware , waitTiles } = createMiddleware ( ) ; const store = createStore ( reducer , { } , applyMiddleware ( middleware ) ) ; store . dispatch ( get ( actions , firstType ) ( ) ) ; store . dispatch ( get ( actions , secondType ) ( ) ) ; return { store , waitTiles } ; } test ( 's' , async ( ) => { const { store , waitTiles } = imitateStore ( { firstType : [ 's' , 's' ] , firstDelay : 0 , secondType : [ 's' , 's' ] , secondDelay : 0 } ) ; await waitTiles ( ) ; expect ( store . getState ( ) ) . toEqual ( { some : { another : { data : { success : true } , isPending : false , error : null , fetched : true , } , } , second : { tile : { data : { data : 's' } , isPending : false , error : null , fetched : true , } , } , } ) ; } ) ; test ( 's' , async ( ) => { imitateStore ( { firstType : [ 's' , 's' ] , firstDelay : 0 , secondType : [ 's' , 's' ] , secondDelay : 0 } ) ; const { store , waitTiles } = imitateStore ( { firstType : [ 's' , 's' ] , firstDelay : 0 , secondType : [ 's' , 's' ] , secondDelay : 0 } ) ; await waitTiles ( ) ; expect ( store . getState ( ) ) . toEqual ( { new_store : { another : { data : { success : true } , isPending : false , error : null , fetched : true , } , } , second_tile : { tile : { data : { data : 's' } , isPending : false , error : null , fetched : true , } , } , } ) ; } ) ;	O O $ITile$ O $any$ O $any$ O $complex$ O O O O O O $any$ O $any$ O O O O O O $any$ O O O O O O $any$ O O O O O $complex$ O O $any$ O $any$ O $any$ O $any$ O O O O $ITile$ O $ITile$ O O $any$ O $any$ O $complex$ O O O O O O O $any$ O $any$ O O O O $boolean$ O O O O O O O O O O $ITile$ O $ITile$ O O $any$ O $any$ O $complex$ O O O O O O O $any$ O $any$ O O O O $string$ O O O O O O O O O O $ITile[]$ O O $ITile$ O $ITile$ O O O $any$ O $any$ O $ITile[]$ O O O $any$ O $any$ O $ITile[]$ O O O O $any$ O $Function$ O O $complex$ O O O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O O $any$ O $Function$ O O O $any$ O O O O O O O O O O $any$ O $Function$ O O $complex$ O O $string[]$ O O O O O O O $number$ O O O $string[]$ O O O O O O O $number$ O O O O O O $Function$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $complex$ O O $complex$ O O $complex$ O O $boolean$ O O O O $boolean$ O O O $null$ O O O $boolean$ O O O O O O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O O $boolean$ O O O $null$ O O O $boolean$ O O O O O O O O O O O O O $any$ O O O O O O O O $complex$ O O $string[]$ O O O O O O O $number$ O O O $string[]$ O O O O O O O $number$ O O O O O O O $any$ O $Function$ O O $complex$ O O $string[]$ O O O O O O O $number$ O O O $string[]$ O O O O O O O $number$ O O O O O O $Function$ O O O $any$ O $any$ O $any$ O O O O $any$ O O $complex$ O O $complex$ O O $complex$ O O $boolean$ O O O O $boolean$ O O O $null$ O O O $boolean$ O O O O O O O $complex$ O O $complex$ O O $complex$ O O $string$ O O O O $boolean$ O O O $null$ O O O $boolean$ O O O O O O O O O O O O O