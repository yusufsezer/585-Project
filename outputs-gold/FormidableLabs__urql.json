export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O O O O O O
'js' let idCounter = 0 ; const store = { todos : [ { id : 0 , text : 's' , complete : false , } , { id : 0 , text : 's' , complete : true , } , { id : 0 , text : 's' , complete : false , } , ] , } ; const typeDefs = `template` ; const resolvers = { Query : { todos : ( ) => { return store . todos ; } , } , Mutation : { toggleTodo : ( root , args ) => { const { id } = args ; const todo = store . todos . find ( t => String ( t . id ) === id ) ; todo . complete = ! todo . complete ; return todo ; } , addTodo : ( root , args ) => { const id = ++ idCounter ; const todo = { complete : false , id , text : args . text } ; store . todos . push ( todo ) ; return todo ; } , deleteTodo : ( root , args ) => { const { id } = args ; const todo = store . todos . find ( t => String ( t . id ) === id ) ; store . todos = store . todos . filter ( t => { return String ( t . id ) !== id ; } ) ; return todo ; } , } , } ; module . exports = { typeDefs , resolvers , context : ( headers , secrets ) => { return { headers , secrets , } ; } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const { ApolloServer } = require ( 's' ) ; const { createServer } = require ( 's' ) ; const expressPlayground = require ( 's' ) . default ; const express = require ( 's' ) ; const app = express ( ) ; const cors = require ( 's' ) ; const { typeDefs , resolvers } = require ( 's' ) ; const PORT = 0 ; const server = new ApolloServer ( { typeDefs , resolvers , } ) ; server . applyMiddleware ( { app } ) ; const webServer = createServer ( app ) ; server . installSubscriptionHandlers ( webServer ) ; const graphqlEndpoint = `template` ; const subscriptionEndpoint = `template` ; app . use ( cors ( ) ) ; app . get ( 's' , expressPlayground ( { endpoint : graphqlEndpoint , subscriptionEndpoint : subscriptionEndpoint , } ) ) ; webServer . listen ( PORT , ( ) => { console . log ( `template` ) ; console . log ( `template` ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) ; const context = path . resolve ( __dirname , 's' ) ; module . exports = { entry : path . resolve ( __dirname , 's' ) , context , mode : 's' , target : 's' , module : { rules : [ { test : "s" , use : [ { loader : require . resolve ( 's' ) , } , ] , include : [ "s" , context ] , exclude : [ "s" ] , enforce : 's' , } , { test : "s" , exclude : "s" , use : [ { loader : require . resolve ( 's' ) , options : { configFileName : require . resolve ( 's' ) , } , } , ] , } , { test : "s" , use : [ { loader : require . resolve ( 's' ) , } , { loader : require . resolve ( 's' ) , } , ] , } , ] , } , resolve : { alias : { react : path . resolve ( __dirname , 's' ) , 's' : path . resolve ( __dirname , 's' ) , } , extensions : [ 's' , 's' , 's' , 's' , 's' , 's' ] , } , stats : 's' , output : { path : path . resolve ( __dirname , 's' ) , filename : 's' , publicPath : 's' , } , devtool : 's' , devServer : { allowedHosts : [ 's' ] , host : 's' , port : 0 , contentBase : path . join ( __dirname , 's' ) , compress : true , historyApiFallback : true , hot : true , https : false , noInfo : true , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const defaultStore = [ 's' , 's' , 's' ] ; context ( 's' , ( ) => { describe ( 's' , ( ) => { it ( 's' , ( ) => { cy . visit ( 's' ) ; cy . get ( 's' ) . should ( 's' , 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { before ( ( ) => { cy . visit ( 's' ) ; } ) ; it ( 's' , ( ) => { cy . wait ( 0 ) ; cy . get ( 's' ) . should ( 's' ) ; } ) ; it ( 's' , ( ) => { cy . get ( 's' ) . should ( 's' ) ; } ) ; it ( 's' , ( ) => { cy . get ( 's' ) . should ( 's' ) ; } ) ; it ( 's' , ( ) => { cy . wait ( 0 ) ; cy . get ( 's' ) . should ( 's' , 0 ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = ( on , config ) => { }	O O O O O O O O O O O O O
'js' import 's'	O O O
export * from 's' ; export * from 's' ;	O O O O O O O O O O
'js' const { PubSub } = require ( 's' ) ; const { StarWars } = require ( 's' ) ; const pubsub = new PubSub ( ) ; const store = { messages : [ ] , } ; const typeDefs = `template` ; const resolvers = { Query : { messages : store . messages , } , Subscription : { newMessages : { subscribe : ( ) => pubsub . asyncIterator ( 's' ) , } , } , } ; module . exports = { typeDefs , resolvers , context : ( headers , secrets ) => { return { headers , secrets , } ; } , } ; let id = 0 ; setInterval ( ( ) => pubsub . publish ( 's' , { newMessages : { id : ++ id , message : StarWars . quote ( ) , from : StarWars . character ( ) , } , } ) , 0 ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const { makeExecutableSchema } = require ( 's' ) ; const { execute , subscribe } = require ( 's' ) ; const { createServer } = require ( 's' ) ; const { SubscriptionServer } = require ( 's' ) ; const { ApolloServer } = require ( 's' ) ; const cors = require ( 's' ) ; const express = require ( 's' ) ; const { typeDefs , resolvers } = require ( 's' ) ; const PORT = 0 ; const WS_PORT = 0 ; const websocketServer = createServer ( ( request , response ) => { response . writeHead ( 0 ) ; response . end ( ) ; } ) ; const subscriptionServer = SubscriptionServer . create ( { execute , subscribe , schema : makeExecutableSchema ( { typeDefs , resolvers } ) , } , { server : websocketServer , path : 's' , } ) ; websocketServer . listen ( WS_PORT , ( ) => console . log ( `template` ) ) ; const app = express ( ) ; app . use ( cors ( ) ) ; const server = new ApolloServer ( { typeDefs , resolvers , subscriptionsPath : `template` , } ) ; server . applyMiddleware ( { app } ) ; app . listen ( { port : PORT } , ( ) => console . log ( `template` ) ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) ; const context = path . resolve ( __dirname , 's' ) ; module . exports = { entry : path . resolve ( __dirname , 's' ) , context , mode : 's' , target : 's' , module : { rules : [ { test : "s" , use : [ { loader : require . resolve ( 's' ) , } , ] , include : [ "s" , context ] , exclude : [ "s" ] , enforce : 's' , } , { test : "s" , exclude : "s" , use : [ { loader : require . resolve ( 's' ) , options : { configFileName : require . resolve ( 's' ) , } , } , ] , } , { test : "s" , use : [ { loader : require . resolve ( 's' ) , } , { loader : require . resolve ( 's' ) , } , ] , } , ] , } , resolve : { alias : { react : path . resolve ( __dirname , 's' ) , 's' : path . resolve ( __dirname , 's' ) , } , extensions : [ 's' , 's' , 's' , 's' , 's' , 's' ] , } , stats : 's' , output : { path : path . resolve ( __dirname , 's' ) , filename : 's' , publicPath : 's' , } , devtool : 's' , devServer : { allowedHosts : [ 's' ] , host : 's' , port : 0 , contentBase : path . join ( __dirname , 's' ) , compress : true , historyApiFallback : true , hot : true , https : false , noInfo : true , } , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) ; module . exports = { webpack => { config . resolve . alias . react = path . resolve ( __dirname , 's' ) ; config . resolve . alias [ 's' ] = path . resolve ( __dirname , 's' ) ; config . resolve . alias [ 's' ] = path . resolve ( __dirname , 's' ) ; config . resolve . alias . urql = path . resolve ( __dirname , 's' ) ; return config } }	O O O O O O O O O O O O O O $config$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' import { createClient , dedupExchange , cacheExchange , fetchExchange , ssrExchange , } from 's' ; import 's' ; let urqlClient = null ; let ssrCache = null ; export default function initUrqlClient ( initialState ) { const isServer = typeof window === 's' ; if ( isServer || ! urqlClient ) { ssrCache = ssrExchange ( { initialState } ) ; urqlClient = createClient ( { url : 's' , suspense : isServer , exchanges : [ dedupExchange , cacheExchange , ssrCache , fetchExchange ] , } ) ; } return [ urqlClient , ssrCache ] ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const pipeExpression = ( t , pipeline ) => { let x = pipeline [ 0 ] ; for ( let i = 0 ; i < pipeline . length ; i ++ ) x = t . callExpression ( pipeline [ i ] , [ x ] ) ; return x ; } ; const pipePlugin = ( { types : t } ) => ( { visitor : { ImportDeclaration ( path , state ) { if ( path . node . source . value === 's' ) { const { specifiers } = path . node ; const pipeSpecifierIndex = specifiers . findIndex ( spec => { return spec . imported . name === 's' ; } ) ; if ( pipeSpecifierIndex > - 0 ) { const pipeSpecifier = specifiers [ pipeSpecifierIndex ] ; state . pipeName = pipeSpecifier . local . name ; if ( specifiers . length > 0 ) { path . node . specifiers . splice ( pipeSpecifierIndex , 0 ) ; } else { path . remove ( ) ; } } } } , CallExpression ( path , state ) { if ( state . pipeName ) { const callee = path . node . callee ; const args = path . node . arguments ; if ( callee . name !== state . pipeName ) { return ; } else if ( args . length === 0 ) { path . replaceWith ( t . identifier ( 's' ) ) ; } else { path . replaceWith ( pipeExpression ( t , args ) ) ; } } } } } ) ; export default pipePlugin ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' import { DEFAULT_EXTENSIONS } from 's' ; import commonjs from 's' ; import nodeResolve from 's' ; import typescript from 's' ; import buble from 's' ; import babel from 's' ; import replace from 's' ; import { terser } from 's' ; import transformPipe from 's' ; const pkgInfo = require ( 's' ) ; let external = [ 's' , 's' , 's' , 's' ] ; if ( pkgInfo . peerDependencies ) external . push ( ... Object . keys ( pkgInfo . peerDependencies ) ) ; if ( pkgInfo . dependencies ) external . push ( ... Object . keys ( pkgInfo . dependencies ) ) ; const externalPredicate = new RegExp ( `template` ) ; const externalTest = id => { if ( id === 's' ) { return false ; } return externalPredicate . test ( id ) ; } ; const terserPretty = terser ( { sourcemap : true , warnings : true , ecma : 0 , keep_fnames : true , 0 : false , compress : { pure_getters : true , toplevel : true , booleans_as_integers : false , keep_fnames : true , keep_fargs : true , if_return : false , 0 : false , sequences : false , loops : false , conditionals : false , join_vars : false } , mangle : false , output : { beautify : true , braces : true , indent_level : 0 } } ) ; const terserMinified = terser ( { sourcemap : true , warnings : true , ecma : 0 , 0 : false , toplevel : true , compress : { keep_infinity : true , pure_getters : true , passes : 0 } , output : { comments : false } } ) ; const makePlugins = ( isProduction = false ) => [ nodeResolve ( { mainFields : [ 's' , 's' , 's' ] , browser : true } ) , commonjs ( { ignoreGlobal : true , include : "s" , namedExports : { 's' : Object . keys ( require ( 's' ) ) } , } ) , typescript ( { typescript : require ( 's' ) , cacheRoot : 's' , useTsconfigDeclarationDir : true , tsconfigDefaults : { compilerOptions : { sourceMap : true } , } , tsconfigOverride : { exclude : [ 's' , 's' , 's' ] , compilerOptions : { declaration : ! isProduction , declarationDir : 's' , target : 's' , } , } , } ) , buble ( { transforms : { unicodeRegExp : false , dangerousForOf : true , dangerousTaggedTemplateString : true } , objectAssign : 's' , exclude : 's' } ) , babel ( { babelrc : false , extensions : [ ... DEFAULT_EXTENSIONS , 's' , 's' ] , exclude : 's' , presets : [ ] , plugins : [ transformPipe , 's' , 's' , [ 's' , { pragma : 's' , pragmaFrag : 's' , useBuiltIns : true } ] , [ 's' , { inlineHelpers : true , externalHelpers : true } ] ] } ) , isProduction && replace ( { 's' : JSON . stringify ( 's' ) } ) , isProduction ? terserMinified : terserPretty ] . filter ( Boolean ) ; const config = { input : 's' , external : externalTest , treeshake : { propertyReadSideEffects : false } } ; export default [ { ... config , plugins : makePlugins ( false ) , output : [ { sourcemap : true , legacy : true , freeze : false , esModule : false , file : 's' , format : 's' } , { sourcemap : true , legacy : true , freeze : false , esModule : false , file : 's' , format : 's' } ] } , { ... config , plugins : makePlugins ( true ) , onwarn : ( ) => { } , output : [ { sourcemap : false , legacy : true , freeze : false , file : 's' , format : 's' } , { sourcemap : false , legacy : true , freeze : false , file : 's' , format : 's' } ] } ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const { configure } = require ( 's' ) ; const Adapter = require ( 's' ) ; configure ( { adapter : new Adapter ( ) } ) ; global . AbortController = undefined ; global . fetch = jest . fn ( ) ; process . on ( 's' , error => { throw error ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { GraphQLError } from 's' ; const generateErrorMessage = ( networkErr ? , graphQlErrs ? : GraphQLError [ ] ) => { let error = 's' ; if ( networkErr !== undefined ) { return ( error = `template` ) ; } if ( graphQlErrs !== undefined ) { graphQlErrs . forEach ( err => { error += `template` ; } ) ; } return error . trim ( ) ; } ; const rehydrateGraphQlError = ( error ) : GraphQLError => { if ( typeof error === 's' ) { return new GraphQLError ( error ) ; } else if ( typeof error === 's' && error . message ) { return new GraphQLError ( error . message , error . nodes , error . source , error . positions , error . path , error . originalError , error . extensions || { } ) ; } else { return error as any ; } } ; export class CombinedError extends Error { public name : string ; public message : string ; public graphQLErrors : GraphQLError [ ] ; public networkError ? : Error ; public response ? : any ; constructor ( { networkError , graphQLErrors , response , } : { networkError ? : Error ; graphQLErrors ? : Array < string | GraphQLError | Error > ; response ? : any ; } ) { const normalizedGraphQLErrors = ( graphQLErrors || [ ] ) . map ( rehydrateGraphQlError ) ; const message = generateErrorMessage ( networkError , normalizedGraphQLErrors ) ; super ( message ) ; this . name = 's' ; this . message = message ; this . graphQLErrors = normalizedGraphQLErrors ; this . networkError = networkError ; this . response = response ; } toString ( ) { return this . message ; } }	O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { DocumentNode } from 's' ; import { Source } from 's' ; import { Client } from 's' ; import { CombinedError } from 's' ; export { ExecutionResult } from 's' ; export type Omit < T , K extends keyof T > = Pick < T , Exclude < keyof T , K > > ; export type PromisifiedSource < T = any > = Source < T > & { toPromise : ( ) => Promise < T > ; } ; export type OperationType = 's' | 's' | 's' | 's' ; export type RequestPolicy = | 's' | 's' | 's' | 's' ; export type CacheOutcome = 's' | 's' | 's' ; export interface GraphQLRequest { key : number ; query : DocumentNode ; variables ? : object ; } export interface OperationDebugMeta { source ? : string ; cacheOutcome ? : CacheOutcome ; networkLatency ? : number ; startTime ? : number ; } export interface OperationContext { [ key ] : any ; fetchOptions ? : RequestInit | ( ( ) => RequestInit ) ; requestPolicy : RequestPolicy ; url : string ; pollInterval ? : number ; meta ? : OperationDebugMeta ; suspense ? : boolean ; } export interface Operation extends GraphQLRequest { operationName : OperationType ; context : OperationContext ; } export interface OperationResult < Data = any > { operation : Operation ; data ? : Data ; error ? : CombinedError ; extensions ? : Record < string , any > ; stale ? : boolean ; } export interface ExchangeInput { forward : ExchangeIO ; client : Client ; } export type Exchange = ( input ) => ExchangeIO ; export type ExchangeIO = ( ops$ < Operation > ) => Source < OperationResult > ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ExchangeInput$ O O O O O O O O O $Source$ O O O O O O O O O O
export const phash = ( h , x ) : number => { h = h | 0 ; for ( let i = 0 , l = x . length | 0 ; i < l ; i ++ ) { h = ( h << 0 ) + h + x . charCodeAt ( i ) ; } return h ; } ; export const hash = ( x ) : number => phash ( 0 | 0 , x ) >>> 0 ;	O O O O O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O
const seen = new Set ( ) ; const stringify = ( x ) : string => { if ( x === undefined ) { return 's' ; } else if ( typeof x == 's' ) { return isFinite ( x ) ? 's' + x : 's' ; } else if ( typeof x !== 's' ) { return JSON . stringify ( x ) ; } else if ( x === null ) { return 's' ; } let out = 's' ; if ( Array . isArray ( x ) ) { out = 's' ; for ( let i = 0 , l = x . length ; i < l ; i ++ ) { if ( i > 0 ) out += 's' ; const value = stringify ( x [ i ] ) ; out += value . length > 0 ? value : 's' ; } out += 's' ; return out ; } else if ( seen . has ( x ) ) { throw new TypeError ( 's' ) ; } const keys = Object . keys ( x ) . sort ( ) ; seen . add ( x ) ; out = 's' ; for ( let i = 0 , l = keys . length ; i < l ; i ++ ) { const key = keys [ i ] ; const value = stringify ( x [ key ] ) ; if ( value . length !== 0 ) { if ( out . length > 0 ) out += 's' ; out += stringify ( key ) + 's' + value ; } } seen . delete ( x ) ; out += 's' ; return out ; } ; export const stringifyVariables = ( x ) : string => { seen . clear ( ) ; return stringify ( x ) ; } ;	O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O
import { DocumentNode , parse , print } from 's' ; import { hash , phash } from 's' ; import { stringifyVariables } from 's' ; import { GraphQLRequest , Operation , OperationContext } from 's' ; interface Documents { [ key ] : DocumentNode ; } const hashQuery = ( q ) : number => hash ( q . replace ( "s" , 's' ) . trim ( ) ) ; const docs = Object . create ( null ) ; const keyProp = 's' ; export const createRequest = ( q : string | DocumentNode , vars ? ) : GraphQLRequest => { let key ; let query ; if ( typeof q === 's' ) { key = hashQuery ( q ) ; query = docs [ key ] !== undefined ? docs [ key ] : parse ( q ) ; } else if ( ( q as any ) [ keyProp ] !== undefined ) { key = ( q as any ) [ keyProp ] ; query = q ; } else { key = hashQuery ( print ( q ) ) ; query = docs [ key ] !== undefined ? docs [ key ] : q ; } docs [ key ] = query ; ( query as any ) [ keyProp ] = key ; return { key : vars ? phash ( key , stringifyVariables ( vars ) ) >>> 0 : key , query , variables : vars || { } , } ; } ; export const addMetadata = ( source , meta < OperationContext [ 's' ] , undefined > ) => ( { ... source , context : { ... source . context , meta : { ... source . context . meta , ... meta , } , } , } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $Documents$ O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O O O O $number$ O O $DocumentNode$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Operation$ O $Exclude$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Operation , OperationResult } from 's' ; import { CombinedError } from 's' ; export const makeResult = ( operation , result , response ? ) : OperationResult => ( { operation , data : result . data , error : Array . isArray ( result . errors ) ? new CombinedError ( { graphQLErrors : result . errors , response , } ) : undefined , extensions : typeof result . extensions === 's' && result . extensions !== null ? result . extensions : undefined , } ) ; export const makeErrorResult = ( operation , error , response ? ) : OperationResult => ( { operation , data : undefined , error : new CombinedError ( { networkError : error , response , } ) , extensions : undefined , } ) ;	O O O O O O O O O O O O O O O O O O O O O $Operation$ O $any$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Operation$ O $Error$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { DocumentNode , FieldNode , InlineFragmentNode , Kind , visit , } from 's' ; interface EntityLike { [ key ] : EntityLike | EntityLike [ ] | any ; __typename : string | null | void ; } const collectTypes = ( obj : EntityLike | EntityLike [ ] , types : string [ ] = [ ] ) => { if ( Array . isArray ( obj ) ) { obj . forEach ( inner => { collectTypes ( inner , types ) ; } ) ; } else if ( typeof obj === 's' && obj !== null ) { for ( const key in obj ) { if ( Object . prototype . hasOwnProperty . call ( obj , key ) ) { const val = obj [ key ] ; if ( key === 's' && typeof val === 's' ) { types . push ( val ) ; } else if ( typeof val === 's' && val !== null ) { collectTypes ( val , types ) ; } } } } return types ; } ; export const collectTypesFromResponse = ( response ) => collectTypes ( response as EntityLike ) . filter ( ( v , i , a ) => a . indexOf ( v ) === i ) ; const formatNode = ( n : FieldNode | InlineFragmentNode ) => { if ( n . selectionSet === undefined ) { return false ; } if ( n . selectionSet . selections . some ( s => s . kind === 's' && s . name . value === 's' ) ) { return n ; } return { ... n , selectionSet : { ... n . selectionSet , selections : [ ... n . selectionSet . selections , { kind : Kind . FIELD , name : { kind : Kind . NAME , value : 's' , } , } , ] , } , } ; } ; export const formatDocument = ( astNode ) => visit ( astNode , { Field : formatNode , InlineFragment : formatNode , } ) ;	O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DocumentNode$ O O O O O O O O O O O O O O O O O O
import { Source , pipe , toPromise , take } from 's' ; import { PromisifiedSource } from 's' ; export function withPromise < T > ( source$ < T > ) < T > { ( source$ as PromisifiedSource < T > ) . toPromise = ( ) => pipe ( source$ , take ( 0 ) , toPromise ) ; return source$ as PromisifiedSource < T > ; }	O O O O O O O O O O O O O O O O O O O O O O $PromisifiedSource$ O O O O $Source$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export const noop = ( ) => { } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { pipe , share , filter , merge , map , tap } from 's' ; import { Exchange , OperationResult , Operation } from 's' ; import { CombinedError } from 's' ; export interface SerializedResult { data ? : any ; error ? : { networkError ? : string ; graphQLErrors : string [ ] ; } ; } export interface SSRData { [ key ] : SerializedResult ; } export interface SSRExchangeParams { isClient ? : boolean ; initialState ? : SSRData ; } export interface SSRExchange extends Exchange { restoreData ( data ) : void ; extractData ( ) : SSRData ; } const shouldSkip = ( { operationName } ) => operationName !== 's' && operationName !== 's' ; const serializeResult = ( { data , error , } ) : SerializedResult => { const result = { data , error : undefined } ; if ( error !== undefined ) { result . error = { networkError : 's' + error . networkError , graphQLErrors : error . graphQLErrors . map ( x => 's' + x ) , } ; } return result ; } ; const deserializeResult = ( operation , result ) : OperationResult => { const { error , data } = result ; const deserialized = { operation , data , extensions : undefined , error : undefined , } ; if ( error !== undefined ) { deserialized . error = new CombinedError ( { networkError : new Error ( error . networkError ) , graphQLErrors : error . graphQLErrors , } ) ; } return deserialized ; } ; export const ssrExchange = ( params ? ) : SSRExchange => { const data = { } ; const isCached = ( operation ) => { return ! shouldSkip ( operation ) && data [ operation . key ] !== undefined ; } ; const ssr = ( { client , forward } ) => ops$ => { const isClient = params && typeof params . isClient === 's' ? ! ! params . isClient : ! client . suspense ; const sharedOps$ = share ( ops$ ) ; let forwardedOps$ = pipe ( sharedOps$ , filter ( op => ! isCached ( op ) ) , forward ) ; let cachedOps$ = pipe ( sharedOps$ , filter ( op => isCached ( op ) ) , map ( op => { const serialized = data [ op . key ] ; return deserializeResult ( op , serialized ) ; } ) ) ; if ( ! isClient ) { forwardedOps$ = pipe ( forwardedOps$ , tap ( ( result ) => { const { operation } = result ; if ( ! shouldSkip ( operation ) ) { const serialized = serializeResult ( result ) ; data [ operation . key ] = serialized ; } } ) ) ; } else { cachedOps$ = pipe ( cachedOps$ , tap ( ( result ) => { delete data [ result . operation . key ] ; } ) ) ; } return merge ( [ forwardedOps$ , cachedOps$ ] ) ; } ; ssr . restoreData = ( restore ) => Object . assign ( data , restore ) ; ssr . extractData = ( ) => Object . assign ( { } , data ) ; if ( params && params . initialState ) { ssr . restoreData ( params . initialState ) ; } return ssr ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SSRData$ O O O O O O O O O O O O O O O O O $Operation$ O O O O O O O O O O O O O O O O O O O $OperationResult$ O O O O O O $SerializedResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Operation$ O $SerializedResult$ O O O O O O O O O O O O O O O $OperationResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SSRExchangeParams$ O O O O O O $SSRData$ O O O O O O O O $Operation$ O O O O O O O O O O O O O O O O O O O O O O $SSRExchange$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OperationResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OperationResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SSRData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { filter , map , merge , pipe , share , tap } from 's' ; import { Client } from 's' ; import { Exchange , Operation , OperationResult } from 's' ; import { addMetadata , collectTypesFromResponse , formatDocument , } from 's' ; type ResultCache = Map < number , OperationResult > ; interface OperationCache { [ key ] : Set < number > ; } const shouldSkip = ( { operationName } ) => operationName !== 's' && operationName !== 's' ; export const cacheExchange = ( { forward , client } ) => { const resultCache = new Map ( ) as ResultCache ; const operationCache = Object . create ( null ) as OperationCache ; const mapTypeNames = ( operation ) : Operation => ( { ... operation , query : formatDocument ( operation . query ) , } ) ; const handleAfterMutation = afterMutation ( resultCache , operationCache , client ) ; const handleAfterQuery = afterQuery ( resultCache , operationCache ) ; const isOperationCached = operation => { const { key , operationName , context : { requestPolicy } , } = operation ; return ( operationName === 's' && requestPolicy !== 's' && ( requestPolicy === 's' || resultCache . has ( key ) ) ) ; } ; return ops$ => { const sharedOps$ = share ( ops$ ) ; const cachedOps$ = pipe ( sharedOps$ , filter ( op => ! shouldSkip ( op ) && isOperationCached ( op ) ) , map ( operation => { const cachedResult = resultCache . get ( operation . key ) ; const result = { ... cachedResult , operation : addMetadata ( operation , { cacheOutcome : cachedResult ? 's' : 's' , } ) , } ; if ( operation . context . requestPolicy === 's' ) { result . stale = true ; reexecuteOperation ( client , operation ) ; } return result ; } ) ) ; const forwardedOps$ = pipe ( merge ( [ pipe ( sharedOps$ , filter ( op => ! shouldSkip ( op ) && ! isOperationCached ( op ) ) , map ( mapTypeNames ) ) , pipe ( sharedOps$ , filter ( op => shouldSkip ( op ) ) ) , ] ) , map ( op => addMetadata ( op , { cacheOutcome : 's' } ) ) , forward , tap ( response => { if ( response . operation && response . operation . operationName === 's' ) { handleAfterMutation ( response ) ; } else if ( response . operation && response . operation . operationName === 's' ) { handleAfterQuery ( response ) ; } } ) ) ; return merge ( [ cachedOps$ , forwardedOps$ ] ) ; } ; } ; const reexecuteOperation = ( client , operation ) => { return client . reexecuteOperation ( { ... operation , context : { ... operation . context , requestPolicy : 's' , } , } ) ; } ; export const afterMutation = ( resultCache , operationCache , client ) => ( response ) => { const pendingOperations = new Set < number > ( ) ; collectTypesFromResponse ( response . data ) . forEach ( typeName => { const operations = operationCache [ typeName ] || ( operationCache [ typeName ] = new Set ( ) ) ; operations . forEach ( key => { pendingOperations . add ( key ) ; } ) ; operations . clear ( ) ; } ) ; pendingOperations . forEach ( key => { if ( resultCache . has ( key ) ) { const operation = ( resultCache . get ( key ) as OperationResult ) . operation ; resultCache . delete ( key ) ; reexecuteOperation ( client , operation ) ; } } ) ; } ; const afterQuery = ( resultCache , operationCache ) => ( response ) => { const { operation , data , error } = response ; if ( data === undefined || data === null ) { return ; } resultCache . set ( operation . key , { operation , data , error } ) ; collectTypesFromResponse ( response . data ) . forEach ( typeName => { const operations = operationCache [ typeName ] || ( operationCache [ typeName ] = new Set ( ) ) ; operations . add ( operation . key ) ; } ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O $Operation$ O O O O O O O O O O O O $Exchange$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Operation$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OperationResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Client$ O $Operation$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResultCache$ O $OperationCache$ O $Client$ O O O $OperationResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResultCache$ O $OperationCache$ O O O $OperationResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { print } from 's' ; import { filter , make , merge , mergeMap , pipe , share , Source , takeUntil , } from 's' ; import { makeResult , makeErrorResult } from 's' ; import { Exchange , ExecutionResult , Operation , OperationContext , OperationResult , } from 's' ; export interface ObserverLike < T > { next : ( value : T ) => void ; error : ( err ) => void ; complete : ( ) => void ; } export interface ObservableLike < T > { subscribe ( observer < T > ) : { unsubscribe : ( ) => void ; } ; } export interface SubscriptionOperation { query : string ; variables ? : object ; key : string ; context : OperationContext ; } export type SubscriptionForwarder = ( operation ) => ObservableLike < ExecutionResult & { extensions ? : Record < string , any > } > ; export interface SubscriptionExchangeOpts { forwardSubscription : SubscriptionForwarder ; } const isSubscriptionOperation = ( operation ) => operation . operationName === 's' ; export const subscriptionExchange = ( { forwardSubscription , } ) : Exchange => ( { client , forward } ) => { const createSubscriptionSource = ( operation ) : Source < OperationResult > => { const observableish = forwardSubscription ( { key : operation . key . toString ( 0 ) , query : print ( operation . query ) , variables : operation . variables , context : { ... operation . context } , } ) ; return make < OperationResult > ( ( [ next , complete ] ) => { let isComplete = false ; const sub = observableish . subscribe ( { next => next ( makeResult ( operation , result ) ) , error => next ( makeErrorResult ( operation , err ) ) , complete : ( ) => { if ( ! isComplete ) { client . reexecuteOperation ( { ... operation , operationName : 's' , } ) ; } complete ( ) ; } , } ) ; return ( ) => { isComplete = true ; sub . unsubscribe ( ) ; } ; } ) ; } ; return ops$ => { const sharedOps$ = share ( ops$ ) ; const subscriptionResults$ = pipe ( sharedOps$ , filter ( isSubscriptionOperation ) , mergeMap ( operation => { const { key } = operation ; const teardown$ = pipe ( sharedOps$ , filter ( op => op . operationName === 's' && op . key === key ) ) ; return pipe ( createSubscriptionSource ( operation ) , takeUntil ( teardown$ ) ) ; } ) ) ; const forward$ = pipe ( sharedOps$ , filter ( op => ! isSubscriptionOperation ( op ) ) , forward ) ; return merge ( [ subscriptionResults$ , forward$ ] ) ; } ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O $ObserverLike$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SubscriptionOperation$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Operation$ O O O O O O O O O O O O O O O O $SubscriptionExchangeOpts$ O O O O O O O O O O O O O O O O O $Operation$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $result$ O O O O O O O O O O O $err$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { pipe , tap } from 's' ; import { Exchange } from 's' ; export const debugExchange = ( { forward } ) => { if ( process . env . NODE_ENV === 's' ) { return ops$ => forward ( ops$ ) ; } else { return ops$ => pipe ( ops$ , tap ( op => console . log ( 's' , op ) ) , forward , tap ( result => console . log ( 's' , result ) ) ) ; } } ;	O O O O O O O O O O O O O O O O O O $Exchange$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { filter , pipe , tap } from 's' ; import { Exchange , Operation , OperationResult } from 's' ; export const dedupExchange = ( { forward } ) => { const inFlightKeys = new Set < number > ( ) ; const filterIncomingOperation = ( operation ) => { const { key , operationName } = operation ; if ( operationName === 's' ) { inFlightKeys . delete ( key ) ; return true ; } else if ( operationName !== 's' ) { return true ; } const isInFlight = inFlightKeys . has ( key ) ; inFlightKeys . add ( key ) ; return ! isInFlight ; } ; const afterOperationResult = ( { operation } ) => { inFlightKeys . delete ( operation . key ) ; } ; return ops$ => { const forward$ = pipe ( ops$ , filter ( filterIncomingOperation ) ) ; return pipe ( forward ( forward$ ) , tap ( afterOperationResult ) ) ; } ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O $Exchange$ O O O O O O O O O O O O O O O O O O O O O O O $Operation$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OperationResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Kind , DocumentNode , OperationDefinitionNode , print } from 's' ; import { filter , make , merge , mergeMap , pipe , share , takeUntil } from 's' ; import { Exchange , Operation , OperationResult } from 's' ; import { makeResult , makeErrorResult } from 's' ; interface Body { query : string ; variables : void | object ; operationName ? : string ; } export const fetchExchange = ( { forward } ) => { const isOperationFetchable = ( operation ) => { const { operationName } = operation ; return operationName === 's' || operationName === 's' ; } ; return ops$ => { const sharedOps$ = share ( ops$ ) ; const fetchResults$ = pipe ( sharedOps$ , filter ( isOperationFetchable ) , mergeMap ( operation => { const { key } = operation ; const teardown$ = pipe ( sharedOps$ , filter ( op => op . operationName === 's' && op . key === key ) ) ; return pipe ( createFetchSource ( operation ) , takeUntil ( teardown$ ) ) ; } ) ) ; const forward$ = pipe ( sharedOps$ , filter ( op => ! isOperationFetchable ( op ) ) , forward ) ; return merge ( [ fetchResults$ , forward$ ] ) ; } ; } ; const getOperationName = ( query ) : string | null => { const node = query . definitions . find ( ( node ) : node is OperationDefinitionNode => { return node . kind === Kind . OPERATION_DEFINITION && node . name ; } ) ; return node !== undefined && node . name ? node . name . value : null ; } ; const createFetchSource = ( operation ) => { if ( process . env . NODE_ENV !== 's' && operation . operationName === 's' ) { throw new Error ( 's' ) ; } return make < OperationResult > ( ( [ next , complete ] ) => { const abortController = typeof AbortController !== 's' ? new AbortController ( ) : undefined ; const { context } = operation ; const extraOptions = typeof context . fetchOptions === 's' ? context . fetchOptions ( ) : context . fetchOptions || { } ; const operationName = getOperationName ( operation . query ) ; const body = { query : print ( operation . query ) , variables : operation . variables , } ; if ( operationName !== null ) { body . operationName = operationName ; } const fetchOptions = { body : JSON . stringify ( body ) , method : 's' , ... extraOptions , headers : { 's' : 's' , ... extraOptions . headers , } , signal : abortController !== undefined ? abortController . signal : undefined , } ; executeFetch ( operation , fetchOptions ) . then ( result => { if ( result !== undefined ) { next ( result ) ; } complete ( ) ; } ) ; return ( ) => { if ( abortController !== undefined ) { abortController . abort ( ) ; } } ; } ) ; } ; const executeFetch = ( operation , opts ) => { const { url , fetch : fetcher } = operation . context ; let response : Response | undefined ; return ( fetcher || fetch ) ( url , opts ) . then ( res => { const { status } = res ; const statusRangeEnd = opts . redirect === 's' ? 0 : 0 ; response = res ; if ( status < 0 || status >= statusRangeEnd ) { throw new Error ( res . statusText ) ; } else { return res . json ( ) ; } } ) . then ( result => makeResult ( operation , result , response ) ) . catch ( err => { if ( err . name !== 's' ) { return makeErrorResult ( operation , err , response ) ; } } ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Exchange$ O O O O O O O O O O O O $Operation$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DocumentNode$ O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Operation$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Body$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Operation$ O $RequestInit$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { filter , pipe , tap } from 's' ; import { ExchangeIO , Operation } from 's' ; export const fallbackExchangeIO = ops$ => pipe ( ops$ , tap < Operation > ( ( { operationName } ) => { if ( operationName !== 's' && process . env . NODE_ENV !== 's' ) { console . warn ( `template` ) ; } } ) , filter < any > ( ( ) => false ) ) ;	O O O O O O O O O O O O O O O O O O O O O O $ExchangeIO$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Exchange } from 's' ; export const composeExchanges = ( exchanges : Exchange [ ] ) : Exchange => { if ( exchanges . length === 0 ) { return exchanges [ 0 ] ; } return ( { client , forward : outerForward } ) => { return exchanges . reduceRight ( ( forward , exchange ) => { return exchange ( { client , forward } ) ; } , outerForward ) ; } ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export { ssrExchange } from 's' ; export { cacheExchange } from 's' ; export { subscriptionExchange } from 's' ; export { debugExchange } from 's' ; export { dedupExchange } from 's' ; export { fetchExchange } from 's' ; export { fallbackExchangeIO } from 's' ; export { composeExchanges } from 's' ; import { cacheExchange } from 's' ; import { dedupExchange } from 's' ; import { fetchExchange } from 's' ; export const defaultExchanges = [ dedupExchange , cacheExchange , fetchExchange ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { print } from 's' ; import gql from 's' ; import { map , pipe , subscribe , tap } from 's' ; import { createClient } from 's' ; const url = 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const c = createClient ( { url , } ) ; expect ( c ) . toMatchSnapshot ( ) ; } ) ; } ) ; const query = { key : 0 , query : `template` , variables : { example : 0 } , } ; let receivedOps : any [ ] = [ ] ; let client = createClient ( { url : 's' } ) ; const receiveMock = jest . fn ( s => pipe ( s , tap ( op => ( receivedOps = [ ... receivedOps , op ] ) ) , map ( op => ( { operation : op } ) ) ) ) ; const exchangeMock = jest . fn ( ( ) => receiveMock ) ; beforeEach ( ( ) => { receivedOps = [ ] ; exchangeMock . mockClear ( ) ; receiveMock . mockClear ( ) ; client = createClient ( { url , exchanges : [ exchangeMock ] as any [ ] , requestPolicy : 's' , } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( typeof exchangeMock . mock . calls [ 0 ] [ 0 ] . forward ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( exchangeMock . mock . calls [ 0 ] [ 0 ] ) . toHaveProperty ( 's' , client ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const queryResult = client . query ( `template` , { example : 0 } , { } ) . toPromise ( ) ; const received = receivedOps [ 0 ] ; expect ( print ( received . query ) ) . toEqual ( print ( query . query ) ) ; expect ( received . key ) . toBeDefined ( ) ; expect ( received . variables ) . toEqual ( { example : 0 } ) ; expect ( received . operationName ) . toEqual ( 's' ) ; expect ( received . context ) . toEqual ( { url : 's' , requestPolicy : 's' , fetchOptions : undefined , fetch : undefined , suspense : false , } ) ; expect ( queryResult ) . toHaveProperty ( 's' ) ; } ) ; it ( 's' , ( ) => { const mutationResult = client . mutation ( `template` , { example : 0 } ) . toPromise ( ) ; const received = receivedOps [ 0 ] ; expect ( print ( received . query ) ) . toEqual ( print ( query . query ) ) ; expect ( received . key ) . toBeDefined ( ) ; expect ( received . variables ) . toEqual ( { example : 0 } ) ; expect ( received . operationName ) . toEqual ( 's' ) ; expect ( received . context ) . toEqual ( { url : 's' , requestPolicy : 's' , fetchOptions : undefined , fetch : undefined , } ) ; expect ( mutationResult ) . toHaveProperty ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { pipe ( client . executeQuery ( query ) , subscribe ( x => x ) ) ; const receivedQuery = receivedOps [ 0 ] . query ; expect ( print ( receivedQuery ) ) . toBe ( print ( query . query ) ) ; } ) ; it ( 's' , ( ) => { pipe ( client . executeQuery ( query ) , subscribe ( x => x ) ) ; expect ( receivedOps [ 0 ] ) . toHaveProperty ( 's' , query . variables ) ; } ) ; it ( 's' , ( ) => { pipe ( client . executeQuery ( query ) , subscribe ( x => x ) ) ; expect ( receivedOps [ 0 ] . context ) . toHaveProperty ( 's' , 's' ) ; } ) ; it ( 's' , ( ) => { pipe ( client . executeQuery ( query , { requestPolicy : 's' } ) , subscribe ( x => x ) ) ; expect ( receivedOps [ 0 ] . context ) . toHaveProperty ( 's' , 's' ) ; } ) ; it ( 's' , ( ) => { pipe ( client . executeQuery ( query ) , subscribe ( x => x ) ) ; expect ( receivedOps [ 0 ] ) . toHaveProperty ( 's' , 's' ) ; } ) ; it ( 's' , ( ) => { pipe ( client . executeQuery ( query ) , subscribe ( x => x ) ) ; expect ( receivedOps [ 0 ] ) . toHaveProperty ( 's' , url ) ; } ) ; it ( 's' , ( ) => { jest . useFakeTimers ( ) ; pipe ( client . executeQuery ( query , { pollInterval : 0 } ) , subscribe ( x => x ) ) ; expect ( receivedOps . length ) . toEqual ( 0 ) ; jest . runOnlyPendingTimers ( ) ; expect ( receivedOps . length ) . toEqual ( 0 ) ; expect ( receivedOps [ 0 ] . operationName ) . toEqual ( 's' ) ; expect ( receivedOps [ 0 ] . operationName ) . toEqual ( 's' ) ; expect ( receivedOps [ 0 ] . operationName ) . toEqual ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { pipe ( client . executeMutation ( query ) , subscribe ( x => x ) ) ; const receivedQuery = receivedOps [ 0 ] . query ; expect ( print ( receivedQuery ) ) . toBe ( print ( query . query ) ) ; } ) ; it ( 's' , ( ) => { pipe ( client . executeMutation ( query ) , subscribe ( x => x ) ) ; expect ( receivedOps [ 0 ] ) . toHaveProperty ( 's' , query . variables ) ; } ) ; it ( 's' , ( ) => { pipe ( client . executeMutation ( query ) , subscribe ( x => x ) ) ; expect ( receivedOps [ 0 ] ) . toHaveProperty ( 's' , 's' ) ; } ) ; it ( 's' , ( ) => { pipe ( client . executeMutation ( query ) , subscribe ( x => x ) ) ; expect ( receivedOps [ 0 ] ) . toHaveProperty ( 's' , url ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , async ( ) => { pipe ( client . executeSubscription ( query ) , subscribe ( x => x ) ) ; const receivedQuery = receivedOps [ 0 ] . query ; expect ( print ( receivedQuery ) ) . toBe ( print ( query . query ) ) ; } ) ; it ( 's' , ( ) => { pipe ( client . executeSubscription ( query ) , subscribe ( x => x ) ) ; expect ( receivedOps [ 0 ] ) . toHaveProperty ( 's' , query . variables ) ; } ) ; it ( 's' , ( ) => { pipe ( client . executeSubscription ( query ) , subscribe ( x => x ) ) ; expect ( receivedOps [ 0 ] ) . toHaveProperty ( 's' , 's' ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { createContext , useContext } from 's' ; import { Client , createClient } from 's' ; const defaultClient = createClient ( { url : 's' } ) ; export const Context = createContext < Client > ( defaultClient ) ; export const Provider = Context . Provider ; export const Consumer = Context . Consumer ; let hasWarnedAboutDefault = false ; export const useClient = ( ) : Client => { const client = useContext ( Context ) ; if ( process . env . NODE_ENV !== 's' && client === defaultClient && ! hasWarnedAboutDefault ) { hasWarnedAboutDefault = true ; console . warn ( "s" + 's' + 's' + "s" ) ; } return client ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { DocumentNode } from 's' ; import { useState , useCallback } from 's' ; import { pipe , toPromise } from 's' ; import { useClient } from 's' ; import { OperationResult , OperationContext } from 's' ; import { CombinedError , createRequest } from 's' ; export interface UseMutationState < T > { fetching : boolean ; stale : boolean ; data ? : T ; error ? : CombinedError ; extensions ? : Record < string , any > ; } export type UseMutationResponse < T , V > = [ UseMutationState < T > , ( variables ? : V , context ? < OperationContext > ) => Promise < OperationResult < T > > ] ; export const useMutation = < T = any , V = object > ( query : DocumentNode | string ) : UseMutationResponse < T , V > => { const client = useClient ( ) ; const [ state , setState ] = useState < UseMutationState < T > > ( { fetching : false , stale : false , error : undefined , data : undefined , extensions : undefined , } ) ; const executeMutation = useCallback ( ( variables ? : V , context ? < OperationContext > ) => { setState ( { fetching : true , stale : false , error : undefined , data : undefined , extensions : undefined , } ) ; const request = createRequest ( query , variables as any ) ; return pipe ( client . executeMutation ( request , context || { } ) , toPromise ) . then ( result => { const { stale , data , error , extensions } = result ; setState ( { fetching : false , stale : ! ! stale , data , error , extensions } ) ; return result ; } ) ; } , [ client , query , setState ] ) ; return [ state , executeMutation ] ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { DocumentNode } from 's' ; import { useRef , useMemo } from 's' ; import { GraphQLRequest } from 's' ; import { createRequest } from 's' ; export const useRequest = ( query : string | DocumentNode , variables ? ) : GraphQLRequest => { const prev = useRef < undefined | GraphQLRequest > ( undefined ) ; return useMemo ( ( ) => { const request = createRequest ( query , variables ) ; if ( prev . current !== undefined && prev . current . key === request . key ) { return prev . current ; } else { prev . current = request ; return request ; } } , [ query , variables ] ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O
import { ReactElement } from 's' ; import { DocumentNode } from 's' ; import { OperationResult , OperationContext } from 's' ; import { useMutation , UseMutationState } from 's' ; export interface MutationProps < T , V > { query : DocumentNode | string ; children : ( arg < T , V > ) => ReactElement < any > ; } export interface MutationState < T , V > extends UseMutationState < T > { executeMutation : ( variables ? : V , context ? < OperationContext > ) => Promise < OperationResult < T > > ; } export function Mutation < T = any , V = any > ( { children , query , } < T , V > ) < any > { const [ state , executeMutation ] = useMutation < T , V > ( query ) ; return children ( { ... state , executeMutation } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $MutationState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O O O O O O O O O O O O O $ReactElement$ O O O O O O O O O O O O O O O $MutationProps$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ReactElement } from 's' ; import { OperationContext } from 's' ; import { useQuery , UseQueryArgs , UseQueryState } from 's' ; export interface QueryProps < T , V > extends UseQueryArgs < V > { children : ( arg < T > ) => ReactElement < any > ; } export interface QueryState < T > extends UseQueryState < T > { executeQuery : ( opts ? < OperationContext > ) => void ; } export function Query < T = any , V = any > ( props < T , V > ) < any > { const [ state , executeQuery ] = useQuery < T , V > ( props ) ; return props . children ( { ... state , executeQuery } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $QueryState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O O O O O O O $ReactElement$ O O O O O O O O O O $QueryProps$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ReactElement } from 's' ; import { OperationContext } from 's' ; import { useSubscription , UseSubscriptionArgs , UseSubscriptionState , SubscriptionHandler , } from 's' ; export interface SubscriptionProps < T , R , V > extends UseSubscriptionArgs < V > { handler ? : SubscriptionHandler < T , R > ; children : ( arg < R > ) => ReactElement < any > ; } export interface SubscriptionState < T > extends UseSubscriptionState < T > { executeSubscription : ( opts ? < OperationContext > ) => void ; } export function Subscription < T = any , R = T , V = any > ( props < T , R , V > ) < any > { const [ state , executeSubscription ] = useSubscription < T , R , V > ( props , props . handler ) ; return props . children ( { ... state , executeSubscription } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SubscriptionState$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $Partial$ O O O O O O O O O O $ReactElement$ O O O O O O O O O O O O O O $SubscriptionProps$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ;	O O O O O O O O O O O O O O O
import { Consumer , Provider } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( Consumer ) . toMatchSnapshot ( ) ; } ) ; it ( 's' , ( ) => { expect ( typeof Consumer ) . toBe ( 's' ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( Provider ) . toMatchSnapshot ( ) ; } ) ; it ( 's' , ( ) => { expect ( typeof Provider ) . toBe ( 's' ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import gql from 's' ; import { ExecutionResult , GraphQLRequest , Operation , OperationContext , OperationResult , } from 's' ; const context = { fetchOptions : { method : 's' , } , requestPolicy : 's' , url : 's' , } ; export const queryGql = { key : 0 , query : `template` , variables : { name : 's' , } , } ; export const mutationGql = { key : 0 , query : `template` , variables : { name : 's' , } , } ; export const subscriptionGql = { key : 0 , query : `template` , variables : { user : 's' , } , } ; export const teardownOperation = { query : queryGql . query , variables : queryGql . variables , key : queryGql . key , operationName : 's' , context , } ; export const queryOperation = { query : teardownOperation . query , variables : teardownOperation . variables , key : teardownOperation . key , operationName : 's' , context , } ; export const mutationOperation = { query : mutationGql . query , variables : mutationGql . variables , key : mutationGql . key , operationName : 's' , context , } ; export const subscriptionOperation = { query : subscriptionGql . query , variables : subscriptionGql . variables , key : subscriptionGql . key , operationName : 's' , context , } ; export const undefinedQueryResponse = { operation : queryOperation , } ; export const queryResponse = { operation : queryOperation , data : { user : { name : 's' , } , } , } ; export const mutationResponse = { operation : mutationOperation , data : { } , } ; export const subscriptionResult = { data : { } , } ;	O O O O O O O O O O O O O O O O O O O O O O $OperationContext$ O O O O O O O O O O O O O O O O O O O O O O O $GraphQLRequest$ O O O O O O O O O O O O O O O O O O O O O O O $GraphQLRequest$ O O O O O O O O O O O O O O O O O O O O O O O $GraphQLRequest$ O O O O O O O O O O O O O O O O O O O O O O O $Operation$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Operation$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Operation$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Operation$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OperationResult$ O O O O O O O O O O $OperationResult$ O O O O O O O O O O O O O O O O O O O O O O O O $OperationResult$ O O O O O O O O O O O O O O O $ExecutionResult$ O O O O O O O O O
export * from 's' ;	O O O O O
import { makeSubject , map , pipe , publish , Source , Subject , forEach , scan , toPromise , } from 's' ; import { Client } from 's' ; import { mutationOperation , mutationResponse , queryOperation , queryResponse , subscriptionOperation , subscriptionResult , undefinedQueryResponse , } from 's' ; import { Operation , OperationResult } from 's' ; import { afterMutation , cacheExchange } from 's' ; let response ; let exchangeArgs ; let forwardedOperations : Operation [ ] ; let reexecuteOperation ; let input < Operation > ; beforeEach ( ( ) => { response = queryResponse ; forwardedOperations = [ ] ; reexecuteOperation = jest . fn ( ) ; input = makeSubject < Operation > ( ) ; const forward = ( s < Operation > ) => { return pipe ( s , map ( op => { forwardedOperations . push ( op ) ; return response ; } ) ) ; } ; const client = { reexecuteOperation : reexecuteOperation as any , } as Client ; exchangeArgs = { forward , client } ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const [ ops$ , next , complete ] = input ; const exchange = cacheExchange ( exchangeArgs ) ( ops$ ) ; publish ( exchange ) ; next ( queryOperation ) ; complete ( ) ; expect ( forwardedOperations . length ) . toBe ( 0 ) ; expect ( reexecuteOperation ) . not . toBeCalled ( ) ; } ) ; it ( 's' , ( ) => { const [ ops$ , next , complete ] = input ; const exchange = cacheExchange ( exchangeArgs ) ( ops$ ) ; publish ( exchange ) ; next ( queryOperation ) ; next ( queryOperation ) ; complete ( ) ; expect ( forwardedOperations . length ) . toBe ( 0 ) ; expect ( reexecuteOperation ) . not . toBeCalled ( ) ; } ) ; it ( 's' , ( ) => { const [ ops$ , next , complete ] = input ; const result = jest . fn ( ) ; const exchange = cacheExchange ( exchangeArgs ) ( ops$ ) ; pipe ( exchange , forEach ( result ) ) ; next ( queryOperation ) ; next ( { ... queryOperation , context : { ... queryOperation . context , requestPolicy : 's' , } , } ) ; complete ( ) ; expect ( forwardedOperations . length ) . toBe ( 0 ) ; expect ( reexecuteOperation ) . toHaveBeenCalledTimes ( 0 ) ; expect ( result ) . toHaveBeenCalledTimes ( 0 ) ; expect ( result . mock . calls [ 0 ] [ 0 ] . stale ) . toBe ( true ) ; expect ( reexecuteOperation . mock . calls [ 0 ] [ 0 ] ) . toEqual ( { ... queryOperation , context : { ... queryOperation . context , requestPolicy : 's' } , } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const [ ops$ , next , complete ] = input ; const exchange = cacheExchange ( exchangeArgs ) ( ops$ ) ; publish ( exchange ) ; next ( queryOperation ) ; complete ( ) ; expect ( forwardedOperations [ 0 ] . context ) . toHaveProperty ( 's' , 's' ) ; } ) ; it ( 's' , async ( ) => { const [ ops$ , next , complete ] = input ; const exchange = cacheExchange ( exchangeArgs ) ( ops$ ) ; const results$ = pipe ( exchange , scan ( ( acc , x ) => [ ... acc , x ] , [ ] as OperationResult [ ] ) , toPromise ) ; publish ( exchange ) ; next ( queryOperation ) ; next ( queryOperation ) ; complete ( ) ; const results = await results$ ; expect ( results [ 0 ] . operation . context ) . toHaveProperty ( 's' , 's' ) ; } ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { response = mutationResponse ; const [ ops$ , next , complete ] = input ; const exchange = cacheExchange ( exchangeArgs ) ( ops$ ) ; publish ( exchange ) ; next ( mutationOperation ) ; next ( mutationOperation ) ; complete ( ) ; expect ( forwardedOperations . length ) . toBe ( 0 ) ; expect ( reexecuteOperation ) . not . toBeCalled ( ) ; } ) ; it ( 's' , ( ) => { const typename = 's' ; const resultCache = new Map ( [ [ 0 , queryResponse ] ] ) ; const operationCache = { [ typename ] : new Set ( [ 0 ] ) } ; afterMutation ( resultCache , operationCache , exchangeArgs . client ) ( { ... mutationResponse , data : { todos : [ { id : 0 , __typename : typename , } , ] , } , } ) ; expect ( reexecuteOperation ) . toBeCalledTimes ( 0 ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { response = subscriptionResult ; const [ ops$ , next , complete ] = input ; const exchange = cacheExchange ( exchangeArgs ) ( ops$ ) ; publish ( exchange ) ; next ( subscriptionOperation ) ; next ( subscriptionOperation ) ; complete ( ) ; expect ( forwardedOperations . length ) . toBe ( 0 ) ; expect ( reexecuteOperation ) . not . toBeCalled ( ) ; } ) ; } ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { response = undefinedQueryResponse ; forwardedOperations = [ ] ; reexecuteOperation = jest . fn ( ) ; input = makeSubject < Operation > ( ) ; const forward = ( s < Operation > ) => { return pipe ( s , map ( op => { forwardedOperations . push ( op ) ; return response ; } ) ) ; } ; const client = { reexecuteOperation : reexecuteOperation as any , } as Client ; exchangeArgs = { forward , client } ; } ) ; it ( 's' , ( ) => { const [ ops$ , next , complete ] = input ; const exchange = cacheExchange ( exchangeArgs ) ( ops$ ) ; publish ( exchange ) ; next ( queryOperation ) ; next ( queryOperation ) ; complete ( ) ; expect ( forwardedOperations . length ) . toBe ( 0 ) ; expect ( reexecuteOperation ) . not . toBeCalled ( ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Subject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Source$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Source$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { empty , Source } from 's' ; import { Client } from 's' ; import { Exchange } from 's' ; import { composeExchanges } from 's' ; const mockClient = { } as Client ; const noopExchange = ( { forward } ) => ops$ => forward ( ops$ ) ; it ( 's' , ( ) => { expect ( composeExchanges ( [ noopExchange ] ) ) . toBe ( noopExchange ) ; } ) ; it ( 's' , ( ) => { let counter = 0 ; const firstExchange = ( { client , forward } ) => { expect ( client ) . toBe ( mockClient ) ; expect ( counter ++ ) . toBe ( 0 ) ; return ops$ => { expect ( counter ++ ) . toBe ( 0 ) ; return forward ( ops$ ) ; } ; } ; const secondExchange = ( { client , forward } ) => { expect ( client ) . toBe ( mockClient ) ; expect ( counter ++ ) . toBe ( 0 ) ; return ops$ => { expect ( counter ++ ) . toBe ( 0 ) ; return forward ( ops$ ) ; } ; } ; const exchange = composeExchanges ( [ firstExchange , secondExchange ] ) ; const outerFw = jest . fn ( ( ) => noopExchange ) as any ; exchange ( { client : mockClient , forward : outerFw } ) ( empty as Source < any > ) ; expect ( outerFw ) . toHaveBeenCalled ( ) ; expect ( counter ) . toBe ( 0 ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Exchange$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Exchange$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Exchange$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeSubject , map , pipe , publish , Source , Subject } from 's' ; import { Client } from 's' ; import { queryOperation , queryResponse } from 's' ; import { Operation } from 's' ; import { debugExchange } from 's' ; let exchangeArgs ; let forwardedOperations : Operation [ ] ; let input < Operation > ; beforeEach ( ( ) => { forwardedOperations = [ ] ; input = makeSubject < Operation > ( ) ; const forward = ( s < Operation > ) => { return pipe ( s , map ( op => { forwardedOperations . push ( op ) ; return queryResponse ; } ) ) ; } ; exchangeArgs = { forward , subject : { } as Client } ; } ) ; it ( 's' , async ( ) => { jest . spyOn ( global . console , 's' ) . mockImplementation ( ) ; const [ ops$ , next , complete ] = input ; const exchange = debugExchange ( exchangeArgs ) ( ops$ ) ; publish ( exchange ) ; next ( queryOperation ) ; complete ( ) ; expect ( console . log ) . toBeCalled ( ) ; expect ( console . log ) . toBeCalledTimes ( 0 ) ; } ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { process . env . NODE_ENV = 's' ; } ) ; afterEach ( ( ) => { process . env . NODE_ENV = 's' ; } ) ; it ( 's' , ( ) => { const [ ops$ ] = input ; debugExchange ( { forward => { expect ( ops ) . toBe ( ops$ ) ; } , } as any ) ( ops$ ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Subject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Source$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ops$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { filter , makeSubject , map , pipe , publish , Source , Subject , } from 's' ; import { Client } from 's' ; import { mutationOperation , queryOperation , queryResponse , } from 's' ; import { Operation } from 's' ; import { dedupExchange } from 's' ; let shouldRespond = false ; let exchangeArgs ; let forwardedOperations : Operation [ ] ; let input < Operation > ; beforeEach ( ( ) => { shouldRespond = false ; forwardedOperations = [ ] ; input = makeSubject < Operation > ( ) ; const forward = ( s < Operation > ) => { return pipe ( s , map ( op => { forwardedOperations . push ( op ) ; return queryResponse ; } ) , filter ( ( ) => ! ! shouldRespond ) ) ; } ; exchangeArgs = { forward , subject : { } as Client } ; } ) ; it ( 's' , async ( ) => { const [ ops$ , next , complete ] = input ; const exchange = dedupExchange ( exchangeArgs ) ( ops$ ) ; publish ( exchange ) ; next ( queryOperation ) ; complete ( ) ; expect ( forwardedOperations . length ) . toBe ( 0 ) ; } ) ; it ( 's' , async ( ) => { shouldRespond = false ; const [ ops$ , next , complete ] = input ; const exchange = dedupExchange ( exchangeArgs ) ( ops$ ) ; publish ( exchange ) ; next ( queryOperation ) ; next ( queryOperation ) ; complete ( ) ; expect ( forwardedOperations . length ) . toBe ( 0 ) ; } ) ; it ( 's' , async ( ) => { shouldRespond = true ; const [ ops$ , next , complete ] = input ; const exchange = dedupExchange ( exchangeArgs ) ( ops$ ) ; publish ( exchange ) ; next ( queryOperation ) ; next ( queryOperation ) ; complete ( ) ; expect ( forwardedOperations . length ) . toBe ( 0 ) ; } ) ; it ( 's' , async ( ) => { shouldRespond = false ; const [ ops$ , next , complete ] = input ; const exchange = dedupExchange ( exchangeArgs ) ( ops$ ) ; publish ( exchange ) ; next ( queryOperation ) ; next ( { ... queryOperation , operationName : 's' } ) ; next ( queryOperation ) ; complete ( ) ; expect ( forwardedOperations . length ) . toBe ( 0 ) ; } ) ; it ( 's' , async ( ) => { shouldRespond = false ; const [ ops$ , next , complete ] = input ; const exchange = dedupExchange ( exchangeArgs ) ( ops$ ) ; publish ( exchange ) ; next ( mutationOperation ) ; next ( mutationOperation ) ; complete ( ) ; expect ( forwardedOperations . length ) . toBe ( 0 ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Subject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Source$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { forEach , fromValue , pipe } from 's' ; import { queryOperation , teardownOperation } from 's' ; import { fallbackExchangeIO } from 's' ; const consoleWarn = console . warn ; beforeEach ( ( ) => { console . warn = jest . fn ( ) ; } ) ; afterAll ( ( ) => { console . warn = consoleWarn ; } ) ; it ( 's' , ( ) => { const res : any [ ] = [ ] ; pipe ( fallbackExchangeIO ( fromValue ( queryOperation ) ) , forEach ( x => res . push ( x ) ) ) ; expect ( res . length ) . toBe ( 0 ) ; expect ( console . warn ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const res : any [ ] = [ ] ; pipe ( fallbackExchangeIO ( fromValue ( teardownOperation ) ) , forEach ( x => res . push ( x ) ) ) ; expect ( res . length ) . toBe ( 0 ) ; expect ( console . warn ) . not . toHaveBeenCalled ( ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { empty , fromValue , pipe , Source , subscribe , toPromise } from 's' ; import { Client } from 's' ; import { queryOperation } from 's' ; import { OperationResult , OperationType } from 's' ; import { fetchExchange } from 's' ; const fetch = ( global as any ) . fetch as jest . Mock ; const abort = jest . fn ( ) ; const abortError = new Error ( ) ; abortError . name = 's' ; beforeAll ( ( ) => { ( global as any ) . AbortController = function AbortController ( ) { this . signal = undefined ; this . abort = abort ; } ; } ) ; beforeEach ( ( ) => { fetch . mockClear ( ) ; abort . mockClear ( ) ; } ) ; afterAll ( ( ) => { ( global as any ) . AbortController = undefined ; } ) ; const response = { status : 0 , data : { data : { user : 0 , } , } , } ; const exchangeArgs = { forward : ( ) => empty as Source < OperationResult > , client : { } as Client , } ; describe ( 's' , ( ) => { beforeEach ( ( ) => { jest . spyOn ( Date , 's' ) . mockImplementationOnce ( ( ) => 0 ) . mockImplementationOnce ( ( ) => 0 ) ; fetch . mockResolvedValue ( { status : 0 , json : jest . fn ( ) . mockResolvedValue ( response ) , } ) ; } ) ; it ( 's' , async ( ) => { const fetchOptions = jest . fn ( ) . mockReturnValue ( { } ) ; const data = await pipe ( fromValue ( { ... queryOperation , context : { ... queryOperation . context , fetchOptions , } , } ) , fetchExchange ( exchangeArgs ) , toPromise ) ; expect ( data ) . toMatchSnapshot ( ) ; expect ( fetchOptions ) . toHaveBeenCalled ( ) ; expect ( fetch . mock . calls [ 0 ] [ 0 ] . body ) . toMatchSnapshot ( ) ; } ) ; } ) ; describe ( 's' , ( ) => { beforeEach ( ( ) => { jest . spyOn ( Date , 's' ) . mockImplementationOnce ( ( ) => 0 ) . mockImplementationOnce ( ( ) => 0 ) ; fetch . mockResolvedValue ( { status : 0 , json : jest . fn ( ) . mockResolvedValue ( response ) , } ) ; } ) ; it ( 's' , async ( ) => { const data = await pipe ( fromValue ( queryOperation ) , fetchExchange ( exchangeArgs ) , toPromise ) ; expect ( data ) . toMatchSnapshot ( ) ; } ) ; it ( 's' , async ( ) => { const fetchOptions = jest . fn ( ) . mockReturnValue ( { redirect : 's' } ) ; const data = await pipe ( fromValue ( { ... queryOperation , context : { ... queryOperation . context , fetchOptions , } , } ) , fetchExchange ( exchangeArgs ) , toPromise ) ; expect ( data ) . toMatchSnapshot ( ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { fetch . mockReturnValue ( Promise . reject ( abortError ) ) ; const [ unsubscribe ] = pipe ( fromValue ( queryOperation ) , fetchExchange ( exchangeArgs ) , subscribe ( fail ) ) ; unsubscribe ( ) ; expect ( fetch ) . toHaveBeenCalledTimes ( 0 ) ; expect ( abort ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; it ( 's' , ( ) => { pipe ( fromValue ( { ... queryOperation , operationName : 's' as OperationType , } ) , fetchExchange ( exchangeArgs ) , subscribe ( fail ) ) ; expect ( fetch ) . toHaveBeenCalledTimes ( 0 ) ; expect ( abort ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { makeSubject , pipe , map , publish , forEach , Subject } from 's' ; import { Client } from 's' ; import { queryOperation , queryResponse } from 's' ; import { ExchangeIO , Operation } from 's' ; import { ssrExchange } from 's' ; let forward ; let exchangeInput ; let client ; let input < Operation > ; let output ; beforeEach ( ( ) => { input = makeSubject < Operation > ( ) ; output = jest . fn ( ) ; forward = ops$ => pipe ( ops$ , map ( output ) ) ; client = { suspense : true } as any ; exchangeInput = { forward , client } ; } ) ; it ( 's' , ( ) => { output . mockReturnValueOnce ( queryResponse ) ; const ssr = ssrExchange ( ) ; const [ ops$ , next ] = input ; const exchange = ssr ( exchangeInput ) ( ops$ ) ; publish ( exchange ) ; next ( queryOperation ) ; const data = ssr . extractData ( ) ; expect ( Object . keys ( data ) ) . toEqual ( [ 's' + queryOperation . key ] ) ; expect ( data ) . toEqual ( { [ queryOperation . key ] : { data : queryResponse . data , error : undefined , } , } ) ; } ) ; it ( 's' , ( ) => { const onPush = jest . fn ( ) ; const ssr = ssrExchange ( { initialState : { [ queryOperation . key ] : queryResponse as any } , } ) ; const [ ops$ , next ] = input ; const exchange = ssr ( exchangeInput ) ( ops$ ) ; pipe ( exchange , forEach ( onPush ) ) ; next ( queryOperation ) ; const data = ssr . extractData ( ) ; expect ( Object . keys ( data ) . length ) . toBe ( 0 ) ; expect ( output ) . not . toHaveBeenCalled ( ) ; expect ( onPush ) . toHaveBeenCalledWith ( queryResponse ) ; } ) ; it ( 's' , ( ) => { client . suspense = false ; const onPush = jest . fn ( ) ; const ssr = ssrExchange ( ) ; ssr . restoreData ( { [ queryOperation . key ] : queryResponse as any } ) ; expect ( Object . keys ( ssr . extractData ( ) ) . length ) . toBe ( 0 ) ; const [ ops$ , next ] = input ; const exchange = ssr ( exchangeInput ) ( ops$ ) ; pipe ( exchange , forEach ( onPush ) ) ; next ( queryOperation ) ; expect ( Object . keys ( ssr . extractData ( ) ) . length ) . toBe ( 0 ) ; expect ( onPush ) . toHaveBeenCalledWith ( queryResponse ) ; expect ( output ) . not . toHaveBeenCalled ( ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ExchangeIO$ O O O O O $Client$ O O $Subject$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { print } from 's' ; import { empty , publish , fromValue , pipe , Source , take , toPromise , } from 's' ; import { Client } from 's' ; import { subscriptionOperation , subscriptionResult } from 's' ; import { OperationResult } from 's' ; import { subscriptionExchange , SubscriptionForwarder } from 's' ; it ( 's' , async ( ) => { const exchangeArgs = { forward : ( ) => empty as Source < OperationResult > , client : { } as Client , } ; const unsubscribe = jest . fn ( ) ; const forwardSubscription = operation => { expect ( operation . query ) . toBe ( print ( subscriptionOperation . query ) ) ; expect ( operation . variables ) . toBe ( subscriptionOperation . variables ) ; expect ( operation . context ) . toEqual ( subscriptionOperation . context ) ; return { subscribe ( observer ) { Promise . resolve ( ) . then ( ( ) => { observer . next ( subscriptionResult ) ; } ) ; return { unsubscribe } ; } , } ; } ; const data = await pipe ( fromValue ( subscriptionOperation ) , subscriptionExchange ( { forwardSubscription } ) ( exchangeArgs ) , take ( 0 ) , toPromise ) ; expect ( data ) . toMatchSnapshot ( ) ; expect ( unsubscribe ) . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const reexecuteOperation = jest . fn ( ) ; const unsubscribe = jest . fn ( ) ; const exchangeArgs = { forward : ( ) => empty as Source < OperationResult > , client : { reexecuteOperation : reexecuteOperation as any } as Client , } ; const forwardSubscription = ( ) => ( { subscribe ( observer ) { observer . complete ( ) ; return { unsubscribe } ; } , } ) ; pipe ( fromValue ( subscriptionOperation ) , subscriptionExchange ( { forwardSubscription } ) ( exchangeArgs ) , publish ) ; expect ( unsubscribe ) . not . toHaveBeenCalled ( ) ; expect ( reexecuteOperation ) . toHaveBeenCalled ( ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SubscriptionForwarder$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SubscriptionForwarder$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { renderHook , act } from 's' ; import { interval , map , pipe } from 's' ; import { createClient } from 's' ; import { useQuery } from 's' ; import { RequestPolicy } from 's' ; jest . mock ( 's' , ( ) => { const d = { data : 's' , error : 's' } ; const mock = { executeQuery : jest . fn ( ( ) => pipe ( interval ( 0 ) , map ( i => ( { data : i , error : i + 0 } ) ) ) ) , } ; return { createClient : ( ) => mock , data : d , } ; } ) ; const client = createClient ( ) as { executeQuery : jest . Mock } ; const mockQuery = `template` ; const mockVariables = { id : 0 , } ; describe ( 's' , ( ) => { beforeAll ( ( ) => { console . log ( 's' ) ; jest . spyOn ( global . console , 's' ) . mockImplementation ( ) ; } ) ; beforeEach ( ( ) => { client . executeQuery . mockClear ( ) ; } ) ; it ( 's' , ( ) => { const { result } = renderHook ( ( { query , variables } ) => useQuery ( { query , variables } ) , { initialProps : { query : mockQuery , variables : mockVariables } } ) ; const [ state ] = result . current ; expect ( state ) . toEqual ( { fetching : true , stale : false , extensions : undefined , error : undefined , data : undefined , } ) ; } ) ; it ( 's' , ( ) => { const context = { url : 's' } ; renderHook ( ( { query , variables } ) => useQuery ( { query , variables , context } ) , { initialProps : { query : mockQuery , variables : mockVariables } } ) ; expect ( client . executeQuery ) . toBeCalledWith ( { key : expect . any ( Number ) , query : expect . any ( Object ) , variables : mockVariables , } , { requestPolicy : undefined , url : 's' , } ) ; } ) ; it ( 's' , async ( ) => { const { waitForNextUpdate } = renderHook ( ( { query , variables } ) => useQuery ( { query , variables } ) , { initialProps : { query : mockQuery , variables : mockVariables } } ) ; await waitForNextUpdate ( ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; } ) ; it ( 's' , async ( ) => { const { waitForNextUpdate } = renderHook ( ( { query , variables } ) => useQuery ( { query , variables } ) , { initialProps : { query : mockQuery , variables : mockVariables } } ) ; await waitForNextUpdate ( ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; expect ( client . executeQuery ) . toBeCalledWith ( { key : expect . any ( Number ) , query : expect . any ( Object ) , variables : mockVariables , } , expect . objectContaining ( { requestPolicy : undefined , } ) ) ; } ) ; it ( 's' , async ( ) => { const { result , waitForNextUpdate } = renderHook ( ( { query , variables } ) => useQuery ( { query , variables } ) , { initialProps : { query : mockQuery , variables : mockVariables } } ) ; await waitForNextUpdate ( ) ; const [ state ] = result . current ; expect ( state ) . toEqual ( { fetching : false , stale : false , extensions : undefined , error : 0 , data : 0 , } ) ; } ) ; it ( 's' , async ( ) => { const { rerender , waitForNextUpdate } = renderHook < { query : string ; variables ? : object } , { } > ( ( { query , variables } ) => useQuery ( { query , variables } ) , { initialProps : { query : mockQuery , variables : mockVariables } , } ) ; await waitForNextUpdate ( ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; const newQuery = `template` ; rerender ( { query : newQuery } ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; expect ( client . executeQuery ) . toHaveBeenNthCalledWith ( 0 , { key : expect . any ( Number ) , query : expect . any ( Object ) , variables : { } , } , expect . objectContaining ( { requestPolicy : undefined , } ) ) ; } ) ; it ( 's' , async ( ) => { const { rerender , waitForNextUpdate } = renderHook < { query : string ; variables : object } , { } > ( ( { query , variables } ) => useQuery ( { query , variables } ) , { initialProps : { query : mockQuery , variables : mockVariables } , } ) ; await waitForNextUpdate ( ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; const newVariables = { id : 0 , } ; rerender ( { query : mockQuery , variables : newVariables } ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; expect ( client . executeQuery ) . toHaveBeenNthCalledWith ( 0 , { key : expect . any ( Number ) , query : expect . any ( Object ) , variables : newVariables , } , expect . objectContaining ( { requestPolicy : undefined , } ) ) ; } ) ; it ( 's' , async ( ) => { const { rerender , waitForNextUpdate } = renderHook ( ( { query , variables } ) => useQuery ( { query , variables } ) , { initialProps : { query : mockQuery , variables : mockVariables } , } ) ; await waitForNextUpdate ( ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; rerender ( { query : mockQuery , variables : mockVariables } ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; } ) ; it ( 's' , async ( ) => { const { rerender , waitForNextUpdate } = renderHook ( ( { query , variables , requestPolicy } ) => useQuery ( { query , variables , requestPolicy } ) , { initialProps : { query : mockQuery , variables : mockVariables , requestPolicy : 's' as RequestPolicy , } , } ) ; await waitForNextUpdate ( ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; expect ( client . executeQuery ) . toHaveBeenNthCalledWith ( 0 , { key : expect . any ( Number ) , query : expect . any ( Object ) , variables : mockVariables , } , expect . objectContaining ( { requestPolicy : 's' , } ) ) ; rerender ( { query : mockQuery , variables : mockVariables , requestPolicy : 's' , } ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; expect ( client . executeQuery ) . toHaveBeenNthCalledWith ( 0 , { key : expect . any ( Number ) , query : expect . any ( Object ) , variables : mockVariables , } , expect . objectContaining ( { requestPolicy : 's' , } ) ) ; } ) ; it ( 's' , async ( ) => { const { result , waitForNextUpdate } = renderHook ( ( { query , variables } ) => useQuery ( { query , variables } ) , { initialProps : { query : mockQuery , variables : mockVariables } } ) ; await waitForNextUpdate ( ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; const [ , executeQuery ] = result . current ; act ( ( ) => executeQuery ( ) ) ; await waitForNextUpdate ( ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; } ) ; it ( 's' , ( ) => { renderHook ( ( { query , variables , pause } ) => useQuery ( { query , variables , pause } ) , { initialProps : { query : mockQuery , variables : mockVariables , pause : true , } , } ) ; expect ( client . executeQuery ) . not . toBeCalled ( ) ; } ) ; it ( 's' , async ( ) => { const { rerender , waitForNextUpdate } = renderHook ( ( { query , variables , pause } ) => useQuery ( { query , variables , pause } ) , { initialProps : { query : mockQuery , variables : mockVariables , pause : false , } , } ) ; await waitForNextUpdate ( ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; rerender ( { query : mockQuery , variables : mockVariables , pause : true } ) ; expect ( client . executeQuery ) . toBeCalledTimes ( 0 ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { renderHook } from 's' ; import { queryGql } from 's' ; import { useRequest } from 's' ; it ( 's' , ( ) => { const { query } = queryGql ; let { variables } = queryGql ; const { result , rerender } = renderHook ( ( { query , variables } ) => useRequest ( query , variables ) , { initialProps : { query , variables } } ) ; const resultA = result . current ; expect ( resultA ) . toEqual ( { key : expect . any ( Number ) , query : expect . anything ( ) , variables : variables , } ) ; variables = { ... variables } ; rerender ( { query , variables } ) ; const resultB = result . current ; expect ( resultA ) . toBe ( resultB ) ; variables = { ... variables , test : true } ; rerender ( { query , variables } ) ; const resultC = result . current ; expect ( resultA ) . not . toBe ( resultC ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export * from 's' ; export { CombinedError , stringifyVariables , createRequest , makeResult , makeErrorResult , formatDocument , } from 's' ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CombinedError } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const err = new CombinedError ( { graphQLErrors : [ ] , } ) ; expect ( err . name ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { const err = new CombinedError ( { networkError : new Error ( 's' ) , } ) ; expect ( err instanceof CombinedError ) . toBe ( true ) ; expect ( err instanceof Error ) . toBe ( true ) ; expect ( Error . prototype . isPrototypeOf ( err ) ) . toBe ( true ) ; expect ( 's' + err ) . toMatchSnapshot ( ) ; } ) ; it ( 's' , ( ) => { const graphQLErrors = [ 's' , 's' ] ; const err = new CombinedError ( { graphQLErrors } ) ; expect ( err . message ) . toBe ( `template` . trim ( ) ) ; expect ( err . graphQLErrors ) . toEqual ( graphQLErrors . map ( x => new Error ( x ) ) ) ; } ) ; it ( 's' , ( ) => { const networkError = new Error ( 's' ) ; const err = new CombinedError ( { networkError } ) ; expect ( err . message ) . toBe ( `template` ) ; } ) ; it ( 's' , ( ) => { const graphQLErrors = [ new Error ( 's' ) , new Error ( 's' ) , ] ; const err = new CombinedError ( { graphQLErrors } ) ; expect ( err . message ) . toBe ( `template` . trim ( ) ) ; expect ( err . graphQLErrors ) . toEqual ( graphQLErrors ) ; } ) ; it ( 's' , ( ) => { const graphQLErrors = [ { x : 's' } ] as any ; const err = new CombinedError ( { graphQLErrors } ) ; expect ( err . graphQLErrors ) . toEqual ( graphQLErrors ) ; } ) ; it ( 's' , ( ) => { const response = { } ; const err = new CombinedError ( { graphQLErrors : [ ] , response , } ) ; expect ( err . response ) . toBe ( response ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { parse , print } from 's' ; import gql from 's' ; import { createRequest } from 's' ; it ( 's' , ( ) => { const reqA = createRequest ( 's' ) ; const reqB = createRequest ( 's' ) ; expect ( reqA . key ) . toBe ( reqB . key ) ; } ) ; it ( 's' , ( ) => { const reqA = createRequest ( parse ( 's' ) ) ; const reqB = createRequest ( parse ( 's' ) ) ; expect ( reqA . key ) . toBe ( reqB . key ) ; expect ( reqA . query ) . toBe ( reqB . query ) ; } ) ; it ( 's' , ( ) => { const doc = parse ( 's' ) ; ( doc as any ) . __key = 0 ; const req = createRequest ( doc ) ; expect ( req . key ) . toBe ( 0 ) ; } ) ; it ( 's' , ( ) => { const docA = parse ( 's' ) ; const docB = print ( docA ) . replace ( "s" , 's' ) ; const reqA = createRequest ( docA ) ; const reqB = createRequest ( docB ) ; expect ( reqA . key ) . toBe ( reqB . key ) ; expect ( reqA . query ) . toBe ( reqB . query ) ; } ) ; it ( 's' , ( ) => { const doc = `template` ; createRequest ( doc ) ; expect ( ( doc as any ) . __key ) . not . toBe ( undefined ) ; } ) ; it ( 's' , ( ) => { const doc = `template` ; const val = createRequest ( doc ) ; expect ( val ) . toMatchObject ( { key : expect . any ( Number ) , query : expect . any ( Object ) , variables : { } , } ) ; } ) ; it ( 's' , ( ) => { const doc = print ( `template` ) ; const val = createRequest ( doc , { test : 0 } ) ; expect ( print ( val . query ) ) . toBe ( doc ) ; expect ( val ) . toMatchObject ( { key : expect . any ( Number ) , query : expect . any ( Object ) , variables : { test : 0 } , } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { queryOperation } from 's' ; import { makeResult } from 's' ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const response = { } ; const origResult = { data : undefined , errors : [ 's' ] , extensions : { extensionKey : 's' , } , } ; const result = makeResult ( queryOperation , origResult , response ) ; expect ( result . operation ) . toBe ( queryOperation ) ; expect ( result . data ) . toBe ( undefined ) ; expect ( result . extensions ) . toEqual ( origResult . extensions ) ; expect ( result . error ) . toMatchInlineSnapshot ( `template` ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { stringifyVariables } from 's' ; it ( 's' , ( ) => { expect ( stringifyVariables ( { b : 's' , a : 's' } ) ) . toBe ( 's' ) ; expect ( stringifyVariables ( { x : { b : 's' , a : 's' } } ) ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( stringifyVariables ( [ 0 , 0 ] ) ) . toBe ( 's' ) ; expect ( stringifyVariables ( { x : [ 0 , 0 ] } ) ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( stringifyVariables ( 0 ) ) . toBe ( 's' ) ; expect ( stringifyVariables ( 's' ) ) . toBe ( 's' ) ; expect ( stringifyVariables ( null ) ) . toBe ( 's' ) ; expect ( stringifyVariables ( undefined ) ) . toBe ( 's' ) ; expect ( stringifyVariables ( Infinity ) ) . toBe ( 's' ) ; expect ( stringifyVariables ( 0 / 0 ) ) . toBe ( 's' ) ; } ) ; it ( 's' , ( ) => { expect ( ( ) => { const x = { x : null } as any ; x . x = x ; stringifyVariables ( x ) ; } ) . toThrow ( ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { pipe , onStart , onPush , onEnd , fromValue , fromArray , makeSubject , never , publish , subscribe , } from 's' ; import { toSuspenseSource } from 's' ; it ( 's' , ( ) => { const start = jest . fn ( ) ; pipe ( fromValue ( 's' ) , onStart ( start ) , toSuspenseSource ) ; expect ( start ) . not . toHaveBeenCalled ( ) ; } ) ; it ( 's' , ( ) => { const start = jest . fn ( ) ; const push = jest . fn ( ) ; let result ; pipe ( fromValue ( 's' ) , onStart ( start ) , onPush ( push ) , toSuspenseSource , subscribe ( value => { result = value ; } ) ) ; expect ( result ) . toBe ( 's' ) ; expect ( start ) . toHaveBeenCalledTimes ( 0 ) ; expect ( push ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; it ( 's' , ( ) => { expect ( ( ) => { pipe ( never , toSuspenseSource , subscribe ( ( ) => { } ) ) ; } ) . toThrow ( expect . any ( Promise ) ) ; } ) ; it ( 's' , ( ) => { const [ source , push ] = makeSubject ( ) ; const end = jest . fn ( ) ; let promise ; let result ; try { pipe ( source , toSuspenseSource , onEnd ( end ) , subscribe ( value => { expect ( value ) . toBe ( 's' ) ; result = value ; } ) ) ; } catch ( error ) { promise = error ; } expect ( promise ) . toBeInstanceOf ( Promise ) ; push ( 's' ) ; expect ( result ) . toBe ( 's' ) ; return promise . then ( resolved => { expect ( resolved ) . toBe ( 's' ) ; expect ( end ) . toHaveBeenCalled ( ) ; } ) ; } ) ; it ( 's' , async ( ) => { const push = jest . fn ( ) ; await new Promise ( resolve => { pipe ( fromArray ( [ 0 , 0 ] ) , toSuspenseSource , onEnd ( resolve ) , subscribe ( push ) ) ; } ) ; expect ( push ) . toHaveBeenCalledTimes ( 0 ) ; } ) ; it ( 's' , async ( ) => { let unsubscribe ; const end = jest . fn ( ) ; try { [ unsubscribe ] = pipe ( fromArray ( [ 0 , 0 ] ) , toSuspenseSource , onEnd ( end ) , publish ) ; } catch ( promise ) { expect ( promise ) . toBe ( expect . any ( Promise ) ) ; } unsubscribe ( ) ; expect ( end ) . toHaveBeenCalledTimes ( 0 ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { parse , print } from 's' ; import { collectTypesFromResponse , formatDocument } from 's' ; const formatTypeNames = ( query ) => { const typedNode = formatDocument ( parse ( query ) ) ; return print ( typedNode ) ; } ; describe ( 's' , ( ) => { it ( 's' , ( ) => { expect ( formatTypeNames ( `template` ) ) . toMatchInlineSnapshot ( `template` ) ; } ) ; it ( 's' , ( ) => { expect ( formatTypeNames ( `template` ) ) . toMatchInlineSnapshot ( `template` ) ; } ) ; } ) ; describe ( 's' , ( ) => { it ( 's' , ( ) => { const typeNames = collectTypesFromResponse ( { todos : [ { id : 0 , __typename : 's' , } , ] , } ) ; expect ( typeNames ) . toEqual ( [ 's' ] ) ; } ) ; it ( 's' , ( ) => { const typeNames = collectTypesFromResponse ( { todos : [ { id : 0 , __typename : 's' , } , { id : 0 , __typename : 's' , } , ] , } ) ; expect ( typeNames ) . toEqual ( [ 's' ] ) ; } ) ; it ( 's' , ( ) => { const typeNames = collectTypesFromResponse ( { todos : [ { id : 0 , __typename : 's' , } , { id : 0 , __typename : 's' , } , ] , } ) ; expect ( typeNames ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( 's' , ( ) => { const typeNames = collectTypesFromResponse ( { todos : [ { id : 0 , __typename : 's' , } , { id : 0 , subTask : { id : 0 , __typename : 's' , } , } , ] , } ) ; expect ( typeNames ) . toEqual ( [ 's' , 's' ] ) ; } ) ; it ( 's' , ( ) => { const typenames = collectTypesFromResponse ( { todos : [ { id : 0 , authors : [ [ { name : 's' , __typename : 's' , } , ] , ] , __typename : 's' , } , ] , } ) ; expect ( typenames ) . toEqual ( [ 's' , 's' ] ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O