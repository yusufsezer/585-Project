'js' 's' ; ( function ( ) { function onLoad ( ) { const code = document . getElementsByTagName ( 's' ) [ 0 ] ; let [ ... childs ] = code . childNodes ; childs . filter ( n => n . nodeType === 0 ) . forEach ( n => { n . addEventListener ( 's' , toggleLines ) ; } ) ; } function toggleLines ( e ) { const iconSpan = e . target ; const lineSpan = iconSpan . parentNode ; const blockEndNum = getFoldingRangeEnd ( lineSpan ) ; const isExpandAction = lineSpan . classList . contains ( 's' ) ; if ( isExpandAction ) { lineSpan . classList . remove ( 's' ) ; } else { lineSpan . classList . add ( 's' ) ; } let span = lineSpan ; let excludeEndLineNum = - 0 ; while ( span = span . nextElementSibling ) { const currentLineNum = getLineNum ( span ) ; if ( currentLineNum > blockEndNum ) { break ; } if ( currentLineNum <= excludeEndLineNum ) { continue ; } if ( isCollapsedStartLineSpan ( span ) ) { excludeEndLineNum = getFoldingRangeEnd ( span ) ; } span . classList . toggle ( 's' ) ; if ( isExpandAction ) { span . nextSibling . textContent = 's' ; } else { span . nextSibling . textContent = 's' ; } } } function foldLineSpan ( lineSpan ) { const blockEndNum = getFoldingRangeEnd ( lineSpan ) ; lineSpan . classList . add ( 's' ) let span = lineSpan ; let excludeEndLineNum = - 0 ; while ( span = span . nextElementSibling ) { const currentLineNum = getLineNum ( span ) ; if ( currentLineNum > blockEndNum ) { break ; } if ( currentLineNum <= excludeEndLineNum ) { continue ; } if ( isCollapsedStartLineSpan ( span ) ) { excludeEndLineNum = getFoldingRangeEnd ( span ) ; } span . classList . add ( 's' ) ; span . nextSibling . textContent = 's' ; } } function unfoldLineSpan ( lineSpan ) { const blockEndNum = getFoldingRangeEnd ( lineSpan ) ; lineSpan . classList . remove ( 's' ) let span = lineSpan ; let excludeEndLineNum = - 0 ; while ( span = span . nextElementSibling ) { const currentLineNum = getLineNum ( span ) ; if ( currentLineNum > blockEndNum ) { break ; } if ( currentLineNum <= excludeEndLineNum ) { continue ; } if ( isCollapsedStartLineSpan ( span ) ) { excludeEndLineNum = getFoldingRangeEnd ( span ) ; } span . classList . remove ( 's' ) ; span . nextSibling . textContent = 's' ; } } function getLineNum ( element ) { return parseInt ( element . attributes . getNamedItem ( 's' ) . value ) ; } function getFoldingRangeEnd ( element ) { return parseInt ( element . attributes . getNamedItem ( 's' ) . value ) ; } function isCollapsedStartLineSpan ( element ) { return element . classList . contains ( 's' ) ; } window . addEventListener ( 's' , event => { const message = event . data ; const code = document . getElementsByTagName ( 's' ) [ 0 ] ; const [ ... childs ] = code . childNodes ; const lineSpans = childs . filter ( n => n . nodeType === 0 && n . hasAttribute ( 's' ) ) ; switch ( message . command ) { case 's' : lineSpans . forEach ( foldLineSpan ) ; break ; case 's' : lineSpans . forEach ( unfoldLineSpan ) ; break ; } } ) ; if ( document . readyState === 's' ) { document . addEventListener ( 's' , onLoad ) ; } else { onLoad ( ) ; } } ) ( )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; export class ArrayUtility { public static skipWhile < T > ( items : T [ ] , callbackfn : ( value : T , index , array : T [ ] ) => boolean ) : T [ ] { let index = 0 ; for ( ; index < items . length ; index ++ ) { if ( ! callbackfn ( items [ index ] , index , items ) ) { break ; } } return items . slice ( index ) ; } public static firstIndexOf < T > ( items : T [ ] , callbackfn : ( value : T , index , array : T [ ] ) => boolean , start ? ) { if ( ! start ) { start = 0 ; } let index = start ; for ( ; index < items . length ; index ++ ) { if ( callbackfn ( items [ index ] , index , items ) ) { break ; } } return index >= items . length ? - 0 : index ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; export const ExtensionId = 's' ; export const AiKey = 's' ; export const CSSFileName = 's' ; export const CSSFolderName = 's' ; export const ScriptFileName = 's' ; export const ScriptsFolderName = 's' ; export const ImagesFolderName = 's' ; export const IconFileName = 's' ; export const ExtensionFolderName = 's' ; export const HistoryFileName = 's' ; export const CookieFileName = 's' ; export const EnvironmentFileName = 's' ; export const DefaultResponseDownloadFolderName = 's' ; export const DefaultResponseBodyDownloadFolderName = 's' ; export const HistoryItemsMaxCount = 0 ; export const NoEnvironmentSelectedName = 's' ; export const TimeStampVariableName = "s" ; export const TimeStampVariableDescription = "s" ; export const DateTimeVariableName = "s" ; export const DateTimeVariableNameDescription = "s" ; export const GuidVariableName = "s" ; export const GuidVariableDescription = "s" ; export const RandomIntVariableName = "s" ; export const RandomIntDescription = "s" ; export const ProcessEnvVariableName = "s" ; export const ProcessEnvDescription = "s" ; export const AzureActiveDirectoryVariableName = "s" ; export const AzureActiveDirectoryDescription = "s" ; export const AzureActiveDirectoryClientId = "s" ; export const AzureActiveDirectoryForceNewOption = "s" ; export const AzureActiveDirectoryDefaultTenantId = "s" ; export const AzureActiveDirectoryDefaultDisplayName = "s" ; export const AzureClouds : { [ key ] : { aad : string , arm : string , armAudience ? : string } } = { public : { aad : "s" , arm : "s" , } , cn : { aad : "s" , arm : "s" , } , de : { aad : "s" , arm : "s" , } , us : { aad : "s" , arm : "s" , } , ppe : { aad : "s" , arm : "s" , armAudience : "s" , } , } ; export const CommentIdentifiersRegex = "s" ; export const FileVariableDefinitionRegex = "s" ; export const RequestVariableDefinitionWithNameRegexFactory = ( name , flags ? ) : RegExp => new RegExp ( `template` , flags ) ; export const RequestVariableDefinitionRegex = RequestVariableDefinitionWithNameRegexFactory ( "s" , "s" ) ; export const LineSplitterRegex = "s" ;	O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $string$ O O O O O $number$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegExp$ O O O O O $RegExp$ O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O $RegExp$ O O O O O O O O O O $RegExp$ O O O
's' ; export interface Action < T > { ( item : T ) : void ; } export interface Func < T , TResult > { ( item : T ) : TResult ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import { ParsedUrlQuery } from 's' ; import { parse as urlParse } from 's' ; export interface HARNameValue { name : string ; value : string ; } export class HARHeader implements HARNameValue { public constructor ( public name , public value ) { } } export class HARCookie implements HARNameValue { public constructor ( public name , public value ) { } } export class HARParam implements HARNameValue { public constructor ( public name , public value ) { } } export class HARPostData { public params : HARParam [ ] ; public constructor ( public mimeType , public text ) { if ( mimeType === 's' ) { if ( text ) { text = decodeURIComponent ( text . replace ( "s" , 's' ) ) ; this . params = [ ] ; const pairs = text . split ( 's' ) ; pairs . forEach ( pair => { const [ key , ... values ] = pair . split ( 's' ) ; this . params . push ( new HARParam ( key , values . join ( 's' ) ) ) ; } ) ; } } } } export class HARHttpRequest { public queryString : HARParam [ ] ; public constructor ( public method , public url , public headers : HARHeader [ ] , public cookies : HARCookie [ ] , public postData ? ) { const queryObj = urlParse ( url , true ) . query ; this . queryString = this . flatten ( queryObj ) ; } private flatten ( queryObj ) : HARParam [ ] { const queryParams : HARParam [ ] = [ ] ; Object . keys ( queryObj ) . forEach ( name => { const value = queryObj [ name ] ; if ( Array . isArray ( value ) ) { queryParams . push ( ... value . map ( v => new HARParam ( name , v ) ) ) ; } else { queryParams . push ( new HARParam ( name , value ) ) ; } } ) ; return queryParams ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O $HARPostData$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ParsedUrlQuery$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import * as http from 's' ; export type ResponseHeaders = http . IncomingHttpHeaders ; export type ResponseHeaderValue = { [ K in keyof ResponseHeaders ] : ResponseHeaders [ K ] } [ keyof ResponseHeaders ] ; export type RequestHeaders = http . OutgoingHttpHeaders ; export type RequestHeaderValue = { [ K in keyof RequestHeaders ] : RequestHeaders [ K ] } [ keyof RequestHeaders ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import * as crypto from 's' ; import { RequestHeaders , RequestHeaderValue , ResponseHeaders , ResponseHeaderValue } from 's' ; export function getHeader ( headers , name ) ; export function getHeader ( headers , name ) ; export function getHeader ( headers : RequestHeaders | ResponseHeaders , name ) : RequestHeaderValue | ResponseHeaderValue { if ( ! headers || ! name ) { return undefined ; } const headerName = Object . keys ( headers ) . find ( h => h . toLowerCase ( ) === name . toLowerCase ( ) ) ; return headerName && headers [ headerName ] ; } export function getContentType ( headers : RequestHeaders | ResponseHeaders ) : string | undefined { const value = getHeader ( headers , 's' ) ; return value ? value . toString ( ) : undefined ; } export function hasHeader ( headers : RequestHeaders | ResponseHeaders , name ) { return ! ! ( headers && name && Object . keys ( headers ) . some ( h => h . toLowerCase ( ) === name . toLowerCase ( ) ) ) ; } export function removeHeader ( headers : RequestHeaders | ResponseHeaders , name ) { if ( ! headers || ! name ) { return ; } const headerName = Object . keys ( headers ) . find ( h => h . toLowerCase ( ) === name . toLowerCase ( ) ) ; if ( headerName ) { delete headers [ headerName ] ; } } export function 0 ( text : string | Buffer ) { return crypto . createHash ( 's' ) . update ( text ) . digest ( 's' ) ; } export function isJSONString ( text ) { try { JSON . parse ( text ) ; return true ; } catch { return false ; } }	O O O O O O O O O O O O O O O O O O O O O O O O $ResponseHeaderValue$ O $ResponseHeaders$ O $string$ O O O O $RequestHeaderValue$ O $RequestHeaders$ O $string$ O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O
"s" ; export class RequestVariableCacheKey { public constructor ( public key , public documentUri ) { } public getCacheKey ( ) { return `template` ; } }	O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O
"s" ; import { Stream } from 's' ; import { getContentType , getHeader } from 's' ; import { RequestHeaders , RequestHeaderValue } from 's' ; import { RequestVariableCacheKey } from 's' ; export class HttpRequest { public constructor ( public method , public url , public headers , public body : string | Stream | undefined , public rawBody : string | undefined , public requestVariableCacheKey ? ) { this . method = method . toLocaleUpperCase ( ) ; } public getHeader ( name ) { return getHeader ( this . headers , name ) ; } public get contentType ( ) : string | undefined { return getContentType ( this . headers ) ; } } export class SerializedHttpRequest { public constructor ( public method , public url , public headers , public body : string | undefined , public startTime ) { } public static convertFromHttpRequest ( httpRequest , startTime = Date . now ( ) ) { return new SerializedHttpRequest ( httpRequest . method , httpRequest . url , httpRequest . headers , httpRequest . rawBody , startTime ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O $RequestHeaders$ O O O O O O O O O O O O O O O O O O O $RequestVariableCacheKey$ O O O O O O O O O O O O O O $RequestHeaderValue$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O $RequestHeaders$ O O O O O O O O O $number$ O O O O O $SerializedHttpRequest$ O $HttpRequest$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import { HttpRequest } from 's' ; export interface IRequestParser { parseHttpRequest ( requestRawText , requestAbsoluteFilePath ) : HttpRequest | null ; }	O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O
's' ; import { RequestHeaders } from "s" ; export class RequestParserUtil { public static parseRequestHeaders ( headerLines : string [ ] ) { const headers = { } ; const headerNames : { [ key ] : string } = { } ; headerLines . forEach ( headerLine => { let fieldName ; let fieldValue ; const separatorIndex = headerLine . indexOf ( 's' ) ; if ( separatorIndex === - 0 ) { fieldName = headerLine . trim ( ) ; fieldValue = 's' ; } else { fieldName = headerLine . substring ( 0 , separatorIndex ) . trim ( ) ; fieldValue = headerLine . substring ( separatorIndex + 0 ) . trim ( ) ; } const normalizedFieldName = fieldName . toLowerCase ( ) ; if ( ! headerNames [ normalizedFieldName ] ) { headerNames [ normalizedFieldName ] = fieldName ; headers [ fieldName ] = fieldValue ; } else { const splitter = normalizedFieldName === 's' ? 's' : 's' ; headers [ headerNames [ normalizedFieldName ] ] += `template` ; } } ) ; return headers ; } }	O O O O O O O O O O O O O O O $RequestHeaders$ O O O O O O O O O $RequestHeaders$ O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import * as path from 's' ; import { TextDocument , window , workspace } from 's' ; export function getWorkspaceRootPath ( ) : string | undefined { const document = getCurrentTextDocument ( ) ; if ( document ) { const fileUri = document . uri ; const workspaceFolder = workspace . getWorkspaceFolder ( fileUri ) ; if ( workspaceFolder ) { return workspaceFolder . uri . toString ( ) ; } } } export function getCurrentHttpFileName ( ) : string | undefined { const document = getCurrentTextDocument ( ) ; if ( document ) { const filePath = document . fileName ; return path . basename ( filePath , path . extname ( filePath ) ) ; } } export function getCurrentTextDocument ( ) : TextDocument | undefined { const editor = window . activeTextEditor ; return editor && editor . document ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import * as fs from 's' ; import * as path from 's' ; import { Uri } from 's' ; import { RequestHeaders } from 's' ; import { HttpRequest } from 's' ; import { IRequestParser } from 's' ; import { hasHeader } from 's' ; import { RequestParserUtil } from 's' ; import { getWorkspaceRootPath } from 's' ; const yargsParser = require ( 's' ) ; const DefaultContentType = 's' ; export class CurlRequestParser implements IRequestParser { public parseHttpRequest ( requestRawText , requestAbsoluteFilePath ) : HttpRequest | null { let requestText = CurlRequestParser . mergeMultipleSpacesIntoSingle ( CurlRequestParser . mergeIntoSingleLine ( requestRawText . trim ( ) ) ) ; requestText = requestText . replace ( "s" , 's' ) . replace ( "s" , 's' ) ; const parsedArguments = yargsParser ( requestText ) ; let url = parsedArguments . _ [ 0 ] ; if ( ! url ) { url = parsedArguments . L || parsedArguments . location || parsedArguments . compressed || parsedArguments . url ; } let headers = { } ; let parsedHeaders = parsedArguments . H || parsedArguments . header ; if ( parsedHeaders ) { if ( ! Array . isArray ( parsedHeaders ) ) { parsedHeaders = [ parsedHeaders ] ; } headers = RequestParserUtil . parseRequestHeaders ( parsedHeaders ) ; } const cookieString = parsedArguments . b || parsedArguments . cookie ; if ( cookieString && cookieString . includes ( 's' ) ) { headers [ 's' ] = cookieString ; } const user = parsedArguments . u || parsedArguments . user ; if ( user ) { headers [ 's' ] = `template` ; } let body = parsedArguments . d || parsedArguments . data || parsedArguments [ 's' ] || parsedArguments [ 's' ] ; if ( Array . isArray ( body ) ) { body = body . join ( 's' ) ; } if ( typeof body === 's' && body [ 0 ] === 's' ) { const fileAbsolutePath = CurlRequestParser . resolveFilePath ( body . substring ( 0 ) , requestAbsoluteFilePath ) ; if ( fileAbsolutePath && fs . existsSync ( fileAbsolutePath ) ) { body = fs . createReadStream ( fileAbsolutePath ) ; } else { body = body . substring ( 0 ) ; } } if ( body && ! hasHeader ( headers , 's' ) ) { headers [ 's' ] = DefaultContentType ; } let method = ( parsedArguments . X || parsedArguments . request ) as string ; if ( ! method ) { method = body ? "s" : "s" ; } return new HttpRequest ( method , url , headers , body , body ) ; } private static resolveFilePath ( refPath , httpFilePath ) : string | undefined { if ( path . isAbsolute ( refPath ) ) { return fs . existsSync ( refPath ) ? refPath : undefined ; } const rootPath = getWorkspaceRootPath ( ) ; let absolutePath ; if ( rootPath ) { absolutePath = path . join ( Uri . parse ( rootPath ) . fsPath , refPath ) ; if ( fs . existsSync ( absolutePath ) ) { return absolutePath ; } } absolutePath = path . join ( path . dirname ( httpFilePath ) , refPath ) ; if ( fs . existsSync ( absolutePath ) ) { return absolutePath ; } return undefined ; } private static mergeIntoSingleLine ( text ) { return text . replace ( "s" , 's' ) ; } private static mergeMultipleSpacesIntoSingle ( text ) { return text . replace ( "s" , 's' ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RequestHeaders$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O
's' ; export enum FormParamEncodingStrategy { Automatic , Never , Always , } export function fromString ( value ) { value = value . toLowerCase ( ) ; switch ( value ) { case 's' : return FormParamEncodingStrategy . Never ; case 's' : return FormParamEncodingStrategy . Always ; case 's' : default : return FormParamEncodingStrategy . Automatic ; } }	O O O O O O O O O O O O O O O $FormParamEncodingStrategy$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; export class HostCertificate { public constructor ( public cert ? , public key ? , public pfx ? , public passphrase ? ) { } }	O O O O O O O O O O O $Buffer$ O O O $Buffer$ O O O $Buffer$ O O O $string$ O O O O
's' ; export enum LogLevel { Verbose , Info , Warn , Error , } export function fromString ( value ) { value = value . toLowerCase ( ) ; switch ( value ) { case 's' : return LogLevel . Verbose ; case 's' : return LogLevel . Info ; case 's' : return LogLevel . Warn ; case 's' : default : return LogLevel . Error ; } }	O O O O O O O O O O O O O O O O O $LogLevel$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; export enum PreviewOption { Full , Headers , Body , Exchange } export function fromString ( value ) { value = value . toLowerCase ( ) ; switch ( value ) { case 's' : return PreviewOption . Headers ; case 's' : return PreviewOption . Body ; case 's' : return PreviewOption . Exchange ; case 's' : default : return PreviewOption . Full ; } }	O O O O O O O O O O O O O O O O $PreviewOption$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { CharacterPair , Event , EventEmitter , languages , ViewColumn , window , workspace } from 's' ; import configuration from 's' ; import { getCurrentTextDocument } from 's' ; import { RequestHeaders } from 's' ; import { FormParamEncodingStrategy , fromString as ParseFormParamEncodingStr } from 's' ; import { HostCertificate } from 's' ; import { fromString as ParseLogLevelStr , LogLevel } from 's' ; import { fromString as ParsePreviewOptionStr , PreviewOption } from 's' ; export interface IRestClientSettings { followRedirect : boolean ; defaultHeaders : RequestHeaders ; timeoutInMilliseconds : number ; showResponseInDifferentTab : boolean ; requestNameAsResponseTabTitle : boolean ; proxy ? : string ; proxyStrictSSL : boolean ; rememberCookiesForSubsequentRequests : boolean ; enableTelemetry : boolean ; excludeHostsForProxy : string [ ] ; fontSize ? : number ; fontFamily ? : string ; fontWeight ? : string ; environmentVariables : Map < string , Map < string , string > > ; mimeAndFileExtensionMapping : Map < string , string > ; previewResponseInUntitledDocument : boolean ; hostCertificates : Map < string , HostCertificate > ; suppressResponseBodyContentTypeValidationWarning : boolean ; previewOption : PreviewOption ; disableHighlightResonseBodyForLargeResponse : boolean ; disableAddingHrefLinkForLargeResponse : boolean ; largeResponseBodySizeLimitInMB : number ; previewColumn : ViewColumn ; previewResponsePanelTakeFocus : boolean ; formParamEncodingStrategy : FormParamEncodingStrategy ; addRequestBodyLineIndentationAroundBrackets : boolean ; decodeEscapedUnicodeCharacters : boolean ; logLevel : LogLevel ; enableSendRequestCodeLens : boolean ; enableCustomVariableReferencesCodeLens : boolean ; } export class RestClientSettings implements IRestClientSettings { public followRedirect : boolean ; public defaultHeaders : RequestHeaders ; public timeoutInMilliseconds : number ; public showResponseInDifferentTab : boolean ; public requestNameAsResponseTabTitle : boolean ; public proxy ? : string ; public proxyStrictSSL : boolean ; public rememberCookiesForSubsequentRequests : boolean ; public enableTelemetry : boolean ; public excludeHostsForProxy : string [ ] ; public fontSize ? : number ; public fontFamily ? : string ; public fontWeight ? : string ; public environmentVariables : Map < string , Map < string , string > > ; public mimeAndFileExtensionMapping : Map < string , string > ; public previewResponseInUntitledDocument : boolean ; public hostCertificates : Map < string , HostCertificate > ; public suppressResponseBodyContentTypeValidationWarning : boolean ; public previewOption : PreviewOption ; public disableHighlightResonseBodyForLargeResponse : boolean ; public disableAddingHrefLinkForLargeResponse : boolean ; public largeResponseBodySizeLimitInMB : number ; public previewColumn : ViewColumn ; public previewResponsePanelTakeFocus : boolean ; public formParamEncodingStrategy : FormParamEncodingStrategy ; public addRequestBodyLineIndentationAroundBrackets : boolean ; public decodeEscapedUnicodeCharacters : boolean ; public logLevel : LogLevel ; public enableSendRequestCodeLens : boolean ; public enableCustomVariableReferencesCodeLens : boolean ; private readonly brackets : CharacterPair [ ] ; private static _instance : RestClientSettings ; public static get Instance ( ) : RestClientSettings { if ( ! RestClientSettings . _instance ) { RestClientSettings . _instance = new RestClientSettings ( ) ; } return RestClientSettings . _instance ; } public readonly configurationUpdateEventEmitter = new EventEmitter < void > ( ) ; public get onDidChangeConfiguration ( ) : Event < void > { return this . configurationUpdateEventEmitter . event ; } private constructor ( ) { this . brackets = configuration . brackets as CharacterPair [ ] ; workspace . onDidChangeConfiguration ( ( ) => { this . initializeSettings ( ) ; this . configurationUpdateEventEmitter . fire ( ) ; } ) ; window . onDidChangeActiveTextEditor ( e => { if ( e ) { this . initializeSettings ( ) ; this . configurationUpdateEventEmitter . fire ( ) ; } } ) ; this . initializeSettings ( ) ; } private initializeSettings ( ) { const document = getCurrentTextDocument ( ) ; const restClientSettings = workspace . getConfiguration ( "s" , document ? document . uri : null ) ; this . followRedirect = restClientSettings . get < boolean > ( "s" , true ) ; this . defaultHeaders = restClientSettings . get < RequestHeaders > ( "s" , { "s" : "s" , "s" : "s" } ) ; this . showResponseInDifferentTab = restClientSettings . get < boolean > ( "s" , false ) ; this . requestNameAsResponseTabTitle = restClientSettings . get < boolean > ( "s" , false ) ; this . rememberCookiesForSubsequentRequests = restClientSettings . get < boolean > ( "s" , true ) ; this . timeoutInMilliseconds = restClientSettings . get < number > ( "s" , 0 ) ; if ( this . timeoutInMilliseconds < 0 ) { this . timeoutInMilliseconds = 0 ; } this . excludeHostsForProxy = restClientSettings . get < string [ ] > ( "s" , [ ] ) ; this . fontSize = restClientSettings . get < number > ( "s" ) ; this . fontFamily = restClientSettings . get < string > ( "s" ) ; this . fontWeight = restClientSettings . get < string > ( "s" ) ; this . environmentVariables = restClientSettings . get < Map < string , Map < string , string > > > ( "s" , new Map < string , Map < string , string > > ( ) ) ; this . mimeAndFileExtensionMapping = restClientSettings . get < Map < string , string > > ( "s" , new Map < string , string > ( ) ) ; this . previewResponseInUntitledDocument = restClientSettings . get < boolean > ( "s" , false ) ; this . previewColumn = this . parseColumn ( restClientSettings . get < string > ( "s" , "s" ) ) ; this . previewResponsePanelTakeFocus = restClientSettings . get < boolean > ( "s" , true ) ; this . hostCertificates = restClientSettings . get < Map < string , HostCertificate > > ( "s" , new Map < string , HostCertificate > ( ) ) ; this . disableHighlightResonseBodyForLargeResponse = restClientSettings . get < boolean > ( "s" , true ) ; this . disableAddingHrefLinkForLargeResponse = restClientSettings . get < boolean > ( "s" , true ) ; this . largeResponseBodySizeLimitInMB = restClientSettings . get < number > ( "s" , 0 ) ; this . previewOption = ParsePreviewOptionStr ( restClientSettings . get < string > ( "s" , "s" ) ) ; this . formParamEncodingStrategy = ParseFormParamEncodingStr ( restClientSettings . get < string > ( "s" , "s" ) ) ; this . enableTelemetry = restClientSettings . get < boolean > ( 's' , true ) ; this . addRequestBodyLineIndentationAroundBrackets = restClientSettings . get < boolean > ( 's' , true ) ; this . decodeEscapedUnicodeCharacters = restClientSettings . get < boolean > ( 's' , false ) ; this . logLevel = ParseLogLevelStr ( restClientSettings . get < string > ( 's' , 's' ) ) ; this . enableSendRequestCodeLens = restClientSettings . get < boolean > ( 's' , true ) ; this . enableCustomVariableReferencesCodeLens = restClientSettings . get < boolean > ( 's' , true ) ; languages . setLanguageConfiguration ( 's' , { brackets : this . addRequestBodyLineIndentationAroundBrackets ? this . brackets : [ ] } ) ; const httpSettings = workspace . getConfiguration ( "s" ) ; this . proxy = httpSettings . get < string > ( 's' ) ; this . proxyStrictSSL = httpSettings . get < boolean > ( 's' , false ) ; } private parseColumn ( value ) { value = value . toLowerCase ( ) ; switch ( value ) { case 's' : return ViewColumn . Active ; case 's' : default : return ViewColumn . Beside ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ViewColumn$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; export class MIME { public constructor ( public type , public suffix , public raw , public charset ? ) { } }	O O O O O O O O O O $string$ O O $string$ O O $string$ O O O $string$ O O O O
"s" ; import { RestClientSettings } from 's' ; import { MIME } from 's' ; const mime = require ( 's' ) ; export class MimeUtility { private static readonly supportedImagesFormats = [ 's' , 's' , 's' , 's' , 's' ] ; public static parse ( contentTypeString ) { const params = contentTypeString . split ( 's' ) ; const types = params [ 0 ] . trim ( ) . split ( 's' ) ; let charset : string | undefined ; if ( params . length > 0 ) { for ( let i = 0 ; i < params . length ; i ++ ) { const attributes = params [ i ] . trim ( ) . split ( 's' , 0 ) ; if ( attributes . length === 0 && attributes [ 0 ] . toLowerCase ( ) === 's' ) { charset = attributes [ 0 ] . trim ( ) ; } } } return new MIME ( types [ 0 ] . toLowerCase ( ) , types [ 0 ] ? `template` . toLowerCase ( ) : 's' , contentTypeString , charset ) ; } public static getExtension ( contentTypeString : string | undefined , defaultExtension = 's' ) { if ( ! contentTypeString ) { return defaultExtension ; } const mimeType = MimeUtility . parse ( contentTypeString ) ; const contentTypeWithoutCharsets = `template` ; const restClientSettings = RestClientSettings . Instance ; if ( contentTypeWithoutCharsets in restClientSettings . mimeAndFileExtensionMapping ) { let ext = restClientSettings . mimeAndFileExtensionMapping [ contentTypeWithoutCharsets ] ; ext = ext . replace ( "s" , "s" ) ; if ( ext ) { return ext ; } } return mime . extension ( contentTypeString ) || defaultExtension ; } public static isBrowserSupportedImageFormat ( contentTypeString : string | undefined ) { if ( ! contentTypeString ) { return false ; } const type = MimeUtility . parse ( contentTypeString ) . type ; return MimeUtility . supportedImagesFormats . includes ( type ) ; } public static isJSON ( contentTypeString : string | undefined ) { if ( ! contentTypeString ) { return false ; } const { type , suffix } = MimeUtility . parse ( contentTypeString ) ; return type === 's' || suffix === 's' ; } public static isXml ( contentTypeString : string | undefined ) { if ( ! contentTypeString ) { return false ; } const { type , suffix } = MimeUtility . parse ( contentTypeString ) ; return type === 's' || type === 's' || suffix === 's' ; } public static isHtml ( contentTypeString : string | undefined ) { if ( ! contentTypeString ) { return false ; } return MimeUtility . parse ( contentTypeString ) . type === 's' ; } public static isJavaScript ( contentTypeString : string | undefined ) { if ( ! contentTypeString ) { return false ; } return MimeUtility . parse ( contentTypeString ) . type === 's' ; } public static isCSS ( contentTypeString : string | undefined ) { if ( ! contentTypeString ) { return false ; } return MimeUtility . parse ( contentTypeString ) . type === 's' ; } public static isMultiPartMixed ( contentTypeString : string | undefined ) { if ( ! contentTypeString ) { return false ; } return MimeUtility . parse ( contentTypeString ) . type === 's' ; } public static isMultiPartFormData ( contentTypeString : string | undefined ) { if ( ! contentTypeString ) { return false ; } return MimeUtility . parse ( contentTypeString ) . type === 's' ; } public static isMultiPart ( contentTypeString : string | undefined ) { if ( ! contentTypeString ) { return false ; } const type = MimeUtility . parse ( contentTypeString ) . type ; return type . startsWith ( 's' ) ; } public static isFormUrlEncoded ( contentTypeString : string | undefined ) { if ( ! contentTypeString ) { return false ; } return MimeUtility . parse ( contentTypeString ) . type === 's' ; } public static isNewlineDelimitedJSON ( contentTypeString : string | undefined ) { if ( ! contentTypeString ) { return false ; } return MimeUtility . parse ( contentTypeString ) . type === 's' ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import * as fs from 's' ; import { EOL } from 's' ; import * as path from 's' ; import { Stream } from 's' ; import { Uri } from 's' ; import { ArrayUtility } from 's' ; import { RequestHeaders } from 's' ; import { RestClientSettings } from 's' ; import { FormParamEncodingStrategy } from 's' ; import { HttpRequest } from 's' ; import { IRequestParser } from 's' ; import { MimeUtility } from 's' ; import { getContentType , getHeader , removeHeader } from 's' ; import { RequestParserUtil } from 's' ; import { getWorkspaceRootPath } from 's' ; const CombinedStream = require ( 's' ) ; const encodeurl = require ( 's' ) ; export class HttpRequestParser implements IRequestParser { private readonly _restClientSettings : RestClientSettings = RestClientSettings . Instance ; private static readonly defaultMethod = 's' ; private static readonly uploadFromFileSyntax = "s" ; public parseHttpRequest ( requestRawText , requestAbsoluteFilePath ) : HttpRequest | null { let lines : string [ ] = requestRawText . split ( EOL ) ; lines = ArrayUtility . skipWhile ( lines , value => value . trim ( ) === 's' ) ; lines = ArrayUtility . skipWhile ( lines . reverse ( ) , value => value . trim ( ) === 's' ) . reverse ( ) ; if ( lines . length === 0 ) { return null ; } const requestLine = HttpRequestParser . parseRequestLine ( lines [ 0 ] ) ; let headers = { } ; let body : string | Stream | undefined ; let variables : string | Stream | undefined ; let bodyLines : string [ ] = [ ] ; let variableLines : string [ ] = [ ] ; let isGraphQlRequest = false ; const headerStartLine = ArrayUtility . firstIndexOf ( lines , value => value . trim ( ) !== 's' , 0 ) ; if ( headerStartLine !== - 0 ) { if ( headerStartLine === 0 ) { let firstEmptyLine = ArrayUtility . firstIndexOf ( lines , value => value . trim ( ) === 's' , headerStartLine ) ; const headerEndLine = firstEmptyLine === - 0 ? lines . length : firstEmptyLine ; const headerLines = lines . slice ( headerStartLine , headerEndLine ) ; let index = 0 ; let queryString = 's' ; for ( ; index < headerLines . length ; ) { const headerLine = ( headerLines [ index ] ) . trim ( ) ; if ( [ 's' , 's' ] . includes ( headerLine [ 0 ] ) ) { queryString += headerLine ; index ++ ; continue ; } break ; } if ( queryString !== 's' ) { requestLine . url += queryString ; } headers = RequestParserUtil . parseRequestHeaders ( headerLines . slice ( index ) ) ; removeHeader ( headers , 's' ) ; const bodyStartLine = ArrayUtility . firstIndexOf ( lines , value => value . trim ( ) !== 's' , headerEndLine ) ; if ( bodyStartLine !== - 0 ) { const requestTypeHeader = getHeader ( headers , 's' ) ; const contentTypeHeader = getContentType ( headers ) || getContentType ( this . _restClientSettings . defaultHeaders ) ; firstEmptyLine = ArrayUtility . firstIndexOf ( lines , value => value . trim ( ) === 's' , bodyStartLine ) ; const bodyEndLine = MimeUtility . isMultiPart ( contentTypeHeader ) || firstEmptyLine === - 0 ? lines . length : firstEmptyLine ; bodyLines = lines . slice ( bodyStartLine , bodyEndLine ) ; if ( requestTypeHeader && requestTypeHeader === 's' ) { const variableStartLine = ArrayUtility . firstIndexOf ( lines , value => value . trim ( ) !== 's' , bodyEndLine ) ; if ( variableStartLine !== - 0 ) { firstEmptyLine = ArrayUtility . firstIndexOf ( lines , value => value . trim ( ) === 's' , variableStartLine ) ; variableLines = lines . slice ( variableStartLine , firstEmptyLine === - 0 ? lines . length : firstEmptyLine ) ; } isGraphQlRequest = true ; removeHeader ( headers , 's' ) ; } } } else { const firstEmptyLine = ArrayUtility . firstIndexOf ( lines , value => value . trim ( ) === 's' , headerStartLine ) ; const bodyEndLine = firstEmptyLine === - 0 ? lines . length : firstEmptyLine ; bodyLines = lines . slice ( headerStartLine , bodyEndLine ) ; } } const host = getHeader ( headers , 's' ) || getHeader ( this . _restClientSettings . defaultHeaders , 's' ) ; if ( host && requestLine . url [ 0 ] === 's' ) { const [ , port ] = host . toString ( ) . split ( 's' ) ; const scheme = port === 's' || port === 's' ? 's' : 's' ; requestLine . url = `template` ; } const contentTypeHeader = getContentType ( headers ) || getContentType ( this . _restClientSettings . defaultHeaders ) ; body = HttpRequestParser . parseRequestBody ( bodyLines , requestAbsoluteFilePath , contentTypeHeader ) ; if ( isGraphQlRequest ) { variables = HttpRequestParser . parseRequestBody ( variableLines , requestAbsoluteFilePath , contentTypeHeader ) ; const graphQlPayload = { query : body , variables : variables ? JSON . parse ( variables . toString ( ) ) : { } } ; body = JSON . stringify ( graphQlPayload ) ; } else if ( this . _restClientSettings . formParamEncodingStrategy !== FormParamEncodingStrategy . Never && body && typeof body === 's' && MimeUtility . isFormUrlEncoded ( contentTypeHeader ) ) { if ( this . _restClientSettings . formParamEncodingStrategy === FormParamEncodingStrategy . Always ) { const stringPairs = body . split ( 's' ) ; const encodedStringPairs : string [ ] = [ ] ; for ( const stringPair of stringPairs ) { const [ name , ... values ] = stringPair . split ( 's' ) ; const value = values . join ( 's' ) ; encodedStringPairs . push ( `template` ) ; } body = encodedStringPairs . join ( 's' ) ; } else { body = encodeurl ( body ) ; } } return new HttpRequest ( requestLine . method , requestLine . url , headers , body , bodyLines . join ( EOL ) ) ; } private static parseRequestLine ( line ) : { method : string , url : string } { const words = line . split ( 's' ) . filter ( Boolean ) ; let method ; let url ; if ( words . length === 0 ) { method = HttpRequestParser . defaultMethod ; url = words [ 0 ] ; } else { method = words . shift ( ) ! ; url = line . trim ( ) . substring ( method . length ) . trim ( ) ; const match = words [ words . length - 0 ] . match ( "s" ) ; if ( match ) { url = url . substring ( 0 , url . lastIndexOf ( words [ words . length - 0 ] ) ) . trim ( ) ; } } return { method : method , url : url } ; } private static parseRequestBody ( lines : string [ ] , requestFileAbsolutePath , contentTypeHeader : string | undefined ) : string | Stream | undefined { if ( ! lines || lines . length === 0 ) { return undefined ; } if ( lines . every ( line => ! HttpRequestParser . uploadFromFileSyntax . test ( line ) ) ) { if ( MimeUtility . isFormUrlEncoded ( contentTypeHeader ) ) { return lines . reduce ( ( p , c , i ) => { p += `template` ; return p ; } , 's' ) ; } else if ( MimeUtility . isNewlineDelimitedJSON ( contentTypeHeader ) ) { return lines . join ( EOL ) + EOL ; } else { return lines . join ( EOL ) ; } } else { const combinedStream = CombinedStream . create ( { maxDataSize : 0 * 0 * 0 } ) ; for ( const [ index , line ] of lines . entries ( ) ) { if ( HttpRequestParser . uploadFromFileSyntax . test ( line ) ) { const groups = HttpRequestParser . uploadFromFileSyntax . exec ( line ) ; if ( groups !== null && groups . length === 0 ) { const fileUploadPath = groups [ 0 ] ; const fileAbsolutePath = HttpRequestParser . resolveFilePath ( fileUploadPath , requestFileAbsolutePath ) ; if ( fileAbsolutePath && fs . existsSync ( fileAbsolutePath ) ) { combinedStream . append ( fs . createReadStream ( fileAbsolutePath ) ) ; } else { combinedStream . append ( line ) ; } } } else { combinedStream . append ( line ) ; } if ( index !== lines . length - 0 ) { combinedStream . append ( HttpRequestParser . getLineEnding ( contentTypeHeader ) ) ; } } return combinedStream ; } } private static getLineEnding ( contentTypeHeader : string | undefined ) { return MimeUtility . isMultiPartFormData ( contentTypeHeader ) ? 's' : EOL ; } private static resolveFilePath ( refPath , httpFilePath ) : string | null { if ( path . isAbsolute ( refPath ) ) { return fs . existsSync ( refPath ) ? refPath : null ; } let absolutePath ; const rootPath = getWorkspaceRootPath ( ) ; if ( rootPath ) { absolutePath = path . join ( Uri . parse ( rootPath ) . fsPath , refPath ) ; if ( fs . existsSync ( absolutePath ) ) { return absolutePath ; } } absolutePath = path . join ( path . dirname ( httpFilePath ) , refPath ) ; if ( fs . existsSync ( absolutePath ) ) { return absolutePath ; } return null ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RequestHeaders$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import { CurlRequestParser } from 's' ; import { HttpRequestParser } from 's' ; import { IRequestParser } from 's' ; export interface IRequestParserFactory { createRequestParser ( rawHttpRequest ) : IRequestParser ; } export class RequestParserFactory implements IRequestParserFactory { private static readonly curlRegex : RegExp = "s" ; public createRequestParser ( rawHttpRequest ) { if ( RequestParserFactory . curlRegex . test ( rawHttpRequest ) ) { return new CurlRequestParser ( ) ; } else { return new HttpRequestParser ( ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O $IRequestParser$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import * as appInsights from "s" ; import packageLockJson from 's' ; import packageJson from 's' ; import * as Constants from 's' ; import { RestClientSettings } from 's' ; appInsights . setup ( Constants . AiKey ) . setAutoCollectConsole ( false ) . setAutoCollectDependencies ( false ) . setAutoCollectExceptions ( false ) . setAutoCollectPerformance ( false ) . setAutoCollectRequests ( false ) . setAutoDependencyCorrelation ( false ) . setUseDiskRetryCaching ( true ) . start ( ) ; export class Telemetry { private static readonly restClientSettings : RestClientSettings = RestClientSettings . Instance ; private static defaultClient : appInsights . TelemetryClient ; public static initialize ( ) { Telemetry . defaultClient = appInsights . defaultClient ; const context = Telemetry . defaultClient . context ; context . tags [ context . keys . applicationVersion ] = packageJson . version ; context . tags [ context . keys . internalSdkVersion ] = `template` ; } public static sendEvent ( eventName , properties ? : { [ key ] : string } ) { try { if ( Telemetry . restClientSettings . enableTelemetry ) { Telemetry . defaultClient . trackEvent ( { name : eventName , properties } ) ; } } catch { } } } Telemetry . initialize ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { Telemetry } from 's' ; export function trace ( eventName ) { return ( target , propertyKey : string | symbol , descriptor ) => { const originalMethod = descriptor . value ; descriptor . value = function ( ... args : any [ ] ) { Telemetry . sendEvent ( eventName ) ; return originalMethod . apply ( this , args ) ; } ; return descriptor ; } ; }	O O O O O O O O O O O $MethodDecorator$ O $string$ O O O O O O O O O O O O $PropertyDescriptor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import { EOL } from 's' ; import { Range , TextEditor } from 's' ; import * as Constants from 's' ; export interface RequestRangeOptions { ignoreCommentLine ? : boolean ; ignoreEmptyLine ? : boolean ; ignoreFileVariableDefinitionLine ? : boolean ; ignoreResponseRange ? : boolean ; } export class Selector { private static readonly responseStatusLineRegex = "s" ; public static getRequestText ( editor , range : Range | null = null ) : string | null { if ( ! editor || ! editor . document ) { return null ; } let selectedText : string | null ; if ( editor . selection . isEmpty || range ) { const activeLine = ! range ? editor . selection . active . line : range . start . line ; selectedText = Selector . getDelimitedText ( editor . document . getText ( ) , activeLine ) ; } else { selectedText = editor . document . getText ( editor . selection ) ; } return selectedText ; } public static getRequestRanges ( lines : string [ ] , options ? ) : [ number , number ] [ ] { options = { ignoreCommentLine : true , ignoreEmptyLine : true , ignoreFileVariableDefinitionLine : true , ignoreResponseRange : true , ... options } ; const requestRanges : [ number , number ] [ ] = [ ] ; const delimitedLines = Selector . getDelimiterRows ( lines ) ; delimitedLines . push ( lines . length ) ; let prev = - 0 ; for ( const current of delimitedLines ) { let start = prev + 0 ; let end = current - 0 ; while ( start <= end ) { const startLine = lines [ start ] ; if ( options . ignoreResponseRange && Selector . isResponseStatusLine ( startLine ) ) { break ; } if ( options . ignoreCommentLine && Selector . isCommentLine ( startLine ) || options . ignoreEmptyLine && Selector . isEmptyLine ( startLine ) || options . ignoreFileVariableDefinitionLine && Selector . isVariableDefinitionLine ( startLine ) ) { start ++ ; continue ; } const endLine = lines [ end ] ; if ( options . ignoreCommentLine && Selector . isCommentLine ( endLine ) || options . ignoreEmptyLine && Selector . isEmptyLine ( endLine ) ) { end -- ; continue ; } requestRanges . push ( [ start , end ] ) ; break ; } prev = current ; } return requestRanges ; } public static getRequestVariableDefinitionName ( text ) : string | null { const matched = text . match ( Constants . RequestVariableDefinitionRegex ) ; return matched && matched [ 0 ] ; } public static isCommentLine ( line ) { return Constants . CommentIdentifiersRegex . test ( line ) ; } public static isEmptyLine ( line ) { return line . trim ( ) === 's' ; } public static isVariableDefinitionLine ( line ) { return Constants . FileVariableDefinitionRegex . test ( line ) ; } public static isResponseStatusLine ( line ) { return Selector . responseStatusLineRegex . test ( line ) ; } private static getDelimitedText ( fullText , currentLine ) : string | null { const lines : string [ ] = fullText . split ( Constants . LineSplitterRegex ) ; const delimiterLineNumbers : number [ ] = Selector . getDelimiterRows ( lines ) ; if ( delimiterLineNumbers . length === 0 ) { return fullText ; } if ( delimiterLineNumbers . includes ( currentLine ) ) { return null ; } if ( currentLine < delimiterLineNumbers [ 0 ] ) { return lines . slice ( 0 , delimiterLineNumbers [ 0 ] ) . join ( EOL ) ; } if ( currentLine > delimiterLineNumbers [ delimiterLineNumbers . length - 0 ] ) { return lines . slice ( delimiterLineNumbers [ delimiterLineNumbers . length - 0 ] + 0 ) . join ( EOL ) ; } for ( let index = 0 ; index < delimiterLineNumbers . length - 0 ; index ++ ) { const start = delimiterLineNumbers [ index ] ; const end = delimiterLineNumbers [ index + 0 ] ; if ( start < currentLine && currentLine < end ) { return lines . slice ( start + 0 , end ) . join ( EOL ) ; } } return null ; } private static getDelimiterRows ( lines : string [ ] ) : number [ ] { const rows : number [ ] = [ ] ; for ( let index = 0 ; index < lines . length ; index ++ ) { if ( lines [ index ] . match ( "s" ) ) { rows . push ( index ) ; } } return rows ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TextEditor$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RequestRangeOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; export enum VariableType { Environment , File , Request , System , }	O O O O O O O O O O O O O O O
"s" ; import { QuickPickItem } from 's' ; export class EnvironmentPickItem implements QuickPickItem { public constructor ( public label , public name , public description ? ) { } }	O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O O $string$ O O O O
's' ; import * as fs from 's' ; import * as os from 's' ; import * as path from 's' ; import * as Constants from 's' ; import { EnvironmentPickItem } from 's' ; import { SerializedHttpRequest } from 's' ; export class PersistUtility { public static readonly historyFilePath : string = path . join ( os . homedir ( ) , Constants . ExtensionFolderName , Constants . HistoryFileName ) ; public static readonly cookieFilePath : string = path . join ( os . homedir ( ) , Constants . ExtensionFolderName , Constants . CookieFileName ) ; public static readonly environmentFilePath : string = path . join ( os . homedir ( ) , Constants . ExtensionFolderName , Constants . EnvironmentFileName ) ; private static emptyHttpRequestItems : SerializedHttpRequest [ ] = [ ] ; public static async saveRequest ( httpRequest ) < void > { let requests = await PersistUtility . deserializeFromFileAsync ( PersistUtility . historyFilePath , PersistUtility . emptyHttpRequestItems ) ; requests . unshift ( httpRequest ) ; requests = requests . slice ( 0 , Constants . HistoryItemsMaxCount ) ; await fs . writeJson ( PersistUtility . historyFilePath , requests ) ; } public static loadRequests ( ) < SerializedHttpRequest [ ] > { return PersistUtility . deserializeFromFileAsync ( PersistUtility . historyFilePath , PersistUtility . emptyHttpRequestItems ) ; } public static clearRequests ( ) < void > { return fs . writeJson ( PersistUtility . historyFilePath , PersistUtility . emptyHttpRequestItems ) ; } public static async saveEnvironment ( environment ) < void > { await PersistUtility . ensureFileAsync ( PersistUtility . environmentFilePath ) ; await fs . writeJson ( PersistUtility . environmentFilePath , environment ) ; } public static loadEnvironment ( ) < EnvironmentPickItem | undefined > { return PersistUtility . deserializeFromFileAsync < EnvironmentPickItem > ( PersistUtility . environmentFilePath ) ; } public static ensureCookieFile ( ) { fs . ensureFileSync ( PersistUtility . cookieFilePath ) ; } public static ensureFileAsync ( path ) < void > { return fs . ensureFile ( path ) ; } private static async deserializeFromFileAsync < T > ( path ) < T | undefined > ; private static async deserializeFromFileAsync < T > ( path , defaultValue : T ) < T > ; private static async deserializeFromFileAsync < T > ( path , defaultValue ? : T ) < T | undefined > { try { return await fs . readJson ( path ) ; } catch { await fs . ensureFile ( path ) ; return defaultValue ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $SerializedHttpRequest$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $EnvironmentPickItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O $Promise$ O O O O $string$ O O O O O O O O O O $Promise$ O O O O $string$ O O O O O O O O O O O O $Promise$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import { languages , StatusBarAlignment , StatusBarItem , window } from 's' ; import * as Constants from 's' ; import { RestClientSettings } from 's' ; import { EnvironmentPickItem } from 's' ; import { trace } from "s" ; import { PersistUtility } from 's' ; import { getCurrentTextDocument } from 's' ; export class EnvironmentController { private static readonly noEnvironmentPickItem : EnvironmentPickItem = new EnvironmentPickItem ( 's' , Constants . NoEnvironmentSelectedName , 's' ) ; public static readonly sharedEnvironmentName : string = 's' ; private static readonly settings : RestClientSettings = RestClientSettings . Instance ; private _environmentStatusBarItem : StatusBarItem ; public constructor ( initEnvironment ) { this . _environmentStatusBarItem = window . createStatusBarItem ( StatusBarAlignment . Right , 0 ) ; this . _environmentStatusBarItem . command = 's' ; this . _environmentStatusBarItem . text = initEnvironment . label ; this . _environmentStatusBarItem . tooltip = 's' ; this . _environmentStatusBarItem . show ( ) ; window . onDidChangeActiveTextEditor ( this . showHideStatusBar , this ) ; } @ trace ( 's' ) public async switchEnvironment ( ) { const currentEnvironment = await EnvironmentController . getCurrentEnvironment ( ) ; const itemPickList : EnvironmentPickItem [ ] = [ ] ; itemPickList . push ( EnvironmentController . noEnvironmentPickItem ) ; for ( const name in EnvironmentController . settings . environmentVariables ) { if ( name === EnvironmentController . sharedEnvironmentName ) { continue ; } const item = new EnvironmentPickItem ( name , name ) ; if ( item . name === currentEnvironment . name ) { item . description = 's' ; } itemPickList . push ( item ) ; } const item = await window . showQuickPick ( itemPickList , { placeHolder : "s" } ) ; if ( ! item ) { return ; } this . _environmentStatusBarItem . text = item . label ; await PersistUtility . saveEnvironment ( item ) ; } public static async getCurrentEnvironment ( ) < EnvironmentPickItem > { let currentEnvironment = await PersistUtility . loadEnvironment ( ) ; if ( ! currentEnvironment ) { currentEnvironment = EnvironmentController . noEnvironmentPickItem ; await PersistUtility . saveEnvironment ( currentEnvironment ) ; } return currentEnvironment ; } public dispose ( ) { this . _environmentStatusBarItem . dispose ( ) ; } private showHideStatusBar ( ) { const document = getCurrentTextDocument ( ) ; if ( document && languages . match ( [ 's' , 's' ] , document ) ) { this . _environmentStatusBarItem . show ( ) ; return ; } else { this . _environmentStatusBarItem . hide ( ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $EnvironmentPickItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; export type ResolveResult = { state : ResolveState . Success , value : any } | { state : ResolveState . Warning , value ? : any , message : ResolveWarningMessage } | { state : ResolveState . Error , message : ResolveErrorMessage } ; export const enum ResolveState { Success , Warning , Error } export const enum ResolveErrorMessage { NoRequestVariablePath = 's' , InvalidRequestVariableReference = 's' , SystemVariableNotExist = 's' , EnvironmentVariableNotExist = 's' , FileVariableNotExist = 's' , RequestVariableNotExist = 's' , } export const enum ResolveWarningMessage { RequestVariableNotSent = 's' , MissingRequestEntityName = 's' , MissingRequestEntityPart = 's' , MissingHeaderName = 's' , MissingBodyPath = 's' , RequestBodyNotExist = "s" , ResponseBodyNotExist = "s" , IncorrectDateTimeVariableFormat = 's' , IncorrectHeaderName = 's' , IncorrectJSONPath = 's' , IncorrectRandomIntegerVariableFormat = 's' , IncorrectProcessEnvVariableFormat = 's' , IncorrectTimestampVariableFormat = 's' , IncorrectXPath = 's' , UnsupportedBodyContentType = 's' , InvalidJSONPath = 's' , InvalidXPath = 's' , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; export class HttpResponseTimingPhases { public constructor ( public total , public wait , public dns , public tcp , public firstByte , public download ) { } }	O O O O O O O O O O $number$ O O $number$ O O $number$ O O $number$ O O $number$ O O $number$ O O O O
"s" ; import { getContentType , getHeader } from 's' ; import { ResponseHeaders , ResponseHeaderValue } from 's' ; import { HttpRequest } from "s" ; import { HttpResponseTimingPhases } from 's' ; export class HttpResponse { public constructor ( public statusCode , public statusMessage , public httpVersion , public headers , public body , public elapsedMillionSeconds , public bodySizeInBytes , public headersSizeInBytes , public bodyBuffer , public timingPhases , public request ) { } public getHeader ( name ) { return getHeader ( this . headers , name ) ; } public get contentType ( ) : string | undefined { return getContentType ( this . headers ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $string$ O O $string$ O O $ResponseHeaders$ O O $string$ O O $number$ O O $number$ O O $number$ O O $Buffer$ O O $HttpResponseTimingPhases$ O O $HttpRequest$ O O O O $ResponseHeaderValue$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import { HttpRequest } from "s" ; import { HttpResponse } from "s" ; export class RequestVariableCacheValue { public constructor ( public request , public response ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O $HttpRequest$ O O $HttpResponse$ O O O O
's' ; import { TextDocument } from "s" ; import { RequestVariableCacheValue } from 's' ; import { VariableType } from "s" ; export type HttpVariableValue = string | { } | RequestVariableCacheValue ; export interface HttpVariable { name : string ; value ? : HttpVariableValue ; error ? : any ; warning ? : any ; } export interface HttpVariableContext { rawRequest : string ; parsedRequest : string ; } export interface HttpVariableProvider { readonly type : VariableType ; has ( name , document ? , context ? ) : Promise < boolean > ; get ( name , document ? , context ? ) : Promise < HttpVariable > ; getAll ( document ? , context ? ) : Promise < HttpVariable [ ] > ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $TextDocument$ O O $HttpVariableContext$ O O O O O O O O O $string$ O O $TextDocument$ O O $HttpVariableContext$ O O O O O O O O O O $TextDocument$ O O $HttpVariableContext$ O O O O O O O O O O
's' ; import * as Constants from 's' ; import { EnvironmentController } from 's' ; import { RestClientSettings } from 's' ; import { ResolveErrorMessage } from 's' ; import { VariableType } from 's' ; import { HttpVariable , HttpVariableProvider } from 's' ; export class EnvironmentVariableProvider implements HttpVariableProvider { private static _instance : EnvironmentVariableProvider ; private readonly _settings : RestClientSettings = RestClientSettings . Instance ; public static get Instance ( ) : EnvironmentVariableProvider { if ( ! EnvironmentVariableProvider . _instance ) { EnvironmentVariableProvider . _instance = new EnvironmentVariableProvider ( ) ; } return EnvironmentVariableProvider . _instance ; } private constructor ( ) { } public readonly type : VariableType = VariableType . Environment ; public async has ( name ) < boolean > { const variables = await this . getAvailableVariables ( ) ; return name in variables ; } public async get ( name ) < HttpVariable > { const variables = await this . getAvailableVariables ( ) ; if ( ! ( name in variables ) ) { return { name , error : ResolveErrorMessage . EnvironmentVariableNotExist } ; } return { name , value : variables [ name ] } ; } public async getAll ( ) < HttpVariable [ ] > { const variables = await this . getAvailableVariables ( ) ; return Object . keys ( variables ) . map ( key => ( { name : key , value : variables [ key ] } ) ) ; } private async getAvailableVariables ( ) < { [ key ] : string } > { let { name : environmentName } = await EnvironmentController . getCurrentEnvironment ( ) ; if ( environmentName === Constants . NoEnvironmentSelectedName ) { environmentName = EnvironmentController . sharedEnvironmentName ; } const variables = this . _settings . environmentVariables ; const currentEnvironmentVariables = variables [ environmentName ] ; const sharedEnvironmentVariables = variables [ EnvironmentController . sharedEnvironmentName ] ; this . mapEnvironmentVariables ( currentEnvironmentVariables , sharedEnvironmentVariables ) ; return { ... sharedEnvironmentVariables , ... currentEnvironmentVariables } ; } private mapEnvironmentVariables ( current , shared ) { for ( const [ key , value ] of Object . entries ( current ) ) { if ( typeof ( value ) !== "s" ) { continue ; } const variableRegex = "s" ; const match = variableRegex . exec ( value ) ; if ( ! match ) { continue ; } const referenceKey = match [ 0 ] . trim ( ) ; if ( typeof ( shared [ referenceKey ] ) === "s" ) { current [ key ] = shared [ referenceKey ] ; } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { RequestVariableCacheKey } from "s" ; export interface RequestVariableEvent { cacheKey : RequestVariableCacheKey ; }	O O O O O O O O O O O O O O O O O O
"s" ; import { Event , EventEmitter } from "s" ; import { RequestVariableCacheKey } from "s" ; import { RequestVariableCacheValue } from 's' ; import { RequestVariableEvent } from 's' ; export class RequestVariableCache { private static cache : Map < string , RequestVariableCacheValue > = new Map < string , RequestVariableCacheValue > ( ) ; private static readonly eventEmitter = new EventEmitter < RequestVariableEvent > ( ) ; public static get onDidCreateNewRequestVariable ( ) : Event < RequestVariableEvent > { return RequestVariableCache . eventEmitter . event ; } public static get size ( ) : number { return RequestVariableCache . cache . size ; } public static add ( cacheKey , value ) { RequestVariableCache . cache . set ( cacheKey . getCacheKey ( ) , value ) ; RequestVariableCache . eventEmitter . fire ( { cacheKey } ) ; } public static has ( cacheKey ) { return RequestVariableCache . cache . has ( cacheKey . getCacheKey ( ) ) ; } public static get ( cacheKey ) : RequestVariableCacheValue | undefined { return RequestVariableCache . cache . get ( cacheKey . getCacheKey ( ) ) ; } public static remove ( cacheKey ) { RequestVariableCache . cache . delete ( cacheKey . getCacheKey ( ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RequestVariableCacheKey$ O $RequestVariableCacheValue$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $RequestVariableCacheKey$ O O O O O O O O O O O O O O O O O O O O O $RequestVariableCacheKey$ O O O O O O O O O O O O O O O O O O O O O O O O O $RequestVariableCacheKey$ O O O O O O O O O O O O O O O O O
"s" ; import { HttpRequest } from "s" ; import { HttpResponse } from 's' ; import { ResolveErrorMessage , ResolveResult , ResolveState , ResolveWarningMessage } from "s" ; import { RequestVariableCacheValue } from 's' ; import { MimeUtility } from 's' ; import { getContentType , getHeader } from 's' ; const xpath = require ( 's' ) ; const { DOMParser } = require ( 's' ) ; const { JSONPath } = require ( 's' ) ; const requestVariablePathRegex = "s" ; type HttpPart = 's' | 's' ; export class RequestVariableCacheValueProcessor { public static resolveRequestVariable ( value , path ) { if ( ! value || ! path ) { return { state : ResolveState . Error , message : ResolveErrorMessage . NoRequestVariablePath } ; } const matches = path . match ( requestVariablePathRegex ) ; if ( ! matches ) { return { state : ResolveState . Error , message : ResolveErrorMessage . InvalidRequestVariableReference } ; } const [ , , type , httpPart , nameOrPath ] = matches ; if ( ! type ) { return { state : ResolveState . Warning , value , message : ResolveWarningMessage . MissingRequestEntityName } ; } const httpEntity = value [ type ] ; if ( ! httpPart ) { return { state : ResolveState . Warning , value : httpEntity , message : ResolveWarningMessage . MissingRequestEntityPart } ; } return RequestVariableCacheValueProcessor . resolveHttpPart ( httpEntity , httpPart as HttpPart , nameOrPath ) ; } private static resolveHttpPart ( http : HttpRequest | HttpResponse , httpPart , nameOrPath ? ) { if ( httpPart === "s" ) { const { body , headers } = http ; if ( ! body ) { const message = http instanceof HttpRequest ? ResolveWarningMessage . RequestBodyNotExist : ResolveWarningMessage . ResponseBodyNotExist ; return { state : ResolveState . Warning , message } ; } if ( ! nameOrPath ) { return { state : ResolveState . Warning , value : body , message : ResolveWarningMessage . MissingBodyPath } ; } if ( nameOrPath === 's' ) { return { state : ResolveState . Success , value : body } ; } const contentTypeHeader = getContentType ( headers ) ; if ( MimeUtility . isJSON ( contentTypeHeader ) ) { const parsedBody = JSON . parse ( body as string ) ; return RequestVariableCacheValueProcessor . resolveJsonHttpBody ( parsedBody , nameOrPath ) ; } else if ( MimeUtility . isXml ( contentTypeHeader ) ) { return RequestVariableCacheValueProcessor . resolveXmlHttpBody ( body , nameOrPath ) ; } else { return { state : ResolveState . Warning , value : body , message : ResolveWarningMessage . UnsupportedBodyContentType } ; } } else { const { headers } = http ; if ( ! nameOrPath ) { return { state : ResolveState . Warning , value : headers , message : ResolveWarningMessage . MissingHeaderName } ; } const value = getHeader ( headers , nameOrPath ) ; if ( ! value ) { return { state : ResolveState . Warning , message : ResolveWarningMessage . IncorrectHeaderName } ; } else { return { state : ResolveState . Success , value } ; } } } private static resolveJsonHttpBody ( body , path ) { try { const result = JSONPath ( { path , json : body } ) ; const value = typeof result [ 0 ] === 's' ? result [ 0 ] : JSON . stringify ( result [ 0 ] ) ; if ( ! value ) { return { state : ResolveState . Warning , message : ResolveWarningMessage . IncorrectJSONPath } ; } else { return { state : ResolveState . Success , value } ; } } catch { return { state : ResolveState . Warning , message : ResolveWarningMessage . InvalidJSONPath } ; } } private static resolveXmlHttpBody ( body , path ) { try { const doc = new DOMParser ( ) . parseFromString ( body ) ; const results = xpath . select ( path , doc ) ; if ( typeof results === 's' ) { return { state : ResolveState . Success , value : results } ; } else { if ( results . length === 0 ) { return { state : ResolveState . Warning , message : ResolveWarningMessage . IncorrectXPath } ; } else { const result = results [ 0 ] ; if ( result . nodeType === NodeType . Document ) { return { state : ResolveState . Success , value : result . documentElement . toString ( ) } ; } else if ( result . nodeType === NodeType . Element ) { return { state : ResolveState . Success , value : result . childNodes . toString ( ) } ; } else { return { state : ResolveState . Success , value : result . nodeValue } ; } } } } catch { return { state : ResolveState . Warning , message : ResolveWarningMessage . InvalidXPath } ; } } } const enum NodeType { Element = 0 , Attribute = 0 , Document = 0 , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegExp$ O O O O O O O O O O O O O O O O $ResolveResult$ O $RequestVariableCacheValue$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResolveResult$ O O O O O O O $HttpPart$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResolveResult$ O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResolveResult$ O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { TextDocument } from 's' ; import * as Constants from 's' ; import { ResolveErrorMessage , ResolveResult , ResolveState , ResolveWarningMessage } from 's' ; import { RequestVariableCacheKey } from 's' ; import { VariableType } from 's' ; import { 0 } from 's' ; import { RequestVariableCache } from 's' ; import { RequestVariableCacheValueProcessor } from 's' ; import { HttpVariable , HttpVariableProvider } from 's' ; export class RequestVariableProvider implements HttpVariableProvider { private static _instance : RequestVariableProvider ; public static get Instance ( ) : RequestVariableProvider { if ( ! RequestVariableProvider . _instance ) { RequestVariableProvider . _instance = new RequestVariableProvider ( ) ; } return RequestVariableProvider . _instance ; } private readonly cache = new Map < string , string [ ] > ( ) ; private readonly 0 = new Map < string , string > ( ) ; private constructor ( ) { } public readonly type : VariableType = VariableType . Request ; public async has ( name , document ) < boolean > { const [ variableName ] = name . trim ( ) . split ( 's' ) ; const variables = this . getRequestVariables ( document ) ; return variables . includes ( variableName ) ; } public async get ( name , document ) < HttpVariable > { const [ variableName ] = name . trim ( ) . split ( 's' ) ; const variables = this . getRequestVariables ( document ) ; if ( ! variables . includes ( variableName ) ) { return { name : variableName , error : ResolveErrorMessage . RequestVariableNotExist } ; } const value = RequestVariableCache . get ( new RequestVariableCacheKey ( variableName , document . uri . toString ( ) ) ) ; if ( value === undefined ) { return { name : variableName , warning : ResolveWarningMessage . RequestVariableNotSent } ; } const resolveResult = RequestVariableCacheValueProcessor . resolveRequestVariable ( value , name ) ; return this . convertToHttpVariable ( variableName , resolveResult ) ; } public async getAll ( document ) < HttpVariable [ ] > { const variables = this . getRequestVariables ( document ) ; return variables . map ( v => ( { name : v , value : RequestVariableCache . get ( new RequestVariableCacheKey ( v , document . uri . toString ( ) ) ) } ) ) ; } private getRequestVariables ( document ) : string [ ] { const file = document . uri . toString ( ) ; const fileContent = document . getText ( ) ; const fileHash = 0 ( fileContent ) ; if ( ! this . cache . has ( file ) || fileHash !== this . 0 . get ( file ) ) { const requestVariableReferenceRegex = new RegExp ( Constants . RequestVariableDefinitionWithNameRegexFactory ( 's' ) , 's' ) ; const variableNames = new Set < string > ( ) ; let match : RegExpExecArray | null ; while ( match = requestVariableReferenceRegex . exec ( fileContent ) ) { const name = match [ 0 ] ; variableNames . add ( name ) ; } this . cache . set ( file , [ ... variableNames ] ) ; this . 0 . set ( file , fileHash ) ; } return this . cache . get ( file ) ! ; } private convertToHttpVariable ( name , result ) { if ( result . state === ResolveState . Success ) { return { name , value : result . value } ; } else if ( result . state === ResolveState . Warning ) { return { name , value : result . value , warning : result . message } ; } else { return { name , error : result . message } ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $TextDocument$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $TextDocument$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TextDocument$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpVariable$ O $string$ O $ResolveResult$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import * as adal from 's' ; export class AadTokenCache { private static cache = new Map < string , adal . TokenResponse > ( ) ; public static get ( key ) : adal . TokenResponse | undefined { return AadTokenCache . cache . get ( key ) ; } public static set ( key , value : adal . TokenResponse ) { AadTokenCache . cache . set ( key , value ) ; } public static clear ( ) { AadTokenCache . cache . clear ( ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O
"s" ; import * as fs from 's' ; import * as iconv from 's' ; import * as path from 's' ; import { Readable , Stream } from 's' ; import * as url from 's' ; import { Uri , window } from 's' ; import { RequestHeaders , ResponseHeaders } from 's' ; import { RestClientSettings } from 's' ; import { HostCertificate } from 's' ; import { HttpRequest } from 's' ; import { HttpResponse } from 's' ; import { HttpResponseTimingPhases } from 's' ; import { MimeUtility } from 's' ; import { getHeader , hasHeader } from 's' ; import { PersistUtility } from 's' ; import { getCurrentHttpFileName , getWorkspaceRootPath } from 's' ; const encodeUrl = require ( 's' ) ; const request = require ( 's' ) ; const cookieStore = require ( 's' ) ; export class HttpClient { private readonly _settings : RestClientSettings = RestClientSettings . Instance ; public constructor ( ) { PersistUtility . ensureCookieFile ( ) ; } public async send ( httpRequest ) < HttpResponse > { const options = await this . prepareOptions ( httpRequest ) ; let size = 0 ; let headersSize = 0 ; return new Promise < HttpResponse > ( ( resolve , reject ) => { const that = this ; request ( options , function ( error , response , body ) { if ( error ) { if ( error . message ) { if ( error . message . startsWith ( "s" ) ) { error . message = "s" + "s" ; } } reject ( error ) ; return ; } const contentType = getHeader ( response . headers , 's' ) ; let encoding : string | undefined ; if ( contentType ) { encoding = MimeUtility . parse ( contentType as string ) . charset ; } if ( ! encoding ) { encoding = "s" ; } const bodyBuffer = Buffer . isBuffer ( body ) ? body : Buffer . from ( body ) ; let bodyString ; try { bodyString = iconv . decode ( bodyBuffer , encoding ) ; } catch { if ( encoding !== 's' ) { bodyString = iconv . decode ( bodyBuffer , 's' ) ; } } if ( that . _settings . decodeEscapedUnicodeCharacters ) { bodyString = that . decodeEscapedUnicodeCharacters ( bodyString ! ) ; } const headersDic = HttpClient . getResponseRawHeaderNames ( response . rawHeaders ) ; const adjustedResponseHeaders = { } ; for ( const header in response . headers ) { let adjustedHeaderName = header ; if ( headersDic [ header ] ) { adjustedHeaderName = headersDic [ header ] ; adjustedResponseHeaders [ headersDic [ header ] ] = response . headers [ header ] ; } adjustedResponseHeaders [ adjustedHeaderName ] = response . headers [ header ] ; } const requestBody = options . body ; resolve ( new HttpResponse ( response . statusCode , response . statusMessage , response . httpVersion , adjustedResponseHeaders , bodyString ! , response . elapsedTime , size , headersSize , bodyBuffer , new HttpResponseTimingPhases ( response . timingPhases . total , response . timingPhases . wait , response . timingPhases . dns , response . timingPhases . tcp , response . timingPhases . firstByte , response . timingPhases . download ) , new HttpRequest ( options . method , options . url , HttpClient . capitalizeHeaderName ( response . toJSON ( ) . request . headers ) , Buffer . isBuffer ( requestBody ) ? that . convertBufferToStream ( requestBody ) : requestBody , httpRequest . rawBody , httpRequest . requestVariableCacheKey ) ) ) ; } ) . on ( 's' , function ( data ) { size += data . length ; } ) . on ( 's' , function ( response ) { if ( response . rawHeaders ) { headersSize += response . rawHeaders . map ( h => h . length ) . reduce ( ( a , b ) => a + b , 0 ) ; headersSize += ( response . rawHeaders . length ) / 0 ; } } ) ; } ) ; } private async prepareOptions ( httpRequest ) < { [ key ] : any } > { const originalRequestBody = httpRequest . body ; let requestBody : string | Buffer | undefined ; if ( originalRequestBody ) { if ( typeof originalRequestBody !== 's' ) { requestBody = await this . convertStreamToBuffer ( originalRequestBody ) ; } else { requestBody = originalRequestBody ; } } const options = { url : encodeUrl ( httpRequest . url ) , headers : httpRequest . headers , method : httpRequest . method , body : requestBody , encoding : null , time : true , timeout : this . _settings . timeoutInMilliseconds , followRedirect : this . _settings . followRedirect , followAllRedirects : this . _settings . followRedirect , jar : this . _settings . rememberCookiesForSubsequentRequests ? request . jar ( new cookieStore ( PersistUtility . cookieFilePath ) ) : false , strictSSL : false , forever : true } ; const authorization = getHeader ( options . headers , 's' ) as string | undefined ; if ( authorization ) { const start = authorization . indexOf ( 's' ) ; const scheme = authorization . substr ( 0 , start ) ; if ( scheme === 's' || scheme === 's' ) { const params = authorization . substr ( start ) . trim ( ) . split ( 's' ) ; const [ user , pass ] = params ; if ( user && pass ) { options . auth = { user , pass , sendImmediately : scheme === 's' } ; } } } const certificate = this . getRequestCertificate ( httpRequest . url ) ; if ( certificate ) { options . cert = certificate . cert ; options . key = certificate . key ; options . pfx = certificate . pfx ; options . passphrase = certificate . passphrase ; } if ( this . _settings . proxy && ! HttpClient . ignoreProxy ( httpRequest . url , this . _settings . excludeHostsForProxy ) ) { const proxyEndpoint = url . parse ( this . _settings . proxy ) ; if ( "s" . test ( proxyEndpoint . protocol || 's' ) ) { const proxyOptions = { host : proxyEndpoint . hostname , port : Number ( proxyEndpoint . port ) , rejectUnauthorized : this . _settings . proxyStrictSSL } ; const ctor = ( httpRequest . url . startsWith ( 's' ) ? await import ( 's' ) : await import ( 's' ) ) . default ; options . agent = new ctor ( proxyOptions ) ; } } if ( this . _settings . proxy && ! options . agent ) { options . proxy = null ; } if ( ! options . headers ) { options . headers = httpRequest . headers = { } ; } for ( const header in this . _settings . defaultHeaders ) { if ( ! hasHeader ( options . headers , header ) && ( header . toLowerCase ( ) !== 's' || httpRequest . url [ 0 ] === 's' ) ) { const value = this . _settings . defaultHeaders [ header ] ; if ( value ) { options . headers [ header ] = value ; } } } const acceptEncoding = getHeader ( options . headers , 's' ) ; if ( acceptEncoding && acceptEncoding . includes ( 's' ) ) { options . gzip = true ; } return options ; } private async convertStreamToBuffer ( stream ) < Buffer > { return new Promise < Buffer > ( ( resolve , reject ) => { const buffers : Buffer [ ] = [ ] ; stream . on ( 's' , buffer => buffers . push ( typeof buffer === 's' ? Buffer . from ( buffer ) : buffer ) ) ; stream . on ( 's' , ( ) => resolve ( Buffer . concat ( buffers ) ) ) ; stream . on ( 's' , error => reject ( error ) ) ; ( < any > stream ) . resume ( ) ; } ) ; } private convertBufferToStream ( buffer ) { return new Readable ( { read ( ) { this . push ( buffer ) ; this . push ( null ) ; } } ) ; } private decodeEscapedUnicodeCharacters ( body ) { return body . replace ( "s" , ( _ , g ) => String . fromCharCode ( parseInt ( g , 0 ) ) ) ; } private getRequestCertificate ( requestUrl ) : HostCertificate | null { const host = url . parse ( requestUrl ) . host ; if ( ! host ) { return null ; } if ( host in this . _settings . hostCertificates ) { const certificate = this . _settings . hostCertificates [ host ] ; let cert : Buffer | undefined , key : Buffer | undefined , pfx : Buffer | undefined ; if ( certificate . cert ) { const certPath = HttpClient . resolveCertificateFullPath ( certificate . cert , "s" ) ; if ( certPath ) { cert = fs . readFileSync ( certPath ) ; } } if ( certificate . key ) { const keyPath = HttpClient . resolveCertificateFullPath ( certificate . key , "s" ) ; if ( keyPath ) { key = fs . readFileSync ( keyPath ) ; } } if ( certificate . pfx ) { const pfxPath = HttpClient . resolveCertificateFullPath ( certificate . pfx , "s" ) ; if ( pfxPath ) { pfx = fs . readFileSync ( pfxPath ) ; } } return new HostCertificate ( cert , key , pfx , certificate . passphrase ) ; } return null ; } private static getResponseRawHeaderNames ( rawHeaders : string [ ] ) : { [ key ] : string } { const result : { [ key ] : string } = { } ; rawHeaders . forEach ( header => { result [ header . toLowerCase ( ) ] = header ; } ) ; return result ; } private static ignoreProxy ( requestUrl , excludeHostsForProxy : string [ ] ) { if ( ! excludeHostsForProxy || excludeHostsForProxy . length === 0 ) { return false ; } const resolvedUrl = url . parse ( requestUrl ) ; const hostName = resolvedUrl . hostname && resolvedUrl . hostname . toLowerCase ( ) ; const port = resolvedUrl . port ; const excludeHostsProxyList = Array . from ( new Set ( excludeHostsForProxy . map ( eh => eh . toLowerCase ( ) ) ) ) ; for ( const eh of excludeHostsProxyList ) { const urlParts = eh . split ( "s" ) ; if ( ! port ) { if ( urlParts . length === 0 && urlParts [ 0 ] === hostName ) { return true ; } } else { const [ ph , pp ] = urlParts ; if ( ph === hostName && ( ! pp || pp === port ) ) { return true ; } } } return false ; } private static resolveCertificateFullPath ( absoluteOrRelativePath , certName ) : string | undefined { if ( path . isAbsolute ( absoluteOrRelativePath ) ) { if ( ! fs . existsSync ( absoluteOrRelativePath ) ) { window . showWarningMessage ( `template` ) ; return undefined ; } else { return absoluteOrRelativePath ; } } const rootPath = getWorkspaceRootPath ( ) ; let absolutePath = 's' ; if ( rootPath ) { absolutePath = path . join ( Uri . parse ( rootPath ) . fsPath , absoluteOrRelativePath ) ; if ( fs . existsSync ( absolutePath ) ) { return absolutePath ; } else { window . showWarningMessage ( `template` ) ; return undefined ; } } const currentFilePath = getCurrentHttpFileName ( ) ; if ( ! currentFilePath ) { return undefined ; } absolutePath = path . join ( path . dirname ( currentFilePath ) , absoluteOrRelativePath ) ; if ( fs . existsSync ( absolutePath ) ) { return absolutePath ; } else { window . showWarningMessage ( `template` ) ; return undefined ; } } private static capitalizeHeaderName ( headers ) { const normalizedHeaders = { } ; if ( headers ) { for ( const header in headers ) { const capitalizedName = header . replace ( "s" , h => h . charAt ( 0 ) . toUpperCase ( ) + h . slice ( 0 ) ) ; normalizedHeaders [ capitalizedName ] = headers [ header ] ; } } return normalizedHeaders ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $HttpRequest$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Buffer$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ResponseHeaders$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $HttpRequest$ O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $Stream$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Stream$ O $Buffer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RequestHeaders$ O $RequestHeaders$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import * as adal from 's' ; import { 0 , Moment , utc } from 's' ; import { Clipboard , commands , env , QuickPickItem , QuickPickOptions , Uri , window } from 's' ; import * as Constants from 's' ; import { HttpRequest } from 's' ; import { ResolveErrorMessage , ResolveWarningMessage } from 's' ; import { VariableType } from 's' ; import { AadTokenCache } from 's' ; import { HttpClient } from 's' ; import { EnvironmentVariableProvider } from 's' ; import { HttpVariable , HttpVariableContext , HttpVariableProvider } from 's' ; const 0 = require ( 's' ) ; type SystemVariableValue = Pick < HttpVariable , Exclude < keyof HttpVariable , 's' > > ; type ResolveSystemVariableFunc = ( name , context ) => Promise < SystemVariableValue > ; export class SystemVariableProvider implements HttpVariableProvider { private readonly clipboard : Clipboard ; private readonly resolveFuncs : Map < string , ResolveSystemVariableFunc > = new Map < string , ResolveSystemVariableFunc > ( ) ; private readonly timestampRegex : RegExp = new RegExp ( `template` ) ; private readonly datetimeRegex : RegExp = new RegExp ( `template` ) ; private readonly randomIntegerRegex : RegExp = new RegExp ( `template` ) ; private readonly processEnvRegex : RegExp = new RegExp ( `template` ) ; private readonly requestUrlRegex : RegExp = "s" ; private readonly aadRegex : RegExp = new RegExp ( `template` ) ; private readonly innerSettingsEnvironmentVariableProvider : EnvironmentVariableProvider = EnvironmentVariableProvider . Instance ; private static _instance : SystemVariableProvider ; public static get Instance ( ) : SystemVariableProvider { if ( ! SystemVariableProvider . _instance ) { SystemVariableProvider . _instance = new SystemVariableProvider ( ) ; } return SystemVariableProvider . _instance ; } private constructor ( ) { this . clipboard = env . clipboard ; this . registerTimestampVariable ( ) ; this . registerDateTimeVariable ( ) ; this . registerGuidVariable ( ) ; this . registerRandomIntVariable ( ) ; this . registerProcessEnvVariable ( ) ; this . registerAadTokenVariable ( ) ; } public readonly type : VariableType = VariableType . System ; public async has ( name ) < boolean > { const [ variableName ] = name . split ( 's' ) . filter ( Boolean ) ; return this . resolveFuncs . has ( variableName ) ; } public async get ( name , document , context ) < HttpVariable > { const [ variableName ] = name . split ( 's' ) . filter ( Boolean ) ; if ( ! this . resolveFuncs . has ( variableName ) ) { return { name : variableName , error : ResolveErrorMessage . SystemVariableNotExist } ; } const result = await this . resolveFuncs . get ( variableName ) ! ( name , context ) ; return { name : variableName , ... result } ; } public async getAll ( document , context ) < HttpVariable [ ] > { return [ ... this . resolveFuncs . keys ( ) ] . map ( name => ( { name } ) ) ; } private registerTimestampVariable ( ) { this . resolveFuncs . set ( Constants . TimeStampVariableName , async name => { const groups = this . timestampRegex . exec ( name ) ; if ( groups !== null && groups . length === 0 ) { const [ , offset , option ] = groups ; const ts = offset && option ? utc ( ) . add ( offset , option as 0 ) . unix ( ) : utc ( ) . unix ( ) ; return { value : ts . toString ( ) } ; } return { warning : ResolveWarningMessage . IncorrectTimestampVariableFormat } ; } ) ; } private registerDateTimeVariable ( ) { this . resolveFuncs . set ( Constants . DateTimeVariableName , async name => { const groups = this . datetimeRegex . exec ( name ) ; if ( groups !== null && groups . length === 0 ) { const [ , type , offset , option ] = groups ; let date ; if ( offset && option ) { date = utc ( ) . add ( offset , option as 0 ) ; } else { date = utc ( ) ; } if ( type === 's' ) { return { value : date . toString ( ) } ; } else if ( type === 's' ) { return { value : date . toISOString ( ) } ; } else { return { value : date . format ( type . slice ( 0 , type . length - 0 ) ) } ; } } return { warning : ResolveWarningMessage . IncorrectDateTimeVariableFormat } ; } ) ; } private registerGuidVariable ( ) { this . resolveFuncs . set ( Constants . GuidVariableName , async name => ( { value : 0 ( ) } ) ) ; } private registerRandomIntVariable ( ) { this . resolveFuncs . set ( Constants . RandomIntVariableName , async name => { const groups = this . randomIntegerRegex . exec ( name ) ; if ( groups !== null && groups . length === 0 ) { const [ , min , max ] = groups ; const minNum = Number ( min ) ; const maxNum = Number ( max ) ; if ( minNum < maxNum ) { return { value : ( Math . floor ( Math . random ( ) * ( maxNum - minNum ) ) + minNum ) . toString ( ) } ; } } return { warning : ResolveWarningMessage . IncorrectRandomIntegerVariableFormat } ; } ) ; } private async resolveSettingsEnvironmentVariable ( name ) { if ( await this . innerSettingsEnvironmentVariableProvider . has ( name ) ) { const { value , error , warning } = await this . innerSettingsEnvironmentVariableProvider . get ( name ) ; if ( ! error && ! warning ) { return value ! . toString ( ) ; } else { return name ; } } else { return name ; } } private registerProcessEnvVariable ( ) { this . resolveFuncs . set ( Constants . ProcessEnvVariableName , async name => { const groups = this . processEnvRegex . exec ( name ) ; if ( groups !== null && groups . length === 0 ) { const [ , refToggle , environmentVarName ] = groups ; let processEnvName = environmentVarName ; if ( refToggle !== undefined ) { processEnvName = await this . resolveSettingsEnvironmentVariable ( environmentVarName ) ; } const envValue = process . env [ processEnvName ] ; if ( envValue !== undefined ) { return { value : envValue . toString ( ) } ; } else { return { value : 's' } ; } } return { warning : ResolveWarningMessage . IncorrectProcessEnvVariableFormat } ; } ) ; } private registerAadTokenVariable ( ) { this . resolveFuncs . set ( Constants . AzureActiveDirectoryVariableName , ( name , context ) => { const match = this . requestUrlRegex . exec ( context . parsedRequest ) ; const url = ( match && match [ 0 ] ) || context . parsedRequest ; let { cloud , targetApp } = this . getCloudProvider ( url ) ; let tenantId = Constants . AzureActiveDirectoryDefaultTenantId ; let forceNewToken = false ; const groups = this . aadRegex . exec ( name ) ; if ( groups ) { forceNewToken = groups [ 0 ] === Constants . AzureActiveDirectoryForceNewOption ; cloud = groups [ 0 ] || cloud ; tenantId = groups [ 0 ] || tenantId ; targetApp = groups [ 0 ] || targetApp ; } cloud = cloud in Constants . AzureClouds ? cloud : 's' ; const endpoint = Constants . AzureClouds [ cloud ] . aad ; const signInUrl = `template` ; const authContext = new adal . AuthenticationContext ( signInUrl ) ; const clientId = Constants . AzureActiveDirectoryClientId ; return new Promise ( ( resolve , reject ) => { const resolveToken = ( token : adal . TokenResponse , cache = true , copy ? ) => { if ( cache ) { AadTokenCache . set ( `template` , token ) ; AadTokenCache . set ( `template` , token ) ; } const tokenString = `template` ; if ( copy && tokenString ) { this . clipboard . writeText ( tokenString ) . then ( ( ) => resolve ( { value : tokenString } ) ) ; } else { resolve ( { value : tokenString } ) ; } } ; const acquireToken = ( ) => this . _acquireToken ( resolveToken , reject , authContext , cloud , tenantId , targetApp , clientId ) ; const cachedToken = ! forceNewToken && AadTokenCache . get ( `template` ) ; if ( cachedToken ) { if ( cachedToken . expiresOn <= new Date ( ) && cachedToken . refreshToken ) { authContext . acquireTokenWithRefreshToken ( cachedToken . refreshToken , clientId , targetApp , ( refreshError , refreshResponse : adal . TokenResponse ) => { if ( refreshError ) { acquireToken ( ) ; } else { resolveToken ( refreshResponse ) ; } } ) ; } else { resolveToken ( cachedToken , false ) ; } return ; } acquireToken ( ) ; } ) ; } ) ; } private getCloudProvider ( endpoint ) : { cloud : string , targetApp : string } { for ( const c in Constants . AzureClouds ) { const { aad , arm , armAudience } = Constants . AzureClouds [ c ] ; if ( aad === endpoint || arm === endpoint ) { return { cloud : c , targetApp : arm === endpoint && armAudience ? armAudience : endpoint } ; } } return { cloud : endpoint . substr ( endpoint . lastIndexOf ( 's' ) + 0 ) , targetApp : endpoint } ; } private _acquireToken ( resolve : ( value ? : adal . TokenResponse | PromiseLike < adal . TokenResponse > , cache ? , copy ? ) => void , reject : ( reason ? ) => void , authContext : adal . AuthenticationContext , cloud , tenantId , targetApp , clientId ) { const messageBoxOptions = { modal : true } ; const signInFailed = ( stage , message ) => { window . showErrorMessage ( `template` , messageBoxOptions ) ; } ; authContext . acquireUserCode ( targetApp , clientId , "s" , ( codeError , codeResponse : adal . UserCodeInfo ) => { if ( codeError ) { signInFailed ( "s" , codeError . message ) ; return reject ( codeError ) ; } const 0 = `template` ; const 0 = `template` ; const signIn = "s" ; const tryAgain = "s" ; const done = "s" ; const signInPrompt = value => { if ( value === signIn || value === tryAgain ) { this . clipboard . writeText ( codeResponse . userCode ) . then ( ( ) => { commands . executeCommand ( "s" , Uri . parse ( codeResponse . verificationUrl ) ) ; window . showInformationMessage ( 0 , messageBoxOptions , done , tryAgain ) . then ( signInPrompt ) ; } ) ; } else if ( value === done ) { authContext . acquireTokenWithDeviceCode ( targetApp , clientId , codeResponse , ( tokenError , tokenResponse : adal . TokenResponse ) => { if ( tokenError ) { signInFailed ( "s" , tokenError . message ) ; return reject ( tokenError ) ; } if ( tenantId === Constants . AzureActiveDirectoryDefaultTenantId ) { const client = new HttpClient ( ) ; const request = new HttpRequest ( "s" , `template` , { Authorization : this . _getTokenString ( tokenResponse ) } , undefined , undefined ) ; return client . send ( request ) . then ( async value => { const items = JSON . parse ( value . body ) . value ; const directories : QuickPickItem [ ] = [ ] ; items . forEach ( element => { let displayName = element . displayName ; const count = element . domains . length ; let domain = element . domains && element . domains [ 0 ] ; if ( count > 0 ) { try { const displayNameSpaceIndex = displayName . indexOf ( "s" ) ; const displayNameFirstWord = displayNameSpaceIndex > - 0 ? displayName . substring ( 0 , displayNameSpaceIndex ) : displayName ; const bestMatches : string [ ] = [ ] ; const bestMatchesRegex = new RegExp ( `template` , "s" ) ; const bestMatchesRegexGroups = bestMatchesRegex . source . match ( new RegExp ( `template` , "s" ) ) ! . length ; for ( const d of element . domains ) { const matches = bestMatchesRegex . exec ( d ) || Array ( bestMatchesRegexGroups + 0 ) . fill ( null ) ; bestMatches [ 0 ] = matches [ 0 ] ; if ( bestMatches [ 0 ] ) { break ; } for ( let g = 0 ; g < bestMatchesRegexGroups ; g ++ ) { bestMatches [ g ] = bestMatches [ g ] || matches [ g + 0 ] ; } } domain = bestMatches . find ( m => ! ! m ) || domain ; } catch { } domain = `template` ; } if ( displayName === Constants . AzureActiveDirectoryDefaultDisplayName ) { const separator = domain . indexOf ( "s" ) ; displayName = `template` ; } directories . push ( { label : displayName , description : element . tenantId , detail : domain } ) ; } ) ; let result : QuickPickItem | undefined ; if ( directories . length > 0 ) { directories . sort ( ( a , b ) => a . label + a . detail < b . label + b . detail ? - 0 : 0 ) ; const options = { matchOnDescription : true , matchOnDetail : true , placeHolder : `template` , ignoreFocusOut : true , } ; result = await window . showQuickPick ( directories , options ) ; } else { result = directories [ 0 ] ; } if ( result ) { const newDirAuthContext = new adal . AuthenticationContext ( `template` ) ; newDirAuthContext . acquireTokenWithRefreshToken ( tokenResponse . refreshToken ! , clientId , null ! , ( newDirError , newDirResponse : adal . TokenResponse ) => { resolve ( newDirError ? tokenResponse : newDirResponse , true , true ) ; } ) ; } else { return resolve ( tokenResponse , true , true ) ; } } ) ; } return resolve ( tokenResponse , true , true ) ; } ) ; } } ; window . showInformationMessage ( 0 , messageBoxOptions , signIn ) . then ( signInPrompt ) ; } ) ; } private _getTokenString ( token : adal . TokenResponse ) { return token ? `template` : 's' ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $HttpVariableContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $undefined$ O $HttpVariableContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $undefined$ O $HttpVariableContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Moment$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O $boolean$ O O O O O O O O $any$ O O O O O O O O O O $string$ O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $QuickPickOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { TextDocument } from 's' ; import { VariableType } from "s" ; import { EnvironmentVariableProvider } from 's' ; import { FileVariableProvider } from 's' ; import { HttpVariableProvider } from 's' ; import { RequestVariableProvider } from 's' ; import { SystemVariableProvider } from 's' ; import { getCurrentTextDocument } from 's' ; export class VariableProcessor { private static readonly providers : [ HttpVariableProvider , boolean ] [ ] = [ [ SystemVariableProvider . Instance , false ] , [ RequestVariableProvider . Instance , true ] , [ FileVariableProvider . Instance , true ] , [ EnvironmentVariableProvider . Instance , true ] , ] ; public static async processRawRequest ( request ) { const variableReferenceRegex = "s" ; let result = 's' ; let match : RegExpExecArray | null ; let lastIndex = 0 ; const resolvedVariables = new Map < string , string > ( ) ; variable : while ( match = variableReferenceRegex . exec ( request ) ) { result += request . substring ( lastIndex , match . index ) ; lastIndex = variableReferenceRegex . lastIndex ; const name = match [ 0 ] . trim ( ) ; const document = getCurrentTextDocument ( ) ; const context = { rawRequest : request , parsedRequest : result } ; for ( const [ provider , cacheable ] of VariableProcessor . providers ) { if ( resolvedVariables . has ( name ) ) { result += resolvedVariables . get ( name ) ; continue variable ; } if ( await provider . has ( name , document , context ) ) { const { value , error , warning } = await provider . get ( name , document , context ) ; if ( ! error && ! warning ) { if ( cacheable ) { resolvedVariables . set ( name , value as string ) ; } result += value ; continue variable ; } else { break ; } } } result += `template` ; } result += request . substring ( lastIndex ) ; return result ; } public static async getAllVariablesDefinitions ( document ) < Map < string , VariableType [ ] > > { const [ , [ requestProvider ] , [ fileProvider ] , [ environmentProvider ] ] = VariableProcessor . providers ; const requestVariables = await ( requestProvider as RequestVariableProvider ) . getAll ( document ) ; const fileVariables = await ( fileProvider as FileVariableProvider ) . getAll ( document ) ; const environmentVariables = await ( environmentProvider as EnvironmentVariableProvider ) . getAll ( ) ; const variableDefinitions = new Map < string , VariableType [ ] > ( ) ; requestVariables . forEach ( ( { name } ) => { if ( variableDefinitions . has ( name ) ) { variableDefinitions . get ( name ) ! . push ( VariableType . Request ) ; } else { variableDefinitions . set ( name , [ VariableType . Request ] ) ; } } ) ; fileVariables . forEach ( ( { name } ) => { if ( variableDefinitions . has ( name ) ) { variableDefinitions . get ( name ) ! . push ( VariableType . File ) ; } else { variableDefinitions . set ( name , [ VariableType . File ] ) ; } } ) ; environmentVariables . forEach ( ( { name } ) => { if ( variableDefinitions . has ( name ) ) { variableDefinitions . get ( name ) ! . push ( VariableType . Environment ) ; } else { variableDefinitions . set ( name , [ VariableType . Environment ] ) ; } } ) ; return variableDefinitions ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Disposable } from "s" ; export function disposeAll ( disposables : Disposable [ ] ) { while ( disposables . length ) { const item = disposables . pop ( ) ; if ( item ) { item . dispose ( ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import * as path from 's' ; import { Event , EventEmitter , extensions , Uri , WebviewPanel } from 's' ; import * as Constants from 's' ; import { RestClientSettings } from 's' ; export abstract class BaseWebview { protected _onDidCloseAllWebviewPanels = new EventEmitter < void > ( ) ; protected readonly settings : RestClientSettings = RestClientSettings . Instance ; protected readonly extensionPath : string ; protected readonly styleFolderPath : Uri ; protected readonly styleFilePath : Uri ; protected readonly scriptFolderPath : Uri ; protected readonly scriptFilePath : Uri ; protected panels : WebviewPanel [ ] ; protected constructor ( ) { this . extensionPath = extensions . getExtension ( Constants . ExtensionId ) ! . extensionPath ; this . panels = [ ] ; this . styleFilePath = Uri . file ( path . join ( this . extensionPath , Constants . CSSFolderName , Constants . CSSFileName ) ) ; this . styleFolderPath = Uri . file ( path . join ( this . extensionPath , Constants . CSSFolderName ) ) ; this . scriptFilePath = Uri . file ( path . join ( this . extensionPath , Constants . ScriptsFolderName , Constants . ScriptFileName ) ) ; this . scriptFolderPath = Uri . file ( path . join ( this . extensionPath , Constants . ScriptsFolderName ) ) ; } public get onDidCloseAllWebviewPanels ( ) : Event < void > { return this . _onDidCloseAllWebviewPanels . event ; } protected abstract get viewType ( ) : string ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { commands , ViewColumn , WebviewPanel , window } from 's' ; import { disposeAll } from 's' ; import { BaseWebview } from 's' ; const hljs = require ( 's' ) ; const codeHighlightLinenums = require ( 's' ) ; export class CodeSnippetWebview extends BaseWebview { private readonly codeSnippetPreviewActiveContextKey = 's' ; protected get viewType ( ) : string { return 's' ; } public constructor ( ) { super ( ) ; } public async render ( convertResult , title , lang ) { let panel ; if ( this . panels . length === 0 ) { panel = window . createWebviewPanel ( this . viewType , title , ViewColumn . Two , { enableFindWidget : true , retainContextWhenHidden : true , localResourceRoots : [ this . styleFolderPath ] } ) ; panel . onDidDispose ( ( ) => { commands . executeCommand ( 's' , this . codeSnippetPreviewActiveContextKey , false ) ; this . panels . pop ( ) ; this . _onDidCloseAllWebviewPanels . fire ( ) ; } ) ; panel . onDidChangeViewState ( ( { webviewPanel } ) => { commands . executeCommand ( 's' , this . codeSnippetPreviewActiveContextKey , webviewPanel . visible ) ; } ) ; this . panels . push ( panel ) ; } else { panel = this . panels [ 0 ] ; panel . title = title ; } panel . webview . html = this . getHtmlForWebview ( panel , convertResult , lang ) ; commands . executeCommand ( 's' , this . codeSnippetPreviewActiveContextKey , true ) ; panel . reveal ( ViewColumn . Two ) ; } public dispose ( ) { disposeAll ( this . panels ) ; } private getHtmlForWebview ( panel , convertResult , lang ) { const csp = this . getCsp ( ) ; return `template` ; } private getHighlightJsLanguageAlias ( lang ) { if ( ! lang || lang === 's' ) { return 's' ; } if ( lang === 's' ) { return 's' ; } return lang ; } private getCsp ( ) { return `template` ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O $WebviewPanel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $WebviewPanel$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O
"s" ; import { EOL } from 's' ; import * as url from 's' ; import { Clipboard , env , QuickInputButtons , QuickPickItem , window } from 's' ; import { ArrayUtility } from "s" ; import * as Constants from 's' ; import { HARCookie , HARHeader , HARHttpRequest , HARPostData } from 's' ; import { HttpRequest } from 's' ; import { RequestParserFactory } from 's' ; import { trace } from "s" ; import { Selector } from 's' ; import { Telemetry } from 's' ; import { VariableProcessor } from 's' ; import { getCurrentTextDocument } from 's' ; import { CodeSnippetWebview } from 's' ; const encodeUrl = require ( 's' ) ; const HTTPSnippet = require ( 's' ) ; interface CodeSnippetTargetQuickPickItem extends QuickPickItem { target : { key : string ; title : string ; clients : [ { title : string ; link : string , description : string } ] } ; } interface CodeSnippetClientQuickPickItem extends CodeSnippetTargetQuickPickItem { client : { key : string ; title : string ; } ; } export class CodeSnippetController { private static _availableTargets = HTTPSnippet . availableTargets ( ) ; private readonly clipboard : Clipboard ; private _convertedResult ; private _webview : CodeSnippetWebview ; constructor ( ) { this . _webview = new CodeSnippetWebview ( ) ; this . clipboard = env . clipboard ; } public async run ( ) { const editor = window . activeTextEditor ; const document = getCurrentTextDocument ( ) ; if ( ! editor || ! document ) { return ; } let selectedText = Selector . getRequestText ( editor ) ; if ( ! selectedText ) { return ; } const lines : string [ ] = selectedText . split ( Constants . LineSplitterRegex ) . filter ( l => ! Constants . CommentIdentifiersRegex . test ( l ) ) ; if ( lines . length === 0 || lines . every ( line => line === 's' ) ) { return ; } selectedText = ArrayUtility . skipWhile ( lines , l => Constants . FileVariableDefinitionRegex . test ( l ) || l . trim ( ) === 's' ) . join ( EOL ) ; selectedText = await VariableProcessor . processRawRequest ( selectedText ) ; const httpRequest = new RequestParserFactory ( ) . createRequestParser ( selectedText ) . parseHttpRequest ( selectedText , document . fileName ) ; if ( ! httpRequest ) { return ; } const harHttpRequest = this . convertToHARHttpRequest ( httpRequest ) ; const snippet = new HTTPSnippet ( harHttpRequest ) ; if ( CodeSnippetController . _availableTargets ) { const quickPick = window . createQuickPick ( ) ; const targetQuickPickItems : CodeSnippetTargetQuickPickItem [ ] = CodeSnippetController . _availableTargets . map ( target => ( { label : target . title , target } ) ) ; quickPick . title = 's' ; quickPick . step = 0 ; quickPick . totalSteps = 0 ; quickPick . items = targetQuickPickItems ; quickPick . matchOnDescription = true ; quickPick . matchOnDetail = true ; quickPick . onDidHide ( ( ) => quickPick . dispose ( ) ) ; quickPick . onDidTriggerButton ( ( ) => { quickPick . step ! -- ; quickPick . buttons = [ ] ; quickPick . items = targetQuickPickItems ; } ) ; quickPick . onDidAccept ( ( ) => { const selectedItem = quickPick . selectedItems [ 0 ] ; if ( selectedItem ) { if ( quickPick . step === 0 ) { quickPick . step ++ ; quickPick . buttons = [ QuickInputButtons . Back ] ; const targetItem = selectedItem as CodeSnippetTargetQuickPickItem ; quickPick . items = targetItem . target . clients . map ( client => ( { label : client . title , description : client . description , detail : client . link , target : targetItem . target , client } ) ) ; } else if ( quickPick . step === 0 ) { const { target : { key : tk , title : tt } , client : { key : ck , title : ct } } = ( selectedItem as CodeSnippetClientQuickPickItem ) ; Telemetry . sendEvent ( 's' , { 's' : tk , 's' : ck } ) ; const result = snippet . convert ( tk , ck ) ; this . _convertedResult = result ; try { this . _webview . render ( result , `template` , tk ) ; } catch ( reason ) { window . showErrorMessage ( reason ) ; } } } } ) ; quickPick . show ( ) ; } else { window . showInformationMessage ( 's' ) ; } } @ trace ( 's' ) public async copy ( ) { if ( this . _convertedResult ) { await this . clipboard . writeText ( this . _convertedResult ) ; } } @ trace ( 's' ) public async copyAsCurl ( ) { const editor = window . activeTextEditor ; const document = getCurrentTextDocument ( ) ; if ( ! editor || ! document ) { return ; } let selectedText = Selector . getRequestText ( editor ) ; if ( ! selectedText ) { return ; } const lines : string [ ] = selectedText . split ( Constants . LineSplitterRegex ) . filter ( l => ! Constants . CommentIdentifiersRegex . test ( l ) ) ; if ( lines . length === 0 || lines . every ( line => line === 's' ) ) { return ; } selectedText = ArrayUtility . skipWhile ( lines , l => Constants . FileVariableDefinitionRegex . test ( l ) || l . trim ( ) === 's' ) . join ( EOL ) ; selectedText = await VariableProcessor . processRawRequest ( selectedText ) ; const httpRequest = new RequestParserFactory ( ) . createRequestParser ( selectedText ) . parseHttpRequest ( selectedText , document . fileName ) ; if ( ! httpRequest ) { return ; } const harHttpRequest = this . convertToHARHttpRequest ( httpRequest ) ; const addPrefix = ! ( url . parse ( harHttpRequest . url ) . protocol ) ; const originalUrl = harHttpRequest . url ; if ( addPrefix ) { harHttpRequest . url = `template` ; } const snippet = new HTTPSnippet ( harHttpRequest ) ; if ( addPrefix ) { snippet . requests [ 0 ] . fullUrl = originalUrl ; } const result = snippet . convert ( 's' , 's' , process . platform === 's' ? { indent : false } : { } ) ; await this . clipboard . writeText ( result ) ; } private convertToHARHttpRequest ( request ) { const headers : HARHeader [ ] = [ ] ; for ( const key in request . headers ) { const headerValue = request . headers [ key ] ; if ( ! headerValue ) { continue ; } const headerValues = Array . isArray ( headerValue ) ? headerValue : [ headerValue . toString ( ) ] ; for ( let value of headerValues ) { if ( key . toLowerCase ( ) === 's' ) { value = CodeSnippetController . normalizeAuthHeader ( value ) ; } headers . push ( new HARHeader ( key , value ) ) ; } } const cookies : HARCookie [ ] = [ ] ; const cookieHeader = headers . find ( header => header . name . toLowerCase ( ) === 's' ) ; if ( cookieHeader ) { cookieHeader . value . split ( 's' ) . forEach ( pair => { const [ headerName , headerValue = 's' ] = pair . split ( 's' , 0 ) ; cookies . push ( new HARCookie ( headerName . trim ( ) , headerValue . trim ( ) ) ) ; } ) ; } let body : HARPostData | undefined ; if ( request . body ) { const contentTypeHeader = headers . find ( header => header . name . toLowerCase ( ) === 's' ) ; const mimeType = ( contentTypeHeader && contentTypeHeader . value ) || 's' ; if ( typeof request . body === 's' ) { const normalizedBody = request . body . split ( EOL ) . reduce ( ( prev , cur ) => prev . concat ( cur . trim ( ) ) , 's' ) ; body = new HARPostData ( mimeType , normalizedBody ) ; } else { body = new HARPostData ( mimeType , request . rawBody ! ) ; } } return new HARHttpRequest ( request . method , encodeUrl ( request . url ) , headers , cookies , body ) ; } public dispose ( ) { this . _webview . dispose ( ) ; } private static normalizeAuthHeader ( authHeader ) { if ( authHeader ) { const start = authHeader . indexOf ( 's' ) ; const scheme = authHeader . substr ( 0 , start ) ; if ( scheme && scheme . toLowerCase ( ) === 's' ) { const params = authHeader . substr ( start ) . trim ( ) . split ( 's' ) ; if ( params . length === 0 ) { return 's' + Buffer . from ( `template` ) . toString ( 's' ) ; } } } return authHeader ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HARHttpRequest$ O $HttpRequest$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { OutputChannel , window } from 's' ; import { RestClientSettings } from 's' ; import { LogLevel } from 's' ; let outputChannel ; function getOrCreateOutputChannel ( ) { if ( ! outputChannel ) { outputChannel = window . createOutputChannel ( 's' ) ; } return outputChannel ; } export class Logger { private readonly _outputChannel : OutputChannel ; private readonly _restClientSettings : RestClientSettings = RestClientSettings . Instance ; public constructor ( ) { this . _outputChannel = getOrCreateOutputChannel ( ) ; } public verbose ( message , data ? ) { this . log ( LogLevel . Verbose , message , data ) ; } public info ( message , data ? ) { this . log ( LogLevel . Info , message , data ) ; } public warn ( message , data ? ) { this . log ( LogLevel . Warn , message , data ) ; } public error ( message , data ? ) { this . log ( LogLevel . Error , message , data ) ; } public log ( level , message , data ? ) { if ( level >= this . _restClientSettings . logLevel ) { this . _outputChannel . appendLine ( `template` ) ; if ( data ) { this . _outputChannel . appendLine ( this . 0 ( data ) ) ; } } } private 0 ( data ) { if ( data instanceof Error ) { return data . stack || data . message ; } if ( typeof data === 's' ) { return data ; } return JSON . stringify ( data , null , 0 ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O $OutputChannel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O $any$ O O O O O O O O O O O O O O O O O $void$ O $string$ O O $any$ O O O O O O O O O O O O O O O O O $void$ O $string$ O O $any$ O O O O O O O O O O O O O O O O O $void$ O $string$ O O $any$ O O O O O O O O O O O O O O O O O $void$ O $LogLevel$ O $string$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import { QuickPickItem } from 's' ; import { SerializedHttpRequest } from 's' ; export class HistoryQuickPickItem implements QuickPickItem { public label : string ; public description : string ; public detail : string ; public rawRequest : SerializedHttpRequest ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import * as fs from 's' ; import moment from 's' ; import { EOL } from 's' ; import { window , workspace } from 's' ; import { Logger } from 's' ; import { HistoryQuickPickItem } from 's' ; import { SerializedHttpRequest } from 's' ; import { trace } from "s" ; import { PersistUtility } from 's' ; const tmp = require ( 's' ) ; export class HistoryController { public constructor ( private readonly logger ) { } @ trace ( 's' ) public async save ( ) { try { const requests = await PersistUtility . loadRequests ( ) ; if ( ! requests || requests . length <= 0 ) { window . showInformationMessage ( "s" ) ; return ; } const itemPickList : HistoryQuickPickItem [ ] = requests . map ( request => { const item = new HistoryQuickPickItem ( ) ; item . label = `template` ; if ( request . body && typeof request . body === 's' && request . body . length > 0 ) { item . description = `template` ; } if ( request . startTime ) { item . detail = `template` ; } item . rawRequest = request ; return item ; } ) ; const item = await window . showQuickPick ( itemPickList , { placeHolder : "s" } ) ; if ( ! item ) { return ; } const path = await this . createRequestInTempFile ( item . rawRequest ) ; const document = await workspace . openTextDocument ( path ) ; window . showTextDocument ( document ) ; } catch ( error ) { this . errorHandler ( error , 's' ) ; } } @ trace ( 's' ) public async clear ( ) { try { window . showInformationMessage ( `template` , { title : 's' } , { title : 's' } ) . then ( async function ( btn ) { if ( btn ) { if ( btn . title === 's' ) { await PersistUtility . clearRequests ( ) ; window . showInformationMessage ( 's' ) ; } } } ) ; } catch ( error ) { this . errorHandler ( error , 's' ) ; } } private async createRequestInTempFile ( request ) < string > { return new Promise < string > ( ( resolve , reject ) => { tmp . file ( { prefix : 's' , postfix : "s" } , function _tempFileCreated ( err , tmpFilePath , fd ) { if ( err ) { reject ( err ) ; return ; } let output = `template` ; if ( request . headers ) { for ( const header in request . headers ) { if ( request . headers . hasOwnProperty ( header ) ) { const value = request . headers [ header ] ; output += `template` ; } } } if ( request . body ) { output += `template` ; } fs . writeFile ( tmpFilePath , output , error => { reject ( error ) ; return ; } ) ; resolve ( tmpFilePath ) ; } ) ; } ) ; } private errorHandler ( error , message ) { this . logger . error ( message , error ) ; window . showErrorMessage ( "s" ) ; } public dispose ( ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Logger$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $SerializedHttpRequest$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import { HttpRequest } from 's' ; export class RequestStore { private readonly cache : Map < string , HttpRequest > = new Map < string , HttpRequest > ( ) ; private readonly cancelledRequestIds : Set < string > = new Set < string > ( ) ; private readonly completedRequestIds : Set < string > = new Set < string > ( ) ; private currentRequestId : string ; private static _instance : RequestStore ; public static get Instance ( ) : RequestStore { if ( ! RequestStore . _instance ) { RequestStore . _instance = new RequestStore ( ) ; } return RequestStore . _instance ; } private constructor ( ) { } public add ( requestId , request ) { if ( request && requestId ) { this . cache . set ( requestId , request ) ; this . currentRequestId = requestId ; } } public getLatest ( ) : HttpRequest | undefined { return this . cache . get ( this . currentRequestId ) ; } public cancel ( requestId ? ) { requestId = requestId || this . currentRequestId ; this . cancelledRequestIds . add ( requestId ) ; } public isCancelled ( requestId ) { return this . cancelledRequestIds . has ( requestId ) ; } public complete ( requestId ) { return requestId && this . completedRequestIds . add ( requestId ) ; } public isCompleted ( requestId ? ) { requestId = requestId || this . currentRequestId ; return this . completedRequestIds . has ( requestId ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $HttpRequest$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O
's' ; import { createScanner , SyntaxKind } from 's' ; import * as os from 's' ; import { window } from 's' ; import { MimeUtility } from 's' ; import { isJSONString } from 's' ; const pd = require ( 's' ) . pd ; export class ResponseFormatUtility { private static readonly jsonSpecialTokenMapping = { [ SyntaxKind . OpenBraceToken ] : 's' , [ SyntaxKind . CloseBraceToken ] : 's' , [ SyntaxKind . OpenBracketToken ] : 's' , [ SyntaxKind . CloseBracketToken ] : 's' , [ SyntaxKind . ColonToken ] : 's' , [ SyntaxKind . CommaToken ] : 's' , [ SyntaxKind . NullKeyword ] : 's' , [ SyntaxKind . TrueKeyword ] : 's' , [ SyntaxKind . FalseKeyword ] : 's' } ; public static formatBody ( body , contentType : string | undefined , suppressValidation ) { if ( contentType ) { if ( MimeUtility . isJSON ( contentType ) ) { if ( isJSONString ( body ) ) { body = ResponseFormatUtility . jsonPrettify ( body ) ; } else if ( ! suppressValidation ) { window . showWarningMessage ( 's' ) ; } } else if ( MimeUtility . isXml ( contentType ) ) { body = pd . xml ( body ) ; } else if ( MimeUtility . isCSS ( contentType ) ) { body = pd . css ( body ) ; } else { if ( isJSONString ( body ) ) { body = ResponseFormatUtility . jsonPrettify ( body ) ; } } } return body ; } private static jsonPrettify ( text , indentSize = 0 ) { const scanner = createScanner ( text , true ) ; let indentLevel = 0 ; function newLineAndIndent ( ) { return os . EOL + 's' . repeat ( indentLevel * indentSize ) ; } function scanNext ( ) : [ SyntaxKind , string ] { const token = scanner . scan ( ) ; const offset = scanner . getTokenOffset ( ) ; const length = scanner . getTokenLength ( ) ; const value = text . substr ( offset , length ) ; return [ token , value ] ; } let [ firstToken , firstTokenValue ] = scanNext ( ) ; let secondToken ; let secondTokenValue ; let result = 's' ; while ( firstToken !== SyntaxKind . EOF ) { [ secondToken , secondTokenValue ] = scanNext ( ) ; switch ( firstToken ) { case SyntaxKind . OpenBraceToken : result += ResponseFormatUtility . jsonSpecialTokenMapping [ firstToken ] ; if ( secondToken !== SyntaxKind . CloseBraceToken ) { indentLevel ++ ; result += newLineAndIndent ( ) ; } break ; case SyntaxKind . OpenBracketToken : result += ResponseFormatUtility . jsonSpecialTokenMapping [ firstToken ] ; if ( secondToken !== SyntaxKind . CloseBracketToken ) { indentLevel ++ ; result += newLineAndIndent ( ) ; } break ; case SyntaxKind . CloseBraceToken : case SyntaxKind . CloseBracketToken : case SyntaxKind . NullKeyword : case SyntaxKind . TrueKeyword : case SyntaxKind . FalseKeyword : result += ResponseFormatUtility . jsonSpecialTokenMapping [ firstToken ] ; if ( secondToken === SyntaxKind . CloseBraceToken || secondToken === SyntaxKind . CloseBracketToken ) { indentLevel -- ; result += newLineAndIndent ( ) ; } break ; case SyntaxKind . CommaToken : result += ResponseFormatUtility . jsonSpecialTokenMapping [ firstToken ] ; if ( secondToken === SyntaxKind . CloseBraceToken || secondToken === SyntaxKind . CloseBracketToken ) { indentLevel -- ; } result += newLineAndIndent ( ) ; break ; case SyntaxKind . ColonToken : result += ResponseFormatUtility . jsonSpecialTokenMapping [ firstToken ] + 's' ; break ; case SyntaxKind . StringLiteral : case SyntaxKind . NumericLiteral : case SyntaxKind . Unknown : result += firstTokenValue ; if ( secondToken === SyntaxKind . CloseBraceToken || secondToken === SyntaxKind . CloseBracketToken ) { indentLevel -- ; result += newLineAndIndent ( ) ; } break ; default : result += firstTokenValue ; } firstToken = secondToken ; firstTokenValue = secondTokenValue ; } return result ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SyntaxKind$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { EOL } from 's' ; import { languages , Position , Range , TextDocument , ViewColumn , window , workspace } from 's' ; import { RequestHeaders , ResponseHeaders } from 's' ; import { RestClientSettings } from 's' ; import { HttpResponse } from 's' ; import { PreviewOption } from 's' ; import { MimeUtility } from 's' ; import { ResponseFormatUtility } from 's' ; export class HttpResponseTextDocumentView { private readonly settings : RestClientSettings = RestClientSettings . Instance ; protected readonly documents : TextDocument [ ] = [ ] ; public constructor ( ) { workspace . onDidCloseTextDocument ( e => { const index = this . documents . indexOf ( e ) ; if ( index !== - 0 ) { this . documents . splice ( index , 0 ) ; } } ) ; } public async render ( response , column ? ) { const content = this . getTextDocumentContent ( response ) ; const language = this . getVSCodeDocumentLanguageId ( response ) ; let document ; if ( this . settings . showResponseInDifferentTab || this . documents . length === 0 ) { document = await workspace . openTextDocument ( { language , content } ) ; this . documents . push ( document ) ; await window . showTextDocument ( document , { viewColumn : column , preserveFocus : ! this . settings . previewResponsePanelTakeFocus , preview : false } ) ; } else { document = this . documents [ this . documents . length - 0 ] ; languages . setTextDocumentLanguage ( document , language ) ; const editor = await window . showTextDocument ( document , { viewColumn : column , preserveFocus : ! this . settings . previewResponsePanelTakeFocus , preview : false } ) ; editor . edit ( edit => { const startPosition = new Position ( 0 , 0 ) ; const endPosition = document . lineAt ( document . lineCount - 0 ) . range . end ; edit . replace ( new Range ( startPosition , endPosition ) , content ) ; } ) ; } } private getTextDocumentContent ( response ) { let content = 's' ; const previewOption = this . settings . previewOption ; if ( previewOption === PreviewOption . Exchange ) { const request = response . request ; content += `template` ; content += this . formatHeaders ( request . headers ) ; if ( request . body ) { if ( typeof request . body !== 's' ) { request . body = 's' ; } content += `template` ; } content += EOL . repeat ( 0 ) ; } if ( previewOption !== PreviewOption . Body ) { content += `template` ; content += this . formatHeaders ( response . headers ) ; } if ( previewOption !== PreviewOption . Headers ) { const prefix = previewOption === PreviewOption . Body ? 's' : EOL ; content += `template` ; } return content ; } private formatHeaders ( headers : RequestHeaders | ResponseHeaders ) { let headerString = 's' ; for ( const header in headers ) { const value = headers [ header ] as string ; headerString += `template` ; } return headerString ; } private getVSCodeDocumentLanguageId ( response ) { if ( this . settings . previewOption === PreviewOption . Body ) { const contentType = response . contentType ; if ( MimeUtility . isJSON ( contentType ) ) { return 's' ; } else if ( MimeUtility . isJavaScript ( contentType ) ) { return 's' ; } else if ( MimeUtility . isXml ( contentType ) ) { return 's' ; } else if ( MimeUtility . isHtml ( contentType ) ) { return 's' ; } else if ( MimeUtility . isCSS ( contentType ) ) { return 's' ; } } return 's' ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpResponse$ O O $ViewColumn$ O O O O O O O O O O O O O O O O O O O O O O O $TextDocument$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $HttpResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import * as path from 's' ; import { commands , ExtensionContext , Uri , ViewColumn , WebviewPanel , window } from 's' ; import * as Constants from 's' ; import { RequestHeaders , ResponseHeaders } from 's' ; import { HttpRequest } from 's' ; import { HttpResponse } from 's' ; import { PreviewOption } from 's' ; import { trace } from 's' ; import { disposeAll } from 's' ; import { MimeUtility } from 's' ; import { isJSONString } from 's' ; import { ResponseFormatUtility } from 's' ; import { BaseWebview } from 's' ; const hljs = require ( 's' ) ; export class HttpResponseWebview extends BaseWebview { private readonly urlRegex = "s" ; private readonly httpResponsePreviewActiveContextKey = 's' ; private readonly panelResponses : Map < WebviewPanel , HttpResponse > ; private readonly iconFilePath : Uri ; protected get viewType ( ) : string { return 's' ; } private activePanel : WebviewPanel | undefined ; public static activePreviewResponse : HttpResponse | undefined ; public constructor ( private readonly context ) { super ( ) ; this . panelResponses = new Map < WebviewPanel , HttpResponse > ( ) ; this . iconFilePath = Uri . file ( path . join ( this . extensionPath , Constants . ImagesFolderName , Constants . IconFileName ) ) ; this . context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => this . foldResponseBody ( ) ) ) ; this . context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => this . unfoldResponseBody ( ) ) ) ; } public async render ( response , column ) { const tabTitle = this . settings . requestNameAsResponseTabTitle && response . request . requestVariableCacheKey && response . request . requestVariableCacheKey . key || 's' ; let panel ; if ( this . settings . showResponseInDifferentTab || this . panels . length === 0 ) { panel = window . createWebviewPanel ( this . viewType , `template` , { viewColumn : column , preserveFocus : ! this . settings . previewResponsePanelTakeFocus } , { enableFindWidget : true , enableScripts : true , retainContextWhenHidden : true , localResourceRoots : [ this . styleFolderPath , this . scriptFolderPath ] } ) ; panel . onDidDispose ( ( ) => { const response = this . panelResponses . get ( panel ) ; if ( response === HttpResponseWebview . activePreviewResponse ) { commands . executeCommand ( 's' , this . httpResponsePreviewActiveContextKey , false ) ; this . activePanel = undefined ; HttpResponseWebview . activePreviewResponse = undefined ; } const index = this . panels . findIndex ( v => v === panel ) ; if ( index !== - 0 ) { this . panels . splice ( index , 0 ) ; this . panelResponses . delete ( panel ) ; } if ( this . panels . length === 0 ) { this . _onDidCloseAllWebviewPanels . fire ( ) ; } } ) ; panel . iconPath = this . iconFilePath ; panel . onDidChangeViewState ( ( { webviewPanel } ) => { commands . executeCommand ( 's' , this . httpResponsePreviewActiveContextKey , webviewPanel . active ) ; this . activePanel = webviewPanel . active ? webviewPanel : undefined ; HttpResponseWebview . activePreviewResponse = webviewPanel . active ? this . panelResponses . get ( webviewPanel ) : undefined ; } ) ; this . panels . push ( panel ) ; } else { panel = this . panels [ this . panels . length - 0 ] ; panel . title = `template` ; } panel . webview . html = this . getHtmlForWebview ( panel , response ) ; commands . executeCommand ( 's' , this . httpResponsePreviewActiveContextKey , this . settings . previewResponsePanelTakeFocus ) ; panel . reveal ( column , ! this . settings . previewResponsePanelTakeFocus ) ; this . panelResponses . set ( panel , response ) ; this . activePanel = panel ; HttpResponseWebview . activePreviewResponse = response ; } public dispose ( ) { disposeAll ( this . panels ) ; } @ trace ( 's' ) private foldResponseBody ( ) { if ( this . activePanel ) { this . activePanel . webview . postMessage ( { 's' : 's' } ) ; } } @ trace ( 's' ) private unfoldResponseBody ( ) { if ( this . activePanel ) { this . activePanel . webview . postMessage ( { 's' : 's' } ) ; } } private getHtmlForWebview ( panel , response ) { let innerHtml ; let width = 0 ; let contentType = response . contentType ; if ( contentType ) { contentType = contentType . trim ( ) ; } if ( contentType && MimeUtility . isBrowserSupportedImageFormat ( contentType ) && ! HttpResponseWebview . isHeadRequest ( response ) ) { innerHtml = `template` ; } else { const code = this . highlightResponse ( response ) ; width = ( code . split ( "s" ) . length + 0 ) . toString ( ) . length ; innerHtml = `template` ; } const nonce = new Date ( ) . getTime ( ) + 's' + new Date ( ) . getMilliseconds ( ) ; const csp = this . getCsp ( nonce ) ; return `template` ; } private highlightResponse ( response ) { let code = 's' ; const previewOption = this . settings . previewOption ; if ( previewOption === PreviewOption . Exchange ) { const request = response . request ; const requestNonBodyPart = `template` ; code += hljs . highlight ( 's' , requestNonBodyPart + 's' ) . value ; if ( request . body ) { if ( typeof request . body !== 's' ) { request . body = 's' ; } const requestBodyPart = `template` ; const bodyLanguageAlias = HttpResponseWebview . getHighlightLanguageAlias ( request . contentType , request . body ) ; if ( bodyLanguageAlias ) { code += hljs . highlight ( bodyLanguageAlias , requestBodyPart ) . value ; } else { code += hljs . highlightAuto ( requestBodyPart ) . value ; } code += 's' ; } code += 's' . repeat ( 0 ) ; } if ( previewOption !== PreviewOption . Body ) { const responseNonBodyPart = `template` ; code += hljs . highlight ( 's' , responseNonBodyPart + ( previewOption !== PreviewOption . Headers ? 's' : 's' ) ) . value ; } if ( previewOption !== PreviewOption . Headers ) { const responseBodyPart = `template` ; if ( this . settings . disableHighlightResonseBodyForLargeResponse && response . bodySizeInBytes > this . settings . largeResponseBodySizeLimitInMB * 0 * 0 ) { code += responseBodyPart ; } else { const bodyLanguageAlias = HttpResponseWebview . getHighlightLanguageAlias ( response . contentType , responseBodyPart ) ; if ( bodyLanguageAlias ) { code += hljs . highlight ( bodyLanguageAlias , responseBodyPart ) . value ; } else { code += hljs . highlightAuto ( responseBodyPart ) . value ; } } } return code ; } private getSettingsOverrideStyles ( width ) { return [ 's' , ( this . settings . fontFamily || this . settings . fontSize || this . settings . fontWeight ? [ 's' , this . settings . fontFamily ? `template` : 's' , this . settings . fontSize ? `template` : 's' , this . settings . fontWeight ? `template` : 's' , 's' , ] : [ ] ) . join ( 's' ) , 's' , `template` , 's' , 's' , `template` , `template` , 's' , 's' , `template` , 's' , 's' , `template` , 's' , 's' ] . join ( 's' ) ; } private getCsp ( nonce ) { return `template` ; } private addLineNums ( code ) { code = code . replace ( "s" , 's' ) ; code = this . cleanLineBreaks ( code ) ; code = code . split ( "s" ) ; const max = ( 0 + code . length ) . toString ( ) . length ; const foldingRanges = this . getFoldingRange ( code ) ; code = code . map ( function ( line , i ) { const lineNum = i + 0 ; const range = foldingRanges . has ( lineNum ) ? `template` : 's' ; const folding = foldingRanges . has ( lineNum ) ? 's' : 's' ; return `template` ; } ) . join ( 's' ) ; return code ; } private cleanLineBreaks ( code ) { const openSpans : string [ ] = [ ] , matcher = "s" , newline = "s" , closingTag = "s" ; return code . replace ( matcher , function ( match ) { if ( newline . test ( match ) ) { if ( openSpans . length ) { return openSpans . map ( ( ) => 's' ) . join ( 's' ) + match + openSpans . join ( 's' ) ; } else { return match ; } } else if ( closingTag . test ( match ) ) { openSpans . pop ( ) ; return match ; } else { openSpans . push ( match ) ; return match ; } } ) ; } private addUrlLinks ( innerHtml ) { return innerHtml . replace ( this . urlRegex , 's' ) ; } private getFoldingRange ( lines : string [ ] ) < number , FoldingRange > { const result = new Map < number , FoldingRange > ( ) ; const stack : [ number , number ] [ ] = [ ] ; const leadingSpaceCount = lines . map ( ( line , index ) => [ index , line . search ( "s" ) ] ) . filter ( ( [ , num ] ) => num !== - 0 ) ; for ( const [ index , [ lineIndex , count ] ] of leadingSpaceCount . entries ( ) ) { if ( index === 0 ) { continue ; } const [ prevLineIndex , prevCount ] = leadingSpaceCount [ index - 0 ] ; if ( prevCount < count ) { stack . push ( [ prevLineIndex , prevCount ] ) ; } else if ( prevCount > count ) { let prev ; while ( ( prev = stack . slice ( - 0 ) [ 0 ] ) && ( prev [ 0 ] >= count ) ) { stack . pop ( ) ; result . set ( prev [ 0 ] + 0 , new FoldingRange ( prev [ 0 ] + 0 , lineIndex ) ) ; } } } return result ; } private static formatHeaders ( headers : RequestHeaders | ResponseHeaders ) { let headerString = 's' ; for ( const header in headers ) { if ( headers . hasOwnProperty ( header ) ) { let value = headers [ header ] ; if ( typeof headers [ header ] !== 's' ) { value = < string > headers [ header ] ; } headerString += `template` ; } } return headerString ; } private static getHighlightLanguageAlias ( contentType : string | undefined , content : string | null = null ) : string | null { if ( MimeUtility . isJSON ( contentType ) ) { return 's' ; } else if ( MimeUtility . isJavaScript ( contentType ) ) { return 's' ; } else if ( MimeUtility . isXml ( contentType ) ) { return 's' ; } else if ( MimeUtility . isHtml ( contentType ) ) { return 's' ; } else if ( MimeUtility . isCSS ( contentType ) ) { return 's' ; } else { if ( content ) { if ( isJSONString ( content ) ) { return 's' ; } } return null ; } } private static isHeadRequest ( { request : { method } } : { request : HttpRequest } ) { return ! ! ( method && method . toLowerCase ( ) === 's' ) ; } } class FoldingRange { public constructor ( public start , public end ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ExtensionContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpResponse$ O $ViewColumn$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $WebviewPanel$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $WebviewPanel$ O $HttpResponse$ O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $HttpResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $Map$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O $number$ O O O O
"s" ; import { EOL } from 's' ; import { ExtensionContext , OutputChannel , Range , StatusBarAlignment , StatusBarItem , ViewColumn , window } from 's' ; import { ArrayUtility } from "s" ; import * as Constants from 's' ; import { Logger } from 's' ; import { RestClientSettings } from 's' ; import { HttpRequest , SerializedHttpRequest } from 's' ; import { HttpResponse } from 's' ; import { RequestParserFactory } from 's' ; import { RequestVariableCacheKey } from 's' ; import { RequestVariableCacheValue } from "s" ; import { trace } from "s" ; import { HttpClient } from 's' ; import { PersistUtility } from 's' ; import { RequestStore } from 's' ; import { RequestVariableCache } from "s" ; import { Selector } from 's' ; import { VariableProcessor } from 's' ; import { getCurrentTextDocument } from 's' ; import { HttpResponseTextDocumentView } from 's' ; import { HttpResponseWebview } from 's' ; const filesize = require ( 's' ) ; const 0 = require ( 's' ) ; export class RequestController { private readonly _restClientSettings : RestClientSettings = RestClientSettings . Instance ; private readonly _requestStore : RequestStore = RequestStore . Instance ; private _durationStatusBarItem : StatusBarItem ; private _sizeStatusBarItem : StatusBarItem ; private _httpClient : HttpClient ; private _webview : HttpResponseWebview ; private _textDocumentView : HttpResponseTextDocumentView ; private _outputChannel : OutputChannel ; public constructor ( context , private readonly logger ) { this . _durationStatusBarItem = window . createStatusBarItem ( StatusBarAlignment . Left ) ; this . _sizeStatusBarItem = window . createStatusBarItem ( StatusBarAlignment . Left ) ; this . _httpClient = new HttpClient ( ) ; this . _webview = new HttpResponseWebview ( context ) ; this . _webview . onDidCloseAllWebviewPanels ( ( ) => { this . _durationStatusBarItem . hide ( ) ; this . _sizeStatusBarItem . hide ( ) ; } ) ; this . _textDocumentView = new HttpResponseTextDocumentView ( ) ; } @ trace ( 's' ) public async run ( range ) { const editor = window . activeTextEditor ; const document = getCurrentTextDocument ( ) ; if ( ! editor || ! document ) { return ; } let selectedText = Selector . getRequestText ( editor , range ) ; if ( ! selectedText ) { return ; } const requestVariable = Selector . getRequestVariableDefinitionName ( selectedText ) ; const lines : string [ ] = selectedText . split ( Constants . LineSplitterRegex ) . filter ( l => ! Constants . CommentIdentifiersRegex . test ( l ) ) ; if ( lines . length === 0 || lines . every ( line => line === 's' ) ) { return ; } selectedText = ArrayUtility . skipWhile ( lines , l => Constants . FileVariableDefinitionRegex . test ( l ) || l . trim ( ) === 's' ) . join ( EOL ) ; selectedText = await VariableProcessor . processRawRequest ( selectedText ) ; const httpRequest = new RequestParserFactory ( ) . createRequestParser ( selectedText ) . parseHttpRequest ( selectedText , document . fileName ) ; if ( ! httpRequest ) { return ; } if ( requestVariable ) { httpRequest . requestVariableCacheKey = new RequestVariableCacheKey ( requestVariable , document . uri . toString ( ) ) ; } await this . runCore ( httpRequest ) ; } @ trace ( 's' ) public async rerun ( ) { const httpRequest = this . _requestStore . getLatest ( ) ; if ( ! httpRequest ) { return ; } await this . runCore ( httpRequest ) ; } @ trace ( 's' ) public async cancel ( ) { if ( this . _requestStore . isCompleted ( ) ) { return ; } this . clearSendProgressStatusText ( ) ; this . _requestStore . cancel ( ) ; this . _durationStatusBarItem . text = 's' ; this . _durationStatusBarItem . tooltip = undefined ; } private async runCore ( httpRequest ) { const requestId = 0 ( ) ; this . _requestStore . add ( < string > requestId , httpRequest ) ; this . setSendingProgressStatusText ( ) ; try { const response = await this . _httpClient . send ( httpRequest ) ; if ( this . _requestStore . isCancelled ( < string > requestId ) ) { return ; } this . clearSendProgressStatusText ( ) ; this . formatDurationStatusBar ( response ) ; this . formatSizeStatusBar ( response ) ; this . _sizeStatusBarItem . show ( ) ; if ( httpRequest . requestVariableCacheKey ) { RequestVariableCache . add ( httpRequest . requestVariableCacheKey , new RequestVariableCacheValue ( httpRequest , response ) ) ; } try { const activeColumn = window . activeTextEditor ! . viewColumn ; const previewColumn = this . _restClientSettings . previewColumn === ViewColumn . Active ? activeColumn : ( ( activeColumn as number ) + 0 ) as ViewColumn ; if ( this . _restClientSettings . previewResponseInUntitledDocument ) { this . _textDocumentView . render ( response , previewColumn ) ; } else if ( previewColumn ) { this . _webview . render ( response , previewColumn ) ; } } catch ( reason ) { this . logger . error ( 's' , reason ) ; window . showErrorMessage ( reason ) ; } const serializedRequest = SerializedHttpRequest . convertFromHttpRequest ( httpRequest ) ; await PersistUtility . saveRequest ( serializedRequest ) ; } catch ( error ) { if ( this . _requestStore . isCancelled ( < string > requestId ) ) { return ; } if ( error . code === 's' ) { error . message = `template` ; } else if ( error . code === 's' ) { error . message = `template` ; } else if ( error . code === 's' ) { error . message = `template` ; } this . clearSendProgressStatusText ( ) ; this . _durationStatusBarItem . text = 's' ; this . logger . error ( 's' , error ) ; window . showErrorMessage ( error . message ) ; } finally { this . _requestStore . complete ( < string > requestId ) ; } } public dispose ( ) { this . _durationStatusBarItem . dispose ( ) ; this . _sizeStatusBarItem . dispose ( ) ; this . _webview . dispose ( ) ; this . _outputChannel . dispose ( ) ; } private setSendingProgressStatusText ( ) { this . clearSendProgressStatusText ( ) ; this . _durationStatusBarItem . text = `template` ; this . _durationStatusBarItem . tooltip = 's' ; this . _durationStatusBarItem . show ( ) ; } private clearSendProgressStatusText ( ) { this . _sizeStatusBarItem . hide ( ) ; } private formatDurationStatusBar ( response ) { this . _durationStatusBarItem . text = `template` ; this . _durationStatusBarItem . tooltip = [ 's' , `template` , `template` , `template` , `template` , `template` ] . join ( EOL ) ; } private formatSizeStatusBar ( response ) { this . _sizeStatusBarItem . text = `template` ; this . _sizeStatusBarItem . tooltip = [ 's' , `template` , `template` ] . join ( EOL ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ExtensionContext$ O O O $Logger$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Range$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpRequest$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HttpResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import * as fs from 's' ; import * as os from 's' ; import * as path from 's' ; import { Clipboard , env , Uri , window , workspace } from 's' ; import * as Constants from 's' ; import { HttpResponse } from 's' ; import { trace } from "s" ; import { MimeUtility } from 's' ; import { PersistUtility } from 's' ; import { HttpResponseWebview } from 's' ; export class ResponseController { public static responseSaveFolderPath : string = path . join ( os . homedir ( ) , Constants . ExtensionFolderName , Constants . DefaultResponseDownloadFolderName ) ; public static responseBodySaveFolderPath : string = path . join ( os . homedir ( ) , Constants . ExtensionFolderName , Constants . DefaultResponseBodyDownloadFolderName ) ; private readonly clipboard : Clipboard ; public constructor ( ) { fs . ensureDir ( ResponseController . responseSaveFolderPath ) ; fs . ensureDir ( ResponseController . responseBodySaveFolderPath ) ; this . clipboard = env . clipboard ; } @ trace ( 's' ) public async save ( ) { const response = HttpResponseWebview . activePreviewResponse ; if ( response ) { const fullResponse = this . getFullResponseString ( response ) ; const defaultFilePath = path . join ( ResponseController . responseSaveFolderPath , `template` ) ; try { const uri = await window . showSaveDialog ( { defaultUri : Uri . file ( defaultFilePath ) } ) ; if ( uri ) { const filePath = uri . fsPath ; await PersistUtility . ensureFileAsync ( filePath ) ; await fs . writeFile ( filePath , fullResponse ) ; const btn = await window . showInformationMessage ( `template` , { title : 's' } , { title : 's' } ) ; if ( btn ) { if ( btn . title === 's' ) { workspace . openTextDocument ( filePath ) . then ( window . showTextDocument ) ; } else if ( btn . title === 's' ) { await this . clipboard . writeText ( filePath ) ; } } } } catch { window . showErrorMessage ( 's' ) ; } } } @ trace ( 's' ) public async copyBody ( ) { const response = HttpResponseWebview . activePreviewResponse ; if ( response ) { await this . clipboard . writeText ( response . body ) ; } } @ trace ( 's' ) public async saveBody ( ) { const response = HttpResponseWebview . activePreviewResponse ; if ( response ) { const extension = MimeUtility . getExtension ( response . contentType , 's' ) ; const fileName = ! extension ? `template` : `template` ; const defaultFilePath = path . join ( ResponseController . responseBodySaveFolderPath , fileName ) ; try { const uri = await window . showSaveDialog ( { defaultUri : Uri . file ( defaultFilePath ) } ) ; if ( uri ) { const filePath = uri . fsPath ; await PersistUtility . ensureFileAsync ( filePath ) ; await fs . writeFile ( filePath , response . bodyBuffer ) ; const btn = await window . showInformationMessage ( `template` , { title : 's' } , { title : 's' } ) ; if ( btn ) { if ( btn . title === 's' ) { workspace . openTextDocument ( filePath ) . then ( window . showTextDocument ) ; } else if ( btn . title === 's' ) { await this . clipboard . writeText ( filePath ) ; } } } } catch { window . showErrorMessage ( 's' ) ; } } } public dispose ( ) { } private getFullResponseString ( response ) { const statusLine = `template` ; let headerString = 's' ; for ( const header in response . headers ) { if ( response . headers . hasOwnProperty ( header ) ) { headerString += `template` ; } } let body = 's' ; if ( response . body ) { body = `template` ; } return `template` ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $HttpResponse$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { Diagnostic , DiagnosticCollection , DiagnosticSeverity , languages , Position , Range , TextDocument , workspace } from 's' ; import * as Constants from 's' ; import { ResolveState } from 's' ; import { RequestVariableCacheKey } from 's' ; import { VariableType } from 's' ; import { RequestVariableCache } from "s" ; import { RequestVariableCacheValueProcessor } from "s" ; import { VariableProcessor } from "s" ; export class CustomVariableDiagnosticsProvider { private httpDiagnosticCollection : DiagnosticCollection ; constructor ( ) { this . httpDiagnosticCollection = languages . createDiagnosticCollection ( ) ; this . checkVariablesInAllTextDocuments ( ) ; RequestVariableCache . onDidCreateNewRequestVariable ( ( ) => this . checkVariablesInAllTextDocuments ( ) ) ; workspace . onDidChangeConfiguration ( e => e . affectsConfiguration ( 's' ) && this . checkVariablesInAllTextDocuments ( ) ) ; } public dispose ( ) { this . httpDiagnosticCollection . clear ( ) ; this . httpDiagnosticCollection . dispose ( ) ; } public deleteDocumentFromDiagnosticCollection ( textDocument ) { if ( this . httpDiagnosticCollection . has ( textDocument . uri ) ) { this . httpDiagnosticCollection . delete ( textDocument . uri ) ; } } public checkVariablesInAllTextDocuments ( ) { workspace . textDocuments . forEach ( this . checkVariables , this ) ; } public async checkVariables ( document ) { if ( document . languageId !== 's' || document . uri . scheme !== 's' ) { return ; } const diagnostics : Diagnostic [ ] = [ ] ; const allAvailableVariables = await VariableProcessor . getAllVariablesDefinitions ( document ) ; const variableReferences = this . findVariableReferences ( document ) ; [ ... variableReferences . entries ( ) ] . filter ( ( [ name ] ) => ! allAvailableVariables . has ( name ) ) . forEach ( ( [ , variables ] ) => { variables . forEach ( v => { diagnostics . push ( new Diagnostic ( new Range ( new Position ( v . lineNumber , v . startIndex ) , new Position ( v . lineNumber , v . endIndex ) ) , `template` , DiagnosticSeverity . Error ) ) ; } ) ; } ) ; [ ... variableReferences . entries ( ) ] . filter ( ( [ name ] ) => allAvailableVariables . has ( name ) && allAvailableVariables . get ( name ) ! [ 0 ] === VariableType . Request && ! RequestVariableCache . has ( new RequestVariableCacheKey ( name , document . uri . toString ( ) ) ) ) . forEach ( ( [ , variables ] ) => { variables . forEach ( v => { diagnostics . push ( new Diagnostic ( new Range ( new Position ( v . lineNumber , v . startIndex ) , new Position ( v . lineNumber , v . endIndex ) ) , `template` , DiagnosticSeverity . Information ) ) ; } ) ; } ) ; [ ... variableReferences . entries ( ) ] . filter ( ( [ name ] ) => allAvailableVariables . has ( name ) && allAvailableVariables . get ( name ) ! [ 0 ] === VariableType . Request && RequestVariableCache . has ( new RequestVariableCacheKey ( name , document . uri . toString ( ) ) ) ) . forEach ( ( [ name , variables ] ) => { const value = RequestVariableCache . get ( new RequestVariableCacheKey ( name , document . uri . toString ( ) ) ) ; variables . forEach ( v => { const path = v . variableValue . replace ( "s" , 's' ) . replace ( "s" , 's' ) ; const result = RequestVariableCacheValueProcessor . resolveRequestVariable ( value ! , path ) ; if ( result . state !== ResolveState . Success ) { diagnostics . push ( new Diagnostic ( new Range ( new Position ( v . lineNumber , v . startIndex ) , new Position ( v . lineNumber , v . endIndex ) ) , result . message , result . state === ResolveState . Error ? DiagnosticSeverity . Error : DiagnosticSeverity . Warning ) ) ; } } ) ; } ) ; this . httpDiagnosticCollection . set ( document . uri , diagnostics ) ; } private findVariableReferences ( document ) < string , Variable [ ] > { const vars < string , Variable [ ] > = new Map < string , Variable [ ] > ( ) ; const lines = document . getText ( ) . split ( Constants . LineSplitterRegex ) ; const pattern = "s" ; lines . forEach ( ( line , lineNumber ) => { let match : RegExpExecArray | null ; while ( match = pattern . exec ( line ) ) { const [ variablePath , variableName ] = match ; const variable = new Variable ( variableName , variablePath , match . index , match . index + variablePath . length , lineNumber ) ; if ( vars . has ( variableName ) ) { vars . get ( variableName ) ! . push ( variable ) ; } else { vars . set ( variableName , [ variable ] ) ; } } } ) ; return vars ; } } class Variable { constructor ( public variableName , public variableValue , public startIndex , public endIndex , public lineNumber ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O $TextDocument$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TextDocument$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Map$ O $TextDocument$ O O O O O O O O O O $Map$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O $string$ O O $number$ O O $number$ O O $number$ O O O O
's' ; import * as fs from 's' ; import * as path from 's' ; import * as url from 's' ; import { CancellationToken , DocumentLink , DocumentLinkProvider , Position , Range , TextDocument , Uri } from 's' ; import * as Constants from 's' ; import { getWorkspaceRootPath } from 's' ; export class RequestBodyDocumentLinkProvider implements DocumentLinkProvider { private _linkPattern = "s" ; public provideDocumentLinks ( document , _token ) : DocumentLink [ ] { const results : DocumentLink [ ] = [ ] ; const base = path . dirname ( document . uri . toString ( ) ) ; const text = document . getText ( ) ; const lines : string [ ] = text . split ( Constants . LineSplitterRegex ) ; for ( let index = 0 ; index < lines . length ; index ++ ) { const line = lines [ index ] ; let match : RegExpMatchArray | null ; if ( match = this . _linkPattern . exec ( line ) ) { const filePath = match [ 0 ] ; const offset = match [ 0 ] . length ; const linkStart = new Position ( index , offset ) ; const linkEnd = new Position ( index , offset + filePath . length ) ; results . push ( new DocumentLink ( new Range ( linkStart , linkEnd ) , this . normalizeLink ( document , filePath , base ) ) ) ; } } return results ; } private normalizeLink ( document , link , base ) { let resourcePath ; if ( path . isAbsolute ( link ) ) { resourcePath = Uri . file ( link ) ; } else { let rootPath = getWorkspaceRootPath ( ) ; if ( rootPath ) { rootPath = rootPath . replace ( "s" , 's' ) ; let resourcePathString = url . resolve ( rootPath , link ) ; if ( ! fs . existsSync ( resourcePathString ) ) { base = base . replace ( "s" , 's' ) ; resourcePathString = url . resolve ( base , link ) ; } resourcePath = Uri . parse ( resourcePathString ) ; } else { base = base . replace ( "s" , 's' ) ; resourcePath = Uri . parse ( url . resolve ( base , link ) ) ; } } return Uri . parse ( `template` ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TextDocument$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Uri$ O $TextDocument$ O $string$ O $string$ O O O $Uri$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { Position , Range , TextDocument , TextLine } from 's' ; import * as Constants from 's' ; export class VariableUtility { public static isFileVariableDefinition ( document , position ) { const wordRange = document . getWordRangeAtPosition ( position ) ; const lineRange = document . lineAt ( position ) ; if ( ! wordRange || wordRange . start . character < 0 || lineRange . text [ wordRange . start . character - 0 ] !== 's' ) { return false ; } return true ; } public static isEnvironmentOrFileVariableReference ( document , position ) { const wordRange = document . getWordRangeAtPosition ( position ) ; if ( wordRange === undefined ) { return false ; } const lineRange = document . lineAt ( position ) ; return VariableUtility . isVariableReferenceFromLine ( wordRange , lineRange ) ; } public static isRequestVariableReference ( document , position ) { const wordRange = document . getWordRangeAtPosition ( position , "s" ) ; return wordRange ? ! wordRange . isEmpty : false ; } public static isPartialRequestVariableReference ( document , position ) { const wordRange = document . getWordRangeAtPosition ( position , "s" ) ; return wordRange ? ! wordRange . isEmpty : false ; } private static isVariableReferenceFromLine ( wordRange , lineRange ) { if ( ! wordRange || wordRange . start . character < 0 || wordRange . end . character > lineRange . range . end . character - 0 || lineRange . text [ wordRange . start . character - 0 ] !== 's' || lineRange . text [ wordRange . start . character - 0 ] !== 's' || lineRange . text [ wordRange . end . character ] !== 's' || lineRange . text [ wordRange . end . character + 0 ] !== 's' ) { return false ; } return true ; } public static getFileVariableDefinitionRanges ( lines : string [ ] , variable ) : Range [ ] { const locations : Range [ ] = [ ] ; for ( const [ index , line ] of lines . entries ( ) ) { let match : RegExpExecArray | null ; if ( ( match = Constants . FileVariableDefinitionRegex . exec ( line ) ) && match [ 0 ] === variable ) { const startPos = line . indexOf ( `template` ) ; const endPos = startPos + variable . length + 0 ; locations . push ( new Range ( index , startPos , index , endPos ) ) ; } } return locations ; } public static getRequestVariableDefinitionRanges ( lines : string [ ] , variable ) : Range [ ] { const locations : Range [ ] = [ ] ; for ( const [ index , line ] of lines . entries ( ) ) { let match : RegExpExecArray | null ; if ( ( match = Constants . RequestVariableDefinitionRegex . exec ( line ) ) && match [ 0 ] === variable ) { const startPos = line . indexOf ( `template` ) ; const endPos = startPos + variable . length + 0 ; locations . push ( new Range ( index , startPos , index , endPos ) ) ; } } return locations ; } public static getFileVariableReferenceRanges ( lines : string [ ] , variable ) : Range [ ] { const locations : Range [ ] = [ ] ; const regex = new RegExp ( `template` , 's' ) ; for ( const [ index , line ] of lines . entries ( ) ) { if ( Constants . CommentIdentifiersRegex . test ( line ) ) { continue ; } regex . lastIndex = 0 ; let match : RegExpExecArray | null ; while ( match = regex . exec ( line ) ) { const startPos = match . index + 0 ; const endPos = startPos + variable . length ; locations . push ( new Range ( index , startPos , index , endPos ) ) ; regex . lastIndex = match . index + 0 ; } } return locations ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $TextDocument$ O $Position$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $TextDocument$ O $Position$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $TextDocument$ O $Position$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $TextDocument$ O $Position$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Range$ O $TextLine$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { CancellationToken , Hover , HoverProvider , MarkdownString , MarkedString , Position , TextDocument } from 's' ; import { EnvironmentVariableProvider } from 's' ; import { FileVariableProvider } from 's' ; import { VariableUtility } from 's' ; export class EnvironmentOrFileVariableHoverProvider implements HoverProvider { public async provideHover ( document , position , token ) < Hover | undefined > { if ( ! VariableUtility . isEnvironmentOrFileVariableReference ( document , position ) ) { return undefined ; } const wordRange = document . getWordRangeAtPosition ( position ) ; const selectedVariableName = document . getText ( wordRange ) ; if ( await FileVariableProvider . Instance . has ( selectedVariableName , document ) ) { const { name , value , error , warning } = await FileVariableProvider . Instance . get ( selectedVariableName , document ) ; if ( ! warning && ! error ) { const contents : MarkedString [ ] = [ value as string , new MarkdownString ( `template` ) ] ; return new Hover ( contents , wordRange ) ; } return undefined ; } if ( await EnvironmentVariableProvider . Instance . has ( selectedVariableName ) ) { const { name , value , error , warning } = await EnvironmentVariableProvider . Instance . get ( selectedVariableName ) ; if ( ! warning && ! error ) { const contents : MarkedString [ ] = [ value as string , new MarkdownString ( `template` ) ] ; return new Hover ( contents , wordRange ) ; } } return undefined ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O $Position$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { CancellationToken , Definition , DefinitionProvider , Location , Position , TextDocument } from 's' ; import * as Constants from 's' ; import { VariableUtility } from 's' ; export class FileVariableDefinitionProvider implements DefinitionProvider { public async provideDefinition ( document , position , token ) < Definition | undefined > { if ( ! VariableUtility . isEnvironmentOrFileVariableReference ( document , position ) ) { return undefined ; } const documentLines = document . getText ( ) . split ( Constants . LineSplitterRegex ) ; const wordRange = document . getWordRangeAtPosition ( position ) ; const selectedVariableName = document . getText ( wordRange ) ; const locations = VariableUtility . getFileVariableDefinitionRanges ( documentLines , selectedVariableName ) ; return locations . map ( location => new Location ( document . uri , location ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O $Position$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { CancellationToken , Location , Position , Range , ReferenceContext , ReferenceProvider , TextDocument } from 's' ; import * as Constants from 's' ; import { VariableUtility } from 's' ; export class FileVariableReferenceProvider implements ReferenceProvider { public async provideReferences ( document , position , context , token ) < Location [ ] | undefined > { if ( ! VariableUtility . isFileVariableDefinition ( document , position ) && ! VariableUtility . isEnvironmentOrFileVariableReference ( document , position ) ) { return undefined ; } const documentLines = document . getText ( ) . split ( Constants . LineSplitterRegex ) ; const wordRange = document . getWordRangeAtPosition ( position ) ; const selectedVariableName = document . getText ( wordRange ) ; const locations : Range [ ] = [ ] ; if ( context . includeDeclaration ) { const definitionLocations = VariableUtility . getFileVariableDefinitionRanges ( documentLines , selectedVariableName ) ; locations . push ( ... definitionLocations ) ; } const referenceLocations = VariableUtility . getFileVariableReferenceRanges ( documentLines , selectedVariableName ) ; locations . push ( ... referenceLocations ) ; return locations . map ( location => new Location ( document . uri , location ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O $Position$ O $ReferenceContext$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { CancellationToken , CodeLens , CodeLensProvider , Command , Location , Range , TextDocument } from 's' ; import * as Constants from 's' ; import { Selector } from 's' ; import { VariableUtility } from 's' ; export class FileVariableReferencesCodeLensProvider implements CodeLensProvider { public provideCodeLenses ( document , token ) < CodeLens [ ] > { const blocks : CodeLens [ ] = [ ] ; const lines : string [ ] = document . getText ( ) . split ( Constants . LineSplitterRegex ) ; const requestRanges : [ number , number ] [ ] = Selector . getRequestRanges ( lines , { ignoreFileVariableDefinitionLine : false } ) ; for ( let [ blockStart , blockEnd ] of requestRanges ) { while ( blockStart <= blockEnd ) { const line = lines [ blockStart ] ; if ( ! Selector . isVariableDefinitionLine ( line ) ) { break ; } const range = new Range ( blockStart , 0 , blockEnd , 0 ) ; let match : RegExpExecArray | null ; if ( match = Constants . FileVariableDefinitionRegex . exec ( line ) ) { const variableName = match [ 0 ] ; const locations = VariableUtility . getFileVariableReferenceRanges ( lines , variableName ) ; const cmd = { arguments : [ document . uri , range . start , locations . map ( loc => new Location ( document . uri , loc ) ) ] , title : locations . length === 0 ? 's' : `template` , command : locations . length ? 's' : 's' , } ; blocks . push ( new CodeLens ( range , cmd ) ) ; } blockStart ++ ; } } return Promise . resolve ( blocks ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Command$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { CancellationToken , CodeLens , CodeLensProvider , Command , Range , TextDocument } from 's' ; import * as Constants from 's' ; import { Selector } from 's' ; export class HttpCodeLensProvider implements CodeLensProvider { public provideCodeLenses ( document , token ) < CodeLens [ ] > { const blocks : CodeLens [ ] = [ ] ; const lines : string [ ] = document . getText ( ) . split ( Constants . LineSplitterRegex ) ; const requestRanges : [ number , number ] [ ] = Selector . getRequestRanges ( lines ) ; for ( const [ blockStart , blockEnd ] of requestRanges ) { const range = new Range ( blockStart , 0 , blockEnd , 0 ) ; const cmd = { arguments : [ document , range ] , title : 's' , command : 's' } ; blocks . push ( new CodeLens ( range , cmd ) ) ; } return Promise . resolve ( blocks ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Command$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import { MarkdownString , SnippetString } from 's' ; export class HttpElement { public constructor ( public name , public type , public prefix ? : string | null , public description ? : string | MarkdownString , public text ? : string | SnippetString ) { this . text = text ; if ( ! this . text ) { this . text = name ; } if ( typeof this . text === 's' ) { if ( type === ElementType . Header ) { this . text = `template` ; } else if ( type === ElementType . Method ) { this . text = `template` ; } this . text = this . text . replace ( "s" , "s" ) ; } if ( type === ElementType . SystemVariable ) { this . name = name . substr ( 0 ) ; } } } export enum ElementType { Method , URL , Header , MIME , Authentication , SystemVariable , EnvironmentCustomVariable , FileCustomVariable , RequestCustomVariable }	O O O O O O O O O O O O O O O O O O O $string$ O O $ElementType$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import * as url from 's' ; import { MarkdownString , SnippetString , TextDocument } from 's' ; import * as Constants from 's' ; import { ElementType , HttpElement } from 's' ; import { EnvironmentVariableProvider } from 's' ; import { FileVariableProvider } from 's' ; import { RequestVariableProvider } from 's' ; import { PersistUtility } from 's' ; export class HttpElementFactory { public static async getHttpElements ( document , line ) < HttpElement [ ] > { const originalElements : HttpElement [ ] = [ ] ; originalElements . push ( new HttpElement ( 's' , ElementType . Method ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Method ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Method ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Method ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Method ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Method ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Method ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Method ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Method ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( 's' , ElementType . Header , null , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . MIME , 's' ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . Authentication , 's' , "s" , new SnippetString ( `template` ) ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . Authentication , 's' , "s" , new SnippetString ( `template` ) ) ) ; originalElements . push ( new HttpElement ( "s" , ElementType . Authentication , 's' , "s" , new SnippetString ( `template` ) ) ) ; originalElements . push ( new HttpElement ( Constants . GuidVariableName , ElementType . SystemVariable , null , Constants . GuidVariableDescription , new SnippetString ( `template` ) ) ) ; originalElements . push ( new HttpElement ( Constants . TimeStampVariableName , ElementType . SystemVariable , null , Constants . TimeStampVariableDescription , new SnippetString ( `template` ) ) ) ; originalElements . push ( new HttpElement ( Constants . DateTimeVariableName , ElementType . SystemVariable , null , Constants . DateTimeVariableNameDescription , new SnippetString ( `template` ) ) ) ; originalElements . push ( new HttpElement ( Constants . RandomIntVariableName , ElementType . SystemVariable , null , Constants . RandomIntDescription , new SnippetString ( `template` ) ) ) ; originalElements . push ( new HttpElement ( Constants . ProcessEnvVariableName , ElementType . SystemVariable , null , Constants . ProcessEnvDescription , new SnippetString ( `template` ) ) ) ; originalElements . push ( new HttpElement ( Constants . AzureActiveDirectoryVariableName , ElementType . SystemVariable , null , Constants . AzureActiveDirectoryDescription , new SnippetString ( `template` ) ) ) ; const environmentVariables = await EnvironmentVariableProvider . Instance . getAll ( ) ; for ( const { name , value } of environmentVariables ) { originalElements . push ( new HttpElement ( name , ElementType . EnvironmentCustomVariable , null , new MarkdownString ( `template` ) , new SnippetString ( `template` ) ) ) ; } const fileVariables = await FileVariableProvider . Instance . getAll ( document ) ; for ( const { name , value } of fileVariables ) { originalElements . push ( new HttpElement ( name , ElementType . FileCustomVariable , 's' , new MarkdownString ( `template` ) , new SnippetString ( `template` ) ) ) ; } const requestVariables = await RequestVariableProvider . Instance . getAll ( document ) ; for ( const { name , value } of requestVariables ) { const v = new MarkdownString ( `template` ) ; originalElements . push ( new HttpElement ( name , ElementType . RequestCustomVariable , null , v , new SnippetString ( `template` ) ) ) ; } const historyItems = await PersistUtility . loadRequests ( ) ; const distinctRequestUrls = Array . from ( new Set ( historyItems . map ( item => item . url ) ) ) ; distinctRequestUrls . forEach ( requestUrl => { const protocol = url . parse ( requestUrl ) . protocol ; if ( ! protocol ) { return ; } const prefixLength = protocol . length + 0 ; originalElements . push ( new HttpElement ( `template` , ElementType . URL , 's' ) ) ; } ) ; let elements : HttpElement [ ] = [ ] ; if ( line ) { originalElements . forEach ( element => { if ( element . prefix ) { if ( line . match ( new RegExp ( element . prefix , 's' ) ) ) { elements . push ( element ) ; } } } ) ; } if ( elements . length === 0 ) { elements = originalElements . filter ( e => ! e . prefix ) ; } else if ( elements . every ( e => e . type === ElementType . FileCustomVariable || e . type === ElementType . RequestCustomVariable ) ) { elements = elements . concat ( originalElements . filter ( e => ! e . prefix ) ) ; } else { originalElements . filter ( e => ! e . prefix && ( e . type === ElementType . SystemVariable || e . type === ElementType . EnvironmentCustomVariable || e . type === ElementType . FileCustomVariable || e . type === ElementType . RequestCustomVariable ) ) . forEach ( element => { elements . push ( element ) ; } ) ; } return elements ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { CancellationToken , CompletionItem , CompletionItemKind , CompletionItemProvider , Position , TextDocument } from 's' ; import { ElementType } from 's' ; import { HttpElementFactory } from 's' ; import { VariableUtility } from "s" ; export class HttpCompletionItemProvider implements CompletionItemProvider { public async provideCompletionItems ( document , position , token ) < CompletionItem [ ] | undefined > { if ( VariableUtility . isPartialRequestVariableReference ( document , position ) ) { return undefined ; } const elements = await HttpElementFactory . getHttpElements ( document , document . lineAt ( position ) . text ) ; return elements . map ( e => { const item = new CompletionItem ( e . name ) ; item . detail = `template` ; item . documentation = e . description ; item . insertText = e . text ; item . kind = e . type in [ ElementType . SystemVariable , ElementType . EnvironmentCustomVariable , ElementType . FileCustomVariable , ElementType . RequestCustomVariable ] ? CompletionItemKind . Variable : e . type === ElementType . Method ? CompletionItemKind . Method : e . type === ElementType . Header ? CompletionItemKind . Property : CompletionItemKind . Field ; return item ; } ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O $Position$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { EOL } from 's' ; import * as url from 's' ; import { CancellationToken , DocumentSymbolProvider , Location , Range , SymbolInformation , SymbolKind , TextDocument , window } from 's' ; import * as Constants from 's' ; import { RequestParserFactory } from 's' ; import { Selector } from 's' ; import { VariableProcessor } from 's' ; import { getCurrentHttpFileName } from 's' ; export class HttpDocumentSymbolProvider implements DocumentSymbolProvider { private static requestParserFactory = new RequestParserFactory ( ) ; public async provideDocumentSymbols ( document , token ) < SymbolInformation [ ] > { const symbols : SymbolInformation [ ] = [ ] ; const lines : string [ ] = document . getText ( ) . split ( Constants . LineSplitterRegex ) ; const requestRange : [ number , number ] [ ] = Selector . getRequestRanges ( lines , { ignoreFileVariableDefinitionLine : false } ) ; for ( let [ blockStart , blockEnd ] of requestRange ) { while ( blockStart <= blockEnd ) { const line = lines [ blockStart ] ; if ( Selector . isEmptyLine ( line ) || Selector . isCommentLine ( line ) ) { blockStart ++ ; } else if ( Selector . isVariableDefinitionLine ( line ) ) { const [ name , container ] = this . getVariableSymbolInfo ( line ) ; symbols . push ( new SymbolInformation ( name , SymbolKind . Variable , container , new Location ( document . uri , new Range ( blockStart , 0 , blockStart , line . length ) ) ) ) ; blockStart ++ ; } else { break ; } } if ( Selector . isResponseStatusLine ( lines [ blockStart ] ) ) { continue ; } if ( blockStart <= blockEnd ) { const text = await VariableProcessor . processRawRequest ( lines . slice ( blockStart , blockEnd + 0 ) . join ( EOL ) ) ; const info = this . getRequestSymbolInfo ( text ) ; if ( ! info ) { continue ; } const [ name , container ] = info ; symbols . push ( new SymbolInformation ( name , SymbolKind . Method , container , new Location ( document . uri , new Range ( blockStart , 0 , blockEnd , lines [ blockEnd ] . length ) ) ) ) ; } } return symbols ; } private getVariableSymbolInfo ( line ) : [ string , string ] { const fileName = getCurrentHttpFileName ( ) ; line = line . trim ( ) ; return [ line . substring ( 0 , line . indexOf ( 's' ) ) . trim ( ) , fileName ! ] ; } private getRequestSymbolInfo ( text ) : [ string , string ] | null { const parser = HttpDocumentSymbolProvider . requestParserFactory . createRequestParser ( text ) ; const request = parser . parseHttpRequest ( text , window . activeTextEditor ! . document . fileName ) ; if ( ! request ) { return null ; } const parsedUrl = url . parse ( request . url ) ; return [ `template` , parsedUrl . host || 's' ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { CancellationToken , CompletionItem , CompletionItemKind , CompletionItemProvider , MarkdownString , Position , Range , TextDocument , TextLine } from 's' ; import * as Constants from "s" ; import { ElementType } from "s" ; import { ResolveState , ResolveWarningMessage } from "s" ; import { RequestVariableCacheValue } from 's' ; import { RequestVariableProvider } from 's' ; import { RequestVariableCacheValueProcessor } from "s" ; import { VariableUtility } from "s" ; const firstPartRegex = "s" ; const secondPartRegex = "s" ; export class RequestVariableCompletionItemProvider implements CompletionItemProvider { public async provideCompletionItems ( document , position , token ) < CompletionItem [ ] | undefined > { if ( ! VariableUtility . isPartialRequestVariableReference ( document , position ) ) { return [ ] ; } const wordRange = document . getWordRangeAtPosition ( position , "s" ) ; const lineRange = document . lineAt ( position ) ; let fullPath = this . getRequestVariableCompletionPath ( wordRange ! , lineRange , position ) ; if ( ! fullPath ) { return undefined ; } const match = fullPath . match ( "s" ) ; if ( ! match || ! this . checkIfRequestVariableDefined ( document , match [ 0 ] ) ) { return [ ] ; } if ( firstPartRegex . test ( fullPath ) ) { return [ new CompletionItem ( "s" , CompletionItemKind . Field ) , new CompletionItem ( "s" , CompletionItemKind . Field ) , ] ; } else if ( secondPartRegex . test ( fullPath ) ) { return [ new CompletionItem ( "s" , CompletionItemKind . Field ) , new CompletionItem ( "s" , CompletionItemKind . Field ) , ] ; } const requestVariables = await RequestVariableProvider . Instance . getAll ( document ) ; for ( const { name , value } of requestVariables ) { const regex = new RegExp ( `template` ) ; if ( regex . test ( fullPath ) ) { fullPath = fullPath . replace ( "s" , 's' ) ; const result = RequestVariableCacheValueProcessor . resolveRequestVariable ( value as RequestVariableCacheValue , fullPath ) ; if ( result . state === ResolveState . Warning && result . message === ResolveWarningMessage . MissingHeaderName ) { const { value } = result ; return Object . keys ( value ) . map ( p => { const item = new CompletionItem ( p ) ; item . detail = `template` ; item . documentation = new MarkdownString ( `template` ) ; item . insertText = p ; item . kind = CompletionItemKind . Field ; return item ; } ) ; } } } return undefined ; } private checkIfRequestVariableDefined ( document , variableName ) { const text = document . getText ( ) ; const regex = new RegExp ( Constants . RequestVariableDefinitionWithNameRegexFactory ( variableName , "s" ) ) ; return regex . test ( text ) ; } private getRequestVariableCompletionPath ( wordRange , lineRange , position ) { let isFirst = false ; let index = position . character ; let forwardIndex = position . character ; for ( ; index >= 0 ; index -- ) { if ( lineRange . text [ index - 0 ] === "s" && lineRange . text [ index - 0 ] === "s" ) { isFirst = true ; for ( ; forwardIndex <= wordRange . end . character ; forwardIndex ++ ) { if ( lineRange . text [ forwardIndex ] === "s" ) { break ; } } break ; } if ( lineRange . text [ index - 0 ] === "s" ) { break ; } } if ( isFirst ) { return lineRange . text . substring ( index , forwardIndex ) ; } else { return lineRange . text . substring ( wordRange . start . character + 0 , index ) ; } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RegExp$ O O O O $RegExp$ O O O O O O O O O O O $Promise$ O $TextDocument$ O $Position$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TextDocument$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Range$ O $TextLine$ O $Position$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { CancellationToken , Definition , DefinitionProvider , Location , Position , TextDocument } from 's' ; import * as Constants from 's' ; import { VariableUtility } from 's' ; export class RequestVariableDefinitionProvider implements DefinitionProvider { public async provideDefinition ( document , position , token ) < Definition | undefined > { if ( ! VariableUtility . isRequestVariableReference ( document , position ) ) { return undefined ; } const documentLines = document . getText ( ) . split ( Constants . LineSplitterRegex ) ; const wordRange = document . getWordRangeAtPosition ( position ) ; const selectedVariableName = document . getText ( wordRange ) ; const locations = VariableUtility . getRequestVariableDefinitionRanges ( documentLines , selectedVariableName ) ; return locations . map ( location => new Location ( document . uri , location ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O $Position$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { CancellationToken , Hover , HoverProvider , MarkdownString , MarkedString , Position , Range , TextDocument , TextLine } from 's' ; import { RequestVariableProvider } from 's' ; import { VariableUtility } from 's' ; export class RequestVariableHoverProvider implements HoverProvider { public async provideHover ( document , position , token ) < Hover | undefined > { if ( ! VariableUtility . isRequestVariableReference ( document , position ) ) { return undefined ; } const wordRange = document . getWordRangeAtPosition ( position , "s" ) ; const lineRange = document . lineAt ( position ) ; const fullPath = this . getRequestVariableHoverPath ( wordRange ! , lineRange ) ; if ( ! fullPath ) { return undefined ; } const { name , value , warning , error } = await RequestVariableProvider . Instance . get ( fullPath , document ) ; if ( ! error && ! warning ) { const contents : MarkedString [ ] = [ ] ; if ( value ) { contents . push ( typeof value === 's' ? value : { language : 's' , value : JSON . stringify ( value , null , 0 ) } ) ; } contents . push ( new MarkdownString ( `template` ) ) ; return new Hover ( contents , wordRange ) ; } return undefined ; } private getRequestVariableHoverPath ( wordRange , lineRange ) { return wordRange && ! wordRange . isEmpty ? lineRange . text . substring ( wordRange . start . character + 0 , wordRange . end . character - 0 ) : null ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $TextDocument$ O $Position$ O $CancellationToken$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Range$ O $TextLine$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
"s" ; import { Disposable } from 's' ; import { RestClientSettings } from 's' ; class ConditionalRegistration { private registration : Disposable | undefined ; public constructor ( private readonly doRegister : ( ) => Disposable ) { } public dispose ( ) { if ( this . registration ) { this . registration . dispose ( ) ; this . registration = undefined ; } } public update ( enabled ) { if ( enabled ) { if ( ! this . registration ) { this . registration = this . doRegister ( ) ; } } else { if ( this . registration ) { this . registration . dispose ( ) ; this . registration = undefined ; } } } } export class ConfigurationDependentRegistration { private readonly settings : RestClientSettings = RestClientSettings . Instance ; private readonly registration : ConditionalRegistration ; public constructor ( register : ( ) => Disposable , private readonly settingValueFunc : ( settings ) => boolean ) { this . registration = new ConditionalRegistration ( register ) ; this . update ( ) ; this . settings . onDidChangeConfiguration ( this . update , this ) ; } public dispose ( ) { this . registration . dispose ( ) ; } private update ( ) { this . registration . update ( this . settingValueFunc ( this . settings ) ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RestClientSettings$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
's' ; import { commands , ExtensionContext , languages , Range , TextDocument , Uri , window , workspace } from 's' ; import { CodeSnippetController } from 's' ; import { EnvironmentController } from 's' ; import { HistoryController } from 's' ; import { RequestController } from 's' ; import { ResponseController } from 's' ; import { Logger } from 's' ; import { CustomVariableDiagnosticsProvider } from "s" ; import { RequestBodyDocumentLinkProvider } from 's' ; import { EnvironmentOrFileVariableHoverProvider } from 's' ; import { FileVariableDefinitionProvider } from 's' ; import { FileVariableReferenceProvider } from 's' ; import { FileVariableReferencesCodeLensProvider } from 's' ; import { HttpCodeLensProvider } from 's' ; import { HttpCompletionItemProvider } from 's' ; import { HttpDocumentSymbolProvider } from 's' ; import { RequestVariableCompletionItemProvider } from "s" ; import { RequestVariableDefinitionProvider } from 's' ; import { RequestVariableHoverProvider } from 's' ; import { AadTokenCache } from 's' ; import { ConfigurationDependentRegistration } from 's' ; export async function activate ( context ) { const logger = new Logger ( ) ; const requestController = new RequestController ( context , logger ) ; const historyController = new HistoryController ( logger ) ; const responseController = new ResponseController ( ) ; const codeSnippetController = new CodeSnippetController ( ) ; const environmentController = new EnvironmentController ( await EnvironmentController . getCurrentEnvironment ( ) ) ; context . subscriptions . push ( requestController ) ; context . subscriptions . push ( historyController ) ; context . subscriptions . push ( responseController ) ; context . subscriptions . push ( codeSnippetController ) ; context . subscriptions . push ( environmentController ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ( document , range ) => requestController . run ( range ) ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => requestController . rerun ( ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => requestController . cancel ( ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => historyController . save ( ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => historyController . clear ( ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => responseController . save ( ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => responseController . saveBody ( ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => responseController . copyBody ( ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => codeSnippetController . run ( ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => codeSnippetController . copy ( ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => codeSnippetController . copyAsCurl ( ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => environmentController . switchEnvironment ( ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , ( ) => AadTokenCache . clear ( ) ) ) ; context . subscriptions . push ( commands . registerCommand ( 's' , args => { workspace . openTextDocument ( Uri . parse ( args . path ) ) . then ( window . showTextDocument , error => { window . showErrorMessage ( error . message ) ; } ) ; } ) ) ; const documentSelector = [ { language : 's' , scheme : 's' } , { language : 's' , scheme : 's' } , ] ; context . subscriptions . push ( languages . registerCompletionItemProvider ( documentSelector , new HttpCompletionItemProvider ( ) ) ) ; context . subscriptions . push ( languages . registerCompletionItemProvider ( documentSelector , new RequestVariableCompletionItemProvider ( ) , 's' ) ) ; context . subscriptions . push ( languages . registerHoverProvider ( documentSelector , new EnvironmentOrFileVariableHoverProvider ( ) ) ) ; context . subscriptions . push ( languages . registerHoverProvider ( documentSelector , new RequestVariableHoverProvider ( ) ) ) ; context . subscriptions . push ( new ConfigurationDependentRegistration ( ( ) => languages . registerCodeLensProvider ( documentSelector , new HttpCodeLensProvider ( ) ) , s => s . enableSendRequestCodeLens ) ) ; context . subscriptions . push ( new ConfigurationDependentRegistration ( ( ) => languages . registerCodeLensProvider ( documentSelector , new FileVariableReferencesCodeLensProvider ( ) ) , s => s . enableCustomVariableReferencesCodeLens ) ) ; context . subscriptions . push ( languages . registerDocumentLinkProvider ( documentSelector , new RequestBodyDocumentLinkProvider ( ) ) ) ; context . subscriptions . push ( languages . registerDefinitionProvider ( documentSelector , new FileVariableDefinitionProvider ( ) ) ) ; context . subscriptions . push ( languages . registerDefinitionProvider ( documentSelector , new RequestVariableDefinitionProvider ( ) ) ) ; context . subscriptions . push ( languages . registerReferenceProvider ( documentSelector , new FileVariableReferenceProvider ( ) ) ) ; context . subscriptions . push ( languages . registerDocumentSymbolProvider ( documentSelector , new HttpDocumentSymbolProvider ( ) ) ) ; const diagnosticsProviders = new CustomVariableDiagnosticsProvider ( ) ; workspace . onDidOpenTextDocument ( diagnosticsProviders . checkVariables , diagnosticsProviders , context . subscriptions ) ; workspace . onDidCloseTextDocument ( diagnosticsProviders . deleteDocumentFromDiagnosticCollection , diagnosticsProviders , context . subscriptions ) ; workspace . onDidSaveTextDocument ( diagnosticsProviders . checkVariables , diagnosticsProviders , context . subscriptions ) ; } export function deactivate ( ) { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ExtensionContext$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TextDocument$ O $Range$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' 's' ; const path = require ( 's' ) ; const config = { target : 's' , entry : 's' , output : { path : path . resolve ( __dirname , 's' ) , filename : 's' , libraryTarget : "s" , devtoolModuleFilenameTemplate : "s" , } , devtool : 's' , externals : { vscode : "s" } , resolve : { extensions : [ 's' , 's' ] } , module : { rules : [ { test : "s" , exclude : "s" , use : [ { loader : 's' , } ] } ] } , } module . exports = config ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O