module GhostText . InputArea { export class AceCodeEditor extends JSCodeEditor implements IScriptToInject { public getScript ( ) { return function ( id ) { console . log ( "s" + id ) ; var offsetToPos = function ( lines , offset ) { var row = 0 , pos = 0 ; while ( row < lines . length && pos + lines [ row ] . length < offset ) { pos += lines [ row ] . length + 0 ; row ++ ; } return { row : row , col : offset - pos } ; } ; var ghostTextAceDiv = < HTMLElement > document . querySelector ( "s" + id ) ; console . log ( ghostTextAceDiv ) ; var ghostTextAceEditor = ace . edit ( ghostTextAceDiv ) ; var ghostTextAceEditorSession = ghostTextAceEditor . getSession ( ) ; var Range = ace . require ( "s" ) . Range ; ghostTextAceDiv . addEventListener ( "s" , function ( e ) { ghostTextAceEditorSession . setValue ( e . detail . text ) ; } ) ; ghostTextAceDiv . addEventListener ( "s" , function ( ) { ghostTextAceEditor . focus ( ) ; } ) ; ghostTextAceDiv . addEventListener ( "s" , function ( ) { ghostTextAceEditor . blur ( ) ; } ) ; ghostTextAceDiv . addEventListener ( "s" , function ( e ) { ghostTextAceEditorSession . selection . clearSelection ( ) ; var lines = ghostTextAceEditorSession . getDocument ( ) . getAllLines ( ) ; for ( var i = 0 ; i < e . detail . selections . length ; i ++ ) { var selection = e . detail . selections [ i ] ; var start = offsetToPos ( lines , selection . start ) ; var end = offsetToPos ( lines , selection . end ) ; var range = new Range ( start . row , start . col , end . row , end . col ) ; if ( i === 0 ) { ghostTextAceEditorSession . selection . addRange ( range , true ) ; } else { ghostTextAceEditorSession . selection . setSelectionRange ( range , true ) ; } } } ) ; ghostTextAceDiv . addEventListener ( "s" , function ( ) { var ghostTextAceScrollerDiv = < HTMLElement > ghostTextAceDiv . querySelector ( "s" ) ; ghostTextAceScrollerDiv . style . transition = "s" ; ghostTextAceScrollerDiv . style . boxShadow = "s" ; } ) ; ghostTextAceDiv . addEventListener ( "s" , function ( ) { var ghostTextAceScrollerDiv = < HTMLElement > ghostTextAceDiv . querySelector ( "s" ) ; ghostTextAceScrollerDiv . style . boxShadow = "s" ; } ) ; ghostTextAceEditorSession . on ( "s" , function ( e ) { window . setTimeout ( function ( ) { var value = ghostTextAceEditorSession . getValue ( ) ; var customEvent = CustomEvent ; var inputEvent = new customEvent ( "s" , { detail : { text : value } } ) ; ghostTextAceDiv . dispatchEvent ( inputEvent ) ; } , 0 ) ; } ) ; ghostTextAceEditor . on ( "s" , function ( e ) { var value = ghostTextAceEditorSession . getValue ( ) ; var customEvent = CustomEvent ; var focusEvent = new customEvent ( "s" , { detail : { text : value } } ) ; ghostTextAceDiv . dispatchEvent ( focusEvent ) ; } ) ; } ; } } }	O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $Function$ O O O O O O $any$ O O $Console$ O $void$ O O O $any$ O O O $complex$ O O O $any$ O $any$ O O O $number$ O O O $number$ O O O O O $number$ O $any$ O $any$ O $number$ O $any$ O $number$ O O $any$ O $any$ O O $number$ O $any$ O $number$ O O $any$ O O O $number$ O O O O O $number$ O $number$ O $number$ O $any$ O $number$ O O O O O $HTMLElement$ O O $complex$ O $Document$ O O O O O $any$ O O $Console$ O $void$ O $HTMLElement$ O O O $Editor$ O $Ace$ O $complex$ O $HTMLElement$ O O O $IEditSession$ O $Editor$ O $IEditSession$ O O O O $any$ O $Ace$ O $any$ O O O O $any$ O $HTMLElement$ O O O O O O O $any$ O O $IEditSession$ O $any$ O $any$ O $any$ O $any$ O O O O O $HTMLElement$ O O O O O O O O O $Editor$ O $any$ O O O O O O $HTMLElement$ O O O O O O O O O $Editor$ O $any$ O O O O O O $HTMLElement$ O O O O O O O $any$ O O $IEditSession$ O $Selection$ O $any$ O O O O $string[]$ O $IEditSession$ O $Document$ O O O $string[]$ O O O O O O $number$ O O O $number$ O $any$ O $any$ O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $number$ O O O $complex$ O $complex$ O $string[]$ O $any$ O $any$ O O O $complex$ O $complex$ O $string[]$ O $any$ O $any$ O O O $any$ O O $any$ O $complex$ O $number$ O $complex$ O $number$ O $complex$ O $number$ O $complex$ O $number$ O O O O $number$ O O O O $IEditSession$ O $Selection$ O $any$ O $any$ O O O O O O O $IEditSession$ O $Selection$ O $any$ O $any$ O O O O O O O O O $HTMLElement$ O O O O O O O O O O $HTMLElement$ O O $complex$ O $HTMLElement$ O O O O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O $HTMLElement$ O O O O O O O O O O $HTMLElement$ O O $complex$ O $HTMLElement$ O O O O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O $IEditSession$ O $any$ O O O O O $any$ O O $complex$ O $number)$ O O O O O O $string$ O $IEditSession$ O $string$ O O O O $any$ O $complex$ O O $any$ O O $any$ O O O O $complex$ O O $string$ O $string$ O O O O $HTMLElement$ O $boolean$ O $any$ O O O O O O O O O O $Editor$ O $any$ O O O O O $any$ O O O $string$ O $IEditSession$ O $string$ O O O O $any$ O $complex$ O O $any$ O O $any$ O O O O $complex$ O O $string$ O $string$ O O O O $HTMLElement$ O $boolean$ O $any$ O O O O O O O O O O
module GhostText . InputArea { export class CodeMirror extends JSCodeEditor implements IScriptToInject { public getScript ( ) { return function ( id ) { console . log ( id ) ; var ghostTextCodeMirrorDiv = < any > document . querySelector ( "s" + id ) ; var ghostTextCodeMirrorEditor = < any > ghostTextCodeMirrorDiv . CodeMirror ; ghostTextCodeMirrorDiv . addEventListener ( "s" , function ( e ) { ghostTextCodeMirrorEditor . doc . setValue ( e . detail . text ) ; } ) ; ghostTextCodeMirrorDiv . addEventListener ( "s" , function ( ) { ghostTextCodeMirrorEditor . focus ( ) ; } ) ; ghostTextCodeMirrorDiv . addEventListener ( "s" , function ( e ) { for ( var i = 0 ; i < e . detail . selections . length ; i ++ ) { var selection = e . detail . selections [ i ] ; var start = ghostTextCodeMirrorEditor . posFromIndex ( selection . start ) ; var end = ghostTextCodeMirrorEditor . posFromIndex ( selection . end ) ; if ( i === 0 ) { ghostTextCodeMirrorEditor . doc . setSelection ( start , end ) } else { ghostTextCodeMirrorEditor . doc . addSelection ( start , end ) } } } ) ; ghostTextCodeMirrorDiv . addEventListener ( "s" , function ( ) { var ghostTextCodeMirrorSizerDiv = < HTMLElement > ghostTextCodeMirrorDiv . querySelector ( "s" ) ; ghostTextCodeMirrorSizerDiv . style . transition = "s" ; ghostTextCodeMirrorSizerDiv . style . boxShadow = "s" ; } ) ; ghostTextCodeMirrorDiv . addEventListener ( "s" , function ( ) { var ghostTextCodeMirrorSizerDiv = < HTMLElement > ghostTextCodeMirrorDiv . querySelector ( "s" ) ; ghostTextCodeMirrorSizerDiv . style . boxShadow = "s" ; } ) ; ghostTextCodeMirrorEditor . on ( "s" , function ( e ) { var value = e . doc . getValue ( ) ; var customEvent = CustomEvent ; var inputEvent = new customEvent ( "s" , { detail : { text : value } } ) ; ghostTextCodeMirrorDiv . dispatchEvent ( inputEvent ) ; } ) ; ghostTextCodeMirrorEditor . on ( "s" , function ( e ) { var value = e . doc . getValue ( ) ; var customEvent = CustomEvent ; var focusEvent = new customEvent ( "s" , { detail : { text : value } } ) ; ghostTextCodeMirrorDiv . dispatchEvent ( focusEvent ) ; } ) ; } ; } } }	O $any$ O $any$ O O O $any$ O $any$ O $any$ O O $Function$ O O O O O O $any$ O O $Console$ O $void$ O $any$ O O O $any$ O O O O $Document$ O O O O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $number$ O O O $number$ O $any$ O $any$ O $any$ O $any$ O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $number$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $number$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O O O O $HTMLElement$ O O $complex$ O $any$ O $any$ O O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O $any$ O $any$ O O O O O O O O $HTMLElement$ O O $complex$ O $any$ O $any$ O O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O $any$ O O $any$ O O O O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O $any$ O O O O $any$ O $complex$ O O $any$ O O $any$ O O O O $complex$ O O $any$ O $any$ O O O O $any$ O $any$ O $any$ O O O O O O O O O O
module GhostText . InputArea { export class ContentEditable implements IInputArea { private contentEditableElement : HTMLElement = null ; private textChangedEventCB : ( inputArea , text ) => void = null ; private selectionChangedEventCB : ( inputArea , selections ) => void = null ; private removeEventCB : ( inputArea ) => void = null ; private focusEventCB : ( inputArea ) => void = null ; private unloadEventCB : ( inputArea ) => void = null ; private inputEventListener : EventListener = null ; private focusEventListener : EventListener = null ; private beforeUnloadListener : EventListener = null ; public bind ( domElement ) { this . contentEditableElement = < HTMLElement > domElement ; var that = this ; this . focusEventListener = function ( ) { if ( that . focusEventCB ) { that . focusEventCB ( that ) ; } that . highlight ( ) ; } ; this . contentEditableElement . addEventListener ( 's' , this . focusEventListener , false ) ; this . inputEventListener = function ( ) { if ( that . textChangedEventCB ) { that . textChangedEventCB ( that , that . getText ( ) ) ; } } ; this . contentEditableElement . addEventListener ( 's' , this . inputEventListener , false ) ; this . contentEditableElement . addEventListener ( 's' , this . inputEventListener , false ) ; this . beforeUnloadListener = function ( ) { if ( that . unloadEventCB ) { that . unloadEventCB ( that ) ; } } ; window . addEventListener ( 's' , this . beforeUnloadListener ) ; } public unbind ( ) { this . contentEditableElement . removeEventListener ( 's' , this . focusEventListener ) ; this . contentEditableElement . removeEventListener ( 's' , this . inputEventListener ) ; this . contentEditableElement . removeEventListener ( 's' , this . inputEventListener ) ; window . removeEventListener ( 's' , this . beforeUnloadListener ) ; this . removeHighlight ( ) ; } public focus ( ) { this . contentEditableElement . focus ( ) ; } public blur ( ) { this . contentEditableElement . blur ( ) ; } public textChangedEvent ( callback : ( inputArea , text ) => void ) { this . textChangedEventCB = callback ; } public selectionChangedEvent ( callback : ( inputArea , selections ) => void ) { this . selectionChangedEventCB = callback ; } public removeEvent ( callback : ( inputArea ) => void ) { this . removeEventCB = callback ; } public focusEvent ( callback : ( inputArea ) => void ) { this . focusEventCB = callback ; } public unloadEvent ( callback : ( inputArea ) => void ) { this . unloadEventCB = callback ; } public getText ( ) { return this . contentEditableElement . innerHTML ; } public setText ( text ) { if ( this . contentEditableElement . innerHTML === text ) { return ; } this . contentEditableElement . innerHTML = text ; } public getSelections ( ) { return new Selections ( [ ] ) ; } public setSelections ( selections ) { } public buildChange ( ) { return new TextChange ( this . getText ( ) , this . getSelections ( ) . getAll ( ) ) ; } private highlight ( ) { this . contentEditableElement . style . transition = 's' ; this . contentEditableElement . style . boxShadow = 's' ; } private removeHighlight ( ) { this . contentEditableElement . style . boxShadow = 's' ; } } }	O $any$ O $any$ O O O $any$ O $any$ O O $HTMLElement$ O $complex$ O O O O $void$ O O $IInputArea$ O $string$ O O O O O O O $void$ O O $IInputArea$ O $Selections$ O O O O O O O $void$ O O $IInputArea$ O O O O O O O $void$ O O $IInputArea$ O O O O O O O $void$ O O $IInputArea$ O O O O O O O $EventListener$ O $any$ O O O O $EventListener$ O $any$ O O O O $EventListener$ O $any$ O O O O $void$ O $HTMLElement$ O O O O $HTMLElement$ O O $complex$ O $HTMLElement$ O O $this$ O O O O O $EventListener$ O O O O O O O $this$ O $void$ O O $this$ O $void$ O $this$ O O O $this$ O $void$ O O O O O O O $HTMLElement$ O O O O O O O $EventListener$ O O O O O O $EventListener$ O O O O O O O $this$ O $void$ O O $this$ O $void$ O $this$ O $this$ O $string$ O O O O O O O O O $HTMLElement$ O O O O O O O $EventListener$ O O O O O O $HTMLElement$ O O O O O O O $EventListener$ O O O O O O $EventListener$ O O O O O O O $this$ O $void$ O O $this$ O $void$ O $this$ O O O O O $complex$ O O O O O O O $EventListener$ O O O O $void$ O O O O O $HTMLElement$ O O O O O O O $EventListener$ O O O O $HTMLElement$ O O O O O O O $EventListener$ O O O O $HTMLElement$ O O O O O O O $EventListener$ O O $complex$ O O O O O O O $EventListener$ O O O O $void$ O O O O O $void$ O O O O O $HTMLElement$ O $void$ O O O O O $void$ O O O O O $HTMLElement$ O $void$ O O O O O $void$ O $void$ O O $IInputArea$ O $string$ O O O O O O O $void$ O $void$ O O O $void$ O $void$ O O $IInputArea$ O $Selections$ O O O O O O O $void$ O $void$ O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $void$ O $void$ O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $void$ O $void$ O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $void$ O $void$ O O O $string$ O O O O O O $HTMLElement$ O $string$ O O O $void$ O $string$ O O O O O O $HTMLElement$ O $string$ O $string$ O O O O O O O $HTMLElement$ O $string$ O $string$ O O O $Selections$ O O O O O $any$ O O O O O O O $void$ O $Selections$ O O O O $TextChange$ O O O O O $any$ O O O $string$ O O O O O $Selections$ O O O $Selection[]$ O O O O O O $void$ O O O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O $void$ O O O O O $HTMLElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O
module GhostText . InputArea { export class Detector { private inputAreaElements : Array < IInputArea > ; private onFocusCB : ( inputArea ) => void = null ; public constructor ( ) { this . inputAreaElements = [ ] ; } public detect ( document ) { if ( this . onFocusCB === null ) { throw 's' ; } this . addAceElements ( document ) ; this . addCodeMirrorElements ( document ) ; this . addTextAreas ( document ) ; this . addContentEditableElements ( document ) ; this . addIframes ( document ) ; if ( this . inputAreaElements . length === 0 ) { return 0 ; } if ( this . trySingleElement ( ) ) { return 0 ; } this . tryMultipleElements ( ) ; return this . inputAreaElements . length ; } public focusEvent ( callback : ( inputArea ) => void ) { this . onFocusCB = callback ; } private addTextAreas ( document ) { var textAreas = document . querySelectorAll ( 's' ) ; for ( var i = 0 ; i < textAreas . length ; i ++ ) { if ( ( < HTMLTextAreaElement > textAreas [ i ] ) . getBoundingClientRect ( ) . width ) { var inputArea = new TextArea ( ) ; inputArea . bind ( < HTMLTextAreaElement > textAreas [ i ] ) ; this . inputAreaElements . push ( inputArea ) ; } } } private addContentEditableElements ( document ) { var contentEditables = document . querySelectorAll ( 's' ) ; for ( var i = 0 ; i < contentEditables . length ; i ++ ) { var inputArea = new ContentEditable ( ) ; inputArea . bind ( < HTMLElement > contentEditables [ i ] ) ; this . inputAreaElements . push ( inputArea ) ; } } private addAceElements ( document ) { var aceEditors = document . querySelectorAll ( 's' ) ; for ( var i = 0 ; i < aceEditors . length ; i ++ ) { var aceEditor = < HTMLElement > aceEditors [ i ] ; var id = aceEditor . getAttribute ( 's' ) ; if ( id === null ) { id = 's' + ( Math . random ( ) * 0 ) ; aceEditor . setAttribute ( 's' , id ) ; } var inputArea = new AceCodeEditor ( ) ; inputArea . bind ( aceEditor ) ; this . injectScript ( document , inputArea . getScript ( ) , id ) ; this . inputAreaElements . push ( inputArea ) ; } } private addCodeMirrorElements ( document ) { var codeMirrorEditors = document . querySelectorAll ( 's' ) ; for ( var i = 0 ; i < codeMirrorEditors . length ; i ++ ) { var codeMirrorEditor = < HTMLElement > codeMirrorEditors [ i ] ; var id = codeMirrorEditor . getAttribute ( 's' ) ; if ( id === null ) { id = 's' + ( Math . random ( ) * 0 ) ; codeMirrorEditor . setAttribute ( 's' , id ) ; } var inputArea = new CodeMirror ( ) ; inputArea . bind ( codeMirrorEditor ) ; this . injectScript ( document , inputArea . getScript ( ) , id ) ; this . inputAreaElements . push ( inputArea ) ; } } private addIframes ( document ) { var iframes : HTMLIFrameElement [ ] = document . getElementsByTagName ( 's' ) ; for ( var i = 0 ; i < iframes . length ; i ++ ) { try { this . detect ( < HTMLDocument > iframes [ i ] . contentDocument ) ; } catch ( e ) { console . log ( e ) ; } } } private trySingleElement ( ) { var that = this ; if ( this . inputAreaElements . length === 0 ) { var inputArea = this . inputAreaElements [ 0 ] ; inputArea . blur ( ) ; inputArea . focus ( ) ; that . onFocusCB ( inputArea ) ; return true ; } return false ; } private tryMultipleElements ( ) { var that = this ; for ( var i = 0 ; i < this . inputAreaElements . length ; i ++ ) { this . inputAreaElements [ i ] . blur ( ) ; this . inputAreaElements [ i ] . focusEvent ( function ( inputArea ) { for ( var j = 0 ; j < that . inputAreaElements . length ; j ++ ) { if ( that . inputAreaElements [ j ] !== inputArea ) { that . inputAreaElements [ j ] . unbind ( ) ; } } that . onFocusCB ( inputArea ) ; } ) ; } } private injectScript ( document , javaScript , id ) { if ( document . getElementById ( 's' + id ) !== null ) { return ; } var script = document . createElement ( 's' ) ; script . setAttribute ( 's' , 's' + id ) ; script . textContent = "s" + javaScript . toString ( ) + "s" + id + "s" ; document . head . appendChild ( script ) ; } } }	O $any$ O $any$ O O O $any$ O O $IInputArea[]$ O $ArrayConstructor$ O $any$ O O O $void$ O O $IInputArea$ O O O O O O O O O O O O O $IInputArea[]$ O O O O O O $number$ O $HTMLDocument$ O O O O O O $void$ O O O O O O O O O O $void$ O $HTMLDocument$ O O O O $void$ O $HTMLDocument$ O O O O $void$ O $HTMLDocument$ O O O O $void$ O $HTMLDocument$ O O O O $void$ O $HTMLDocument$ O O O O O O $IInputArea[]$ O $number$ O O O O O O O O O O O O $boolean$ O O O O O O O O O O $void$ O O O O O O $IInputArea[]$ O $number$ O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $void$ O $void$ O O O $void$ O $HTMLDocument$ O O O $NodeList$ O $HTMLDocument$ O O O O O O O O O $number$ O O O $number$ O $NodeList$ O $number$ O $number$ O O O O O O O $complex$ O $NodeList$ O $number$ O O O $complex$ O O O $number$ O O O $TextArea$ O O $any$ O O O $TextArea$ O $void$ O O $complex$ O $NodeList$ O $number$ O O O O O $IInputArea[]$ O $number$ O $TextArea$ O O O O O O $void$ O $HTMLDocument$ O O O $NodeList$ O $HTMLDocument$ O O O O O O O O O $number$ O O O $number$ O $NodeList$ O $number$ O $number$ O O O O $ContentEditable$ O O $any$ O O O $ContentEditable$ O $void$ O O $complex$ O $NodeList$ O $number$ O O O O O $IInputArea[]$ O $number$ O $ContentEditable$ O O O O O $void$ O $HTMLDocument$ O O O $NodeList$ O $HTMLDocument$ O O O O O O O O O $number$ O O O $number$ O $NodeList$ O $number$ O $number$ O O O O $HTMLElement$ O O $complex$ O $NodeList$ O $number$ O O O $string$ O $HTMLElement$ O $string$ O O O O O O $string$ O O O O $string$ O O O O $Math$ O $number$ O O O O O O $HTMLElement$ O $void$ O O O $string$ O O O O $AceCodeEditor$ O O $any$ O O O $AceCodeEditor$ O $void$ O $HTMLElement$ O O O O $void$ O $HTMLDocument$ O $AceCodeEditor$ O $Function$ O O O $string$ O O O O $IInputArea[]$ O $number$ O $AceCodeEditor$ O O O O O $void$ O $HTMLDocument$ O O O $NodeList$ O $HTMLDocument$ O O O O O O O O O $number$ O O O $number$ O $NodeList$ O $number$ O $number$ O O O O $HTMLElement$ O O $complex$ O $NodeList$ O $number$ O O O $string$ O $HTMLElement$ O $string$ O O O O O O $string$ O O O O $string$ O O O O $Math$ O $number$ O O O O O O $HTMLElement$ O $void$ O O O $string$ O O O O $CodeMirror$ O O $any$ O O O $CodeMirror$ O $void$ O $HTMLElement$ O O O O $void$ O $HTMLDocument$ O $CodeMirror$ O $Function$ O O O $string$ O O O O $IInputArea[]$ O $number$ O $CodeMirror$ O O O O O $void$ O $any$ O O O $HTMLIFrameElement[]$ O $complex$ O O O $any$ O $any$ O O O O O O O $number$ O O O $number$ O $HTMLIFrameElement[]$ O $number$ O $number$ O O O O O O O $number$ O O $complex$ O $HTMLIFrameElement[]$ O $number$ O O $Document$ O O O O O $any$ O O $Console$ O $void$ O $any$ O O O O O O $boolean$ O O O O $this$ O O O O O O O $IInputArea[]$ O $number$ O O O O O $IInputArea$ O O O $IInputArea[]$ O O O O $IInputArea$ O $void$ O O O $IInputArea$ O $void$ O O O $this$ O $void$ O $IInputArea$ O O O O O O O O O O O $void$ O O O O $this$ O O O O O O $number$ O O O $number$ O O O $IInputArea[]$ O $number$ O $number$ O O O O O $IInputArea[]$ O $number$ O O $void$ O O O O O $IInputArea[]$ O $number$ O O $void$ O O O $IInputArea$ O O O O O $number$ O O O $number$ O $this$ O $IInputArea[]$ O $number$ O $number$ O O O O O $this$ O $IInputArea[]$ O $number$ O O $IInputArea$ O O $this$ O $IInputArea[]$ O $number$ O O $void$ O O O O O $this$ O $void$ O $IInputArea$ O O O O O O O O $void$ O $HTMLDocument$ O $Function$ O $string$ O O O O $HTMLDocument$ O $HTMLElement$ O O O $string$ O O O O O O O O O $HTMLScriptElement$ O $HTMLDocument$ O O O O O O $HTMLScriptElement$ O $void$ O O O O O $string$ O O $HTMLScriptElement$ O $string$ O O O $Function$ O $string$ O O O O O $string$ O O O $HTMLDocument$ O $HTMLHeadElement$ O $T$ O $HTMLScriptElement$ O O O O O
module GhostText . InputArea { export interface IInputArea { bind ( domElement ) : void ; unbind ( ) : void ; focus ( ) : void ; blur ( ) : void ; textChangedEvent ( callback : ( inputArea , text ) => void ) : void ; selectionChangedEvent ( callback : ( inputArea , selections ) => void ) : void ; removeEvent ( callback : ( inputArea ) => void ) : void ; focusEvent ( callback : ( inputArea ) => void ) : void ; unloadEvent ( callback : ( inputArea ) => void ) : void ; getText ( ) : string ; setText ( text ) : void ; getSelections ( ) : Selections ; setSelections ( selections ) : void ; buildChange ( ) : TextChange ; } }	O $any$ O $any$ O O O $any$ O $void$ O $HTMLElement$ O O O O $void$ O O O O O $void$ O O O O O $void$ O O O O O $void$ O $void$ O O $IInputArea$ O $string$ O O O O O O O $void$ O $void$ O O $IInputArea$ O $Selections$ O O O O O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $string$ O O O O O $void$ O $string$ O O O O $Selections$ O O O $any$ O $void$ O $Selections$ O O O O $TextChange$ O O O $any$ O O O
module GhostText . InputArea { export interface IScriptToInject { getScript ( ) : Function ; } }	O $any$ O $any$ O O O $any$ O $Function$ O O O $FunctionConstructor$ O O O
module GhostText . InputArea { export class JSCodeEditor implements IInputArea { private jsCodeEditorDiv : HTMLElement = null ; private textChangedEventCB : ( inputArea , text ) => void = null ; private selectionChangedEventCB : ( inputArea , selections ) => void = null ; private removeEventCB : ( inputArea ) => void = null ; private focusEventCB : ( inputArea ) => void = null ; private unloadEventCB : ( inputArea ) => void = null ; private inputEventListener : EventListener = null ; private focusEventListener : EventListener = null ; private beforeUnloadListener : EventListener = null ; private elementRemovedListener : EventListener = null ; private currentText : string = null ; public bind ( domElement ) { this . jsCodeEditorDiv = < HTMLElement > domElement ; var that = this ; this . inputEventListener = function ( e ) { if ( that . currentText == e . detail . text ) { return ; } that . currentText = e . detail . text ; if ( that . textChangedEventCB ) { that . textChangedEventCB ( that , that . getText ( ) ) ; } } ; this . jsCodeEditorDiv . addEventListener ( 's' , this . inputEventListener , false ) ; this . focusEventListener = function ( e ) { if ( that . currentText == e . detail . text ) { return ; } that . currentText = e . detail . text ; if ( that . focusEventCB ) { that . focusEventCB ( that ) ; } } ; this . jsCodeEditorDiv . addEventListener ( 's' , this . focusEventListener , false ) ; this . beforeUnloadListener = function ( e ) { if ( that . unloadEventCB ) { that . unloadEventCB ( that ) ; } } ; this . jsCodeEditorDiv . addEventListener ( 's' , this . beforeUnloadListener ) ; this . highlight ( ) ; } public unbind ( ) { this . jsCodeEditorDiv . removeEventListener ( 's' , this . focusEventListener ) ; this . jsCodeEditorDiv . removeEventListener ( 's' , this . inputEventListener ) ; this . jsCodeEditorDiv . removeEventListener ( 's' , this . beforeUnloadListener ) ; this . removeHighlight ( ) ; } public focus ( ) { var gtDoFocusEvent = < Event > StandardsCustomEvent . get ( 's' , { detail : null } ) ; this . jsCodeEditorDiv . dispatchEvent ( gtDoFocusEvent ) ; } public blur ( ) { var gtDoBlurEvent = < Event > StandardsCustomEvent . get ( 's' , { detail : null } ) ; this . jsCodeEditorDiv . dispatchEvent ( gtDoBlurEvent ) ; } public textChangedEvent ( callback : ( inputArea , text ) => void ) { this . textChangedEventCB = callback ; } public selectionChangedEvent ( callback : ( inputArea , selections ) => void ) { this . selectionChangedEventCB = callback ; } public removeEvent ( callback : ( inputArea ) => void ) { this . removeEventCB = callback ; } public focusEvent ( callback : ( inputArea ) => void ) { this . focusEventCB = callback ; } public unloadEvent ( callback : ( inputArea ) => void ) { this . unloadEventCB = callback ; } public getText ( ) { return this . currentText ; } public setText ( text ) { if ( this . currentText == text ) { return ; } this . currentText = text ; var details = { detail : { text : this . currentText } } ; var gtServerInputEvent = < Event > StandardsCustomEvent . get ( 's' , details ) ; this . jsCodeEditorDiv . dispatchEvent ( gtServerInputEvent ) ; } public getSelections ( ) { return new Selections ( [ new Selection ( ) ] ) ; } public setSelections ( selections ) { var details = { detail : { selections : selections . toJSON ( ) } } ; var gtDoFocusEvent = < Event > StandardsCustomEvent . get ( 's' , details ) ; this . jsCodeEditorDiv . dispatchEvent ( gtDoFocusEvent ) ; } public buildChange ( ) { return new TextChange ( this . getText ( ) , this . getSelections ( ) . getAll ( ) ) ; } private highlight ( ) { var gtDoHighlightEvent = < Event > StandardsCustomEvent . get ( 's' , { detail : null } ) ; this . jsCodeEditorDiv . dispatchEvent ( gtDoHighlightEvent ) ; } private removeHighlight ( ) { var gtRemoveHighlightEvent = < Event > StandardsCustomEvent . get ( 's' , { detail : null } ) ; this . jsCodeEditorDiv . dispatchEvent ( gtRemoveHighlightEvent ) ; } } }	O $any$ O $any$ O O O $any$ O $any$ O O $HTMLElement$ O $complex$ O O O O $void$ O O $IInputArea$ O $string$ O O O O O O O $void$ O O $IInputArea$ O $Selections$ O O O O O O O $void$ O O $IInputArea$ O O O O O O O $void$ O O $IInputArea$ O O O O O O O $void$ O O $IInputArea$ O O O O O O O $EventListener$ O $any$ O O O O $EventListener$ O $any$ O O O O $EventListener$ O $any$ O O O O $EventListener$ O $any$ O O O O $string$ O O O O O O $void$ O $HTMLElement$ O O O O $HTMLElement$ O O $complex$ O $HTMLElement$ O O $this$ O O O O O $EventListener$ O O O $CustomEvent$ O O O O $this$ O $string$ O $CustomEvent<any>$ O $any$ O $any$ O O O O O $this$ O $string$ O $CustomEvent<any>$ O $any$ O $any$ O O O $this$ O $void$ O O $this$ O $void$ O $this$ O $this$ O $string$ O O O O O O O O O $HTMLElement$ O O O O O O O $EventListener$ O O O O O O $EventListener$ O O O $CustomEvent$ O O O O $this$ O $string$ O $CustomEvent<any>$ O $any$ O $any$ O O O O O $this$ O $string$ O $CustomEvent<any>$ O $any$ O $any$ O O O $this$ O $void$ O O $this$ O $void$ O $this$ O O O O O O O $HTMLElement$ O O O O O O O $EventListener$ O O O O O O $EventListener$ O O O $Event$ O O O O $this$ O $void$ O O $this$ O $void$ O $this$ O O O O O O O $HTMLElement$ O O O O O O O $EventListener$ O O O O $void$ O O O O O $void$ O O O O O $HTMLElement$ O O O O O O O $EventListener$ O O O O $HTMLElement$ O O O O O O O $EventListener$ O O O O $HTMLElement$ O O O O O O O $EventListener$ O O O O $void$ O O O O O $void$ O O O O $Event$ O O $complex$ O $any$ O $CustomEvent<any>$ O O O O $null$ O O O O O O O $HTMLElement$ O $boolean$ O $Event$ O O O O $void$ O O O O $Event$ O O $complex$ O $any$ O $CustomEvent<any>$ O O O O $null$ O O O O O O O $HTMLElement$ O $boolean$ O $Event$ O O O O $void$ O $void$ O O $IInputArea$ O $string$ O O O O O O O $void$ O $void$ O O O $void$ O $void$ O O $IInputArea$ O $Selections$ O O O O O O O $void$ O $void$ O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $void$ O $void$ O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $void$ O $void$ O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $void$ O $void$ O O O $string$ O O O O O O $string$ O O O $void$ O $string$ O O O O O O $string$ O $string$ O O O O O O O $string$ O $string$ O O $complex$ O O $complex$ O O $string$ O O O $string$ O O O O $Event$ O O $complex$ O $any$ O $CustomEvent<any>$ O O O $complex$ O O O O $HTMLElement$ O $boolean$ O $Event$ O O O O $Selections$ O O O O O $any$ O O O $any$ O O O O O O O $void$ O $Selections$ O O O $complex$ O O $complex$ O O $any[]$ O $Selections$ O $any[]$ O O O O O O $Event$ O O $complex$ O $any$ O $CustomEvent<any>$ O O O $complex$ O O O O $HTMLElement$ O $boolean$ O $Event$ O O O O $TextChange$ O O O O O $any$ O O O $string$ O O O O O $Selections$ O O O $Selection[]$ O O O O O O $void$ O O O O $Event$ O O $complex$ O $any$ O $CustomEvent<any>$ O O O O $null$ O O O O O O O $HTMLElement$ O $boolean$ O $Event$ O O O O $void$ O O O O $Event$ O O $complex$ O $any$ O $CustomEvent<any>$ O O O O $null$ O O O O O O O $HTMLElement$ O $boolean$ O $Event$ O O O O O
module GhostText . InputArea { export class Selection { public constructor ( public start = 0 , public end = 0 ) { } public toJSON ( ) { return { start : this . start , end : this . end } ; } } }	O $any$ O $any$ O O O $any$ O O O O O $number$ O O O O $number$ O O O O O O $any$ O O O O O $number$ O O O $number$ O $number$ O O O $number$ O O O O O
module GhostText . InputArea { export class Selections { private selections : Array < Selection > ; public constructor ( selections < Selection > = [ ] ) { this . selections = selections ; } public add ( selection ) { this . selections . push ( selection ) ; } public getAll ( ) < Selection > { return this . selections ; } public getMinMaxSelection ( ) { var minMaxSelection = new Selection ( Number . MAX_VALUE , Number . MIN_VALUE ) ; for ( var i = this . selections . length - 0 ; i >= 0 ; i -- ) { minMaxSelection . start = Math . min ( minMaxSelection . start , this . selections [ i ] . start ) ; minMaxSelection . end = Math . max ( minMaxSelection . end , this . selections [ i ] . end ) ; } return minMaxSelection ; } public static fromPlainJS ( selections < any > ) { var newSelections < Selection > = [ ] ; for ( var i = selections . length - 0 ; i >= 0 ; i -- ) { newSelections . push ( new Selection ( selections [ i ] . start , selections [ i ] . end ) ) ; } return new Selections ( newSelections ) ; } public toJSON ( ) < any > { var returnValue < any > = [ ] ; for ( var i = this . selections . length - 0 ; i >= 0 ; i -- ) { returnValue . push ( this . selections [ i ] . toJSON ( ) ) ; } return returnValue ; } } }	O $any$ O $any$ O O O $any$ O O $Selection[]$ O $ArrayConstructor$ O $any$ O O O O O $Array$ O $any$ O O O O O O O O $Selection[]$ O $Selection[]$ O O O $void$ O $Selection$ O O O O $Selection[]$ O $number$ O $Selection$ O O O O $Array$ O O O $any$ O O O O O $Selection[]$ O O O $Selection$ O O O O $Selection$ O O $any$ O $NumberConstructor$ O $number$ O $NumberConstructor$ O $number$ O O O O O $number$ O O O $Selection[]$ O $number$ O O O $number$ O O O $number$ O O O $Selection$ O $number$ O $Math$ O $number$ O $Selection$ O $number$ O O O $Selection[]$ O $number$ O O $number$ O O $Selection$ O $number$ O $Math$ O $number$ O $Selection$ O $number$ O O O $Selection[]$ O $number$ O O $number$ O O O O $Selection$ O O O O $Selections$ O $Array$ O O O O O O $Array$ O $any$ O O O O O O O O $number$ O $any[]$ O $number$ O O O $number$ O O O $number$ O O O $Selection[]$ O $number$ O O $any$ O $any[]$ O $number$ O O $any$ O $any[]$ O $number$ O O $any$ O O O O O O $any$ O $Selection[]$ O O O O $Array$ O O O O O O O $Array$ O O O O O O O O O O $number$ O O O $Selection[]$ O $number$ O O O $number$ O O O $number$ O O O $any[]$ O $number$ O O O $Selection[]$ O $number$ O O $any$ O O O O O O $any[]$ O O O O
module GhostText . InputArea { declare function cloneInto ( detailData , window ) ; export class StandardsCustomEvent { static get ( eventType , data : { detail : any } ) { var customEvent = < any > CustomEvent ; var event = new customEvent ( eventType , data ) ; return < CustomEvent > event ; } } }	O $any$ O $any$ O O O $any$ O $any$ O $Window$ O O O O $any$ O O $CustomEvent$ O $string$ O $complex$ O O $any$ O O O O O O $any$ O O O O $complex$ O O $any$ O O $any$ O $string$ O $complex$ O O O O $complex$ O $any$ O O O O
module GhostText . InputArea { export class TextArea implements IInputArea { private textArea : HTMLTextAreaElement = null ; private textChangedEventCB : ( inputArea , text ) => void = null ; private selectionChangedEventCB : ( inputArea , selections ) => void = null ; private removeEventCB : ( inputArea ) => void = null ; private focusEventCB : ( inputArea ) => void = null ; private unloadEventCB : ( inputArea ) => void = null ; private customEventInput : Event = null ; private customKeyUpEvent : Event = null ; private inputEventListener : EventListener = null ; private focusEventListener : EventListener = null ; private beforeUnloadListener : EventListener = null ; private elementRemovedListener : EventListener = null ; public bind ( domElement ) { this . textArea = < HTMLTextAreaElement > domElement ; var that = this ; this . focusEventListener = function ( ) { if ( that . focusEventCB ) { that . focusEventCB ( that ) ; } that . highlight ( ) ; } ; this . textArea . addEventListener ( 's' , this . focusEventListener , false ) ; this . inputEventListener = function ( e ) { if ( e . detail && e . detail [ 's' ] ) { return ; } if ( that . textChangedEventCB ) { that . textChangedEventCB ( that , that . getText ( ) ) ; } } ; this . textArea . addEventListener ( 's' , this . inputEventListener , false ) ; this . elementRemovedListener = function ( ) { if ( that . textChangedEventCB ) { that . textChangedEventCB ( that , that . getText ( ) ) ; } } ; this . textArea . addEventListener ( 's' , this . elementRemovedListener , false ) ; this . beforeUnloadListener = function ( ) { if ( that . unloadEventCB ) { that . unloadEventCB ( that ) ; } } ; window . addEventListener ( 's' , this . beforeUnloadListener ) ; this . customEventInput = < Event > StandardsCustomEvent . get ( 's' , { detail : { generatedByGhostText : true } } ) ; this . customKeyUpEvent = this . createKeyboardEvent ( ) ; } private createKeyboardEvent ( type = 's' ) { var keyboardEvent = document . createEvent ( 's' ) ; var initMethod = typeof ( < any > keyboardEvent ) . initKeyboardEvent !== 's' ? 's' : 's' ; keyboardEvent [ initMethod ] ( type , true , true , window , false , false , false , false , 0 , 0 ) ; return keyboardEvent ; } public unbind ( ) { this . textArea . removeEventListener ( 's' , this . focusEventListener ) ; this . textArea . removeEventListener ( 's' , this . inputEventListener ) ; this . textArea . removeEventListener ( 's' , this . elementRemovedListener ) ; window . removeEventListener ( 's' , this . beforeUnloadListener ) ; this . removeHighlight ( ) ; } public focus ( ) { this . textArea . focus ( ) ; if ( this . focusEventCB ) { this . focusEventCB ( this ) ; } } public blur ( ) { this . textArea . blur ( ) ; } public textChangedEvent ( callback : ( inputArea , text ) => void ) { this . textChangedEventCB = callback ; } public selectionChangedEvent ( callback : ( inputArea , selections ) => void ) { this . selectionChangedEventCB = callback ; } public removeEvent ( callback : ( inputArea ) => void ) { this . removeEventCB = callback ; } public focusEvent ( callback : ( inputArea ) => void ) { this . focusEventCB = callback ; } public unloadEvent ( callback : ( inputArea ) => void ) { this . unloadEventCB = callback ; } public getText ( ) { return this . textArea . value ; } public setText ( text ) { this . textArea . value = text ; this . textArea . dispatchEvent ( this . customEventInput ) ; this . textArea . dispatchEvent ( this . customKeyUpEvent ) ; } public getSelections ( ) { return new Selections ( [ new Selection ( this . textArea . selectionStart , this . textArea . selectionEnd ) ] ) ; } public setSelections ( selections ) { var selection = selections . getMinMaxSelection ( ) ; this . textArea . selectionStart = selection . start ; this . textArea . selectionEnd = selection . end ; } public buildChange ( ) { return new TextChange ( this . getText ( ) , this . getSelections ( ) . getAll ( ) ) ; } private highlight ( ) { this . textArea . style . transition = 's' ; this . textArea . style . boxShadow = 's' ; } private removeHighlight ( ) { this . textArea . style . boxShadow = 's' ; } } }	O $any$ O $any$ O O O $any$ O $any$ O O $HTMLTextAreaElement$ O $complex$ O O O O $void$ O O $IInputArea$ O $string$ O O O O O O O $void$ O O $IInputArea$ O $Selections$ O O O O O O O $void$ O O $IInputArea$ O O O O O O O $void$ O O $IInputArea$ O O O O O O O $void$ O O $IInputArea$ O O O O O O O $Event$ O $complex$ O O O O $Event$ O $complex$ O O O O $EventListener$ O $any$ O O O O $EventListener$ O $any$ O O O O $EventListener$ O $any$ O O O O $EventListener$ O $any$ O O O O $void$ O $HTMLElement$ O O O O $HTMLTextAreaElement$ O O $complex$ O $HTMLElement$ O O $this$ O O O O O $EventListener$ O O O O O O O $this$ O $void$ O O $this$ O $void$ O $this$ O O O $this$ O $void$ O O O O O O O $HTMLTextAreaElement$ O O O O O O O $EventListener$ O O O O O O $EventListener$ O O O $UIEvent$ O O O O $UIEvent$ O $number$ O $UIEvent$ O $number$ O O O O O O O O O O $this$ O $void$ O O $this$ O $void$ O $this$ O $this$ O $string$ O O O O O O O O O $HTMLTextAreaElement$ O O O O O O O $EventListener$ O O O O O O $EventListener$ O O O O O O O $this$ O $void$ O O $this$ O $void$ O $this$ O $this$ O $string$ O O O O O O O O O $HTMLTextAreaElement$ O O O O O O O $EventListener$ O O O O O O $EventListener$ O O O O O O O $this$ O $void$ O O $this$ O $void$ O $this$ O O O O O $complex$ O O O O O O O $EventListener$ O O O O $Event$ O O $complex$ O $any$ O $CustomEvent<any>$ O O O O $complex$ O O $boolean$ O O O O O O O O $Event$ O O O $Event$ O O O O O $Event$ O $string$ O O O O O $Event$ O $Document$ O $complex$ O O O O O $string$ O O O O O O $Event$ O O $any$ O O O O O O O $Event$ O $string$ O O $string$ O O O O O $complex$ O O O O O O O O O O O O O O O $Event$ O O O $void$ O O O O O $HTMLTextAreaElement$ O O O O O O O $EventListener$ O O O O $HTMLTextAreaElement$ O O O O O O O $EventListener$ O O O O $HTMLTextAreaElement$ O O O O O O O $EventListener$ O O $complex$ O O O O O O O $EventListener$ O O O O $void$ O O O O O $void$ O O O O O $HTMLTextAreaElement$ O $void$ O O O O O O O $void$ O O O O $void$ O O O O O O O $void$ O O O O O $HTMLTextAreaElement$ O $void$ O O O O O $void$ O $void$ O O $IInputArea$ O $string$ O O O O O O O $void$ O $void$ O O O $void$ O $void$ O O $IInputArea$ O $Selections$ O O O O O O O $void$ O $void$ O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $void$ O $void$ O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $void$ O $void$ O O O $void$ O $void$ O O $IInputArea$ O O O O O O O $void$ O $void$ O O O $string$ O O O O O O $HTMLTextAreaElement$ O $string$ O O O $void$ O $string$ O O O O $HTMLTextAreaElement$ O $string$ O $string$ O O O $HTMLTextAreaElement$ O $boolean$ O O O $Event$ O O O O $HTMLTextAreaElement$ O $boolean$ O O O $Event$ O O O O $Selections$ O O O O O $any$ O O O $any$ O O O $HTMLTextAreaElement$ O $number$ O O O $HTMLTextAreaElement$ O $number$ O O O O O O $void$ O $Selections$ O O O $Selection$ O $Selections$ O $Selection$ O O O O O $HTMLTextAreaElement$ O $number$ O $Selection$ O $number$ O O O $HTMLTextAreaElement$ O $number$ O $Selection$ O $number$ O O O $TextChange$ O O O O O $any$ O O O $string$ O O O O O $Selections$ O O O $Selection[]$ O O O O O O $void$ O O O O O $HTMLTextAreaElement$ O $CSSStyleDeclaration$ O $string$ O O O O O $HTMLTextAreaElement$ O $CSSStyleDeclaration$ O $string$ O O O O O $void$ O O O O O $HTMLTextAreaElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O
module GhostText . InputArea { export class TextChange { public constructor ( public text = null , public selections < Selection > = [ ] , public title = window . document . title , public url = location . host , public syntax = 's' ) { } } }	O $any$ O $any$ O O O $any$ O O O O O $string$ O O O O $Array$ O $any$ O O O O O O $string$ O $complex$ O $Document$ O $string$ O O $string$ O $Location$ O $string$ O O $string$ O O O O O O O
'js' GhostText . connectionHandler ( ) ;	O $any$ O $any$ O O O
'js' 's' ; var GhostTextContent = { tabId : null , port : null , currentInputArea : null , messageHandler : function ( request ) { console . log ( 's' , request ) ; if ( ! request || ! request . action || ! request . tabId ) { return ; } GhostTextContent . tabId = request . tabId ; switch ( request . action ) { case 's' : GhostTextContent . selectField ( ) ; break ; case 's' : GhostTextContent . enableField ( ) ; break ; case 's' : GhostTextContent . disableField ( ) ; break ; case 's' : switch ( request . type ) { case 's' : if ( GhostTextContent . currentInputArea !== null ) { GhostTextContent . currentInputArea . unbind ( ) ; } GhostTextContent . alertUser ( request . message , request . stay ) ; break ; default : GhostTextContent . informUser ( request . message , request . stay ) ; break ; } break ; } } , informUser : function ( message , stay ) { console . info ( 's' , message ) ; GThumane . remove ( ) ; message = message . replace ( "s" , 's' ) ; var timeout = stay ? 0 : GhostTextContent . getMessageDisplayTime ( message ) ; GThumane . log ( message , { timeout : timeout , clickToClose : true } ) ; } , alertUser : function ( message , stay ) { console . warn ( 's' , message ) ; GThumane . remove ( ) ; message = message . replace ( "s" , 's' ) ; var timeout = stay ? 0 : GhostTextContent . getMessageDisplayTime ( message ) ; GThumane . log ( message , { timeout : timeout , clickToClose : true , addnCls : 's' } ) ; } , getMessageDisplayTime : function ( message ) { var wpm = 0 ; return message . split ( 's' ) . length / wpm * 0 ; } , disableField : function ( ) { console . log ( 's' ) ; if ( GhostTextContent . currentInputArea === null ) { return ; } GhostTextContent . currentInputArea . unbind ( ) ; GhostTextContent . currentInputArea = null ; GhostTextContent . informUser ( 's' ) ; } , selectField : function ( ) { console . log ( 's' ) ; var detector = new GhostText . InputArea . Detector ( ) ; detector . focusEvent ( function ( inputArea ) { console . log ( 's' ) ; GhostTextContent . currentInputArea = inputArea ; GhostTextContent . port = chrome . runtime . connect ( { name : 's' } ) ; GhostTextContent . reportFieldData ( ) ; } ) ; var countElementsFound = detector . detect ( document ) ; if ( countElementsFound === 0 ) { GhostTextContent . alertUser ( 's' ) ; } else if ( countElementsFound > 0 ) { GhostTextContent . informUser ( 's' , true ) ; } } , enableField : function ( ) { console . log ( 's' ) ; var inputArea = GhostTextContent . currentInputArea ; GhostTextContent . informUser ( 's' ) ; inputArea . textChangedEvent ( function ( ) { GhostTextContent . reportFieldData ( ) ; } ) ; inputArea . removeEvent ( function ( ) { GhostTextContent . requestServerDisconnection ( ) ; } ) ; inputArea . unloadEvent ( function ( ) { GhostTextContent . requestServerDisconnection ( ) ; } ) ; inputArea . focusEvent ( null ) ; inputArea . selectionChangedEvent ( null ) ; GhostTextContent . port . onMessage . addListener ( function ( msg ) { if ( msg . tabId !== GhostTextContent . tabId ) { return ; } var response = JSON . parse ( msg . change ) ; GhostTextContent . currentInputArea . setText ( response . text ) ; GhostTextContent . currentInputArea . setSelections ( GhostText . InputArea . Selections . fromPlainJS ( response . selections ) ) ; } ) ; } , reportFieldData : function ( ) { console . log ( 's' ) ; if ( GhostTextContent . currentInputArea === null ) { throw 's' ; } if ( GhostTextContent . port === null ) { throw 's' ; } var textChange = GhostTextContent . currentInputArea . buildChange ( ) ; GhostTextContent . port . postMessage ( { change : JSON . stringify ( textChange ) , tabId : GhostTextContent . tabId } ) ; } , requestServerDisconnection : function ( ) { console . log ( 's' ) ; chrome . extension . sendMessage ( { action : 's' , tabId : GhostTextContent . tabId } ) ; } } ; chrome . runtime . onMessage . addListener ( GhostTextContent . messageHandler ) ;	O O O O O O O $number$ O O O $any$ O O O $any$ O O O $void$ O O O $any$ O O $Console$ O $void$ O O O $any$ O O O O O $any$ O O $any$ O $any$ O O $any$ O $any$ O O O O O O O $number$ O $any$ O $any$ O O O $any$ O $any$ O O O O O O O $void$ O O O O O O O O O O $void$ O O O O O O O O O O $void$ O O O O O O O O O O $any$ O $any$ O O O O O O O O O $any$ O O O O O O $any$ O $any$ O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O $void$ O $any$ O $any$ O $any$ O $any$ O O O O O O O O O O $void$ O O O $string$ O $boolean$ O O $Console$ O $void$ O O O $string$ O O $any$ O $any$ O O O $string$ O $string$ O $complex$ O O O O O O O $number$ O $boolean$ O O O O O $number$ O $string$ O O $any$ O $any$ O $string$ O O $number$ O $number$ O $boolean$ O O O O O O O $void$ O O O $string$ O $boolean$ O O $Console$ O $void$ O O O $string$ O O $any$ O $any$ O O O $string$ O $string$ O $complex$ O O O O O O O $number$ O $boolean$ O O O O O $number$ O $string$ O O $any$ O $any$ O $string$ O O $number$ O $number$ O $boolean$ O O O $string$ O O O O O O O $number$ O O O $string$ O O O $number$ O O O O $string$ O $complex$ O O O O $number$ O $number$ O O O O O $void$ O O O O O $Console$ O $void$ O O O O O O O O $any$ O O O O O O O O O $any$ O $any$ O O O O O $any$ O O O O O $void$ O O O O O O $void$ O O O O O $Console$ O $void$ O O O O O $Detector$ O O $any$ O $any$ O $any$ O O O $Detector$ O $void$ O O O $IInputArea$ O O $Console$ O $void$ O O O O O O $any$ O $IInputArea$ O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O O O O O $void$ O O O O O O O $number$ O $Detector$ O $number$ O $Document$ O O O O $number$ O O O O O O $void$ O O O O O O O O $number$ O O O O O O $void$ O O O O O O O O O $void$ O O O O O $Console$ O $void$ O O O O O $any$ O O O $any$ O O O $void$ O O O O $any$ O $any$ O O O O O O O $void$ O O O O O O $any$ O $any$ O O O O O O O $void$ O O O O O O $any$ O $any$ O O O O O O O $void$ O O O O O O $any$ O $any$ O O O O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O $any$ O O O $number$ O O O O O O $complex$ O $JSON$ O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $complex$ O $complex$ O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $Selections$ O $complex$ O $complex$ O O O O O O O O $void$ O O O O O $Console$ O $void$ O O O O O O O O $any$ O O O O O O O O O O O O $any$ O O O O O O O O O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O O $string$ O $JSON$ O $complex$ O $any$ O O $number$ O O O $number$ O O O O O $void$ O O O O O $Console$ O $void$ O O O O $any$ O $any$ O $any$ O O $string$ O O O $number$ O O O $number$ O O O O O O $any$ O $any$ O $any$ O $any$ O O O $void$ O O
'js' 's' ; var GhostText = { protocolVersion : 0 , connections : { } , inCurrentTab : function ( callback ) { chrome . tabs . query ( { active : true , currentWindow : true } , function ( tabs ) { callback ( tabs [ 0 ] . id ) ; } ) ; } , serverPort : function ( port ) { if ( ! port ) { return localStorage . getItem ( 's' ) || 0 ; } localStorage . setItem ( 's' , port ) ; } , loadContentJs : function ( tabId , callback ) { chrome . tabs . executeScript ( tabId , { code : 's' } , function ( hasContentJs ) { if ( hasContentJs [ 0 ] ) { callback ( ) ; } else { chrome . tabs . insertCSS ( tabId , { file : 's' } ) ; chrome . tabs . executeScript ( tabId , { file : 's' } ) ; chrome . tabs . executeScript ( tabId , { file : 's' } ) ; chrome . tabs . executeScript ( tabId , { file : 's' } , callback ) ; } } ) ; } , connectionHandler : function ( ) { chrome . runtime . onConnect . addListener ( GhostText . connectionHandlerOnConnect ) ; chrome . runtime . onMessage . addListener ( GhostText . messageHandler ) ; chrome . browserAction . onClicked . addListener ( GhostText . toggleCurrentTab ) ; chrome . commands . onCommand . addListener ( function ( command ) { if ( command === 's' ) { GhostText . toggleCurrentTab ( ) ; } } ) ; } , toggleCurrentTab : function ( ) { GhostText . inCurrentTab ( function ( tabId ) { GhostText . loadContentJs ( tabId , function ( ) { if ( GhostText . connections [ tabId ] ) { GhostText . closeConnection ( tabId ) ; } else { chrome . tabs . sendMessage ( tabId , { action : 's' , tabId : tabId } ) ; } } ) ; } ) ; } , connectionHandlerOnConnect : function ( port ) { if ( port . name !== 's' ) { return ; } port . onMessage . addListener ( function ( msg ) { var tabId = msg . tabId ; if ( GhostText . connections [ tabId ] && GhostText . connections [ tabId ] . readyState === 0 ) { GhostText . connections [ tabId ] . send ( msg . change ) ; return ; } fetch ( 's' + GhostText . serverPort ( ) ) . then ( r => r . json ( ) ) . then ( ( { ProtocolVersion , WebSocketPort } ) => { if ( ! GhostText . checkProtocolVersion ( ProtocolVersion ) ) { return ; } try { GhostText . connections [ tabId ] = new WebSocket ( 's' + WebSocketPort ) ; } catch ( e ) { GhostText . errorHandler ( e ) ; return ; } GhostText . connections [ tabId ] . onopen = function ( ) { chrome . browserAction . setBadgeText ( { text : "s" . test ( navigator . userAgent ) ? 's' : 's' , tabId : tabId } ) ; chrome . browserAction . setBadgeBackgroundColor ( { color : 's' , tabId : tabId } ) ; GhostText . connections [ tabId ] . send ( msg . change ) ; console . log ( 's' ) ; chrome . tabs . sendMessage ( tabId , { action : 's' , tabId : tabId } ) ; } ; GhostText . connections [ tabId ] . onclose = function ( ) { GhostText . closeConnection ( tabId ) ; } ; GhostText . connections [ tabId ] . onerror = function ( event ) { GhostText . closeConnection ( tabId ) ; console . log ( 's' , event ) ; GhostText . errorHandler ( event ) ; } ; GhostText . connections [ tabId ] . onmessage = function ( event ) { port . postMessage ( { tabId : tabId , change : event . data } ) ; } ; } ) . catch ( GhostText . errorHandler ) ; } ) ; } , closeConnection : function ( tabId ) { if ( ! GhostText . connections [ tabId ] ) { return false ; } if ( GhostText . connections [ tabId ] . readyState !== 0 ) { try { GhostText . connections [ tabId ] . close ( ) ; } catch ( e ) { console . log ( 's' , e ) ; } } delete GhostText . connections [ tabId ] ; console . log ( 's' ) ; try { chrome . tabs . sendMessage ( tabId , { action : 's' , tabId : tabId } ) ; chrome . browserAction . setBadgeText ( { text : 's' , tabId : tabId } ) ; chrome . tabs . get ( tabId , function ( tab ) { chrome . windows . update ( tab . windowId , { focused : true } ) ; chrome . tabs . update ( tabId , { active : true } ) ; } ) ; } catch ( e ) { } return true ; } , errorHandler : function ( e ) { if ( e && ( e . target && e . target . readyState === 0 ) || e . status === 0 || e . status === 0 ) { GhostText . notifyUser ( 's' , 's' , 's' , 's' , 's' , 's' ) ; } } , checkProtocolVersion : function ( version ) { version = parseFloat ( version ) ; if ( version === GhostText . protocolVersion ) { return true ; } GhostText . notifyUser ( 's' , 's' , version , 's' , GhostText . protocolVersion ) ; return false ; } , messageHandler : function ( request ) { if ( ! request || ! request . action ) { return ; } switch ( request . action ) { case 's' : GhostText . closeConnection ( request . tabId ) ; break ; } } , notifyUser : function ( type , message ) { message = [ ] . slice . call ( arguments , 0 ) . join ( 's' ) ; GhostText . inCurrentTab ( function ( tabId ) { chrome . tabs . sendMessage ( tabId , { tabId : tabId , type : type , action : 's' , message : message } ) ; } ) ; } } ;	O O O O O O O $number$ O O O $WebSocket[]$ O O O O $void$ O O O $Function$ O O $any$ O $any$ O $any$ O O $boolean$ O O O $boolean$ O O O O O O $any$ O O $Function$ O $any$ O O O O $any$ O O O O O O O $number$ O O O $number$ O O O O O $number$ O O O $Storage$ O $string$ O O O O O O O $Storage$ O $void$ O O O $number$ O O O O $void$ O O O $number$ O $Function$ O O $any$ O $any$ O $any$ O $number$ O O $string$ O O O O O O $any$ O O O O $any$ O O O O O $Function$ O O O O O O $any$ O $any$ O $any$ O $number$ O O $string$ O O O O O $any$ O $any$ O $any$ O $number$ O O $string$ O O O O O $any$ O $any$ O $any$ O $number$ O O $string$ O O O O O $any$ O $any$ O $any$ O $number$ O O $string$ O O O O $Function$ O O O O O O O O $void$ O O O O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $any$ O $any$ O O O $any$ O O O O $any$ O O O O $any$ O $any$ O O O O O O O O O $void$ O O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O $string$ O O O $any$ O $any$ O O O O O O O O O O O O $void$ O O O $any$ O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O $any$ O O O $string$ O $any$ O $any$ O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $string$ O O $any$ O O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O O O O $Promise<Response>$ O O O $any$ O $any$ O O O O O O $Response$ O $Response$ O $Promise<any>$ O O O O O O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O O O O O O O O $any$ O $any$ O $string$ O O O $complex$ O O O $any$ O O O O O $any$ O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $string$ O O $any$ O O O O O $any$ O $any$ O $any$ O O $string$ O O O $boolean$ O $Navigator$ O $string$ O O O O O O $string$ O $string$ O O O $any$ O $any$ O $any$ O O $string$ O O O $string$ O $string$ O O O $any$ O $any$ O $string$ O O $any$ O $any$ O $any$ O O $Console$ O $void$ O O O O $any$ O $any$ O $any$ O $string$ O O $string$ O O O $string$ O $string$ O O O O O $any$ O $any$ O $string$ O O $any$ O O O O O $any$ O $any$ O $string$ O O O O $any$ O $any$ O $string$ O O $any$ O O O $any$ O O $any$ O $any$ O $string$ O O $Console$ O $void$ O O O $any$ O O $any$ O $any$ O $any$ O O O O $any$ O $any$ O $string$ O O $any$ O O O $any$ O O $any$ O $any$ O O $string$ O $string$ O $any$ O $any$ O $any$ O O O O O O O O $complex$ O $any$ O $any$ O O O O O O O $boolean$ O O O $number$ O O O O O $any$ O $any$ O $number$ O O O O O O O O O $any$ O $any$ O $number$ O O $any$ O O O O O O $any$ O $any$ O $number$ O O $any$ O O O O O O $any$ O O $Console$ O $void$ O O O $any$ O O O O O $any$ O $any$ O $number$ O O $Console$ O $void$ O O O O O O $any$ O $any$ O $any$ O $number$ O O $string$ O O O $number$ O $number$ O O O $any$ O $any$ O $any$ O O $string$ O O O $number$ O $number$ O O O $any$ O $any$ O $any$ O $number$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O $any$ O O $boolean$ O O O O O $any$ O $any$ O $any$ O $number$ O O $boolean$ O O O O O O O O O O O $any$ O O O O O O O O $void$ O O O $Error$ O O O O $Error$ O O $Error$ O $any$ O $Error$ O $any$ O $any$ O O O O $Error$ O $any$ O O O $Error$ O $any$ O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O $boolean$ O O O $number$ O O $number$ O $number$ O $number$ O O O O $number$ O $any$ O $any$ O O O O O O $any$ O $any$ O O O O O $number$ O O O $any$ O $any$ O O O O O O O $void$ O O O $any$ O O O O O $any$ O O $any$ O $any$ O O O O O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O $any$ O O O O O O O $void$ O O O $string$ O $complex$ O O $complex$ O O O O $undefined[]$ O $any$ O $IArguments$ O O O O $any$ O O O O $any$ O $any$ O O O $any$ O O $any$ O $any$ O $any$ O $any$ O O $any$ O $any$ O $string$ O $string$ O $string$ O O O $complex$ O $complex$ O O O O O O O O O
'js' var serverPortInput = document . getElementById ( 's' ) ; var initialServerPort = GhostText . serverPort ( ) ; if ( initialServerPort !== serverPortInput . placeholder ) { serverPortInput . value = initialServerPort ; } serverPortInput . addEventListener ( 's' , function ( ) { GhostText . serverPort ( serverPortInput . value || 0 ) ; } ) ; document . getElementById ( 's' ) . textContent = chrome . runtime . getManifest ( ) . version ;	O O $Element$ O $Document$ O $HTMLElement$ O O O O O $number$ O $any$ O $any$ O O O O O $number$ O $Element$ O $any$ O O $Element$ O $any$ O $number$ O O $Element$ O $complex$ O O O O O O O $any$ O $any$ O $Element$ O $any$ O O O O O O O $Document$ O $HTMLElement$ O O O O $string$ O $any$ O $any$ O $any$ O O O $any$ O
'js' ! function ( t , e , i ) { "s" != typeof module ? module . exports = i ( t , e ) : "s" == typeof define && "s" == typeof define . amd ? define ( i ) : e [ t ] = i ( t , e ) } ( "s" , this , function ( ) { var t = window , e = document , i = { on : function ( e , i , n ) { "s" in t ? e . addEventListener ( i , n , ! 0 ) : e . attachEvent ( "s" + i , n ) } , off : function ( e , i , n ) { "s" in t ? e . removeEventListener ( i , n , ! 0 ) : e . detachEvent ( "s" + i , n ) } , bind : function ( t , e ) { return function ( ) { t . apply ( e , arguments ) } } , isArray : Array . isArray || function ( t ) { return "s" === Object . prototype . toString . call ( t ) } , config : function ( t , e ) { return null != t ? t : e } , transSupport : ! 0 , useFilter : "s" . test ( navigator . userAgent ) , _checkTransition : function ( ) { var t = e . createElement ( "s" ) , i = { webkit : "s" , Moz : "s" , O : "s" , ms : "s" } ; for ( var n in i ) n + "s" in t . style && ( this . vendorPrefix = i [ n ] , this . transSupport = ! 0 ) } } ; i . _checkTransition ( ) ; var n = function ( e ) { e || ( e = { } ) , this . queue = [ ] , this . baseCls = e . baseCls || "s" , this . addnCls = e . addnCls || "s" , this . timeout = "s" in e ? e . timeout : 0 , this . waitForMove = e . waitForMove || ! 0 , this . clickToClose = e . clickToClose || ! 0 , this . timeoutAfterMove = e . timeoutAfterMove || ! 0 , this . container = e . container ; try { this . _setupEl ( ) } catch ( n ) { i . on ( t , "s" , i . bind ( this . _setupEl , this ) ) } } ; return n . prototype = { constructor : n , _setupEl : function ( ) { var t = e . createElement ( "s" ) ; if ( t . style . display = "s" , ! this . container ) { if ( ! e . body ) throw "s" ; this . container = e . body } this . container . appendChild ( t ) , this . el = t , this . removeEvent = i . bind ( function ( ) { this . timeoutAfterMove ? setTimeout ( i . bind ( this . remove , this ) , this . timeout ) : this . remove ( ) } , this ) , this . transEvent = i . bind ( this . _afterAnimation , this ) , this . _run ( ) } , _afterTimeout : function ( ) { i . config ( this . currentMsg . waitForMove , this . waitForMove ) ? this . removeEventsSet || ( i . on ( e . body , "s" , this . removeEvent ) , i . on ( e . body , "s" , this . removeEvent ) , i . on ( e . body , "s" , this . removeEvent ) , i . on ( e . body , "s" , this . removeEvent ) , this . removeEventsSet = ! 0 ) : this . remove ( ) } , _run : function ( ) { if ( ! this . _animating && this . queue . length && this . el ) { this . _animating = ! 0 , this . currentTimer && ( clearTimeout ( this . currentTimer ) , this . currentTimer = null ) ; var t = this . queue . shift ( ) , e = i . config ( t . clickToClose , this . clickToClose ) ; e && ( i . on ( this . el , "s" , this . removeEvent ) , i . on ( this . el , "s" , this . removeEvent ) ) ; var n = i . config ( t . timeout , this . timeout ) ; n > 0 && ( this . currentTimer = setTimeout ( i . bind ( this . _afterTimeout , this ) , n ) ) , i . isArray ( t . html ) && ( t . html = "s" + t . html . join ( "s" ) + "s" ) , this . el . innerHTML = t . html , this . currentMsg = t , this . el . className = this . baseCls , i . transSupport ? ( this . el . style . display = "s" , setTimeout ( i . bind ( this . _showMsg , this ) , 0 ) ) : this . _showMsg ( ) } } , _setOpacity : function ( t ) { if ( i . useFilter ) try { this . el . filters . item ( "s" ) . Opacity = 0 * t } catch ( e ) { } else this . el . style . opacity = String ( t ) } , _showMsg : function ( ) { var t = i . config ( this . currentMsg . addnCls , this . addnCls ) ; if ( i . transSupport ) this . el . className = this . baseCls + "s" + t + "s" + this . baseCls + "s" ; else { var e = 0 ; this . el . className = this . baseCls + "s" + t + "s" + this . baseCls + "s" , this . _setOpacity ( 0 ) , this . el . style . display = "s" ; var n = this , s = setInterval ( function ( ) { 0 > e ? ( e += 0 , e > 0 && ( e = 0 ) , n . _setOpacity ( e ) ) : clearInterval ( s ) } , 0 ) } } , _hideMsg : function ( ) { var t = i . config ( this . currentMsg . addnCls , this . addnCls ) ; if ( i . transSupport ) this . el . className = this . baseCls + "s" + t , i . on ( this . el , i . vendorPrefix ? i . vendorPrefix + "s" : "s" , this . transEvent ) ; else var e = 0 , n = this , s = setInterval ( function ( ) { e > 0 ? ( e -= 0 , 0 > e && ( e = 0 ) , n . _setOpacity ( e ) ) : ( n . el . className = n . baseCls + "s" + t , clearInterval ( s ) , n . _afterAnimation ( ) ) } , 0 ) } , _afterAnimation : function ( ) { i . transSupport && i . off ( this . el , i . vendorPrefix ? i . vendorPrefix + "s" : "s" , this . transEvent ) , this . currentMsg . cb && this . currentMsg . cb ( ) , this . el . style . display = "s" , this . _animating = ! 0 , this . _run ( ) } , remove : function ( t ) { var n = "s" == typeof t ? t : null ; i . off ( e . body , "s" , this . removeEvent ) , i . off ( e . body , "s" , this . removeEvent ) , i . off ( e . body , "s" , this . removeEvent ) , i . off ( e . body , "s" , this . removeEvent ) , i . off ( this . el , "s" , this . removeEvent ) , i . off ( this . el , "s" , this . removeEvent ) , this . removeEventsSet = ! 0 , n && this . currentMsg && ( this . currentMsg . cb = n ) , this . _animating ? this . _hideMsg ( ) : n && n ( ) } , log : function ( t , e , i , n ) { var s = { } ; if ( n ) for ( var o in n ) s [ o ] = n [ o ] ; if ( "s" == typeof e ) i = e ; else if ( e ) for ( var o in e ) s [ o ] = e [ o ] ; return s . html = t , i && ( s . cb = i ) , this . queue . push ( s ) , this . _run ( ) , this } , spawn : function ( t ) { var e = this ; return function ( i , n , s ) { return e . log . call ( e , i , n , s , t ) , e } } , create : function ( t ) { return new n ( t ) } } , new n } ) ;	O O O O $string$ O $complex$ O $complex$ O O O O O O O $complex$ O $complex$ O $complex$ O $string$ O $complex$ O O O O O $any$ O O O O $any$ O $any$ O $any$ O $complex$ O O $complex$ O $string$ O O $complex$ O $string$ O $complex$ O O O O O O O O O O O O $complex$ O $complex$ O $Document$ O $Document$ O $complex$ O O $void$ O O O $any$ O $any$ O $any$ O O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $void$ O O O $any$ O $any$ O $any$ O O O O $complex$ O $any$ O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O O O $any$ O $any$ O O O $void$ O O O $any$ O $any$ O O O O O O O $any$ O $any$ O $any$ O $IArguments$ O O O O $boolean$ O $ArrayConstructor$ O $complex$ O O O $any$ O O O O O $ObjectConstructor$ O $Object$ O $string$ O $any$ O $any$ O O O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O $boolean$ O O O O $boolean$ O O O $boolean$ O $Navigator$ O $string$ O O $any$ O O O O O O $HTMLDivElement$ O $Document$ O O O O O O $complex$ O O $string$ O O O $string$ O O O $string$ O O O $string$ O O O O O O O $string$ O $complex$ O $string$ O O O $HTMLDivElement$ O $CSSStyleDeclaration$ O O O O $any$ O $complex$ O $string$ O O O O $boolean$ O O O O O O O $complex$ O $any$ O O O O $any$ O O O $any$ O O $any$ O O $any$ O O O O O O O $any[]$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O $any$ O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O O $any$ O $any$ O $any$ O O O O O $any$ O O O O O $any$ O O $complex$ O $void$ O $complex$ O O O $complex$ O $void$ O O O $any$ O O O O O O O O $any$ O $complex$ O O $any$ O $any$ O $any$ O O O O O O $HTMLDivElement$ O $Document$ O O O O O O O O $HTMLDivElement$ O $CSSStyleDeclaration$ O $string$ O O O O O O $any$ O O O O O $Document$ O $HTMLElement$ O O O O O O $HTMLElement$ O $Document$ O $HTMLElement$ O O O $any$ O $any$ O $HTMLDivElement$ O O O O $HTMLDivElement$ O $HTMLDivElement$ O O O $void$ O $complex$ O $void$ O O O O O O O $any$ O $number$ O $complex$ O $void$ O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O O O O O $void$ O $complex$ O $void$ O O O $any$ O O O O O O $any$ O O O O $any$ O O O O O $complex$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O $any$ O O $complex$ O $void$ O $Document$ O $HTMLElement$ O O O O O $any$ O O $complex$ O $void$ O $Document$ O $HTMLElement$ O O O O O $any$ O O $complex$ O $void$ O $Document$ O $HTMLElement$ O O O O O $any$ O O $complex$ O $void$ O $Document$ O $HTMLElement$ O O O O O $any$ O O O O $boolean$ O O O O O O O $any$ O O O O $any$ O O O O O O O O O O $any$ O O O $any[]$ O $number$ O O O $any$ O O O O $boolean$ O O O O O O $any$ O O $void$ O O O $any$ O O O O $number$ O O O O O $any$ O O O $any[]$ O $any$ O O O $any$ O $complex$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O $complex$ O $void$ O O O $any$ O O O O O $any$ O O $complex$ O $void$ O O O $any$ O O O O O $any$ O O O O $any$ O $complex$ O $any$ O $any$ O $any$ O O O $any$ O O $any$ O O O O O O $number$ O $number$ O $complex$ O $void$ O O O $any$ O O O O $any$ O O O $complex$ O $boolean$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O $any$ O O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $any$ O O O $any$ O $complex$ O $boolean$ O O O O $any$ O $any$ O $any$ O O O $number$ O $complex$ O $void$ O O O $void$ O O O O O O O O O O $void$ O O O O O $void$ O O O $any$ O O O O $complex$ O $boolean$ O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O O O O $any$ O $any$ O $any$ O $StringConstructor$ O $any$ O O O $void$ O O O O O O $any$ O $complex$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O $complex$ O $boolean$ O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O $any$ O O O O O O $number$ O O O O O $any$ O $any$ O O O $any$ O O O $any$ O O O O O $any$ O O O O O $void$ O O O O O O $any$ O $any$ O $any$ O O O O $complex$ O O O $number$ O $number$ O O O O O O O $number$ O O $number$ O O O $number$ O O O O $number$ O O O O $complex$ O $void$ O $number$ O O O $void$ O $number$ O O O O O O O O $void$ O O O O O O $any$ O $complex$ O $any$ O O O $any$ O $any$ O O O $any$ O O O O $complex$ O $boolean$ O O O $any$ O $any$ O O O $any$ O O O $any$ O $complex$ O $void$ O O O $any$ O $complex$ O $any$ O $complex$ O $any$ O O O O O O O $any$ O O O O $number$ O O O $complex$ O O O $number$ O $number$ O O O O O $number$ O O O O $number$ O O O O O $number$ O O $number$ O O O O $complex$ O $void$ O $number$ O O O O $complex$ O $any$ O $any$ O $complex$ O $any$ O O O $any$ O $void$ O $number$ O O $complex$ O $any$ O O O O O O O O O $any$ O O O O O $complex$ O $boolean$ O $complex$ O $void$ O O O $any$ O $complex$ O $any$ O $complex$ O $any$ O O O O O O O $any$ O O O O $any$ O $any$ O O O $any$ O $any$ O O O O O $any$ O $any$ O $any$ O O O O O $boolean$ O O O O O O $any$ O O O O $any$ O O O $any$ O O O $any$ O O O O $any$ O $any$ O O O $complex$ O $void$ O $Document$ O $HTMLElement$ O O O O O $any$ O O $complex$ O $void$ O $Document$ O $HTMLElement$ O O O O O $any$ O O $complex$ O $void$ O $Document$ O $HTMLElement$ O O O O O $any$ O O $complex$ O $void$ O $Document$ O $HTMLElement$ O O O O O $any$ O O $complex$ O $void$ O O O $any$ O O O O O $any$ O O $complex$ O $void$ O O O $any$ O O O O O $any$ O O O O $boolean$ O O O O $any$ O O O $any$ O O O O $any$ O $any$ O $any$ O O O O $any$ O O O $void$ O O O $any$ O $any$ O O O O O O O O $any$ O $any$ O $any$ O $any$ O O O $complex$ O O O O O O $any$ O O O O $string$ O $any$ O $complex$ O $string$ O O $any$ O $string$ O O O O O O O $any$ O $any$ O $any$ O O O O $any$ O O O O $string$ O $any$ O $complex$ O $string$ O O $any$ O $string$ O O O $complex$ O $any$ O $any$ O $any$ O O $complex$ O $any$ O $any$ O O O O $any[]$ O $number$ O $complex$ O O O O $any$ O O O O O O O O O O $any$ O O O $complex$ O O O O O O $any$ O $any$ O $any$ O O O $complex$ O O O $any$ O $complex$ O $any$ O $any$ O $any$ O $any$ O O $complex$ O O O $complex$ O O O $any$ O O O O $any$ O $any$ O O O O O $any$ O O O