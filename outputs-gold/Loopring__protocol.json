'js' var Migrations = artifacts . require ( "s" ) ; module . exports = function ( deployer ) { deployer . deploy ( Migrations ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' var TokenRegistryImpl = artifacts . require ( "s" ) ; var TokenTransferDelegateImpl = artifacts . require ( "s" ) ; var TokenFactoryImpl = artifacts . require ( "s" ) ; module . exports = function ( deployer , network , accounts ) { deployer . deploy ( TokenTransferDelegateImpl ) ; deployer . deploy ( TokenRegistryImpl ) ; deployer . deploy ( TokenFactoryImpl ) ; } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { development : [ { decimals : 0 , name : "s" , symbol : "s" , } , { decimals : 0 , name : "s" , symbol : "s" , } , { decimals : 0 , name : "s" , symbol : "s" , } , { decimals : 0 , name : "s" , symbol : "s" , } , { decimals : 0 , name : "s" , symbol : "s" , } , ] , live : [ ] , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' var tokenInfo = require ( "s" ) ; var Bluebird = require ( "s" ) ; var _ = require ( "s" ) ; var DummyToken = artifacts . require ( "s" ) ; var TokenRegistry = artifacts . require ( "s" ) ; module . exports = function ( deployer , network , accounts ) { if ( network === "s" ) { } else { var devTokenInfos = tokenInfo . development ; var totalSupply = 0 ; deployer . then ( ( ) => { return TokenRegistry . deployed ( ) ; } ) . then ( ( tokenRegistry ) => { return Bluebird . each ( devTokenInfos . map ( token => DummyToken . new ( token . name , token . symbol , token . decimals , totalSupply , ) ) , _ . noop ) . then ( dummyTokens => { return Bluebird . each ( dummyTokens . map ( ( tokenContract , i ) => { var token = devTokenInfos [ i ] ; return tokenRegistry . registerToken ( tokenContract . address , token . symbol ) ; } ) , _ . noop ) ; } ) ; } ) ; } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' var TokenRegistry = artifacts . require ( "s" ) ; var TokenTransferDelegate = artifacts . require ( "s" ) ; var LoopringProtocolImpl = artifacts . require ( "s" ) ; module . exports = function ( deployer , network , accounts ) { if ( network === "s" ) { deployer . then ( ( ) => { return Promise . all ( [ TokenRegistry . deployed ( ) , TokenTransferDelegate . deployed ( ) , ] ) ; } ) . then ( ( contracts ) => { var lrcAddr = "s" ; return deployer . deploy ( LoopringProtocolImpl , lrcAddr , TokenRegistry . address , TokenTransferDelegate . address , 0 , 0 ) ; } ) ; } else { deployer . then ( ( ) => { return Promise . all ( [ TokenRegistry . deployed ( ) , TokenTransferDelegate . deployed ( ) , ] ) ; } ) . then ( ( contracts ) => { var [ tokenRegistry ] = contracts ; return tokenRegistry . getAddressBySymbol ( "s" ) ; } ) . then ( lrcAddr => { return deployer . deploy ( LoopringProtocolImpl , lrcAddr , TokenRegistry . address , TokenTransferDelegate . address , 0 , 0 ) ; } ) ; } } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BigNumber } from "s" ; import xor = require ( "s" ) ; import BN = require ( "s" ) ; import promisify = require ( "s" ) ; import ABI = require ( "s" ) ; import ethUtil = require ( "s" ) ; import * as _ from "s" ; import 0 = require ( "s" ) ; import { OrderParams } from "s" ; export class Order { public owner : string ; public params : OrderParams ; public 0 : 0 ; constructor ( owner , params ) { this . owner = owner ; this . params = params ; try { if ( 0 ) { this . 0 = 0 ; } } catch ( err ) { console . log ( "s" , err ) ; } } public isValidSignature ( ) { const { v , r , s } = this . params ; if ( _ . isUndefined ( v ) || _ . isUndefined ( r ) || _ . isUndefined ( s ) ) { throw new Error ( "s" ) ; } const orderHash = this . getOrderHash ( ) ; const msgHash = ethUtil . hashPersonalMessage ( orderHash ) ; try { const pubKey = ethUtil . ecrecover ( msgHash , v , ethUtil . toBuffer ( r ) , ethUtil . toBuffer ( s ) ) ; const recoveredAddress = ethUtil . bufferToHex ( ethUtil . pubToAddress ( pubKey ) ) ; return recoveredAddress === this . owner ; } catch ( err ) { return false ; } } public async signAsync ( ) { const orderHash = this . getOrderHash ( ) ; const signature = await promisify ( this . 0 . eth . sign ) ( this . owner , ethUtil . bufferToHex ( orderHash ) ) ; const { v , r , s } = ethUtil . fromRpcSig ( signature ) ; this . params = _ . assign ( this . params , { orderHashHex : ethUtil . bufferToHex ( orderHash ) , r : ethUtil . bufferToHex ( r ) , s : ethUtil . bufferToHex ( s ) , v , } ) ; } public getOrderHash ( ) { const args = [ this . params . delegateContract , this . owner , this . params . tokenS , this . params . tokenB , this . params . walletAddr , this . params . authAddr , this . toBN ( this . params . amountS ) , this . toBN ( this . params . amountB ) , this . toBN ( this . params . validSince ) , this . toBN ( this . params . validUntil ) , this . toBN ( this . params . lrcFee ) , this . params . buyNoMoreThanAmountB , this . params . marginSplitPercentage , ] ; const argTypes = [ "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , "s" , ] ; const orderHash = ABI . 0 ( argTypes , args ) ; return orderHash ; } private toBN ( bg ) { return new BN ( bg . toString ( 0 ) , 0 ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $OrderParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BigNumber$ O O O O O O O O O O O O O O O O O O
import { BigNumber } from "s" ; import promisify = require ( "s" ) ; import ABI = require ( "s" ) ; import ethUtil = require ( "s" ) ; import * as _ from "s" ; import 0 = require ( "s" ) ; import { Order } from "s" ; export class Ring { public owner : string ; public orders : Order [ ] ; public feeSelections : number [ ] ; public v : number ; public r : string ; public s : string ; public authV : number [ ] = [ ] ; public authR : string [ ] = [ ] ; public authS : string [ ] = [ ] ; private 0 : 0 ; private rate : number ; constructor ( owner , orders : Order [ ] , feeSelections : number [ ] ) { this . owner = owner ; this . orders = orders ; this . feeSelections = feeSelections ; try { if ( 0 ) { this . 0 = 0 ; } } catch ( err ) { } } public isValidSignature ( ) { if ( _ . isUndefined ( this . v ) || _ . isUndefined ( this . r ) || _ . isUndefined ( this . s ) ) { throw new Error ( "s" ) ; } const ringHash = this . getRingHash ( ) ; const msgHash = ethUtil . hashPersonalMessage ( ringHash ) ; try { const pubKey = ethUtil . ecrecover ( msgHash , this . v , ethUtil . toBuffer ( this . r ) , ethUtil . toBuffer ( this . s ) ) ; const recoveredAddress = ethUtil . bufferToHex ( ethUtil . pubToAddress ( pubKey ) ) ; return recoveredAddress === this . owner ; } catch ( err ) { return false ; } } public async signAsync ( ) { const ringHash = this . getRingHash ( ) ; const signer = promisify ( this . 0 . eth . sign ) ; const signature = await signer ( this . owner , ethUtil . bufferToHex ( ringHash ) ) ; const { v , r , s } = ethUtil . fromRpcSig ( signature ) ; this . v = v ; this . r = ethUtil . bufferToHex ( r ) ; this . s = ethUtil . bufferToHex ( s ) ; for ( const order of this . orders ) { const authSig = await signer ( order . params . authAddr , ethUtil . bufferToHex ( ringHash ) ) ; const sigRes = ethUtil . fromRpcSig ( authSig ) ; this . authV . push ( sigRes . v ) ; this . authR . push ( ethUtil . bufferToHex ( sigRes . r ) ) ; this . authS . push ( ethUtil . bufferToHex ( sigRes . s ) ) ; } } public getRingHash ( ) { const orderHashList : string [ ] = [ ] ; for ( const order of this . orders ) { const orderHash = order . getOrderHash ( ) ; orderHashList . push ( ethUtil . bufferToHex ( orderHash ) ) ; } const ringHash = ABI . 0 ( [ "s" , "s" , "s" , ] , [ this . xorReduceStr ( orderHashList ) , this . owner , this . feeSelectionListToNumber ( this . feeSelections ) , ] ) ; return ringHash ; } public feeSelectionListToNumber ( feeSelections : number [ ] ) { let res = 0 ; for ( let i = 0 ; i < feeSelections . length ; i ++ ) { res += feeSelections [ i ] << i ; } return res ; } public getRingHashHex ( ) { const ringHash = this . getRingHash ( ) ; const ringHashHex = ethUtil . bufferToHex ( ringHash ) ; return ringHashHex ; } public caculateAndSetRateAmount ( ) { const size = this . orders . length ; this . rate = 0 ; for ( const order of this . orders ) { this . rate = this . rate * order . params . amountS . toNumber ( ) / order . params . amountB . toNumber ( ) ; } this . rate = Math . pow ( this . rate , 0 / size ) ; for ( const order of this . orders ) { order . params . rateAmountB = order . params . amountB . toNumber ( ) ; order . params . rateAmountS = Math . floor ( order . params . amountS . toNumber ( ) / this . rate ) ; } } public printToConsole ( ) { console . log ( "s" . repeat ( 0 ) ) ; console . log ( "s" , this . owner ) ; console . log ( "s" , this . rate ) ; for ( const order of this . orders ) { console . log ( "s" . repeat ( 0 ) ) ; console . log ( "s" , order . owner ) ; console . log ( "s" , order . params ) ; } console . log ( "s" , this . feeSelections ) ; console . log ( "s" . repeat ( 0 ) ) ; } private xorReduce ( numberArr : number [ ] ) { const 0 = numberArr [ 0 ] ; const tail = numberArr . slice ( 0 ) ; const intRes = tail . reduce ( ( 0 , 0 ) => 0 ^ 0 , 0 ) ; return intRes ; } private xorReduceStr ( strArr : string [ ] ) { const 0 = strArr [ 0 ] ; const tail = strArr . slice ( 0 ) ; const strXor = ( 0 , 0 ) => { const 0 = Buffer . from ( 0 . slice ( 0 ) , "s" ) ; const 0 = Buffer . from ( 0 . slice ( 0 ) , "s" ) ; const res = Buffer . alloc ( 0 ) ; for ( let i = 0 ; i < 0 ; i ++ ) { res [ i ] = 0 [ i ] ^ 0 [ i ] ; } const strRes = ethUtil . bufferToHex ( res ) ; return strRes ; } ; const reduceRes = tail . reduce ( ( a , b ) => strXor ( a , b ) , 0 ) ; return Buffer . from ( reduceRes . slice ( 0 ) , "s" ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BigNumber } from "s" ; import { Ring } from "s" ; export interface OrderParams { delegateContract : string ; tokenS : string ; tokenB : string ; amountS : BigNumber ; amountB : BigNumber ; validSince : BigNumber ; validUntil : BigNumber ; lrcFee : BigNumber ; buyNoMoreThanAmountB : boolean ; marginSplitPercentage : number ; authAddr : string ; walletAddr : string ; tokenSSymbol ? : string ; scaledAmountS ? : number ; scaledAmountB ? : number ; rateAmountS ? : number ; rateAmountB ? : number ; fillAmountS ? : number ; orderHashHex ? : string ; v ? : number ; r ? : string ; s ? : string ; } export interface LoopringSubmitParams { addressList : string [ ] [ ] ; uintArgsList : BigNumber [ ] [ ] ; 0 : number [ ] [ ] ; buyNoMoreThanAmountBList : boolean [ ] ; vList : number [ ] ; rList : string [ ] ; sList : string [ ] ; ringOwner : string ; feeRecepient : string ; feeSelections : number ; } export interface FeeItem { feeS : number ; feeB : number ; feeLrc : number ; lrcReward : number ; } export interface BalanceItem { balanceS : number ; balanceB : number ; } export interface RingInfo { amountSList : number [ ] ; amountBList : number [ ] ; lrcFeeAmountList ? : number [ ] ; miner ? : string ; orderOwners ? : string [ ] ; tokenAddressList ? : string [ ] ; marginSplitPercentageList ? : number [ ] ; buyNoMoreThanAmountBList ? : boolean [ ] ; feeSelections ? : number [ ] ; spendableAmountSList ? : number [ ] ; spendableLrcFeeAmountList ? : number [ ] ; orderFilledOrCancelledAmountList ? : number [ ] ; description ? : string ; salt ? : number ; verbose ? : boolean ; id ? : string ; } export interface RingBalanceInfo { participiants : string [ ] ; tokenAddressList : string [ ] ; tokenSymbolList : string [ ] ; tokenBalances : number [ ] [ ] ; } export interface SimulatorReport { ring : Ring ; feeItems : FeeItem [ ] ; transferList : TransferItem [ ] ; ringBalanceInfo ? : RingBalanceInfo ; } export interface TransferItem { description : string ; tokenAddress : string ; tokenSymbol ? : string ; fromAddress : string ; toAddress : string ; amount : number ; } export interface RawTx { content : string ; id ? : string ; url ? : string ; verbose ? : boolean ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { RawTx } from "s" ; export const rawTxs : RawTx [ ] = [ { id : "s" , content : "s" , verbose : false , } , { id : "s" , content : "s" , verbose : false , } , ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { RingInfo } from "s" ; export const ringInfoList : RingInfo [ ] = [ { description : "s" , amountSList : [ 0 , 0 ] , amountBList : [ 0 , 0 ] , buyNoMoreThanAmountBList : [ false , false ] , feeSelections : [ 0 , 0 ] , salt : 0 , } , { description : "s" , amountSList : [ 0 , 0 ] , amountBList : [ 0 , 0 ] , buyNoMoreThanAmountBList : [ false , false ] , feeSelections : [ 0 , 0 ] , orderFilledOrCancelledAmountList : [ 0 , 0 ] , salt : 0 , verbose : false , } , { description : "s" , amountSList : [ 0 , 0 ] , amountBList : [ 0 , 0 ] , lrcFeeAmountList : [ 0 , 0 ] , marginSplitPercentageList : [ 0 , 0 ] , buyNoMoreThanAmountBList : [ false , false ] , feeSelections : [ 0 , 0 ] , salt : 0 , } , { description : "s" , amountSList : [ 0 , 0 ] , amountBList : [ 0 , 0 ] , lrcFeeAmountList : [ 0 , 0 ] , orderOwners : [ "s" ] , marginSplitPercentageList : [ 0 , 0 ] , buyNoMoreThanAmountBList : [ false , false ] , feeSelections : [ 0 , 0 ] , salt : 0 , verbose : false , } , { description : "s" , amountSList : [ 0 , 0 ] , amountBList : [ 0 , 0 ] , lrcFeeAmountList : [ 0 , 0 ] , marginSplitPercentageList : [ 0 , 0 ] , buyNoMoreThanAmountBList : [ false , false ] , feeSelections : [ 0 , 0 ] , salt : 0 , verbose : false , } , { description : "s" , amountSList : [ 0 , 0 ] , amountBList : [ 0 , 0 ] , lrcFeeAmountList : [ 0 , 0 ] , marginSplitPercentageList : [ 0 , 0 ] , buyNoMoreThanAmountBList : [ true , false ] , feeSelections : [ 0 , 0 ] , salt : 0 , } , { description : "s" , amountSList : [ 0 , 0 ] , amountBList : [ 0 , 0 ] , lrcFeeAmountList : [ 0 , 0 ] , marginSplitPercentageList : [ 0 , 0 ] , buyNoMoreThanAmountBList : [ true , false ] , feeSelections : [ 0 , 0 ] , salt : 0 , } , { description : "s" , amountSList : [ 0 , 0 , 0 ] , amountBList : [ 0 , 0 , 0 ] , lrcFeeAmountList : [ 0 , 0 , 0 ] , marginSplitPercentageList : [ 0 , 0 , 0 ] , buyNoMoreThanAmountBList : [ true , false , false ] , feeSelections : [ 0 , 0 , 0 ] , salt : 0 , verbose : false , } , { description : "s" , amountSList : [ 0 , 0 , 0 ] , amountBList : [ 0 , 0 , 0 ] , lrcFeeAmountList : [ 0 , 0 , 0 ] , marginSplitPercentageList : [ 0 , 0 , 0 ] , buyNoMoreThanAmountBList : [ true , false , false ] , feeSelections : [ 0 , 0 , 0 ] , spendableLrcFeeAmountList : [ 0 , 0 , 0 , 0 ] , salt : 0 , verbose : false , } , { description : "s" , amountSList : [ 0 , 0 , 0 ] , amountBList : [ 0 , 0 , 0 ] , lrcFeeAmountList : [ 0 , 0 , 0 ] , marginSplitPercentageList : [ 0 , 0 , 0 ] , buyNoMoreThanAmountBList : [ false , true , true ] , feeSelections : [ 0 , 0 , 0 ] , spendableLrcFeeAmountList : [ 0 , 0 , 0 , 0 ] , salt : 0 , verbose : false , } , { description : "s" , amountSList : [ 0 , 0 , 0 ] , amountBList : [ 0 , 0 , 0 ] , lrcFeeAmountList : [ 0 , 0 , 0 ] , marginSplitPercentageList : [ 0 , 0 , 0 ] , buyNoMoreThanAmountBList : [ false , true , false ] , feeSelections : [ 0 , 0 , 0 ] , spendableLrcFeeAmountList : [ 0 , 0 , 0 , 0 ] , salt : 0 , verbose : false , } , { description : "s" , amountSList : [ 0 , 0 , 0 ] , amountBList : [ 0 , 0 , 0 ] , lrcFeeAmountList : [ 0 , 0 , 0 ] , marginSplitPercentageList : [ 0 , 0 , 0 ] , buyNoMoreThanAmountBList : [ false , true , false ] , feeSelections : [ 0 , 0 , 0 ] , spendableLrcFeeAmountList : [ 0 , 0 , 0 , 0 ] , salt : 0 , verbose : false , } , ] ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export class Artifacts { public TokenRegistry : any ; public LoopringProtocolImpl : any ; public TokenTransferDelegate : any ; public DummyToken : any ; constructor ( artifacts ) { this . TokenRegistry = artifacts . require ( "s" ) ; this . LoopringProtocolImpl = artifacts . require ( "s" ) ; this . TokenTransferDelegate = artifacts . require ( "s" ) ; this . DummyToken = artifacts . require ( "s" ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import BN = require ( "s" ) ; import txDecoder = require ( "s" ) ; import abi = require ( "s" ) ; import { RawTx , RingInfo } from "s" ; export class TxParser { public protocolAbi : string ; constructor ( protocolAbi ) { this . protocolAbi = protocolAbi ; } public parseSubmitRingTx ( txRaw ) { const fnDecoder = new txDecoder . FunctionDecoder ( this . protocolAbi ) ; const decodedTx = txDecoder . decodeTx ( txRaw . content ) ; const arrayish = fnDecoder . decodeFn ( decodedTx . data ) ; const miner = arrayish [ 0 ] ; const orderOwners : string [ ] = [ ] ; const tokenAddressList : string [ ] = [ ] ; for ( const addrs of arrayish [ 0 ] ) { orderOwners . push ( addrs [ 0 ] ) ; tokenAddressList . push ( addrs [ 0 ] ) ; } const amountSList : number [ ] = [ ] ; const amountBList : number [ ] = [ ] ; const lrcFeeAmountList : number [ ] = [ ] ; for ( const amounts of arrayish [ 0 ] ) { amountSList . push ( this . bnToNumber ( amounts [ 0 ] ) ) ; amountBList . push ( this . bnToNumber ( amounts [ 0 ] ) ) ; lrcFeeAmountList . push ( this . bnToNumber ( amounts [ 0 ] ) ) ; } const marginSplitPercentageList = [ ] . concat ( ... arrayish [ 0 ] ) ; const buyNoMoreThanAmountBList = arrayish [ 0 ] ; const feeSelectionNumber = arrayish [ 0 ] ; const ringSize = tokenAddressList . length ; const feeSelections = this . feeSelectionNumberToArray ( feeSelectionNumber , ringSize ) ; const ringInfo = { amountSList , amountBList , lrcFeeAmountList , miner , orderOwners , tokenAddressList , marginSplitPercentageList , buyNoMoreThanAmountBList , feeSelections , description : "s" + txRaw . id , id : txRaw . id , verbose : txRaw . verbose , } ; return ringInfo ; } private feeSelectionNumberToArray ( fsn , ringSize ) { const feeSelectionList : number [ ] = [ ] ; for ( let i = ringSize - 0 ; i >= 0 ; i -- ) { const feeSelection = ( fsn >> i ) % 0 ; feeSelectionList . push ( feeSelection ) ; } return feeSelectionList ; } private bnToNumber ( bn ) { const bnStr = bn . toString ( 0 ) ; return parseInt ( bnStr , 0 ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $RawTx$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $RingInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O
import { BigNumber } from "s" ; import fs = require ( "s" ) ; import 0 = require ( "s" ) ; export class ChainReader { private 0 : 0 ; private 0 : any ; private DelegateContract : any ; private TokenRegistryContract : any ; private connected : boolean ; constructor ( ) { try { if ( 0 ) { this . 0 = 0 ; } else { this . 0 = new 0 ( new 0 . providers . HttpProvider ( "s" ) ) ; } this . connected = true ; } catch ( err ) { console . log ( "s" , err ) ; this . connected = false ; throw err ; } const 0 = fs . readFileSync ( "s" , "s" ) ; const delegateAbi = fs . readFileSync ( "s" , "s" ) ; const tokenRegistryAbi = fs . readFileSync ( "s" , "s" ) ; this . 0 = this . 0 . eth . contract ( JSON . parse ( 0 ) ) ; this . DelegateContract = this . 0 . eth . contract ( JSON . parse ( delegateAbi ) ) ; this . TokenRegistryContract = this . 0 . eth . contract ( JSON . parse ( tokenRegistryAbi ) ) ; } public isConnected ( ) { return this . connected ; } public async 0 ( tokenAddr , ownerAddr ) { const tokenContractInstance = this . 0 . at ( tokenAddr ) ; const balance = await tokenContractInstance . balanceOf ( ownerAddr ) ; const balanceBN = new BigNumber ( balance ) ; return balanceBN . toNumber ( ) ; } public async 0 ( tokenAddr , ownerAddr , spenderAddr ) { const tokenContractInstance = this . 0 . at ( tokenAddr ) ; const balance = await tokenContractInstance . allowance ( ownerAddr , spenderAddr ) ; const balanceBN = new BigNumber ( balance ) ; return balanceBN . toNumber ( ) ; } public async 0 ( tokenAddr , ownerAddr , spenderAddr ) { const balance = await this . 0 ( tokenAddr , ownerAddr ) ; const allowance = await this . 0 ( tokenAddr , ownerAddr , spenderAddr ) ; return Math . min ( balance , allowance ) ; } public async getOrderCancelledOrFilledAmount ( orderHash , delegateAddr ) { const delegateContractInstance = this . DelegateContract . at ( delegateAddr ) ; const amount = await delegateContractInstance . cancelledOrFilled ( orderHash ) ; const amountBN = new BigNumber ( amount ) ; return amount . toNumber ( ) ; } public async getTokenAddressBySymbol ( tokenRegistryAddr , symbol ) { const tokenRegistryInstance = this . TokenRegistryContract . at ( tokenRegistryAddr ) ; const tokenAddr = await tokenRegistryInstance . getAddressBySymbol ( symbol ) ; return tokenAddr ; } public async getTokenSymbolByAddress ( tokenRegistryAddr , tokenAddr ) { const tokenRegistryInstance = this . TokenRegistryContract . at ( tokenRegistryAddr ) ; const tokenInfo = await tokenRegistryInstance . addressMap ( tokenAddr ) ; return tokenInfo [ 0 ] ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BigNumber } from "s" ; import { ChainReader } from "s" ; import { Order } from "s" ; import { Ring } from "s" ; import { BalanceItem , FeeItem , RingBalanceInfo , SimulatorReport , TransferItem } from "s" ; export class ProtocolSimulator { public ring : Ring ; public lrcAddress : string ; public tokenRegistryAddress : string ; public walletSplitPercentage : number ; public feeSelectionList : number [ ] ; public chainReader : ChainReader ; public ringBalanceInfoBefore : RingBalanceInfo ; public verbose : boolean ; private spendableAmountSList : number [ ] = [ ] ; private spendableLrcAmountList : number [ ] = [ ] ; private orderFilledOrCancelledAmountList : number [ ] = [ ] ; constructor ( ring , lrcAddress , tokenRegistryAddress , walletSplitPercentage ) { this . ring = ring ; this . lrcAddress = lrcAddress ; this . tokenRegistryAddress = tokenRegistryAddress ; this . walletSplitPercentage = walletSplitPercentage ; this . feeSelectionList = ring . feeSelections ; this . chainReader = new ChainReader ( ) ; } public async simulateAndReport ( spendableAmountSList : number [ ] , spendableLrcAmountList : number [ ] , orderFilledOrCancelledAmountList : number [ ] , printReport ) { const ringSize = this . ring . orders . length ; await this . loadChainData ( ) ; if ( spendableAmountSList && spendableAmountSList . length === ringSize ) { this . spendableAmountSList = spendableAmountSList ; } if ( spendableLrcAmountList && spendableLrcAmountList . length === ringSize ) { this . spendableLrcAmountList = spendableLrcAmountList ; } if ( orderFilledOrCancelledAmountList && orderFilledOrCancelledAmountList . length === ringSize ) { this . orderFilledOrCancelledAmountList = orderFilledOrCancelledAmountList ; } this . ring . caculateAndSetRateAmount ( ) ; this . scaleRing ( ) ; this . caculateFillAmountS ( ) ; const feeItems = this . caculateOrderFees ( ) ; const transferList = this . assembleTransferItems ( feeItems ) ; const result = { ring : this . ring , feeItems , transferList , } ; if ( printReport ) { this . printSimulatorReport ( result ) ; } return result ; } private async loadChainData ( ) { if ( ! this . chainReader . isConnected ( ) ) { return ; } const orderOwners = this . ring . orders . map ( ( o ) => o . owner ) ; const orderAndRingOwners = orderOwners . concat ( this . ring . owner ) ; let delegateAddr = "s" ; for ( let i = 0 ; i < orderOwners . length ; i ++ ) { const order = this . ring . orders [ i ] ; const tokenAddr = order . params . tokenS ; if ( ! delegateAddr ) { delegateAddr = order . params . delegateContract ; } const spendableAmount = await this . chainReader . 0 ( tokenAddr , orderOwners [ i ] , delegateAddr ) ; this . spendableAmountSList . push ( spendableAmount ) ; const orderHash = order . params . orderHashHex ; const cancelOrFillAmount = await this . chainReader . getOrderCancelledOrFilledAmount ( orderHash , delegateAddr ) ; this . orderFilledOrCancelledAmountList . push ( cancelOrFillAmount ) ; const symbol = await await this . chainReader . getTokenSymbolByAddress ( this . tokenRegistryAddress , tokenAddr ) ; order . params . tokenSSymbol = symbol ; } for ( const addr of orderAndRingOwners ) { const spendableAmount = await this . chainReader . 0 ( this . lrcAddress , addr , delegateAddr ) ; this . spendableLrcAmountList . push ( spendableAmount ) ; } } private printSimulatorReport ( report ) { console . log ( "s" . repeat ( 0 ) , "s" , "s" . repeat ( 0 ) ) ; report . ring . printToConsole ( ) ; console . log ( "s" , report . feeItems ) ; console . log ( "s" , report . transferList ) ; console . log ( "s" . repeat ( 0 ) , "s" , "s" . repeat ( 0 ) ) ; } private scaleRing ( ) { const size = this . ring . orders . length ; for ( let i = 0 ; i < size ; i ++ ) { const order = this . ring . orders [ i ] ; const amountS = order . params . amountS . toNumber ( ) ; const amountB = order . params . amountB . toNumber ( ) ; const lrcFee = order . params . lrcFee . toNumber ( ) ; let availableAmountS = amountS ; let availableAmountB = amountB ; if ( order . params . buyNoMoreThanAmountB ) { availableAmountB -= this . orderFilledOrCancelledAmountList [ i ] ; availableAmountS = Math . floor ( availableAmountB * amountS / amountB ) ; } else { availableAmountS -= this . orderFilledOrCancelledAmountList [ i ] ; availableAmountB = Math . floor ( availableAmountS * amountB / amountS ) ; } if ( this . spendableAmountSList && this . spendableAmountSList [ i ] && this . spendableAmountSList [ i ] < availableAmountS ) { availableAmountS = this . spendableAmountSList [ i ] ; availableAmountB = Math . floor ( availableAmountS * amountB / amountS ) ; } if ( availableAmountS <= 0 || availableAmountB <= 0 ) { throw new Error ( "s" ) ; } if ( amountS < availableAmountS ) { availableAmountS = amountS ; availableAmountB = Math . floor ( availableAmountS * amountB / amountS ) ; } if ( amountB < availableAmountB ) { availableAmountB = amountB ; availableAmountS = Math . floor ( availableAmountB * amountS / amountB ) ; } order . params . scaledAmountS = availableAmountS ; order . params . scaledAmountB = availableAmountB ; order . params . fillAmountS = availableAmountS ; } } private caculateFillAmountS ( ) { const size = this . ring . orders . length ; let smallestIndex = 0 ; for ( let i = 0 ; i < size ; i ++ ) { const nextIndex = ( i + 0 ) % size ; const currOrder = this . ring . orders [ i ] ; const nextOrder = this . ring . orders [ nextIndex ] ; smallestIndex = this . caculateNextFillAmountS ( currOrder , nextOrder , smallestIndex , i , nextIndex ) ; } for ( let i = 0 ; i < smallestIndex ; i ++ ) { const nextIndex = ( i + 0 ) % size ; const currOrder = this . ring . orders [ i ] ; const nextOrder = this . ring . orders [ nextIndex ] ; this . caculateNextFillAmountS ( currOrder , nextOrder , 0 , 0 , 0 ) ; } } private caculateNextFillAmountS ( currOrder , nextOrder , smallestIndex , currIndex , nextIndex ) { let newSamllestIndex = smallestIndex ; let currFillAmountB = currOrder . params . fillAmountS * currOrder . params . rateAmountB / currOrder . params . rateAmountS ; currFillAmountB = Math . floor ( currFillAmountB ) ; if ( currOrder . params . buyNoMoreThanAmountB ) { if ( currFillAmountB > currOrder . params . scaledAmountB ) { currFillAmountB = currOrder . params . scaledAmountB ; currOrder . params . fillAmountS = Math . floor ( currFillAmountB * currOrder . params . rateAmountS / currOrder . params . rateAmountB ) ; newSamllestIndex = currIndex ; } } if ( nextOrder . params . fillAmountS >= currFillAmountB ) { nextOrder . params . fillAmountS = currFillAmountB ; } else { newSamllestIndex = nextIndex ; } return newSamllestIndex ; } private caculateOrderFees ( ) { const size = this . ring . orders . length ; const fillAmountSList = this . ring . orders . map ( ( o ) => o . params . fillAmountS ) ; const fees : FeeItem [ ] = [ ] ; let minerSpendableLrc = this . spendableLrcAmountList [ size ] ; for ( let i = 0 ; i < size ; i ++ ) { const nextInd = ( i + 0 ) % size ; const order = this . ring . orders [ i ] ; const feeItem = { feeS : 0 , feeB : 0 , feeLrc : 0 , lrcReward : 0 , } ; if ( order . params . lrcFee . toNumber ( ) === 0 ) { this . feeSelectionList [ i ] = 0 ; order . params . marginSplitPercentage = 0 ; } if ( order . params . tokenB === this . lrcAddress ) { this . spendableLrcAmountList [ i ] += fillAmountSList [ nextInd ] ; } if ( this . spendableLrcAmountList [ i ] === 0 ) { this . feeSelectionList [ i ] = 0 ; order . params . marginSplitPercentage = 0 ; } let feeLrcToPay = 0 ; if ( order . params . buyNoMoreThanAmountB ) { const fillAmountB = Math . floor ( fillAmountSList [ i ] * order . params . rateAmountB / order . params . rateAmountS ) ; feeLrcToPay = Math . floor ( order . params . lrcFee . toNumber ( ) * fillAmountB / order . params . amountB . toNumber ( ) ) ; } else { feeLrcToPay = Math . floor ( order . params . lrcFee . toNumber ( ) * fillAmountSList [ i ] / order . params . amountS . toNumber ( ) ) ; } if ( order . params . tokenS === this . lrcAddress ) { this . spendableLrcAmountList [ i ] -= fillAmountSList [ i ] ; } if ( order . params . tokenB === this . lrcAddress ) { this . spendableLrcAmountList [ i ] += fillAmountSList [ nextInd ] ; } if ( this . spendableLrcAmountList [ i ] < feeLrcToPay ) { feeLrcToPay = this . spendableLrcAmountList [ i ] ; order . params . marginSplitPercentage = 0 ; } if ( 0 === this . feeSelectionList [ i ] ) { feeItem . feeLrc = feeLrcToPay ; if ( order . params . tokenB === this . lrcAddress ) { if ( this . spendableLrcAmountList [ i ] >= feeLrcToPay ) { feeItem . feeB = feeLrcToPay ; feeItem . feeLrc = 0 ; } else { feeItem . feeB = this . spendableLrcAmountList [ i ] ; feeItem . feeLrc = feeLrcToPay - this . spendableLrcAmountList [ i ] ; } } } else if ( 0 === this . feeSelectionList [ i ] ) { if ( minerSpendableLrc >= feeLrcToPay ) { if ( order . params . buyNoMoreThanAmountB ) { feeItem . feeS = Math . floor ( fillAmountSList [ nextInd ] * order . params . amountS . toNumber ( ) / order . params . amountB . toNumber ( ) ) - fillAmountSList [ i ] ; feeItem . feeS = Math . floor ( feeItem . feeS * order . params . marginSplitPercentage / 0 ) ; } else { feeItem . feeB = fillAmountSList [ nextInd ] - Math . floor ( fillAmountSList [ i ] * order . params . amountB . toNumber ( ) / order . params . amountS . toNumber ( ) ) ; feeItem . feeB = Math . floor ( feeItem . feeB * order . params . marginSplitPercentage / 0 ) ; } if ( feeItem . feeS > 0 || feeItem . feeB > 0 ) { minerSpendableLrc -= feeLrcToPay ; feeItem . lrcReward = feeLrcToPay ; } feeItem . feeLrc = 0 ; } } else { throw new Error ( "s" ) ; } fees . push ( feeItem ) ; } return fees ; } private assembleTransferItems ( feeItems : FeeItem [ ] ) { const orderOwners = this . ring . orders . map ( ( o ) => o . owner ) ; const ringSize = orderOwners . length ; const transferItems : TransferItem [ ] = [ ] ; for ( let i = 0 ; i < ringSize ; i ++ ) { const prevIndex = ( i + ringSize - 0 ) % ringSize ; const descriptions = [ "s" , "s" , "s" , "s" , "s" , "s" ] ; const tokenS = this . ring . orders [ i ] . params . tokenS ; const tokenB = this . ring . orders [ i ] . params . tokenB ; const fillAmountS = this . ring . orders [ i ] . params . fillAmountS ; const walletAddr = this . ring . orders [ i ] . params . walletAddr ; const tokenAddressList = [ tokenS , tokenS , tokenS , this . lrcAddress , this . lrcAddress , this . lrcAddress ] ; const fromAddressList = [ orderOwners [ i ] , orderOwners [ i ] , orderOwners [ i ] , orderOwners [ i ] , orderOwners [ i ] , this . ring . owner ] ; const toAddressList = [ orderOwners [ prevIndex ] , this . ring . owner , walletAddr , this . ring . owner , walletAddr , orderOwners [ i ] ] ; const feeItem = feeItems [ i ] ; const prevFeeItem = feeItems [ prevIndex ] ; const walletSplit = Math . floor ( ( feeItem . feeS + prevFeeItem . feeB ) * this . walletSplitPercentage / 0 ) ; const minerSplit = feeItem . feeS + prevFeeItem . feeB - walletSplit ; const walletLrc = Math . floor ( feeItem . feeLrc * this . walletSplitPercentage / 0 ) ; const minerLrc = feeItem . feeLrc - walletLrc ; const amountList = [ fillAmountS - prevFeeItem . feeB , minerSplit , walletSplit , minerLrc , walletLrc , feeItem . lrcReward ] ; for ( let j = 0 ; j < amountList . length ; j ++ ) { if ( amountList [ j ] > 0 ) { const fromAddress = fromAddressList [ j ] ; const toAddress = toAddressList [ j ] ; if ( fromAddress === toAddress ) { continue ; } const transferItem = { description : descriptions [ j ] , tokenAddress : tokenAddressList [ j ] , tokenSymbol : "s" , fromAddress , toAddress , amount : amountList [ j ] , } ; transferItems . push ( transferItem ) ; } } } return transferItems ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Ring$ O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SimulatorReport$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SimulatorReport$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Order$ O $Order$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $FeeItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TransferItem$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BigNumber } from "s" ; import 0 = require ( "s" ) ; export class Bitstream { private data : string ; constructor ( ) { this . data = "s" ; } public getData ( ) { if ( this . data . length === 0 ) { return "s" ; } else { return "s" + this . data ; } } public addBigNumber ( x , numBytes = 0 ) { this . data += this . padString ( 0 . toHex ( x ) . slice ( 0 ) , numBytes * 0 ) ; } public addNumber ( x , numBytes = 0 ) { this . addBigNumber ( new BigNumber ( x ) , numBytes ) ; } public addAddress ( x , numBytes = 0 ) { this . data += this . padString ( x . slice ( 0 ) , numBytes * 0 ) ; } public addHex ( x ) { if ( x . startsWith ( "s" ) ) { this . data += x . slice ( 0 ) ; } else { this . data += x ; } } private padString ( x , targetLength ) { if ( x . length > targetLength ) { throw Error ( "s" + x + "s" + targetLength + "s" ) ; } while ( x . length < targetLength ) { x = "s" + x ; } return x ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BigNumber$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BigNumber } from "s" ; import BN = require ( "s" ) ; import { LoopringSubmitParams , OrderParams , RingInfo } from "s" ; import { Bitstream } from "s" ; import { Order } from "s" ; import { Ring } from "s" ; export class RingFactory { public delegateContractAddr : string ; public currBlockTimeStamp : number ; public authAddress : string ; public walletAddr : string ; constructor ( delegateContractAddr , authAddress , currBlockTimeStamp ) { this . delegateContractAddr = delegateContractAddr ; this . authAddress = authAddress ; this . currBlockTimeStamp = currBlockTimeStamp ; } public async generateRing ( ringInfo ) { const ringSize = ringInfo . amountSList . length ; const salt = ringInfo . salt ? ringInfo . salt : 0 ; const orders : Order [ ] = [ ] ; for ( let i = 0 ; i < ringSize ; i ++ ) { const nextIndex = ( i + 0 ) % ringSize ; const orderParam = { delegateContract : this . delegateContractAddr , tokenS : ringInfo . tokenAddressList [ i ] , tokenB : ringInfo . tokenAddressList [ nextIndex ] , amountS : new BigNumber ( ringInfo . amountSList [ i ] ) , amountB : new BigNumber ( ringInfo . amountBList [ i ] ) , validSince : new BigNumber ( this . currBlockTimeStamp - 0 ) , validUntil : new BigNumber ( this . currBlockTimeStamp + 0 + salt ) , lrcFee : new BigNumber ( ringInfo . lrcFeeAmountList [ i ] ) , buyNoMoreThanAmountB : ringInfo . buyNoMoreThanAmountBList [ i ] , marginSplitPercentage : ringInfo . marginSplitPercentageList [ i ] , authAddr : this . authAddress , walletAddr : this . walletAddr , } ; const order = new Order ( ringInfo . orderOwners [ i ] , orderParam ) ; await order . signAsync ( ) ; orders . push ( order ) ; } const ring = new Ring ( ringInfo . miner , orders , ringInfo . feeSelections ) ; await ring . signAsync ( ) ; return ring ; } public ringToSubmitableParams ( ring ) { const ringSize = ring . orders . length ; ring . caculateAndSetRateAmount ( ) ; const bitstream = new Bitstream ( ) ; bitstream . addNumber ( ringSize , 0 ) ; bitstream . addAddress ( ring . owner ) ; bitstream . addNumber ( this . feeSelectionListToNumber ( ring . feeSelections ) , 0 ) ; for ( let i = 0 ; i < ringSize ; i ++ ) { const order = ring . orders [ i ] ; let authAddr = order . params . authAddr ; let walletAddr = order . params . walletAddr ; let ringAuthR = ring . authR [ i ] ; let ringAuthS = ring . authS [ i ] ; let ringAuthV = ring . authV [ i ] ; if ( i > 0 ) { const previousOrder = ring . orders [ i - 0 ] ; authAddr = this . xor ( previousOrder . params . authAddr , order . params . authAddr , 0 ) ; walletAddr = this . xor ( previousOrder . params . walletAddr , order . params . walletAddr , 0 ) ; ringAuthR = this . xor ( ring . authR [ i - 0 ] , ring . authR [ i ] , 0 ) ; ringAuthS = this . xor ( ring . authS [ i - 0 ] , ring . authS [ i ] , 0 ) ; ringAuthV = ring . authV [ i - 0 ] ^ ring . authV [ i ] ; } bitstream . addAddress ( order . owner , 0 ) ; bitstream . addAddress ( order . params . tokenS , 0 ) ; bitstream . addAddress ( walletAddr , 0 ) ; bitstream . addAddress ( authAddr , 0 ) ; bitstream . addBigNumber ( order . params . amountS ) ; bitstream . addBigNumber ( order . params . amountB ) ; bitstream . addBigNumber ( order . params . lrcFee ) ; bitstream . addBigNumber ( new BigNumber ( order . params . rateAmountS . toPrecision ( 0 ) ) , 0 ) ; bitstream . addHex ( order . params . r ) ; bitstream . addHex ( order . params . s ) ; bitstream . addHex ( ringAuthR ) ; bitstream . addHex ( ringAuthS ) ; bitstream . addBigNumber ( order . params . validSince , 0 ) ; bitstream . addBigNumber ( order . params . validUntil . minus ( order . params . validSince ) , 0 ) ; bitstream . addNumber ( order . params . v , 0 ) ; bitstream . addNumber ( ringAuthV , 0 ) ; bitstream . addNumber ( ( ( order . params . buyNoMoreThanAmountB ? 0 : 0 ) << 0 ) + order . params . marginSplitPercentage , 0 ) ; } const submitParams = { data : bitstream . getData ( ) , } ; return submitParams ; } public feeSelectionListToNumber ( feeSelections : number [ ] ) { let res = 0 ; for ( let i = 0 ; i < feeSelections . length ; i ++ ) { res += feeSelections [ i ] << i ; } return res ; } private xor ( 0 , 0 , numBytes ) { const 0 = new BN ( 0 . slice ( 0 ) , 0 ) ; const 0 = new BN ( 0 . slice ( 0 ) , 0 ) ; const result = 0 . xor ( 0 ) ; return "s" + result . toString ( 0 , numBytes * 0 ) ; } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O $RingInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $OrderParams$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Ring$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Artifacts } from "s" ; const { TokenRegistry , DummyToken , } = new Artifacts ( artifacts ) ; contract ( "s" , ( accounts : string [ ] ) => { const owner = accounts [ 0 ] ; const user = accounts [ 0 ] ; let tokenRegistry ; let testTokenAddr ; let lrcAddress ; let eosAddress ; let gtoAddress ; let rdnAddress ; before ( async ( ) => { tokenRegistry = await TokenRegistry . deployed ( ) ; testTokenAddr = "s" ; lrcAddress = await tokenRegistry . getAddressBySymbol ( "s" ) ; eosAddress = await tokenRegistry . getAddressBySymbol ( "s" ) ; gtoAddress = await tokenRegistry . getAddressBySymbol ( "s" ) ; rdnAddress = await tokenRegistry . getAddressBySymbol ( "s" ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await tokenRegistry . registerToken ( testTokenAddr , "s" , { from : owner } ) ; const isRegistered = await tokenRegistry . isTokenRegistered ( testTokenAddr ) ; assert . equal ( isRegistered , true , "s" ) ; } ) ; it ( "s" , async ( ) => { let isRegistered = await tokenRegistry . isTokenRegistered ( testTokenAddr ) ; let isRegisteredBySymbol = await tokenRegistry . isTokenRegisteredBySymbol ( "s" ) ; assert . equal ( isRegistered , true , "s" ) ; assert . equal ( isRegisteredBySymbol , true , "s" ) ; await tokenRegistry . unregisterToken ( testTokenAddr , "s" , { from : owner } ) ; isRegistered = await tokenRegistry . isTokenRegistered ( testTokenAddr ) ; isRegisteredBySymbol = await tokenRegistry . isTokenRegisteredBySymbol ( "s" ) ; assert . equal ( isRegistered , false , "s" ) ; assert . equal ( isRegisteredBySymbol , false , "s" ) ; } ) ; it ( "s" , async ( ) => { const tokenList = [ lrcAddress , gtoAddress , eosAddress , rdnAddress ] ; const allRegistered = await tokenRegistry . areAllTokensRegistered ( tokenList ) ; assert . equal ( allRegistered , true , "s" ) ; tokenList . push ( testTokenAddr ) ; const 0 = await tokenRegistry . areAllTokensRegistered ( tokenList ) ; assert . equal ( 0 , false , "s" ) ; } ) ; it ( "s" , async ( ) => { const allTokens = await tokenRegistry . getTokens ( 0 , 0 ) ; const size = allTokens . length ; const 0 = await tokenRegistry . getTokens ( 0 , 0 ) ; const 0 = await tokenRegistry . getTokens ( 0 , 0 ) ; assert . deepEqual ( 0 , allTokens . slice ( 0 , 0 ) , "s" ) ; assert . deepEqual ( 0 , allTokens . slice ( 0 , 0 ) , "s" ) ; } ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { const isRegistered = await tokenRegistry . isTokenRegistered ( testTokenAddr , { from : user } ) ; assert . equal ( isRegistered , isRegistered , "s" ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O $string$ O O $string$ O O $string$ O O $string$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BigNumber } from "s" ; import BN = require ( "s" ) ; import abi = require ( "s" ) ; import * as _ from "s" ; import { Artifacts } from "s" ; const { TokenTransferDelegate , TokenRegistry , DummyToken , } = new Artifacts ( artifacts ) ; contract ( "s" , ( accounts : string [ ] ) => { const owner = accounts [ 0 ] ; const 0 = accounts [ 0 ] ; const 0 = accounts [ 0 ] ; const 0 = accounts [ 0 ] ; const 0 = accounts [ 0 ] ; const 0 = accounts [ 0 ] ; const 0 = accounts [ 0 ] ; const 0 = accounts [ 0 ] ; let tokenRegistry ; let tokenTransferDelegate ; let lrc ; let eos ; let gto ; let lrcAddress ; let eosAddress ; let gtoAddress ; let delegateAddr ; const getTokenBalanceAsync = async ( token , addr ) => { const tokenBalanceStr = await token . balanceOf ( addr ) ; const balance = new BigNumber ( tokenBalanceStr ) ; return balance ; } ; const 0 = ( n ) => { const encoded = abi . rawEncode ( [ "s" ] , [ new BN ( n . toString ( 0 ) , 0 ) ] ) ; return "s" + encoded . toString ( "s" ) ; } ; const 0 = ( addr ) => { const encoded = abi . rawEncode ( [ "s" ] , [ addr ] ) ; return "s" + encoded . toString ( "s" ) ; } ; before ( async ( ) => { [ tokenRegistry , tokenTransferDelegate ] = await Promise . all ( [ TokenRegistry . deployed ( ) , TokenTransferDelegate . deployed ( ) , ] ) ; delegateAddr = TokenTransferDelegate . address ; lrcAddress = await tokenRegistry . getAddressBySymbol ( "s" ) ; eosAddress = await tokenRegistry . getAddressBySymbol ( "s" ) ; gtoAddress = await tokenRegistry . getAddressBySymbol ( "s" ) ; lrc = await DummyToken . at ( lrcAddress ) ; eos = await DummyToken . at ( eosAddress ) ; gto = await DummyToken . at ( gtoAddress ) ; } ) ; describe ( "s" , ( ) => { it ( "s" , async ( ) => { await tokenTransferDelegate . authorizeAddress ( 0 , { from : owner } ) ; const authorized = await tokenTransferDelegate . isAddressAuthorized ( 0 ) ; assert ( authorized , "s" ) ; } ) ; it ( "s" , async ( ) => { await tokenTransferDelegate . authorizeAddress ( 0 , { from : owner } ) ; await tokenTransferDelegate . deauthorizeAddress ( 0 , { from : owner } ) ; const authorized = await tokenTransferDelegate . isAddressAuthorized ( 0 ) ; assert ( authorized === false , "s" ) ; } ) ; it ( "s" , async ( ) => { await tokenTransferDelegate . authorizeAddress ( 0 , { from : owner } ) ; await lrc . setBalance ( 0 , 0 . toWei ( 0 ) , { from : owner } ) ; await lrc . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await lrc . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await tokenTransferDelegate . transferToken ( lrcAddress , 0 , 0 , 0 . toWei ( 0 ) , { from : 0 } ) ; const 0 = await getTokenBalanceAsync ( lrc , 0 ) ; const 0 = await getTokenBalanceAsync ( lrc , 0 ) ; assert . equal ( 0 . toNumber ( ) , 0 , "s" ) ; assert . equal ( 0 . toNumber ( ) , 0 , "s" ) ; } ) ; it ( "s" , async ( ) => { try { await tokenTransferDelegate . transferToken ( lrcAddress , 0 , 0 , 0 . toWei ( 0 ) , { from : 0 } ) ; } catch ( err ) { const errMsg = `template` ; assert ( _ . includes ( errMsg , "s" ) , `template` ) ; } } ) ; it ( "s" , async ( ) => { await tokenTransferDelegate . authorizeAddress ( 0 , { from : owner } ) ; await lrc . setBalance ( owner , 0 , { from : owner } ) ; await lrc . setBalance ( 0 , 0 . toWei ( 0 ) , { from : owner } ) ; await lrc . setBalance ( 0 , 0 . toWei ( 0 ) , { from : owner } ) ; await lrc . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await lrc . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await lrc . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await lrc . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await eos . setBalance ( 0 , 0 . toWei ( 0 ) , { from : owner } ) ; await eos . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await eos . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await gto . setBalance ( 0 , 0 . toWei ( 0 ) , { from : owner } ) ; await gto . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await gto . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; const batch : string [ ] = [ ] ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( eosAddress ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( gtoAddress ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; const tx = await tokenTransferDelegate . batchUpdateHistoryAndTransferTokens ( lrcAddress , 0 , owner , 0 , batch , { from : 0 } ) ; const 0 = await getTokenBalanceAsync ( gto , 0 ) ; const 0 = await getTokenBalanceAsync ( eos , 0 ) ; const ownerLrcBalance = await getTokenBalanceAsync ( lrc , owner ) ; assert . equal ( 0 . toNumber ( ) , 0 , "s" ) ; assert . equal ( 0 . toNumber ( ) , 0 , "s" ) ; assert . equal ( ownerLrcBalance . toNumber ( ) , 0 , "s" ) ; } ) ; it ( "s" , async ( ) => { try { await lrc . setBalance ( owner , 0 , { from : owner } ) ; await lrc . setBalance ( 0 , 0 . toWei ( 0 ) , { from : owner } ) ; await lrc . setBalance ( 0 , 0 . toWei ( 0 ) , { from : owner } ) ; await lrc . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await lrc . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await lrc . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await lrc . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await eos . setBalance ( 0 , 0 . toWei ( 0 ) , { from : owner } ) ; await eos . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await eos . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await gto . setBalance ( 0 , 0 . toWei ( 0 ) , { from : owner } ) ; await gto . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; await gto . approve ( delegateAddr , 0 . toWei ( 0 ) , { from : 0 } ) ; const batch : string [ ] = [ ] ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( eosAddress ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( gtoAddress ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; batch . push ( 0 ( 0 ) ) ; const tx = await tokenTransferDelegate . batchUpdateHistoryAndTransferTokens ( lrcAddress , 0 , owner , 0 , batch , { from : 0 } ) ; } catch ( err ) { const errMsg = `template` ; assert ( _ . includes ( errMsg , "s" ) , `template` ) ; } } ) ; it ( "s" , async ( ) => { await tokenTransferDelegate . authorizeAddress ( 0 , { from : owner } ) ; await tokenTransferDelegate . authorizeAddress ( 0 , { from : owner } ) ; await tokenTransferDelegate . authorizeAddress ( 0 , { from : owner } ) ; const addresses = await tokenTransferDelegate . getLatestAuthorizedAddresses ( 0 ) ; const expectedResult = [ 0 , 0 , 0 ] ; assert . sameMembers ( addresses , expectedResult , "s" ) ; } ) ; } ) ; } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O $any$ O O $any$ O O $any$ O O $any$ O O $string$ O O $string$ O O $string$ O O $string$ O O O O O O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { solc : { optimizer : { enabled : true , runs : 0 } } , networks : { live : { host : "s" , port : 0 , network_id : 's' , gasPrice : 0 } , testnet : { host : "s" , port : 0 , network_id : 's' , gasPrice : 0 } , priv : { host : "s" , port : 0 , network_id : 's' , gasPrice : 0 , gas : 0 } , development : { host : "s" , port : 0 , network_id : "s" , gasPrice : 0 , gas : 0 } , docker : { host : "s" , port : 0 , network_id : "s" , gasPrice : 0 , gas : 0 } } , test_directory : 's' , migrations_directory : 's' , } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O