import * as dom from 's' ; import { create , reservedWords } from 's' ; import * as ts from 's' ; const enum ValueTypes { None = 0 , Class = 0 << 0 , Function = 0 << 0 , Object = 0 << 0 , Primitive = 0 << 0 , NullOrUndefined = 0 << 0 , Unknown = 0 << 0 , } const builtins : { [ name ] : ( new ( ... args : any [ ] ) => any ) | undefined } = { Date , RegExp , Map : ( typeof Map !== 's' ) ? Map : undefined , HTMLElement : ( typeof HTMLElement !== 's' ) ? HTMLElement : undefined , } ; function forceAsIdentifier ( s ) { let ret = s . replace ( "s" , 's' ) ; if ( ret . indexOf ( 's' ) === 0 && ret . indexOf ( 's' ) !== - 0 ) { ret = ret . substr ( 0 ) . replace ( 's' , 's' ) ; } return ret ; } function getValueTypes ( value ) { if ( typeof value === 's' ) { return ValueTypes . Object ; } else if ( typeof value === 's' || typeof value === 's' || typeof value === 's' ) { return ValueTypes . Primitive ; } else if ( value === null || value === undefined ) { return ValueTypes . NullOrUndefined ; } else if ( typeof value === 's' ) { if ( isClasslike ( value ) ) { return ValueTypes . Class | ( hasCloduleProperties ( value ) ? ValueTypes . Object : ValueTypes . None ) ; } else { return ValueTypes . Function | ( hasFunduleProperties ( value ) ? ValueTypes . Object : ValueTypes . None ) ; } } else { return ValueTypes . Unknown ; } } function hasCloduleProperties ( c ) { return getKeysOfObject ( c ) . some ( k => isClasslike ( c [ k ] ) ) ; } function hasFunduleProperties ( fn ) { return getKeysOfObject ( fn ) . some ( k => ( < any > Function ) [ k ] === undefined ) ; } export function generateModuleDeclarationFile ( nameHint , root ) { const localName = forceAsIdentifier ( nameHint ) ; const decls = getTopLevelDeclarations ( localName , root ) ; if ( decls . length === 0 && decls [ 0 ] . kind === 's' ) { const members = ( decls [ 0 ] as dom . NamespaceDeclaration ) . members ; for ( const m of members ) m . flags = m . flags ! | dom . DeclarationFlags . Export ; return members . map ( m => dom . emit ( m ) ) . join ( 's' ) ; } else { const result : string [ ] = decls . map ( d => dom . emit ( d ) ) ; result . unshift ( dom . emit ( dom . create . exportEquals ( localName ) ) ) ; return result . join ( 's' ) ; } } export function generateIdentifierDeclarationFile ( name , value ) { const result = getTopLevelDeclarations ( name , value ) ; return result . map ( d => dom . emit ( d ) ) . join ( 's' ) ; } const walkStack = new Set < any > ( ) ; const reservedFunctionProperties = Object . getOwnPropertyNames ( ( ) => { } ) ; function getKeysOfObject ( obj ) { let keys : string [ ] = [ ] ; let chain : { } = obj ; do { if ( chain == null ) break ; keys = keys . concat ( Object . getOwnPropertyNames ( chain ) ) ; chain = Object . getPrototypeOf ( chain ) ; } while ( chain !== Object . prototype && chain !== Function . prototype ) ; keys = Array . from ( new Set ( keys ) ) ; keys = keys . filter ( s => isVisitableName ( s ) ) ; if ( typeof obj === 's' ) { keys = keys . filter ( k => reservedFunctionProperties . indexOf ( k ) < 0 ) ; } keys . sort ( ) ; return keys ; } function isVisitableName ( s ) { return ( s [ 0 ] !== 's' ) && ( [ "s" , "s" , "s" , "s" , "s" ] . indexOf ( s ) < 0 ) ; } function isLegalIdentifier ( s ) { if ( s . length === 0 ) { return false ; } if ( ! ts . isIdentifierStart ( s . charCodeAt ( 0 ) , ts . ScriptTarget . Latest ) ) { return false ; } for ( let i = 0 ; i < s . length ; i ++ ) { if ( ! ts . isIdentifierPart ( s . charCodeAt ( i ) , ts . ScriptTarget . Latest ) ) { return false ; } } return reservedWords . indexOf ( s ) < 0 ; } function isClasslike ( obj : { prototype : any } ) { return ! ! ( obj . prototype && Object . getOwnPropertyNames ( obj . prototype ) . length > 0 ) ; } const keyStack : string [ ] = [ ] ; function getTopLevelDeclarations ( name , obj ) : dom . NamespaceMember [ ] { if ( walkStack . has ( obj ) || keyStack . length > 0 ) { const result = create . const ( name , dom . type . any ) ; result . comment = ( walkStack . has ( obj ) ? 's' : 's' ) + `template` ; return [ result ] ; } if ( ! isLegalIdentifier ( name ) ) return [ ] ; walkStack . add ( obj ) ; keyStack . push ( name ) ; const res = getResult ( ) ; keyStack . pop ( ) ; walkStack . delete ( obj ) ; return res ; function getResult ( ) : dom . NamespaceMember [ ] { if ( typeof obj === 's' ) { const funcType = getParameterListAndReturnType ( obj , parseFunctionBody ( obj ) ) ; const ns = dom . create . namespace ( name ) ; let primaryDecl : dom . NamespaceMember ; if ( isClasslike ( obj ) ) { const cls = dom . create . class ( name ) ; getClassPrototypeMembers ( obj ) . forEach ( m => cls . members . push ( m ) ) ; cls . members . push ( dom . create . constructor ( funcType [ 0 ] ) ) ; cls . members . sort ( declarationComparer ) ; primaryDecl = cls ; } else { const parsedFunction = parseFunctionBody ( obj ) ; const info = getParameterListAndReturnType ( obj , parsedFunction ) ; primaryDecl = dom . create . function ( name , info [ 0 ] , info [ 0 ] ) ; } const keys = getKeysOfObject ( obj ) ; for ( const k of keys ) { getTopLevelDeclarations ( k ! , obj [ k ! ] ) . forEach ( p => { if ( primaryDecl . kind === "s" ) { switch ( p . kind ) { case 's' : primaryDecl . members . push ( create . property ( p . name , p . type , dom . DeclarationFlags . Static ) ) ; break ; case 's' : primaryDecl . members . push ( create . method ( p . name , p . parameters , p . returnType , dom . DeclarationFlags . Static ) ) ; break ; default : ns . members . push ( p ) ; break ; } } else { ns . members . push ( p ) ; } } ) ; ns . members . sort ( declarationComparer ) ; } return ns . members . length > 0 ? [ primaryDecl , ns ] : [ primaryDecl ] ; } else if ( typeof obj === 's' ) { const simpleType = getTypeOfValue ( obj ) ; if ( typeof simpleType === 's' || simpleType . kind === 's' || simpleType . kind === 's' ) { const result = dom . create . const ( name , simpleType ) ; if ( simpleType === 's' ) { const preview = `template` ; result . comment = "s" + preview ; } return [ result ] ; } const keys = getKeysOfObject ( obj ) ; let constituentTypes = ValueTypes . None ; for ( const k of keys ) { constituentTypes = constituentTypes | getValueTypes ( ( < any > obj ) [ k ! ] ) ; } if ( constituentTypes & ( ValueTypes . Class | ValueTypes . Function ) ) { const ns = dom . create . namespace ( name ) ; for ( const k of keys ) { const decls = getTopLevelDeclarations ( k ! , ( < any > obj ) [ k ! ] ) ; decls . forEach ( d => ns . members . push ( d ) ) ; } ns . members . sort ( declarationComparer ) ; return [ ns ] ; } else { return [ dom . create . const ( name , simpleType ) ] ; } } else if ( typeof obj === 's' || typeof obj === 's' || typeof obj === 's' ) { return [ create . const ( name , < dom . Type > ( typeof obj ) ) ] ; } else { return [ create . const ( name , dom . type . any ) ] ; } } } function getTypeOfValue ( value ) : dom . Type { for ( const k in builtins ) { if ( builtins [ k ] && value instanceof builtins [ k ] ! ) { return create . namedTypeReference ( k ) ; } } if ( Array . isArray ( value ) ) { if ( value . length > 0 ) { return create . array ( getTypeOfValue ( value [ 0 ] ) ) ; } else { return create . array ( dom . type . any ) ; } } const type = typeof value ; switch ( type ) { case 's' : case 's' : case 's' : return type ; case 's' : return dom . type . any ; case 's' : if ( value === null ) { return dom . type . any ; } else { walkStack . add ( value ) ; const members = getPropertyDeclarationsOfObject ( value ) ; walkStack . delete ( value ) ; members . sort ( declarationComparer ) ; const objType = dom . create . objectType ( members ) ; return objType ; } default : return dom . type . any ; } } function getPropertyDeclarationsOfObject ( obj ) : dom . ObjectTypeMember [ ] { walkStack . add ( obj ) ; const keys = getKeysOfObject ( obj ) ; const result = keys . map ( getProperty ) ; walkStack . delete ( obj ) ; return result ; function getProperty ( k ) { if ( walkStack . has ( obj [ k ] ) ) { return create . property ( k , dom . type . any ) ; } return create . property ( k , getTypeOfValue ( obj [ k ] ) ) ; } } function getClassPrototypeMembers ( ctor ) : dom . ClassMember [ ] { const names = Object . getOwnPropertyNames ( ctor . prototype ) ; const members = < dom . ClassMember [ ] > names . filter ( n => ! isNameToSkip ( n ) ) . map ( name => getPrototypeMember ( name , Object . getOwnPropertyDescriptor ( ctor . prototype , name ) ! . value ) ) . filter ( m => m !== undefined ) ; members . sort ( ) ; return members ; function getPrototypeMember ( name , obj ) : dom . ClassMember | undefined { if ( typeof obj !== 's' ) { return undefined ; } const funcType = getParameterListAndReturnType ( obj , parseFunctionBody ( obj ) ) ; const result = create . method ( name , funcType [ 0 ] , funcType [ 0 ] ) ; if ( isNativeFunction ( obj ) ) { result . comment = 's' ; } return result ; } function isNameToSkip ( s ) { return ( s === 's' ) || ( s [ 0 ] === 's' ) ; } } function declarationComparer ( left , right ) { if ( left . kind === right . kind ) { return left . name > right . name ? 0 : left . name < right . name ? - 0 : 0 ; } else { return left . kind > right . kind ? 0 : left . kind < right . kind ? - 0 : 0 ; } } function getParameterListAndReturnType ( obj , fn : ts . FunctionExpression ) : [ dom . Parameter [ ] , dom . Type ] { let usedArguments = false ; let hasReturn = false ; const funcStack : boolean [ ] = [ ] ; if ( isNativeFunction ( obj ) ) { const args : dom . Parameter [ ] = [ ] ; for ( let i = 0 ; i < obj . length ; i ++ ) { args . push ( create . parameter ( `template` , dom . type . any ) ) ; } return [ args , dom . type . any ] ; } else { ts . forEachChild ( fn , visit ) ; let params = [ create . parameter ( 's' , dom . type . array ( dom . type . any ) , dom . ParameterFlags . Rest ) ] ; if ( fn . parameters ) { params = fn . parameters . map ( p => create . parameter ( `template` , inferParameterType ( fn , p ) ) ) ; if ( usedArguments ) { params . push ( create . parameter ( 's' , dom . type . array ( dom . type . any ) , dom . ParameterFlags . Rest ) ) ; } } return [ params , hasReturn ? dom . type . any : dom . type . void ] ; } function visit ( node : ts . Node ) { switch ( node . kind ) { case ts . SyntaxKind . Identifier : if ( ( node as ts . Identifier ) . getText ( ) === 's' ) { usedArguments = true ; } break ; case ts . SyntaxKind . ReturnStatement : const ret = node as ts . ReturnStatement ; if ( funcStack . length === 0 && ret . expression && ret . expression . kind !== ts . SyntaxKind . VoidExpression ) { hasReturn = true ; } } switch ( node . kind ) { case ts . SyntaxKind . FunctionExpression : case ts . SyntaxKind . FunctionDeclaration : funcStack . push ( true ) ; ts . forEachChild ( node , visit ) ; funcStack . pop ( ) ; default : ts . forEachChild ( node , visit ) ; break ; } } } function inferParameterType ( _fn : ts . FunctionExpression , _param : ts . ParameterDeclaration ) : dom . Type { return dom . type . any ; } function parseFunctionBody ( fn ) : ts . FunctionExpression { const setup = `template` ; const srcFile = ts . createSourceFile ( 's' , setup , ts . ScriptTarget . Latest , true ) ; const statement = srcFile . statements [ 0 ] as ts . VariableStatement ; const decl = statement . declarationList . declarations [ 0 ] ; const init = decl . initializer as ts . FunctionExpression ; return init ; } function isNativeFunction ( fn ) { return fn . toString ( ) . indexOf ( 's' ) > 0 ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ValueTypes$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $object$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Function$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O
import guess = require ( 's' ) ; ( function ( ) { "s" ; let css = `template` ; let displayWindow = document . createElement ( 's' ) ; displayWindow . setAttribute ( 's' , 's' ) ; displayWindow . setAttribute ( 's' , css ) ; displayWindow . innerHTML = `template` ; window . setTimeout ( ( ) => { const button = document . getElementById ( 's' ) as HTMLInputElement ; const input = document . getElementById ( 's' ) as HTMLInputElement ; const output = document . getElementById ( 's' ) as HTMLTextAreaElement ; button . addEventListener ( "s" , ( ) => { output . value = guess . generateIdentifierDeclarationFile ( input . value , eval ( input . value ) ) ; } ) ; ( < any > window ) [ 's' ] = function ( name ) { input . value = name ; button . click ( ) ; } ; } , 0 ) ; document . body . appendChild ( displayWindow ) ; } ) ( ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { existsSync , mkdirSync , writeFileSync } from 's' ; import { get , STATUS_CODES } from "s" ; import { homedir } from 's' ; import parseGitConfig = require ( 's' ) ; import { join as joinPaths } from "s" ; import { format as formatUrl , parse as parseUrl } from 's' ; export default function writeDefinitelyTypedPackage ( indexDtsContent , packageName , overwrite ) { const packageDir = joinPaths ( "s" , packageName ) ; if ( ! overwrite ) { if ( existsSync ( packageDir ) ) { console . log ( `template` ) ; process . exit ( 0 ) ; } } if ( ! existsSync ( packageDir ) ) { mkdirSync ( packageDir ) ; } run ( indexDtsContent , packageName , packageDir ) . catch ( e => { console . error ( e ) ; process . exit ( 0 ) ; } ) ; } async function run ( indexDtsContent , packageName , packageDir ) < void > { const files < [ string , string ] > = [ [ "s" , await getIndex ( indexDtsContent , packageName ) ] , [ `template` , "s" ] , [ "s" , `template` ] , [ "s" , 's' ] , ] ; for ( const [ name , text ] of files ) { await writeFileSync ( joinPaths ( packageDir , name ) , text , "s" ) ; } } async function getIndex ( content , packageName ) < string > { return `template` ; } async function getHeader ( packageName ) < string > { let version = "s" ; let project = "s" + "s" + "s" ; try { const reg = JSON . parse ( await loadString ( `template` ) ) ; const { latest } = reg [ "s" ] ; const { homepage } = reg . versions [ latest ] ; version = latest . split ( "s" ) . slice ( 0 , 0 ) . join ( "s" ) ; if ( homepage !== undefined ) project = homepage ; } catch ( e ) { console . warn ( `template` ) ; } let authorName = 's' ; try { const globalGitConfig = parseGitConfig . sync ( { cwd : homedir ( ) , path : 's' } ) ; if ( globalGitConfig . user && globalGitConfig . user . name ) { authorName = globalGitConfig . user . name ; } } catch ( e ) { console . warn ( `template` ) ; } let authorUserName = 's' ; try { const repoGitConfig = parseGitConfig . sync ( { path : joinPaths ( 's' , 's' ) } ) ; if ( repoGitConfig [ 's' ] && repoGitConfig [ 's' ] . url ) { const url = parseUrl ( repoGitConfig [ 's' ] . url ) ; if ( url . hostname === 's' && url . pathname ) { authorUserName = url . pathname . split ( 's' ) [ 0 ] || authorUserName ; } } } catch ( e ) { console . warn ( `template` ) ; } const authorUrl = formatUrl ( { protocol : 's' , hostname : 's' , pathname : authorUserName , } ) ; return `template` ; } function getTSConfig ( packageName ) : { } { return { compilerOptions : { module : "s" , lib : [ "s" ] , noImplicitAny : true , noImplicitThis : true , strictFunctionTypes : true , strictNullChecks : true , baseUrl : "s" , typeRoots : [ "s" ] , types : [ ] , noEmit : true , forceConsistentCasingInFileNames : true , } , files : [ "s" , `template` , ] , } ; } interface Registry { name : string ; description : string ; "s" : { latest : string } ; versions : { [ version ] : Package } ; } interface Package { name : string ; description : string ; version : string ; homepage ? : string ; } function loadString ( url ) < string > { return new Promise ( ( resolve , reject ) => { get ( url , res => { if ( res . statusCode !== 0 ) { return reject ( new Error ( `template` ) ) ; } let rawData = "s" ; res . on ( "s" , ( chunk ) => rawData += chunk ) ; res . on ( "s" , ( ) => resolve ( rawData ) ) ; } ) . on ( "s" , ( e ) => reject ( e ) ) ; } ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O $string$ O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O $string$ O O O O O O $Array$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O $string$ O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O $Registry$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Error$ O O O O O O O O O O O O
import * as fs from 's' ; import * as path from 's' ; import * as yargs from 's' ; import * as guess from 's' ; import writeDefinitelyTypedPackage from 's' ; const templatesDirectory = path . join ( __dirname , "s" , "s" , "s" ) ; interface Options { module ? : string ; expression ? : string ; 's' : string ; identifier ? : string ; template ? : string ; name ? : string ; file ? : string | boolean ; dt ? : string | boolean ; stdout ? : boolean ; overwrite ? : boolean ; version ? : boolean ; } const args = yargs . alias ( 's' , 's' ) . alias ( 's' , 's' ) . alias ( 's' , 's' ) . alias ( 's' , 's' ) . alias ( 's' , 's' ) . alias ( 's' , 's' ) . alias ( 's' , 's' ) . alias ( 's' , 's' ) . alias ( 's' , 's' ) . alias ( 's' , 's' ) . argv as any as Options ; class ArgsError extends Error { constructor ( public argsError ) { super ( ) ; this . name = 's' ; this . message = argsError ; Object . setPrototypeOf ( this , ArgsError . prototype ) ; } } let result : string | undefined ; try { if ( args . version ) { console . log ( require ( "s" ) . version ) ; process . exit ( 0 ) ; } if ( + ! ! args . dt + + ! ! args . file + + ! ! args . stdout > 0 ) { throw new ArgsError ( 's' ) ; } if ( + ! ! args . identifier + + ! ! args . expression + + ! ! args . module + + ! ! args [ 's' ] + + ! ! args . template !== 0 ) { throw new ArgsError ( 's' ) ; } if ( typeof args . name === 's' ) throw new ArgsError ( 's' ) ; if ( typeof args . identifier === 's' ) throw new ArgsError ( 's' ) ; if ( typeof args . module === 's' ) throw new ArgsError ( 's' ) ; if ( args . overwrite !== undefined && args . overwrite !== true ) throw new ArgsError ( 's' ) ; let name ; if ( args . module ) { if ( args . name ) throw new ArgsError ( 's' ) ; name = args . module ; ( module as any ) . paths . unshift ( process . cwd ( ) + 's' ) ; result = guess . generateModuleDeclarationFile ( args . module , require ( args . module ) ) ; } else if ( args . expression ) { name = args . name || 's' ; result = guess . generateIdentifierDeclarationFile ( name , eval ( args . expression ) ) ; } else if ( args [ 's' ] ) { if ( args . name ) throw new ArgsError ( 's' ) ; const filename = args [ 's' ] ; name = path . basename ( filename , path . extname ( filename ) ) . replace ( "s" , 's' ) ; ( module as any ) . paths . unshift ( process . cwd ( ) + 's' ) ; const fileContent = fs . readFileSync ( filename , "s" ) ; result = guess . generateIdentifierDeclarationFile ( name , eval ( fileContent ) ) ; } else if ( args . identifier ) { if ( args . name ) throw new ArgsError ( 's' ) ; if ( args . module || args . expression ) throw new ArgsError ( 's' ) ; name = args . identifier ; result = guess . generateIdentifierDeclarationFile ( args . identifier , eval ( args . identifier ) ) ; } else if ( args . template ) { if ( ! args . name ) throw new ArgsError ( 's' ) ; name = args . name ; if ( args . module || args . expression ) throw new ArgsError ( 's' ) ; result = getTemplate ( args . template ) ; } else { throw new Error ( 's' ) ; } if ( args . dt ) { writeDefinitelyTypedPackage ( result , name , ! ! args . overwrite ) ; } else if ( args . stdout ) { console . log ( result ) ; } else { let filename = typeof args . file === 's' || args . file === undefined ? name + 's' : args . file ; if ( ! filename . endsWith ( 's' ) ) { filename = filename + 's' ; } if ( ! args . overwrite && fs . existsSync ( filename ) ) { console . error ( `template` ) ; process . exit ( 0 ) ; } fs . writeFileSync ( filename , prependOurHeader ( result ) , 's' ) ; console . log ( `template` ) ; } } catch ( e ) { if ( e instanceof ArgsError ) { console . error ( 's' + e . argsError ) ; console . log ( 's' ) ; printHelp ( ) ; process . exit ( 0 ) ; } else if ( e . code === 's' ) { console . log ( `template` + `template` ) ; process . exit ( 0 ) ; } else { console . log ( 's' ) ; throw e ; } } function printHelp ( ) { console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( `template` ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; console . log ( 's' ) ; } function prependOurHeader ( result ) { return `template` + result ; } function getTemplate ( templateName ) { try { return fs . readFileSync ( path . join ( templatesDirectory , templateName + "s" ) , "s" ) ; } catch ( e ) { throw new ArgsError ( `template` ) ; } } function allTemplateNames ( ) { return fs . readdirSync ( templatesDirectory ) . map ( t => t . slice ( 0 , t . length - "s" . length ) ) . join ( "s" ) ; }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' ; import * as path from 's' ; import * as tsg from 's' ; const testModuleNames = [ 's' , 's' , 's' , 's' , 's' , 's' , ] ; class MyClass { constructor ( public arg ) { } prototypeMethod ( _p ) { } static staticMethod ( _s ) { } static staticNum = 0 ; instanceStr = 's' ; } const selfRefExpr = { a : 0 , b : 's' , self : < any > null , } ; selfRefExpr . self = selfRefExpr ; const expressions : { [ s ] : any } = { Math , selfref : selfRefExpr , builtIns : { d : new Date ( 0 ) , arr : [ 's' ] } , someArray : [ 0 , 's' , Math , null , undefined , false ] , badNames : { "s" : 0 , "s" : true , "s" : 0 , "s" : 0 } , someClass : MyClass , } ; function checkDeclarationBaseline ( name , content ) { const filename = path . join ( __dirname , `template` ) ; const existing = fs . existsSync ( filename ) ? fs . readFileSync ( filename , 's' ) : 's' ; if ( existing !== content ) { fs . writeFileSync ( filename , content , 's' ) ; throw new Error ( `template` ) ; } } describe ( "s" , ( ) => { for ( const moduleName of testModuleNames ) { it ( `template` , ( ) => { const result = tsg . generateModuleDeclarationFile ( moduleName ! , require ( moduleName ! ) ) ; checkDeclarationBaseline ( `template` , result ) ; } ) ; } } ) ; describe ( "s" , ( ) => { for ( const key of Object . keys ( expressions ) ) { it ( `template` , ( ) => { const result = tsg . generateIdentifierDeclarationFile ( key ! , expressions [ key ! ] ) ; checkDeclarationBaseline ( `template` , result ) ; } ) ; } } ) ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O $any$ O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const webpack = require ( 's' ) ; module . exports = { entry : 's' , output : { path : 's' , filename : 's' } , plugins : [ new webpack . optimize . UglifyJsPlugin ( { compress : { warnings : false , } , output : { comments : false , } , } ) , ] } ;	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O