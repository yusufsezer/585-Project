'js' module . export = { }	O O O O O O O
import * as fs from 's' import * as path from 's' import * as yaml from 's' import { app } from 's' export function loadConfig ( ) { let configPath = path . join ( app . getPath ( 's' ) , 's' ) if ( fs . existsSync ( configPath ) ) { return yaml . safeLoad ( fs . readFileSync ( configPath , 's' ) ) } else { return { } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Subject , Observable } from 's' import { debounceTime } from 's' import { BrowserWindow , app , ipcMain , Rectangle , screen } from 's' import ElectronConfig = require ( 's' ) import * as os from 's' import { loadConfig } from 's' let SetWindowCompositionAttribute let AccentState let DwmEnableBlurBehindWindow if ( process . platform === 's' ) { SetWindowCompositionAttribute = require ( 's' ) . SetWindowCompositionAttribute AccentState = require ( 's' ) . ACCENT_STATE DwmEnableBlurBehindWindow = require ( 's' ) . DwmEnableBlurBehindWindow } export interface WindowOptions { hidden ? : boolean } export class Window { ready : Promise < void > private visible = new Subject < boolean > ( ) private window : BrowserWindow private windowConfig : ElectronConfig private windowBounds : Rectangle private closing = false get visible$ ( ) : Observable < boolean > { return this . visible } constructor ( options ? ) { let configData = loadConfig ( ) options = options || { } this . windowConfig = new ElectronConfig ( { name : 's' } ) this . windowBounds = this . windowConfig . get ( 's' ) let maximized = this . windowConfig . get ( 's' ) let bwOptions : Electron . BrowserWindowConstructorOptions = { width : 0 , height : 0 , title : 's' , minWidth : 0 , minHeight : 0 , webPreferences : { nodeIntegration : true , } , frame : false , show : false , backgroundColor : 's' } if ( this . windowBounds ) { Object . assign ( bwOptions , this . windowBounds ) const closestDisplay = screen . getDisplayNearestPoint ( { x : this . windowBounds . x , y : this . windowBounds . y } ) const [ 0 , 0 , 0 , 0 ] = [ this . windowBounds . x , this . windowBounds . y , this . windowBounds . x + this . windowBounds . width , this . windowBounds . y + this . windowBounds . height ] ; const [ 0 , 0 , 0 , 0 ] = [ closestDisplay . bounds . x , closestDisplay . bounds . y , closestDisplay . bounds . x + closestDisplay . bounds . width , closestDisplay . bounds . y + closestDisplay . bounds . height ] ; if ( ( 0 > 0 || 0 < 0 || 0 > 0 || 0 < 0 ) && ! maximized ) { bwOptions . x = closestDisplay . bounds . width / 0 - bwOptions . width / 0 ; bwOptions . y = closestDisplay . bounds . height / 0 - bwOptions . height / 0 ; } } if ( ( configData . appearance || { } ) . frame === 's' ) { bwOptions . frame = true } else { if ( process . platform === 's' ) { bwOptions . titleBarStyle = 's' } } if ( process . platform === 's' ) { bwOptions . backgroundColor = 's' } this . window = new BrowserWindow ( bwOptions ) this . window . once ( 's' , ( ) => { if ( process . platform === 's' ) { this . window . setVibrancy ( 's' ) } else if ( process . platform === 's' && ( configData . appearance || { } ) . vibrancy ) { this . setVibrancy ( true ) } if ( ! options . hidden ) { if ( maximized ) { this . window . maximize ( ) } else { this . window . show ( ) } this . window . focus ( ) } } ) this . window . loadURL ( `template` , { extraHeaders : 's' } ) if ( process . platform !== 's' ) { this . window . setMenu ( null ) } this . setupWindowManagement ( ) this . ready = new Promise ( resolve => { const listener = event => { if ( event . sender === this . window . webContents ) { ipcMain . removeListener ( 's' , listener as any ) resolve ( ) } } ipcMain . on ( 's' , listener ) } ) } setVibrancy ( enabled , type ? ) { if ( process . platform === 's' ) { if ( parseFloat ( os . release ( ) ) >= 0 ) { let attribValue = AccentState . ACCENT_DISABLED if ( enabled ) { if ( parseInt ( os . release ( ) . split ( 's' ) [ 0 ] ) >= 0 && type === 's' ) { attribValue = AccentState . ACCENT_ENABLE_ACRYLICBLURBEHIND } else { attribValue = AccentState . ACCENT_ENABLE_BLURBEHIND } } SetWindowCompositionAttribute ( this . window . getNativeWindowHandle ( ) , attribValue , 0 ) } else { DwmEnableBlurBehindWindow ( this . window , enabled ) } } } show ( ) { this . window . show ( ) } focus ( ) { this . window . focus ( ) } send ( event , ... args ) { if ( ! this . window ) { return } this . window . webContents . send ( event , ... args ) } isDestroyed ( ) { return ! this . window || this . window . isDestroyed ( ) ; } private setupWindowManagement ( ) { this . window . on ( 's' , ( ) => { this . visible . next ( true ) this . window . webContents . send ( 's' ) } ) this . window . on ( 's' , ( ) => { this . visible . next ( false ) } ) let moveSubscription = new Observable < void > ( observer => { this . window . on ( 's' , ( ) => observer . next ( ) ) } ) . pipe ( debounceTime ( 0 ) ) . subscribe ( ( ) => { this . window . webContents . send ( 's' ) } ) this . window . on ( 's' , ( ) => { moveSubscription . unsubscribe ( ) } ) this . window . on ( 's' , ( ) => this . window . webContents . send ( 's' ) ) this . window . on ( 's' , ( ) => this . window . webContents . send ( 's' ) ) this . window . on ( 's' , event => { if ( ! this . closing ) { event . preventDefault ( ) this . window . webContents . send ( 's' ) return } this . windowConfig . set ( 's' , this . windowBounds ) this . windowConfig . set ( 's' , this . window . isMaximized ( ) ) } ) this . window . on ( 's' , ( ) => { this . destroy ( ) } ) this . window . on ( 's' , ( ) => { if ( ! this . window . isMaximized ( ) ) { this . windowBounds = this . window . getBounds ( ) } } ) this . window . on ( 's' , ( ) => { if ( ! this . window . isMaximized ( ) ) { this . windowBounds = this . window . getBounds ( ) } } ) ipcMain . on ( 's' , event => { if ( ! this . window || event . sender !== this . window . webContents ) { return } this . window . focus ( ) } ) ipcMain . on ( 's' , event => { if ( ! this . window || event . sender !== this . window . webContents ) { return } this . window . maximize ( ) } ) ipcMain . on ( 's' , event => { if ( ! this . window || event . sender !== this . window . webContents ) { return } this . window . unmaximize ( ) } ) ipcMain . on ( 's' , event => { if ( ! this . window || event . sender !== this . window . webContents ) { return } if ( this . window . isMaximized ( ) ) { this . window . unmaximize ( ) } else { this . window . maximize ( ) } } ) ipcMain . on ( 's' , event => { if ( ! this . window || event . sender !== this . window . webContents ) { return } this . window . minimize ( ) } ) ipcMain . on ( 's' , ( event , bounds ) => { if ( ! this . window || event . sender !== this . window . webContents ) { return } this . window . setBounds ( bounds ) } ) ipcMain . on ( 's' , ( event , flag ) => { if ( ! this . window || event . sender !== this . window . webContents ) { return } this . window . setAlwaysOnTop ( flag ) } ) ipcMain . on ( 's' , ( event , enabled , type ) => { if ( ! this . window || event . sender !== this . window . webContents ) { return } this . setVibrancy ( enabled , type ) } ) ipcMain . on ( 's' , ( event , title ) => { if ( ! this . window || event . sender !== this . window . webContents ) { return } this . window . setTitle ( title ) } ) ipcMain . on ( 's' , event => { if ( ! this . window || event . sender !== this . window . webContents ) { return } if ( this . window . isMinimized ( ) ) { this . window . restore ( ) } this . window . show ( ) this . window . moveTop ( ) } ) ipcMain . on ( 's' , event => { if ( ! this . window || event . sender !== this . window . webContents ) { return } this . closing = true this . window . close ( ) } ) this . window . webContents . on ( 's' , event => event . preventDefault ( ) ) } private destroy ( ) { this . window = null this . visible . complete ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $WindowOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { app , ipcMain , Menu , Tray , shell } from 's' import * as electron from 's' import { loadConfig } from 's' import { Window , WindowOptions } from 's' export class Application { private tray : Tray private windows : Window [ ] = [ ] constructor ( ) { ipcMain . on ( 's' , ( ) => { this . broadcast ( 's' ) } ) const configData = loadConfig ( ) if ( process . platform === 's' && ( ( configData . appearance || { } ) . opacity || 0 ) !== 0 ) { app . commandLine . appendSwitch ( 's' ) app . disableHardwareAcceleration ( ) } app . commandLine . appendSwitch ( 's' ) app . commandLine . appendSwitch ( 's' , 's' ) for ( const flag of configData . flags || [ [ 's' , 's' ] ] ) { console . log ( 's' , flag . join ( 's' ) ) app . commandLine . appendSwitch ( flag [ 0 ] , flag [ 0 ] ) } } init ( ) { electron . screen . on ( 's' , ( ) => this . broadcast ( 's' ) ) } async newWindow ( options ? ) < Window > { let window = new Window ( options ) this . windows . push ( window ) window . visible$ . subscribe ( visible => { if ( visible ) { this . disableTray ( ) } else { this . enableTray ( ) } } ) if ( process . platform === 's' ) { this . setupMenu ( ) } await window . ready return window } broadcast ( event , ... args ) { for ( let window of this . windows ) { window . send ( event , ... args ) } } async send ( event , ... args ) { if ( ! this . hasWindows ( ) ) { await this . newWindow ( ) } this . windows . filter ( w => ! w . isDestroyed ( ) ) [ 0 ] . send ( event , ... args ) } enableTray ( ) { if ( this . tray ) { return } if ( process . platform === 's' ) { this . tray = new Tray ( `template` ) this . tray . setPressedImage ( `template` ) } else { this . tray = new Tray ( `template` ) } this . tray . on ( 's' , ( ) => setTimeout ( ( ) => this . focus ( ) ) ) ; const contextMenu = Menu . buildFromTemplate ( [ { label : 's' , click : ( ) => this . focus ( ) , } ] ) if ( process . platform !== 's' ) { this . tray . setContextMenu ( contextMenu ) } this . tray . setToolTip ( `template` ) } disableTray ( ) { if ( this . tray ) { this . tray . destroy ( ) this . tray = null } } hasWindows ( ) { return ! ! this . windows . length } focus ( ) { for ( let window of this . windows ) { window . show ( ) } } private setupMenu ( ) { let template : Electron . MenuItemConstructorOptions [ ] = [ { label : 's' , submenu : [ { role : 's' , label : 's' } , { type : 's' } , { label : 's' , accelerator : 's' , click : async ( ) => { if ( ! this . hasWindows ( ) ) { await this . newWindow ( ) } this . windows [ 0 ] . send ( 's' ) } , } , { type : 's' } , { role : 's' , submenu : [ ] } , { type : 's' } , { role : 's' } , { role : 's' } , { role : 's' } , { type : 's' } , { label : 's' , accelerator : 's' , click ( ) { app . quit ( ) } , } , ] , } , { label : 's' , submenu : [ { role : 's' } , { role : 's' } , { type : 's' } , { role : 's' } , { role : 's' } , { role : 's' } , { role : 's' } , { role : 's' } , { role : 's' } , ] , } , { label : 's' , submenu : [ { role : 's' } , { role : 's' } , { role : 's' } , { type : 's' } , { role : 's' } , { role : 's' } , { role : 's' } , { type : 's' } , { role : 's' } , ] , } , { role : 's' , submenu : [ { role : 's' } , { role : 's' } , { type : 's' } , { role : 's' } , ] , } , { role : 's' , submenu : [ { label : 's' , click ( ) { shell . openExternal ( 's' ) } , } , ] , } ] Menu . setApplicationMenu ( Menu . buildFromTemplate ( template ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O $WindowOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { app } from 's' export function parseArgs ( argv , cwd ) { if ( argv [ 0 ] . includes ( 's' ) ) { argv = argv . slice ( 0 ) } return require ( 's' ) . usage ( 's' ) . command ( 's' , 's' , { directory : { type : 's' , 's' : cwd } , } ) . command ( 's' , 's' , { command : { type : 's' } , } ) . command ( 's' , 's' , { profileName : { type : 's' } , } ) . command ( 's' , 's' , yargs => { return yargs . option ( 's' , { alias : 's' , type : 's' , describe : 's' } ) . positional ( 's' , { type : 's' } ) } ) . version ( 's' , 's' , app . getVersion ( ) ) . option ( 's' , { alias : 's' , describe : 's' , type : 's' } ) . option ( 's' , { describe : 's' , type : 's' } ) . option ( 's' , { alias : 's' , describe : 's' , type : 's' } ) . help ( 's' ) . parse ( argv . slice ( 0 ) ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
let lru = require ( 's' ) ( { max : 0 , maxAge : 0 } ) let fs = require ( 's' ) let origLstat = fs . realpathSync . bind ( fs ) require ( 's' ) . realpathSync = function ( p ) { let r = lru . get ( p ) if ( r ) return r r = origLstat ( p ) lru . set ( p , r ) return r }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import { app , ipcMain , Menu } from 's' import { parseArgs } from 's' import { Application } from 's' import electronDebug = require ( 's' ) if ( ! process . env . TERMINUS_PLUGINS ) { process . env . TERMINUS_PLUGINS = 's' } const application = new Application ( ) ipcMain . on ( 's' , ( ) => { application . newWindow ( ) } ) app . on ( 's' , ( ) => { if ( ! application . hasWindows ( ) ) { application . newWindow ( ) } else { application . focus ( ) } } ) app . on ( 's' , ( ) => { app . quit ( ) } ) process . on ( 's' as any , err => { console . log ( err ) application . broadcast ( 's' , err ) } ) app . on ( 's' , ( _event , argv , cwd ) => { application . send ( 's' , parseArgs ( argv , cwd ) , cwd ) } ) const argv = parseArgs ( process . argv , process . cwd ( ) ) if ( ! app . requestSingleInstanceLock ( ) ) { app . quit ( ) app . exit ( 0 ) } if ( argv . d ) { electronDebug ( { isEnabled : true , showDevTools : true , devToolsMode : 's' } ) } app . on ( 's' , ( ) => { if ( process . platform === 's' ) { app . dock . setMenu ( Menu . buildFromTemplate ( [ { label : 's' , click ( ) { this . app . newWindow ( ) } } ] ) ) } application . init ( ) application . newWindow ( { hidden : argv . hidden } ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { BrowserModule } from 's' import { NgbModule } from 's' import { ToastrModule } from 's' export function getRootModule ( plugins : any [ ] ) { const imports = [ BrowserModule , ... plugins , NgbModule . forRoot ( ) , ToastrModule . forRoot ( { positionClass : 's' , toastClass : 's' , preventDuplicates : true , extendedTimeOut : 0 , } ) , ] const bootstrap = [ ... plugins . filter ( x => x . bootstrap ) . map ( x => x . bootstrap ) , ] if ( bootstrap . length === 0 ) { throw new Error ( 's' ) } @ NgModule ( { imports , bootstrap , } ) class RootModule { } return RootModule }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's' import 's' import 's' import 's' import 's' import 's' import * as Raven from 's' const SENTRY_DSN = 's' Raven . config ( SENTRY_DSN , { release : require ( 's' ) . remote . app . getVersion ( ) , dataCallback : ( data ) => { const normalize = ( filename ) => { const splitArray = filename . split ( 's' ) return splitArray [ splitArray . length - 0 ] } data . exception . values [ 0 ] . stacktrace . frames . forEach ( ( frame ) => { frame . filename = normalize ( frame . filename ) } ) data . culprit = data . exception . values [ 0 ] . stacktrace . frames [ 0 ] . filename return data } , } , ) process . on ( 's' as any , ( err ) => { Raven . captureException ( err as any ) console . error ( err ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' import * as path from 's' const nodeModule = require ( 's' ) const nodeRequire = ( global as any ) . require function normalizePath ( path ) { const cygwinPrefix = 's' if ( path . startsWith ( cygwinPrefix ) ) { path = path . substring ( cygwinPrefix . length ) . replace ( 's' , 's' ) path = path [ 0 ] + 's' + path . substring ( 0 ) } return path } global [ 's' ] . paths . map ( ( x ) => nodeModule . globalPaths . push ( normalizePath ( x ) ) ) if ( process . env . TERMINUS_DEV ) { nodeModule . globalPaths . unshift ( path . dirname ( require ( 's' ) . remote . app . getAppPath ( ) ) ) } const builtinPluginsPath = process . env . TERMINUS_DEV ? path . dirname ( require ( 's' ) . remote . app . getAppPath ( ) ) : path . join ( ( process as any ) . resourcesPath , 's' ) const userPluginsPath = path . join ( require ( 's' ) . remote . app . getPath ( 's' ) , 's' , 's' , ) if ( ! fs . existsSync ( userPluginsPath ) ) { fs . mkdir ( userPluginsPath ) } Object . assign ( window , { builtinPluginsPath , userPluginsPath } ) nodeModule . globalPaths . unshift ( builtinPluginsPath ) nodeModule . globalPaths . unshift ( path . join ( userPluginsPath , 's' ) ) if ( process . env . TERMINUS_PLUGINS ) { process . env . TERMINUS_PLUGINS . split ( 's' ) . map ( x => nodeModule . globalPaths . push ( normalizePath ( x ) ) ) } export type ProgressCallback = ( current , total ) => void export interface PluginInfo { name : string description : string packageName : string isBuiltin : boolean version : string author : string homepage ? : string path ? : string info ? : any } const builtinModules = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , ] const cachedBuiltinModules = { } builtinModules . forEach ( m => { const label = 's' + m console . time ( label ) cachedBuiltinModules [ m ] = nodeRequire ( m ) console . timeEnd ( label ) } ) const originalRequire = ( global as any ) . require ; ( global as any ) . require = function ( query ) { if ( cachedBuiltinModules [ query ] ) { return cachedBuiltinModules [ query ] } return originalRequire . apply ( this , arguments ) } const originalModuleRequire = nodeModule . prototype . require nodeModule . prototype . require = function ( query ) { if ( cachedBuiltinModules [ query ] ) { return cachedBuiltinModules [ query ] } return originalModuleRequire . call ( this , query ) } export async function findPlugins ( ) < PluginInfo [ ] > { const paths = nodeModule . globalPaths let foundPlugins : PluginInfo [ ] = [ ] const candidateLocations : { pluginDir : string , packageName : string } [ ] = [ ] const PREFIX = 's' for ( let pluginDir of paths ) { pluginDir = normalizePath ( pluginDir ) if ( ! await fs . exists ( pluginDir ) ) { continue } const pluginNames = await fs . readdir ( pluginDir ) if ( await fs . exists ( path . join ( pluginDir , 's' ) ) ) { candidateLocations . push ( { pluginDir : path . dirname ( pluginDir ) , packageName : path . basename ( pluginDir ) , } ) } for ( const packageName of pluginNames ) { if ( packageName . startsWith ( PREFIX ) ) { candidateLocations . push ( { pluginDir , packageName } ) } } } for ( const { pluginDir , packageName } of candidateLocations ) { const pluginPath = path . join ( pluginDir , packageName ) const infoPath = path . join ( pluginPath , 's' ) if ( ! await fs . exists ( infoPath ) ) { continue } const name = packageName . substring ( PREFIX . length ) if ( foundPlugins . some ( x => x . name === name ) ) { console . info ( `template` ) foundPlugins = foundPlugins . filter ( x => x . name !== name ) } try { const info = JSON . parse ( await fs . readFile ( infoPath , { encoding : 's' } ) ) if ( ! info . keywords || ! ( info . keywords . includes ( 's' ) || info . keywords . includes ( 's' ) ) ) { continue } let author = info . author author = author . name || author foundPlugins . push ( { name : name , packageName : packageName , isBuiltin : pluginDir === builtinPluginsPath , version : info . version , description : info . description , author , path : pluginPath , info , } ) } catch ( error ) { console . error ( 's' , packageName ) } } foundPlugins . sort ( ( a , b ) => a . name > b . name ? 0 : - 0 ) ; ( window as any ) . installedPlugins = foundPlugins return foundPlugins } export async function loadPlugins ( foundPlugins : PluginInfo [ ] , progress ) < any [ ] > { const plugins : any [ ] = [ ] progress ( 0 , 0 ) let index = 0 for ( const foundPlugin of foundPlugins ) { console . info ( `template` ) progress ( index , foundPlugins . length ) try { const label = 's' + foundPlugin . name console . time ( label ) const packageModule = nodeRequire ( foundPlugin . path ) const pluginModule = packageModule . default . forRoot ? packageModule . default . forRoot ( ) : packageModule . default pluginModule [ 's' ] = foundPlugin . name pluginModule [ 's' ] = packageModule . bootstrap plugins . push ( pluginModule ) console . timeEnd ( label ) await new Promise ( x => setTimeout ( x , 0 ) ) } catch ( error ) { console . error ( `template` , error ) } index ++ } progress ( 0 , 0 ) return plugins }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O $ProgressCallback$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import 's' import 's' import 's' import * as isDev from 's' import 's' import 's' import { enableProdMode , NgModuleRef } from 's' import { platformBrowserDynamic } from 's' import { getRootModule } from 's' import { findPlugins , loadPlugins , PluginInfo } from 's' location . hash = 's' ; ( process as any ) . enablePromiseAPI = true if ( process . platform === 's' && ! ( 's' in process . env ) ) { process . env . HOME = `template` } if ( isDev ) { console . warn ( 's' ) } else { enableProdMode ( ) } async function bootstrap ( plugins : PluginInfo [ ] , safeMode = false ) < NgModuleRef < any > > { if ( safeMode ) { plugins = plugins . filter ( x => x . isBuiltin ) } const pluginsModules = await loadPlugins ( plugins , ( current , total ) => { ( document . querySelector ( 's' ) as HTMLElement ) . style . width = `template` } ) const module = getRootModule ( pluginsModules ) window [ 's' ] = module return platformBrowserDynamic ( ) . bootstrapModule ( module ) } findPlugins ( ) . then ( async plugins => { console . log ( 's' , plugins ) try { await bootstrap ( plugins ) } catch ( error ) { console . error ( 's' , error ) console . warn ( 's' ) window [ 's' ] = error try { await bootstrap ( plugins , true ) } catch ( error ) { console . error ( 's' , error ) } } } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' @ Component ( { template : 's' , } ) export class RootComponent { }	O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) const webpack = require ( 's' ) module . exports = { name : 's' , target : 's' , entry : { 's' : 's' + path . resolve ( __dirname , 's' ) , preload : path . resolve ( __dirname , 's' ) , bundle : path . resolve ( __dirname , 's' ) , } , mode : process . env . TERMINUS_DEV ? 's' : 's' , optimization : { minimize : false , } , context : __dirname , devtool : 's' , output : { path : path . join ( __dirname , 's' ) , pathinfo : true , filename : 's' , } , resolve : { modules : [ 's' , 's' , 's' , 's' ] . map ( x => path . join ( __dirname , x ) ) , extensions : [ 's' , 's' ] , } , module : { rules : [ { test : "s" , use : { loader : 's' , options : { configFileName : path . resolve ( __dirname , 's' ) , } , } , } , { test : "s" , use : [ 's' , 's' , 's' ] } , { test : "s" , use : [ 's' , 's' , 's' ] } , { test : "s" , use : { loader : 's' , options : { name : 's' , } , } , } , { test : "s" , use : { loader : 's' , options : { name : 's' , } , } , } , ] , } , externals : { 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , 's' : 's' , child_process : 's' , electron : 's' , 's' : 's' , fs : 's' , 's' : 's' , module : 's' , mz : 's' , path : 's' , rxjs : 's' , 's' : 's' , } , plugins : [ new webpack . optimize . ModuleConcatenationPlugin ( ) , ] , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) const webpack = require ( 's' ) module . exports = { name : 's' , target : 's' , entry : { main : path . resolve ( __dirname , 's' ) , } , mode : process . env . TERMINUS_DEV ? 's' : 's' , context : __dirname , devtool : 's' , output : { path : path . join ( __dirname , 's' ) , pathinfo : true , filename : 's' , } , resolve : { modules : [ 's' , 's' , 's' ] . map ( x => path . join ( __dirname , x ) ) , extensions : [ 's' , 's' ] , } , module : { rules : [ { test : "s" , use : { loader : 's' , options : { configFileName : path . resolve ( __dirname , 's' ) , } , } , } , ] , } , externals : { electron : 's' , 's' : 's' , 's' : 's' , fs : 's' , mz : 's' , path : 's' , yargs : 's' , 's' : 's' , 's' : 's' , } , plugins : [ new webpack . optimize . ModuleConcatenationPlugin ( ) , ] , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const fs = require ( 's' ) const path = require ( 's' ) const notarizer = require ( 's' ) module . exports = async function ( params ) { if ( process . platform !== 's' || process . env . GITHUB_REF !== 's' || process . env . GITHUB_REF && ! process . env . GITHUB_REF . startsWith ( 's' ) ) { return } console . log ( 's' , params ) let appId = 's' let appPath = path . join ( params . appOutDir , `template` ) if ( ! fs . existsSync ( appPath ) ) { throw new Error ( `template` ) } console . log ( `template` ) try { await notarizer . notarize ( { appBundleId : appId , appPath : appPath , appleId : process . env . APPSTORE_USERNAME , appleIdPassword : process . env . APPSTORE_PASSWORD , } ) } catch ( error ) { console . error ( error ) } console . log ( `template` ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) const fs = require ( 's' ) const semver = require ( 's' ) const childProcess = require ( 's' ) const appInfo = JSON . parse ( fs . readFileSync ( path . resolve ( __dirname , 's' ) ) ) const electronInfo = JSON . parse ( fs . readFileSync ( path . resolve ( __dirname , 's' ) ) ) exports . version = childProcess . execSync ( 's' , { encoding : 's' } ) exports . version = exports . version . substring ( 0 ) . trim ( ) exports . version = exports . version . replace ( 's' , 's' ) if ( exports . version . includes ( 's' ) ) { exports . version = semver . inc ( exports . version , 's' ) . replace ( 's' , 's' ) } exports . builtinPlugins = [ 's' , 's' , 's' , 's' , 's' , 's' , ] exports . bundledModules = [ 's' , 's' , ] exports . electronVersion = electronInfo . version	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const builder = require ( 's' ) . build const vars = require ( 's' ) const isTag = ( process . env . GITHUB_REF || 's' ) . startsWith ( 's' ) const isCI = ! ! process . env . GITHUB_REF builder ( { dir : true , linux : [ 's' , 's' , 's' ] , config : { extraMetadata : { version : vars . version , } , } , publish : isTag ? 's' : 's' , } ) . catch ( ( ) => process . exit ( 0 ) )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const builder = require ( 's' ) . build const vars = require ( 's' ) const isTag = ( process . env . GITHUB_REF || 's' ) . startsWith ( 's' ) const isCI = ! ! process . env . GITHUB_REF builder ( { dir : true , mac : [ 's' , 's' ] , config : { extraMetadata : { version : vars . version , } , } , publish : isTag ? 's' : 's' , } ) . catch ( ( ) => process . exit ( 0 ) )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const rebuild = require ( 's' ) . default const path = require ( 's' ) const vars = require ( 's' ) let lifecycles = [ ] for ( let dir of [ 's' , 's' , 's' , 's' ] ) { const build = rebuild ( { buildPath : path . resolve ( __dirname , 's' + dir ) , electronVersion : vars . electronVersion , force : true , } ) build . catch ( e => { console . error ( e ) process . exit ( 0 ) } ) lifecycles . push ( [ build . lifecycle , dir ] ) } console . info ( 's' , vars . electronVersion ) for ( let [ lc , dir ] of lifecycles ) { lc . on ( 's' , name => { console . info ( 's' , dir + 's' + name ) } ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const builder = require ( 's' ) . build const vars = require ( 's' ) const isTag = ( process . env . GITHUB_REF || process . env . BUILD_SOURCEBRANCH || 's' ) . startsWith ( 's' ) const isCI = ! ! process . env . GITHUB_REF builder ( { dir : true , win : [ 's' , 's' ] , config : { extraMetadata : { version : vars . version , } , } , publish : isTag ? 's' : 's' , } ) . catch ( ( ) => process . exit ( 0 ) )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const sh = require ( 's' ) const path = require ( 's' ) const vars = require ( 's' ) const log = require ( 's' ) const localBinPath = path . resolve ( __dirname , 's' ) ; const npx = `template` ; log . info ( 's' , 's' ) sh . cd ( 's' ) sh . exec ( `template` ) sh . cd ( 's' ) vars . builtinPlugins . forEach ( plugin => { log . info ( 's' , plugin ) sh . cd ( plugin ) sh . exec ( `template` ) sh . cd ( 's' ) } ) if ( [ 's' , 's' ] . includes ( process . platform ) ) { sh . cd ( 's' ) for ( let x of vars . builtinPlugins ) { sh . ln ( 's' , 's' + x , x ) } for ( let x of vars . bundledModules ) { sh . ln ( 's' , 's' + x , x ) } sh . cd ( 's' ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const rebuild = require ( 's' ) . default const sh = require ( 's' ) const path = require ( 's' ) const fs = require ( 's' ) const vars = require ( 's' ) const log = require ( 's' ) let target = path . resolve ( __dirname , 's' ) sh . mkdir ( 's' , target ) fs . writeFileSync ( path . join ( target , 's' ) , 's' ) sh . cd ( target ) vars . builtinPlugins . forEach ( plugin => { log . info ( 's' , plugin ) sh . cp ( 's' , path . join ( 's' , plugin ) , 's' ) sh . rm ( 's' , path . join ( plugin , 's' ) ) sh . cd ( plugin ) sh . exec ( `template` ) log . info ( 's' , 's' ) if ( fs . existsSync ( 's' ) ) { rebuild ( path . resolve ( 's' ) , vars . electronVersion , process . arch , [ ] , true ) } sh . cd ( 's' ) } ) fs . unlinkSync ( path . join ( target , 's' ) , 's' )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const sh = require ( 's' ) const vars = require ( 's' ) const log = require ( 's' ) vars . builtinPlugins . forEach ( plugin => { log . info ( 's' , plugin ) sh . cd ( plugin ) sh . exec ( 's' + vars . version ) sh . cd ( 's' ) } )	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { TerminalColorSchemeProvider , TerminalColorScheme } from 's' const schemeContents = require . context ( 's' , true , "s" ) @ Injectable ( ) export class ColorSchemes extends TerminalColorSchemeProvider { async getSchemes ( ) < TerminalColorScheme [ ] > { const schemes : TerminalColorScheme [ ] = [ ] schemeContents . keys ( ) . forEach ( schemeFile => { const lines = ( schemeContents ( schemeFile ) . default as string ) . split ( 's' ) const variables = { } lines . filter ( x => x . startsWith ( 's' ) ) . map ( x => x . split ( 's' ) . map ( v => v . trim ( ) ) ) . forEach ( ( [ _ , variableName , variableValue ] ) => { variables [ variableName ] = variableValue } ) const values = { } lines . filter ( x => x . startsWith ( 's' ) ) . map ( x => x . substring ( 0 ) ) . map ( x => x . split ( 's' ) . map ( v => v . trim ( ) ) ) . forEach ( ( [ key , value ] ) => { values [ key ] = variables [ value ] ? variables [ value ] : value } ) const colors : string [ ] = [ ] let colorIndex = 0 while ( values [ `template` ] ) { colors . push ( values [ `template` ] ) colorIndex ++ } schemes . push ( { name : schemeFile . split ( 's' ) [ 0 ] . trim ( ) , foreground : values . foreground , background : values . background , cursor : values . cursorColor , colors , } ) } ) return schemes } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { TerminalColorSchemeProvider } from 's' import { ColorSchemes } from 's' @ NgModule ( { providers : [ { provide : TerminalColorSchemeProvider , useClass : ColorSchemes , multi : true } , ] , } ) export default class PopularThemesModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) module . exports = { target : 's' , entry : 's' , context : __dirname , devtool : 's' , output : { path : path . resolve ( __dirname , 's' ) , filename : 's' , pathinfo : true , libraryTarget : 's' , devtoolModuleFilenameTemplate : 's' , } , mode : process . env . TERMINUS_DEV ? 's' : 's' , optimization : { minimize : false , } , resolve : { modules : [ 's' , 's' , 's' , 's' ] . map ( x => path . join ( __dirname , x ) ) , extensions : [ 's' , 's' ] , } , module : { rules : [ { test : "s" , use : { loader : 's' , options : { configFileName : path . resolve ( __dirname , 's' ) , typeRoots : [ path . resolve ( __dirname , 's' ) , path . resolve ( __dirname , 's' ) , ] , paths : { "s" : [ path . resolve ( __dirname , 's' ) ] , "s" : [ path . resolve ( __dirname , 's' ) ] , } , } , } , } , { test : "s" , use : "s" } , ] , } , externals : [ "s" , "s" , "s" , "s" , ] , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export abstract class ConfigProvider { defaults : any = { } platformDefaults : { [ platform ] : any } = { } }	O O O O O O O O O O O O O O O $string$ O O O O O O O O
export interface HotkeyDescription { id : string name : string } export abstract class HotkeyProvider { hotkeys : HotkeyDescription [ ] = [ ] abstract provide ( ) < HotkeyDescription [ ] > }	O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O
import { Observable , Subject } from 's' import { ViewRef } from 's' export interface BaseTabProcess { name : string } export abstract class BaseTabComponent { title : string customTitle : string hasActivity = false hostView : ViewRef color : string | null = null protected hasFocus = false protected recoveryStateChangedHint = new Subject < void > ( ) private progressClearTimeout : number private titleChange = new Subject < string > ( ) private focused = new Subject < void > ( ) private blurred = new Subject < void > ( ) private progress = new Subject < number | null > ( ) private activity = new Subject < boolean > ( ) private destroyed = new Subject < void > ( ) get focused$ ( ) : Observable < void > { return this . focused } get blurred$ ( ) : Observable < void > { return this . blurred } get titleChange$ ( ) : Observable < string > { return this . titleChange } get progress$ ( ) : Observable < number | null > { return this . progress } get activity$ ( ) : Observable < boolean > { return this . activity } get destroyed$ ( ) : Observable < void > { return this . destroyed } get recoveryStateChangedHint$ ( ) : Observable < void > { return this . recoveryStateChangedHint } constructor ( ) { this . focused$ . subscribe ( ( ) => { this . hasFocus = true } ) this . blurred$ . subscribe ( ( ) => { this . hasFocus = false } ) } setTitle ( title ) { this . title = title if ( ! this . customTitle ) { this . titleChange . next ( title ) } } setProgress ( progress : number | null ) { this . progress . next ( progress ) if ( progress ) { if ( this . progressClearTimeout ) { clearTimeout ( this . progressClearTimeout ) } this . progressClearTimeout = setTimeout ( ( ) => { this . setProgress ( null ) } , 0 ) as any } } displayActivity ( ) { this . hasActivity = true this . activity . next ( true ) } clearActivity ( ) { this . hasActivity = false this . activity . next ( false ) } async getRecoveryToken ( ) < any > { return null } async getCurrentProcess ( ) < BaseTabProcess | null > { return null } async canClose ( ) < boolean > { return true } emitFocused ( ) { this . focused . next ( ) } emitBlurred ( ) { this . blurred . next ( ) } destroy ( skipDestroyedEvent = false ) { this . focused . complete ( ) this . blurred . complete ( ) this . titleChange . complete ( ) this . progress . complete ( ) this . recoveryStateChangedHint . complete ( ) if ( ! skipDestroyedEvent ) { this . destroyed . next ( ) } this . destroyed . complete ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O $Promise$ O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { TouchBar , BrowserWindow , Menu , MenuItem , NativeImage } from 's' export interface MessageBoxResponse { response : number checkboxChecked ? : boolean } @ Injectable ( { providedIn : 's' } ) export class ElectronService { app : Electron . App ipcRenderer : Electron . IpcRenderer shell : Electron . Shell dialog : Electron . Dialog clipboard : Electron . Clipboard globalShortcut : Electron . GlobalShortcut nativeImage : typeof NativeImage screen : Electron . Screen remote : Electron . Remote autoUpdater : Electron . AutoUpdater TouchBar : typeof TouchBar BrowserWindow : typeof BrowserWindow Menu : typeof Menu MenuItem : typeof MenuItem private electron : any constructor ( ) { this . electron = require ( 's' ) this . remote = this . electron . remote this . app = this . remote . app this . screen = this . remote . screen this . dialog = this . remote . dialog this . shell = this . electron . shell this . clipboard = this . electron . clipboard this . ipcRenderer = this . electron . ipcRenderer this . globalShortcut = this . remote . globalShortcut this . nativeImage = this . remote . nativeImage this . autoUpdater = this . remote . autoUpdater this . TouchBar = this . remote . TouchBar this . BrowserWindow = this . remote . BrowserWindow this . Menu = this . remote . Menu this . MenuItem = this . remote . MenuItem } loseFocus ( ) { if ( process . platform === 's' ) { this . remote . Menu . sendActionToFirstResponder ( 's' ) } } async showMessageBox ( browserWindow : Electron . BrowserWindow , options : Electron . MessageBoxOptions ) < MessageBoxResponse > { return this . dialog . showMessageBox ( browserWindow , options ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { ElectronService } from 's' import * as winston from 's' import * as fs from 's' import * as path from 's' const initializeWinston = ( electron ) => { const logDirectory = electron . app . getPath ( 's' ) if ( ! fs . existsSync ( logDirectory ) ) { fs . mkdirSync ( logDirectory ) } return winston . createLogger ( { transports : [ new winston . transports . File ( { level : 's' , filename : path . join ( logDirectory , 's' ) , format : winston . format . simple ( ) , handleExceptions : false , maxsize : 0 , maxFiles : 0 , } ) , ] , exitOnError : false , } ) } export class Logger { constructor ( private winstonLogger , private name , ) { } debug ( ... args : any [ ] ) { this . doLog ( 's' , ... args ) } info ( ... args : any [ ] ) { this . doLog ( 's' , ... args ) } warn ( ... args : any [ ] ) { this . doLog ( 's' , ... args ) } error ( ... args : any [ ] ) { this . doLog ( 's' , ... args ) } log ( ... args : any [ ] ) { this . doLog ( 's' , ... args ) } private doLog ( level , ... args : any [ ] ) { console [ level ] ( `template` , 's' , ... args ) if ( this . winstonLogger ) { this . winstonLogger [ level ] ( ... args ) } } } @ Injectable ( { providedIn : 's' } ) export class LogService { private log : any constructor ( electron ) { this . log = initializeWinston ( electron ) } create ( name ) { return new Logger ( this . log , name ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElectronService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElectronService$ O O O O O O O O O O O $Logger$ O $string$ O O O O O O O O O O O O O O
import * as path from 's' import shellEscape from 's' import { Observable , Subject } from 's' import { Injectable , NgZone , EventEmitter } from 's' import { ElectronService } from 's' import { Logger , LogService } from 's' export enum Platform { Linux , macOS , Windows , } export interface Bounds { x : number y : number width : number height : number } @ Injectable ( { providedIn : 's' } ) export class HostAppService { platform : Platform shown = new EventEmitter < any > ( ) isFullScreen = false isPortable = ! ! process . env . PORTABLE_EXECUTABLE_FILE private preferencesMenu = new Subject < void > ( ) private secondInstance = new Subject < void > ( ) private cliOpenDirectory = new Subject < string > ( ) private cliRunCommand = new Subject < string [ ] > ( ) private cliPaste = new Subject < string > ( ) private cliOpenProfile = new Subject < string > ( ) private configChangeBroadcast = new Subject < void > ( ) private windowCloseRequest = new Subject < void > ( ) private windowMoved = new Subject < void > ( ) private displayMetricsChanged = new Subject < void > ( ) private logger : Logger private windowId : number get preferencesMenu$ ( ) : Observable < void > { return this . preferencesMenu } get secondInstance$ ( ) : Observable < void > { return this . secondInstance } get cliOpenDirectory$ ( ) : Observable < string > { return this . cliOpenDirectory } get cliRunCommand$ ( ) : Observable < string [ ] > { return this . cliRunCommand } get cliPaste$ ( ) : Observable < string > { return this . cliPaste } get cliOpenProfile$ ( ) : Observable < string > { return this . cliOpenProfile } get configChangeBroadcast$ ( ) : Observable < void > { return this . configChangeBroadcast } get windowCloseRequest$ ( ) : Observable < void > { return this . windowCloseRequest } get windowMoved$ ( ) : Observable < void > { return this . windowMoved } get displayMetricsChanged$ ( ) : Observable < void > { return this . displayMetricsChanged } private constructor ( private zone , private electron , log , ) { this . logger = log . create ( 's' ) this . platform = { 0 : Platform . Windows , darwin : Platform . macOS , linux : Platform . Linux , } [ process . platform ] this . windowId = parseInt ( location . search . substring ( 0 ) ) this . logger . info ( 's' , this . windowId ) electron . ipcRenderer . on ( 's' , ( ) => this . zone . run ( ( ) => this . preferencesMenu . next ( ) ) ) electron . ipcRenderer . on ( 's' , ( _$event , err ) => { this . logger . error ( 's' , err ) } ) electron . ipcRenderer . on ( 's' , ( ) => this . zone . run ( ( ) => { this . isFullScreen = true } ) ) electron . ipcRenderer . on ( 's' , ( ) => this . zone . run ( ( ) => { this . isFullScreen = false } ) ) electron . ipcRenderer . on ( 's' , ( ) => { this . zone . run ( ( ) => this . shown . emit ( ) ) } ) electron . ipcRenderer . on ( 's' , ( ) => { this . zone . run ( ( ) => this . windowCloseRequest . next ( ) ) } ) electron . ipcRenderer . on ( 's' , ( ) => { this . zone . run ( ( ) => this . windowMoved . next ( ) ) } ) electron . ipcRenderer . on ( 's' , ( ) => { this . zone . run ( ( ) => this . displayMetricsChanged . next ( ) ) } ) electron . ipcRenderer . on ( 's' , ( _$event , argv , cwd ) => this . zone . run ( ( ) => { this . logger . info ( 's' , argv ) const op = argv . _ [ 0 ] if ( op === 's' ) { this . cliOpenDirectory . next ( path . resolve ( cwd , argv . directory ) ) } else if ( op === 's' ) { this . cliRunCommand . next ( argv . command ) } else if ( op === 's' ) { let text = argv . text if ( argv . escape ) { text = shellEscape ( [ text ] ) } this . cliPaste . next ( text ) } else if ( op === 's' ) { this . cliOpenProfile . next ( argv . profileName ) } else if ( op === undefined ) { this . newWindow ( ) } else { this . secondInstance . next ( ) } } ) ) electron . ipcRenderer . on ( 's' , ( ) => this . zone . run ( ( ) => { this . configChangeBroadcast . next ( ) } ) ) } getWindow ( ) { return this . electron . BrowserWindow . fromId ( this . windowId ) } newWindow ( ) { this . electron . ipcRenderer . send ( 's' ) } toggleFullscreen ( ) { const window = this . getWindow ( ) window . setFullScreen ( ! this . isFullScreen ) } openDevTools ( ) { this . getWindow ( ) . webContents . openDevTools ( { mode : 's' } ) } focusWindow ( ) { this . electron . ipcRenderer . send ( 's' ) } minimize ( ) { this . electron . ipcRenderer . send ( 's' ) } maximize ( ) { this . electron . ipcRenderer . send ( 's' ) } unmaximize ( ) { this . electron . ipcRenderer . send ( 's' ) } toggleMaximize ( ) { this . electron . ipcRenderer . send ( 's' ) } setBounds ( bounds ) { this . electron . ipcRenderer . send ( 's' , bounds ) } setAlwaysOnTop ( flag ) { this . electron . ipcRenderer . send ( 's' , flag ) } setVibrancy ( enable , type ) { document . body . classList . toggle ( 's' , enable ) if ( this . platform === Platform . macOS ) { this . getWindow ( ) . setVibrancy ( enable ? 's' : null as any ) } if ( this . platform === Platform . Windows ) { this . electron . ipcRenderer . send ( 's' , enable , type ) } } setTitle ( title ) { this . electron . ipcRenderer . send ( 's' , title ) } setTouchBar ( touchBar : Electron . TouchBar ) { this . getWindow ( ) . setTouchBar ( touchBar ) } popupContextMenu ( menuDefinition : Electron . MenuItemConstructorOptions [ ] ) { this . electron . Menu . buildFromTemplate ( menuDefinition ) . popup ( { } ) } broadcastConfigChange ( ) { this . electron . ipcRenderer . send ( 's' ) } emitReady ( ) { this . electron . ipcRenderer . send ( 's' ) } bringToFront ( ) { this . electron . ipcRenderer . send ( 's' ) } closeWindow ( ) { this . electron . ipcRenderer . send ( 's' ) } relaunch ( ) { if ( this . isPortable ) { this . electron . app . relaunch ( { execPath : process . env . PORTABLE_EXECUTABLE_FILE } ) } else { this . electron . app . relaunch ( ) } this . electron . app . exit ( ) } quit ( ) { this . logger . info ( 's' ) this . electron . app . quit ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgZone$ O O $ElectronService$ O $LogService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bounds$ O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O $boolean$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Observable , Subject } from 's' import * as yaml from 's' import * as path from 's' import * as fs from 's' import { Injectable , Inject } from 's' import { ConfigProvider } from 's' import { ElectronService } from 's' import { HostAppService } from 's' const configMerge = ( a , b ) => require ( 's' ) ( a , b , { arrayMerge : ( _d , s ) => s } ) function isStructuralMember ( v ) { return v instanceof Object && ! ( v instanceof Array ) && Object . keys ( v ) . length > 0 && ! v . __nonStructural } function isNonStructuralObjectMember ( v ) { return v instanceof Object && ! ( v instanceof Array ) && v . __nonStructural } export class ConfigProxy { constructor ( real , defaults ) { for ( const key in defaults ) { if ( isStructuralMember ( defaults [ key ] ) ) { if ( ! real [ key ] ) { real [ key ] = { } } const proxy = new ConfigProxy ( real [ key ] , defaults [ key ] ) Object . defineProperty ( this , key , { enumerable : true , configurable : false , get : ( ) => proxy , } ) } else { Object . defineProperty ( this , key , { enumerable : true , configurable : false , get : ( ) => this . getValue ( key ) , set : ( value ) => { this . setValue ( key , value ) } , } ) } } this . getValue = ( key ) => { if ( real [ key ] !== undefined ) { return real [ key ] } else { if ( isNonStructuralObjectMember ( defaults [ key ] ) ) { real [ key ] = { ... defaults [ key ] } delete real [ key ] . __nonStructural return real [ key ] } else { return defaults [ key ] } } } this . setValue = ( key , value ) => { real [ key ] = value } } getValue ( _key ) { } setValue ( _key , _value ) { } } @ Injectable ( { providedIn : 's' } ) export class ConfigService { store : any restartRequested : boolean path : string private changed = new Subject < void > ( ) private _store : any private defaults : any private servicesCache : { [ id ] : Function [ ] } | null = null get changed$ ( ) : Observable < void > { return this . changed } constructor ( electron , private hostApp , @ Inject ( ConfigProvider ) configProviders : ConfigProvider [ ] , ) { this . path = path . join ( electron . app . getPath ( 's' ) , 's' ) this . defaults = configProviders . map ( provider => { let defaults = { } if ( provider . platformDefaults ) { defaults = configMerge ( defaults , provider . platformDefaults [ hostApp . platform ] || { } ) } if ( provider . defaults ) { defaults = configMerge ( defaults , provider . defaults ) } return defaults } ) . reduce ( configMerge ) this . load ( ) hostApp . configChangeBroadcast$ . subscribe ( ( ) => { this . load ( ) this . emitChange ( ) } ) } getDefaults ( ) { return this . defaults } load ( ) { if ( fs . existsSync ( this . path ) ) { this . _store = yaml . safeLoad ( fs . readFileSync ( this . path , 's' ) ) } else { this . _store = { } } this . store = new ConfigProxy ( this . _store , this . defaults ) } save ( ) { fs . writeFileSync ( this . path , yaml . safeDump ( this . _store ) , 's' ) this . emitChange ( ) this . hostApp . broadcastConfigChange ( ) } readRaw ( ) { return yaml . safeDump ( this . _store ) } writeRaw ( data ) { this . _store = yaml . safeLoad ( data ) this . save ( ) this . load ( ) this . emitChange ( ) } requestRestart ( ) { this . restartRequested = true } enabledServices < T extends object > ( services : T [ ] ) : T [ ] { if ( ! this . servicesCache ) { this . servicesCache = { } const ngModule = window [ 's' ] . ngInjectorDef for ( const imp of ngModule . imports ) { const module = imp [ 's' ] || imp if ( module . ngInjectorDef && module . ngInjectorDef . providers ) { this . servicesCache [ module [ 's' ] ] = module . ngInjectorDef . providers . map ( provider => { return provider [ 's' ] || provider } ) } } } return services . filter ( service => { for ( const pluginName in this . servicesCache ) { if ( this . servicesCache [ pluginName ] . includes ( service . constructor ) ) { return ! this . store . pluginBlacklist . includes ( pluginName ) } } return true } ) } private emitChange ( ) { this . changed . next ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O $any$ O $string$ O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElectronService$ O O $HostAppService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O
import { Injectable , Inject } from 's' import { TabRecoveryProvider , RecoveredTab } from 's' import { BaseTabComponent } from 's' import { Logger , LogService } from 's' import { ConfigService } from 's' @ Injectable ( { providedIn : 's' } ) export class TabRecoveryService { logger : Logger constructor ( @ Inject ( TabRecoveryProvider ) private tabRecoveryProviders : TabRecoveryProvider [ ] , private config , log ) { this . logger = log . create ( 's' ) } async saveTabs ( tabs : BaseTabComponent [ ] ) { window . localStorage . tabsRecovery = JSON . stringify ( await Promise . all ( tabs . map ( tab => tab . getRecoveryToken ( ) ) . filter ( token => ! ! token ) ) ) } async recoverTab ( token ) < RecoveredTab | null > { for ( const provider of this . config . enabledServices ( this . tabRecoveryProviders ) ) { try { const tab = await provider . recover ( token ) if ( tab ) { return tab } } catch ( error ) { this . logger . warn ( 's' , token , provider , error ) } } return null } async recoverTabs ( ) < RecoveredTab [ ] > { if ( window . localStorage . tabsRecovery ) { const tabs : RecoveredTab [ ] = [ ] for ( const token of JSON . parse ( window . localStorage . tabsRecovery ) ) { const tab = await this . recoverTab ( token ) if ( tab ) { tabs . push ( tab ) } } return tabs } return [ ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O $LogService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable , ComponentFactoryResolver , Injector } from 's' import { BaseTabComponent } from 's' import { TabRecoveryService } from 's' export type TabComponentType = new ( ... args : any [ ] ) => BaseTabComponent @ Injectable ( { providedIn : 's' } ) export class TabsService { constructor ( private componentFactoryResolver , private injector , private tabRecovery , ) { } create ( type , inputs ? ) { const componentFactory = this . componentFactoryResolver . resolveComponentFactory ( type ) const componentRef = componentFactory . create ( this . injector ) const tab = componentRef . instance tab . hostView = componentRef . hostView Object . assign ( tab , inputs || { } ) return tab } async duplicate ( tab ) < BaseTabComponent | null > { const token = await tab . getRecoveryToken ( ) if ( ! token ) { return null } const dup = await this . tabRecovery . recoverTab ( token ) if ( dup ) { return this . create ( dup . type , dup . options ) } return null } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFactoryResolver$ O O $Injector$ O O $TabRecoveryService$ O O O O $BaseTabComponent$ O $TabComponentType$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TabComponentType } from 's' export interface RecoveredTab { type : TabComponentType options ? : any } export abstract class TabRecoveryProvider { abstract async recover ( recoveryToken ) < RecoveredTab | null > }	O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $any$ O O O O O O O
export const metaKeyName = { darwin : 's' , 0 : 's' , linux : 's' , } [ process . platform ] export const altKeyName = { darwin : 's' , 0 : 's' , linux : 's' , } [ process . platform ] export function stringifyKeySequence ( events : KeyboardEvent [ ] ) : string [ ] { const items : string [ ] = [ ] events = events . slice ( ) while ( events . length > 0 ) { const event = events . shift ( ) ! if ( ( event as any ) . event === 's' ) { const itemKeys : string [ ] = [ ] if ( event . ctrlKey ) { itemKeys . push ( 's' ) } if ( event . metaKey ) { itemKeys . push ( metaKeyName ) } if ( event . altKey ) { itemKeys . push ( altKeyName ) } if ( event . shiftKey ) { itemKeys . push ( 's' ) } if ( [ 's' , 's' , 's' , 's' ] . includes ( event . key ) ) { continue } let key = event . code key = key . replace ( 's' , 's' ) key = key . replace ( 's' , 's' ) key = key . replace ( 's' , 's' ) key = { Comma : 's' , Period : 's' , Slash : 's' , Backslash : 's' , IntlBackslash : 's' , Backquote : 's' , Minus : 's' , Equal : 's' , Semicolon : 's' , Quote : 's' , BracketLeft : 's' , BracketRight : 's' , } [ key ] || key itemKeys . push ( key ) items . push ( itemKeys . join ( 's' ) ) } } return items }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable , Inject , NgZone , EventEmitter } from 's' import { HotkeyDescription , HotkeyProvider } from 's' import { stringifyKeySequence } from 's' import { ConfigService } from 's' import { ElectronService } from 's' export interface PartialHotkeyMatch { id : string strokes : string [ ] matchedLength : number } const KEY_TIMEOUT = 0 interface EventBufferEntry { event : KeyboardEvent time : number } @ Injectable ( { providedIn : 's' } ) export class HotkeysService { key = new EventEmitter < KeyboardEvent > ( ) matchedHotkey = new EventEmitter < string > ( ) globalHotkey = new EventEmitter < void > ( ) private currentKeystrokes : EventBufferEntry [ ] = [ ] private disabledLevel = 0 private hotkeyDescriptions : HotkeyDescription [ ] = [ ] private constructor ( private zone , private electron , private config , @ Inject ( HotkeyProvider ) private hotkeyProviders : HotkeyProvider [ ] , ) { const events = [ 's' , 's' ] events . forEach ( event => { document . addEventListener ( event , ( nativeEvent ) => { if ( document . querySelectorAll ( 's' ) . length === 0 ) { this . pushKeystroke ( event , nativeEvent ) this . processKeystrokes ( ) this . emitKeyEvent ( nativeEvent ) } } ) } ) this . config . changed$ . subscribe ( ( ) => { this . registerGlobalHotkey ( ) } ) this . registerGlobalHotkey ( ) this . getHotkeyDescriptions ( ) . then ( hotkeys => { this . hotkeyDescriptions = hotkeys } ) } pushKeystroke ( name , nativeEvent ) { ( nativeEvent as any ) . event = name this . currentKeystrokes . push ( { event : nativeEvent , time : performance . now ( ) } ) } processKeystrokes ( ) { if ( this . isEnabled ( ) ) { this . zone . run ( ( ) => { const matched = this . getCurrentFullyMatchedHotkey ( ) if ( matched ) { console . log ( 's' , matched ) this . matchedHotkey . emit ( matched ) this . clearCurrentKeystrokes ( ) } } ) } } emitKeyEvent ( nativeEvent ) { this . zone . run ( ( ) => { this . key . emit ( nativeEvent ) } ) } clearCurrentKeystrokes ( ) { this . currentKeystrokes = [ ] } getCurrentKeystrokes ( ) : string [ ] { this . currentKeystrokes = this . currentKeystrokes . filter ( x => performance . now ( ) - x . time < KEY_TIMEOUT ) return stringifyKeySequence ( this . currentKeystrokes . map ( x => x . event ) ) } getCurrentFullyMatchedHotkey ( ) : string | null { const currentStrokes = this . getCurrentKeystrokes ( ) const config = this . getHotkeysConfig ( ) for ( const id in config ) { for ( const sequence of config [ id ] ) { if ( currentStrokes . length < sequence . length ) { continue } if ( sequence . every ( ( x , index ) => x . toLowerCase ( ) === currentStrokes [ currentStrokes . length - sequence . length + index ] . toLowerCase ( ) ) ) { return id } } } return null } getCurrentPartiallyMatchedHotkeys ( ) : PartialHotkeyMatch [ ] { const currentStrokes = this . getCurrentKeystrokes ( ) const config = this . getHotkeysConfig ( ) const result : PartialHotkeyMatch [ ] = [ ] for ( const id in config ) { for ( const sequence of config [ id ] ) { for ( let matchLength = Math . min ( currentStrokes . length , sequence . length ) ; matchLength > 0 ; matchLength -- ) { if ( sequence . slice ( 0 , matchLength ) . every ( ( x , index ) => x . toLowerCase ( ) === currentStrokes [ currentStrokes . length - matchLength + index ] . toLowerCase ( ) ) ) { result . push ( { matchedLength : matchLength , id , strokes : sequence , } ) break } } } } return result } getHotkeyDescription ( id ) { return this . hotkeyDescriptions . filter ( ( x ) => x . id === id ) [ 0 ] } enable ( ) { this . disabledLevel -- } disable ( ) { this . disabledLevel ++ } isEnabled ( ) { return this . disabledLevel === 0 } async getHotkeyDescriptions ( ) < HotkeyDescription [ ] > { return ( await Promise . all ( this . config . enabledServices ( this . hotkeyProviders ) . map ( async x => x . provide ? x . provide ( ) : x . hotkeys ) ) ) . reduce ( ( a , b ) => a . concat ( b ) ) } private registerGlobalHotkey ( ) { this . electron . globalShortcut . unregisterAll ( ) let value = this . config . store . hotkeys [ 's' ] || [ ] if ( typeof value === 's' ) { value = [ value ] } value . forEach ( ( item : string | string [ ] ) => { item = typeof item === 's' ? [ item ] : item try { let electronKeySpec = item [ 0 ] electronKeySpec = electronKeySpec . replace ( 's' , 's' ) electronKeySpec = electronKeySpec . replace ( 's' , 's' ) electronKeySpec = electronKeySpec . replace ( "s" , 's' ) this . electron . globalShortcut . register ( electronKeySpec , ( ) => { this . globalHotkey . emit ( ) } ) } catch ( err ) { console . error ( 's' , err ) } } ) } private getHotkeysConfig ( ) { return this . getHotkeysConfigRecursive ( this . config . store . hotkeys ) } private getHotkeysConfigRecursive ( branch ) { const keys = { } for ( const key in branch ) { let value = branch [ key ] if ( value instanceof Object && ! ( value instanceof Array ) ) { const subkeys = this . getHotkeysConfigRecursive ( value ) for ( const subkey in subkeys ) { keys [ key + 's' + subkey ] = subkeys [ subkey ] } } else { if ( typeof value === 's' ) { value = [ value ] } if ( value ) { value = value . map ( ( item : string | string [ ] ) => typeof item === 's' ? [ item ] : item ) keys [ key ] = value } } } return keys } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgZone$ O O $ElectronService$ O O $ConfigService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HotkeyDescription$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Observable , Subject , Subscription } from 's' import { Component , Injectable , ViewChild , ViewContainerRef , EmbeddedViewRef , OnInit , OnDestroy } from 's' import { BaseTabComponent , BaseTabProcess } from 's' import { TabRecoveryProvider , RecoveredTab } from 's' import { TabsService } from 's' import { HotkeysService } from 's' import { TabRecoveryService } from 's' export type SplitOrientation = 's' | 's' export type SplitDirection = 's' | 's' | 's' | 's' export class SplitContainer { orientation : SplitOrientation = 's' children : ( BaseTabComponent | SplitContainer ) [ ] = [ ] ratios : number [ ] = [ ] x : number y : number w : number h : number getAllTabs ( ) : BaseTabComponent [ ] { let r : BaseTabComponent [ ] = [ ] for ( const child of this . children ) { if ( child instanceof SplitContainer ) { r = r . concat ( child . getAllTabs ( ) ) } else { r . push ( child ) } } return r } normalize ( ) { for ( let i = 0 ; i < this . children . length ; i ++ ) { const child = this . children [ i ] if ( child instanceof SplitContainer ) { child . normalize ( ) if ( child . children . length === 0 ) { this . children . splice ( i , 0 ) this . ratios . splice ( i , 0 ) i -- continue } else if ( child . children . length === 0 ) { this . children [ i ] = child . children [ 0 ] } else if ( child . orientation === this . orientation ) { const ratio = this . ratios [ i ] this . children . splice ( i , 0 ) this . ratios . splice ( i , 0 ) for ( let j = 0 ; j < child . children . length ; j ++ ) { this . children . splice ( i , 0 , child . children [ j ] ) this . ratios . splice ( i , 0 , child . ratios [ j ] * ratio ) i ++ } } } } let s = 0 for ( const x of this . ratios ) { s += x } this . ratios = this . ratios . map ( x => x / s ) } getOffsetRatio ( index ) { let s = 0 for ( let i = 0 ; i < index ; i ++ ) { s += this . ratios [ i ] } return s } async serialize ( ) { const children : any [ ] = [ ] for ( const child of this . children ) { if ( child instanceof SplitContainer ) { children . push ( await child . serialize ( ) ) } else { children . push ( await child . getRecoveryToken ( ) ) } } return { type : 's' , ratios : this . ratios , orientation : this . orientation , children , } } } export interface SplitSpannerInfo { container : SplitContainer index : number } @ Component ( { selector : 's' , template : `template` , styles : [ require ( 's' ) ] , } ) export class SplitTabComponent extends BaseTabComponent implements OnInit , OnDestroy { @ ViewChild ( 's' , { read : ViewContainerRef } ) viewContainer : ViewContainerRef root : SplitContainer _recoveredState : any _spanners : SplitSpannerInfo [ ] = [ ] private focusedTab : BaseTabComponent private hotkeysSubscription : Subscription private viewRefs : Map < BaseTabComponent , EmbeddedViewRef < any > > = new Map ( ) private tabAdded = new Subject < BaseTabComponent > ( ) private tabRemoved = new Subject < BaseTabComponent > ( ) private splitAdjusted = new Subject < SplitSpannerInfo > ( ) private focusChanged = new Subject < BaseTabComponent > ( ) get tabAdded$ ( ) : Observable < BaseTabComponent > { return this . tabAdded } get tabRemoved$ ( ) : Observable < BaseTabComponent > { return this . tabRemoved } get splitAdjusted$ ( ) : Observable < SplitSpannerInfo > { return this . splitAdjusted } get focusChanged$ ( ) : Observable < BaseTabComponent > { return this . focusChanged } constructor ( private hotkeys , private tabsService , private tabRecovery , ) { super ( ) this . root = new SplitContainer ( ) this . setTitle ( 's' ) this . focused$ . subscribe ( ( ) => { this . getAllTabs ( ) . forEach ( x => x . emitFocused ( ) ) if ( this . focusedTab ) { this . focus ( this . focusedTab ) } else { this . focusAnyIn ( this . root ) } } ) this . blurred$ . subscribe ( ( ) => this . getAllTabs ( ) . forEach ( x => x . emitBlurred ( ) ) ) this . hotkeysSubscription = this . hotkeys . matchedHotkey . subscribe ( hotkey => { if ( ! this . hasFocus ) { return } switch ( hotkey ) { case 's' : this . splitTab ( this . focusedTab , 's' ) break case 's' : this . splitTab ( this . focusedTab , 's' ) break case 's' : this . splitTab ( this . focusedTab , 's' ) break case 's' : this . splitTab ( this . focusedTab , 's' ) break case 's' : this . navigate ( 's' ) break case 's' : this . navigate ( 's' ) break case 's' : this . navigate ( 's' ) break case 's' : this . navigate ( 's' ) break case 's' : this . removeTab ( this . focusedTab ) break } } ) } async ngOnInit ( ) { if ( this . _recoveredState ) { await this . recoverContainer ( this . root , this . _recoveredState ) this . layout ( ) setImmediate ( ( ) => { if ( this . hasFocus ) { this . getAllTabs ( ) . forEach ( x => x . emitFocused ( ) ) this . focusAnyIn ( this . root ) } } ) } } ngOnDestroy ( ) { this . hotkeysSubscription . unsubscribe ( ) } getAllTabs ( ) { return this . root . getAllTabs ( ) } getFocusedTab ( ) { return this . focusedTab } focus ( tab ) { this . focusedTab = tab for ( const x of this . getAllTabs ( ) ) { if ( x !== tab ) { x . emitBlurred ( ) } } if ( tab ) { tab . emitFocused ( ) this . focusChanged . next ( tab ) } this . layout ( ) } focusAnyIn ( parent : BaseTabComponent | SplitContainer ) { if ( ! parent ) { return } if ( parent instanceof SplitContainer ) { this . focusAnyIn ( parent . children [ 0 ] ) } else { this . focus ( parent ) } } addTab ( tab , relative : BaseTabComponent | null , side ) { let target = ( relative ? this . getParentOf ( relative ) : null ) || this . root let insertIndex = relative ? target . children . indexOf ( relative ) : - 0 if ( target . orientation === 's' && [ 's' , 's' ] . includes ( side ) || target . orientation === 's' && [ 's' , 's' ] . includes ( side ) ) { const newContainer = new SplitContainer ( ) newContainer . orientation = target . orientation === 's' ? 's' : 's' newContainer . children = relative ? [ relative ] : [ ] newContainer . ratios = [ 0 ] target . children [ insertIndex ] = newContainer target = newContainer insertIndex = 0 } if ( insertIndex === - 0 ) { insertIndex = 0 } else { insertIndex += side === 's' || side === 's' ? 0 : 0 } for ( let i = 0 ; i < target . children . length ; i ++ ) { target . ratios [ i ] *= target . children . length / ( target . children . length + 0 ) } target . ratios . splice ( insertIndex , 0 , 0 / ( target . children . length + 0 ) ) target . children . splice ( insertIndex , 0 , tab ) this . recoveryStateChangedHint . next ( ) this . attachTabView ( tab ) setImmediate ( ( ) => { this . layout ( ) this . tabAdded . next ( tab ) this . focus ( tab ) } ) } removeTab ( tab ) { const parent = this . getParentOf ( tab ) if ( ! parent ) { return } const index = parent . children . indexOf ( tab ) parent . ratios . splice ( index , 0 ) parent . children . splice ( index , 0 ) this . detachTabView ( tab ) this . layout ( ) this . tabRemoved . next ( tab ) if ( this . root . children . length === 0 ) { this . destroy ( ) } else { this . focusAnyIn ( parent ) } } navigate ( dir ) { let rel : BaseTabComponent | SplitContainer = this . focusedTab let parent = this . getParentOf ( rel ) if ( ! parent ) { return } const orientation = [ 's' , 's' ] . includes ( dir ) ? 's' : 's' while ( parent !== this . root && parent . orientation !== orientation ) { rel = parent parent = this . getParentOf ( rel ) if ( ! parent ) { return } } if ( parent . orientation !== orientation ) { return } const index = parent . children . indexOf ( rel ) if ( [ 's' , 's' ] . includes ( dir ) ) { if ( index > 0 ) { this . focusAnyIn ( parent . children [ index - 0 ] ) } } else { if ( index < parent . children . length - 0 ) { this . focusAnyIn ( parent . children [ index + 0 ] ) } } } async splitTab ( tab , dir ) { const newTab = await this . tabsService . duplicate ( tab ) if ( newTab ) { this . addTab ( newTab , tab , dir ) } } getParentOf ( tab : BaseTabComponent | SplitContainer , root ? ) : SplitContainer | null { root = root || this . root for ( const child of root . children ) { if ( child instanceof SplitContainer ) { const r = this . getParentOf ( tab , child ) if ( r ) { return r } } if ( child === tab ) { return root } } return null } async canClose ( ) < boolean > { return ! ( await Promise . all ( this . getAllTabs ( ) . map ( x => x . canClose ( ) ) ) ) . some ( x => ! x ) } async getRecoveryToken ( ) < any > { return this . root . serialize ( ) } async getCurrentProcess ( ) < BaseTabProcess | null > { return ( await Promise . all ( this . getAllTabs ( ) . map ( x => x . getCurrentProcess ( ) ) ) ) . find ( x => ! ! x ) || null } onSpannerAdjusted ( spanner ) { this . layout ( ) this . splitAdjusted . next ( spanner ) } private attachTabView ( tab ) { const ref = this . viewContainer . insert ( tab . hostView ) as EmbeddedViewRef < any > this . viewRefs . set ( tab , ref ) ref . rootNodes [ 0 ] . addEventListener ( 's' , ( ) => this . focus ( tab ) ) tab . titleChange$ . subscribe ( t => this . setTitle ( t ) ) tab . activity$ . subscribe ( a => a ? this . displayActivity ( ) : this . clearActivity ( ) ) tab . progress$ . subscribe ( p => this . setProgress ( p ) ) if ( tab . title ) { this . setTitle ( tab . title ) } tab . destroyed$ . subscribe ( ( ) => { this . removeTab ( tab ) } ) } private detachTabView ( tab ) { const ref = this . viewRefs . get ( tab ) if ( ref ) { this . viewRefs . delete ( tab ) this . viewContainer . remove ( this . viewContainer . indexOf ( ref ) ) } } private layout ( ) { this . root . normalize ( ) this . _spanners = [ ] this . layoutInternal ( this . root , 0 , 0 , 0 , 0 ) } private layoutInternal ( root , x , y , w , h ) { const size = root . orientation === 's' ? h : w const sizes = root . ratios . map ( x => x * size ) root . x = x root . y = y root . w = w root . h = h let offset = 0 root . children . forEach ( ( child , i ) => { const childX = root . orientation === 's' ? x : x + offset const childY = root . orientation === 's' ? y + offset : y const childW = root . orientation === 's' ? w : sizes [ i ] const childH = root . orientation === 's' ? sizes [ i ] : h if ( child instanceof SplitContainer ) { this . layoutInternal ( child , childX , childY , childW , childH ) } else { const element = this . viewRefs . get ( child ) ! . rootNodes [ 0 ] element . style . position = 's' element . style . left = `template` element . style . top = `template` element . style . width = `template` element . style . height = `template` element . style . opacity = child === this . focusedTab ? 0 : 0 } offset += sizes [ i ] if ( i !== 0 ) { this . _spanners . push ( { container : root , index : i , } ) } } ) } private async recoverContainer ( root , state ) { const children : ( SplitContainer | BaseTabComponent ) [ ] = [ ] root . orientation = state . orientation root . ratios = state . ratios root . children = children for ( const childState of state . children ) { if ( childState . type === 's' ) { const child = new SplitContainer ( ) await this . recoverContainer ( child , childState ) children . push ( child ) } else { const recovered = await this . tabRecovery . recoverTab ( childState ) if ( recovered ) { const tab = this . tabsService . create ( recovered . type , recovered . options ) children . push ( tab ) this . attachTabView ( tab ) } else { state . ratios . splice ( state . children . indexOf ( childState ) , 0 ) } } } } } @ Injectable ( ) export class SplitTabRecoveryProvider extends TabRecoveryProvider { async recover ( recoveryToken ) < RecoveredTab | null > { if ( recoveryToken && recoveryToken . type === 's' ) { return { type : SplitTabComponent , options : { _recoveredState : recoveryToken } , } } return null } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HotkeysService$ O O $TabsService$ O O $TabRecoveryService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O O O O O O O O O O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O O O O O O O $SplitDirection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SplitDirection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O $SplitDirection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SplitContainer$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SplitSpannerInfo$ O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SplitContainer$ O $number$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SplitContainer$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface ToolbarButton { icon ? : string title : string touchBarNSImage ? : string touchBarTitle ? : string weight ? : number click ? : ( ) => void submenu ? : ( ) => Promise < ToolbarButton [ ] > submenuItems ? : ToolbarButton [ ] } export abstract class ToolbarButtonProvider { abstract provide ( ) : ToolbarButton [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export abstract class Theme { name : string css : string terminalBackground : string }	O O O O O O O O O O O O O O O
import { Component , Input , ElementRef , ViewChild } from 's' import { NgbActiveModal } from 's' @ Component ( { selector : 's' , template : require ( 's' ) , } ) export class RenameTabModalComponent { @ Input ( ) value : string @ ViewChild ( 's' ) input : ElementRef constructor ( private modalInstance ) { } ngOnInit ( ) { setTimeout ( ( ) => { this . input . nativeElement . focus ( ) this . input . nativeElement . select ( ) } , 0 ) } save ( ) { this . modalInstance . close ( this . value ) } close ( ) { this . modalInstance . dismiss ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgbActiveModal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Observable , Subject , AsyncSubject } from 's' import { takeUntil } from 's' import { Injectable } from 's' import { BaseTabComponent } from 's' import { SplitTabComponent } from 's' import { ConfigService } from 's' import { HostAppService } from 's' import { TabRecoveryService } from 's' import { TabsService , TabComponentType } from 's' class CompletionObserver { get done$ ( ) : Observable < void > { return this . done } get destroyed$ ( ) : Observable < void > { return this . destroyed } private done = new AsyncSubject < void > ( ) private destroyed = new AsyncSubject < void > ( ) private interval : number constructor ( private tab ) { this . interval = setInterval ( ( ) => this . tick ( ) , 0 ) as any this . tab . destroyed$ . pipe ( takeUntil ( this . destroyed$ ) ) . subscribe ( ( ) => this . stop ( ) ) } async tick ( ) { if ( ! await this . tab . getCurrentProcess ( ) ) { this . done . next ( ) this . stop ( ) } } stop ( ) { clearInterval ( this . interval ) this . destroyed . next ( ) this . destroyed . complete ( ) this . done . complete ( ) } } @ Injectable ( { providedIn : 's' } ) export class AppService { tabs : BaseTabComponent [ ] = [ ] get activeTab ( ) : BaseTabComponent { return this . _activeTab } private lastTabIndex = 0 private _activeTab : BaseTabComponent private activeTabChange = new Subject < BaseTabComponent > ( ) private tabsChanged = new Subject < void > ( ) private tabOpened = new Subject < BaseTabComponent > ( ) private tabClosed = new Subject < BaseTabComponent > ( ) private ready = new AsyncSubject < void > ( ) private completionObservers = new Map < BaseTabComponent , CompletionObserver > ( ) get activeTabChange$ ( ) : Observable < BaseTabComponent > { return this . activeTabChange } get tabOpened$ ( ) : Observable < BaseTabComponent > { return this . tabOpened } get tabsChanged$ ( ) : Observable < void > { return this . tabsChanged } get tabClosed$ ( ) : Observable < BaseTabComponent > { return this . tabClosed } get ready$ ( ) : Observable < void > { return this . ready } constructor ( private config , private hostApp , private tabRecovery , private tabsService , ) { if ( hostApp . getWindow ( ) . id === 0 ) { this . tabRecovery . recoverTabs ( ) . then ( tabs => { for ( const tab of tabs ) { this . openNewTabRaw ( tab . type , tab . options ) } this . tabsChanged$ . subscribe ( ( ) => { tabRecovery . saveTabs ( this . tabs ) } ) setInterval ( ( ) => { tabRecovery . saveTabs ( this . tabs ) } , 0 ) } ) } } addTabRaw ( tab ) { this . tabs . push ( tab ) this . selectTab ( tab ) this . tabsChanged . next ( ) this . tabOpened . next ( tab ) if ( this . hostApp . getWindow ( ) . id === 0 ) { tab . recoveryStateChangedHint$ . subscribe ( ( ) => { this . tabRecovery . saveTabs ( this . tabs ) } ) } tab . titleChange$ . subscribe ( title => { if ( tab === this . _activeTab ) { this . hostApp . setTitle ( title ) } } ) tab . destroyed$ . subscribe ( ( ) => { const newIndex = Math . max ( 0 , this . tabs . indexOf ( tab ) - 0 ) this . tabs = this . tabs . filter ( ( x ) => x !== tab ) if ( tab === this . _activeTab ) { this . selectTab ( this . tabs [ newIndex ] ) } this . tabsChanged . next ( ) this . tabClosed . next ( tab ) } ) } openNewTabRaw ( type , inputs ? ) { const tab = this . tabsService . create ( type , inputs ) this . addTabRaw ( tab ) return tab } openNewTab ( type , inputs ? ) { const splitTab = this . tabsService . create ( SplitTabComponent ) as SplitTabComponent const tab = this . tabsService . create ( type , inputs ) splitTab . addTab ( tab , null , 's' ) this . addTabRaw ( splitTab ) return tab } selectTab ( tab ) { if ( this . _activeTab === tab ) { this . _activeTab . emitFocused ( ) return } if ( this . tabs . includes ( this . _activeTab ) ) { this . lastTabIndex = this . tabs . indexOf ( this . _activeTab ) } else { this . lastTabIndex = 0 } if ( this . _activeTab ) { this . _activeTab . clearActivity ( ) this . _activeTab . emitBlurred ( ) } this . _activeTab = tab this . activeTabChange . next ( tab ) if ( this . _activeTab ) { setImmediate ( ( ) => { this . _activeTab . emitFocused ( ) } ) this . hostApp . setTitle ( this . _activeTab . title ) } } toggleLastTab ( ) { if ( ! this . lastTabIndex || this . lastTabIndex >= this . tabs . length ) { this . lastTabIndex = 0 } this . selectTab ( this . tabs [ this . lastTabIndex ] ) } nextTab ( ) { if ( this . tabs . length > 0 ) { const tabIndex = this . tabs . indexOf ( this . _activeTab ) if ( tabIndex < this . tabs . length - 0 ) { this . selectTab ( this . tabs [ tabIndex + 0 ] ) } else if ( this . config . store . appearance . cycleTabs ) { this . selectTab ( this . tabs [ 0 ] ) } } } previousTab ( ) { if ( this . tabs . length > 0 ) { const tabIndex = this . tabs . indexOf ( this . _activeTab ) if ( tabIndex > 0 ) { this . selectTab ( this . tabs [ tabIndex - 0 ] ) } else if ( this . config . store . appearance . cycleTabs ) { this . selectTab ( this . tabs [ this . tabs . length - 0 ] ) } } } emitTabsChanged ( ) { this . tabsChanged . next ( ) } async closeTab ( tab , checkCanClose ? ) < void > { if ( ! this . tabs . includes ( tab ) ) { return } if ( checkCanClose && ! await tab . canClose ( ) ) { return } tab . destroy ( ) } async duplicateTab ( tab ) { const dup = await this . tabsService . duplicate ( tab ) if ( dup ) { this . addTabRaw ( dup ) } } async closeAllTabs ( ) < boolean > { for ( const tab of this . tabs ) { if ( ! await tab . canClose ( ) ) { return false } } for ( const tab of this . tabs ) { tab . destroy ( true ) } return true } emitReady ( ) { this . ready . next ( ) this . ready . complete ( ) this . hostApp . emitReady ( ) } observeTabCompletion ( tab ) < void > { if ( ! this . completionObservers . has ( tab ) ) { const observer = new CompletionObserver ( tab ) observer . destroyed$ . subscribe ( ( ) => { this . stopObservingTabCompletion ( tab ) } ) this . completionObservers . set ( tab , observer ) } return this . completionObservers . get ( tab ) ! . done$ } stopObservingTabCompletion ( tab ) { this . completionObservers . delete ( tab ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O O $HostAppService$ O O $TabRecoveryService$ O O $TabsService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O $TabComponentType$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O $TabComponentType$ O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $BaseTabComponent$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $BaseTabComponent$ O O O O O O O O O O O O
import { Component , Input , Optional , Inject , HostBinding , HostListener , ViewChild , ElementRef } from 's' import { SortableComponent } from 's' import { NgbModal } from 's' import { TabContextMenuItemProvider } from 's' import { BaseTabComponent } from 's' import { RenameTabModalComponent } from 's' import { HotkeysService } from 's' import { ElectronService } from 's' import { AppService } from 's' import { HostAppService , Platform } from 's' export interface SortableComponentProxy { setDragHandle ( _ ) } @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) ] , } ) export class TabHeaderComponent { @ Input ( ) index : number @ Input ( ) @ HostBinding ( 's' ) active : boolean @ Input ( ) @ HostBinding ( 's' ) hasActivity : boolean @ Input ( ) tab : BaseTabComponent @ Input ( ) progress : number | null @ ViewChild ( 's' ) handle : ElementRef private constructor ( public app , private electron , private hostApp , private ngbModal , private hotkeys , @ Inject ( SortableComponent ) private parentDraggable , @ Optional ( ) @ Inject ( TabContextMenuItemProvider ) protected contextMenuProviders : TabContextMenuItemProvider [ ] , ) { this . hotkeys . matchedHotkey . subscribe ( ( hotkey ) => { if ( this . app . activeTab === this . tab ) { if ( hotkey === 's' ) { this . showRenameTabModal ( ) } } } ) this . contextMenuProviders . sort ( ( a , b ) => a . weight - b . weight ) } ngOnInit ( ) { if ( this . hostApp . platform === Platform . macOS ) { this . parentDraggable . setDragHandle ( this . handle . nativeElement ) } this . tab . progress$ . subscribe ( progress => { this . progress = progress } ) } showRenameTabModal ( ) { const modal = this . ngbModal . open ( RenameTabModalComponent ) modal . componentInstance . value = this . tab . customTitle || this . tab . title modal . result . then ( result => { this . tab . setTitle ( result ) this . tab . customTitle = result } ) . catch ( ( ) => null ) } async buildContextMenu ( ) < Electron . MenuItemConstructorOptions [ ] > { let items : Electron . MenuItemConstructorOptions [ ] = [ ] for ( const section of await Promise . all ( this . contextMenuProviders . map ( x => x . getItems ( this . tab , this ) ) ) ) { items . push ( { type : 's' } ) items = items . concat ( section ) } return items . slice ( 0 ) } @ HostListener ( 's' ) onDoubleClick ( ) { this . showRenameTabModal ( ) } @ HostListener ( 's' , [ 's' ] ) async onAuxClick ( $event ) { if ( $event . which === 0 ) { this . app . closeTab ( this . tab , true ) } if ( $event . which === 0 ) { $event . preventDefault ( ) const contextMenu = this . electron . remote . Menu . buildFromTemplate ( await this . buildContextMenu ( ) ) contextMenu . popup ( { x : $event . pageX , y : $event . pageY , } ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AppService$ O O $ElectronService$ O O $HostAppService$ O O $NgbModal$ O O $HotkeysService$ O O O O O O O $SortableComponentProxy$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BaseTabComponent } from 's' import { TabHeaderComponent } from 's' export abstract class TabContextMenuItemProvider { weight = 0 abstract async getItems ( tab , tabHeader ? ) < Electron . MenuItemConstructorOptions [ ] > }	O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $BaseTabComponent$ O O $TabHeaderComponent$ O O O O O O O O O
import { Injectable } from 's' import { ConfigService } from 's' import { ElectronService } from 's' import { HostAppService , Bounds } from 's' @ Injectable ( { providedIn : 's' } ) export class DockingService { constructor ( private electron , private config , private hostApp , ) { electron . screen . on ( 's' , ( ) => this . repositionWindow ( ) ) electron . screen . on ( 's' , ( ) => this . repositionWindow ( ) ) } dock ( ) { const dockSide = this . config . store . appearance . dock if ( dockSide === 's' ) { this . hostApp . setAlwaysOnTop ( false ) return } let display = this . electron . screen . getAllDisplays ( ) . filter ( x => x . id === this . config . store . appearance . dockScreen ) [ 0 ] if ( ! display ) { display = this . getCurrentScreen ( ) } const newBounds = { x : 0 , y : 0 , width : 0 , height : 0 } const fill = this . config . store . appearance . dockFill <= 0 ? this . config . store . appearance . dockFill : 0 const [ minWidth , minHeight ] = this . hostApp . getWindow ( ) . getMinimumSize ( ) if ( dockSide === 's' || dockSide === 's' ) { newBounds . width = Math . max ( minWidth , Math . round ( fill * display . bounds . width ) ) newBounds . height = display . bounds . height } if ( dockSide === 's' || dockSide === 's' ) { newBounds . width = display . bounds . width newBounds . height = Math . max ( minHeight , Math . round ( fill * display . bounds . height ) ) } if ( dockSide === 's' ) { newBounds . x = display . bounds . x + display . bounds . width - newBounds . width } else { newBounds . x = display . bounds . x } if ( dockSide === 's' ) { newBounds . y = display . bounds . y + display . bounds . height - newBounds . height } else { newBounds . y = display . bounds . y } this . hostApp . setAlwaysOnTop ( true ) setImmediate ( ( ) => { this . hostApp . setBounds ( newBounds ) } ) } getCurrentScreen ( ) { return this . electron . screen . getDisplayNearestPoint ( this . electron . screen . getCursorScreenPoint ( ) ) } getScreens ( ) { const primaryDisplayID = this . electron . screen . getPrimaryDisplay ( ) . id return this . electron . screen . getAllDisplays ( ) . sort ( ( a , b ) => a . bounds . x === b . bounds . x ? a . bounds . y - b . bounds . y : a . bounds . x - b . bounds . x ) . map ( ( display , index ) => { return { id : display . id , name : display . id === primaryDisplayID ? 's' : `template` , } } ) } private repositionWindow ( ) { const [ x , y ] = this . hostApp . getWindow ( ) . getPosition ( ) for ( const screen of this . electron . screen . getAllDisplays ( ) ) { const bounds = screen . bounds if ( x >= bounds . x && x <= bounds . x + bounds . width && y >= bounds . y && y <= bounds . y + bounds . height ) { return } } const screen = this . electron . screen . getPrimaryDisplay ( ) this . hostApp . getWindow ( ) . setPosition ( screen . bounds . x , screen . bounds . y ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElectronService$ O O $ConfigService$ O O $HostAppService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Bounds$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as os from 's' import { Injectable } from 's' import { ElectronService } from 's' import { ConfigService } from 's' import * as mixpanel from 's' import * as 0 from 's' @ Injectable ( { providedIn : 's' } ) export class HomeBaseService { appVersion : string mixpanel : any constructor ( private electron , private config , ) { this . appVersion = electron . app . getVersion ( ) if ( this . config . store . enableAnalytics && ! this . config . store . enableWelcomeTab ) { this . enableAnalytics ( ) } } openGitHub ( ) { this . electron . shell . openExternal ( 's' ) } reportBug ( ) { let body = `template` body += `template` const label = { darwin : 's' , windows : 's' , linux : 's' , } [ os . platform ( ) ] const plugins = ( window as any ) . installedPlugins . filter ( x => ! x . isBuiltin ) . map ( x => x . name ) body += `template` this . electron . shell . openExternal ( `template` ) } enableAnalytics ( ) { if ( ! window . localStorage . analyticsUserID ) { window . localStorage . analyticsUserID = 0 ( ) } this . mixpanel = mixpanel . init ( 's' ) if ( ! window . localStorage . installEventSent ) { this . mixpanel . track ( 's' , this . getAnalyticsProperties ( ) ) window . localStorage . installEventSent = true } this . mixpanel . track ( 's' , this . getAnalyticsProperties ( ) ) } getAnalyticsProperties ( ) { return { distinct_id : window . localStorage . analyticsUserID , platform : process . platform , os : os . release ( ) , version : this . appVersion , } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElectronService$ O O $ConfigService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' import * as fs from 's' import { exec } from 's' import { Injectable } from 's' import { ElectronService } from 's' import { HostAppService , Platform } from 's' try { var wnr = require ( 's' ) } catch ( _ ) { } @ Injectable ( { providedIn : 's' } ) export class ShellIntegrationService { private automatorWorkflows = [ 's' , 's' ] private automatorWorkflowsLocation : string private automatorWorkflowsDestination : string private registryKeys = [ { path : 's' , command : 's' , } , { path : 's' , command : 's' , } , ] constructor ( private electron , private hostApp , ) { if ( this . hostApp . platform === Platform . macOS ) { this . automatorWorkflowsLocation = path . join ( path . dirname ( path . dirname ( this . electron . app . getPath ( 's' ) ) ) , 's' , 's' , 's' , ) this . automatorWorkflowsDestination = path . join ( process . env . HOME as string , 's' , 's' ) } this . updatePaths ( ) } async isInstalled ( ) < boolean > { if ( this . hostApp . platform === Platform . macOS ) { return fs . exists ( path . join ( this . automatorWorkflowsDestination , this . automatorWorkflows [ 0 ] ) ) } else if ( this . hostApp . platform === Platform . Windows ) { return ! ! wnr . getRegistryKey ( wnr . HK . CU , this . registryKeys [ 0 ] . path ) } return true } async install ( ) { const exe = process . env . PORTABLE_EXECUTABLE_FILE || this . electron . app . getPath ( 's' ) if ( this . hostApp . platform === Platform . macOS ) { for ( const wf of this . automatorWorkflows ) { await exec ( `template` ) } } else if ( this . hostApp . platform === Platform . Windows ) { for ( const registryKey of this . registryKeys ) { wnr . createRegistryKey ( wnr . HK . CU , registryKey . path ) wnr . createRegistryKey ( wnr . HK . CU , registryKey . path + 's' ) wnr . setRegistryValue ( wnr . HK . CU , registryKey . path , 's' , wnr . REG . SZ , exe ) wnr . setRegistryValue ( wnr . HK . CU , registryKey . path + 's' , 's' , wnr . REG . SZ , exe + 's' + registryKey . command ) } } } async remove ( ) { if ( this . hostApp . platform === Platform . macOS ) { for ( const wf of this . automatorWorkflows ) { await exec ( `template` ) } } else if ( this . hostApp . platform === Platform . Windows ) { for ( const registryKey of this . registryKeys ) { wnr . deleteRegistryKey ( wnr . HK . CU , registryKey . path ) } } } private async updatePaths ( ) < void > { if ( this . hostApp . platform === Platform . Windows ) { if ( await this . isInstalled ( ) ) { await this . install ( ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElectronService$ O O $HostAppService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Inject , Injectable } from 's' import { ConfigService } from 's' import { Theme } from 's' @ Injectable ( { providedIn : 's' } ) export class ThemesService { private styleElement : HTMLElement | null = null constructor ( private config , @ Inject ( Theme ) private themes : Theme [ ] , ) { this . applyCurrentTheme ( ) config . changed$ . subscribe ( ( ) => { this . applyCurrentTheme ( ) } ) } findTheme ( name ) : Theme | null { return this . config . enabledServices ( this . themes ) . find ( x => x . name === name ) || null } findCurrentTheme ( ) { return this . findTheme ( this . config . store . appearance . theme ) || this . findTheme ( 's' ) ! } applyTheme ( theme ) { if ( ! this . styleElement ) { this . styleElement = document . createElement ( 's' ) this . styleElement . setAttribute ( 's' , 's' ) document . querySelector ( 's' ) ! . appendChild ( this . styleElement ) } this . styleElement . textContent = theme . css document . querySelector ( 's' ) ! . innerHTML = this . config . store . appearance . css } private applyCurrentTheme ( ) { this . applyTheme ( this . findCurrentTheme ( ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Theme$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $Theme$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O
export { BaseTabComponent , BaseTabProcess } from 's' export { SplitTabComponent , SplitContainer } from 's' export { TabRecoveryProvider , RecoveredTab } from 's' export { ToolbarButtonProvider , ToolbarButton } from 's' export { ConfigProvider } from 's' export { HotkeyProvider , HotkeyDescription } from 's' export { Theme } from 's' export { TabContextMenuItemProvider } from 's' export { AppService } from 's' export { ConfigService } from 's' export { DockingService } from 's' export { ElectronService } from 's' export { Logger , LogService } from 's' export { HomeBaseService } from 's' export { HotkeysService } from 's' export { HostAppService , Platform } from 's' export { ShellIntegrationService } from 's' export { ThemesService } from 's' export { TabsService } from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import axios from 's' import * as fs from 's' import os from 's' import { spawn } from 's' import { Injectable } from 's' import { Logger , LogService } from 's' import { ElectronService } from 's' import { ConfigService } from 's' const UPDATES_URL = 's' @ Injectable ( { providedIn : 's' } ) export class UpdaterService { private logger : Logger private downloaded : Promise < boolean > private electronUpdaterAvailable = true private updateURL : string private autoUpdater constructor ( log , private electron , config , ) { this . logger = log . create ( 's' ) this . autoUpdater = electron . remote . require ( 's' ) . autoUpdater this . autoUpdater . autoInstallOnAppQuit = ! ! config . store . enableAutomaticUpdates this . autoUpdater . on ( 's' , ( ) => { this . logger . info ( 's' ) } ) this . autoUpdater . once ( 's' , ( ) => { this . logger . info ( 's' ) } ) this . downloaded = new Promise < boolean > ( resolve => { this . autoUpdater . once ( 's' , ( ) => resolve ( true ) ) } ) this . logger . debug ( 's' ) if ( this . electronUpdaterAvailable && ! process . env . TERMINUS_DEV ) { try { this . autoUpdater . checkForUpdates ( ) } catch ( e ) { this . electronUpdaterAvailable = false this . logger . info ( 's' , e ) } } } async check ( ) < boolean > { if ( ! this . electronUpdaterAvailable ) { this . logger . debug ( 's' ) const response = await axios . get ( UPDATES_URL ) const data = response . data const version = data . tag_name . substring ( 0 ) if ( this . electron . app . getVersion ( ) !== version ) { this . logger . info ( 's' ) this . updateURL = data . html_url return true } this . logger . info ( 's' ) return false } return this . downloaded } async update ( ) { if ( ! this . electronUpdaterAvailable ) { this . electron . shell . openExternal ( this . updateURL ) } else { if ( process . platform === 's' ) { let downloadpath = await this . autoUpdater . downloadUpdate ( ) fs . exists ( downloadpath [ 0 ] , ( exists ) => { if ( exists ) { fs . copyFile ( downloadpath [ 0 ] , os . tmpdir ( ) + 's' , ( err ) => { if ( ! err ) { spawn ( os . tmpdir ( ) + 's' , [ 's' ] , { detached : true , stdio : 's' } ) } } ) } } ) } else { await this . downloaded this . autoUpdater . quitAndInstall ( false , true ) } } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogService$ O O $ElectronService$ O $ConfigService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable , Inject , NgZone } from 's' import { TouchBarSegmentedControl , SegmentedControlSegment } from 's' import { AppService } from 's' import { ConfigService } from 's' import { ElectronService } from 's' import { HostAppService , Platform } from 's' import { ToolbarButton , ToolbarButtonProvider } from 's' @ Injectable ( { providedIn : 's' } ) export class TouchbarService { private tabsSegmentedControl : TouchBarSegmentedControl private buttonsSegmentedControl : TouchBarSegmentedControl private tabSegments : SegmentedControlSegment [ ] = [ ] private nsImageCache : { [ id ] : Electron . NativeImage } = { } constructor ( private app , private hostApp , @ Inject ( ToolbarButtonProvider ) private toolbarButtonProviders : ToolbarButtonProvider [ ] , private config , private electron , private zone , ) { if ( this . hostApp . platform !== Platform . macOS ) { return } app . tabsChanged$ . subscribe ( ( ) => this . updateTabs ( ) ) app . activeTabChange$ . subscribe ( ( ) => this . updateTabs ( ) ) const activityIconPath = `template` const activityIcon = this . electron . nativeImage . createFromPath ( activityIconPath ) app . tabOpened$ . subscribe ( tab => { tab . titleChange$ . subscribe ( title => { const segment = this . tabSegments [ app . tabs . indexOf ( tab ) ] if ( segment ) { segment . label = this . shortenTitle ( title ) this . tabsSegmentedControl . segments = this . tabSegments } } ) tab . activity$ . subscribe ( hasActivity => { const showIcon = this . app . activeTab !== tab && hasActivity const segment = this . tabSegments [ app . tabs . indexOf ( tab ) ] if ( segment ) { segment . icon = showIcon ? activityIcon : undefined } } ) } ) } updateTabs ( ) { this . tabSegments = this . app . tabs . map ( tab => ( { label : this . shortenTitle ( tab . title ) , } ) ) this . tabsSegmentedControl . segments = this . tabSegments this . tabsSegmentedControl . selectedIndex = this . app . tabs . indexOf ( this . app . activeTab ) } update ( ) { if ( this . hostApp . platform !== Platform . macOS ) { return } let buttons : ToolbarButton [ ] = [ ] this . config . enabledServices ( this . toolbarButtonProviders ) . forEach ( provider => { buttons = buttons . concat ( provider . provide ( ) ) } ) buttons = buttons . filter ( x => ! ! x . touchBarNSImage ) buttons . sort ( ( a , b ) => ( a . weight || 0 ) - ( b . weight || 0 ) ) this . tabSegments = this . app . tabs . map ( tab => ( { label : this . shortenTitle ( tab . title ) , } ) ) this . tabsSegmentedControl = new this . electron . TouchBar . TouchBarSegmentedControl ( { segments : this . tabSegments , selectedIndex : this . app . tabs . indexOf ( this . app . activeTab ) , change : ( selectedIndex ) => this . zone . run ( ( ) => { this . app . selectTab ( this . app . tabs [ selectedIndex ] ) } ) , } ) this . buttonsSegmentedControl = new this . electron . TouchBar . TouchBarSegmentedControl ( { segments : buttons . map ( button => this . getButton ( button ) ) , mode : 's' , change : ( selectedIndex ) => this . zone . run ( ( ) => { if ( buttons [ selectedIndex ] . click ) { buttons [ selectedIndex ] . click ! ( ) } } ) , } ) const touchBar = new this . electron . TouchBar ( { items : [ this . tabsSegmentedControl , new this . electron . TouchBar . TouchBarSpacer ( { size : 's' } ) , new this . electron . TouchBar . TouchBarSpacer ( { size : 's' } ) , this . buttonsSegmentedControl , ] , } ) this . hostApp . setTouchBar ( touchBar ) } private getButton ( button ) : Electron . SegmentedControlSegment { return { label : button . touchBarNSImage ? undefined : this . shortenTitle ( button . touchBarTitle || button . title ) , icon : button . touchBarNSImage ? this . getCachedNSImage ( button . touchBarNSImage ) : undefined , } } private getCachedNSImage ( name ) { if ( ! this . nsImageCache [ name ] ) { this . nsImageCache [ name ] = this . electron . nativeImage . createFromNamedImage ( name , [ 0 , 0 , 0 ] ) } return this . nsImageCache [ name ] } private shortenTitle ( title ) { if ( title . length > 0 ) { title = title . substring ( 0 , 0 ) + 's' } return title } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $AppService$ O O $HostAppService$ O O O O O O O O O O O O O O $ConfigService$ O O $ElectronService$ O O $NgZone$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ToolbarButton$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' import { NgbActiveModal } from 's' @ Component ( { template : require ( 's' ) , } ) export class SafeModeModalComponent { @ Input ( ) error : Error constructor ( public modalInstance , ) { this . error = window [ 's' ] } close ( ) { this . modalInstance . dismiss ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgbActiveModal$ O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Inject , Input , HostListener , HostBinding } from 's' import { trigger , style , animate , transition , state } from 's' import { DomSanitizer } from 's' import { NgbModal } from 's' import { ElectronService } from 's' import { HostAppService , Platform } from 's' import { HotkeysService } from 's' import { Logger , LogService } from 's' import { ConfigService } from 's' import { DockingService } from 's' import { ThemesService } from 's' import { UpdaterService } from 's' import { TouchbarService } from 's' import { BaseTabComponent } from 's' import { SafeModeModalComponent } from 's' import { AppService , ToolbarButton , ToolbarButtonProvider } from 's' @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) ] , animations : [ trigger ( 's' , [ state ( 's' , style ( { 's' : 's' , width : 's' , } ) ) , transition ( 's' , [ style ( { 's' : 's' , width : 's' , } ) , animate ( 's' , style ( { 's' : 's' , width : 's' , } ) ) , ] ) , transition ( 's' , [ style ( { 's' : 's' , width : 's' , } ) , animate ( 's' , style ( { 's' : 's' , width : 's' , } ) ) , ] ) , ] ) , ] , } ) export class AppRootComponent { Platform = Platform @ Input ( ) ready = false @ Input ( ) leftToolbarButtons : ToolbarButton [ ] @ Input ( ) rightToolbarButtons : ToolbarButton [ ] @ HostBinding ( 's' ) platformClassWindows = process . platform === 's' @ HostBinding ( 's' ) platformClassMacOS = process . platform === 's' @ HostBinding ( 's' ) platformClassLinux = process . platform === 's' @ HostBinding ( 's' ) noTabs = true tabsDragging = false unsortedTabs : BaseTabComponent [ ] = [ ] updateIcon : string updatesAvailable = false private logger : Logger private constructor ( private docking , private electron , private hotkeys , private updater , private touchbar , public hostApp , public config , public app , private domSanitizer , @ Inject ( ToolbarButtonProvider ) private toolbarButtonProviders : ToolbarButtonProvider [ ] , log , ngbModal , _themes , ) { this . logger = log . create ( 's' ) this . logger . info ( 's' , electron . app . getVersion ( ) ) this . leftToolbarButtons = this . getToolbarButtons ( false ) this . rightToolbarButtons = this . getToolbarButtons ( true ) this . updateIcon = require ( 's' ) this . hotkeys . matchedHotkey . subscribe ( ( hotkey ) => { if ( hotkey . startsWith ( 's' ) ) { const index = parseInt ( hotkey . split ( 's' ) [ 0 ] ) if ( index <= this . app . tabs . length ) { this . app . selectTab ( this . app . tabs [ index - 0 ] ) } } if ( this . app . activeTab ) { if ( hotkey === 's' ) { this . app . closeTab ( this . app . activeTab , true ) } if ( hotkey === 's' ) { this . app . toggleLastTab ( ) } if ( hotkey === 's' ) { this . app . nextTab ( ) } if ( hotkey === 's' ) { this . app . previousTab ( ) } } if ( hotkey === 's' ) { this . hostApp . toggleFullscreen ( ) } } ) this . docking . dock ( ) this . hostApp . shown . subscribe ( ( ) => { this . docking . dock ( ) } ) this . hostApp . secondInstance$ . subscribe ( ( ) => { this . presentWindow ( ) } ) this . hotkeys . globalHotkey . subscribe ( ( ) => { this . onGlobalHotkey ( ) } ) this . hostApp . windowCloseRequest$ . subscribe ( async ( ) => { await this . app . closeAllTabs ( ) && this . hostApp . closeWindow ( ) } ) if ( window [ 's' ] ) { ngbModal . open ( SafeModeModalComponent ) } this . updater . check ( ) . then ( available => { this . updatesAvailable = available } ) this . touchbar . update ( ) config . changed$ . subscribe ( ( ) => this . updateVibrancy ( ) ) this . updateVibrancy ( ) let lastProgress : number | null = null this . app . tabOpened$ . subscribe ( tab => { this . unsortedTabs . push ( tab ) tab . progress$ . subscribe ( progress => { if ( lastProgress === progress ) { return } if ( progress !== null ) { this . hostApp . getWindow ( ) . setProgressBar ( progress / 0 , { mode : 's' } ) } else { this . hostApp . getWindow ( ) . setProgressBar ( - 0 , { mode : 's' } ) } lastProgress = progress } ) this . noTabs = false } ) this . app . tabClosed$ . subscribe ( tab => { this . unsortedTabs = this . unsortedTabs . filter ( x => x !== tab ) this . noTabs = app . tabs . length === 0 } ) } onGlobalHotkey ( ) { if ( this . hostApp . getWindow ( ) . isFocused ( ) ) { this . hideWindow ( ) } else { this . presentWindow ( ) } } presentWindow ( ) { if ( ! this . hostApp . getWindow ( ) . isVisible ( ) ) { this . hostApp . getWindow ( ) . show ( ) this . hostApp . getWindow ( ) . focus ( ) } else { if ( this . config . store . appearance . dock === 's' ) { setTimeout ( ( ) => { this . hostApp . getWindow ( ) . focus ( ) } ) } else { this . hostApp . getWindow ( ) . hide ( ) } } } hideWindow ( ) { this . electron . loseFocus ( ) this . hostApp . getWindow ( ) . blur ( ) if ( this . hostApp . platform !== Platform . macOS ) { this . hostApp . getWindow ( ) . hide ( ) } } async ngOnInit ( ) { this . ready = true this . app . emitReady ( ) } @ HostListener ( 's' ) onDragOver ( ) { return false } @ HostListener ( 's' ) onDrop ( ) { return false } async updateApp ( ) { if ( ( await this . electron . showMessageBox ( this . hostApp . getWindow ( ) , { type : 's' , message : 's' , buttons : [ 's' , 's' ] , defaultId : 0 , } ) ) . response === 0 ) { this . updater . update ( ) } } onTabDragStart ( ) { this . tabsDragging = true } onTabDragEnd ( ) { setTimeout ( ( ) => { this . tabsDragging = false this . app . emitTabsChanged ( ) } ) } async generateButtonSubmenu ( button ) { if ( button . submenu ) { button . submenuItems = await button . submenu ( ) } } sanitizeIcon ( icon ) { return this . domSanitizer . bypassSecurityTrustHtml ( icon || 's' ) } private getToolbarButtons ( aboveZero ) : ToolbarButton [ ] { let buttons : ToolbarButton [ ] = [ ] this . config . enabledServices ( this . toolbarButtonProviders ) . forEach ( provider => { buttons = buttons . concat ( provider . provide ( ) ) } ) return buttons . filter ( button => ( button . weight || 0 ) > 0 === aboveZero ) . sort ( ( a , b ) => ( a . weight || 0 ) - ( b . weight || 0 ) ) } private updateVibrancy ( ) { this . hostApp . setVibrancy ( this . config . store . appearance . vibrancy , this . config . store . appearance . vibrancyType ) this . hostApp . getWindow ( ) . setOpacity ( this . config . store . appearance . opacity ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $DockingService$ O O $ElectronService$ O O $HotkeysService$ O O $UpdaterService$ O O $TouchbarService$ O O $HostAppService$ O O $ConfigService$ O O $AppService$ O O $DomSanitizer$ O O O O O O O O O O O O O $LogService$ O $NgbModal$ O $ThemesService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ToolbarButton$ O O O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ToolbarButton$ O $ToolbarButton$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgZone , Component , Input , HostBinding , HostListener } from 's' import { ControlValueAccessor , NG_VALUE_ACCESSOR } from 's' @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) ] , providers : [ { provide : NG_VALUE_ACCESSOR , useExisting : CheckboxComponent , multi : true } , ] , } ) export class CheckboxComponent implements ControlValueAccessor { @ HostBinding ( 's' ) @ Input ( ) model : boolean @ Input ( ) disabled : boolean @ Input ( ) text : string private changed = new Array < ( val ) => void > ( ) @ HostListener ( 's' ) click ( ) { NgZone . assertInAngularZone ( ) if ( this . disabled ) { return } this . model = ! this . model for ( const fx of this . changed ) { fx ( this . model ) } } writeValue ( obj ) { this . model = obj } registerOnChange ( fn ) { this . changed . push ( fn ) } registerOnTouched ( fn ) { this . changed . push ( fn ) } setDisabledState ( isDisabled ) { this . disabled = isDisabled } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O $void$ O $any$ O O O O O O O O O O O $void$ O $any$ O O O O O O O O O O O O O $boolean$ O O O O O O O O O
import { Component , Input , HostBinding , ElementRef , Output , EventEmitter } from 's' import { SplitContainer } from 's' @ Component ( { selector : 's' , template : 's' , styles : [ require ( 's' ) ] , } ) export class SplitTabSpannerComponent { @ Input ( ) container : SplitContainer @ Input ( ) index : number @ Output ( ) change = new EventEmitter < void > ( ) @ HostBinding ( 's' ) isActive = false @ HostBinding ( 's' ) isHorizontal = false @ HostBinding ( 's' ) isVertical = true @ HostBinding ( 's' ) cssLeft : string @ HostBinding ( 's' ) cssTop : string @ HostBinding ( 's' ) cssWidth : string @ HostBinding ( 's' ) cssHeight : string private marginOffset = - 0 constructor ( private element ) { } ngAfterViewInit ( ) { this . element . nativeElement . addEventListener ( 's' , ( e ) => { this . isActive = true const start = this . isVertical ? e . pageY : e . pageX let current = start const oldPosition = this . isVertical ? this . element . nativeElement . offsetTop : this . element . nativeElement . offsetLeft const dragHandler = ( e ) => { current = this . isVertical ? e . pageY : e . pageX const newPosition = oldPosition + ( current - start ) if ( this . isVertical ) { this . element . nativeElement . style . top = `template` } else { this . element . nativeElement . style . left = `template` } } const offHandler = ( ) => { this . isActive = false document . removeEventListener ( 's' , offHandler ) this . element . nativeElement . parentElement . removeEventListener ( 's' , dragHandler ) let diff = ( current - start ) / ( this . isVertical ? this . element . nativeElement . parentElement . clientHeight : this . element . nativeElement . parentElement . clientWidth ) diff = Math . max ( diff , - this . container . ratios [ this . index - 0 ] + 0 ) diff = Math . min ( diff , this . container . ratios [ this . index ] - 0 ) this . container . ratios [ this . index - 0 ] += diff this . container . ratios [ this . index ] -= diff this . change . emit ( ) } document . addEventListener ( 's' , offHandler ) this . element . nativeElement . parentElement . addEventListener ( 's' , dragHandler ) } ) } ngOnChanges ( ) { this . isHorizontal = this . container . orientation === 's' this . isVertical = this . container . orientation === 's' if ( this . isVertical ) { this . setDimensions ( this . container . x , this . container . y + this . container . h * this . container . getOffsetRatio ( this . index ) , this . container . w , 0 ) } else { this . setDimensions ( this . container . x + this . container . w * this . container . getOffsetRatio ( this . index ) , this . container . y , 0 , this . container . h ) } } private setDimensions ( x , y , w , h ) { this . cssLeft = `template` this . cssTop = `template` this . cssWidth = w ? `template` : 's' this . cssHeight = h ? `template` : 's' } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElementRef$ O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O O O O O O O O O O O O O O O O O O O O O O O O $MouseEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Inject } from 's' import { DomSanitizer } from 's' import { ConfigService } from 's' import { HomeBaseService } from 's' import { ToolbarButton , ToolbarButtonProvider } from 's' @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) ] , } ) export class StartPageComponent { version : string constructor ( private config , private domSanitizer , public homeBase , @ Inject ( ToolbarButtonProvider ) private toolbarButtonProviders : ToolbarButtonProvider [ ] , ) { } getButtons ( ) : ToolbarButton [ ] { return this . config . enabledServices ( this . toolbarButtonProviders ) . map ( provider => provider . provide ( ) ) . reduce ( ( a , b ) => a . concat ( b ) ) . filter ( x => ! ! x . click ) . sort ( ( a , b ) => ( a . weight || 0 ) - ( b . weight || 0 ) ) } sanitizeIcon ( icon ) { return this . domSanitizer . bypassSecurityTrustHtml ( icon || 's' ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O O $DomSanitizer$ O O $HomeBaseService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ToolbarButton$ O $ToolbarButton$ O O O O O O O O O O O O O O O O O O O $any$ O $string$ O O O O O O O O O O O O O O O
import { Component , Input , ViewChild , HostBinding , ViewContainerRef , OnChanges } from 's' import { BaseTabComponent } from 's' @ Component ( { selector : 's' , template : `template` , styles : [ require ( 's' ) , require ( 's' ) , ] , } ) export class TabBodyComponent implements OnChanges { @ Input ( ) @ HostBinding ( 's' ) active : boolean @ Input ( ) tab : BaseTabComponent @ ViewChild ( 's' , { read : ViewContainerRef } ) placeholder : ViewContainerRef ngOnChanges ( changes ) { if ( changes . tab ) { if ( this . placeholder ) { this . placeholder . detach ( ) } setImmediate ( ( ) => { this . placeholder . insert ( this . tab . hostView ) } ) } } ngOnDestroy ( ) { this . placeholder . detach ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) ] , } ) export class TitleBarComponent { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' import { NG_VALUE_ACCESSOR } from 's' import { CheckboxComponent } from 's' @ Component ( { selector : 's' , template : `template` , styles : [ require ( 's' ) ] , providers : [ { provide : NG_VALUE_ACCESSOR , useExisting : ToggleComponent , multi : true } , ] , } ) export class ToggleComponent extends CheckboxComponent { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' import { BaseTabComponent } from 's' import { ConfigService } from 's' import { AppService } from 's' @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) ] , } ) export class WelcomeTabComponent extends BaseTabComponent { constructor ( private app , public config , ) { super ( ) this . setTitle ( 's' ) } closeAndDisable ( ) { this . config . store . enableWelcomeTab = false this . config . save ( ) this . app . closeTab ( this ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AppService$ O O $ConfigService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' import { HostAppService } from 's' import { AppService } from 's' @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) ] , } ) export class WindowControlsComponent { constructor ( public hostApp , public app ) { } async closeWindow ( ) { if ( await this . app . closeAllTabs ( ) ) { this . hostApp . closeWindow ( ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O O $AppService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ConfigProvider } from 's' import { Platform } from 's' export class CoreConfigProvider extends ConfigProvider { platformDefaults = { [ Platform . macOS ] : require ( 's' ) , [ Platform . Windows ] : require ( 's' ) , [ Platform . Linux ] : require ( 's' ) , } defaults = require ( 's' ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Directive , AfterViewInit , ElementRef } from 's' @ Directive ( { selector : 's' , } ) export class AutofocusDirective implements AfterViewInit { constructor ( private el ) { } ngAfterViewInit ( ) { this . el . nativeElement . blur ( ) setTimeout ( ( ) => { this . el . nativeElement . focus ( ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElementRef$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { HotkeyDescription , HotkeyProvider } from 's' @ Injectable ( ) export class AppHotkeyProvider extends HotkeyProvider { hotkeys : HotkeyDescription [ ] = [ { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , ] async provide ( ) < HotkeyDescription [ ] > { return this . hotkeys } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O
import { Injectable } from 's' import { Theme } from 's' @ Injectable ( ) export class StandardTheme extends Theme { name = 's' css = require ( 's' ) terminalBackground = 's' } @ Injectable ( ) export class StandardCompactTheme extends Theme { name = 's' css = require ( 's' ) terminalBackground = 's' } @ Injectable ( ) export class PaperTheme extends Theme { name = 's' css = require ( 's' ) terminalBackground = 's' }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable , NgZone } from 's' import { AppService } from 's' import { BaseTabComponent } from 's' import { TabHeaderComponent } from 's' import { TabContextMenuItemProvider } from 's' @ Injectable ( ) export class CloseContextMenu extends TabContextMenuItemProvider { weight = - 0 constructor ( private app , private zone , ) { super ( ) } async getItems ( tab ) < Electron . MenuItemConstructorOptions [ ] > { return [ { label : 's' , click : ( ) => this . zone . run ( ( ) => { this . app . closeTab ( tab , true ) } ) , } , { label : 's' , click : ( ) => this . zone . run ( ( ) => { for ( const t of this . app . tabs . filter ( x => x !== tab ) ) { this . app . closeTab ( t , true ) } } ) , } , { label : 's' , click : ( ) => this . zone . run ( ( ) => { for ( const t of this . app . tabs . slice ( this . app . tabs . indexOf ( tab ) + 0 ) ) { this . app . closeTab ( t , true ) } } ) , } , { label : 's' , click : ( ) => this . zone . run ( ( ) => { for ( const t of this . app . tabs . slice ( 0 , this . app . tabs . indexOf ( tab ) ) ) { this . app . closeTab ( t , true ) } } ) , } , ] } } const COLORS = [ { name : 's' , value : null } , { name : 's' , value : 's' } , { name : 's' , value : 's' } , { name : 's' , value : 's' } , { name : 's' , value : 's' } , { name : 's' , value : 's' } , { name : 's' , value : 's' } , ] @ Injectable ( ) export class CommonOptionsContextMenu extends TabContextMenuItemProvider { weight = - 0 constructor ( private zone , private app , ) { super ( ) } async getItems ( tab , tabHeader ? ) < Electron . MenuItemConstructorOptions [ ] > { return [ { label : 's' , click : ( ) => this . zone . run ( ( ) => tabHeader && tabHeader . showRenameTabModal ( ) ) , } , { label : 's' , click : ( ) => this . zone . run ( ( ) => this . app . duplicateTab ( tab ) ) , } , { label : 's' , sublabel : COLORS . find ( x => x . value === tab . color ) ! . name , submenu : COLORS . map ( color => ( { label : color . name , type : 's' , checked : tab . color === color . value , click : ( ) => this . zone . run ( ( ) => { tab . color = color . value } ) , } ) ) as Electron . MenuItemConstructorOptions [ ] , } , ] } } @ Injectable ( ) export class TaskCompletionContextMenu extends TabContextMenuItemProvider { constructor ( private app , private zone , ) { super ( ) } async getItems ( tab ) < Electron . MenuItemConstructorOptions [ ] > { const process = await tab . getCurrentProcess ( ) if ( process ) { return [ { id : 's' , enabled : false , label : 's' + process . name , } , { label : 's' , type : 's' , checked : ( tab as any ) . __completionNotificationEnabled , click : ( ) => this . zone . run ( ( ) => { ( tab as any ) . __completionNotificationEnabled = ! ( tab as any ) . __completionNotificationEnabled if ( ( tab as any ) . __completionNotificationEnabled ) { this . app . observeTabCompletion ( tab ) . subscribe ( ( ) => { new Notification ( 's' , { body : process . name , } ) . addEventListener ( 's' , ( ) => { this . app . selectTab ( tab ) } ) ; ( tab as any ) . __completionNotificationEnabled = false } ) } else { this . app . stopObservingTabCompletion ( tab ) } } ) , } , ] } return [ ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AppService$ O O $NgZone$ O O O O O O O O $Promise$ O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgZone$ O O $AppService$ O O O O O O O O $Promise$ O $BaseTabComponent$ O O $TabHeaderComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AppService$ O O $NgZone$ O O O O O O O O $Promise$ O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule , ModuleWithProviders } from 's' import { BrowserModule } from 's' import { BrowserAnimationsModule } from 's' import { FormsModule } from 's' import { NgbModule } from 's' import { PerfectScrollbarModule , PERFECT_SCROLLBAR_CONFIG } from 's' import { DndModule } from 's' import { AppRootComponent } from 's' import { CheckboxComponent } from 's' import { TabBodyComponent } from 's' import { SafeModeModalComponent } from 's' import { StartPageComponent } from 's' import { TabHeaderComponent } from 's' import { TitleBarComponent } from 's' import { ToggleComponent } from 's' import { WindowControlsComponent } from 's' import { RenameTabModalComponent } from 's' import { SplitTabComponent , SplitTabRecoveryProvider } from 's' import { SplitTabSpannerComponent } from 's' import { WelcomeTabComponent } from 's' import { AutofocusDirective } from 's' import { HotkeyProvider } from 's' import { ConfigProvider } from 's' import { Theme } from 's' import { TabContextMenuItemProvider } from 's' import { TabRecoveryProvider } from 's' import { AppService } from 's' import { ConfigService } from 's' import { StandardTheme , StandardCompactTheme , PaperTheme } from 's' import { CoreConfigProvider } from 's' import { AppHotkeyProvider } from 's' import { TaskCompletionContextMenu , CommonOptionsContextMenu , CloseContextMenu } from 's' import 's' import 's' import { fromEvent } from 's' import { merge } from 's' require ( 's' ) . fromEvent = fromEvent require ( 's' ) . merge = merge const PROVIDERS = [ { provide : HotkeyProvider , useClass : AppHotkeyProvider , multi : true } , { provide : Theme , useClass : StandardTheme , multi : true } , { provide : Theme , useClass : StandardCompactTheme , multi : true } , { provide : Theme , useClass : PaperTheme , multi : true } , { provide : ConfigProvider , useClass : CoreConfigProvider , multi : true } , { provide : TabContextMenuItemProvider , useClass : CommonOptionsContextMenu , multi : true } , { provide : TabContextMenuItemProvider , useClass : CloseContextMenu , multi : true } , { provide : TabContextMenuItemProvider , useClass : TaskCompletionContextMenu , multi : true } , { provide : TabRecoveryProvider , useClass : SplitTabRecoveryProvider , multi : true } , { provide : PERFECT_SCROLLBAR_CONFIG , useValue : { suppressScrollX : true } } , ] @ NgModule ( { imports : [ BrowserModule , BrowserAnimationsModule , FormsModule , NgbModule . forRoot ( ) , PerfectScrollbarModule , DndModule . forRoot ( ) , ] , declarations : [ AppRootComponent as any , CheckboxComponent , StartPageComponent , TabBodyComponent , TabHeaderComponent , TitleBarComponent , ToggleComponent , WindowControlsComponent , RenameTabModalComponent , SafeModeModalComponent , AutofocusDirective , SplitTabComponent , SplitTabSpannerComponent , WelcomeTabComponent , ] , entryComponents : [ RenameTabModalComponent , SafeModeModalComponent , SplitTabComponent , WelcomeTabComponent , ] , exports : [ CheckboxComponent , ToggleComponent , AutofocusDirective , ] , } ) export default class AppModule { constructor ( app , config ) { app . ready$ . subscribe ( ( ) => { if ( config . store . enableWelcomeTab ) { app . openNewTabRaw ( WelcomeTabComponent ) } } ) } static forRoot ( ) { return { ngModule : AppModule , providers : PROVIDERS , } } } export { AppRootComponent as bootstrap } export * from 's' export { ToolbarButton as IToolbarButton } from 's' export { HotkeyDescription as IHotkeyDescription } from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AppService$ O $ConfigService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ModuleWithProviders$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) module . exports = { target : 's' , entry : 's' , context : __dirname , devtool : 's' , output : { path : path . resolve ( __dirname , 's' ) , filename : 's' , pathinfo : true , libraryTarget : 's' , devtoolModuleFilenameTemplate : 's' , } , mode : process . env . TERMINUS_DEV ? 's' : 's' , optimization : { minimize : false , } , resolve : { modules : [ 's' , 's' , 's' , 's' ] . map ( x => path . join ( __dirname , x ) ) , extensions : [ 's' , 's' ] , } , module : { rules : [ { test : "s" , use : { loader : 's' , options : { configFileName : path . resolve ( __dirname , 's' ) , typeRoots : [ path . resolve ( __dirname , 's' ) , path . resolve ( __dirname , 's' ) , ] , paths : { "s" : [ path . resolve ( __dirname , 's' ) ] , "s" : [ path . resolve ( __dirname , 's' ) ] , } , } , } , } , { test : "s" , use : [ 's' , 's' ] } , { test : "s" , use : [ 's' , 's' , 's' ] } , { test : "s" , use : [ 's' , 's' ] , include : "s" } , { test : "s" , use : [ 's' , 's' ] , exclude : "s" } , { test : "s" , use : [ 's' , 's' ] } , { test : "s" , use : [ 's' ] } , ] , } , externals : [ 's' , 's' , 's' , 's' , 's' , "s" , "s" , "s" , ] , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import axios from 's' import { Observable , from } from 's' import { map } from 's' import { Injectable } from 's' import { Logger , LogService } from 's' const NAME_PREFIX = 's' const KEYWORD = 's' const OFFICIAL_NPM_ACCOUNT = 's' export interface PluginInfo { name : string description : string packageName : string isBuiltin : boolean isOfficial : boolean version : string homepage ? : string author : string path ? : string } @ Injectable ( { providedIn : 's' } ) export class PluginManagerService { logger : Logger builtinPluginsPath : string = ( window as any ) . builtinPluginsPath userPluginsPath : string = ( window as any ) . userPluginsPath installedPlugins : PluginInfo [ ] = ( window as any ) . installedPlugins private npmReady : Promise < void > private npm : any constructor ( log , ) { this . logger = log . create ( 's' ) } async getNPM ( ) { if ( ! this . npm ) { if ( ! this . npmReady ) { this . npmReady = new Promise ( resolve => { const npm = ( global as any ) . require ( 's' ) npm . load ( { prefix : this . userPluginsPath , } , err => { if ( err ) { this . logger . error ( err ) } this . npm = npm resolve ( ) } ) } ) } await this . npmReady } return this . npm } listAvailable ( query ? ) < PluginInfo [ ] > { return from ( axios . get ( `template` , { headers : { 's' : 's' , } , } ) ) . pipe ( map ( response => response . data . objects . map ( item => ( { name : item . package . name . substring ( NAME_PREFIX . length ) , packageName : item . package . name , description : item . package . description , version : item . package . version , homepage : item . package . links . homepage , author : ( item . package . author || { } ) . name , isOfficial : item . package . publisher . username === OFFICIAL_NPM_ACCOUNT , } ) ) ) , map ( plugins => plugins . filter ( x => x . packageName . startsWith ( NAME_PREFIX ) ) ) , ) } async installPlugin ( plugin ) { ( await this . getNPM ( ) ) . commands . install ( [ `template` ] , err => { if ( err ) { this . logger . error ( err ) } this . installedPlugins = this . installedPlugins . filter ( x => x . packageName !== plugin . packageName ) this . installedPlugins . push ( plugin ) } ) } async uninstallPlugin ( plugin ) { ( await this . getNPM ( ) ) . commands . remove ( [ plugin . packageName ] , err => { if ( err ) { this . logger . error ( err ) } this . installedPlugins = this . installedPlugins . filter ( x => x . packageName !== plugin . packageName ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BehaviorSubject , Observable } from 's' import { debounceTime , distinctUntilChanged , first , tap , flatMap , map } from 's' import * as semver from 's' import { Component , Input } from 's' import { ConfigService , ElectronService } from 's' import { PluginInfo , PluginManagerService } from 's' enum BusyState { Installing , Uninstalling } @ Component ( { template : require ( 's' ) , styles : [ require ( 's' ) ] , } ) export class PluginsSettingsTabComponent { BusyState = BusyState @ Input ( ) availablePlugins$ : Observable < PluginInfo [ ] > @ Input ( ) availablePluginsQuery$ = new BehaviorSubject < string > ( 's' ) @ Input ( ) availablePluginsReady = false @ Input ( ) knownUpgrades : { [ id ] : PluginInfo | null } = { } @ Input ( ) busy : { [ id ] : BusyState } = { } @ Input ( ) erroredPlugin : string @ Input ( ) errorMessage : string constructor ( private electron , private config , public pluginManager ) { } ngOnInit ( ) { this . availablePlugins$ = this . availablePluginsQuery$ . asObservable ( ) . pipe ( debounceTime ( 0 ) , distinctUntilChanged ( ) , flatMap ( query => { this . availablePluginsReady = false return this . pluginManager . listAvailable ( query ) . pipe ( tap ( ( ) => { this . availablePluginsReady = true } ) ) } ) ) this . availablePlugins$ . pipe ( first ( ) , map ( ( plugins : PluginInfo [ ] ) => { plugins . sort ( ( a , b ) => a . name > b . name ? 0 : - 0 ) return plugins } ) ) . subscribe ( available => { for ( const plugin of this . pluginManager . installedPlugins ) { this . knownUpgrades [ plugin . name ] = available . find ( x => x . name === plugin . name && semver . gt ( x . version , plugin . version ) ) || null } } ) } openPluginsFolder ( ) { this . electron . shell . openItem ( this . pluginManager . userPluginsPath ) } searchAvailable ( query ) { this . availablePluginsQuery$ . next ( query ) } isAlreadyInstalled ( plugin ) { return this . pluginManager . installedPlugins . some ( x => x . name === plugin . name ) } async installPlugin ( plugin ) < void > { this . busy [ plugin . name ] = BusyState . Installing try { await this . pluginManager . installPlugin ( plugin ) delete this . busy [ plugin . name ] this . config . requestRestart ( ) } catch ( err ) { this . erroredPlugin = plugin . name this . errorMessage = err delete this . busy [ plugin . name ] throw err } } async uninstallPlugin ( plugin ) < void > { this . busy [ plugin . name ] = BusyState . Uninstalling try { await this . pluginManager . uninstallPlugin ( plugin ) delete this . busy [ plugin . name ] this . config . requestRestart ( ) } catch ( err ) { this . erroredPlugin = plugin . name this . errorMessage = err delete this . busy [ plugin . name ] throw err } } async upgradePlugin ( plugin ) < void > { return this . installPlugin ( this . knownUpgrades [ plugin . name ] ! ) } showPluginInfo ( plugin ) { this . electron . shell . openExternal ( 's' + plugin . packageName ) } enablePlugin ( plugin ) { this . config . store . pluginBlacklist = this . config . store . pluginBlacklist . filter ( x => x !== plugin . name ) this . config . save ( ) this . config . requestRestart ( ) } disablePlugin ( plugin ) { this . config . store . pluginBlacklist = [ ... this . config . store . pluginBlacklist , plugin . name ] this . config . save ( ) this . config . requestRestart ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O $ElectronService$ O O $ConfigService$ O O $PluginManagerService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O $boolean$ O $PluginInfo$ O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $PluginInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $PluginInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $PluginInfo$ O O O O O O O O O O O O O O O O O O O O O O O $PluginInfo$ O O O O O O O O O O O O O O O O O O O $PluginInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PluginInfo$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { SettingsTabProvider } from 's' import { PluginsSettingsTabComponent } from 's' @ Injectable ( ) export class PluginsSettingsTabProvider extends SettingsTabProvider { id = 's' title = 's' getComponentType ( ) { return PluginsSettingsTabComponent } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O
import { NgModule } from 's' import { BrowserModule } from 's' import { FormsModule } from 's' import { NgbModule } from 's' import { SettingsTabProvider } from 's' import { PluginsSettingsTabComponent } from 's' import { PluginManagerService } from 's' import { PluginsSettingsTabProvider } from 's' @ NgModule ( { imports : [ BrowserModule , FormsModule , NgbModule , ] , providers : [ { provide : SettingsTabProvider , useClass : PluginsSettingsTabProvider , multi : true } , ] , entryComponents : [ PluginsSettingsTabComponent , ] , declarations : [ PluginsSettingsTabComponent , ] , } ) export default class PluginManagerModule { } export { PluginManagerService }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) module . exports = { target : 's' , entry : 's' , context : __dirname , devtool : 's' , output : { path : path . resolve ( __dirname , 's' ) , filename : 's' , pathinfo : true , libraryTarget : 's' , devtoolModuleFilenameTemplate : 's' , } , mode : process . env . TERMINUS_DEV ? 's' : 's' , optimization : { minimize : false , } , resolve : { modules : [ 's' , 's' , 's' , 's' ] . map ( x => path . join ( __dirname , x ) ) , extensions : [ 's' , 's' ] , } , module : { rules : [ { test : "s" , use : { loader : 's' , query : { configFileName : path . resolve ( __dirname , 's' ) , typeRoots : [ path . resolve ( __dirname , 's' ) , path . resolve ( __dirname , 's' ) , ] , paths : { "s" : [ path . resolve ( __dirname , 's' ) ] , "s" : [ path . resolve ( __dirname , 's' ) ] , } , } , } , } , { test : "s" , use : [ 's' , 's' ] } , { test : "s" , use : [ 's' , 's' , 's' ] } , ] , } , externals : [ 's' , 's' , 's' , 's' , "s" , "s" , "s" , "s" , ] , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export abstract class SettingsTabProvider { id : string icon : string title : string getComponentType ( ) { return null } }	O O O O O O O O O O O O O O $any$ O O O O O O O
import * as yaml from 's' import * as os from 's' import { Subscription } from 's' import { Component , Inject , Input , HostBinding , NgZone } from 's' import { ElectronService , DockingService , ConfigService , HotkeyDescription , HotkeysService , BaseTabComponent , Theme , HostAppService , Platform , HomeBaseService , ShellIntegrationService , } from 's' import { SettingsTabProvider } from 's' @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) , require ( 's' ) , ] , } ) export class SettingsTabComponent extends BaseTabComponent { @ Input ( ) activeTab : string hotkeyFilter = 's' hotkeyDescriptions : HotkeyDescription [ ] screens : any [ ] Platform = Platform configDefaults : any configFile : string isShellIntegrationInstalled = false isFluentVibrancySupported = false @ HostBinding ( 's' ) padWindowControls = false private configSubscription : Subscription constructor ( public config , private electron , public docking , public hostApp , public homeBase , public shellIntegration , public zone , hotkeys , @ Inject ( SettingsTabProvider ) public settingsProviders : SettingsTabProvider [ ] , @ Inject ( Theme ) public themes : Theme [ ] , ) { super ( ) this . setTitle ( 's' ) this . screens = this . docking . getScreens ( ) this . settingsProviders = config . enabledServices ( this . settingsProviders ) this . themes = config . enabledServices ( this . themes ) this . configDefaults = yaml . safeDump ( config . getDefaults ( ) ) const onConfigChange = ( ) => { this . configFile = config . readRaw ( ) this . padWindowControls = hostApp . platform === Platform . macOS && config . store . appearance . tabsLocation === 's' } this . configSubscription = config . changed$ . subscribe ( onConfigChange ) onConfigChange ( ) const onScreenChange = ( ) => { this . zone . run ( ( ) => this . screens = this . docking . getScreens ( ) ) } electron . screen . on ( 's' , onScreenChange ) electron . screen . on ( 's' , onScreenChange ) electron . screen . on ( 's' , onScreenChange ) hotkeys . getHotkeyDescriptions ( ) . then ( descriptions => { this . hotkeyDescriptions = descriptions } ) this . isFluentVibrancySupported = hostApp . platform === Platform . Windows && parseFloat ( os . release ( ) ) >= 0 && parseInt ( os . release ( ) . split ( 's' ) [ 0 ] ) >= 0 } async ngOnInit ( ) { this . isShellIntegrationInstalled = await this . shellIntegration . isInstalled ( ) } async toggleShellIntegration ( ) { if ( ! this . isShellIntegrationInstalled ) { await this . shellIntegration . install ( ) } else { await this . shellIntegration . remove ( ) } this . isShellIntegrationInstalled = await this . shellIntegration . isInstalled ( ) } async getRecoveryToken ( ) < any > { return null } ngOnDestroy ( ) { this . configSubscription . unsubscribe ( ) this . config . save ( ) } restartApp ( ) { this . hostApp . relaunch ( ) } saveConfigFile ( ) { if ( this . isConfigFileValid ( ) ) { this . config . writeRaw ( this . configFile ) } } showConfigFile ( ) { this . electron . shell . showItemInFolder ( this . config . path ) } isConfigFileValid ( ) { try { yaml . safeLoad ( this . configFile ) return true } catch ( _ ) { return false } } getHotkey ( id ) { let ptr = this . config . store . hotkeys for ( const token of id . split ( "s" ) ) { ptr = ptr [ token ] } return ptr } setHotkey ( id , value ) { let ptr = this . config . store let prop = 's' for ( const token of id . split ( "s" ) ) { ptr = ptr [ prop ] prop = token } ptr [ prop ] = value } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O O $ElectronService$ O O $DockingService$ O O $HostAppService$ O O $HomeBaseService$ O O $ShellIntegrationService$ O O $NgZone$ O $HotkeysService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { ToolbarButtonProvider , ToolbarButton , AppService , HostAppService , HotkeysService } from 's' import { SettingsTabComponent } from 's' @ Injectable ( ) export class ButtonProvider extends ToolbarButtonProvider { constructor ( hostApp , hotkeys , private app , ) { super ( ) hostApp . preferencesMenu$ . subscribe ( ( ) => this . open ( ) ) hotkeys . matchedHotkey . subscribe ( async ( hotkey ) => { if ( hotkey === 's' ) { this . open ( ) } } ) } provide ( ) : ToolbarButton [ ] { return [ { icon : require ( 's' ) , title : 's' , touchBarNSImage : 's' , weight : 0 , click : ( ) => this . open ( ) , } ] } open ( ) { const settingsTab = this . app . tabs . find ( tab => tab instanceof SettingsTabComponent ) if ( settingsTab ) { this . app . selectTab ( settingsTab ) } else { this . app . openNewTabRaw ( SettingsTabComponent ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O $HotkeysService$ O O $AppService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' import { trigger , transition , style , animate } from 's' import { NgbActiveModal } from 's' import { Subscription } from 's' import { HotkeysService } from 's' const INPUT_TIMEOUT = 0 @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) ] , animations : [ trigger ( 's' , [ transition ( 's' , [ style ( { transform : 's' , opacity : 's' , } ) , animate ( 's' , style ( { transform : 's' , opacity : 's' , } ) ) , ] ) , transition ( 's' , [ style ( { transform : 's' , opacity : 's' , } ) , animate ( 's' , style ( { transform : 's' , opacity : 's' , } ) ) , ] ) , ] ) , ] , } ) export class HotkeyInputModalComponent { @ Input ( ) value : string [ ] = [ ] @ Input ( ) timeoutProgress = 0 private keySubscription : Subscription private lastKeyEvent : number | null = null private keyTimeoutInterval : number | null = null constructor ( private modalInstance , public hotkeys , ) { this . hotkeys . clearCurrentKeystrokes ( ) this . keySubscription = hotkeys . key . subscribe ( ( event ) => { this . lastKeyEvent = performance . now ( ) this . value = this . hotkeys . getCurrentKeystrokes ( ) event . preventDefault ( ) event . stopPropagation ( ) } ) } splitKeys ( keys ) : string [ ] { return keys . split ( 's' ) . map ( ( x ) => x . trim ( ) ) } ngOnInit ( ) { this . keyTimeoutInterval = window . setInterval ( ( ) => { if ( ! this . lastKeyEvent ) { return } this . timeoutProgress = Math . min ( 0 , ( performance . now ( ) - this . lastKeyEvent ) * 0 / INPUT_TIMEOUT ) if ( this . timeoutProgress === 0 ) { this . modalInstance . close ( this . value ) } } , 0 ) this . hotkeys . disable ( ) } ngOnDestroy ( ) { this . keySubscription . unsubscribe ( ) this . hotkeys . clearCurrentKeystrokes ( ) this . hotkeys . enable ( ) clearInterval ( this . keyTimeoutInterval ! ) } close ( ) { this . modalInstance . dismiss ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgbActiveModal$ O O $HotkeysService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , Output , EventEmitter , ChangeDetectionStrategy } from 's' import { NgbModal } from 's' import { HotkeyInputModalComponent } from 's' @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) ] , changeDetection : ChangeDetectionStrategy . OnPush , } ) export class MultiHotkeyInputComponent { @ Input ( ) model : string [ ] [ ] @ Output ( ) modelChange = new EventEmitter ( ) constructor ( private ngbModal , ) { } ngOnInit ( ) { if ( ! this . model ) { this . model = [ ] } if ( typeof this . model === 's' ) { this . model = [ this . model ] } this . model = this . model . map ( item => typeof item === 's' ? [ item ] : item ) } editItem ( item ) { this . ngbModal . open ( HotkeyInputModalComponent ) . result . then ( ( value : string [ ] ) => { this . model [ this . model . findIndex ( x => x === item ) ] = value this . model = this . model . slice ( ) this . modelChange . emit ( this . model ) } ) } addItem ( ) { this . ngbModal . open ( HotkeyInputModalComponent ) . result . then ( ( value : string [ ] ) => { this . model = this . model . concat ( [ value ] ) this . modelChange . emit ( this . model ) } ) } removeItem ( item ) { this . model = this . model . filter ( x => x !== item ) this . modelChange . emit ( this . model ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgbModal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , ViewContainerRef , ViewChild , ComponentFactoryResolver , ComponentRef } from 's' import { SettingsTabProvider } from 's' @ Component ( { selector : 's' , template : 's' , } ) export class SettingsTabBodyComponent { @ Input ( ) provider : SettingsTabProvider @ ViewChild ( 's' , { read : ViewContainerRef } ) placeholder : ViewContainerRef component : ComponentRef < Component > constructor ( private componentFactoryResolver ) { } ngAfterViewInit ( ) { setImmediate ( ( ) => { this . component = this . placeholder . createComponent ( this . componentFactoryResolver . resolveComponentFactory ( this . provider . getComponentType ( ) ) ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ComponentFactoryResolver$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ConfigProvider , Platform } from 's' export class SettingsConfigProvider extends ConfigProvider { defaults = { } platformDefaults = { [ Platform . macOS ] : { hotkeys : { settings : [ 's' ] , } , } , [ Platform . Windows ] : { hotkeys : { settings : [ 's' ] , } , } , [ Platform . Linux ] : { hotkeys : { settings : [ 's' ] , } , } , } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { HotkeyDescription , HotkeyProvider } from 's' @ Injectable ( ) export class SettingsHotkeyProvider extends HotkeyProvider { hotkeys : HotkeyDescription [ ] = [ { id : 's' , name : 's' , } , ] async provide ( ) < HotkeyDescription [ ] > { return this . hotkeys } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O
import { Injectable } from 's' import { TabRecoveryProvider , RecoveredTab } from 's' import { SettingsTabComponent } from 's' @ Injectable ( ) export class RecoveryProvider extends TabRecoveryProvider { async recover ( recoveryToken ) < RecoveredTab | null > { if ( recoveryToken && recoveryToken . type === 's' ) { return { type : SettingsTabComponent } } return null } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { BrowserModule } from 's' import { FormsModule } from 's' import { NgbModule } from 's' import TerminusCorePlugin , { ToolbarButtonProvider , TabRecoveryProvider , HotkeyProvider , ConfigProvider } from 's' import { HotkeyInputModalComponent } from 's' import { MultiHotkeyInputComponent } from 's' import { SettingsTabComponent } from 's' import { SettingsTabBodyComponent } from 's' import { ButtonProvider } from 's' import { RecoveryProvider } from 's' import { SettingsHotkeyProvider } from 's' import { SettingsConfigProvider } from 's' @ NgModule ( { imports : [ BrowserModule , FormsModule , NgbModule , TerminusCorePlugin , ] , providers : [ { provide : ToolbarButtonProvider , useClass : ButtonProvider , multi : true } , { provide : TabRecoveryProvider , useClass : RecoveryProvider , multi : true } , { provide : ConfigProvider , useClass : SettingsConfigProvider , multi : true } , { provide : HotkeyProvider , useClass : SettingsHotkeyProvider , multi : true } , ] , entryComponents : [ HotkeyInputModalComponent , SettingsTabComponent , ] , declarations : [ HotkeyInputModalComponent , MultiHotkeyInputComponent , SettingsTabComponent , SettingsTabBodyComponent , ] , } ) export default class SettingsModule { } export * from 's' export { SettingsTabComponent }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) module . exports = { target : 's' , entry : 's' , context : __dirname , devtool : 's' , output : { path : path . resolve ( __dirname , 's' ) , filename : 's' , pathinfo : true , libraryTarget : 's' , devtoolModuleFilenameTemplate : 's' , } , mode : process . env . TERMINUS_DEV ? 's' : 's' , optimization : { minimize : false , } , resolve : { modules : [ 's' , 's' , 's' , 's' ] . map ( x => path . join ( __dirname , x ) ) , extensions : [ 's' , 's' ] , } , module : { rules : [ { test : "s" , use : { loader : 's' , options : { configFileName : path . resolve ( __dirname , 's' ) , typeRoots : [ path . resolve ( __dirname , 's' ) , path . resolve ( __dirname , 's' ) , ] , paths : { "s" : [ path . resolve ( __dirname , 's' ) ] , "s" : [ path . resolve ( __dirname , 's' ) ] , } , } , } , } , { test : "s" , use : [ 's' , 's' ] } , { test : "s" , use : [ 's' , 's' , 's' ] } , { test : "s" , use : [ 's' , 's' , 's' ] } , { test : "s" , use : [ 's' ] } , ] , } , externals : [ 's' , 's' , 's' , "s" , "s" , "s" , "s" , ] , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BaseSession } from 's' export interface LoginScript { expect : string send : string isRegex ? : boolean optional ? : boolean } export enum SSHAlgorithmType { HMAC = 's' , KEX = 's' , CIPHER = 's' , HOSTKEY = 's' } export interface SSHConnection { name : string host : string port : number user : string password ? : string privateKey ? : string group ? : string scripts ? : LoginScript [ ] keepaliveInterval ? : number keepaliveCountMax ? : number readyTimeout ? : number algorithms ? : { [ t ] : string [ ] } } export class SSHSession extends BaseSession { scripts ? : LoginScript [ ] shell : any constructor ( public connection ) { super ( ) this . scripts = connection . scripts || [ ] } start ( ) { this . open = true this . shell . on ( 's' , data => { const dataString = data . toString ( ) this . emitOutput ( dataString ) if ( this . scripts ) { let found = false for ( const script of this . scripts ) { let match = false let cmd = 's' if ( script . isRegex ) { const re = new RegExp ( script . expect , 's' ) if ( dataString . match ( re ) ) { cmd = dataString . replace ( re , script . send ) match = true found = true } } else { if ( dataString . includes ( script . expect ) ) { cmd = script . send match = true found = true } } if ( match ) { console . log ( 's' + cmd + 's' ) this . shell . write ( cmd + 's' ) this . scripts = this . scripts . filter ( x => x !== script ) } else { if ( script . optional ) { console . log ( 's' + script . expect ) found = true this . scripts = this . scripts . filter ( x => x !== script ) } else { break } } } if ( found ) { this . executeUnconditionalScripts ( ) } } } ) this . shell . on ( 's' , ( ) => { if ( this . open ) { this . destroy ( ) } } ) this . executeUnconditionalScripts ( ) } resize ( columns , rows ) { if ( this . shell ) { this . shell . setWindow ( rows , columns ) } } write ( data ) { if ( this . shell ) { this . shell . write ( data ) } } kill ( signal ? ) { if ( this . shell ) { this . shell . signal ( signal || 's' ) } } async getChildProcesses ( ) < any [ ] > { return [ ] } async gracefullyKillProcess ( ) < void > { this . kill ( 's' ) } async getWorkingDirectory ( ) < string | null > { return null } private executeUnconditionalScripts ( ) { if ( this . scripts ) { for ( const script of this . scripts ) { if ( ! script . expect ) { console . log ( 's' , script . send ) this . shell . write ( script . send + 's' ) this . scripts = this . scripts . filter ( x => x !== script ) } else { break } } } } } export interface SSHConnectionGroup { name : string connections : SSHConnection [ ] }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O $SSHConnection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , ViewChild , ElementRef } from 's' import { NgbActiveModal } from 's' @ Component ( { template : require ( 's' ) , } ) export class PromptModalComponent { @ Input ( ) value : string @ Input ( ) password : boolean @ Input ( ) remember : boolean @ Input ( ) showRememberCheckbox : boolean @ ViewChild ( 's' ) input : ElementRef constructor ( private modalInstance , ) { } ngOnInit ( ) { setTimeout ( ( ) => { this . input . nativeElement . focus ( ) } ) } ok ( ) { this . modalInstance . close ( { value : this . value , remember : this . remember , } ) } cancel ( ) { this . modalInstance . close ( null ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgbActiveModal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' import { first } from 's' import { BaseTerminalTabComponent } from 's' import { SSHService } from 's' import { SSHConnection , SSHSession } from 's' @ Component ( { template : `template` , styles : [ require ( 's' ) , ... BaseTerminalTabComponent . styles ] , animations : BaseTerminalTabComponent . animations , } ) export class SSHTabComponent extends BaseTerminalTabComponent { connection : SSHConnection ssh : SSHService session : SSHSession ngOnInit ( ) { this . logger = this . log . create ( 's' ) this . ssh = this . injector . get ( SSHService ) this . frontendReady$ . pipe ( first ( ) ) . subscribe ( ( ) => { this . initializeSession ( ) } ) super . ngOnInit ( ) setImmediate ( ( ) => { this . setTitle ( this . connection . name ) } ) } async initializeSession ( ) { if ( ! this . connection ) { this . logger . error ( 's' ) return } this . session = new SSHSession ( this . connection ) this . attachSessionHandlers ( ) this . write ( `template` ) const interval = setInterval ( ( ) => this . write ( 's' ) , 0 ) try { await this . ssh . connectSession ( this . session , ( message ) => { this . write ( 's' + message ) } ) } catch ( e ) { this . write ( 's' ) this . write ( e . message ) return } finally { clearInterval ( interval ) this . write ( 's' ) } this . session . resize ( this . size . columns , this . size . rows ) this . session . start ( ) } async getRecoveryToken ( ) < any > { return { type : 's' , connection : this . connection , } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { SSHConnection } from 's' import * as keytar from 's' @ Injectable ( { providedIn : 's' } ) export class PasswordStorageService { async savePassword ( connection , password ) < void > { return keytar . setPassword ( `template` , connection . user , password ) } async deletePassword ( connection ) < void > { await keytar . deletePassword ( `template` , connection . user ) } async loadPassword ( connection ) < string | null > { return keytar . getPassword ( `template` , connection . user ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $SSHConnection$ O $string$ O O O O O O O O O O O O O O O O O O O O $Promise$ O $SSHConnection$ O O O O O O O O O O O O O O O O O O $Promise$ O $SSHConnection$ O O O O O O O O O O O O O O O O O O O O
import { Injectable , NgZone } from 's' import { NgbModal } from 's' import { Client } from 's' import * as fs from 's' import * as path from 's' import { ToastrService } from 's' import { AppService , HostAppService , Platform , Logger , LogService } from 's' import { SSHConnection , SSHSession } from 's' import { PromptModalComponent } from 's' import { SSHTabComponent } from 's' import { PasswordStorageService } from 's' import { 0 } from 's' try { var windowsProcessTreeNative = require ( 's' ) } catch { } @ Injectable ( { providedIn : 's' } ) export class SSHService { private logger : Logger private constructor ( log , private app , private zone , private ngbModal , private hostApp , private passwordStorage , private toastr , ) { this . logger = log . create ( 's' ) } async openTab ( connection ) < SSHTabComponent > { return this . zone . run ( ( ) => this . app . openNewTab ( SSHTabComponent , { connection } ) as SSHTabComponent ) } async connectSession ( session , logCallback ? : ( s ) => void ) < void > { let privateKey : string | null = null let privateKeyPassphrase : string | null = null let privateKeyPath = session . connection . privateKey if ( ! logCallback ) { logCallback = ( ) => null } const log = ( s ) => { logCallback ! ( s ) this . logger . info ( s ) } if ( ! privateKeyPath ) { const userKeyPath = path . join ( process . env . HOME as string , 's' , 's' ) if ( await fs . exists ( userKeyPath ) ) { log ( `template` ) privateKeyPath = userKeyPath } } if ( privateKeyPath ) { try { privateKey = ( await fs . readFile ( privateKeyPath ) ) . toString ( ) } catch ( error ) { log ( 's' ) this . toastr . error ( 's' ) } if ( privateKey ) { log ( `template` ) let encrypted = privateKey . includes ( 's' ) if ( privateKeyPath . toLowerCase ( ) . endsWith ( 's' ) ) { encrypted = encrypted || privateKey . includes ( 's' ) && ! privateKey . includes ( 's' ) } if ( encrypted ) { const modal = this . ngbModal . open ( PromptModalComponent ) log ( 's' ) modal . componentInstance . prompt = 's' modal . componentInstance . password = true try { const result = await modal . result if ( result ) { privateKeyPassphrase = result . value } } catch ( e ) { } } } } const ssh = new Client ( ) let connected = false let savedPassword : string | null = null await new Promise ( async ( resolve , reject ) => { ssh . on ( 's' , ( ) => { connected = true if ( savedPassword ) { this . passwordStorage . savePassword ( session . connection , savedPassword ) } this . zone . run ( resolve ) } ) ssh . on ( 's' , error => { if ( error . message === 's' ) { this . passwordStorage . deletePassword ( session . connection ) } this . zone . run ( ( ) => { if ( connected ) { this . toastr . error ( error . toString ( ) ) } else { reject ( error ) } } ) } ) ssh . on ( 's' , ( name , instructions , instructionsLang , prompts , finish ) => this . zone . run ( async ( ) => { log ( `template` ) this . logger . info ( 's' , name , instructions , instructionsLang ) const results : string [ ] = [ ] for ( const prompt of prompts ) { const modal = this . ngbModal . open ( PromptModalComponent ) modal . componentInstance . prompt = prompt . prompt modal . componentInstance . password = ! prompt . echo const result = await modal . result results . push ( result ? result . value : 's' ) } finish ( results ) } ) ) ssh . on ( 's' , greeting => { log ( 's' + greeting ) } ) ssh . on ( 's' , banner => { log ( 's' + banner ) } ) let agent : string | null = null if ( this . hostApp . platform === Platform . Windows ) { const pageantRunning = new Promise < boolean > ( resolve => { windowsProcessTreeNative . getProcessList ( list => { resolve ( list . some ( x => x . name === 's' ) ) } , 0 ) } ) if ( await pageantRunning ) { agent = 's' } } else { agent = process . env . SSH_AUTH_SOCK as string } try { ssh . connect ( { host : session . connection . host , port : session . connection . port || 0 , username : session . connection . user , password : session . connection . privateKey ? undefined : 's' , privateKey : privateKey || undefined , passphrase : privateKeyPassphrase || undefined , tryKeyboard : true , agent : agent || undefined , agentForward : ! ! agent , keepaliveInterval : session . connection . keepaliveInterval , keepaliveCountMax : session . connection . keepaliveCountMax , readyTimeout : session . connection . readyTimeout , hostVerifier => { log ( 's' + digest ) return true } , hostHash : 's' as any , algorithms : session . connection . algorithms , } ) } catch ( e ) { this . toastr . error ( e . message ) reject ( e ) } let keychainPasswordUsed = false ; ( ssh as any ) . config . password = ( ) => this . zone . run ( async ( ) => { if ( session . connection . password ) { log ( 's' ) return session . connection . password } if ( ! keychainPasswordUsed ) { const password = await this . passwordStorage . loadPassword ( session . connection ) if ( password ) { log ( 's' ) keychainPasswordUsed = true return password } } const modal = this . ngbModal . open ( PromptModalComponent ) modal . componentInstance . prompt = `template` modal . componentInstance . password = true modal . componentInstance . showRememberCheckbox = true try { const result = await modal . result if ( result ) { if ( result . remember ) { savedPassword = result . value } return result . value } return 's' } catch ( _ ) { return 's' } } ) } ) try { const shell = await new Promise < any > ( ( resolve , reject ) => { ssh . shell ( { term : 's' } , ( err , shell ) => { if ( err ) { reject ( err ) } else { resolve ( shell ) } } ) } ) session . shell = shell shell . on ( 's' , greeting => { log ( `template` ) } ) shell . on ( 's' , banner => { log ( `template` ) } ) } catch ( error ) { this . toastr . error ( error . message ) throw error } } } const _authPassword = 0 . prototype . authPassword 0 . prototype . authPassword = async function ( username , passwordFn ) { _authPassword . bind ( this ) ( username , await passwordFn ( ) ) } as any	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LogService$ O O $AppService$ O O $NgZone$ O O $NgbModal$ O O $HostAppService$ O O $PasswordStorageService$ O O $ToastrService$ O O O O O O O O O O O O O O O $Promise$ O $SSHConnection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $SSHSession$ O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $digest$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O
import { Component } from 's' import { NgbActiveModal } from 's' import { ToastrService } from 's' import { ConfigService , AppService } from 's' import { SettingsTabComponent } from 's' import { SSHService } from 's' import { SSHConnection , SSHConnectionGroup } from 's' @ Component ( { template : require ( 's' ) , styles : [ require ( 's' ) ] , } ) export class SSHModalComponent { connections : SSHConnection [ ] childFolders : SSHConnectionGroup [ ] quickTarget : string lastConnection : SSHConnection | null = null childGroups : SSHConnectionGroup [ ] groupCollapsed : { [ id ] : boolean } = { } constructor ( public modalInstance , private config , private ssh , private app , private toastr , ) { } ngOnInit ( ) { this . connections = this . config . store . ssh . connections if ( window . localStorage . lastConnection ) { this . lastConnection = JSON . parse ( window . localStorage . lastConnection ) } this . refresh ( ) } quickConnect ( ) { let user = 's' let host = this . quickTarget let port = 0 if ( host . includes ( 's' ) ) { [ user , host ] = host . split ( 's' ) } if ( host . includes ( 's' ) ) { port = parseInt ( host . split ( 's' ) [ 0 ] ) host = host . split ( 's' ) [ 0 ] } const connection = { name : this . quickTarget , host , user , port , } window . localStorage . lastConnection = JSON . stringify ( connection ) this . connect ( connection ) } clearLastConnection ( ) { window . localStorage . lastConnection = null this . lastConnection = null } connect ( connection ) { this . close ( ) this . ssh . openTab ( connection ) . catch ( error => { this . toastr . error ( `template` ) } ) . then ( ( ) => { setTimeout ( ( ) => { this . app . activeTab . emitFocused ( ) } ) } ) } manageConnections ( ) { this . close ( ) this . app . openNewTab ( SettingsTabComponent , { activeTab : 's' } ) } close ( ) { this . modalInstance . close ( ) } refresh ( ) { this . childGroups = [ ] let connections = this . connections if ( this . quickTarget ) { connections = connections . filter ( ( connection ) => ( connection . name + connection . group ! ) . toLowerCase ( ) . includes ( this . quickTarget ) ) } for ( const connection of connections ) { connection . group = connection . group || undefined let group = this . childGroups . find ( x => x . name === connection . group ) if ( ! group ) { group = { name : connection . group ! , connections : [ ] , } this . childGroups . push ( group ! ) } group . connections . push ( connection ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $NgbActiveModal$ O O $ConfigService$ O O $SSHService$ O O $AppService$ O O $ToastrService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SSHConnection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SSHConnection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SSHConnection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { NgbModal } from 's' import { HotkeysService , ToolbarButtonProvider , ToolbarButton } from 's' import { SSHModalComponent } from 's' @ Injectable ( ) export class ButtonProvider extends ToolbarButtonProvider { constructor ( private ngbModal , hotkeys , ) { super ( ) hotkeys . matchedHotkey . subscribe ( async ( hotkey ) => { if ( hotkey === 's' ) { this . activate ( ) } } ) } activate ( ) { this . ngbModal . open ( SSHModalComponent ) } provide ( ) : ToolbarButton [ ] { return [ { icon : require ( 's' ) , weight : 0 , title : 's' , touchBarNSImage : 's' , click : async ( ) => { this . activate ( ) } , } ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgbModal$ O $HotkeysService$ O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' import { NgbModal , NgbActiveModal } from 's' import { ElectronService , HostAppService } from 's' import { PasswordStorageService } from 's' import { SSHConnection , LoginScript , SSHAlgorithmType } from 's' import { PromptModalComponent } from 's' import { ALGORITHMS } from 's' @ Component ( { template : require ( 's' ) , } ) export class EditConnectionModalComponent { connection : SSHConnection hasSavedPassword : boolean supportedAlgorithms : { [ id ] : string [ ] } = { } defaultAlgorithms : { [ id ] : string [ ] } = { } algorithms : { [ id ] : { [ a ] : boolean } } = { } constructor ( private modalInstance , private electron , private hostApp , private passwordStorage , private ngbModal , ) { for ( const k of Object . values ( SSHAlgorithmType ) ) { const supportedAlg = { [ SSHAlgorithmType . KEX ] : 's' , [ SSHAlgorithmType . HOSTKEY ] : 's' , [ SSHAlgorithmType . CIPHER ] : 's' , [ SSHAlgorithmType . HMAC ] : 's' , } [ k ] const defaultAlg = { [ SSHAlgorithmType . KEX ] : 's' , [ SSHAlgorithmType . HOSTKEY ] : 's' , [ SSHAlgorithmType . CIPHER ] : 's' , [ SSHAlgorithmType . HMAC ] : 's' , } [ k ] this . supportedAlgorithms [ k ] = ALGORITHMS [ supportedAlg ] this . defaultAlgorithms [ k ] = ALGORITHMS [ defaultAlg ] } } async ngOnInit ( ) { this . hasSavedPassword = ! ! await this . passwordStorage . loadPassword ( this . connection ) this . connection . algorithms = this . connection . algorithms || { } this . connection . scripts = this . connection . scripts || [ ] for ( const k of Object . values ( SSHAlgorithmType ) ) { if ( ! this . connection . algorithms [ k ] ) { this . connection . algorithms [ k ] = this . defaultAlgorithms [ k ] } this . algorithms [ k ] = { } for ( const alg of this . connection . algorithms [ k ] ) { this . algorithms [ k ] [ alg ] = true } } } async setPassword ( ) { const modal = this . ngbModal . open ( PromptModalComponent ) modal . componentInstance . prompt = `template` modal . componentInstance . password = true try { const result = await modal . result if ( result && result . value ) { this . passwordStorage . savePassword ( this . connection , result . value ) this . hasSavedPassword = true } } catch { } } clearSavedPassword ( ) { this . hasSavedPassword = false this . passwordStorage . deletePassword ( this . connection ) } selectPrivateKey ( ) { this . electron . dialog . showOpenDialog ( this . hostApp . getWindow ( ) , { title : 's' , } ) . then ( result => { if ( result . filePaths ) { this . connection . privateKey = result . filePaths [ 0 ] } } ) } save ( ) { for ( const k of Object . values ( SSHAlgorithmType ) ) { this . connection . algorithms ! [ k ] = Object . entries ( this . algorithms [ k ] ) . filter ( ( [ _k , v ] ) => ! ! v ) . map ( ( [ k , _v ] ) => k ) } this . modalInstance . close ( this . connection ) } cancel ( ) { this . modalInstance . dismiss ( ) } moveScriptUp ( script ) { if ( ! this . connection . scripts ) { this . connection . scripts = [ ] } const index = this . connection . scripts . indexOf ( script ) if ( index > 0 ) { this . connection . scripts . splice ( index , 0 ) this . connection . scripts . splice ( index - 0 , 0 , script ) } } moveScriptDown ( script ) { if ( ! this . connection . scripts ) { this . connection . scripts = [ ] } const index = this . connection . scripts . indexOf ( script ) if ( index >= 0 && index < this . connection . scripts . length - 0 ) { this . connection . scripts . splice ( index , 0 ) this . connection . scripts . splice ( index + 0 , 0 , script ) } } async deleteScript ( script ) { if ( this . connection . scripts && ( await this . electron . showMessageBox ( this . hostApp . getWindow ( ) , { type : 's' , message : 's' , detail : script . expect , buttons : [ 's' , 's' ] , defaultId : 0 , } ) ) . response === 0 ) { this . connection . scripts = this . connection . scripts . filter ( x => x !== script ) } } addScript ( ) { if ( ! this . connection . scripts ) { this . connection . scripts = [ ] } this . connection . scripts . push ( { expect : 's' , send : 's' } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O $string$ O O O O $string$ O O O O O O O O O O O $NgbActiveModal$ O O $ElectronService$ O O $HostAppService$ O O $PasswordStorageService$ O O $NgbModal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LoginScript$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LoginScript$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $LoginScript$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' import { NgbModal } from 's' import { ConfigService , ElectronService , HostAppService } from 's' import { SSHConnection , SSHConnectionGroup } from 's' import { EditConnectionModalComponent } from 's' import { PromptModalComponent } from 's' @ Component ( { template : require ( 's' ) , } ) export class SSHSettingsTabComponent { connections : SSHConnection [ ] childGroups : SSHConnectionGroup [ ] groupCollapsed : { [ id ] : boolean } = { } constructor ( public config , private electron , private hostApp , private ngbModal , ) { this . connections = this . config . store . ssh . connections this . refresh ( ) } createConnection ( ) { const connection = { name : 's' , host : 's' , port : 0 , user : 's' , } const modal = this . ngbModal . open ( EditConnectionModalComponent ) modal . componentInstance . connection = connection modal . result . then ( result => { this . connections . push ( result ) this . config . store . ssh . connections = this . connections this . config . save ( ) this . refresh ( ) } ) } editConnection ( connection ) { const modal = this . ngbModal . open ( EditConnectionModalComponent , { size : 's' } ) modal . componentInstance . connection = Object . assign ( { } , connection ) modal . result . then ( result => { Object . assign ( connection , result ) this . config . store . ssh . connections = this . connections this . config . save ( ) this . refresh ( ) } ) } async deleteConnection ( connection ) { if ( ( await this . electron . showMessageBox ( this . hostApp . getWindow ( ) , { type : 's' , message : `template` , buttons : [ 's' , 's' ] , defaultId : 0 , } ) ) . response === 0 ) { this . connections = this . connections . filter ( x => x !== connection ) this . config . store . ssh . connections = this . connections this . config . save ( ) this . refresh ( ) } } editGroup ( group ) { const modal = this . ngbModal . open ( PromptModalComponent ) modal . componentInstance . prompt = 's' modal . componentInstance . value = group . name modal . result . then ( result => { if ( result ) { for ( const connection of this . connections . filter ( x => x . group === group . name ) ) { connection . group = result . value } this . config . store . ssh . connections = this . connections this . config . save ( ) this . refresh ( ) } } ) } async deleteGroup ( group ) { if ( ( await this . electron . showMessageBox ( this . hostApp . getWindow ( ) , { type : 's' , message : `template` , buttons : [ 's' , 's' ] , defaultId : 0 , } ) ) . response === 0 ) { for ( const connection of this . connections . filter ( x => x . group === group . name ) ) { connection . group = undefined } this . config . save ( ) this . refresh ( ) } } refresh ( ) { this . connections = this . config . store . ssh . connections this . childGroups = [ ] for ( const connection of this . connections ) { connection . group = connection . group || undefined let group = this . childGroups . find ( x => x . name === connection . group ) if ( ! group ) { group = { name : connection . group ! , connections : [ ] , } this . childGroups . push ( group ! ) } group . connections . push ( connection ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O $ConfigService$ O O $ElectronService$ O O $HostAppService$ O O $NgbModal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $SSHConnection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SSHConnection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SSHConnection$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SSHConnectionGroup$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SSHConnectionGroup$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ConfigProvider } from 's' export class SSHConfigProvider extends ConfigProvider { defaults = { ssh : { connections : [ ] , options : { } , } , hotkeys : { ssh : [ 's' , ] , } , } platformDefaults = { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { HotkeyDescription , HotkeyProvider } from 's' @ Injectable ( ) export class SSHHotkeyProvider extends HotkeyProvider { hotkeys : HotkeyDescription [ ] = [ { id : 's' , name : 's' , } , ] async provide ( ) < HotkeyDescription [ ] > { return this . hotkeys } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O
import { Injectable } from 's' import { SettingsTabProvider } from 's' import { SSHSettingsTabComponent } from 's' @ Injectable ( ) export class SSHSettingsTabProvider extends SettingsTabProvider { id = 's' icon = 's' title = 's' getComponentType ( ) { return SSHSettingsTabComponent } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O
import { Injectable } from 's' import { TabRecoveryProvider , RecoveredTab } from 's' import { SSHTabComponent } from 's' @ Injectable ( ) export class RecoveryProvider extends TabRecoveryProvider { async recover ( recoveryToken ) < RecoveredTab | null > { if ( recoveryToken && recoveryToken . type === 's' ) { return { type : SSHTabComponent , options : { connection : recoveryToken . connection } , } } return null } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgModule } from 's' import { CommonModule } from 's' import { FormsModule } from 's' import { NgbModule } from 's' import { ToastrModule } from 's' import TerminusCoreModule , { ToolbarButtonProvider , ConfigProvider , TabRecoveryProvider , HotkeyProvider } from 's' import { SettingsTabProvider } from 's' import { EditConnectionModalComponent } from 's' import { SSHModalComponent } from 's' import { PromptModalComponent } from 's' import { SSHSettingsTabComponent } from 's' import { SSHTabComponent } from 's' import { ButtonProvider } from 's' import { SSHConfigProvider } from 's' import { SSHSettingsTabProvider } from 's' import { RecoveryProvider } from 's' import { SSHHotkeyProvider } from 's' @ NgModule ( { imports : [ NgbModule , CommonModule , FormsModule , ToastrModule , TerminusCoreModule , ] , providers : [ { provide : ToolbarButtonProvider , useClass : ButtonProvider , multi : true } , { provide : ConfigProvider , useClass : SSHConfigProvider , multi : true } , { provide : SettingsTabProvider , useClass : SSHSettingsTabProvider , multi : true } , { provide : TabRecoveryProvider , useClass : RecoveryProvider , multi : true } , { provide : HotkeyProvider , useClass : SSHHotkeyProvider , multi : true } , ] , entryComponents : [ EditConnectionModalComponent , PromptModalComponent , SSHModalComponent , SSHSettingsTabComponent , SSHTabComponent , ] , declarations : [ EditConnectionModalComponent , PromptModalComponent , SSHModalComponent , SSHSettingsTabComponent , SSHTabComponent , ] , } ) export default class SSHModule { }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) module . exports = { target : 's' , entry : 's' , context : __dirname , devtool : 's' , output : { path : path . resolve ( __dirname , 's' ) , filename : 's' , pathinfo : true , libraryTarget : 's' , devtoolModuleFilenameTemplate : 's' , } , mode : process . env . TERMINUS_DEV ? 's' : 's' , optimization : { minimize : false , } , resolve : { modules : [ 's' , 's' , 's' , 's' ] . map ( x => path . join ( __dirname , x ) ) , extensions : [ 's' , 's' ] , } , module : { rules : [ { test : "s" , use : { loader : 's' , options : { configFileName : path . resolve ( __dirname , 's' ) , typeRoots : [ path . resolve ( __dirname , 's' ) , path . resolve ( __dirname , 's' ) , ] , paths : { "s" : [ path . resolve ( __dirname , 's' ) ] , "s" : [ path . resolve ( __dirname , 's' ) ] , } , } , } , } , { test : "s" , use : [ 's' , 's' ] } , { test : "s" , use : [ 's' , 's' , 's' ] } , { test : "s" , use : [ 's' ] } , ] , } , externals : [ 's' , 's' , 's' , 's' , 's' , "s" , "s" , "s" , "s" , ] , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
export interface ResizeEvent { columns : number rows : number } export interface SessionOptions { name ? : string command : string args : string [ ] cwd ? : string env ? : { [ id ] : string } width ? : number height ? : number pauseAfterExit ? : boolean runAsAdministrator ? : boolean } export interface Profile { name : string , sessionOptions : SessionOptions , isBuiltin ? : boolean icon ? : string } export interface TerminalColorScheme { name : string foreground : string background : string cursor : string colors : string [ ] } export interface Shell { id : string name ? : string command : string args ? : string [ ] env : { [ id ] : string } fsBase ? : string icon ? : string hidden ? : boolean }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O
import * as os from 's' export const WIN_BUILD_CONPTY_SUPPORTED = 0 export const WIN_BUILD_CONPTY_STABLE = 0 export const WIN_BUILD_WSL_EXE_DISTRO_FLAG = 0 export function isWindowsBuild ( build ) { return process . platform === 's' && parseFloat ( os . release ( ) ) >= 0 && parseInt ( os . release ( ) . split ( 's' ) [ 0 ] ) >= build } export function getCSSFontFamily ( config ) { let fonts = config . terminal . font . split ( 's' ) . map ( x => x . trim ( ) . replace ( "s" , 's' ) ) if ( config . terminal . fallbackFont ) { fonts . push ( config . terminal . fallbackFont ) } fonts . push ( 's' ) fonts . push ( 's' ) fonts = fonts . map ( x => `template` ) return fonts . join ( 's' ) }	O O O O O O O O O O O O O O O O O O O O O O O $boolean$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as psNode from 's' import * as fs from 's' import * as os from 's' import * as nodePTY from 's' import { Observable , Subject } from 's' import { first } from 's' import { Injectable } from 's' import { Logger , LogService , ConfigService } from 's' import { exec } from 's' import { SessionOptions } from 's' import { WIN_BUILD_CONPTY_SUPPORTED , isWindowsBuild } from 's' try { var macOSNativeProcessList = require ( 's' ) } catch { } try { var windowsProcessTree = require ( 's' ) } catch { } export interface ChildProcess { pid : number ppid : number command : string } const windowsDirectoryRegex = "s" const catalinaDataVolumePrefix = 's' const 0 = 's' const 0 = 's' export abstract class BaseSession { open : boolean name : string truePID : number protected output = new Subject < string > ( ) protected closed = new Subject < void > ( ) protected destroyed = new Subject < void > ( ) private initialDataBuffer = 's' private initialDataBufferReleased = false get output$ ( ) : Observable < string > { return this . output } get closed$ ( ) : Observable < void > { return this . closed } get destroyed$ ( ) : Observable < void > { return this . destroyed } emitOutput ( data ) { if ( ! this . initialDataBufferReleased ) { this . initialDataBuffer += data } else { this . output . next ( data ) } } releaseInitialDataBuffer ( ) { this . initialDataBufferReleased = true this . output . next ( this . initialDataBuffer ) this . initialDataBuffer = 's' } async destroy ( ) < void > { if ( this . open ) { this . open = false this . closed . next ( ) this . destroyed . next ( ) this . output . complete ( ) await this . gracefullyKillProcess ( ) } } abstract start ( options ) abstract resize ( columns , rows ) abstract write ( data ) abstract kill ( signal ? ) abstract async getChildProcesses ( ) < ChildProcess [ ] > abstract async gracefullyKillProcess ( ) < void > abstract async getWorkingDirectory ( ) < string | null > } export class Session extends BaseSession { private pty : any private pauseAfterExit = false private guessedCWD : string | null = null private reportedCWD : string constructor ( private config ) { super ( ) } start ( options ) { this . name = options . name || 's' const env = { ... process . env , TERM : 's' , TERM_PROGRAM : 's' , ... options . env , ... this . config . store . terminal . environment || { } , } if ( process . platform === 's' && ! process . env . LC_ALL ) { const locale = process . env . LC_CTYPE || 's' Object . assign ( env , { LANG : locale , LC_ALL : locale , LC_MESSAGES : locale , LC_NUMERIC : locale , LC_COLLATE : locale , LC_MONETARY : locale , } ) } let cwd = options . cwd || process . env . HOME if ( ! fs . existsSync ( cwd ) ) { console . warn ( 's' , cwd ) cwd = undefined } this . pty = nodePTY . spawn ( options . command , options . args || [ ] , { name : 's' , cols : options . width || 0 , rows : options . height || 0 , cwd , env : env , experimentalUseConpty : ( isWindowsBuild ( WIN_BUILD_CONPTY_SUPPORTED ) && this . config . store . terminal . useConPTY ? 0 : false ) as any , } ) this . guessedCWD = cwd || null this . truePID = this . pty [ 's' ] setTimeout ( async ( ) => { let processes = await this . getChildProcesses ( ) while ( processes . length === 0 ) { this . truePID = processes [ 0 ] . pid processes = await this . getChildProcesses ( ) } } , 0 ) this . open = true this . pty . on ( 's' , data => { data = this . 0 ( data ) this . emitOutput ( data ) if ( process . platform === 's' ) { this . guessWindowsCWD ( data ) } } ) this . pty . on ( 's' , ( ) => { if ( this . pauseAfterExit ) { return } else if ( this . open ) { this . destroy ( ) } } ) this . pty . on ( 's' , ( ) => { if ( this . pauseAfterExit ) { this . emitOutput ( 's' ) } else if ( this . open ) { this . destroy ( ) } } ) this . pauseAfterExit = options . pauseAfterExit || false } 0 ( data ) { if ( data . includes ( 0 ) ) { const preData = data . substring ( 0 , data . indexOf ( 0 ) ) let params = data . substring ( data . indexOf ( 0 ) + 0 . length ) const postData = params . substring ( params . indexOf ( 0 ) + 0 . length ) params = params . substring ( 0 , params . indexOf ( 0 ) ) if ( params . startsWith ( 's' ) ) { this . reportedCWD = params . split ( 's' ) [ 0 ] if ( this . reportedCWD . startsWith ( 's' ) ) { this . reportedCWD = os . homedir ( ) + this . reportedCWD . substring ( 0 ) } data = preData + postData } } return data } resize ( columns , rows ) { if ( this . pty . _writable ) { this . pty . resize ( columns , rows ) } } write ( data ) { if ( this . open ) { if ( this . pty . _writable ) { this . pty . write ( Buffer . from ( data , 's' ) ) } else { this . destroy ( ) } } } kill ( signal ? ) { this . pty . kill ( signal ) } async getChildProcesses ( ) < ChildProcess [ ] > { if ( ! this . truePID ) { return [ ] } if ( process . platform === 's' ) { const processes = await macOSNativeProcessList . getProcessList ( ) return processes . filter ( x => x . ppid === this . truePID ) . map ( p => ( { pid : p . pid , ppid : p . ppid , command : p . name , } ) ) } if ( process . platform === 's' ) { return new Promise < ChildProcess [ ] > ( resolve => { windowsProcessTree . getProcessTree ( this . truePID , tree => { resolve ( tree ? tree . children . map ( child => ( { pid : child . pid , ppid : tree . pid , command : child . name , } ) ) : [ ] ) } ) } ) } return new Promise < ChildProcess [ ] > ( ( resolve , reject ) => { psNode . lookup ( { ppid : this . truePID } , ( err , processes ) => { if ( err ) { return reject ( err ) } resolve ( processes as ChildProcess [ ] ) } ) } ) } async gracefullyKillProcess ( ) < void > { if ( process . platform === 's' ) { this . kill ( ) } else { await new Promise ( ( resolve ) => { this . kill ( 's' ) setImmediate ( ( ) => { if ( ! this . open ) { resolve ( ) } else { setTimeout ( ( ) => { if ( this . open ) { this . kill ( 's' ) } resolve ( ) } , 0 ) } } ) } ) } } async getWorkingDirectory ( ) < string | null > { if ( this . reportedCWD ) { return this . reportedCWD } if ( ! this . truePID ) { return null } if ( process . platform === 's' ) { let lines : string [ ] try { lines = ( await exec ( `template` ) ) [ 0 ] . toString ( ) . split ( 's' ) } catch ( e ) { return null } let cwd = lines [ lines [ 0 ] === 's' ? 0 : 0 ] . substring ( 0 ) if ( cwd . startsWith ( catalinaDataVolumePrefix ) ) { cwd = cwd . substring ( catalinaDataVolumePrefix . length ) } return cwd } if ( process . platform === 's' ) { return fs . readlink ( `template` ) } if ( process . platform === 's' ) { if ( ! this . guessedCWD ) { return null } try { await fs . access ( this . guessedCWD ) } catch ( e ) { return null } return this . guessedCWD } return null } private guessWindowsCWD ( data ) { const match = windowsDirectoryRegex . exec ( data ) if ( match ) { this . guessedCWD = match [ 0 ] } } } @ Injectable ( { providedIn : 's' } ) export class SessionsService { sessions : { [ id ] : BaseSession } = { } logger : Logger private lastID = 0 constructor ( log , ) { require ( 's' ) ( nodePTY ) this . logger = log . create ( 's' ) } addSession ( session , options ) { this . lastID ++ options . name = `template` session . start ( options ) session . destroyed$ . pipe ( first ( ) ) . subscribe ( ( ) => { delete this . sessions [ session . name ] } ) this . sessions [ session . name ] = session return session } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $SessionOptions$ O O $void$ O $number$ O $number$ O O $void$ O $string$ O O $void$ O O $string$ O O O $Promise$ O O O O O O O O O $Promise$ O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O O O O O O O O $SessionOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O $LogService$ O O O O O O O O O O O O O O O O O O O O O O O $BaseSession$ O $SessionOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Observable , Subject , AsyncSubject , ReplaySubject , BehaviorSubject } from 's' import { ResizeEvent } from 's' import { ConfigService , ThemesService , HotkeysService } from 's' export interface SearchOptions { regex ? : boolean wholeWord ? : boolean caseSensitive ? : boolean } export abstract class Frontend { configService : ConfigService themesService : ThemesService hotkeysService : HotkeysService enableResizing = true protected ready = new AsyncSubject < void > ( ) protected title = new ReplaySubject < string > ( 0 ) protected alternateScreenActive = new BehaviorSubject < boolean > ( false ) protected mouseEvent = new Subject < MouseEvent > ( ) protected bell = new Subject < void > ( ) protected contentUpdated = new Subject < void > ( ) protected input = new Subject < string > ( ) protected resize = new ReplaySubject < ResizeEvent > ( 0 ) protected dragOver = new Subject < DragEvent > ( ) protected drop = new Subject < DragEvent > ( ) get ready$ ( ) : Observable < void > { return this . ready } get title$ ( ) : Observable < string > { return this . title } get alternateScreenActive$ ( ) : Observable < boolean > { return this . alternateScreenActive } get mouseEvent$ ( ) : Observable < MouseEvent > { return this . mouseEvent } get bell$ ( ) : Observable < void > { return this . bell } get contentUpdated$ ( ) : Observable < void > { return this . contentUpdated } get input$ ( ) : Observable < string > { return this . input } get resize$ ( ) : Observable < ResizeEvent > { return this . resize } get dragOver$ ( ) : Observable < DragEvent > { return this . dragOver } get drop$ ( ) : Observable < DragEvent > { return this . drop } destroy ( ) { for ( const o of [ this . ready , this . title , this . alternateScreenActive , this . mouseEvent , this . bell , this . contentUpdated , this . input , this . resize , this . dragOver , this . drop , ] ) { o . complete ( ) } } abstract attach ( host ) detach ( host ) { } abstract getSelection ( ) abstract copySelection ( ) abstract clearSelection ( ) abstract focus ( ) abstract write ( data ) abstract clear ( ) abstract visualBell ( ) abstract scrollToBottom ( ) abstract configure ( ) abstract setZoom ( zoom ) abstract findNext ( term , searchOptions ? ) abstract findPrevious ( term , searchOptions ? ) }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $HTMLElement$ O $void$ O $HTMLElement$ O O O O $string$ O O O $void$ O O O $void$ O O O $void$ O O O $void$ O $string$ O O $void$ O O O $void$ O O O $void$ O O O $void$ O O O $void$ O $number$ O O $boolean$ O $string$ O O $SearchOptions$ O O $boolean$ O $string$ O O $SearchOptions$ O O
export const hterm = require ( 's' ) hterm . hterm . defaultStorage = new hterm . lib . Storage . Memory ( ) export const preferenceManager = new hterm . hterm . PreferenceManager ( 's' ) hterm . hterm . VT . ESC [ 's' ] = function ( parseState ) { parseState . resetArguments ( ) function parseOSC ( ps ) { if ( ! this . parseUntilStringTerminator_ ( ps ) || ps . func === parseOSC ) { return } this . terminal . setWindowTitle ( ps . args [ 0 ] ) } parseState . func = parseOSC } preferenceManager . set ( 's' , 's' ) preferenceManager . set ( 's' , { 0 : 's' , } ) hterm . hterm . Terminal . prototype . showOverlay = ( ) => null hterm . hterm . Terminal . prototype . setCSS = function ( css ) { const doc = this . scrollPort_ . document_ if ( ! doc . querySelector ( 's' ) ) { const node = doc . createElement ( 's' ) node . id = 's' doc . head . appendChild ( node ) } doc . querySelector ( 's' ) . innerText = css } const oldCharWidthDisregardAmbiguous = hterm . lib . wc . charWidthDisregardAmbiguous hterm . lib . wc . charWidthDisregardAmbiguous = codepoint => { if ( ( codepoint >= 0 && codepoint <= 0 ) || ( codepoint >= 0 && codepoint <= 0 ) ) { return 0 } return oldCharWidthDisregardAmbiguous ( codepoint ) } hterm . hterm . Terminal . prototype . applyCursorShape = function ( ) { const modes = [ [ hterm . hterm . Terminal . cursorShape . BLOCK , true ] , [ this . defaultCursorShape || hterm . hterm . Terminal . cursorShape . BLOCK , false ] , [ hterm . hterm . Terminal . cursorShape . BLOCK , false ] , [ hterm . hterm . Terminal . cursorShape . UNDERLINE , true ] , [ hterm . hterm . Terminal . cursorShape . UNDERLINE , false ] , [ hterm . hterm . Terminal . cursorShape . BEAM , true ] , [ hterm . hterm . Terminal . cursorShape . BEAM , false ] , ] const modeNumber = this . cursorMode || 0 if ( modeNumber >= modes . length ) { console . warn ( 's' + modeNumber ) return } setTimeout ( ( ) => { this . setCursorShape ( modes [ modeNumber ] [ 0 ] ) this . setCursorBlink ( modes [ modeNumber ] [ 0 ] ) } ) setTimeout ( ( ) => { this . setCursorVisible ( true ) } ) } hterm . hterm . VT . CSI [ 's' ] = function ( parseState ) { const arg = parseState . args [ 0 ] this . terminal . cursorMode = arg this . terminal . applyCursorShape ( ) } hterm . hterm . VT . OSC [ 's' ] = function ( parseState ) { const args : string [ ] = parseState . args [ 0 ] . split ( 's' ) const pairCount = args . length / 0 const colorPalette = this . terminal . getTextAttributes ( ) . colorPalette const responseArray : string [ ] = [ ] for ( let pairNumber = 0 ; pairNumber < pairCount ; ++ pairNumber ) { const colorIndex = parseInt ( args [ pairNumber * 0 ] ) let colorValue = args [ pairNumber * 0 + 0 ] if ( colorIndex >= colorPalette . length ) { continue } if ( colorValue === 's' ) { colorValue = hterm . lib . colors . 0 ( colorPalette [ colorIndex ] ) if ( colorValue ) { responseArray . push ( colorIndex . toString ( ) + 's' + colorValue ) } continue } colorValue = hterm . lib . colors . 0 ( colorValue ) if ( colorValue ) { this . terminal . colorPaletteOverrides [ colorIndex ] = colorValue colorPalette [ colorIndex ] = colorValue } } if ( responseArray . length ) { this . terminal . io . sendString ( 's' + responseArray . join ( 's' ) + 's' ) } } const _collapseToEnd = Selection . prototype . collapseToEnd Selection . prototype . collapseToEnd = function ( ) { try { _collapseToEnd . apply ( this ) } catch ( e ) { } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Frontend , SearchOptions } from 's' import { hterm , preferenceManager } from 's' import { getCSSFontFamily } from 's' export class HTermFrontend extends Frontend { term : any io : any private htermIframe : HTMLElement private initialized = false private configuredFontSize = 0 private configuredLinePadding = 0 private configuredBackgroundColor = 's' private zoom = 0 attach ( host ) { if ( ! this . initialized ) { this . init ( ) this . initialized = true preferenceManager . set ( 's' , 's' ) this . term . decorate ( host ) this . htermIframe = this . term . scrollPort_ . iframe_ } else { host . appendChild ( this . htermIframe ) } } getSelection ( ) { return this . term . getSelectionText ( ) } copySelection ( ) { this . term . copySelectionToClipboard ( ) } clearSelection ( ) { this . term . getDocument ( ) . getSelection ( ) . removeAllRanges ( ) } focus ( ) { setTimeout ( ( ) => { this . term . scrollPort_ . resize ( ) this . term . scrollPort_ . focus ( ) } , 0 ) } write ( data ) { this . io . 0 ( data ) } clear ( ) { this . term . wipeContents ( ) this . term . onVTKeystroke ( 's' ) } configure ( ) { const config = this . configService . store this . configuredFontSize = config . terminal . fontSize this . configuredLinePadding = config . terminal . linePadding this . setFontSize ( ) preferenceManager . set ( 's' , getCSSFontFamily ( config ) ) preferenceManager . set ( 's' , true ) preferenceManager . set ( 's' , config . terminal . bell === 's' ) preferenceManager . set ( 's' , false ) preferenceManager . set ( 's' , 's' ) preferenceManager . set ( 's' , 's' ) preferenceManager . set ( 's' , false ) preferenceManager . set ( 's' , process . platform === 's' ) preferenceManager . set ( 's' , config . terminal . copyOnSelect ) preferenceManager . set ( 's' , false ) preferenceManager . set ( 's' , config . terminal . altIsMeta ) preferenceManager . set ( 's' , 's' ) preferenceManager . set ( 's' , 's' ) preferenceManager . set ( 's' , true ) preferenceManager . set ( 's' , config . terminal . cursorBlink ) preferenceManager . set ( 's' , true ) preferenceManager . set ( 's' , false ) preferenceManager . set ( 's' , config . terminal . scrollOnInput ) if ( config . terminal . colorScheme . foreground ) { preferenceManager . set ( 's' , config . terminal . colorScheme . foreground ) } if ( config . terminal . background === 's' ) { if ( config . terminal . colorScheme . background ) { preferenceManager . set ( 's' , config . terminal . colorScheme . background ) } } else { preferenceManager . set ( 's' , config . appearance . vibrancy ? 's' : this . themesService . findCurrentTheme ( ) . terminalBackground ) } this . configuredBackgroundColor = preferenceManager . get ( 's' ) if ( ! this . term ) { return } let css = require ( 's' ) if ( ! config . terminal . ligatures ) { css += `template` } else { css += `template` } css += config . appearance . css this . term . setCSS ( css ) if ( config . terminal . colorScheme . colors ) { preferenceManager . set ( 's' , Object . assign ( [ ] , config . terminal . colorScheme . colors , this . term . colorPaletteOverrides ) ) } if ( config . terminal . colorScheme . cursor ) { preferenceManager . set ( 's' , config . terminal . colorScheme . cursor ) } this . term . setBracketedPaste ( config . terminal . bracketedPaste ) this . term . defaultCursorShape = { block : hterm . hterm . Terminal . cursorShape . BLOCK , underline : hterm . hterm . Terminal . cursorShape . UNDERLINE , beam : hterm . hterm . Terminal . cursorShape . BEAM , } [ config . terminal . cursor ] this . term . applyCursorShape ( ) this . term . setCursorBlink ( config . terminal . cursorBlink ) if ( config . terminal . cursorBlink ) { this . term . onCursorBlink_ ( ) } } setZoom ( zoom ) { this . zoom = zoom this . setFontSize ( ) } visualBell ( ) { preferenceManager . set ( 's' , 's' ) setTimeout ( ( ) => { preferenceManager . set ( 's' , this . configuredBackgroundColor ) } , 0 ) } scrollToBottom ( ) { this . term . scrollEnd ( ) } findNext ( _term , _searchOptions ? ) { return false } findPrevious ( _term , _searchOptions ? ) { return false } private setFontSize ( ) { const size = this . configuredFontSize * Math . pow ( 0 , this . zoom ) preferenceManager . set ( 's' , size ) if ( this . term ) { setTimeout ( ( ) => { this . term . scrollPort_ . characterSize = this . term . scrollPort_ . measureCharacterSize ( ) this . term . setFontSize ( size ) } ) } } private init ( ) { this . term = new hterm . hterm . Terminal ( ) this . term . colorPaletteOverrides = [ ] this . term . onTerminalReady = ( ) => { this . term . installKeyboard ( ) this . term . scrollPort_ . setCtrlVPaste ( true ) this . io = this . term . io . push ( ) this . io . onVTKeystroke = this . io . sendString = data => this . input . next ( data ) this . io . onTerminalResize = ( columns , rows ) => { this . resize . next ( { columns , rows } ) } this . ready . next ( ) this . ready . complete ( ) this . term . scrollPort_ . document_ . addEventListener ( 's' , event => { this . dragOver . next ( event ) } ) this . term . scrollPort_ . document_ . addEventListener ( 's' , event => { this . drop . next ( event ) } ) } this . term . setWindowTitle = title => this . title . next ( title ) const _setAlternateMode = this . term . setAlternateMode . bind ( this . term ) this . term . setAlternateMode = ( state ) => { _setAlternateMode ( state ) this . alternateScreenActive . next ( state ) } this . term . primaryScreen_ . syncSelectionCaret = ( ) => null this . term . alternateScreen_ . syncSelectionCaret = ( ) => null this . term . primaryScreen_ . terminal = this . term this . term . alternateScreen_ . terminal = this . term this . term . scrollPort_ . onPaste_ = ( event ) => { event . preventDefault ( ) } const _resize = this . term . scrollPort_ . resize . bind ( this . term . scrollPort_ ) this . term . scrollPort_ . resize = ( ) => { if ( this . enableResizing ) { _resize ( ) } } const _onMouse = this . term . onMouse_ . bind ( this . term ) this . term . onMouse_ = ( event ) => { this . mouseEvent . next ( event ) if ( event . type === 's' && event . which === 0 ) { event . preventDefault ( ) event . stopPropagation ( ) return } if ( event . type === 's' && event . altKey ) { event . preventDefault ( ) } _onMouse ( event ) } this . term . ringBell = ( ) => this . bell . next ( ) for ( const screen of [ this . term . primaryScreen_ , this . term . alternateScreen_ ] ) { const _insertString = screen . insertString . bind ( screen ) screen . insertString = ( data ) => { _insertString ( data ) this . contentUpdated . next ( ) } const _deleteChars = screen . deleteChars . bind ( screen ) screen . deleteChars = ( count ) => { const ret = _deleteChars ( count ) this . contentUpdated . next ( ) return ret } const _expandSelection = screen . expandSelection . bind ( screen ) screen . expandSelection = ( selection ) => { const range = selection . getRangeAt ( 0 ) if ( range . endOffset > 0 && range . endContainer . nodeType === 0 && range . endContainer . textContent !== 's' ) { while ( "s" . test ( range . endContainer . textContent . substr ( 0 , range . endOffset ) ) ) { range . setEnd ( range . endContainer , range . endOffset - 0 ) } } _expandSelection ( selection ) } } const _measureCharacterSize = this . term . scrollPort_ . measureCharacterSize . bind ( this . term . scrollPort_ ) this . term . scrollPort_ . measureCharacterSize = ( ) => { const size = _measureCharacterSize ( ) size . height += this . configuredLinePadding return size } const _onCursorBlink = this . term . onCursorBlink_ . bind ( this . term ) this . term . onCursorBlink_ = ( ) => { this . term . cursorNode_ . style . opacity = 's' _onCursorBlink ( ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O $boolean$ O $string$ O O $SearchOptions$ O O O O O $boolean$ O $string$ O O $SearchOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Frontend , SearchOptions } from 's' import { Terminal , ITheme } from 's' import { getCSSFontFamily } from 's' import { FitAddon } from 's' import { LigaturesAddon } from 's' import { SearchAddon } from 's' import { WebglAddon } from 's' import 's' import deepEqual from 's' import { Attributes } from 's' import { AttributeData } from 's' import { CellData } from 's' const COLOR_NAMES = [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , ] export class XTermFrontend extends Frontend { enableResizing = true protected xtermCore : any protected enableWebGL = false private xterm : Terminal private configuredFontSize = 0 private zoom = 0 private resizeHandler : ( ) => void private configuredTheme : ITheme = { } private copyOnSelect = false private search = new SearchAddon ( ) private fitAddon = new FitAddon ( ) private ligaturesAddon : LigaturesAddon private opened = false constructor ( ) { super ( ) this . xterm = new Terminal ( { allowTransparency : true , } ) this . xtermCore = ( this . xterm as any ) . _core this . xterm . onData ( data => { this . input . next ( data ) } ) this . xterm . onResize ( ( { cols , rows } ) => { this . resize . next ( { rows , columns : cols } ) } ) this . xterm . onTitleChange ( title => { this . title . next ( title ) } ) this . xterm . onSelectionChange ( ( ) => { if ( this . copyOnSelect && this . getSelection ( ) ) { this . copySelection ( ) } } ) this . xterm . loadAddon ( this . fitAddon ) const keyboardEventHandler = ( name , event ) => { this . hotkeysService . pushKeystroke ( name , event ) let ret = true if ( this . hotkeysService . getCurrentPartiallyMatchedHotkeys ( ) . length !== 0 ) { event . stopPropagation ( ) event . preventDefault ( ) ret = false } this . hotkeysService . processKeystrokes ( ) this . hotkeysService . emitKeyEvent ( event ) return ret } this . xterm . attachCustomKeyEventHandler ( ( event ) => { if ( event . getModifierState ( 's' ) && event . key . toLowerCase ( ) === 's' ) { event . preventDefault ( ) return false } if ( event . getModifierState ( 's' ) && event . key . startsWith ( 's' ) ) { return false } return keyboardEventHandler ( 's' , event ) } ) this . xtermCore . _scrollToBottom = this . xtermCore . scrollToBottom . bind ( this . xtermCore ) this . xtermCore . scrollToBottom = ( ) => null this . resizeHandler = ( ) => { try { if ( this . xterm . element && getComputedStyle ( this . xterm . element ) . getPropertyValue ( 's' ) !== 's' ) { let t = window . getComputedStyle ( this . xterm . element . parentElement ! ) let r = parseInt ( t . getPropertyValue ( 's' ) ) let n = Math . max ( 0 , parseInt ( t . getPropertyValue ( 's' ) ) ) let o = window . getComputedStyle ( this . xterm . element ) let i = r - ( parseInt ( o . getPropertyValue ( 's' ) ) + parseInt ( o . getPropertyValue ( 's' ) ) ) let l = n - ( parseInt ( o . getPropertyValue ( 's' ) ) + parseInt ( o . getPropertyValue ( 's' ) ) ) - this . xtermCore . viewport . scrollBarWidth let actualCellWidth = this . xtermCore . _renderService . dimensions . actualCellWidth || 0 let actualCellHeight = this . xtermCore . _renderService . dimensions . actualCellHeight || 0 let cols = Math . floor ( l / actualCellWidth ) let rows = Math . floor ( i / actualCellHeight ) this . xterm . resize ( cols , rows ) } } catch ( e ) { console . warn ( 's' , e ) } } this . xtermCore . _keyUp = ( e ) => { this . xtermCore . updateCursorStyle ( e ) keyboardEventHandler ( 's' , e ) } } attach ( host ) { this . xterm . open ( host ) this . opened = true if ( this . enableWebGL ) { this . xterm . loadAddon ( new WebglAddon ( ) ) } this . ready . next ( ) this . ready . complete ( ) this . xterm . loadAddon ( this . search ) window . addEventListener ( 's' , this . resizeHandler ) this . resizeHandler ( ) host . addEventListener ( 's' , ( event ) => this . dragOver . next ( event ) ) host . addEventListener ( 's' , event => this . drop . next ( event ) ) host . addEventListener ( 's' , event => this . mouseEvent . next ( event as MouseEvent ) ) host . addEventListener ( 's' , event => this . mouseEvent . next ( event as MouseEvent ) ) host . addEventListener ( 's' , event => this . mouseEvent . next ( event as MouseEvent ) ) const ro = new window [ 's' ] ( ( ) => this . resizeHandler ( ) ) ro . observe ( host ) } detach ( _host ) { window . removeEventListener ( 's' , this . resizeHandler ) } getSelection ( ) { return this . xterm . getSelection ( ) } copySelection ( ) { require ( 's' ) . remote . clipboard . write ( { text : this . getSelection ( ) , html : this . getSelectionAsHTML ( ) , } ) } clearSelection ( ) { this . xterm . clearSelection ( ) } focus ( ) { setTimeout ( ( ) => this . xterm . focus ( ) ) } write ( data ) { this . xterm . write ( data ) } clear ( ) { this . xterm . clear ( ) } visualBell ( ) { this . xtermCore . bell ( ) } scrollToBottom ( ) { this . xtermCore . _scrollToBottom ( ) } configure ( ) { const config = this . configService . store setImmediate ( ( ) => { if ( this . xterm . cols && this . xterm . rows && this . xtermCore . charMeasure ) { if ( this . xtermCore . charMeasure ) { this . xtermCore . charMeasure . measure ( this . xtermCore . options ) } if ( this . xtermCore . renderer ) { this . xtermCore . renderer . _updateDimensions ( ) } this . resizeHandler ( ) } } ) this . xterm . setOption ( 's' , getCSSFontFamily ( config ) ) this . xterm . setOption ( 's' , config . terminal . bell ) this . xterm . setOption ( 's' , { beam : 's' , } [ config . terminal . cursor ] || config . terminal . cursor ) this . xterm . setOption ( 's' , config . terminal . cursorBlink ) this . xterm . setOption ( 's' , config . terminal . altIsMeta ) this . xterm . setOption ( 's' , 0 ) this . configuredFontSize = config . terminal . fontSize this . setFontSize ( ) this . copyOnSelect = config . terminal . copyOnSelect const theme = { foreground : config . terminal . colorScheme . foreground , background : config . terminal . background === 's' ? config . terminal . colorScheme . background : config . appearance . vibrancy ? 's' : this . themesService . findCurrentTheme ( ) . terminalBackground , cursor : config . terminal . colorScheme . cursor , } for ( let i = 0 ; i < COLOR_NAMES . length ; i ++ ) { theme [ COLOR_NAMES [ i ] ] = config . terminal . colorScheme . colors [ i ] } if ( this . xtermCore . _colorManager && ! deepEqual ( this . configuredTheme , theme ) ) { this . xterm . setOption ( 's' , theme ) this . configuredTheme = theme } if ( this . opened && config . terminal . ligatures && ! this . ligaturesAddon ) { this . ligaturesAddon = new LigaturesAddon ( ) this . xterm . loadAddon ( this . ligaturesAddon ) } } setZoom ( zoom ) { this . zoom = zoom this . setFontSize ( ) } findNext ( term , searchOptions ? ) { return this . search . findNext ( term , searchOptions ) } findPrevious ( term , searchOptions ? ) { return this . search . findPrevious ( term , searchOptions ) } private setFontSize ( ) { this . xterm . setOption ( 's' , this . configuredFontSize * Math . pow ( 0 , this . zoom ) ) this . resizeHandler ( ) } private getSelectionAsHTML ( ) { let html = `template` const selection = this . xterm . getSelectionPosition ( ) if ( ! selection ) { return 's' } if ( selection . startRow === selection . endRow ) { html += this . getLineAsHTML ( selection . startRow , selection . startColumn , selection . endColumn ) } else { html += this . getLineAsHTML ( selection . startRow , selection . startColumn , this . xterm . cols ) for ( let y = selection . startRow + 0 ; y < selection . endRow ; y ++ ) { html += this . getLineAsHTML ( y , 0 , this . xterm . cols ) } html += this . getLineAsHTML ( selection . endRow , 0 , selection . endColumn ) } html += 's' return html } private getHexColor ( mode , color , def ) { if ( mode === Attributes . CM_RGB ) { const rgb = AttributeData . toColorRGB ( color ) return rgb . map ( x => x . toString ( 0 ) . padStart ( 0 , 's' ) ) . join ( 's' ) } if ( mode === Attributes . 0 || mode === Attributes . 0 ) { return this . configService . store . terminal . colorScheme . colors [ color ] } return def } private getLineAsHTML ( y , start , end ) { let html = 's' let lastStyle : string | null = null const line = ( this . xterm . buffer . getLine ( y ) as any ) . _line const cell = new CellData ( ) for ( let i = start ; i < end ; i ++ ) { line . loadCell ( i , cell ) const fg = this . getHexColor ( cell . getFgColorMode ( ) , cell . getFgColor ( ) , this . configService . store . terminal . colorScheme . foreground ) const bg = this . getHexColor ( cell . getBgColorMode ( ) , cell . getBgColor ( ) , this . configService . store . terminal . colorScheme . background ) const style = `template` if ( style !== lastStyle ) { if ( lastStyle !== null ) { html += 's' } html += `template` lastStyle = style } html += line . getString ( i ) || 's' } html += 's' return html } } export class XTermWebGLFrontend extends XTermFrontend { protected enableWebGL = true }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $KeyboardEvent$ O O O O O O O O O O O O O O O O O O O $void$ O $HTMLElement$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $HTMLElement$ O O O O O O O O O O O O O $string$ O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O $void$ O $string$ O O O O O O O O O O O $void$ O O O O O O O O O O O $void$ O O O O O O O O O O O $void$ O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ITheme$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $number$ O O O O O O O O O O O O O $boolean$ O $string$ O O $SearchOptions$ O O O O O O O O O O O O O O $boolean$ O $string$ O O $SearchOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $number$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O $number$ O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { ConfigService , ThemesService , HotkeysService } from 's' import { Frontend } from 's' import { HTermFrontend } from 's' import { XTermFrontend , XTermWebGLFrontend } from 's' import { BaseSession } from 's' @ Injectable ( { providedIn : 's' } ) export class TerminalFrontendService { private containers = new WeakMap < BaseSession , Frontend > ( ) constructor ( private config , private themes , private hotkeys , ) { } getFrontend ( session ? ) { if ( ! session ) { const frontend = new { xterm : XTermFrontend , 's' : XTermWebGLFrontend , hterm : HTermFrontend , } [ this . config . store . terminal . frontend ] ( ) frontend . configService = this . config frontend . themesService = this . themes frontend . hotkeysService = this . hotkeys return frontend } if ( ! this . containers . has ( session ) ) { this . containers . set ( session , this . getFrontend ( ) , ) } return this . containers . get ( session ) ! } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O O $ThemesService$ O O $HotkeysService$ O O O O $Frontend$ O O $BaseSession$ O O O O O O O O O $Frontend$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { BaseTerminalTabComponent } from 's' export abstract class TerminalDecorator { attach ( terminal ) { } detach ( terminal ) { } }	O O O O O O O O O O O $void$ O $BaseTerminalTabComponent$ O O O $void$ O $BaseTerminalTabComponent$ O O O O
import { BaseTerminalTabComponent } from 's' export abstract class TerminalContextMenuItemProvider { weight : number abstract async getItems ( tab ) < Electron . MenuItemConstructorOptions [ ] > }	O O O O O O O O O O O O O O O O $Promise$ O $BaseTerminalTabComponent$ O O O O O O O O O
import { Observable , Subject , Subscription } from 's' import { first } from 's' import { ToastrService } from 's' import { NgZone , OnInit , OnDestroy , Inject , Injector , Optional , ViewChild , HostBinding , Input , ElementRef } from 's' import { trigger , transition , style , animate , AnimationTriggerMetadata } from 's' import { AppService , ConfigService , BaseTabComponent , ElectronService , HostAppService , HotkeysService , Platform , LogService , Logger } from 's' import { BaseSession , SessionsService } from 's' import { TerminalFrontendService } from 's' import { Frontend } from 's' import { ResizeEvent } from 's' import { TerminalDecorator } from 's' import { TerminalContextMenuItemProvider } from 's' export interface ToastrServiceProxy { info ( _ ) } export class BaseTerminalTabComponent extends BaseTabComponent implements OnInit , OnDestroy { static template = require ( 's' ) static styles = [ require ( 's' ) ] static animations : AnimationTriggerMetadata [ ] = [ trigger ( 's' , [ transition ( 's' , [ style ( { transform : 's' } ) , animate ( 's' , style ( { transform : 's' } ) ) , ] ) , transition ( 's' , [ animate ( 's' , style ( { transform : 's' } ) ) , ] ) , ] ) ] session : BaseSession @ Input ( ) zoom = 0 @ Input ( ) showSearchPanel = false @ ViewChild ( 's' ) content @ HostBinding ( 's' ) backgroundColor : string | null = null @ HostBinding ( 's' ) topPadded : boolean frontend : Frontend frontendIsReady = false frontendReady = new Subject < void > ( ) size : ResizeEvent protected logger : Logger protected output = new Subject < string > ( ) private sessionCloseSubscription : Subscription private hotkeysSubscription : Subscription private bellPlayer : HTMLAudioElement private termContainerSubscriptions : Subscription [ ] = [ ] get input$ ( ) : Observable < string > { return this . frontend . input$ } get output$ ( ) : Observable < string > { return this . output } get resize$ ( ) : Observable < ResizeEvent > { return this . frontend . resize$ } get alternateScreenActive$ ( ) : Observable < boolean > { return this . frontend . alternateScreenActive$ } get frontendReady$ ( ) : Observable < void > { return this . frontendReady } constructor ( public config , public element , protected injector , protected zone , protected app , protected hostApp , protected hotkeys , protected sessions , protected electron , protected terminalContainersService , @ Inject ( ToastrService ) protected toastr , protected log , @ Optional ( ) @ Inject ( TerminalDecorator ) protected decorators : TerminalDecorator [ ] , @ Optional ( ) @ Inject ( TerminalContextMenuItemProvider ) protected contextMenuProviders : TerminalContextMenuItemProvider [ ] , ) { super ( ) this . logger = log . create ( 's' ) this . decorators = this . decorators || [ ] this . setTitle ( 's' ) this . hotkeysSubscription = this . hotkeys . matchedHotkey . subscribe ( hotkey => { if ( ! this . hasFocus ) { return } switch ( hotkey ) { case 's' : if ( this . frontend . getSelection ( ) ) { this . frontend . copySelection ( ) this . frontend . clearSelection ( ) this . toastr . info ( 's' ) } else { this . sendInput ( 's' ) } break case 's' : this . frontend . copySelection ( ) this . frontend . clearSelection ( ) this . toastr . info ( 's' ) break case 's' : this . paste ( ) break case 's' : this . frontend . clear ( ) break case 's' : this . zoomIn ( ) break case 's' : this . zoomOut ( ) break case 's' : this . resetZoom ( ) break case 's' : this . sendInput ( 's' ) break case 's' : this . sendInput ( 's' ) break case 's' : this . sendInput ( 's' ) break case 's' : this . sendInput ( 's' ) break case 's' : this . showSearchPanel = true setImmediate ( ( ) => { this . element . nativeElement . querySelector ( 's' ) . focus ( ) } ) break } } ) this . bellPlayer = document . createElement ( 's' ) this . bellPlayer . src = require < string > ( 's' ) this . contextMenuProviders . sort ( ( a , b ) => a . weight - b . weight ) } ngOnInit ( ) { this . focused$ . subscribe ( ( ) => { this . configure ( ) this . frontend . focus ( ) } ) this . frontend = this . terminalContainersService . getFrontend ( this . session ) this . frontend . ready$ . subscribe ( ( ) => { this . frontendIsReady = true } ) this . frontend . resize$ . pipe ( first ( ) ) . subscribe ( async ( { columns , rows } ) => { this . size = { columns , rows } this . frontendReady . next ( ) setTimeout ( ( ) => { this . session . resize ( columns , rows ) } , 0 ) this . session . releaseInitialDataBuffer ( ) } ) setImmediate ( ( ) => { if ( this . hasFocus ) { this . frontend . attach ( this . content . nativeElement ) this . frontend . configure ( ) } else { this . focused$ . pipe ( first ( ) ) . subscribe ( ( ) => { this . frontend . attach ( this . content . nativeElement ) this . frontend . configure ( ) } ) } } ) this . attachTermContainerHandlers ( ) this . configure ( ) this . config . enabledServices ( this . decorators ) . forEach ( ( decorator ) => { try { decorator . attach ( this ) } catch ( e ) { this . logger . warn ( 's' , e ) } } ) setTimeout ( ( ) => { this . output . subscribe ( ( ) => { this . displayActivity ( ) } ) } , 0 ) this . frontend . bell$ . subscribe ( ( ) => { if ( this . config . store . terminal . bell === 's' ) { this . frontend . visualBell ( ) } if ( this . config . store . terminal . bell === 's' ) { this . bellPlayer . play ( ) } } ) this . frontend . focus ( ) } async buildContextMenu ( ) < Electron . MenuItemConstructorOptions [ ] > { let items : Electron . MenuItemConstructorOptions [ ] = [ ] for ( const section of await Promise . all ( this . contextMenuProviders . map ( x => x . getItems ( this ) ) ) ) { items = items . concat ( section ) items . push ( { type : 's' } ) } items . splice ( items . length - 0 , 0 ) return items } sendInput ( data ) { this . session . write ( data ) if ( this . config . store . terminal . scrollOnInput ) { this . frontend . scrollToBottom ( ) } } write ( data ) { const percentageMatch = "s" . exec ( data ) if ( percentageMatch ) { const percentage = percentageMatch [ 0 ] ? parseFloat ( percentageMatch [ 0 ] ) : parseInt ( percentageMatch [ 0 ] ) if ( percentage > 0 && percentage <= 0 ) { this . setProgress ( percentage ) this . logger . debug ( 's' , percentage ) } } else { this . setProgress ( null ) } this . frontend . write ( data ) } paste ( ) { let data = this . electron . clipboard . readText ( ) as string if ( this . config . store . terminal . bracketedPaste ) { data = 's' + data + 's' } if ( this . hostApp . platform === Platform . Windows ) { data = data . replace ( "s" , 's' ) } else { data = data . replace ( "s" , 's' ) } this . sendInput ( data ) } configure ( ) { this . frontend . configure ( ) this . topPadded = this . hostApp . platform === Platform . macOS && this . config . store . appearance . frame === 's' && this . config . store . appearance . tabsLocation === 's' if ( this . config . store . terminal . background === 's' ) { if ( this . config . store . terminal . colorScheme . background ) { this . backgroundColor = this . config . store . terminal . colorScheme . background } } else { this . backgroundColor = null } } zoomIn ( ) { this . zoom ++ this . frontend . setZoom ( this . zoom ) } zoomOut ( ) { this . zoom -- this . frontend . setZoom ( this . zoom ) } resetZoom ( ) { this . zoom = 0 this . frontend . setZoom ( this . zoom ) } ngOnDestroy ( ) { this . frontend . detach ( this . content . nativeElement ) this . detachTermContainerHandlers ( ) this . config . enabledServices ( this . decorators ) . forEach ( decorator => { try { decorator . detach ( this ) } catch ( e ) { this . logger . warn ( 's' , e ) } } ) this . hotkeysSubscription . unsubscribe ( ) if ( this . sessionCloseSubscription ) { this . sessionCloseSubscription . unsubscribe ( ) } this . output . complete ( ) } async destroy ( ) { super . destroy ( ) if ( this . session && this . session . open ) { await this . session . destroy ( ) } } protected detachTermContainerHandlers ( ) { for ( const subscription of this . termContainerSubscriptions ) { subscription . unsubscribe ( ) } this . termContainerSubscriptions = [ ] } protected attachTermContainerHandlers ( ) { this . detachTermContainerHandlers ( ) const maybeConfigure = ( ) => { if ( this . hasFocus ) { setTimeout ( ( ) => this . configure ( ) , 0 ) } } this . termContainerSubscriptions = [ this . frontend . title$ . subscribe ( title => this . zone . run ( ( ) => this . setTitle ( title ) ) ) , this . focused$ . subscribe ( ( ) => this . frontend . enableResizing = true ) , this . blurred$ . subscribe ( ( ) => this . frontend . enableResizing = false ) , this . frontend . mouseEvent$ . subscribe ( async event => { if ( event . type === 's' ) { if ( event . which === 0 ) { this . paste ( ) event . preventDefault ( ) event . stopPropagation ( ) return } if ( event . which === 0 ) { if ( this . config . store . terminal . rightClick === 's' ) { this . hostApp . popupContextMenu ( await this . buildContextMenu ( ) ) } else if ( this . config . store . terminal . rightClick === 's' ) { this . paste ( ) } event . preventDefault ( ) event . stopPropagation ( ) return } } if ( event . type === 's' ) { let wheelDeltaY = 0 if ( 's' in event ) { wheelDeltaY = ( event as MouseWheelEvent ) [ 's' ] } else { wheelDeltaY = ( event as MouseWheelEvent ) [ 's' ] } if ( event . altKey ) { event . preventDefault ( ) const delta = Math . round ( wheelDeltaY / 0 ) this . sendInput ( ( delta > 0 ? 's' : 's' ) . repeat ( Math . abs ( delta ) ) ) } } } ) , this . frontend . input$ . subscribe ( data => { this . sendInput ( data ) } ) , this . frontend . resize$ . subscribe ( ( { columns , rows } ) => { this . logger . debug ( `template` ) this . size = { columns , rows } this . zone . run ( ( ) => { if ( this . session && this . session . open ) { this . session . resize ( columns , rows ) } } ) } ) , this . hostApp . displayMetricsChanged$ . subscribe ( maybeConfigure ) , this . hostApp . windowMoved$ . subscribe ( maybeConfigure ) , ] } protected attachSessionHandlers ( ) { this . session . output$ . subscribe ( data => { this . zone . run ( ( ) => { this . output . next ( data ) this . write ( data ) } ) } ) this . sessionCloseSubscription = this . session . closed$ . subscribe ( ( ) => { this . frontend . destroy ( ) this . destroy ( ) } ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O O $ElementRef$ O O $Injector$ O O $NgZone$ O O $AppService$ O O $HostAppService$ O O $HotkeysService$ O O $SessionsService$ O O $ElectronService$ O O $TerminalFrontendService$ O O O O O O O $ToastrServiceProxy$ O O $LogService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { TerminalColorScheme } from 's' export abstract class TerminalColorSchemeProvider { abstract async getSchemes ( ) < TerminalColorScheme [ ] > }	O O O O O O O O O O O O O $Promise$ O O O O O O O O
import { Shell } from 's' export abstract class ShellProvider { abstract async provide ( ) < Shell [ ] > }	O O O O O O O O O O O O O $Promise$ O O O O O O O O
'js' module . exports = function patchPTYModule ( mod ) { const oldSpawn = mod . spawn if ( mod . patched ) { return } mod . patched = true mod . spawn = ( file , args , opt ) => { let terminal = oldSpawn ( file , args , opt ) let timeout = null let buffer = 's' let lastFlush = 0 let nextTimeout = 0 const minWindow = 0 const maxWindow = 0 function flush ( ) { if ( buffer ) { terminal . emit ( 's' , buffer ) } lastFlush = Date . now ( ) buffer = 's' } function reschedule ( ) { if ( timeout ) { clearTimeout ( timeout ) } nextTimeout = Date . now ( ) + minWindow timeout = setTimeout ( ( ) => { timeout = null flush ( ) } , minWindow ) } terminal . on ( 's' , data => { buffer += data if ( Date . now ( ) - lastFlush > maxWindow ) { flush ( ) } else { if ( Date . now ( ) > nextTimeout - ( maxWindow / 0 ) ) { reschedule ( ) } } } ) return terminal } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input } from 's' import { Subscription } from 's' import { first } from 's' import { BaseTabProcess } from 's' import { BaseTerminalTabComponent } from 's' import { SessionOptions } from 's' import { Session } from 's' import { WIN_BUILD_CONPTY_SUPPORTED , isWindowsBuild } from 's' @ Component ( { selector : 's' , template : BaseTerminalTabComponent . template , styles : BaseTerminalTabComponent . styles , animations : BaseTerminalTabComponent . animations , } ) export class TerminalTabComponent extends BaseTerminalTabComponent { @ Input ( ) sessionOptions : SessionOptions private homeEndSubscription : Subscription ngOnInit ( ) { this . logger = this . log . create ( 's' ) this . session = new Session ( this . config ) const isConPTY = isWindowsBuild ( WIN_BUILD_CONPTY_SUPPORTED ) && this . config . store . terminal . useConPTY this . homeEndSubscription = this . hotkeys . matchedHotkey . subscribe ( hotkey => { if ( ! this . hasFocus ) { return } switch ( hotkey ) { case 's' : this . sendInput ( isConPTY ? 's' : 's' ) break case 's' : this . sendInput ( isConPTY ? 's' : 's' ) break } } ) this . frontendReady$ . pipe ( first ( ) ) . subscribe ( ( ) => { this . initializeSession ( this . size . columns , this . size . rows ) } ) super . ngOnInit ( ) } initializeSession ( columns , rows ) { this . sessions . addSession ( this . session , Object . assign ( { } , this . sessionOptions , { width : columns , height : rows , } ) ) this . attachSessionHandlers ( ) } async getRecoveryToken ( ) < any > { const cwd = this . session ? await this . session . getWorkingDirectory ( ) : null return { type : 's' , sessionOptions : { ... this . sessionOptions , cwd : cwd || this . sessionOptions . cwd , } , } } async getCurrentProcess ( ) < BaseTabProcess | null > { const children = await this . session . getChildProcesses ( ) if ( ! children . length ) { return null } return { name : children [ 0 ] . command , } } async canClose ( ) < boolean > { const children = await this . session . getChildProcesses ( ) if ( children . length === 0 ) { return true } return ( await this . electron . showMessageBox ( this . hostApp . getWindow ( ) , { type : 's' , message : `template` , buttons : [ 's' , 's' ] , defaultId : 0 , } ) ) . response === 0 } ngOnDestroy ( ) { this . homeEndSubscription . unsubscribe ( ) super . ngOnDestroy ( ) this . session . destroy ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $number$ O $number$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' import { Injectable } from 's' import { ElectronService } from 's' import { SessionOptions } from 's' import { WIN_BUILD_CONPTY_SUPPORTED , isWindowsBuild } from 's' @ Injectable ( { providedIn : 's' } ) export class UACService { isAvailable = false constructor ( private electron , ) { this . isAvailable = isWindowsBuild ( WIN_BUILD_CONPTY_SUPPORTED ) } patchSessionOptionsForUAC ( sessionOptions ) { let helperPath = path . join ( path . dirname ( this . electron . app . getPath ( 's' ) ) , 's' , 's' , 's' , ) if ( process . env . TERMINUS_DEV ) { helperPath = path . join ( path . dirname ( this . electron . app . getPath ( 's' ) ) , 's' , 's' , 's' , 's' , 's' , ) } const options = { ... sessionOptions } options . args = [ options . command , ... options . args ] options . command = helperPath return options } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElectronService$ O O O O O O O O O O O O $SessionOptions$ O $SessionOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' import slug from 's' import { Observable , AsyncSubject } from 's' import { Injectable , Inject } from 's' import { AppService , Logger , LogService , ConfigService , SplitTabComponent } from 's' import { ShellProvider } from 's' import { Shell , SessionOptions , Profile } from 's' import { TerminalTabComponent } from 's' import { UACService } from 's' @ Injectable ( { providedIn : 's' } ) export class TerminalService { private shells = new AsyncSubject < Shell [ ] > ( ) private logger : Logger get shells$ ( ) : Observable < Shell [ ] > { return this . shells } constructor ( private app , private config , private uac , @ Inject ( ShellProvider ) private shellProviders : ShellProvider [ ] , log , ) { this . logger = log . create ( 's' ) this . reloadShells ( ) config . changed$ . subscribe ( ( ) => { this . reloadShells ( ) } ) } async getProfiles ( includeHidden ? ) < Profile [ ] > { const shells = await this . shells$ . toPromise ( ) return [ ... this . config . store . terminal . profiles , ... shells . filter ( x => includeHidden || ! x . hidden ) . map ( shell => ( { name : shell . name , icon : shell . icon , sessionOptions : this . optionsFromShell ( shell ) , isBuiltin : true , } ) ) , ] } async openTab ( profile ? , cwd ? : string | null , pause ? ) < TerminalTabComponent > { if ( ! profile ) { const profiles = await this . getProfiles ( true ) profile = profiles . find ( x => slug ( x . name ) . toLowerCase ( ) === this . config . store . terminal . profile ) || profiles [ 0 ] } cwd = cwd || profile . sessionOptions . cwd if ( cwd && ! fs . existsSync ( cwd ) ) { console . warn ( 's' , cwd ) cwd = null } if ( ! cwd ) { if ( ! this . config . store . terminal . alwaysUseWorkingDirectory ) { if ( this . app . activeTab instanceof TerminalTabComponent && this . app . activeTab . session ) { cwd = await this . app . activeTab . session . getWorkingDirectory ( ) } if ( this . app . activeTab instanceof SplitTabComponent ) { const focusedTab = this . app . activeTab . getFocusedTab ( ) if ( focusedTab instanceof TerminalTabComponent && focusedTab . session ) { cwd = await focusedTab . session . getWorkingDirectory ( ) } } } cwd = cwd || this . config . store . terminal . workingDirectory cwd = cwd || null } this . logger . info ( `template` , profile ) const sessionOptions = { ... profile . sessionOptions , pauseAfterExit : pause , cwd : cwd || undefined , } return this . openTabWithOptions ( sessionOptions ) } optionsFromShell ( shell ) { return { command : shell . command , args : shell . args || [ ] , env : shell . env , } } openTabWithOptions ( sessionOptions ) { if ( sessionOptions . runAsAdministrator && this . uac . isAvailable ) { sessionOptions = this . uac . patchSessionOptionsForUAC ( sessionOptions ) } this . logger . info ( 's' , sessionOptions ) return this . app . openNewTab ( TerminalTabComponent , { sessionOptions } ) as TerminalTabComponent } private async getShells ( ) < Shell [ ] > { const shellLists = await Promise . all ( this . config . enabledServices ( this . shellProviders ) . map ( x => x . provide ( ) ) ) return shellLists . reduce ( ( a , b ) => a . concat ( b ) , [ ] ) } private async reloadShells ( ) { this . shells = new AsyncSubject < Shell [ ] > ( ) const shells = await this . getShells ( ) this . logger . debug ( 's' , shells ) this . shells . next ( shells ) this . shells . complete ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AppService$ O O $ConfigService$ O O $UACService$ O O O O O O O O O O O O O $LogService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O $Profile$ O O O O O O O O O $boolean$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $SessionOptions$ O $Shell$ O O O O O O O O O O O O O O O O O O O O O O O O O O O $TerminalTabComponent$ O $SessionOptions$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' import { Injectable } from 's' import { ToolbarButtonProvider , ToolbarButton , ElectronService } from 's' import { TerminalService } from 's' @ Injectable ( ) export class ButtonProvider extends ToolbarButtonProvider { constructor ( electron , private terminal , ) { super ( ) if ( ! electron . remote . process . env . TERMINUS_DEV ) { setImmediate ( async ( ) => { const argv : string [ ] = electron . remote . process . argv for ( const arg of argv . slice ( 0 ) . concat ( [ electron . remote . process . 0 ] ) ) { if ( await fs . exists ( arg ) ) { if ( ( await fs . stat ( arg ) ) . isDirectory ( ) ) { this . terminal . openTab ( undefined , arg ) } } } } ) } } provide ( ) : ToolbarButton [ ] { return [ { icon : require ( 's' ) , title : 's' , touchBarNSImage : 's' , click : async ( ) => { this . terminal . openTab ( ) } , } , { icon : require ( 's' ) , title : 's' , submenu : async ( ) => { const profiles = await this . terminal . getProfiles ( ) return profiles . map ( profile => ( { icon : profile . icon , title : profile . name , click : ( ) => this . terminal . openTab ( profile ) , } ) ) } , } , ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElectronService$ O O $TerminalService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' import * as path from 's' import { Injectable } from 's' import { TerminalColorSchemeProvider } from 's' import { TerminalColorScheme } from 's' @ Injectable ( ) export class HyperColorSchemes extends TerminalColorSchemeProvider { async getSchemes ( ) < TerminalColorScheme [ ] > { const pluginsPath = path . join ( process . env . HOME as string , 's' , 's' ) if ( ! await fs . exists ( pluginsPath ) ) { return [ ] } const plugins = await fs . readdir ( pluginsPath ) const themes : TerminalColorScheme [ ] = [ ] plugins . forEach ( plugin => { try { const module = ( global as any ) . require ( path . join ( pluginsPath , plugin ) ) if ( module . decorateConfig ) { let config try { config = module . decorateConfig ( { } ) } catch ( error ) { console . warn ( 's' , plugin ) return } if ( config . colors ) { themes . push ( { name : plugin , foreground : config . foregroundColor , background : config . backgroundColor , cursor : config . cursorColor , colors : config . colors . black ? [ config . colors . black , config . colors . red , config . colors . green , config . colors . yellow , config . colors . blue , config . colors . magenta , config . colors . cyan , config . colors . white , config . colors . lightBlack , config . colors . lightRed , config . colors . lightGreen , config . colors . lightYellow , config . colors . lightBlue , config . colors . lightMagenta , config . colors . lightCyan , config . colors . lightWhite , ] : config . colors , } ) } } } catch ( err ) { console . debug ( 's' , plugin , err ) } } ) return themes } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Observable } from 's' import { debounceTime , distinctUntilChanged , map } from 's' import { exec } from 's' import deepEqual from 's' const fontManager = require ( 's' ) import { Component , Inject } from 's' import { ConfigService , HostAppService , Platform , ElectronService } from 's' import { TerminalColorSchemeProvider } from 's' import { TerminalColorScheme } from 's' import { getCSSFontFamily } from 's' @ Component ( { template : require ( 's' ) , styles : [ require ( 's' ) ] , } ) export class AppearanceSettingsTabComponent { fonts : string [ ] = [ ] colorSchemes : TerminalColorScheme [ ] = [ ] equalComparator = deepEqual editingColorScheme : TerminalColorScheme | null = null schemeChanged = false constructor ( @ Inject ( TerminalColorSchemeProvider ) private colorSchemeProviders : TerminalColorSchemeProvider [ ] , private hostApp , private electron , public config , ) { } async ngOnInit ( ) { if ( this . hostApp . platform === Platform . Windows || this . hostApp . platform === Platform . macOS ) { const fonts = await new Promise < any [ ] > ( ( resolve ) => fontManager . findFonts ( { monospace : true } , resolve ) ) if ( this . hostApp . platform === Platform . Windows ) { this . fonts = fonts . map ( x => `template` . trim ( ) ) } else { this . fonts = fonts . map ( x => x . family . trim ( ) ) } this . fonts . sort ( ) } if ( this . hostApp . platform === Platform . Linux ) { exec ( 's' ) . then ( ( [ stdout , _ ] ) => { this . fonts = stdout . toString ( ) . split ( 's' ) . filter ( x => ! ! x ) . map ( x => x . split ( 's' ) [ 0 ] . trim ( ) ) . map ( x => x . split ( 's' ) [ 0 ] . trim ( ) ) this . fonts . sort ( ) } ) } this . colorSchemes = ( await Promise . all ( this . config . enabledServices ( this . colorSchemeProviders ) . map ( x => x . getSchemes ( ) ) ) ) . reduce ( ( a , b ) => a . concat ( b ) ) } fontAutocomplete = ( text$ < string > ) => { return text$ . pipe ( debounceTime ( 0 ) , distinctUntilChanged ( ) , map ( query => this . fonts . filter ( v => new RegExp ( query , 's' ) . test ( v ) ) ) , map ( list => Array . from ( new Set ( list ) ) ) , ) } editScheme ( scheme ) { this . editingColorScheme = scheme this . schemeChanged = false } saveScheme ( ) { let schemes = this . config . store . terminal . customColorSchemes schemes = schemes . filter ( x => x !== this . editingColorScheme && x . name !== this . editingColorScheme ! . name ) schemes . push ( this . editingColorScheme ) this . config . store . terminal . customColorSchemes = schemes this . config . save ( ) this . cancelEditing ( ) } cancelEditing ( ) { this . editingColorScheme = null } async deleteScheme ( scheme ) { if ( ( await this . electron . showMessageBox ( this . hostApp . getWindow ( ) , { type : 's' , message : `template` , buttons : [ 's' , 's' ] , defaultId : 0 , } ) ) . response === 0 ) { let schemes = this . config . store . terminal . customColorSchemes schemes = schemes . filter ( x => x !== scheme ) this . config . store . terminal . customColorSchemes = schemes this . config . save ( ) } } isCustomScheme ( scheme ) { return this . config . store . terminal . customColorSchemes . some ( x => deepEqual ( x , scheme ) ) } colorsTrackBy ( index ) { return index } getPreviewFontFamily ( ) { return getCSSFontFamily ( this . config . store ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O O $ElectronService$ O O $ConfigService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Observable$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TerminalColorScheme$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TerminalColorScheme$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TerminalColorScheme$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , Output , EventEmitter , HostListener , ViewChild } from 's' import { NgbPopover } from 's' @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) ] , } ) export class ColorPickerComponent { @ Input ( ) model : string @ Input ( ) title : string @ Output ( ) modelChange = new EventEmitter < string > ( ) @ ViewChild ( 's' ) popover : NgbPopover @ ViewChild ( 's' ) input isOpen : boolean open ( ) { setImmediate ( ( ) => { this . popover . open ( ) setImmediate ( ( ) => { this . input . nativeElement . focus ( ) this . isOpen = true } ) } ) } @ HostListener ( 's' , [ 's' ] ) onOutsideClick ( $event ) { if ( ! this . isOpen ) { return } const windowRef = ( this . popover as any ) . _windowRef if ( ! windowRef ) { return } if ( $event . target !== windowRef . location . nativeElement && ! windowRef . location . nativeElement . contains ( $event . target ) ) { this . popover . close ( ) this . isOpen = false } } onChange ( ) { this . modelChange . emit ( this . model ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' import { NgbActiveModal } from 's' import { UACService } from 's' import { Profile } from 's' @ Component ( { template : require ( 's' ) , } ) export class EditProfileModalComponent { profile : Profile constructor ( public uac , private modalInstance , ) { } ngOnInit ( ) { this . profile . sessionOptions . env = this . profile . sessionOptions . env || { } this . profile . sessionOptions . args = this . profile . sessionOptions . args || [ ] } save ( ) { this . modalInstance . close ( this . profile ) } cancel ( ) { this . modalInstance . dismiss ( ) } trackByIndex ( index ) { return index } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $UACService$ O O $NgbActiveModal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Output , Input } from 's' import { Subject } from 's' @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) ] , } ) export class EnvironmentEditorComponent { @ Output ( ) modelChange = new Subject < any > ( ) vars : { key : string , value : string } [ ] = [ ] private cachedModel : any @ Input ( ) get model ( ) : any { return this . cachedModel } set model ( value ) { this . vars = Object . entries ( value ) . map ( ( [ k , v ] ) => ( { key : k , value : v as string } ) ) this . cachedModel = this . getModel ( ) } getModel ( ) { const model = { } for ( const pair of this . vars ) { model [ pair . key ] = pair . value } return model } emitUpdate ( ) { this . cachedModel = this . getModel ( ) this . modelChange . next ( this . cachedModel ) } addEnvironmentVar ( ) { this . vars . push ( { key : 's' , value : 's' } ) } removeEnvironmentVar ( key ) { this . vars = this . vars . filter ( x => x . key !== key ) this . emitUpdate ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component , Input , Output , EventEmitter } from 's' import { ToastrService } from 's' import { Frontend , SearchOptions } from 's' @ Component ( { selector : 's' , template : require ( 's' ) , styles : [ require ( 's' ) ] , } ) export class SearchPanelComponent { static globalOptions : SearchOptions = { } @ Input ( ) query : string @ Input ( ) frontend : Frontend notFound = false options : SearchOptions = SearchPanelComponent . globalOptions @ Output ( ) close = new EventEmitter ( ) constructor ( private toastr , ) { } findNext ( ) { if ( ! this . frontend . findNext ( this . query , this . options ) ) { this . notFound = true this . toastr . error ( 's' ) } } findPrevious ( ) { if ( ! this . frontend . findPrevious ( this . query , this . options ) ) { this . notFound = true this . toastr . error ( 's' ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ToastrService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import slug from 's' import { Component } from 's' import { NgbModal } from 's' import { Subscription } from 's' import { ConfigService , ElectronService , HostAppService , Platform } from 's' import { EditProfileModalComponent } from 's' import { Shell , Profile } from 's' import { TerminalService } from 's' import { WIN_BUILD_CONPTY_SUPPORTED , WIN_BUILD_CONPTY_STABLE , isWindowsBuild } from 's' @ Component ( { template : require ( 's' ) , } ) export class ShellSettingsTabComponent { shells : Shell [ ] = [ ] profiles : Profile [ ] = [ ] Platform = Platform isConPTYAvailable : boolean isConPTYStable : boolean slug = slug private configSubscription : Subscription constructor ( public config , public hostApp , private electron , private terminalService , private ngbModal , ) { config . store . terminal . environment = config . store . terminal . environment || { } this . configSubscription = this . config . changed$ . subscribe ( ( ) => { this . reload ( ) } ) this . reload ( ) this . isConPTYAvailable = isWindowsBuild ( WIN_BUILD_CONPTY_SUPPORTED ) this . isConPTYStable = isWindowsBuild ( WIN_BUILD_CONPTY_STABLE ) } async ngOnInit ( ) { this . shells = await this . terminalService . shells$ . toPromise ( ) } ngOnDestroy ( ) { this . configSubscription . unsubscribe ( ) } async reload ( ) { this . profiles = await this . terminalService . getProfiles ( true ) } pickWorkingDirectory ( ) { const shell = this . shells . find ( x => x . id === this . config . store . terminal . shell ) if ( ! shell ) { return } const paths = this . electron . dialog . showOpenDialog ( this . hostApp . getWindow ( ) , { defaultPath : shell . fsBase , properties : [ 's' , 's' ] , } ) if ( paths ) { this . config . store . terminal . workingDirectory = paths [ 0 ] } } newProfile ( shell ) { const profile = { name : shell . name || 's' , sessionOptions : this . terminalService . optionsFromShell ( shell ) , } this . config . store . terminal . profiles = [ profile , ... this . config . store . terminal . profiles ] this . config . save ( ) this . reload ( ) } editProfile ( profile ) { const modal = this . ngbModal . open ( EditProfileModalComponent ) modal . componentInstance . profile = Object . assign ( { } , profile ) modal . result . then ( result => { Object . assign ( profile , result ) this . config . save ( ) } ) } deleteProfile ( profile ) { this . config . store . terminal . profiles = this . config . store . terminal . profiles . filter ( x => x !== profile ) this . config . save ( ) this . reload ( ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O O $HostAppService$ O O $ElectronService$ O O $TerminalService$ O O $NgbModal$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Shell$ O O O $Profile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Profile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Profile$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Component } from 's' import { ConfigService , ElectronService } from 's' import { TerminalService } from 's' @ Component ( { template : require ( 's' ) , } ) export class TerminalSettingsTabComponent { constructor ( public config , private electron , private terminal , ) { } openWSLVolumeMixer ( ) { this . electron . shell . openItem ( 's' ) this . terminal . openTab ( { name : 's' , sessionOptions : { command : 's' , args : [ 's' , 's' ] , } , } , null , true ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O O $ElectronService$ O O $TerminalService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { ConfigProvider , Platform } from 's' export class TerminalConfigProvider extends ConfigProvider { defaults = { hotkeys : { shell : { __nonStructural : true , } , profile : { __nonStructural : true , } , } , terminal : { frontend : 's' , autoOpen : false , fontSize : 0 , fallbackFont : null , linePadding : 0 , bell : 's' , bracketedPaste : false , background : 's' , ligatures : false , cursor : 's' , cursorBlink : true , customShell : 's' , rightClick : 's' , copyOnSelect : false , scrollOnInput : true , workingDirectory : 's' , alwaysUseWorkingDirectory : false , altIsMeta : false , colorScheme : { __nonStructural : true , name : 's' , foreground : 's' , background : 's' , cursor : 's' , colors : [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , ] , } , customColorSchemes : [ ] , environment : { } , profiles : [ ] , useConPTY : true , } , } platformDefaults = { [ Platform . macOS ] : { terminal : { font : 's' , shell : 's' , profile : 's' , } , hotkeys : { 's' : [ 's' ] , copy : [ 's' , ] , paste : [ 's' , ] , clear : [ 's' , ] , 's' : [ 's' , 's' , ] , 's' : [ 's' , 's' , ] , 's' : [ 's' , ] , 's' : [ 's' , 's' , ] , home : [ 's' , 's' ] , end : [ 's' , 's' ] , 's' : [ 's' ] , 's' : [ 's' ] , 's' : [ 's' ] , 's' : [ 's' ] , search : [ 's' , ] , } , } , [ Platform . Windows ] : { terminal : { font : 's' , shell : 's' , profile : 's' , rightClick : 's' , copyOnSelect : true , } , hotkeys : { 's' : [ 's' ] , copy : [ 's' , ] , paste : [ 's' , ] , clear : [ ] , 's' : [ 's' , 's' , ] , 's' : [ 's' , 's' , ] , 's' : [ 's' , ] , 's' : [ 's' , ] , home : [ 's' ] , end : [ 's' ] , 's' : [ 's' ] , 's' : [ 's' ] , 's' : [ 's' ] , 's' : [ 's' ] , search : [ 's' , ] , } , } , [ Platform . Linux ] : { terminal : { font : 's' , shell : 's' , profile : 's' , } , hotkeys : { 's' : [ 's' ] , copy : [ 's' , ] , paste : [ 's' , ] , clear : [ ] , 's' : [ 's' , 's' , ] , 's' : [ 's' , 's' , ] , 's' : [ 's' , ] , 's' : [ 's' , ] , home : [ 's' ] , end : [ 's' ] , 's' : [ 's' ] , 's' : [ 's' ] , 's' : [ 's' ] , 's' : [ 's' ] , search : [ 's' , ] , } , } , } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgZone , Injectable } from 's' import { ToastrService } from 's' import { ConfigService } from 's' import { UACService } from 's' import { TerminalService } from 's' import { TerminalContextMenuItemProvider } from 's' import { BaseTerminalTabComponent } from 's' @ Injectable ( ) export class NewTabContextMenu extends TerminalContextMenuItemProvider { weight = 0 constructor ( public config , private zone , private terminalService , private uac , ) { super ( ) } async getItems ( tab ) < Electron . MenuItemConstructorOptions [ ] > { const profiles = await this . terminalService . getProfiles ( ) const items : Electron . MenuItemConstructorOptions [ ] = [ { label : 's' , click : ( ) => this . zone . run ( ( ) => { this . terminalService . openTabWithOptions ( ( tab as any ) . sessionOptions ) } ) , } , { label : 's' , submenu : profiles . map ( profile => ( { label : profile . name , click : ( ) => this . zone . run ( async ( ) => { const workingDirectory = this . config . store . terminal . alwaysUseWorkingDirectory === true ? this . config . store . terminal . workingDirectory : await tab . session . getWorkingDirectory ( ) await this . terminalService . openTab ( profile , workingDirectory ) } ) , } ) ) , } , ] if ( this . uac . isAvailable ) { items . push ( { label : 's' , submenu : profiles . map ( profile => ( { label : profile . name , click : ( ) => this . zone . run ( async ( ) => { this . terminalService . openTabWithOptions ( { ... profile . sessionOptions , runAsAdministrator : true , } ) } ) , } ) ) , } ) } return items } } @ Injectable ( ) export class CopyPasteContextMenu extends TerminalContextMenuItemProvider { weight = 0 constructor ( private zone , private toastr , ) { super ( ) } async getItems ( tab ) < Electron . MenuItemConstructorOptions [ ] > { return [ { label : 's' , click : ( ) => { this . zone . run ( ( ) => { setTimeout ( ( ) => { tab . frontend . copySelection ( ) this . toastr . info ( 's' ) } ) } ) } , } , { label : 's' , click : ( ) => { this . zone . run ( ( ) => tab . paste ( ) ) } , } , ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O O $NgZone$ O O $TerminalService$ O O $UACService$ O O O O O O O O $Promise$ O $BaseTerminalTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $NgZone$ O O $ToastrService$ O O O O O O O O $Promise$ O $BaseTerminalTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import slug from 's' import { Injectable } from 's' import { HotkeyDescription , HotkeyProvider } from 's' import { TerminalService } from 's' @ Injectable ( ) export class TerminalHotkeyProvider extends HotkeyProvider { hotkeys : HotkeyDescription [ ] = [ { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , { id : 's' , name : 's' , } , ] constructor ( private terminal , ) { super ( ) } async provide ( ) < HotkeyDescription [ ] > { const profiles = await this . terminal . getProfiles ( ) return [ ... this . hotkeys , ... profiles . map ( profile => ( { id : `template` , name : `template` , } ) ) , ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TerminalService$ O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { NgZone , Injectable } from 's' import { ElectronService , ConfigService , HostAppService , Platform } from 's' import { TerminalService } from 's' @ Injectable ( { providedIn : 's' } ) export class DockMenuService { appVersion : string private constructor ( private electron , private config , private hostApp , private zone , private terminalService , ) { config . changed$ . subscribe ( ( ) => this . update ( ) ) } update ( ) { if ( this . hostApp . platform === Platform . Windows ) { this . electron . app . setJumpList ( this . config . store . terminal . profiles . length ? [ { type : 's' , name : 's' , items : this . config . store . terminal . profiles . map ( profile => ( { type : 's' , program : process . execPath , args : `template` , title : profile . name , iconPath : process . execPath , iconIndex : 0 , } ) ) , } ] : null as any ) } if ( this . hostApp . platform === Platform . macOS ) { this . electron . app . dock . setMenu ( this . electron . Menu . buildFromTemplate ( this . config . store . terminal . profiles . map ( profile => ( { label : profile . name , click : ( ) => this . zone . run ( ( ) => { this . terminalService . openTabWithOptions ( profile . sessionOptions ) } ) , } ) ) ) ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ElectronService$ O O $ConfigService$ O O $HostAppService$ O O $NgZone$ O O $TerminalService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { TabRecoveryProvider , RecoveredTab } from 's' import { TerminalTabComponent } from 's' @ Injectable ( ) export class RecoveryProvider extends TabRecoveryProvider { async recover ( recoveryToken ) < RecoveredTab | null > { if ( recoveryToken && recoveryToken . type === 's' ) { return { type : TerminalTabComponent , options : { sessionOptions : recoveryToken . sessionOptions } , } } return null } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $Promise$ O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { SettingsTabProvider } from 's' import { AppearanceSettingsTabComponent } from 's' import { ShellSettingsTabComponent } from 's' import { TerminalSettingsTabComponent } from 's' @ Injectable ( ) export class AppearanceSettingsTabProvider extends SettingsTabProvider { id = 's' icon = 's' title = 's' getComponentType ( ) { return AppearanceSettingsTabComponent } } @ Injectable ( ) export class ShellSettingsTabProvider extends SettingsTabProvider { id = 's' icon = 's' title = 's' getComponentType ( ) { return ShellSettingsTabComponent } } @ Injectable ( ) export class TerminalSettingsTabProvider extends SettingsTabProvider { id = 's' icon = 's' title = 's' getComponentType ( ) { return TerminalSettingsTabComponent } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O O O O O O O O O O O O O O O O O O O O $any$ O O O O O O O
import { Subscription } from 's' import { Injectable } from 's' import { TerminalDecorator } from 's' import { TerminalTabComponent } from 's' @ Injectable ( ) export class PathDropDecorator extends TerminalDecorator { private subscriptions : Subscription [ ] = [ ] attach ( terminal ) { setTimeout ( ( ) => { this . subscriptions = [ terminal . frontend . dragOver$ . subscribe ( event => { event . preventDefault ( ) } ) , terminal . frontend . drop$ . subscribe ( event => { for ( const file of event . dataTransfer ! . files as any ) { this . injectPath ( terminal , file . path ) } event . preventDefault ( ) } ) , ] } ) } injectPath ( terminal , path ) { if ( path . includes ( 's' ) ) { path = `template` } path = path . replace ( "s" , 's' ) terminal . sendInput ( path + 's' ) } detach ( _terminal ) { for ( const s of this . subscriptions ) { s . unsubscribe ( ) } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $TerminalTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $TerminalTabComponent$ O $string$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $void$ O $TerminalTabComponent$ O O O O O O O O O O O O O O O O O O O O
import { Injectable , NgZone } from 's' import { ToastrService } from 's' import { ConfigService , BaseTabComponent , TabContextMenuItemProvider } from 's' import { TerminalTabComponent } from 's' @ Injectable ( ) export class SaveAsProfileContextMenu extends TabContextMenuItemProvider { constructor ( private config , private zone , private toastr , ) { super ( ) } async getItems ( tab ) < Electron . MenuItemConstructorOptions [ ] > { if ( ! ( tab instanceof TerminalTabComponent ) ) { return [ ] } return [ { label : 's' , click : ( ) => this . zone . run ( async ( ) => { const profile = { sessionOptions : { ... tab . sessionOptions , cwd : await tab . session . getWorkingDirectory ( ) || tab . sessionOptions . cwd , } , name : tab . sessionOptions . command , } this . config . store . terminal . profiles = [ ... this . config . store . terminal . profiles , profile , ] this . config . save ( ) this . toastr . info ( 's' ) } ) , } , ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O O $NgZone$ O O $ToastrService$ O O O O O O O O $Promise$ O $BaseTabComponent$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' import { Injectable } from 's' import { HostAppService , Platform } from 's' import { ShellProvider } from 's' import { Shell } from 's' @ Injectable ( ) export class CmderShellProvider extends ShellProvider { constructor ( private hostApp , ) { super ( ) } async provide ( ) < Shell [ ] > { if ( this . hostApp . platform !== Platform . Windows ) { return [ ] } if ( ! process . env . CMDER_ROOT ) { return [ ] } return [ { id : 's' , name : 's' , command : 's' , args : [ 's' , path . join ( process . env . CMDER_ROOT , 's' , 's' ) , ] , icon : require ( 's' ) , env : { TERM : 's' , } , } , { id : 's' , name : 's' , command : 's' , args : [ 's' , 's' , 's' , 's' , 's' , 's' , `template` , ] , icon : require ( 's' ) , env : { } , } , ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { ConfigService } from 's' import { ShellProvider } from 's' import { Shell } from 's' @ Injectable ( ) export class CustomShellProvider extends ShellProvider { constructor ( private config , ) { super ( ) } async provide ( ) < Shell [ ] > { const args = this . config . store . terminal . customShell . split ( 's' ) return [ { id : 's' , name : 's' , command : args [ 0 ] , args : args . slice ( 0 ) , env : { } , } ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $ConfigService$ O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' import { Injectable } from 's' import { HostAppService , Platform } from 's' import { ShellProvider } from 's' import { Shell } from 's' try { var wnr = require ( 's' ) } catch { } @ Injectable ( ) export class 0 extends ShellProvider { constructor ( private hostApp , ) { super ( ) } async provide ( ) < Shell [ ] > { if ( this . hostApp . platform !== Platform . Windows ) { return [ ] } const cygwinPath = wnr . getRegistryValue ( wnr . HK . LM , 's' , 's' ) if ( ! cygwinPath ) { return [ ] } return [ { id : 's' , name : 's' , command : path . join ( cygwinPath , 's' , 's' ) , icon : require ( 's' ) , env : { TERM : 's' , } , } ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' import { Injectable } from 's' import { HostAppService , Platform } from 's' import { ShellProvider } from 's' import { Shell } from 's' try { var wnr = require ( 's' ) } catch { } @ Injectable ( ) export class 0 extends ShellProvider { constructor ( private hostApp , ) { super ( ) } async provide ( ) < Shell [ ] > { if ( this . hostApp . platform !== Platform . Windows ) { return [ ] } const cygwinPath = wnr . getRegistryValue ( wnr . HK . LM , 's' , 's' ) if ( ! cygwinPath ) { return [ ] } return [ { id : 's' , name : 's' , command : path . join ( cygwinPath , 's' , 's' ) , icon : require ( 's' ) , env : { TERM : 's' , } , } ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' import { Injectable } from 's' import { HostAppService , Platform } from 's' import { ShellProvider } from 's' import { Shell } from 's' try { var wnr = require ( 's' ) } catch { } @ Injectable ( ) export class GitBashShellProvider extends ShellProvider { constructor ( private hostApp , ) { super ( ) } async provide ( ) < Shell [ ] > { if ( this . hostApp . platform !== Platform . Windows ) { return [ ] } let gitBashPath = wnr . getRegistryValue ( wnr . HK . LM , 's' , 's' ) if ( ! gitBashPath ) { gitBashPath = wnr . getRegistryValue ( wnr . HK . CU , 's' , 's' ) } if ( ! gitBashPath ) { return [ ] } return [ { id : 's' , name : 's' , command : path . join ( gitBashPath , 's' , 's' ) , args : [ 's' , 's' ] , icon : require ( 's' ) , env : { TERM : 's' , } , } ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' import { Injectable } from 's' import { HostAppService , Platform , LogService , Logger } from 's' import { ShellProvider } from 's' import { Shell } from 's' @ Injectable ( ) export class LinuxDefaultShellProvider extends ShellProvider { private logger : Logger constructor ( private hostApp , log , ) { super ( ) this . logger = log . create ( 's' ) } async provide ( ) < Shell [ ] > { if ( this . hostApp . platform !== Platform . Linux ) { return [ ] } const line = ( await fs . readFile ( 's' , { encoding : 's' } ) ) . split ( 's' ) . find ( x => x . startsWith ( `template` ) ) if ( ! line ) { this . logger . warn ( 's' ) return [ { id : 's' , name : 's' , command : 's' , env : { } , } ] } else { return [ { id : 's' , name : 's' , command : line . split ( 's' ) [ 0 ] , args : [ 's' ] , hidden : true , env : { } , } ] } } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O $LogService$ O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { exec } from 's' import { Injectable } from 's' import { HostAppService , Platform } from 's' import { ShellProvider } from 's' import { Shell } from 's' @ Injectable ( ) export class MacOSDefaultShellProvider extends ShellProvider { constructor ( private hostApp , ) { super ( ) } async provide ( ) < Shell [ ] > { if ( this . hostApp . platform !== Platform . macOS ) { return [ ] } const shellEntry = ( await exec ( `template` ) ) [ 0 ] . toString ( ) return [ { id : 's' , name : 's' , command : shellEntry . split ( 's' ) [ 0 ] . trim ( ) , args : [ 's' ] , hidden : true , env : { } , } ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' import slug from 's' import { Injectable } from 's' import { HostAppService , Platform } from 's' import { ShellProvider } from 's' import { Shell } from 's' @ Injectable ( ) export class POSIXShellsProvider extends ShellProvider { constructor ( private hostApp , ) { super ( ) } async provide ( ) < Shell [ ] > { if ( this . hostApp . platform === Platform . Windows ) { return [ ] } return ( await fs . readFile ( 's' , { encoding : 's' } ) ) . split ( 's' ) . map ( x => x . trim ( ) ) . filter ( x => x && ! x . startsWith ( 's' ) ) . map ( x => ( { id : slug ( x ) , name : x . split ( 's' ) [ 0 ] , command : x , args : [ 's' ] , env : { } , } ) ) } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { HostAppService , Platform } from 's' import { ShellProvider } from 's' import { Shell } from 's' try { var wnr = require ( 's' ) } catch { } @ Injectable ( ) export class PowerShellCoreShellProvider extends ShellProvider { constructor ( private hostApp , ) { super ( ) } async provide ( ) < Shell [ ] > { if ( this . hostApp . platform !== Platform . Windows ) { return [ ] } const pwshPath = wnr . getRegistryValue ( wnr . HK . LM , 's' , 's' ) if ( ! pwshPath ) { return [ ] } return [ { id : 's' , name : 's' , command : pwshPath , args : [ 's' ] , icon : require ( 's' ) , env : { TERM : 's' , } , } ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' import slug from 's' import { Injectable } from 's' import { HostAppService , Platform } from 's' import { ShellProvider } from 's' import { Shell } from 's' import { isWindowsBuild , WIN_BUILD_WSL_EXE_DISTRO_FLAG } from 's' try { var wnr = require ( 's' ) } catch { } @ Injectable ( ) export class WSLShellProvider extends ShellProvider { constructor ( private hostApp , ) { super ( ) } async provide ( ) < Shell [ ] > { if ( this . hostApp . platform !== Platform . Windows ) { return [ ] } const bashPath = `template` const wslPath = `template` const shells : Shell [ ] = [ { id : 's' , name : 's' , command : wslPath , env : { TERM : 's' , COLORTERM : 's' , } , } ] const lxssPath = 's' const lxss = wnr . getRegistryKey ( wnr . HK . CU , lxssPath ) if ( ! lxss || ! lxss . DefaultDistribution || ! isWindowsBuild ( WIN_BUILD_WSL_EXE_DISTRO_FLAG ) ) { if ( await fs . exists ( bashPath ) ) { return [ { id : 's' , name : 's' , command : bashPath , env : { TERM : 's' , COLORTERM : 's' , } , } ] } else { return [ ] } } for ( const child of wnr . listRegistrySubkeys ( wnr . HK . CU , lxssPath ) as string [ ] ) { const childKey = wnr . getRegistryKey ( wnr . HK . CU , lxssPath + 's' + child ) if ( ! childKey . DistributionName ) { continue } const name = childKey . DistributionName . value shells . push ( { id : `template` , name : `template` , command : wslPath , args : [ 's' , name ] , fsBase : childKey . BasePath . value as string + 's' , env : { TERM : 's' , COLORTERM : 's' , } , } ) } return shells } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as path from 's' import { Injectable } from 's' import { HostAppService , Platform , ElectronService } from 's' import { ShellProvider } from 's' import { Shell } from 's' @ Injectable ( ) export class WindowsStockShellsProvider extends ShellProvider { constructor ( private hostApp , private electron , ) { super ( ) } async provide ( ) < Shell [ ] > { if ( this . hostApp . platform !== Platform . Windows ) { return [ ] } return [ { id : 's' , name : 's' , command : 's' , args : [ 's' , path . join ( path . dirname ( this . electron . app . getPath ( 's' ) ) , 's' , 's' , 's' , `template` , ) , 's' , ] , env : { } , icon : require ( 's' ) , } , { id : 's' , name : 's' , command : 's' , env : { } , icon : require ( 's' ) , } , { id : 's' , name : 's' , command : 's' , args : [ 's' ] , icon : require ( 's' ) , env : { TERM : 's' , } , } , ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $HostAppService$ O O $ElectronService$ O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import { Injectable } from 's' import { HostAppService , Platform } from 's' import { ShellProvider } from 's' import { Shell } from 's' import { WSLShellProvider } from 's' import { PowerShellCoreShellProvider } from 's' import { WindowsStockShellsProvider } from 's' @ Injectable ( ) export class WindowsDefaultShellProvider extends ShellProvider { private providers : ShellProvider [ ] constructor ( psc , wsl , stock , private hostApp , ) { super ( ) this . providers = [ psc , wsl , stock , ] } async provide ( ) < Shell [ ] > { if ( this . hostApp . platform !== Platform . Windows ) { return [ ] } const shellLists = await Promise . all ( this . providers . map ( x => x . provide ( ) ) ) for ( const list of shellLists ) { if ( list . length ) { const shell = list [ list . length - 0 ] return [ { ... shell , id : 's' , name : `template` , hidden : true , env : { } , } ] } } return [ ] } }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $PowerShellCoreShellProvider$ O $WSLShellProvider$ O $WindowsStockShellsProvider$ O O $HostAppService$ O O O O O O O O O O O O O O O O O O O O $Promise$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
import * as fs from 's' import slug from 's' import { NgModule } from 's' import { BrowserModule } from 's' import { FormsModule } from 's' import { NgbModule } from 's' import { ToastrModule } from 's' import TerminusCorePlugin , { HostAppService , ToolbarButtonProvider , TabRecoveryProvider , ConfigProvider , HotkeysService , HotkeyProvider , AppService , ConfigService , TabContextMenuItemProvider } from 's' import { SettingsTabProvider } from 's' import { AppearanceSettingsTabComponent } from 's' import { TerminalTabComponent } from 's' import { ShellSettingsTabComponent } from 's' import { TerminalSettingsTabComponent } from 's' import { ColorPickerComponent } from 's' import { EditProfileModalComponent } from 's' import { EnvironmentEditorComponent } from 's' import { SearchPanelComponent } from 's' import { BaseSession } from 's' import { TerminalFrontendService } from 's' import { TerminalService } from 's' import { DockMenuService } from 's' import { ButtonProvider } from 's' import { RecoveryProvider } from 's' import { TerminalDecorator } from 's' import { TerminalContextMenuItemProvider } from 's' import { TerminalColorSchemeProvider } from 's' import { ShellProvider } from 's' import { TerminalSettingsTabProvider , AppearanceSettingsTabProvider , ShellSettingsTabProvider } from 's' import { PathDropDecorator } from 's' import { TerminalConfigProvider } from 's' import { TerminalHotkeyProvider } from 's' import { HyperColorSchemes } from 's' import { NewTabContextMenu , CopyPasteContextMenu } from 's' import { SaveAsProfileContextMenu } from 's' import { CmderShellProvider } from 's' import { CustomShellProvider } from 's' import { 0 } from 's' import { 0 } from 's' import { GitBashShellProvider } from 's' import { LinuxDefaultShellProvider } from 's' import { MacOSDefaultShellProvider } from 's' import { POSIXShellsProvider } from 's' import { PowerShellCoreShellProvider } from 's' import { WindowsDefaultShellProvider } from 's' import { WindowsStockShellsProvider } from 's' import { WSLShellProvider } from 's' import { hterm } from 's' import { Frontend } from 's' import { HTermFrontend } from 's' import { XTermFrontend , XTermWebGLFrontend } from 's' @ NgModule ( { imports : [ BrowserModule , FormsModule , NgbModule , ToastrModule , TerminusCorePlugin , ] , providers : [ { provide : SettingsTabProvider , useClass : AppearanceSettingsTabProvider , multi : true } , { provide : SettingsTabProvider , useClass : ShellSettingsTabProvider , multi : true } , { provide : SettingsTabProvider , useClass : TerminalSettingsTabProvider , multi : true } , { provide : ToolbarButtonProvider , useClass : ButtonProvider , multi : true } , { provide : TabRecoveryProvider , useClass : RecoveryProvider , multi : true } , { provide : ConfigProvider , useClass : TerminalConfigProvider , multi : true } , { provide : HotkeyProvider , useClass : TerminalHotkeyProvider , multi : true } , { provide : TerminalColorSchemeProvider , useClass : HyperColorSchemes , multi : true } , { provide : TerminalDecorator , useClass : PathDropDecorator , multi : true } , { provide : ShellProvider , useClass : WindowsDefaultShellProvider , multi : true } , { provide : ShellProvider , useClass : MacOSDefaultShellProvider , multi : true } , { provide : ShellProvider , useClass : LinuxDefaultShellProvider , multi : true } , { provide : ShellProvider , useClass : WindowsStockShellsProvider , multi : true } , { provide : ShellProvider , useClass : PowerShellCoreShellProvider , multi : true } , { provide : ShellProvider , useClass : CmderShellProvider , multi : true } , { provide : ShellProvider , useClass : CustomShellProvider , multi : true } , { provide : ShellProvider , useClass : 0 , multi : true } , { provide : ShellProvider , useClass : 0 , multi : true } , { provide : ShellProvider , useClass : GitBashShellProvider , multi : true } , { provide : ShellProvider , useClass : POSIXShellsProvider , multi : true } , { provide : ShellProvider , useClass : WSLShellProvider , multi : true } , { provide : TerminalContextMenuItemProvider , useClass : NewTabContextMenu , multi : true } , { provide : TerminalContextMenuItemProvider , useClass : CopyPasteContextMenu , multi : true } , { provide : TabContextMenuItemProvider , useClass : SaveAsProfileContextMenu , multi : true } , PowerShellCoreShellProvider , WSLShellProvider , WindowsStockShellsProvider , ] , entryComponents : [ TerminalTabComponent , AppearanceSettingsTabComponent , ShellSettingsTabComponent , TerminalSettingsTabComponent , EditProfileModalComponent , ] as any [ ] , declarations : [ ColorPickerComponent , TerminalTabComponent , AppearanceSettingsTabComponent , ShellSettingsTabComponent , TerminalSettingsTabComponent , EditProfileModalComponent , EnvironmentEditorComponent , SearchPanelComponent , ] as any [ ] , exports : [ ColorPickerComponent , EnvironmentEditorComponent , ] , } ) export default class TerminalModule { constructor ( app , config , hotkeys , terminal , hostApp , dockMenu , ) { const events = [ { name : 's' , htermHandler : 's' , } , { name : 's' , htermHandler : 's' , } , ] events . forEach ( ( event ) => { const oldHandler = hterm . hterm . Keyboard . prototype [ event . htermHandler ] hterm . hterm . Keyboard . prototype [ event . htermHandler ] = function ( nativeEvent ) { hotkeys . pushKeystroke ( event . name , nativeEvent ) if ( hotkeys . getCurrentPartiallyMatchedHotkeys ( ) . length === 0 ) { oldHandler . bind ( this ) ( nativeEvent ) } else { nativeEvent . stopPropagation ( ) nativeEvent . preventDefault ( ) } hotkeys . processKeystrokes ( ) hotkeys . emitKeyEvent ( nativeEvent ) } } ) if ( config . store . terminal . autoOpen ) { let argv = require ( 's' ) . remote . process . argv if ( argv [ 0 ] . includes ( 's' ) ) { argv = argv . slice ( 0 ) } if ( require ( 's' ) . parse ( argv . slice ( 0 ) ) . _ [ 0 ] !== 's' ) { app . ready$ . subscribe ( ( ) => { terminal . openTab ( ) } ) } } hotkeys . matchedHotkey . subscribe ( async ( hotkey ) => { if ( hotkey === 's' ) { terminal . openTab ( ) } if ( hotkey === 's' ) { hostApp . newWindow ( ) } if ( hotkey . startsWith ( 's' ) ) { const profiles = await terminal . getProfiles ( ) const profile = profiles . find ( x => slug ( x . name ) . toLowerCase ( ) === hotkey . split ( 's' ) [ 0 ] ) if ( profile ) { terminal . openTabWithOptions ( profile . sessionOptions ) } } } ) hostApp . cliOpenDirectory$ . subscribe ( async directory => { if ( await fs . exists ( directory ) ) { if ( ( await fs . stat ( directory ) ) . isDirectory ( ) ) { terminal . openTab ( undefined , directory ) hostApp . bringToFront ( ) } } } ) hostApp . cliRunCommand$ . subscribe ( async command => { terminal . openTab ( { name : 's' , sessionOptions : { command : command [ 0 ] , args : command . slice ( 0 ) , } , } , null , true ) hostApp . bringToFront ( ) } ) hostApp . cliPaste$ . subscribe ( text => { if ( app . activeTab instanceof TerminalTabComponent && app . activeTab . session ) { app . activeTab . sendInput ( text ) hostApp . bringToFront ( ) } } ) hostApp . cliOpenProfile$ . subscribe ( async profileName => { const profile = config . store . terminal . profiles . find ( x => x . name === profileName ) if ( ! profile ) { console . error ( 's' , profileName , 's' ) return } terminal . openTabWithOptions ( profile . sessionOptions ) hostApp . bringToFront ( ) } ) dockMenu . update ( ) } } export { TerminalService , BaseSession , TerminalTabComponent , TerminalFrontendService , TerminalDecorator , TerminalContextMenuItemProvider , TerminalColorSchemeProvider , ShellProvider } export { Frontend , XTermFrontend , XTermWebGLFrontend , HTermFrontend } export { BaseTerminalTabComponent } from 's' export * from 's' export { TerminalColorScheme as ITerminalColorScheme , Shell as IShell } from 's'	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O $AppService$ O $ConfigService$ O $HotkeysService$ O $TerminalService$ O $HostAppService$ O $DockMenuService$ O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' const path = require ( 's' ) module . exports = { target : 's' , entry : 's' , context : __dirname , devtool : 's' , output : { path : path . resolve ( __dirname , 's' ) , filename : 's' , pathinfo : true , libraryTarget : 's' , devtoolModuleFilenameTemplate : 's' , } , mode : process . env . TERMINUS_DEV ? 's' : 's' , optimization : { minimize : false , } , resolve : { modules : [ 's' , 's' , 's' , 's' , 's' ] . map ( x => path . join ( __dirname , x ) ) , extensions : [ 's' , 's' ] , } , module : { rules : [ { test : "s" , use : { loader : 's' , query : { configFileName : path . resolve ( __dirname , 's' ) , typeRoots : [ path . resolve ( __dirname , 's' ) , path . resolve ( __dirname , 's' ) , ] , paths : { "s" : [ path . resolve ( __dirname , 's' ) ] , "s" : [ path . resolve ( __dirname , 's' ) , path . resolve ( __dirname , 's' ) , ] , } , } , } , } , { test : "s" , use : [ 's' , 's' ] } , { test : "s" , use : [ 's' , 's' , 's' ] } , { test : "s" , use : [ 's' , 's' ] } , { test : "s" , use : [ 's' ] } , { test : "s" , use : { loader : 's' , options : { limit : 0 , } , } , } , ] , } , externals : [ 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , 's' , "s" , "s" , "s" , 's' , "s" , ] , }	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = { ignoreCompilerErrors : true , excludeNotExported : true , excludePrivate : true , excludeExternals : true , mode : 's' }	O O O O O O O O O O O O O O O O O O O O O O O O O O
'js' module . exports = [ require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) , require ( 's' ) , ]	O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O O